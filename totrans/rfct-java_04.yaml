- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: When we talk about refactoring, as we have already mentioned, we essentially
    mean rewriting the code in a better way (where “better” can have various meanings)
    without changing its behavior. This last point is crucial, and we have not yet
    delved deep enough into it. To ensure that the behavior does not change and, in
    general, to approach every refactoring with a high level of confidence, it is
    necessary to be covered by an adequate set of tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论重构时，正如我们已经提到的，我们本质上是指以更好的方式（“更好”可以有各种含义）重写代码，而不改变其行为。这一点至关重要，而我们还没有深入探讨。为了确保行为不会改变，并且通常来说，为了以高水平的信心进行每一次重构，有必要有一套足够的测试来覆盖。
- en: 'It may sound obvious, but a test is nothing more than a way to verify the functionality
    of certain software (whether it is a piece of code, a module, or an entire architecture)
    against a set of requirements. In practice, we’re saying: “*Check that my code,
    given a certain input X, produces a certain output Y*.” It can be much more complex
    than that, but for now, let’s settle with this explanation.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能很显然，但测试不过是一种验证某些软件功能（无论是代码片段、模块还是整个架构）是否符合一系列要求的方式。在实践中，我们说的是：“*检查我的代码，给定输入X，产生输出Y*。”它可能比这更复杂，但为了现在，我们就用这个解释来解决问题。
- en: There can be various types of tests, as well as different approaches to writing
    them, as we will see during the course of this chapter. But before discussing
    the “how,” we will look at why testing is essential, especially when it comes
    to refactoring. Within the context of refactoring, I would say testing is a fundamental
    condition.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有各种类型的测试，以及不同的编写方法，正如我们在本章的进程中将会看到的。但在讨论“如何”之前，我们将探讨为什么测试是必要的，尤其是在重构方面。在重构的背景下，我会说测试是一个基本条件。
- en: Fortunately, there are methodologies and tools that can assist us, such as the
    famous **JUnit framework**. In terms of methodologies, it is certainly worth mentioning
    **Test-Driven Development** (**TDD**), which *serves* refactoring and simultaneously
    *uses* refactoring – you will see what I mean by this somewhat cryptic statement.
    But to be truly safe, it is also necessary to ensure that most of the implemented
    functionalities have been rigorously tested; also, for this, we have tools that
    can save us quite a bit of headaches.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些方法和工具可以帮助我们，比如著名的**JUnit框架**。在方法方面，当然值得提到**测试驱动开发**（**TDD**），它**服务于**重构，同时**使用**重构——你将会明白我为什么说这句话有点晦涩。但为了真正安全，还必须确保大多数实现的功能都经过了严格的测试；为此，我们也有工具可以节省我们不少麻烦。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why you should test, and why you should do it often
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该测试，以及为什么你应该经常进行测试
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Contract testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同测试
- en: Be safe – checking and improving your test coverage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保安全——检查和改进你的测试覆盖率
- en: Test-driven development
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Before anything else, however, as a famous book by Simon Sinek suggests, let’s
    start with “why.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在所有事情之前，正如西蒙·辛克的一本著名书籍所建议的，让我们从“为什么”开始。
- en: Why you should test (often)
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你应该经常进行测试
- en: As already mentioned, testing is a fundamental part of the work of a software
    engineer. It is a statement that we can all agree on – I would say it is almost
    intuitive – but let’s try to dig a little deeper and truly understand why it is
    essential to test our code (and our code interacting with other code and systems).
    The reasons I am about to present are not necessarily listed in order of importance,
    and they may not be the only ones. I am sharing what, in my experience, has been
    significant.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试是软件工程师工作的一个基本部分。这是我们都可以同意的——我会说这几乎是直观的——但让我们试着深入挖掘，真正理解为什么测试我们的代码（以及我们的代码与其他代码和系统交互）是至关重要的。我即将提出的理由不一定按照重要性排序，它们可能不是唯一的。我在分享在我经验中被认为是重要的东西。
- en: Identifying and fixing defects
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别和修复缺陷
- en: Let’s start with the most obvious motivation. Testing your software allows you
    to identify defects (bugs), errors, and faults. In this regard, we have included
    an article in the *Further reading* section that explains the differences between
    these terms, which are often used interchangeably. These issues can manifest in
    various forms, such as functional flaws, performance bottlenecks, security vulnerabilities,
    or usability problems. When left unresolved, these problems can have severe consequences,
    leading to system failures, data breaches, dissatisfied users, and costly rework.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最明显的动机开始。测试你的软件可以让你识别缺陷（错误）、错误和故障。在这方面，我们在“进一步阅读”部分包含了一篇文章，解释了这些术语之间的区别，这些术语经常被互换使用。这些问题可以以各种形式出现，如功能缺陷、性能瓶颈、安全漏洞或可用性问题。如果这些问题未得到解决，可能会产生严重后果，导致系统故障、数据泄露、用户不满和昂贵的返工。
- en: By conducting comprehensive testing throughout the development cycle, developers
    can detect and address these issues early on. This proactive approach to testing
    allows them to pinpoint and rectify potential problems before they escalate into
    more significant issues, thereby minimizing the risk of critical defects in the
    final product.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在整个开发周期中进行全面的测试，开发者可以早期检测和解决这些问题。这种主动的测试方法允许他们在问题升级为更严重的问题之前，确定并纠正潜在问题，从而最大限度地减少最终产品中关键缺陷的风险。
- en: One of the primary benefits of early bug identification and resolution is the
    prevention of downstream complications. As the development progresses, the complexity
    of the software typically increases, making it more challenging to identify and
    fix defects. Bugs that go unnoticed in the initial stages can compound as new
    features are added, resulting in a cascade of interconnected problems that are
    difficult and time-consuming to resolve.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 早期识别和解决错误的一个主要好处是预防下游的复杂问题。随着开发的进行，软件的复杂性通常会增加，这使得识别和修复缺陷变得更加具有挑战性。在初始阶段未被注意到的错误，随着新功能的添加可能会累积，导致一系列相互关联的问题，这些问题难以解决且耗时。
- en: Moreover, addressing bugs at later stages of development – or, worse, after
    the software is released – can significantly impact the project’s timeline and
    budget. The cost of fixing defects in the production phase is usually much higher
    than resolving them during the development phase. Additionally, urgent bug fixes
    might necessitate disrupting regular development activities, leading to delays
    in delivering new features or updates (I can already see you nodding and sighing).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在开发的后期阶段或更糟糕的是在软件发布后解决错误，可能会显著影响项目的进度和预算。在生产阶段修复缺陷的成本通常远高于开发阶段。此外，紧急的错误修复可能需要中断常规的开发活动，导致交付新功能或更新的延迟（我都能看到你点头和叹气）。
- en: In brief, the more you test and the earlier you do so (that is, test small chunks
    of software while you’re writing it – we’ll see in a moment how we can be helped
    in such an activity), the better it is. Thinking a bit more laterally, anticipating
    potential issues brings both financial benefits (cost-effectiveness) and risk
    mitigation, especially in the case of software where even small defects can lead
    to significant damages (consider, for example, sectors such as healthcare, finance,
    or the aerospace industry).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，测试越多，越早进行（也就是说，在编写软件的同时测试小块软件——我们稍后会看到我们如何在这种活动中得到帮助），效果越好。稍微横向思考一下，预测潜在问题既带来财务效益（成本效益），又降低风险，尤其是在软件领域，即使是微小的缺陷也可能导致重大损害（例如，考虑医疗保健、金融或航空航天等行业）。
- en: Ensuring quality and reliability
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保质量和可靠性
- en: Testing is a critical aspect of the software development process that goes beyond
    simply identifying bugs and defects. It involves a systematic and comprehensive
    examination of the software to ensure that it meets the required quality standards
    and performs as expected. This process is essential to deliver a reliable, stable,
    and high-quality product that meets the needs and expectations of its users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发过程中的一个关键方面，它不仅限于简单地识别错误和缺陷。它涉及对软件进行系统性和全面的检查，以确保它符合所需的质量标准并按预期运行。这个过程对于交付可靠、稳定和高质量的产品，满足用户的需求和期望至关重要。
- en: When software undergoes thorough testing, it is placed under rigorous scrutiny
    across various dimensions. **Functional testing** verifies that the software’s
    features and functionalities behave correctly and in accordance with the specified
    requirements. **Non-functional testing**, on the other hand, evaluates aspects
    such as performance, security, usability, and compatibility to ensure that the
    software meets the expected levels in these areas.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件经过彻底测试时，它将在各个维度上受到严格的审查。**功能测试**验证软件的功能和特性是否正确运行，并符合指定的要求。另一方面，**非功能测试**评估性能、安全性、可用性和兼容性等方面，以确保软件在这些领域达到预期的水平。
- en: By subjecting the software to a suite of tests, developers can have confidence
    that the application will operate smoothly under normal conditions and handle
    challenging scenarios without unexpected crashes or malfunctions. This is especially
    crucial in mission-critical systems where any unforeseen issues could have severe
    consequences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对软件进行一系列测试，开发者可以确信应用程序在正常条件下能够平稳运行，并且能够处理具有挑战性的场景而不会出现意外的崩溃或故障。这在关键任务系统中尤为重要，因为任何不可预见的问题都可能导致严重后果。
- en: 'When talking about quality and reliability, it is worth defining some terms
    that I often hear being used – and I sometimes use myself – incorrectly. Let’s
    define what performance tests, load tests, and stress tests are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到质量和可靠性时，值得定义一些我经常听到被错误使用——有时我自己也使用——的术语。让我们定义一下性能测试、负载测试和压力测试是什么：
- en: '**Performance tests**: These are tests designed to assess the speed, responsiveness,
    and overall efficiency of a system or software under specific conditions. They
    aim to evaluate how well the system performs in normal situations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：这些测试旨在评估系统或软件在特定条件下的速度、响应性和整体效率。它们旨在评估系统在正常情况下的表现。'
- en: '**Load tests**: Load tests are conducted to evaluate how well a system can
    handle a specific amount of load or user activity. The objective is to determine
    the system’s capacity and identify any performance bottlenecks under anticipated
    loads. They are a subset of performance tests.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：负载测试是为了评估系统处理特定负载或用户活动的能力。目标是确定系统的容量并识别在预期负载下的任何性能瓶颈。它们是性能测试的一个子集。'
- en: '**Stress tests**: Stress tests involve pushing the system or software beyond
    its normal operating limits. The purpose is to check how the system behaves under
    extreme conditions, such as high user traffic, excessive data volumes, or limited
    resources. The goal is to identify potential weaknesses or failures in the system’s
    stability and resilience. Stress tests are also used for sizing environments (e.g.,
    you need to set up a new tier, and you know in advance how many resources you
    will need) or simply to know what the limit is, so you know in advance if and
    when to scale.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：压力测试涉及将系统或软件推到其正常操作极限之外。目的是检查系统在极端条件下的表现，例如高用户流量、大量数据或资源有限。目标是识别系统稳定性和弹性的潜在弱点或故障。压力测试还用于确定环境规模（例如，你需要设置一个新的层级，并且事先知道你需要多少资源）或简单地了解极限在哪里，以便提前知道何时以及如何扩展。'
- en: There is a very common tool, used for performance testing, which you probably
    know, called `jmeter-java-dsl`, you have the option to write your performance
    tests in Java, taking advantage of IDEs’ autocompletion and inline documentation.
    To get started, you can find a good resource in the *Further* *reading* section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常常见的工具，用于性能测试，你可能知道，叫做`jmeter-java-dsl`，你可以选择用Java编写性能测试，利用IDE的自动完成和内联文档。要开始，你可以在*进一步阅读*部分找到一个很好的资源。
- en: While JMeter remains one of the popular load-testing tools, scaling it for a
    large, distributed test can be somewhat challenging, particularly when dealing
    with multiple machines that require intricate configurations to communicate effectively.
    Additionally, executing large JMeter tests may lead to a range of orchestrating
    issues.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JMeter 仍然是流行的负载测试工具之一，但将其扩展到大型、分布式测试可能有些挑战，尤其是在处理需要复杂配置以有效通信的多台机器时。此外，执行大型
    JMeter 测试可能会导致一系列编排问题。
- en: Customer satisfaction
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户满意度
- en: Customer satisfaction is the level of contentment customers feel after using
    a product or service, based on their perceptions and expectations. It’s a critical
    indicator of business success, impacting loyalty and reputation. There are many
    ways to measure it; jump to the *Further reading* section if you’d like to learn
    more.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户满意度是指客户在使用产品或服务后根据他们的感知和期望所感受到的满意程度。它是衡量商业成功的关键指标，影响忠诚度和声誉。有许多方法可以衡量它；如果您想了解更多信息，请跳转到*进一步阅读*部分。
- en: High-quality software that undergoes rigorous testing not only ensures its reliability
    but also increases the likelihood of meeting the needs and expectations of its
    users. When customers find the software to be efficient, stable, and bug-free,
    they are more likely to be satisfied with their experience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 经过严格测试的高质量软件不仅确保其可靠性，还增加了满足用户需求和期望的可能性。当客户发现软件高效、稳定且无错误时，他们更有可能对他们的体验感到满意。
- en: Satisfied customers tend to build a sense of trust and loyalty toward the product
    and the company behind it. They are more inclined to continue using the software
    for extended periods, fostering long-term engagement and loyalty. Moreover, happy
    customers often become advocates for the product, enthusiastically recommending
    it to their peers, friends, and colleagues.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 满意的客户往往会对产品及其背后的公司产生信任和忠诚感。他们更倾向于长期使用该软件，从而培养长期参与和忠诚度。此外，快乐的客户常常成为产品的倡导者，热情地向他们的同行、朋友和同事推荐。
- en: Word-of-mouth referrals from satisfied users can be a powerful driver for the
    software’s success. Positive recommendations can significantly expand the software’s
    user base, leading to increased adoption rates and potential revenue growth for
    the company.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 满意用户的口碑推荐可以是软件成功的一个强大推动力。积极的推荐可以显著扩大软件的用户基础，导致公司采用率的增加和潜在收入的增长。
- en: Compliance and standards
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合规性和标准
- en: In certain industries, such as healthcare, finance, and aerospace, the software
    used plays a critical role in the safety, security, and well-being of individuals
    and organizations. Due to the high stakes involved, these industries are subject
    to strict regulations and standards that software must adhere to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些行业，如医疗保健、金融和航空航天，所使用的软件在个人和组织的安全、安全和福祉中起着关键作用。由于涉及的高风险，这些行业受到严格的法规和标准的约束，软件必须遵守。
- en: In healthcare, for example, software for medical devices and health management
    must meet strict regulations set by authorities such as the FDA and EMA to ensure
    patient safety. The financial industry relies on software to handle critical tasks,
    and compliance with SEC and FCA standards is vital to protect consumers from fraud
    and data breaches. Similarly, aerospace software must adhere to FAA and EASA standards
    to ensure passenger safety and avoid accidents or operational disruptions. Non-compliance
    can have severe consequences for all these sectors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在医疗保健领域，医疗设备和健康管理软件必须符合FDA和EMA等机构设定的严格规定，以确保患者安全。金融行业依赖软件处理关键任务，遵守SEC和FCA标准对于保护消费者免受欺诈和数据泄露至关重要。同样，航空航天软件必须遵守FAA和EASA标准，以确保乘客安全并避免事故或运营中断。不遵守规定可能对所有这些行业产生严重后果。
- en: Testing helps identify and address potential issues, vulnerabilities, and defects
    that could compromise the software’s performance, security, or compliance. By
    conducting deep testing, organizations can avoid legal and financial consequences
    that may arise from non-compliance with industry regulations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有助于识别和解决可能损害软件性能、安全或合规性的潜在问题、漏洞和缺陷。通过进行深入测试，组织可以避免因不遵守行业规定而产生的法律和财务后果。
- en: Security
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全
- en: In today’s digital landscape, where cyber threats and attacks are becoming increasingly
    sophisticated, it is imperative to fortify software systems against potential
    security breaches.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的数字环境中，网络威胁和攻击变得越来越复杂，加强软件系统以抵御潜在的安全漏洞至关重要。
- en: During the testing process, security experts and testers employ various methodologies
    and tools to simulate real-world attack scenarios, attempting to exploit weaknesses
    in the software’s defenses. This includes techniques such as penetration testing,
    where testers try to gain unauthorized access to the system, and vulnerability
    assessments, which identify potential areas of weakness.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，安全专家和测试人员采用各种方法和工具来模拟现实世界的攻击场景，试图利用软件防御中的弱点。这包括渗透测试，测试人员试图未经授权访问系统，以及漏洞评估，识别潜在的弱点区域。
- en: By conducting such tests, developers can proactively identify and address security
    flaws before the software is deployed to the production environment. This proactive
    approach significantly reduces the risk of potential security breaches that could
    lead to data breaches, unauthorized access, or service disruptions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行此类测试，开发人员可以主动识别并解决在软件部署到生产环境之前的安全漏洞。这种主动方法显著降低了可能导致数据泄露、未经授权的访问或服务中断的潜在安全漏洞风险。
- en: 'Here are some suggestions to effectively integrate security testing into the
    **Software Development Life Cycle** (**SDLC**); these are just a few ideas, based
    on what we have encountered in experience, and we suggest you look deeper into
    each point if it piques your interest:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些建议，以有效地将安全测试集成到**软件开发生命周期（SDLC**）中；这些只是一些基于我们经验中遇到的想法，如果您对此感兴趣，我们建议您深入了解每个点：
- en: '**Create security requirements specific to your application**: Ensure these
    requirements align with industry standards and compliance regulations.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建针对您应用程序的安全需求**：确保这些需求与行业标准及合规性规定相一致。'
- en: '**Training and awareness**: Train developers and the development team on secure
    coding practices, fostering a security-aware culture within your organization.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**培训和意识提升**：对开发人员和开发团队进行安全编码实践的培训，培养组织内部的安全意识文化。'
- en: '**Dependency scanning**: Regularly scan third-party dependencies for known
    vulnerabilities. Implement or use automated tools that can alert you when a dependency
    has a security issue.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项扫描**：定期扫描第三方依赖项中的已知漏洞。实施或使用能够提醒您依赖项存在安全问题的自动化工具。'
- en: '**Penetration testing**: Conduct penetration testing to simulate real-world
    attacks. Test the application from an attacker’s perspective to identify vulnerabilities
    that automated tools might miss.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渗透测试**：进行渗透测试以模拟现实世界的攻击。从攻击者的角度测试应用程序，以识别自动化工具可能遗漏的漏洞。'
- en: These are just some of the measures we’ve seen implemented in companies, usually
    large companies that have dedicated teams. These activities are not only time-consuming
    but also very complex and require specific skills.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们在公司（通常是拥有专门团队的大型公司）中看到的一些实施措施。这些活动不仅耗时，而且非常复杂，需要特定的技能。
- en: Integration and compatibility
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成和兼容性
- en: Testing plays a crucial role in verifying the seamless integration and compatibility
    of software with other components or systems. In today’s complex technological
    landscape, software rarely operates in isolation; it often interacts with various
    hardware, software modules, databases, APIs, and external systems. Ensuring that
    all these pieces work harmoniously together is essential for the overall success
    and efficiency of the application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在验证软件与其他组件或系统无缝集成和兼容性方面发挥着关键作用。在当今复杂的技术环境中，软件很少独立运行；它通常与各种硬件、软件模块、数据库、API和外部系统交互。确保所有这些部件协同工作对于应用程序的整体成功和效率至关重要。
- en: One of the primary testing methodologies used to assess integration and compatibility
    is **integration testing**. This type of testing focuses on evaluating how different
    modules or components of the software interact and exchange data with each other.
    We’ll deep dive into this topic in a dedicated section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 评估集成和兼容性的主要测试方法之一是**集成测试**。此类测试侧重于评估软件的不同模块或组件之间如何相互交互和交换数据。我们将在专门的章节中深入探讨这个话题。
- en: '**Compatibility testing** is another vital aspect of the testing process. With
    the wide variety of devices, operating systems, web browsers, and configurations
    available, it is essential to validate that the software functions correctly across
    different environments. Compatibility testing involves testing the software on
    various platforms to ensure that it behaves consistently and uniformly across
    all of them.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**兼容性测试**是测试过程中的另一个重要方面。鉴于各种设备、操作系统、网络浏览器和配置的广泛性，验证软件在不同环境中正确运行至关重要。兼容性测试包括在多种平台上测试软件，以确保它在所有环境中表现一致和统一。'
- en: By conducting compatibility testing, developers can identify platform-specific
    issues and make necessary adjustments to the software. This not only improves
    the user experience but also expands the potential user base, as a broader range
    of users can access and use the software without encountering compatibility-related
    problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行兼容性测试，开发者可以识别特定平台的问题并对软件进行必要的调整。这不仅提高了用户体验，还扩大了潜在的用户群，因为更广泛的用户可以在不遇到兼容性问题的情况下访问和使用该软件。
- en: Integration and compatibility issues can arise at different stages of software
    development, from the initial design to the final implementation. By incorporating
    testing throughout the development process, developers can proactively address
    these challenges, reducing the likelihood of integration bottlenecks (that is,
    a point in a system where the flow of data or functionality between different
    components is restricted, causing delays or inefficiencies) or compatibility conflicts
    in the later stages of the project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 集成和兼容性问题可能在软件开发的各个阶段出现，从最初的设计到最终的实现。通过在整个开发过程中融入测试，开发者可以主动应对这些挑战，降低项目后期出现集成瓶颈（即在系统中数据或功能在不同组件之间流动受限的点，导致延误或低效）或兼容性冲突的可能性。
- en: Confidence and peace of mind
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信心和安心
- en: It might sound strange, but rigorous testing of our software allows us to sleep
    more peacefully, and that is not a trivial matter. Let me explain further. If
    every time we release a new version of our software, we know that it has been
    well tested and we are confident in its proper functioning, this increases the
    team’s self-confidence and, ultimately, we work better, which is undoubtedly a
    benefit for everyone. When we work better, we become more productive and produce
    something of higher quality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有些奇怪，但对我们软件的严格测试使我们能够更安心地入睡，这不是一件小事。让我进一步解释。如果我们每次发布软件的新版本时都知道它已经经过良好的测试，并且我们对它的正常功能有信心，这将提高团队的自信心，最终我们工作得更好，这对每个人无疑都是一种好处。当我们工作得更好时，我们变得更有效率，创造出更高品质的产品。
- en: Furthermore, I must add that many developers don’t enjoy working on bugs, especially
    when they are complex to identify and resolve. Bug-fixing is time-consuming and
    often difficult to predict. As already mentioned, it takes time away from the
    team’s core activities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我必须补充说，许多开发者不喜欢处理错误，尤其是当它们难以识别和解决时。修复错误耗时且往往难以预测。如前所述，这会占用团队核心活动的时间。
- en: That’s why it’s essential for developers to care about testing; it’s not only
    crucial in itself but also affects people’s well-being in some way. The primary
    goal (before clean code and refactoring – which cannot be safely done without
    a proper battery of tests) of developers must be that their software is adequately
    and automatically tested every time a change is made. The first and most immediate
    way to perform automatic tests is to write so-called “unit tests”; in Java, the
    most widely used framework for this is undoubtedly JUnit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，开发者关注测试至关重要；它本身至关重要，而且在某种程度上也影响着人们的福祉。开发者的主要目标（在编写干净代码和重构之前——这不能在没有适当的一套测试的情况下安全进行）必须是每次进行更改时，他们的软件都得到充分和自动的测试。执行自动测试的第一种也是最快的方式是编写所谓的“单元测试”；在Java中，用于此目的最广泛使用的框架无疑是JUnit。
- en: Unit testing
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit testing** is a type of software testing where individual units or components
    of a software application are tested in isolation to ensure they function correctly.
    A *unit* typically refers to the smallest testable part of the software, such
    as a function, method, or class. The main goal of unit testing is to validate
    that each unit of the software works as expected and produces the correct output
    for a given input. By testing units independently, developers can identify and
    fix bugs or issues in the early stages of development, making it easier to maintain
    and improve (hence, to refactor) the code base.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是一种软件测试类型，其中软件应用的各个单元或组件在隔离状态下进行测试，以确保它们能正确运行。*单元*通常指软件中最小的可测试部分，例如函数、方法或类。单元测试的主要目标是验证每个软件单元按预期工作并产生给定输入的正确输出。通过独立测试单元，开发者可以在开发早期阶段识别和修复错误或问题，这使得维护和改进（即重构）代码库变得更加容易。'
- en: 'There are several benefits to adopting unit testing, some of which are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 采用单元测试的好处有很多，以下是一些：
- en: '**Velocity**: Unit tests are fast! They focus on testing small, isolated units
    of code, typically individual functions or methods, in isolation from the rest
    of the system. This isolation allows unit tests to execute quickly because they
    don’t rely on external dependencies or perform complex setup and teardown processes.
    This helps developers to run them often and get quick feedback.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：单元测试非常快！它们专注于测试小型、隔离的代码单元，通常是单个函数或方法，与系统其他部分隔离。这种隔离使得单元测试可以快速执行，因为它们不依赖于外部依赖或执行复杂的设置和拆卸过程。这有助于开发者频繁运行它们并获得快速反馈。'
- en: '**Isolation**: Each unit test is designed to run independently of the rest
    of the application. This isolation ensures that if a test fails, the cause is
    likely within the specific unit being tested, making it easier to pinpoint and
    fix the issue.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：每个单元测试都是设计为独立于应用程序的其他部分运行的。这种隔离确保如果测试失败，原因很可能在于正在测试的特定单元中，这使得定位和修复问题变得更加容易。'
- en: '**Automation**: Unit tests are usually automated, meaning they can be run automatically
    and regularly as part of the development process. This automation helps ensure
    that new code changes don’t introduce regressions or break existing functionality.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：单元测试通常是自动化的，这意味着它们可以作为开发过程的一部分自动和定期运行。这种自动化有助于确保新的代码更改不会引入回归或破坏现有功能。'
- en: '**Early detection of issues**: Unit testing facilitates the early detection
    of defects, which can significantly reduce the cost and effort required for debugging
    and maintenance later in the development cycle.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期问题检测**：单元测试促进了缺陷的早期检测，这可以显著减少在开发周期后期进行调试和维护所需的成本和努力。'
- en: '**Documentation**: Unit tests serve as living documentation, providing examples
    of how units are expected to behave. Developers can refer to these tests to understand
    the intended functionality of a unit and its possible edge cases. This is crucial;
    a well-written unit test can be better than 10 pages of documentation.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：单元测试充当活文档，提供单元预期行为的示例。开发者可以参考这些测试来了解单元的预期功能及其可能的边缘情况。这是至关重要的；一个编写良好的单元测试可能比10页文档更有价值。'
- en: '**Refactoring support**: Of course, that’s why we’re talking about tests in
    this book! When refactoring code, unit tests act as a safety net. If the refactored
    code breaks any functionality, the unit tests will catch it, helping ensure the
    changes do not introduce bugs.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：当然，这就是我们在这本书中讨论测试的原因！在重构代码时，单元测试充当安全网。如果重构后的代码破坏了任何功能，单元测试会捕捉到它，帮助确保更改不会引入错误。'
- en: In practice, in a unit test, nothing else is done except executing a certain
    portion of code (for example, a method) and verifying that, starting from a specific
    input, the same output is always produced. Easy, right? Well, not always, and
    soon we’ll see why.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，在单元测试中，除了执行特定部分的代码（例如，一个方法）并验证从特定输入开始，总是产生相同的输出之外，没有做其他任何事情。简单，对吧？嗯，并不总是这样，很快我们就会看到原因。
- en: 'To test our unit, we will write – in fact – a Java class with several methods
    (each of which is a unit test) that will test the various functionalities. It
    is always advisable to be organized even in the design of test classes; by convention,
    to test, for example, the `com.acme.demo.MyClass` class, we will create a class
    called `com.acme.demo.MyClassTest`. The former will be placed under the `main`
    folder, while the latter will be under the `test` folder. Inside each unit test,
    it is advisable to follow a fairly established pattern, called **AAA**, or the
    three As:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的单元，我们将编写一个Java类，其中包含几个方法（每个方法都是一个单元测试），以测试各种功能。即使在测试类的设计中，保持组织性也是始终建议的；按照惯例，例如，为了测试`com.acme.demo.MyClass`类，我们将创建一个名为`com.acme.demo.MyClassTest`的类。前者将放置在`main`文件夹下，而后者将放置在`test`文件夹下。在每个单元测试中，建议遵循一个相当固定的模式，称为**AAA**，或三个A：
- en: '**Arrange**: This phase involves preparing the objects that will be subjected
    to testing. During this phase, you establish the desired condition of the system
    under test and set up its dependencies. This can involve directly creating instances
    of the necessary objects or getting them ready by creating their test counterparts.
    This may include initializing resources (collaborators) needed for the class under
    test, and so on.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排（Arrange）**：这个阶段涉及准备将被测试的对象。在这个阶段，你建立被测试系统的期望条件并设置其依赖项。这可能包括直接创建必要对象的实例，或者通过创建它们的测试对应物来准备它们。这可能包括初始化被测试类所需的资源（协作者）等。'
- en: '**Act**: This is where you interact with the system under test. In this phase,
    you invoke one of its methods, providing any required dependencies, and capturing
    any resulting output values if applicable.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动（Act）**：这是与被测试的系统交互的地方。在这个阶段，你调用其一个方法，提供任何所需的依赖项，并捕获任何相关的输出值（如果适用）。'
- en: '**Assert**: This is where you check Boolean expressions (assertions) that must
    be true if the test is successful; that is, the observed output data and/or post-conditions
    are different from the expected ones. Sometimes, it is not only the output that
    is evaluated, but it is also possible to verify the method’s execution flow by
    making assertions regarding whether a certain component – present *inside* the
    class under test – has been called, how many times, and with what input.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言（Assert）**：这是检查测试成功时必须为真的布尔表达式（断言）的地方；也就是说，观察到的输出数据和/或后置条件与预期的不一样。有时，不仅评估输出，还可以通过关于某个组件（存在于被测试类的**内部**）是否被调用、调用了多少次以及使用什么输入的断言来验证方法的执行流程。'
- en: 'Let’s go through a trivial example. Let’s suppose we have a `Calculator` class,
    which has a method that takes two integers and returns their sum (I said it was
    trivial!):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来了解一下。假设我们有一个`Calculator`类，它有一个方法，接受两个整数并返回它们的和（我说的是很简单！）：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s now write a test class for `Calculator`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来为`Calculator`编写一个测试类：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we have created a test method called `testAddition`. The test
    method creates an instance of the `Calculator` class, calls `testAddition` with
    a specific input, and then compares the result with the expected output. When
    you run the `CalculatorTest` class, it will output whether the test has passed
    or failed based on the comparison of the actual results and expected results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`testAddition`的测试方法。测试方法创建了一个`Calculator`类的实例，使用特定的输入调用`testAddition`，然后比较结果与预期输出。当你运行`CalculatorTest`类时，它将根据实际结果与预期结果的比较输出测试是否通过或失败。
- en: Keep in mind that this is just a basic example to demonstrate how unit tests
    can be written without using a testing framework such as JUnit. In real-world
    scenarios, using a testing framework such as JUnit provides many additional features
    and benefits, such as easier test organization, assertions, test reporting, and
    integration with build tools and CI/CD pipelines.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个基本的例子，用于展示如何在不使用JUnit等测试框架的情况下编写单元测试。在实际场景中，使用JUnit等测试框架提供了许多额外的功能和好处，例如更易于测试组织、断言、测试报告以及与构建工具和CI/CD管道的集成。
- en: JUnit framework
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JUnit框架
- en: JUnit is a popular testing framework for Java that is primarily used to perform
    unit testing of Java applications. It provides a set of annotations, assertions,
    and test runners that make writing and executing tests easier and more organized.
    JUnit is widely used in the Java development community and has become a standard
    for writing unit tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是一个流行的Java测试框架，主要用于执行Java应用程序的单元测试。它提供了一套注解、断言和测试运行器，使得编写和执行测试更加容易和有组织。JUnit在Java开发社区中广泛使用，并已成为编写单元测试的标准。
- en: 'Here are some key features and concepts of JUnit:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是JUnit的一些关键特性和概念：
- en: '`@Test`, `@Before`, `@After`, `@BeforeClass`, and `@AfterClass`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Test`、`@Before`、`@After`、`@BeforeClass`和`@AfterClass`。'
- en: '`@Test` and are responsible for verifying specific functionality in the code
    being tested. Each test method should be independent and focus on testing a specific
    part of the code base.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Test`负责验证代码中被测试的特定功能。每个测试方法应该是独立的，并专注于测试代码库的特定部分。'
- en: '`@Before` and `@After` annotations are used to mark methods that will be executed
    before and after each test method. They are used for setting up the test environment
    (e.g., initializing objects) and cleaning up resources after each test.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before`和`@After`注解用于标记在每个测试方法之前和之后执行的方法。它们用于设置测试环境（例如，初始化对象）并在每次测试后清理资源。'
- en: '`BlockJUnit4ClassRunner`, but `org.junit.platform.runner.JUnitPlatform`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockJUnit4ClassRunner`，但使用`org.junit.platform.runner.JUnitPlatform`。'
- en: '`assertEquals`, `assertTrue`, `assertFalse`, etc.) to perform various types
    of assertions to check the expected outcomes of the tests.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`assertEquals`、`assertTrue`、`assertFalse`等函数执行各种类型的断言，以检查测试的预期结果。
- en: '`@RunWith` and `@``Suite` annotations.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RunWith`和`@Suite`注解。'
- en: '**Parameterized tests**: **JUnit 4** introduced the concept of parameterized
    tests, allowing you to run the same test with multiple sets of data.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数化测试**：**JUnit 4**引入了参数化测试的概念，允许你使用多组数据运行相同的测试。'
- en: JUnit 5 is the next major version of JUnit and introduced several new features
    and improvements over JUnit 4\. It offers a more modular and extensible architecture,
    better support for `@BeforeEach`, `@AfterEach`, and `@DisplayName`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5是JUnit的下一个主要版本，在JUnit 4的基础上引入了几个新功能和改进。它提供了一个更模块化和可扩展的架构，更好地支持`@BeforeEach`、`@AfterEach`和`@DisplayName`。
- en: 'If we wanted to rewrite the `CalculatorTest` class using JUnit, the result
    would be as follows. The example is straightforward, but it helps us understand
    how the framework works:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用JUnit重写`CalculatorTest`类，结果如下。这个例子很简单，但它有助于我们理解框架的工作原理：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can notice the `@Test` annotation, which allows the framework to “understand”
    that that is a unit test. `@DisplayName` is utilized to specify a personalized
    name for the annotated test class or test method; these display names are commonly
    employed for test reporting within IDEs and build tools, and they have the flexibility
    to include spaces, special characters, and emojis.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到`@Test`注解，它允许框架“理解”这是一个单元测试。`@DisplayName`用于指定被注解的测试类或测试方法的个性化名称；这些显示名称通常用于IDE和构建工具中的测试报告，并且它们具有包含空格、特殊字符和表情符号的灵活性。
- en: 'This is how the IntelliJ IDE represents the execution of a successful JUnit
    test:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是IntelliJ IDE如何表示成功JUnit测试的执行：
- en: '![Figure 4.1 – Execution of a successful JUnit test in the IntelliJ IDE](img/B20912_04_1.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – IntelliJ IDE中成功JUnit测试的执行](img/B20912_04_1.jpg)'
- en: Figure 4.1 – Execution of a successful JUnit test in the IntelliJ IDE
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – IntelliJ IDE中成功JUnit测试的执行
- en: Now, it is quite intuitive, I believe, to understand how an automated test suite
    can be integrated into the code development process; frameworks such as JUnit
    help developers test their code, find bugs, and potentially improve performance.
    JUnit (and unit testing in general) reaches its full potential when integrated
    through tools such as **Maven** or **Gradle** (which allow code build management
    and automated test execution) and **Jenkins** or **GitHub**, which handle **Continuous
    Integration** (**CI**), a practice that involves automatically and regularly integrating
    code changes into a shared repository and running automated tests to detect integration
    issues early. CI is a very broad topic, so I refer you to the *Further reading*
    section, where there is a related Wikipedia entry. Unfortunately, it is challenging
    to find *agnostic*, meaning not tied to specific products, material online that
    explains the concepts. I hope this can serve as a starting point and stimulate
    your curiosity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests is hard and complicated, much more than it may seem from
    these few simple examples. It is also a crucial task, essential both for a smooth
    production release and to be able to perform any desired refactoring. One of the
    most challenging aspects is imagining all possible test cases (i.e., all potential
    behaviors of the application, all the “flows” it can follow – think of all the
    `if` statements and polymorphism you have used in your code); fortunately, we
    don’t have to imagine, as we can use tools designed for this purpose.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing involves checking how various pieces, modules, or parts
    of a software application work together, even if different programmers coded them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The goal of integration testing is to examine the connections between these
    modules and uncover any issues that might pop up when these components come together
    and have to work together.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'It is usually performed downstream of unit tests; assuming that individual
    software modules (be they projects, classes, or entire applications) are tested
    individually, we begin to test the interactions they have with other modules with
    which they collaborate, as shown in *Figure 4**.2*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Unit tests concern each module individually, while integration
    tests concern interactions](img/B20912_04_2.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Unit tests concern each module individually, while integration
    tests concern interactions
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: To carry out integration testing, testers use test drivers and *stubs*, that
    is, placeholder programs that step in for any absent modules and mimic data exchange
    between modules for testing. There are several frameworks that can help you along
    the way; you don’t have to do all the work by yourself! The most famous framework
    used to perform integration testing (at least on a basic and widespread level)
    is JUnit (which we just saw) in combination with Mockito.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Mockito
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mockito is a widely used Java-based open source framework for creating and
    configuring mock objects in both unit testing and integration testing. In the
    context of Java software development, Mockito is favored for its ability to facilitate
    testing by creating mock objects that mimic the behavior of real components. These
    mock objects are especially valuable in integration testing for several reasons:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito是一个广泛使用的基于Java的开源框架，用于在单元测试和集成测试中创建和配置模拟对象。在Java软件开发背景下，Mockito因其能够通过创建模拟对象来模拟真实组件的行为，从而促进测试而受到青睐。这些模拟对象在集成测试中特别有价值，原因如下：
- en: 'Firstly, Mockito aids in isolating specific parts of an application. It allows
    developers to create mock objects that simulate the behavior of real components,
    thereby enabling them to test particular modules, components, or services in isolation.
    This isolation is crucial when you want to verify the behavior of a specific part
    of your application without involving the entire system or interacting with real
    dependencies, such as databases, web services, or external APIs. In the following
    code snippet, we can get an idea of how Mockito works:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，Mockito有助于隔离应用程序的特定部分。它允许开发者创建模拟对象来模拟真实组件的行为，从而使得他们能够单独测试特定的模块、组件或服务。这种隔离在你想验证应用程序特定部分的行为而不涉及整个系统或与真实依赖项（如数据库、Web服务或外部API）交互时至关重要。在下面的代码片段中，我们可以了解Mockito是如何工作的：
- en: '[PRE3]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Secondly, Mockito provides control and verification capabilities. Developers
    can define the behavior of mock objects, specify what methods should return, and
    record interactions with these objects during the test. This level of control
    and verification ensures that the component under test correctly interacts with
    its dependencies. To verify something, you just have to write something such as
    the following:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，Mockito提供了控制和验证能力。开发者可以定义模拟对象的行为，指定哪些方法应该返回什么，并在测试期间记录与这些对象的交互。这种控制和验证水平确保了被测试的组件正确地与其依赖项交互。要验证某事，你只需编写如下内容：
- en: '[PRE4]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Additionally, Mockito contributes to the efficiency and speed of integration
    tests. Using real external dependencies in integration tests can be slow and complex
    to set up, and may result in undesirable side effects. In contrast, Mockito’s
    mock objects are lightweight and do not rely on external resources, making integration
    tests faster, more efficient, and less prone to side effects.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，Mockito有助于提高集成测试的效率和速度。在集成测试中使用真实的外部依赖项可能很慢，设置复杂，并可能导致不希望出现的副作用。相比之下，Mockito的模拟对象轻量级且不依赖于外部资源，这使得集成测试更快、更高效，并且不太可能出现副作用。
- en: Lastly, Mockito offers test flexibility. Developers can create customizable
    mock objects that allow them to specify different behaviors for various test cases.
    This flexibility simplifies the simulation of various scenarios in integration
    tests.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Mockito提供了测试灵活性。开发者可以创建可定制的模拟对象，允许他们为不同的测试案例指定不同的行为。这种灵活性简化了集成测试中各种场景的模拟。
- en: We have left some material in the *Further Readings* section to deep dive into
    the magic of Mockito.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*进一步阅读*部分留下了一些材料，以便深入了解Mockito的魔法。
- en: Contract testing
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同测试
- en: We have seen that integration tests are also used to test external services,
    services that are probably not in our code base and that may not even be maintained
    by us. You then create a stub, or mock, that returns a “fake” answer, based on
    documentation or, often, on the real answers exchanged at runtime between the
    two services. But what happens if something changes, if one of the two changes
    the contract? How do you make sure that the mock we’ve created is really a representation
    of the outside service? Contract testing helps us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，集成测试也用于测试外部服务，这些服务可能不在我们的代码库中，甚至可能不是由我们维护。然后你创建一个存根或模拟，返回一个“虚假”的答案，基于文档或，通常是两个服务在运行时交换的真实答案。但如果有什么变化，如果其中之一改变了合同，怎么办？你如何确保我们创建的模拟确实代表了外部服务？合同测试帮助我们。
- en: Contract testing aims to ensure compatibility and agreement between different
    services or components within a distributed system. It is particularly useful
    in scenarios such as microservices architectures where different services need
    to communicate seamlessly. In contract testing, services communicate with each
    other based on well-defined interfaces or contracts. These contracts outline how
    data is exchanged, specify available methods or endpoints, and describe expected
    responses.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 合约测试旨在确保分布式系统中不同服务或组件之间的兼容性和一致性。它在诸如微服务架构等场景中特别有用，在这些场景中，不同的服务需要无缝通信。在合约测试中，服务根据定义良好的接口或合约相互通信。这些合约概述了数据交换的方式，指定了可用的方法或端点，并描述了预期的响应。
- en: 'There are two primary roles in contract testing: consumers and providers. Consumers
    are the services or components that utilize data or functionality from another
    service, known as the provider. Contracts define what the consumer expects from
    the provider; that is why it is said that contract tests are consumer-driven.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 合约测试中有两个主要角色：消费者和提供者。消费者是利用来自另一个服务（称为提供者）的数据或功能的服务或组件。合约定义了消费者从提供者那里期望什么；这就是为什么说合约测试是消费者驱动的。
- en: 'The process starts with the definition of contracts, which can take various
    forms, such as API specifications or interface documentation. Contract testing
    primarily focuses on the consumer’s perspective. Consumer tests are written to
    ensure that the provider’s behavior aligns with the contract. These tests are
    typically managed by the consumer’s team. Provider tests, on the other hand, are
    written by the provider’s team. They verify that the provider complies with the
    contract specifications. Automated contract tests run continuously as part of
    the build and deployment process. They help detect compatibility issues early
    whenever changes occur in either the consumer or provider service. Here is a diagram
    to help understand contract testing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程从定义合约开始，可以采取各种形式，如API规范或接口文档。合约测试主要关注消费者的视角。消费者测试是为了确保提供者的行为与合约一致而编写的。这些测试通常由消费者的团队管理。另一方面，提供者测试是由提供者的团队编写的。它们验证提供者是否符合合约规范。自动合约测试作为构建和部署过程的一部分持续运行。它们有助于在消费者或提供者服务发生更改时及早发现兼容性问题。以下是一个有助于理解合约测试的图表：
- en: '![Figure 4.3 – Contract testing](img/B20912_04_3.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 合约测试](img/B20912_04_3.jpg)'
- en: Figure 4.3 – Contract testing
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 合约测试
- en: Various tools and libraries support contract testing, depending on the project’s
    technology stack and requirements. Some popular options include Pact, Spring Cloud
    Contract, and Pacto.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工具和库支持合约测试，这取决于项目的技术栈和需求。一些流行的选项包括Pact、Spring Cloud Contract和Pacto。
- en: Be safe – checking and improving your test coverage
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保安全 – 检查和改进你的测试覆盖率
- en: Testing is important, but we need to make sure we test our code thoroughly,
    not just a part of it; covering all the code doesn’t only mean all the classes,
    but also all possible execution paths. We might think it’s easy to keep all possible
    cases in mind, and perhaps this is true for very small projects; but as the project
    grows and inevitably becomes more complex (for example, the number of features
    increases or the possible execution paths multiply), it becomes difficult to understand
    the efficiency of our tests for keeping us safe. This is why we introduce the
    concept of test coverage and a tool to measure it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很重要，但我们需要确保我们彻底测试我们的代码，而不仅仅是其中的一部分；覆盖所有代码不仅意味着所有类，还包括所有可能的执行路径。我们可能会认为记住所有可能的案例很容易，也许对于非常小的项目来说这是真的；但随着项目的增长和不可避免地变得更加复杂（例如，功能数量增加或可能的执行路径增多），理解我们的测试在保持安全方面的效率变得困难。这就是为什么我们引入了测试覆盖率和测量它的工具的概念。
- en: What is test coverage?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是测试覆盖率？
- en: '**Test coverage**, also known as **code coverage**, is a metric used to measure
    the extent to which the source code of a program is executed by a set of test
    cases. It is a quantitative measure that helps developers and testers understand
    how much of the code is being exercised during testing.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试覆盖率**，也称为**代码覆盖率**，是一个衡量程序源代码被一组测试用例执行的程度的指标。它是一个定量指标，有助于开发人员和测试人员了解在测试过程中有多少代码被执行。'
- en: Test coverage is usually expressed as a percentage, representing the proportion
    of code lines, branches, statements, or methods that have been executed by the
    test suite compared to the total number of such elements in the code base.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率通常以百分比表示，表示测试套件执行的代码行、分支、语句或方法与代码库中此类元素总数的比例。
- en: 'There are different types of coverage metrics:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着不同类型的覆盖率指标：
- en: '**Line coverage**: This measures the percentage of lines of code that have
    been executed at least once during testing.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行覆盖率**：这衡量了在测试期间至少执行过一次的代码行的百分比。'
- en: '`if` instances in your code) that have been taken or not taken during testing.
    It ensures that both true and false branches of conditional statements are tested.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中，测试期间是否已采取或未采取的`if`实例。它确保了条件语句的真和假分支都被测试。
- en: '**Statement coverage**: This measures the percentage of executable statements
    that have been executed during testing.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句覆盖率**：这衡量了在测试期间执行的可执行语句的百分比。'
- en: '**Method coverage**: Method coverage measures the percentage of methods or
    functions that have been called during testing.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法覆盖率**：方法覆盖率衡量了在测试期间被调用的方法或函数的百分比。'
- en: Test coverage is not a definitive measure of software quality but provides valuable
    insights into the thoroughness of testing efforts. High coverage indicates that
    a significant portion of the code has been tested, increasing confidence in the
    correctness of the application. However, even 100% coverage does not guarantee
    a bug-free application, as it is possible to have untested edge cases or incorrect
    assumptions in the test cases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率并不是软件质量的最终衡量标准，但它提供了对测试工作全面性的宝贵见解。高覆盖率表明代码的大部分已被测试，从而增加了对应用程序正确性的信心。然而，即使达到100%的覆盖率，也不能保证应用程序没有错误，因为测试用例中可能存在未测试的边缘情况或错误的假设。
- en: By improving test coverage, developers can mitigate the risk of undiscovered
    defects and make their code more robust and maintainable. We use code coverage
    tools to generate coverage reports, which can be analyzed to identify areas of
    the code that need more testing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提高测试覆盖率，开发者可以降低未发现缺陷的风险，并使他们的代码更加健壮和易于维护。我们使用代码覆盖率工具生成覆盖率报告，这些报告可以分析以确定需要更多测试的代码区域。
- en: A Java code coverage tool – JaCoCo
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Java代码覆盖率工具 - JaCoCo
- en: '**JaCoCo** (short for **Java Code Coverage**) is a widely used open source
    code coverage library for Java projects. It provides a comprehensive and detailed
    analysis of code coverage, allowing developers to understand how much of their
    Java code is exercised by their tests.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**JaCoCo**（代表**Java 代码覆盖率**）是一个广泛使用的开源Java项目代码覆盖率库。它提供了全面且详细的代码覆盖率分析，使开发者能够了解他们的Java代码中有多少是通过测试执行的。'
- en: JaCoCo offers various types of code coverage analysis, including line coverage,
    branch coverage, and method coverage. It instruments the Java bytecode during
    the build process to collect execution data, which is then used to generate coverage
    reports.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JaCoCo 提供了各种类型的代码覆盖率分析，包括行覆盖率、分支覆盖率和方法覆盖率。它在构建过程中对Java字节码进行插桩以收集执行数据，然后使用这些数据生成覆盖率报告。
- en: 'JaCoCo primarily provides three significant metrics:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JaCoCo 主要提供三个重要的指标：
- en: '**Line coverage** indicates the extent of code that has been executed based
    on the number of Java bytecode instructions called by the tests'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行覆盖率**表示基于测试调用的Java字节码指令数量来衡量已执行的代码范围。'
- en: '`if`/`else` and `switch` statements'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if`/`else` 和 `switch` 语句'
- en: '**Cyclomatic complexity** reflects the code’s complexity by quantifying the
    number of paths required to cover all the possible code paths through a linear
    combination'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**循环复杂度**通过量化通过线性组合覆盖所有可能代码路径所需的路径数量来反映代码的复杂度。'
- en: To illustrate with a simple example, if the code contains no `if` or `switch`
    statements, the cyclomatic complexity will be 1, as only one execution path is
    needed to cover the entire code. In general, the cyclomatic complexity represents
    the number of test cases required to achieve full code coverage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的例子来说明，如果代码中没有`if`或`switch`语句，循环复杂度将是1，因为只需要一个执行路径就可以覆盖整个代码。一般来说，循环复杂度代表实现全面代码覆盖率所需的测试用例数量。
- en: To illustrate how JaCoCo works, let’s start with a very simple example. It is
    not my intention to create a tutorial on this tool here – there are already plenty
    of them online – but I would like to show you its main features so that you can
    get a rough idea of how it works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 JaCoCo 的工作原理，让我们从一个非常简单的例子开始。我的意图并不是在这里创建这个工具的教程 – 网上已经有 plenty of 这样的教程
    – 但我想向您展示它的主要功能，以便您可以大致了解它的工作方式。
- en: 'Let’s suppose we have a project consisting of only one class named `Calculator`,
    defined as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个只包含一个名为 `Calculator` 的类的项目，定义如下：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the `Calculator` class exposes three very simple methods that
    take two integers as input and return, respectively, their sum, difference, and
    product. Let’s proceed to write the corresponding test class, which we will define
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Calculator` 类公开了三个非常简单的方法，它们接受两个整数作为输入，并分别返回它们的和、差和乘积。让我们继续编写相应的测试类，我们将如下定义它：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The test class creates an instance of `Calculator` and then performs two unit
    tests, one for the sum and the other for the difference. Using the JUnit framework,
    we verify that the expected result matches the actual result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类创建一个 `Calculator` 实例，然后执行两个单元测试，一个用于求和，另一个用于求差。使用 JUnit 框架，我们验证预期的结果与实际结果是否匹配。
- en: 'There are many ways to use a tool like JaCoCo, but in my opinion, the best
    approach is to integrate it into the development cycle. Assuming we are using
    Maven, we will configure our `pom.xml` file so that the plugin is executed and
    reports are generated:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 JaCoCo 这样的工具有很多方法，但在我看来，最好的方法是将它集成到开发周期中。假设我们使用 Maven，我们将配置我们的 `pom.xml`
    文件，以便插件被执行并生成报告：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The execution of JaCoCo’s Maven plugin will create a report inside the `target/site`
    folder, which can be easily viewed through any web browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JaCoCo Maven 插件的执行将在 `target/site` 文件夹中创建一个报告，它可以通过任何网络浏览器轻松查看。
- en: '![Figure 4.4 – The mini-website created by JaCoCo shows the test coverage for
    each class](img/B20912_04_4.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – JaCoCo 创建的迷你网站显示了每个类的测试覆盖率](img/B20912_04_4.jpg)'
- en: Figure 4.4 – The mini-website created by JaCoCo shows the test coverage for
    each class
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – JaCoCo 创建的迷你网站显示了每个类的测试覆盖率
- en: 'In this table, we find the only class in our project. We can see from the report
    that the `Calculator` class has `multiply` method. Let’s add a third unit test
    to our test class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，我们找到了我们项目中的唯一一个类。我们可以从报告中看到 `Calculator` 类有一个 `multiply` 方法。让我们向我们的测试类添加第三个单元测试：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, let’s run the JaCoCo Maven plugin again. The report will now look like
    this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们再次运行 JaCoCo Maven 插件。现在报告将看起来像这样：
- en: '![Figure 4.5 – After adding a test case, coverage is now 100%](img/B20912_04_5.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 添加测试用例后，覆盖率现在是 100%](img/B20912_04_5.jpg)'
- en: Figure 4.5 – After adding a test case, coverage is now 100%
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 添加测试用例后，覆盖率现在是 100%
- en: All the methods of `Calculator` have been tested. The coverage is **100%**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`计算器`的所有方法都已测试。覆盖率是**100%**。'
- en: 'What happens if we make changes? Let’s say, for example, we decide not to support
    negative results in the subtraction operation by adding a check that throws an
    exception when the subtrahend (the number that is subtracted from another number)
    is greater than the minuend (the number from which another number is subtracted):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行更改会发生什么？比如说，我们决定不支持减法操作中的负结果，通过添加一个检查来抛出异常，当减数（从另一个数中减去的数）大于被减数（从另一个数中减去的数）时：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we run JaCoCo again, we can notice something very interesting:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行 JaCoCo，我们可以注意到一些非常有趣的事情：
- en: '![Figure 4.6 – By adding a new feature without adding the relative test, the
    coverage decreases](img/B20912_04_6.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 在不添加相关测试的情况下添加新功能，覆盖率降低](img/B20912_04_6.jpg)'
- en: Figure 4.6 – By adding a new feature without adding the relative test, the coverage
    decreases
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 在不添加相关测试的情况下添加新功能，覆盖率降低
- en: The coverage has decreased, and specifically, the `if`-`else` statements and
    `switch`-`case` statements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率已经降低，具体来说，是 `if`-`else` 语句和 `switch`-`case` 语句。
- en: 'We can see which method is affected by clicking on `Calculator`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击 `Calculator` 来查看受影响的方法：
- en: '![Figure 4.7 – By clicking on the Calculator entry, it is clearer which of
    its methods is not fully covered](img/B20912_04_7.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 点击“计算器”条目，可以更清楚地看到其哪些方法没有得到完全覆盖](img/B20912_04_7.jpg)'
- en: Figure 4.7 – By clicking on the Calculator entry, it is clearer which of its
    methods is not fully covered
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 点击“计算器”条目，可以更清楚地看到其哪些方法没有得到完全覆盖
- en: 'We can even click on the method to see which part of the code is not covered:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以点击方法来查看代码的哪些部分没有被覆盖：
- en: '![Figure 4.8 – Clicking on the single method entry, it’s possible to see where
    the test coverage is missing](img/B20912_04_8.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 点击单个方法条目，可以看到测试覆盖率缺失的地方](img/B20912_04_8.jpg)'
- en: Figure 4.8 – Clicking on the single method entry, it’s possible to see where
    the test coverage is missing
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 点击单个方法条目，可以看到测试覆盖率缺失的地方
- en: 'Since we have added an `if` statement, we have created a branch. Whenever a
    branch is created, which represents a new possible execution flow, we must cover
    it with tests. Let’s do this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了一个`if`语句，我们创建了一个分支。每当创建一个分支时，它代表一个新的可能的执行流程，我们必须用测试来覆盖它。让我们这样做：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s regenerate the report to see the changes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新生成报告以查看更改：
- en: '![Figure 4.9 – Again, full coverage](img/B20912_04_9.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 再次，全面覆盖](img/B20912_04_9.jpg)'
- en: Figure 4.9 – Again, full coverage
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 再次，全面覆盖
- en: The coverage is now back to **100%**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在覆盖率回到了**100%**。
- en: This is just the tip of the iceberg. JaCoCo is highly configurable (for example,
    you can configure branches and missed instructions) and can be used to completely
    block the build when a minimum coverage threshold is not met. You can exclude
    individual classes, class patterns, packages, and more. I strongly encourage you
    to explore this tool further.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是冰山一角。JaCoCo高度可配置（例如，您可以配置分支和遗漏的指令）并且可以在未达到最小覆盖率阈值时完全阻止构建。您可以排除单个类、类模式、包等等。我强烈建议您进一步探索这个工具。
- en: Now that we have roughly seen how JaCoCo works and, above all, what test coverage
    is, let’s delve further into our reasoning and try to understand why it is convenient,
    sensible, and extremely advantageous, when developing, not only to write tests
    but also to... start with them!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大致了解了JaCoCo的工作原理，更重要的是，了解了测试覆盖率，让我们进一步深入我们的推理，并试图理解为什么在开发过程中，不仅编写测试，而且从测试开始，是方便的、合理的，并且极为有利！
- en: Test-driven development
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: As the name suggests, **test-driven development**, abbreviated as **TDD**, is
    a widely used software development practice in Agile methodologies, especially
    in **Extreme Programming**. It is widely regarded as a fundamental technique for
    achieving higher-quality software.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**测试驱动开发**，简称**TDD**，是敏捷方法中广泛使用的软件开发实践，尤其是在**极限编程**中。它被广泛认为是实现更高质量软件的基本技术。
- en: 'As the name itself suggests, development is driven by tests, not the other
    way around. The classic development cycle involves the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，开发是由测试驱动的，而不是相反。经典的开发周期包括以下内容：
- en: '![Figure 4.10 – The classic development cycle involves designing, coding, and
    then testing](img/B20912_04_10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 经典的开发周期包括设计、编码然后测试](img/B20912_04_10.jpg)'
- en: Figure 4.10 – The classic development cycle involves designing, coding, and
    then testing
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 经典的开发周期包括设计、编码然后测试
- en: 'This is flipped around. We start with the tests to arrive at defining the design;
    of course, writing the code in between:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是颠倒过来的。我们首先从测试开始，以定义设计；当然，在中间编写代码：
- en: '![Figure 4.11 – The TDD cycle starts with the tests](img/B20912_04_11.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – TDD周期从测试开始](img/B20912_04_11.jpg)'
- en: Figure 4.11 – The TDD cycle starts with the tests
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – TDD周期从测试开始
- en: 'Attention is given to the functional aspects of the code, specifically the
    method signatures, before the actual implementation of the code. To start with
    the tests, you need to take the perspective of the “client” of your code and primarily
    consider the public methods:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码实现之前，关注代码的功能方面，特别是方法签名。要开始测试，您需要从您代码的“客户端”的角度出发，主要考虑公共方法：
- en: The methodology involves immediately writing a test; by executing this test
    (which requires defining an input, invoking a method, and asserting the result),
    the outcome will inevitably be a failure since the implementation does not exist
    yet. This phase is called **Red** (the color that commonly indicates a failure
    of a unit test in many IDEs).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法涉及立即编写一个测试；通过执行这个测试（需要定义输入、调用方法并断言结果），由于实现尚不存在，结果不可避免地会失败。这个阶段被称为**红**（在许多IDE中常用颜色表示单元测试的失败）。
- en: The next step is to implement the missing functionality by writing the bare
    minimum to make the test pass as quickly as possible. When the test passes, you
    are in the so-called **Green** phase. Don’t worry if the code you wrote is not
    perfect or if you think it could be improved; that will be addressed in the next
    phase.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third and final phase of TDD is **Refactor**, which allows you to transform
    your code by adapting, simplifying, streamlining, and removing duplicates. In
    this phase, you do not add new features, as it is purely a refactoring process.
    If you want to add new features, you must go back to the Red phase and start again
    from there.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a diagram of the TDD process:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The TDD cycle](img/B20912_04_12.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The TDD cycle
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: I think that by this point, you will have understood how cool this technique
    is; however, as with all things, there are not just advantages. Let’s take a closer
    look at the pros and cons of this methodology so that you can form your own opinion.
    As usual, don’t expect an exhaustive list; even though I tried to refer to the
    existing literature on the subject, much of it is influenced by my personal experience.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of TDD
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some advantages of TDD:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**You only write code that’s needed**: According to the principles, it’s important
    to avoid writing production code right after all your tests pass. Instead, when
    your project requires a new feature, you should create a test first to guide the
    implementation process. The code you write should be the most straightforward
    and minimal necessary to fulfill the feature’s requirements. In this way, only
    the essential code to implement the features will end up in the final product.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast failing**: The distinctive aspect of TDD is its ability to facilitate
    rapid failure. This shortens the feedback loop, allowing the development team
    to quickly determine whether the code is correct. Developers can conduct self-assessments
    and manual acceptance tests, while also engaging in peer-to-peer reviews. The
    outcome is a reduced turnaround time, leading to minimal defects during testing.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous change**: As usual, most developers collaborate on the same code
    base. Whenever an individual developer starts working, CI tools detect the changes
    and promptly execute the unit tests, assessing the code within a few minutes.
    If any failures occur, they are promptly reported to the developers, who resolve
    the issues before proceeding to manual or integrated testing, ensuring that end
    users do not encounter these problems.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to maintain and refactor the code base**: Decoupling and clear interfaces
    make code more manageable. You can replace microfeature implementations without
    affecting other modules and rewrite the entire application with preserved tests.
    Thorough testing for each feature eliminates the fear of making changes. A complete
    test suite allows confident code improvements without breaking the application.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear documentation**: TDD uses unit tests, which act as effective documentation,
    sparing the need for time-consuming and difficult-to-maintain written documentation.
    This aspect is a key characteristic of good test coverage overall. TDD significantly
    contributes to achieving comprehensive test coverage.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nudge to refactoring**: There is a dedicated Refactor step as part of the
    Red-Green-Refactor cycle, ensuring that developers think about improvements in
    the design for every single line of code that they write.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development speed – a note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Especially at the beginning, the feeling is that of progressing very slowly.
    TDD is more focused on delivering quality code rather than delivering code quickly.
    People might also write too many tests that are similar or redundant, or perhaps
    write tests that are too simple or test trivial parts of the code. Until the mindset
    is well integrated within the team, it may take some time to proceed at a decent
    pace.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, when developers delay the creation of tests, it may initially appear
    to expedite the development process. However, this approach frequently results
    in tightly coupled code, rendering certain portions untestable. In the event of
    discovering bugs, the debugging phase can become a time-consuming and unpredictable
    task. Consequently, choosing to replace the uncertain and variable debugging process
    with a more predictable and structured testing procedure is often a better idea.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, TDD is a software development methodology in which developers
    create automated tests before writing the actual code. This process involves three
    main steps: writing a failing test that defines the desired functionality, writing
    the minimum code required to pass the test, and then refining the code while ensuring
    all tests continue to pass. It can be implemented over unit tests and also other
    kind of tests, such as integration tests. TDD encourages iterative development,
    improves code quality, and helps catch bugs early in the development process.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope I have conveyed to you the importance of testing, not only as a necessary
    condition for refactoring but also as a cornerstone of quality code. In this chapter,
    we have understood why testing is crucial and why it is beneficial to do it frequently,
    allowing us to fail as early as possible – this may appear like a paradox, but
    it isn’t.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We have various types of tests at our disposal, but we focused particularly
    on unit testing, for which a framework such as JUnit is of great help.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Since testing is essential, it is crucial to have as much of our code base covered
    by tests as possible. For this purpose, we have the assistance of another tool,
    JaCoCo.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we introduced the fundamental methodology TDD, reversing the traditional
    development flow to start with tests and then proceeding to write the code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered all the fundamentals, we can move on to the next chapter,
    where we will finally analyze some refactoring techniques, delving deeper into
    topics that we only briefly touched upon in the chapter on code smells – [*Chapter
    3*](B20912_03.xhtml#_idTextAnchor070).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了所有基础知识，我们可以继续到下一章，在那里我们将最终分析一些重构技术，深入探讨我们在代码异味章节中仅简要提及的主题 – [*第3章*](B20912_03.xhtml#_idTextAnchor070)。
- en: Further reading
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**The Confusion: Error vs. Fault vs. Bug vs. Defect vs.** **Failure**: [https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b](https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混淆：错误 vs. 故障 vs. 缺陷 vs. 缺陷 vs. 失败**：[https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b](https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b)'
- en: 'Getting started with Apache JMeter: [https://jmeter.apache.org/usermanual/get-started.html](https://jmeter.apache.org/usermanual/get-started.html)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Apache JMeter：[https://jmeter.apache.org/usermanual/get-started.html](https://jmeter.apache.org/usermanual/get-started.html)
- en: 'Customer satisfaction: [https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer](https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户满意度：[https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer](https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer)
- en: 'Continuous integration: [https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration
    )'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成：[https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration
    )
- en: '*Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment
    Automation* by Jez Humble and David Farley (Addison-Weasley, 2010)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《通过构建、测试和部署自动化实现可靠的软件发布：持续交付》由Jez Humble和David Farley著（Addison-Weasley，2010年）'
- en: 'The JUnit framework’s official website: [https://junit.org/junit5/](https://junit.org/junit5/)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit框架的官方网站：[https://junit.org/junit5/](https://junit.org/junit5/)
- en: 'Getting started with Mockito: [https://www.baeldung.com/mockito-series](https://www.baeldung.com/mockito-series)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Mockito：[https://www.baeldung.com/mockito-series](https://www.baeldung.com/mockito-series)
- en: 'JaCoCo website: [https://www.jacoco.org/jacoco/](https://www.jacoco.org/jacoco/)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JaCoCo网站：[https://www.jacoco.org/jacoco/](https://www.jacoco.org/jacoco/)
