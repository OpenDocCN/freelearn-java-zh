- en: 8\. Sockets, Files, and Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you to work with external data storage systems. In the
    early sections, you will be taken through how to list the contents of directories—the
    logical first step to learning to create, open, read, and write to external files
    using Java. From there, you will study different methods, buffered and unbuffered,
    and how to distinguish between them. You will then learn to identify two main
    `java.io` and `java.nio`, their respective relationship to the aforementioned
    methods, and when and where to use them. In this chapter's final activity, you
    will be asked to use all these Java skills and tools in order to communicate between
    two different programs running on remote computers, in preparation for the chapters
    to come.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On an operating system level, files and directories are kind of similar. They
    are names representing a link to something in storage, whether it is your hard
    drive, somewhere in the cloud, or the USB drive in your pocket. However, at a
    conceptual level, they are inherently different. Files contain information, while
    directories link to other directories and files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main `java.io` and `java.nio`. Both APIs can be used to navigate
    directories and manipulate files. The information about the location of a file
    is called a pathname. It contains the full information of the directory in your
    hard drive in which the file resides, all the way to the file''s name and extension.
    It should have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Different operating systems refer to files and folder structures differently.
    In Unix systems (such as Linux or macOSX), the `/` symbol represents the separation
    between folders. Having one at the beginning of the pathname indicates an absolute
    positioning against the root folder of the system. Not having that symbol will
    indicate a relative positioning against the `classpath` or the path where our
    program is being executed from. In Windows computers, the folder separator is
    \, and the root is determined by a hard drive label. By default, the root folder
    in Windows is `C:`, but you can also store files in any other drive, such as `D:`.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the two APIs mentioned previously (that is, `java.io`
    and `java.nio`) is in the way they read and write data. The first one, `java.io`,
    can work with streams (this is a concept that we will explore later in the chapter)
    and carries data byte to byte in a blocking manner from one point to another.
    The second one, `java.nio`, works with buffers. This means that data is read and
    written in chunks into a part of the memory (a buffer) and not directly from the
    stream. This allows non-blocking communication, which will, for example, allow
    your code to continue doing something else without having to wait until all the
    data is sent—you simply start copying the information into the buffer and move
    on to doing other things.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to files, the big difference is how using one method or the other
    will translate into faster or slower programs when trying to perform the same
    task in different ways. We will mainly focus on using `java.nio`, since it is
    easier to use files with it, and then refer to `java.io` occasionally. The `java.nio.file`
    (note the difference from `java.io.File`) API defines classes and interfaces for
    the JVM—which makes use of files, their attributes, and filesystems—is more recent,
    and offers an easier way to use interfaces. However, this is not true for all
    cases, as we will see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to examine how to list files and directories in different ways.
    These techniques can come in handy when checking whether a certain file exists,
    which will allow you to give more sensitive information to users when, for example,
    trying to find a properties file. If you detect that the file you're looking for
    doesn't exist and, at the same time, you notice that you are not in the right
    directory, you could make your program locate the actual folder in which the file
    resides, or you could simply inform the user about this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are different techniques to list the files and directories at any location
    on your computer. You must choose wisely depending on the circumstances. While
    the latest API seems more complex at first sight, as you will see in the following
    examples, it is a lot more powerful than any of the previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the old way of listing the contents of a directory. In the
    next exercise, we will only use `java.io`. It requires making a call to `File(dir).list()`,
    where `dir` is a string representing the name of the folder you want to access.
    To ensure the code in this book works with your operating system, we have chosen
    to check your operating system's temporary folder. Java stores that in a JVM property,
    which is labeled `java.io.tmpdir`. Therefore, the call to `getProperty()` at the
    beginning of the method extracts the name of the folder. For example, for any
    Unix OS, that property points to the `/tmp` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your temporary folder is going to be filled up with a lot of files and folders
    created by the different programs running in your computer. Therefore, we have
    chosen to display only the first five listed by the OS – the order is determined
    by the OS. Unless you sort the results of calling `list()`, you will most likely
    not find any logic in how the output is sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since the contents of computers are different for every one of us—even within
    specific folders—the kind of information you will see as output to the code listings
    in this chapter will look different from what you will see in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we have been intentionally hiding the part of the
    APIs that take care of each block of code to simplify the code listing. If you
    remove the three import statements from the code and follow the instructions from
    the IDE to add the more granular APIs to handle this code, you will get the following
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You have learned about almost all these APIs throughout the book up to now.
    Even `java.io.File` was briefly presented in the chapter on exceptions to catch
    `IOException`. In the following examples, we will follow the same principle, just
    to keep the program headers as short as possible. However, it is better to reduce
    the lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore another way to list the contents of a directory, but this time
    using `java.nio`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this listing is different from the previous example, as you can
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the full path to the directories and files are shown. This has to do
    with the way `DirectoryStream` captures information from the OS. The `for` loop
    in this example might look new for you. This has to do with how we work with streams.
    We haven''t explained them yet, and we will not do so until later in this chapter.
    But you can see what it is doing: it creates a buffer that stores the information
    about the different directories inside. Then, it is possible to iterate through
    the buffer using the `for(Path path : directoryStream)` statement if there is
    data in it. Since we don''t know about its size from the start, we will need a
    list to store the string containing the contents of the directory. However, at
    this point, we are still not calling the `java.util.stream` API yet, since `DirectoryStream`
    belongs to the `java.nio` API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another code listing that uses streams properly is shown here. Note that we
    do not show its output because it''s the same as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Separating Directories from Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you want to mark files differently from directories when listing
    a folder''s contents. In order to do so, you can use a method from `java.nio`
    called `isDirectory()`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have highlighted the part of the code that is new compared with the previous
    example in which we accessed the directory using the java.nio API. `Files.isDirectory()`
    requires an object of the `Paths` class. `Paths.get()` transforms the path from
    a directory item, passed as a string to the actual instance of the Paths class.
    With that, `Files.isDirectory()` will answer with a Boolean that is `true` if
    the item is a directory and `false` if not. We used an inline `if` statement to
    assign the string `Dir` or `Fil`, depending on whether we are dealing with a directory
    or with a file. The result of this code listing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the temporary directory, there are both files and subdirectories.
    The next question is how to list the content of the subdirectories. We will approach
    that question as an exercise, but before we do that, try one more example that
    will list only those items that are directories. This is a more advanced technique,
    but it will give us an excuse to step back and try to implement our own solution
    with the knowledge we have gained so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, to show that there is the possibility of using other environment variables
    (that's what we call the system properties as defined for your OS), we changed
    the folder to user home, which corresponds to your user space, or the directory
    where you will typically store your files. Please be careful from now on to avoid
    any kind of accidents with your files.
  prefs: []
  type: TYPE_NORMAL
- en: '`Files.walk()` will extract the directory structure up to a certain depth,
    in our case, one. The depth represents how many levels of subdirectories your
    code will be digging into. `filter(Files::isDirectory)` is going to exclude anything
    that is not a directory. We have not seen filters yet, but it is a clear enough
    concept to not need any further explanation at this point. The final part of the
    call, `collect(Collectors.toList())`, will be creating a list of the output. This
    means that the `subDirectories` object will contain a list of paths to directories.
    That is why in this example, unlike the previous one, we do not have to make a
    call to `Paths.get(filePath)`. The output of that call will depend on what your
    OS is and whatever you have in your home folder. The result on my computer, which
    runs a version of Linux, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<userName>` corresponds to the user's nickname on the computer. As you
    can see, this is only representing the contents of the directory initialized at
    `pathString`. The question is, can we represent the content of the nested subdirectories
    to the initial `pathString` in our program?
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Listing the Contents of Subdirectories'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make a program to navigate through subdirectories using the knowledge
    we have gained so far. It might not be the most optimal way of solving this challenge,
    but it will work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the latest example, where we used a call to `Files.walk()`
    with a depth of 1 and a filter to list the contents—just the directories—of a
    certain directory, `pathString`. The depth in a directory search determines how
    many levels of subdirectories our will program navigate into. Level 1 is the same
    level as where the search is initiated. Level 2 indicates that we should also
    represent the contents of the directories inside the main directory. In principle,
    it should be as easy as giving the call a higher value for depth, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But there is the catch. When running a call like that, it is likely that there
    are directories or files that your program is not allowed to access. An exception
    regarding permissions will be fired and your program will stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Accessing any directory or file that is contained in any of these subdirectories,
    which are under strict administrative user permissions, will make this program
    crash. It is of no use to catch this exception because the result will still be
    a non-functional directory listing. There is a pretty advanced technique to get
    this to work, but you have not been introduced to everything you need to know
    in order to do so. Instead, let's focus on the tools you have gained so far to
    create your own method to dig into subdirectories and extract their contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go back to *Example 03* and modify it to just display directories inside
    user.home:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have applied the `filter()` method we saw earlier. We could
    have also implemented the alternative of checking with `isDirectory()`, as we
    saw in *Example 04*, but this is cleaner, and simplicity is key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the idea that `list()` can give you the contents of any folder, let''s
    call it again for each filename. This means we will have to modify the `forEach()`
    statement we are using so that we can access the second level of nested directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, the highlighted code is a repetition of the code we had earlier,
    with the name of the object changed to `fileNames2`. This time, we removed the
    limit, which means it will print the output of any subdirectories each directory
    has. The real novelty is how we have gone from calling just `System.out::print`
    to writing more complex code where we first print out the path we are at, and
    then we print the paths to the subfolders of that path. We are anticipating something
    called a lambda expression here. They will be explained in a later chapter. However,
    the code here is easy enough for you to understand. For each `(item)` in the `fileNames`
    buffer, we will perform the operations just mentioned. The result looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, `IOException` must be caught at the time of generating the list, otherwise
    the code will not compile. `throw IOException` in the declaration of the `main`
    method doesn't apply to the `forEach()` expression because it is one level deeper
    in the program's scope. We are looking at an inline definition of a method in
    this case. But the question is, how can we get around the idea of having an arbitrary
    depth in the directory exploration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Digging deeper in the `java.nio` API, we find the `walkFileTree()` method,
    which can browse through directory structures up to a certain depth – two in the
    following example – and offers the possibility of overriding some of its methods
    to decide what happens when reaching a directory item and trying to access it.
    A call to this method could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, you can see how the `preVisitDirectory()` method is called at the time
    of trying to open a directory item in a folder. A program including that line
    will run until, for example, a permissions-related exception arrives. If there
    is no exceptional situation, the overridden method will print out all directory
    names up to two levels of depth. In the case of the home directory we are experimenting
    with, we know that there is a folder that Java''s default user permissions are
    not enough for our program to gain access to. Therefore, if we run this program,
    we will see it operate normally until an exception is reached:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `preVisitDirectory()` method will tell the `walkFileTree` method that it
    should continue to work through its return. The issue here is that because of
    the `AccessDeniedException`, our program will not enter `preVisitDirectory()`.
    We need to override yet another method called `visitFileFailed()` to see how to
    handle any kind of exception that occurs when trying to access an item in the
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of this will be the desired result, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can conclude from this process that, even though there are many ways to perform
    the same task, the way those solutions are implemented will allow us to have control.
    In this case, the `walk()` method is not enough for us to handle exceptions easily,
    so we had to explore an alternative that, in the end, turned out to be easier
    to understand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For reference, the final code resulting from this exercise should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating and Writing to a File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we are familiar with how to list the contents of directories, the next
    logical step is to proceed with the creation of files and folders. Let''s start
    by creating and writing data into a file by using `java.nio`. The easiest way
    to create a file using this API requires calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, creating a directory is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As a good practice, you should check whether directories and/or files exist
    prior to creating any with the same name. There is a simple method that will look
    into any objects of the Path class to see whether any can be found in the folder
    our program is exploring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put all of this together into a single example that will create a folder,
    and then a file inside the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this code listing, the first time you execute it, should be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Any subsequent executions should give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This created a file that is essentially empty. Making use of the terminal,
    you could list the size of the file by calling the `ls -lah ~/javaTemp/temp.txt`
    command, which will throw a result like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the file takes zero bytes of hard drive space. This means that
    the file is there, but it is empty. Writing text to the file can easily be done
    using a method from the `java.nio.file.Files` API: `write()`. The only issue is
    that it is not trivial passing arguments to this method. In its easiest interface,
    you must pass two arguments: the `Path` object and a `List` containing a text.
    On top of that, there is a risk that the file may not exist, which requires handling
    the classic `IOException`. It could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When calling `write()` to write text to a file, you don't have to add the end-of-line
    symbol at the end of the string. It will be added automatically by the method
    as one would expect when using commands such as println().
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have added the last code snippet to the latest example, the program
    will give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example just writes text to the file but also deletes everything
    that was there before. In order to append text instead, you need to modify the
    call to the write command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted part of the call is responsible for determining what text will
    be added at the end of the file instead of erasing everything and writing everything
    from scratch. The following example simply appends text to an existing file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This program appended a whole sentence to the example text file. The final
    content of the file will read is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is asking for a soda in Spanish. In the next section, let's examine how
    to read the file we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Writing the Directory Structure to a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this activity is to program an application that will read the directory
    structure, starting from a directory that is stored in a variable. The results
    will be written to a text file so that, for each nesting level, you will include
    either a tab space or four white spaces to indent nested folders visually from
    their respective parents. Also, you will have to show only the name of the folder
    and not the full path to it. In other words, the content of the file should correspond
    to the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The program that you will have to create will need to have a certain depth
    of directories as a parameter, but we recommend you don''t go too deep with this—a
    maximum of 10 is fine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When working with the obtained paths to the directories, you need to split
    the resulting string using the / symbol as a separator and then take the last
    item. Additionally, you will have to print the number of indents based on the
    depth, which will require having some code that can estimate the current depth
    given the initial path. A trick for solving those problems could be by making
    the content of `preVisitDirectory()` like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 552.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading an Existing File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reading a file can be done in a simple way. The question is about where you
    will store the data once you have it. We will work with lists, iterate through
    the lists, and then print out the results to `System.out`. The next example uses
    `readAllLines()` to open the existing file and reads the contents into the computer''s
    memory, putting them into the `fileContent` list. After that, we use an iterator
    to go through each line and send them to the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `temp.txt` file is the one where we saved a message earlier; therefore,
    the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file wasn''t there (you may have deleted it after the previous exercise),
    you would instead get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A different approach that gets the same result, but avoids Lists and uses Streams
    instead, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Reading a Properties File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Property files store key-value (also called key-map) pairs in a standard format.
    An example of the content of such a file is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a made-up example of the properties file for an imaginary user. Note
    how the comment is marked using a hashtag symbol, #. You will use properties files
    to store the configurable parameters of applications or even for localization
    strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try reading a properties file. You can create a text file in the same
    temporary folder that we created in the user's space earlier in the chapter. Name
    it `user.properties` and write to it the contents of the preceding example. This
    follows an example of a program using `java.io` to read and print out the contents
    of a properties file. Given the way Java works, there is no better alternative
    to performing this task than using `java.nio`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Reading the contents of a properties file consists not just in getting each
    line of the file, but also parsing the key-value pairs and being able to extract
    data from them.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you will notice is that reading the properties file requires
    opening a file as a stream – again, a concept we will explore later in the chapter
    – using `FileInputStream`. From there, the `Properties` class contains a method
    called `load()` that can extract the key-value pairs from the data stream. To
    clean up the code listing, we have separated the loading and printing aspects
    of the code from the ones handling the opening of the file. Additionally, we have
    made sure that all exceptions are handled in the main class, just to have a single
    point where we can manage them, which makes for more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There is also an aspect that we have not yet discussed in this chapter. Streams
    must be closed once you are done working with them. This means that they will
    be unavailable for further data handling after you close them. This step is important
    for avoiding any kind of JVM memory issues during runtime. Therefore, the example
    code calls `fileStream.close()` once we are done loading the properties file.
    If you remember the *Good Practices* section in *Chapter 5*, *Exceptions*, it
    was mentioned that you should close streams inside the `finally` statement. This
    is also the reason why this program must throw `IOException` in the main method.
    If you wanted to handle this in a clean way (by avoiding nested try-catch statements
    or using `throws IOException` in the main method), you can wrap the whole `try`
    block in a method that you would, in turn, call from the main method where you
    could catch the `IOException`. Look at the forthcoming exercise to see how this
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the previous example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There are interesting methods within the `Properties` class for you to explore.
    For example, `properties.keys()` will return an enumeration of all the keys in
    the file, in our case name, familyName, userName, and so on. This specific method
    is inherited by `Properties` because of its relation to the `Hashtable` class.
    It is recommended that you read through the API's documentation for this class
    to discover the other interesting methods you can make use of.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the properties files location, they could be stored inside
    the classpath, sometimes even inside the actual JAR file, which provides a very
    compact way to distribute applications with properties files inside.
  prefs: []
  type: TYPE_NORMAL
- en: The next aspect to explore is how to programmatically make your own properties
    files. Let's look into this topic through a step-by-step exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Creating a Properties File from the CLI'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be making an application capable of creating a properties
    file (or modifying an existing one) from input on the CLI. You will pass the properties
    file''s name and key-value pairs as arguments to your program. This will allow
    you to create any kind of properties file easily. An example of the expected call
    to the application will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The process of operations in such a program is simple. First, you need to check
    whether the file exists. If so, load the properties. Then, add the new properties
    or modify the existing ones with the data handed over as an argument. Later, write
    the information to the file and give feedback to the user on the final content
    sent to the file. In that way, the user will be able to see that the modifications
    they made are working without having to open the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to make such a program step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IntelliJ and create a new Java CLI project called `Exercise02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to check whether the properties file we are defining in the
    CLI already exists. The program we are going to implement will check whether the
    file exists. If that is the case, it will open it and load the existing properties.
    The rest of the arguments in the CLI will be used to either modify existing key-value
    pairs or add new ones. To see whether a properties file exists and load it, we
    will need to execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loading the properties is done reusing the code from *Example 10*, but wrapping
    it into the `LoadPoperties()` method that we called in the previous step. Let''s
    implement it to return an object of the `Properties` class (note what we did to
    implement the `finally` statement to make sure that the stream is closed after
    a possible exception. We had to initialize the stream as null):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the file doesn't exist, it will be created when calling the `store()` method
    later—there is no need to create an empty file at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to read the remaining arguments at the CLI from the `arg[]` array
    and push them, one by one, into the properties object. The properties object inherits
    its behavior from the `Hashtable` class, which handles key-value pairs. The `setProperty()`
    method will be used to either modify an existing property or to write a new one.
    Since the arguments are expressed as a string formatted as key=value, we can use
    `split()` to separate the arguments we need to pass to `setProperty()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to be writing to a file, but instead of using a stream that will
    be inputting data, we will use one that will be outputting data. Its name is simple
    to infer, `FileOutputStream`. The declaration of a variable of that class will
    be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add some comments to the properties file, we simply need to add a parameter
    to the `store()` method. In this case, just to add some contextual information,
    let''s add a timestamp by calling the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We call the `store()` method, which will send the properties into the file.
    We will be overwriting whatever existed in it before. This call uses, as an argument,
    the output `Stream` and whatever comment we have chosen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To improve the program''s usability, make a method that will iterate through
    the whole properties set and print it out. In that way, the user can see whether
    they wrote things properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code with, for example, the following call in the CLI. In this case,
    we are intentionally modifying the file we have been working with throughout the
    chapter. The program will print out the modified set. Please note that there is
    no clear order to the key-value pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the resulting file in a text editor and see whether your changes took effect
    or not. Also note that the comments, as well as the `\` sign added by the `store()`
    method to avoid the color parameter (which is expressed in HEX format using the
    hashtag symbol) being misunderstood as a comment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could now consider making other modifications to the program so it can
    clear up an existing file, append several files, and more. You could do that using
    different commands as arguments. The code for the full exercise is available on
    GitHub: [https://packt.live/2JjUHZL](https://packt.live/2JjUHZL)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Streams?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Streams in Java are sequences of bytes and eventually, by extension, also objects.
    You can understand a stream as a flow of data between two places. Creating a variable
    of the stream type is like opening a peephole to look into a pipe carrying water
    between two containers and seeing the water passing through. What we are trying
    to say is that data inside a stream is always changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen before, we have two different ways of looking at things in
    this chapter: one through the lens of the `java.io` API and one through the `java.nio`
    API. While the second one works at a more abstract and therefore easier level,
    the first one is extremely powerful and low-level. Continuing with the water analogy,
    `java.io` would allow you to see the drops, while `java.nio` would let you play
    only with 1-liter bottles at a time. Each one of them has its advantages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams in `java.io` can be as granular as going down to the level of the byte.
    If we were, for example, to look at a stream of sound data coming from the computer''s
    microphone input, we would see the different bytes representing the sound, one
    by one. The other API, `java.nio` is buffer-oriented, and not so much stream-oriented.
    While this is true, there is a way to work with streams in `java.nio`. Because
    of its simplicity, in this section, we will see an example relating to `java.nio`,
    while in the following section, we will deal with streams using the API that is
    best prepared is to handle them: `java.io`.'
  prefs: []
  type: TYPE_NORMAL
- en: Streams in `java.nio` are sequences of objects (not arbitrary unsorted data).
    Since those objects belong to specific classes, streams offer the possibility
    of applying the objects' corresponding methods to the stream directly. The result
    of applying a method to a stream is yet another stream, which means that methods
    can, therefore, be pipelined.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen different streams in this chapter, mainly because streams play
    such a big role in Java that it is almost impossible to do any kind of file-related
    example without using them. Now you will see how they work in more depth. This
    will help you understand some of the aspects that may not have been so clear to
    you so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nature of streams is typically hard to grasp in the first place. As mentioned,
    they are not plain data structures. Information is arranged in the form of objects.
    Input is taken from `Arrays`, I/O channels in the program, or `Collections`. The
    kinds of operation we can perform on streams are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map` (intermediate): This will let you map objects following a predicate that
    you can give as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter` (intermediate): This is used to exclude some elements from the whole
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sorted` (intermediate): This will sort the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collect` (terminal): This will put the results of the different operations
    into an object a form, for example, a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach` (terminal): This will iterate through all of the objects in the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce` (terminal): This operates the stream to answer a single value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have marked each one of the operations with either intermediate or terminal.
    The former means that the operation that will be performed will give another stream
    as a result, and therefore it should be possible to chain another operation onto
    it afterward. The latter means that there cannot be further operations performed
    after that one has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, you have seen some of those operations in action in this chapter.
    You can go back to the examples where those operations showed up and revisit them.
    It will make it a lot clearer what `filter()`, `collect()`, and `forEach()` are
    doing. Let''s see the other three operations in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The complete code of `Example11.java` is available at `Chapter 1/Code.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is divided into two parts. The first half of the program checks
    whether a file called `numbers.txt` exists in the `javaTemp` folder that we have
    been using throughout the chapter. If this file doesn''t exist, the program creates
    it with `Files.createFile(pathFile)` and then populates it with 10 random numbers
    previously stored in an array of `int` called `numbers`. The call to `Files.write(pathFile,
    Arrays.asList("" + n), StandardOpenOption.APPEND)` is responsible for adding each
    number in the array as separate lines in the file. The resulting file will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea of having one number per line is that we can then read the file as
    a list, transform the list into a stream, and then start making different operations.
    The simplest operation consists of calling `fileContent.forEach(System.out::print)`,
    which will print the raw data as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Before applying other operations, such as `sorted()`, we need to transform
    the data into a stream, something that is done with the `stream()` method. This
    is done using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this operation will be sorted. Equal values will show up side
    by side, repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'With `map()`, we will be able to handle the data and perform different operations
    on it. For example, here, we multiply it by 2 and print it to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there are different terminations that can be used. To do this, we
    will use lambda expressions, which are not introduced until a much later chapter.
    However, the following is easy enough to not need any further explanation. To
    perform the sum of all the numbers, we need to do the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that, when reading the file, we have read it as a `List` of `String`, and
    therefore, the numbers are stored as strings. This means that, in order to operate
    them as numbers, we need to cast them back into integers, which is done through
    the call to `Integer.parseInt(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: The Different Streams of the Java Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To discuss types of streams, we need to take one step back and move away from
    `java.nio` and into `java.io`. This API is the one that has the best support for
    streams. Depending on the situation, streams can either go into the program or
    out from the program. This gives us two main interfaces for streams: `InputStream`
    and `OutputStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within each of those two main categories, there are four ways to look at streams
    from the perspective of the type of data they are dealing with: `File`, `ByteArray`,
    `Filter`, or `Object`. In other words, there is a `FileInputStream` class, a `FileOutputStream`
    class, a `ByteArrayInputStream` class, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: According to Javadocs, it is important to understand that there is a hierarchy
    of streams. All streams are built on top of byte streams. But we should try, as
    much as possible, to use the kind of stream type that is the closest in the hierarchy
    to the kind of data we are using. For example, if we were to deal with a series
    of images coming from the internet, we should avoid working at a low level with
    byte streams to store the images, and we should use object streams instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Read more about streams in the official Java documentation at [https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html](https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'How would it then open and print out a file using java.io and `FileInputStream`?
    We saw a bit of this when dealing with the properties files. Let''s do the lowest-level
    example possible that will read a file and print out its contents byte by byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This example opens the temp.txt file we created earlier in the chapter and
    prints out its contents. Remember that it contained some plain text in the lines
    of `hola\nHola,\nme da un ...`. When looking at the terminal, what you will read
    will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering – what happened to the text? As you know, every symbol
    of the English alphabet is represented by a standard called ASCII. This standard
    represents each symbol with a number. It differentiates uppercase from lowercase,
    different symbols such as exclamation marks or hashtags, numbers, and more. An
    excerpt of the ASCII table representing the lowercase symbols is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If you start taking the stream of numbers you get and parse it using the table
    for the ASCII symbols, you will see that `104` corresponds to `h`, `111` to `o`,
    `108` to `l`, and `97` to `a`. If you had a full ASCII table (including capitals,
    symbols, and numbers) you would be able to decode the whole message. We did get
    the content of the file, but we didn't interpret the data we got in our program,
    which rendered the output unreadable. This is the reason why you should try to
    use a higher-level kind of stream, which will stop you having to decode the information
    at such a low level, which for characters – as in this example – is not such a
    big deal. But data transfers between software entities can get complex very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine another way of performing the same operation of opening the
    file, but with a different type of stream. In this case, we will use `FileReader`,
    which is a different type of stream, on top of `FileInputStream`. To get the stream
    in the form of characters and pass it over to `BufferedReader`, which is a stream
    class that includes the possibility of reading full lines of a text. Since we
    know that our file contains text arranged in lines, this will probably be the
    best way to see the contents of the file in a neat way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example will be what we expected to see in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, the information is the same, but it matters how we look at it.
    Using a higher-level class from the stream family will offer us better methods
    to handle the same information in a different yet more usable way.
  prefs: []
  type: TYPE_NORMAL
- en: There is another concept that we haven't introduced yet, and that is the difference
    between buffered streams and unbuffered streams. When working at a low level with
    java.io, you will be most likely working in an unbuffered way. This means that
    you will be addressing the OS directly from your code. Those exchanges are computationally
    hungry, especially in comparison with loading any information into a buffer inside
    the JVM and operating directly there instead (it doesn't mean that it will not
    be accessing the OS directly — it will, but it will optimize its use.
  prefs: []
  type: TYPE_NORMAL
- en: This example is clearly using `BufferedReader`, which differs from the previous
    one. We mentioned earlier in the chapter how `java.nio` works with buffers – this
    means that, unlike `java.io`, it doesn't offer the possibility of doing those
    direct calls to the OS. In a way, it is better because it is less prone to errors.
    If you have a properly constructed API with all the methods needed to perform
    whatever you want to do, you should avoid using other less optimal tools.
  prefs: []
  type: TYPE_NORMAL
- en: What are Sockets?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A socket is the endpoint of a bidirectional communication channel between two
    programs operating over a network. It is as if a virtual cable was connecting
    those two programs, offering the possibility of sending data back and forth. Java's
    APIs have classes to easily construct programs at both ends of the communication.
    The exchanges on, for example, the internet happen over a TCP/IP network, where
    we distinguish between the roles of those that participate in the communication.
    There are servers and clients. The former can be implemented using the ServerSocket
    class, while the latter can use the socket class.
  prefs: []
  type: TYPE_NORMAL
- en: The way the communication process works involves both parties. The client will
    send a request to the server asking for a connection. This is done through one
    of the available TCP/IP ports on your computer. If the connection is accepted,
    the socket is opened at both ends. The endpoints at the server and the client
    will be uniquely identifiable. This means that you will be able to use that port
    for multiple connections.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to deal with sockets, together with streams, will allow you to work
    with information coming directly from the internet, which will bring your programs
    to the next level. In the following sections, we are going to see how to implement
    a client and a server to prototype this communication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While working with these examples, make sure your computer's security system
    (firewalls and the like) allow communicating over whatever port you decide to
    use. It wouldn't be the first time someone has wasted several hours thinking their
    code is wrong when the issue is somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SocketServer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trying to read data from sockets requires a little involvement from existing
    networked resources. If you want to have a program that connects to a server,
    you will require a known server before you can even try the connection. On the
    internet, there are servers offering the possibility of connecting, opening a
    socket, sending data, and receiving it back. These servers are called EchoServers—a
    name that leaves little doubt about what they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you can implement your own server and play it safe. Oracle
    offers a simple example of an EchoServer for you to test. This is going to be
    a new kind of challenge because you are going to need to run two programs on your
    computer at once: the EchoServer and whatever client you will implement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the EchoServer that you can get from [https://packt.live/33LmH0k](https://packt.live/33LmH0k).
    The code for you to analyze is included in the next example. Note that we have
    removed the opening disclaimer and code comments to keep it short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the code checks that you have selected a port for your server
    to be listening to. This port number is given as an argument on the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If no port was chosen, this program will simply exit. Remember, as we mentioned
    earlier, to make sure that whatever port you use, it is not blocked by your computer's
    firewall.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `ServerSocket(Integer.parseInt(args[0]))` will start the object
    of the `ServerSocket` class, configuring the port defined in the arguments to
    call the program as the one to listen to. Later, `serverSocket.accept()` will
    block the server and make it wait until a connection arrives. Once it arrives,
    it will be automatically accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the beginning code in this example, there are two different streams: `BufferReader
    in` for the input, and `PrinterWriter out` for the output. As soon as a connection
    is established, `in` will get the data, and `out` will send it – without any further
    processing—back to the socket. The server program will run until forcing an exit
    when pressing *Ctrl*+*C* on the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the server started, you will need to compile it using the build icon
    (the hammer) and call it from the terminal using a specific port name. Try port
    8080, because that is typically used for experiments like the one, we are going
    to do now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes as planned, the program will start running and will not print
    any messages. It is there just waiting for a connection to be made.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, by default, your own computer always has the IP number 127.0.0.1,
    which allows you to figure out the IP number of your computer in the network.
    We will use this for the connection with the client.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Data on and Reading Data from a Socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While our server runs in the background, we will need to produce a simple program
    that will open a socket and send something to the server. To do this, you need
    to create a new project in the IDE but in a separate window. Remember that your
    server is currently running!
  prefs: []
  type: TYPE_NORMAL
- en: The simplest client that you can produce is Oracle's companion to the *EchoServer*.
    For obvious reasons, it is called *EchoClient*, and you can find it at [https://packt.live/2PbLNBx](https://packt.live/2PbLNBx).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in this case, instead of creating a `SocketServer` object, we create
    a `Socket` object. This second program introduces the idea of using one of the
    system streams to capture data and send it to the socket: `System.in`. This program
    will run for as long as the input in `System.in` is `not null`. This is something
    that cannot really be achieved through direct interaction with System.in, because
    we will be just pressing keys on the keyboard. Therefore, you will need to call
    *Ctrl* + *C* to stop the client, just as was the case with the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Note how sending data to the server is done with `out.println()`, where out
    is a `PrinterWriter` object, a stream, that is constructed on top of the `Socket`.
    On the other hand, to read the incoming `Socket`, we have implemented a `BufferedReader`
    object called `in`. Since it is buffered, we can poll the object whenever we want.
    The call to `out.readLine()` and `in.readLine()` is blocking. It will not stop
    reading from `System.in` or from the socket until the end of the line has been
    reached.
  prefs: []
  type: TYPE_NORMAL
- en: This makes this reader synchronous because it waits for the user to type, sends
    the data, and, finally, waits until getting an answer from the socket.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Every operating system makes three different system streams available to the
    JVM: System.in, System.out, and System.err. As they are streams, you can use the
    full power of the Stream classes to read data from them, put them into buffers,
    parse them, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the client started, you will need to compile it using the build icon
    (the hammer) and call it from the terminal using a specific IP and port name.
    Try the IP 127.0.0.1 and port 8080\. Remember that you need to start the server
    before you start the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'From that moment on, and until you issue the Ctrl + C command, for as long
    as the server is connected, you will be able to type whatever you want on the
    terminal, and when you press Enter, it will be sent to and from the server. Upon
    arrival, the client will write it to the terminal by adding the message echo before
    it. We highlight the response coming from the server by making the typeface bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Also, when forcing an exit on the client, it will force an exit on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Improving the EchoServer and EchoClient Programs'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will have to make improvements to the programs in the
    last two sections. First, you will have to add some text to the data relayed on
    the server. This will make it easier for the user to understand that the data
    was sent back from the server. Let''s make it a counter that will act as a sort
    of unique ID for the exchange. In this way, the answer from the server will be
    shown with a number added to the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, you should add a command in the client that will send a termination
    signal to the server. This command will exit the server, and then exit the client.
    To terminate any of the programs, you can call `System.exit()` after sending a
    message to the terminal informing the user that the program is ending. As a termination
    command, you could make something simple, such as a message that contains the
    word 'bye'.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected results will require you to modify both the server and the client
    in a very similar way. On the client-side, you will have to do something like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the server, the modifications should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected interaction between the server and the client should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.1: The interaction between the client and the server.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: The interaction between the client and the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 555.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking and Non-Blocking Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a topic we have been covering in this chapter, but we have not addressed
    it directly. The `java.io` read and write operations are blocking. This means
    that the program will wait until the data is fully read or until the data has
    been fully written. However, working with buffered streams as implemented in `java.nio`
    allows you to check whether the data is ready to be read. When writing data, `java.nio`
    will copy the data to the buffer and let the API write the data to the channel
    by itself. This allows an entirely different programming style where we don't
    need to wait for the operations to happen. At the same time, this means that we
    will not have low-level control of the communication. A different part of the
    JVM performs that action for us.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have been introduced to two main APIs in the Java language:
    java.io and java.nio. They have some overlapping functions, and they are needed
    to deal with streams and files. On top of that, you have seen how to work with
    sockets, a natural source of data that can only be handled with streams.'
  prefs: []
  type: TYPE_NORMAL
- en: There have been a series of examples looking at how to capture data from the
    terminal, which in the end happened to be `stream (System.in)`. You then explored
    how to process it using streams with all sorts of high-level functions, such as
    filter, map, sorted, foreach, reduce, and collect. You have seen how to open files
    and properties files, and how java.nio is very capable with the former, but not
    with the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a more practical perspective, this chapter has introduced one important
    technique that was only explained in theory in an earlier chapter: how to use
    `finally` to close streams, and avoid potential memory issues during runtime.
    You have seen that, in order to handle exceptions cleanly, you may have to move
    blocks of code into methods. In this way, you can avoid throwing exceptions and
    can always process them with try-catch statements.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to play around with sockets, you have experimented with building an
    EchoServer and an EchoClient. You had two different programs interacting with
    one another and sending data over the internet. You saw how to run both the server
    and the client on your own computer, and it is now time to try those two programs
    running on different computers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the two activities in this chapter introduced you to creating or modifying
    properties files on the fly by typing key-value pairs as arguments to a program,
    and remotely controlling another program via commands over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about HTTP and how to create a program that
    connects to a specific web server and downloads data.
  prefs: []
  type: TYPE_NORMAL
