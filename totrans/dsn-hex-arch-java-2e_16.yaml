- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using SOLID Principles with Hexagonal Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of having a set of principles to help us develop better software amuses
    me. Over the years, programmers have faced many problems; some happened so often
    that patterns to solve such issues emerged, giving rise to the so-called **design
    patterns**. These patterns have been employed to solve specific software development
    problems. Complementing design patterns that act more on recurrent and specific
    coding problems, ideas have emerged on tackling maintainability problems in software
    projects. A remarkable and influential set of those ideas has been synthesized
    into what is known as **SOLID principles**.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore SOLID principles and how we can tap into them while
    using hexagonal architecture. We will start by reviewing each principle, and then
    we will proceed to see how they can be applied in the context of a hexagonal system.
    Finally, we will discuss how design patterns, such as builder and abstract factory,
    can be used with hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying SOLID on a hexagonal architecture system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will be able to employ SOLID principles in
    conjunction with hexagonal architecture techniques. Also, you will know how to
    use design patterns, such as chain of responsibility, decorator, builder, and
    singleton, while developing a hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for the Linux, MacOS, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the advent of programming, developers have discussed ideas and captured
    principles to help develop better software. These principles arose as a response
    to help handle highly complex code. After suffering multiple times from the same
    recurrent problems, developers started recognizing those problems’ patterns and
    devised techniques to prevent such issues. A notable example is the **Gang of
    Four** (**GoF**) book on design patterns, which caused a tremendous impact in
    the object-oriented world and continues to influence generations of developers
    to this day. Another remarkable and influential example is the ideas formulated
    by Robert Martin that led to SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOLID stands for the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility** **Principle** (**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Closed** **Principle** (**OCP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution** **Principle** (**LSP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation** **Principle** (**ISP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion** **Principle** (**DIP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These principles aim to help developers create robust and easy-to-change software
    through code, based on a set of rules defined by those principles. I believe that
    using these principles does not fully guarantee that software is free of maintainability
    problems. However, such principles can significantly improve overall code quality.
    In essence, it’s all about employing techniques that allow the introduction of
    changes to a code base in a sustainable way. I mean, the software will grow, but
    its complexity will be kept under control.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles work in a similar way to hexagonal architecture because both
    aim to provide techniques to develop more maintainable, change-tolerant software.
    Therefore, it makes sense to explore how those principles can be applied in the
    context of a hexagonal application. Let’s start our exploration by reviewing each
    one of the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle (SRP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not hard for me to remember a situation where I would witness or be the
    author of a code change that caused side effects, discovered only after an application
    was deployed to a staging or, even worse, production environment. A stakeholder
    would report problems in the application that started to occur right after the
    change that caused the side effect was deployed. So, although the change solved
    the problem for one stakeholder, it created a problem for another. Why? Because
    the change responsible for the problem has violated the SRP. The violation occurred
    because the same system logic served two different stakeholders. The change solved
    the problem for one stakeholder but created a side effect that caused trouble
    for the other.
  prefs: []
  type: TYPE_NORMAL
- en: An SRP violation can also occur when we define abstractions too early. Suppose
    we define an abstract class with certain data and behaviors we believe will be
    common to all future implementations of that abstract class. Then, later on, we
    discover, through an unfortunate incident report, that some data or behavior from
    that abstract class causes unexpected outcomes in a recent implementation provided
    by another developer, who assumed the behaviors and data provided by that abstraction
    would work in the implementation that causes the trouble.
  prefs: []
  type: TYPE_NORMAL
- en: The SRP ensures a method or function is changed based on requests from only
    one type of stakeholder or actor, usually a department or a line of business in
    an organization. It is important to ensure the logic from department A, for example,
    does not mess up the logic from department B, which can be accomplished by arranging
    the code in a way that the logic to serve different stakeholders is adequately
    separated.
  prefs: []
  type: TYPE_NORMAL
- en: Open-Closed Principle (OCP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind this principle lies in increasing what software can do without
    changing the existing things in it. In order to do this, a software component
    or module should be open for extension but closed for modification. I can recall
    an experience where I was implementing a reporting feature. Instead of having
    one class to deal with all kinds of reports, I created a base abstract class with
    basic attributes common to reports. Every time a new type of report had to be
    implemented, a new concrete class would be created by implementing the base abstract
    class. Additional attributes and functions would be appended to the basic attributes
    of the base abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: We use the OCP to avoid those situations where we want to add a new feature,
    and to do so, we also need to change some piece of logic already supporting an
    existing feature. By doing that, we violate the OCP. Instead, we need to arrange
    code so that we can add new features without modifying the code already serving
    existing features.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle (LSP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the reporting example I gave in the OCP description, let’s suppose
    we have a `Report` class containing the `print` method declaration. According
    to a given problem domain, the `print` method is a behavior supported by any report.
    In addition to the `Report` class, imagine we have the `WorkdayReport` and `WeekendReport`
    classes extending it. The LSP prescribes that if we pass objects of type `WorkdayReport`
    or `WeekendReport` to a method expecting a `Report` type, that method will be
    able to trigger the behaviors inherent to all kinds of reports – in this case,
    the `print` method. The bottom line is that the `Report` type should be designed
    so that its declared methods, when overridden for sub-types, should be coherent
    with the subtype’s purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation Principle (ISP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ISP is helpful whenever we want to provide clients with an interface containing
    only the method declarations they need. This principle is usually employed when
    we have a single interface with many method declarations, and a given client only
    implements some methods and provides dummy implementations for those they don’t
    need. By employing the ISP, we break that single interface with multiple interfaces
    tailored for specific client needs.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle (DIP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stable and unstable software components have distinct concepts. *Stable* means
    those components that don’t change too often, while *unstable* is the opposite.
    Having a client component depending directly on an unstable component may be risky
    because changes in unstable code can trigger changes in the client. Most of the
    time, the unstable component is a concrete class with implementation details that
    don’t need to be exposed to its clients.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid exposing such implementation details and protect the client from dependency
    changes, DIP prescribes that clients should always depend on abstractions rather
    than concretions. The unstable component – a concrete class with implementation
    details – should derive from an abstraction by implementing an interface, for
    example. Then, the client should rely on a stable component, an interface implemented
    by the unstable component (a concrete class). We call an interface a stable component
    because it acts as a contract, and contracts are less susceptible to change.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see in the next section how we can apply SOLID principles to an application
    developed using hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Applying SOLID on a hexagonal architecture system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see how each SOLID principle is applied, we will go back to the topology
    and inventory system we have developed throughout the book. Let’s start by seeing
    how the SRP can be applied in the topology and inventory system.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the SRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just to recap, the topology and inventory system manages network resources such
    as routers and switches. Such a system is suited for telecommunication or **Internet
    Service Provider** (**ISP**) companies that want to keep an inventory of the network
    resources they use to serve their customers.
  prefs: []
  type: TYPE_NORMAL
- en: In the topology and inventory system, we have core and edge routers. Core routers
    handle high-load network traffic from one or more edge routers. Edge routers are
    used to handle traffic from end users. Edge routers connect to network switches.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a scenario where core and edge routers change locations. For example,
    a core router that is now localized in France needs, for some reason, to be re-provisioned
    in Italy, and an edge router that is in Frankfurt needs to be re-provisioned in
    Berlin. Consider also that network changes across countries are handled by actor
    A, and network changes across cities are handled by actor B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the topology and inventory application to fulfill the described
    requirement. The changes described as follows are made in the Domain hexagon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `AllowedCountrySpec` specification class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This specification limits which countries can be chosen through the `allowedCountries`
    attribute. That’s not how you should represent it in a real application, but it
    is enough to illustrate the SRP idea.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create the `AllowedCitySpec` specification class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Following the same idea from the previous specification, here we limit which
    cities are allowed through the `allowedCities` attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Declare the `changeLocation` method in the `Router` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `Router` is an abstract sealed class, allowing only the `CoreRouter`
    and `EdgeRouter` classes to implement it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Provide an implementation for `CoreRouter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `AllowedCountrySpec` to check whether the new router `Location` is
    allowed. If a non-allowed country is provided, an exception is thrown. Otherwise,
    the new location is assigned to the `location` variable from the `Router` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Provide an implementation for `EdgeRouter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `EdgeRouter` implementation is slightly different. In addition to `AllowedCountrySpec`,
    we also have `AllowedCitySpec`. A new `Location` will be assigned to the `Router`
    object only after fulfilling these two specifications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s review what we have done here. We started by creating the `AllowedCountrySpec`
    and `AllowedCitySpec` specifications; then, we declared the `changeLocation` method
    on the `Router` abstract class. As both `CoreRouter` and `EdgeRouter` implement
    this class, we had to override the `changeLocation` method to serve the needs
    of actor A and actor B. Actor A is responsible for handling location changes across
    countries – in this case, `CoreRouter`. Actor B is in charge of handling location
    changes across cities, which is the responsibility of `EdgeRouter`’.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose that instead of declaring `changeLocation` as abstract, we provided
    a concrete implementation shared by both the `CoreRouter` and `EdgeRouter` classes.
    That would violate the SRP because the `changeLocation` logic would serve different
    actors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Applying the OCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have not stated it yet, but the arrangement between the `Router`, `CoreRouter`,
    and `EdgeRouter` classes represents an application of the OCP. Observe the following
    Unified Modeling Language (UML) diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Applying the OCP](img/B19777_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Applying the OCP
  prefs: []
  type: TYPE_NORMAL
- en: The OCP ensures that a module or component is closed for change but open for
    extension. Instead of providing a class design where one single class would contain
    the logic to handle both core and edge routers, we leverage the inheritance capability
    from Java to extend the possibilities of the `Router` abstract class, without
    changing its attributes and behaviors. Such extensions are possible through the
    `CoreRouter` and `EdgeRouter` concrete class implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the LSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the application of the LSP, we need to make more changes in
    the topology and inventory system. While applying the SRP and OCP, we changed
    the Domain hexagon. Now, we will make changes in the Application hexagon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `changeLocation` method in the `RouterManagementUseCase` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Changing a router’s location is a new use case that we add to the topology and
    inventory system, so we add the `changeLocation` method declaration to express
    that use case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `changeLocation` method in `RouterManagementInputPort`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `changeLocation` method from `RouterManagementInputPort` calls `changeLocation`
    from `Router` by passing a `Location` object. `changeLocation` from `Router` has
    a logic that checks whether the provided `Location` is allowed. If everything
    is fine, we call `persitRouter` to persist `Router` with its new `Location`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The LSP application can be observed when we implement the `changeLocation`
    method in `RouterManagementInputPort`. Note that `changeLocation` expects a `Router`
    type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It means we can pass here either a `CoreRouter` or an `EdgeRouter` object because
    both extend `Router`, and both provide an implementation of `changeLocation`,
    a behavior inherent to all routers.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the ISP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While applying the LSP, we created `RouterManagementUseCase` and `RouterManagementInputPort`
    in the Application hexagon. Let’s finish our implementation by providing an input
    adapter in the Framework hexagon to connect the input adapter to the input port:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `changeLocation` method in the `RouterManagementAdapter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `POST` and `PATH` annotations, we turn this method into a `REST` endpoint
    to receive requests sent to the `/router/changeLocation/{routerId}` URI. The router
    part of the URI comes from the top-level definition of the `PATH` annotation of
    the `RouterManagementAdapter` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This input adapter gets `Router` using the `retrieveRouter` method from `RouterManagementUseCase`.
    Then, it converts the `LocationRequest` object into a `Location` domain object.
    Finally, it passes `Router` and `Location` to the `changeLocation` method from
    `RouterManagementUseCase`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To confirm that our implementation works, let’s implement a test to check the
    entire flow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the following test in the `RouterManagementAdapterTest` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test changes the location of the Router, which is a core router located
    in the United States. After sending a `POST` request containing a `Location` object
    with `Germany` as the country and `Berlin` as the city, we run an assertion to
    ensure that the returned `Router` object has the changed location – Germany instead
    of the United States.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The ISP can be observed in making use-case operations available to the input
    adapter. We have the `RouterManagementInputPort` class implementing the `RouterManagementUseCase`
    interface. The ISP is employed because all method declarations from the `RouterManagementUseCase`
    interface are relevant and implemented by `RouterManagementInputPort`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the DIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed dependency inversion in [*Chapter 9*](B19777_09.xhtml#_idTextAnchor192),
    *Applying Dependency Inversion with Java Modules*, where we used the **Java Platform
    Module System** (**JPMS**) to apply dependency inversion. To recap, let’s review
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Reviewing dependency inversion](img/B19777_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Reviewing dependency inversion
  prefs: []
  type: TYPE_NORMAL
- en: 'The DIP states that clients should always depend on abstractions rather than
    concretions. That is precisely what we are doing by making `RouterManagementAdapter`
    depend on the `RouterManagementUseCase` interface, rather than the `RouterManagementInputPort`
    concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency Inversion
    with Java Modules*, the `RouterManagementUseCase` interface implementation – a
    `RouterManagementInputPort` object – is provided by the JPMS. In the current implementation,
    we use Quarkus with the `@Inject` annotation to provide `RouterManagementInputPort`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we applied some design patterns while developing the topology
    and inventory system. These patterns helped us arrange code to support application
    needs better. So, in this section, we will review the design patterns we applied
    while implementing hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before introducing Quarkus to our topology and inventory system, we had to provide
    our own mechanism to create a single database connection object. When handling
    database-based connections, it’s common to have just one instance that connects
    to a database and shares that connection with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Singleton is the pattern we used to create a single database connection instance,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To ensure only an object is created, we create a private constructor to prevent
    clients from creating additional instances. The object creation is handled by
    the `getInstance` method, which checks whether the instance attribute is `null.`
    If it is `null`, then it creates a new `RouterNetworkH2Adapter` and assigns it
    to the `instance` variable. The private constructor then creates a database connection
    using `EntityManagerFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: When executing `getInstance` for a second time, instead of creating a new `RouterNetworkH2Adapter`,
    we return the existing instance created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Builder is a design pattern that helps us expressively create complex objects.
    It’s intended for scenarios with constructors with many parameters and different
    ways to make the same object. We have used that design pattern to create `CoreRouter`
    and `EdgeRouter` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where we create an instance of `CoreRouter`
    using its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: One of the drawbacks of using the constructor directly is that we need to know
    how to pass the parameters in the correct order. In the previous example, we must
    pass first `id`, then `parentRouterId`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see the object creation using builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Other than skipping some parameters such as `parentRouterId`, we pass the parameters
    in any order through builder methods such as `vendor` or `model`. Once we are
    done, we call the `build` method to return the `CoreRouter` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book, we have not provided a custom builder implementation.
    Instead, we relied on the helpful Lombok libraries to create builders by simply
    adding the `Builder` annotation to the class’s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Lombok is probably enough for you if you don’t have special requirements for
    how your objects should be created. Otherwise, you can implement your own builder
    mechanism. That is usually done when you want to define mandatory or optional
    parameters and other rules for object creation.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed in the previous section how applying the LSP enables us to pass
    a `CoreRouter` or `EdgeRouter` object to a method expecting a `Router` type, and
    then we can use that object without any issues. The abstract factory pattern comes
    into play whenever we need to create `CoreRouter` or `EdgeRouter` objects. We
    did so when we implemented the `RouterFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `RouterFactory` class contains only the `getRouter` method, which receives
    some parameters required to create code and edge routers and returns an object
    of type `Router`. Note that we pass a `RouterType` parameter used in the `switch`
    statement to identify which kind of router needs to be created, either `CoreRouter`
    or `EdgeRouter`. Regardless of the specific router subtype, we always return it
    as the `Router` supertype for use, for example, in scenarios where the LSP can
    be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter allowed us to explore how SOLID principles can be employed together
    with hexagonal architecture. We also reviewed our design patterns while implementing
    the topology and inventory system. We started by briefly discussing SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: After getting a basic understanding of the principles, we moved on to see how
    they can be applied in the context of a hexagonal application. We then implemented
    the change router location feature to the topology and inventory system. Finally,
    we reviewed how design patterns such as builder, singleton, and abstract factory
    are employed while designing the hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: The next and final chapter will explore further design practices to help us
    build better software.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does OCP stand for, and what is its purpose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the goal of the DIP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which design pattern can support the LSP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It stands for the **Open-Closed Principle**. Its purpose is to ensure a software
    component or module is closed for modification but open for extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DIP prescribes that clients should always depend on abstractions rather
    than concretions. By doing that, we protect clients from changes in the concretions
    that may require changes in the client code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The abstract factory pattern provides objects based on their supertype, which
    can be used in LSP, where supertypes are replaced with subtypes while retaining
    the object’s behavior consistency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
