- en: Spring Boot DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring Boot DevTools to a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring LiveReload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring dynamic application restart triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Remote Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a world of DevOps, agile software development practices, the introduction
    of microservices, and with more and more teams doing continuous development and
    deployment, it becomes even more important to be able to quickly see the code
    changes to an application without going through the whole process of re-compiling
    the entire project, rebuilding, and restarting the application.
  prefs: []
  type: TYPE_NORMAL
- en: The arrival of containerization services such as Docker has also presented a
    challenge in terms of access to the actual application running environment. It
    has changed the notion of a machine by abstracting and encapsulating the runtime
    environment, removing the ability to use any port to get access.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot DevTools provides the ability to do selective class reloading and
    debugging applications running inside Docker containers using HTTP remote debug
    tunnel, in order to give developers a quick feedback loop to see their changes
    reflected in the running application without long rebuild and restart cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring Boot DevTools to a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with Spring Boot 1.3, we have the ability to take advantage of DevTools
    components in our projects to enable things like automatic application restarts
    upon code change, reloading the browser windows for the UI, or remotely reloading
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The DevTools module is available for both Maven and Gradle, and works nicely
    with either Eclipse or IntelliJ IDEA editors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover integration with Gradle and IntelliJ IDEA, but
    for detailed information about using Spring Boot DevTools, take a look at the
    documentation at [http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html](http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuing with our `BookPub` project, we will be adding a DevTools module
    to the main build configuration by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `build.gradle` file located at the root of
    the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After application startup, you might notice in the console log an output warning
    about the inability to register with Spring Boot admin (unless you have one running)
    that looks like this: Failed to register application as Application.... Let''s
    make a live change to the `application.properties` file located in the `build/resources/main`
    directory from the root of our project and add a property entry with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Without doing anything else, upon saving the file, we should see the console
    log showing us that the application context is being restarted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have probably learned by now, when we add a `spring-boot-devtools` module
    as a dependency there is some autoconfiguration magic that takes place to add
    a number of components. A number of listeners and autoconfigurations extend the
    application context to handle the code changes and do appropriate restarts and
    reloads, both local and remote.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, we did a quick test to make sure the restart functionality worked
    and everything had been configured by making a property change in the `application.properties`
    file. You have probably noticed that instead of making the change in `src/main/resources/application.properties`,
    we made the change to the compiled version located under the `build/resources/main`
    directory. The reason for this was because of the property placeholder replacements
    for the `info.` block that we used during the Gradle build phase. If we were to
    only make a change in the original file and use the IntelliJ compile option, it
    would not perform the required replacements and thus result in a restart failure.
  prefs: []
  type: TYPE_NORMAL
- en: When the DevTools are enabled, the application after being started, begins to
    monitor the classpath for changes to the classes that are on that classpath. When
    any class or a resource changes, it will serve as a trigger for DevTools to reload
    the application by refreshing the classloader containing the project's codebase
    (which is not the same classloader that holds the classes from the static dependency
    artifacts).
  prefs: []
  type: TYPE_NORMAL
- en: 'See the detailed explanation of the inner workings at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart](http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart)'
  prefs: []
  type: TYPE_NORMAL
- en: After the reloadable classloader has completed the refresh, the application
    context gets restarted automatically, thus effectively causing the application
    restart.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring LiveReload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those who work on frontend web applications will probably agree that being able
    to automatically reload the page once the backend code or resource change has
    taken place will save a few clicks and prevent situations where a forgotten reload
    leads to wasteful debugging efforts and chasing an error that does not exist.
    Thankfully, DevTools comes to the rescue by providing a LiveReload server implementation,
    which can be used together with a LiveReload browser extention to automatically
    reload the page when the backend change occurs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the DevTools module is added to the build dependencies, the LiveReload server
    has been automatically started. We do, however, need to install and enable the
    browser extensions by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Unless the browser already has the LiveReload extension installed, go to [http://livereload.com/extensions/](http://livereload.com/extensions/)
    and install the appropriate extension for your browser of choice (Firefox, Safari,
    and Chrome are supported).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Internet Explorer users, there is a third-party extension available that
    can be found at [https://github.com/dvdotsenko/livereload_ie_extension/downloads](https://github.com/dvdotsenko/livereload_ie_extension/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: After the extension is installed, it typically needs to be enabled on the page
    by clicking a button in the toolbar. This is what it would look like in the Chrome
    browser:![](img/8114390a-7101-4692-b995-d33a1fe19d56.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After enabling the extension, we can go ahead and make another change as we
    did in the previous recipe (or any other code or resource change), or simply execute
    the `touch build/resources/main/application.properties` command. We should see
    the application reload taking place on the backend as well as the browser page
    reloading after.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the addition of the LiveReload browser extension, and a running LiveReload
    server embedded into our `BookPub` application, the browser is now capable of
    connecting to the backend server using a web socket to monitor changes. When the
    Spring Boot DevTools detects a change that should trigger a reload, it will trigger
    the reload as well as send a notification to the browser to reload the page as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: If there is ever a need to disable the LiveReload part of the DevTools functionality,
    it can easily be achieved by adding the  `spring.devtools.livereload.enabled=false`
    property via any of the supported configuration options, be that a property file,
    environment variable, or a system property.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dynamic application restart triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we have looked into the basic capabilities of DevTools
    when it comes to restarting the application upon code or resource change and communicating
    to the browser to reload the page. This section will address the various configuration
    options that we can leverage to indicate to Spring Boot DevTools exactly what
    we want those events to be triggered by, and when.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, adding a DevTools module to a project will make it monitor all
    the classes or resources, which could become undesired behavior, especially when
    it comes to multi-module repositories. This becomes true when building and launching
    projects from within an IDE like IntelliJ or Eclipse. We need to tell DevTools
    to exclude the `db-count-starter` sub-module in our project from the watch list
    by adjusting the configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file named `spring-devtools.properties` under the `db-count-starter/src/main/resources/META-INF`
    directory from the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next we need to launch our application from within an IDE by opening the `BookPubApplication`
    class located under the `src/main/java/com/example/bookpub` directory from the
    root of our project and starting the `main(String[] args)` method either in **run**
    or **debug** mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `db-count-starter` module excluded, we can safely make a change to
    a file, for example a `spring.factories` resource located under the `db-count-starter/build/resources/main/META-INF`
    directory from the root of our project, only to see the application not being
    restarted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to completely disable the restart capability, we can do so by adding
    the following property to `application.properties` located under the `src/main/resources`
    directory from the root of our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After relaunching our application, even the changes to the `build/resources/main/application.properties`
    file, which is what's being loaded from the classpath, will not trigger the application
    restart
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we have looked at a number of different reload trigger configurations,
    so let''s look at each of them individually to understand where best to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.devtools.restart.enabled`: This property offers the simplest of controls,
    fully enabling or disabling the restart functionality of DevTools. With the value
    of `false`, no restart of the application will take place, regardless of the class
    or resource changes on the classpath.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.devtools.restart.exclude`: This property provides an ability to stop
    specific classpaths from being reloaded. This property accepts values in a comma-separated
    form using the Ant Path matching pattern style. The default exclude value is `"META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.devtools.restart.additional-exclude`: This property provides the convenience
    of being able to add to the default excludes list without having to copy/paste
    the default values, but rather simply adding to them while retaining the original
    defaults. It takes the same comma-separated Ant Path matching pattern style of
    input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.devtools.restart.additional-paths`: This property provides the ability
    to watch for resources that are outside of the classpath. For example, this could
    be a `config` directory that gets loaded at application startup, and you want
    to restart the application if the config entry changes. It takes a comma-separated
    list of absolute file paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.devtools.restart.poll-interval`: This property specifies how long to
    pause, in milliseconds, between checking for classpath changes. The default value
    is `1000` milliseconds, but if there is a need to save some CPU cycles, this will
    do the trick.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.devtools.restart.quiet-period`: This property controls how much time
    should pass, in milliseconds, without any changes to the classpath before the
    restart will take place. This is needed to ensure the restarts don''t get overwhelming
    if there are continuous changes taking place. The default value is `400` milliseconds,
    but it can be changed if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.devtools.restart.trigger-file`: This property provides explicit control
    over when a restart happens by watching a `trigger` file for change. This is useful
    for situations where the classpath gets continuously changed, and you don''t want
    to get caught in a restart loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding property settings listed are usually shared between all the
    application projects that developers work on, so DevTools provides the ability
    to have global properties defined in this, making it convenient to share the development
    configurations across many projects without having to copy/paste the same values
    in all the different codebases.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, this capability is implemented as `PropertySource`, which gets added
    to the top of the configuration precedence hierarchy. This means that not only
    the `spring.devtools` configuration family, but any property added to the global
    file will be applied to all applications using DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to control reload triggers is with the use of `META-INF/spring-devtools.properties`
    with the `restart.exclude.<name>` and `restart.include.<name>` configurations
    inside them. By default, the restart of the application only gets triggered by
    changes to the actual classes or resources that are directly on the classpath
    and not bundled into JARs. This allows you to keep the majority of the classes
    in the non-reloadable base classloader, greatly limiting the number of entries
    that need to be monitored for changes.
  prefs: []
  type: TYPE_NORMAL
- en: In situations where developers work with multiple projects that are dependent
    on each other, or work in a multi-module repository, like the `BookPub` one, it
    might be desirable to add some JARs into a reloadable classloader and watch them
    for change. This would typically be applied to dependencies that point to the `build/libs`
    or `target` directories, where the JARs inside them are a direct result of a build
    task execution and typically get rebuilt frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case, which we explored in this recipe, is the inclusion or exclusion
    of `build/classes` or `target/classes` from the watch list. If a multi-module
    project is loaded in an IDE, it is common for the classpath to contain direct
    reference to the build directories of the sub-modules instead of the compiled
    JAR artifact, and depending on the use case, we might or might not choose to include
    or exclude those from triggering the reload.
  prefs: []
  type: TYPE_NORMAL
- en: The `<name>` part of the keys is not important as long as it is unique, because
    all the `META-INF/spring-devtools.properties` files will be loaded as composites,
    regardless whether if they live inside the JARs or right in the project. The suggested
    approach is to use a sub-module/artifact name, as it will typically ensure uniqueness.
    If more than one pattern applies, the name can be appended with a sequence number,
    for example `restart.exclude.db-count-starter-1` and `restart.exclude.db-count-starter-2`.
    The value of each key should contain a valid regex pattern that can be evaluated
    against every entry in the classpath to determine whether that particular classpath
    URL should go into the reloadable or base classloader.
  prefs: []
  type: TYPE_NORMAL
- en: Using Remote Update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the growing popularity of Docker, more and more applications are being
    built and deployed as Docker containers. One of the great features of Docker is
    the isolation of the runtime environment from the host OS, but that same isolation
    makes it difficult to make continuous changes and test your application in a true
    environment. Each time there is a change to a property file or a Java class, one
    needs to rebuild everything, create a new Docker image, restart the container,
    and so on. That's a lot of work to be doing for every change.
  prefs: []
  type: TYPE_NORMAL
- en: Even though, unfortunately, as of version 2.0, Spring Boot has removed the capability
    of doing a remote debug, there is still the very helpful ability to remotely reload
    the code changes from within your IDE as you work on the code, without the need
    to at least rebuild the application JAR and Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: The **Remote Restart** capability provides a solution for better continuous
    development and makes it possible to do dynamic application restarts remotely,
    as if it were on a local machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have probably guessed, Remote Restart involves an agent running locally
    and sending instructions to the remote client. DevTools provides an implementation
    of such an agent—`RemoteSpringApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable Remote Restart, we need to add a property to `application.properties`
    located under the `src/main/resources` directory from the root of our project
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next step would be to create a Java application launch configuration for
    the `RemoteSpringApplication` class in the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to make sure the program arguments field has the base URL of
    the application you are trying to debug together with the port. Ensure that the
    working directory points to the main project, and the classpath of the module
    is pointing to the main project module as well.
  prefs: []
  type: TYPE_NORMAL
- en: The figure on the next page shows what such a configuration would look like
    in IntelliJ IDEA. The Eclipse IDE would have a similar form as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7503253b-f437-48e8-a5be-cbd5facb2aea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After filling out all the fields, we need to start `RemoteSpringApplication`
    from within our IDE by clicking Run. If all has been configured correctly, we
    should see a similar output in the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To simulate remoteness, we will launch the application in a separate command
    shell, executing the `./gradlew clean bootJar` command followed by executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the application has started, take a look at one of the last lines in the
    log that should look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The property value of `my.config.value` is not being set, because we don't have
    one defined in our `application.properties ` file, and we didn't use any environment
    variables or startup system property settings to set it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s pretend we need to do a live change and modify our `application.properties`
    file located under the `build/resources/main` directory from the root of our project
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should see in the console that our application has automatically restarted
    and, after all is done, we should see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might look like voodoo magic, but the science behind the Remote Restart functionality
    is pretty straightforward. Under the hood, when a DevTools module is included,
    the HTTP endpoint handler for `/.~~spring-boot!~/restart` automatically gets added.
    This allows the `RemoteSpringApplication` process to send the code change payload
    via an HTTP tunnel to the remote application and back.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that no malicious outside debug connection gets to connect to our
    remote application, the value of the `spring.devtools.remote.secret` property
    gets sent across and verified to establish the authenticity of the request.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* of the recipe, we launched the `RemoteSpringApplication` process
    with a program arguments value of `http://127.0.0.1:8080`, which is how `RemoteSpringApplication`
    knows how to communicate with our remote application. The `RemoteSpringApplication` class
    itself scans for the local file changes from an IDE by monitoring the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6* of the recipe, when we added the property to our config in the code,
    it is very important to note that we made the change to the `application.properties`
    file located in the running classpath of the `RemoteSpringApplication` class not
    under `src/main/resources`, but under the `build/resources/main` directory, where
    Gradle has placed all the compiled files—hopefully that's the same directory your
    IDE is using as a classpath to run `RemoteSpringApplication`. If that's not the
    path your IDE is using, you should make the change in the appropriate folder,
    where the IDE has compiled the classes—for IntelliJ IDEA that would be the `out/production/resources`
    directory by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If DevTools needs to be enabled inside an application running as a Docker container,
    we need to explicitly configure the `build` script to do so by adding the following
    to the `build.gradle` file in the main project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The reason we need to do this is because, by default, when a Spring Boot application
    gets re-packaged for production deployment, which is the case when building a
    Docker container image, the DevTools module is excluded from the classpath during
    build time. To prevent this from happening, we need to tell the build system to
    not exclude the module in order to take advantage of its capabilities, namely
    the Remote Restart.
  prefs: []
  type: TYPE_NORMAL
