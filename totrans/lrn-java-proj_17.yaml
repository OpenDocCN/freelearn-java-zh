- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: 'In the previous chapter, we explored the nuances of streamlined data manipulation
    and parallelized operations that utilize the power of modern multi-core processors.
    This was already a little introduction to this chapter’s topic: concurrency!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了利用现代多核处理器的强大功能进行数据操作和并行操作的细微差别。这已经是对本章主题的初步介绍：并发！
- en: Concurrency allows applications to perform multiple tasks at the same time.
    This makes the system more efficient. Any available resources can be utilized
    more efficiently, and this leads to overall improved performance. In order to
    do multiple things at the same in Java, we need to know quite a bit. That’s what
    this chapter is for!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 并发允许应用程序同时执行多个任务。这使得系统更加高效。任何可用的资源都可以更有效地利用，这导致整体性能的提高。为了在Java中同时做很多事情，我们需要了解很多。这正是本章的目的！
- en: 'Here’s what we’ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要涵盖的内容：
- en: A definition of concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发的定义
- en: Working with threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与线程一起工作
- en: Atomic classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子类
- en: The synchronized keyword
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步关键字
- en: Using locks for exclusive thread access
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁进行线程独占访问
- en: Concurrent collections
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发集合
- en: Using `ExecutorService`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ExecutorService`
- en: Common threading problems and how to avoid them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的线程问题及其避免方法
- en: This is often a dreaded (or threaded?) topic, especially for new developers,
    so don’t despair if you need to go over parts of this chapter twice. I’m going
    to try my best to carefully walk you through all the concepts you need to know.
    Unlike your applications, focus solely on this chapter and don’t do other things
    simultaneously. Let’s get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一个令人畏惧（或线程化的？）的话题，尤其是对于新开发者来说，所以如果你需要反复阅读本章的部分内容，请不要气馁。我将尽力仔细地引导你了解你需要知道的所有概念。与你的应用程序不同，请专注于本章，并且不要同时做其他事情。让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch17](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch17).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch17](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch17)。
- en: Understanding concurrency
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并发
- en: Have you ever wondered how many tasks a computer can truly run simultaneously?
    It’s tempting to say *several*, yet, in reality, a single-core computer can only
    execute one process at a given instant. This might appear as simultaneous due
    to the impressive speed at which CPUs switch between processes, thus creating
    the illusion of simultaneous multitasking.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过一台计算机可以真正同时运行多少个任务？说“几个”可能很有诱惑力，然而，实际上，单核计算机在某一时刻只能执行一个进程。这可能会因为CPU在进程之间切换的速度之快而显得像是同时多任务处理，从而产生多任务处理的错觉。
- en: Concurrency is the concept of executing multiple tasks or threads at the same
    time, rather than sequentially. In a sequential system, tasks are executed one
    after the other, with each task waiting for its predecessor to complete before
    starting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是指同时执行多个任务或线程的概念，而不是按顺序执行。在顺序系统中，任务一个接一个地执行，每个任务在开始之前都要等待其前一个任务完成。
- en: For our Java applications, concurrency refers to executing different segments
    of a program, simultaneously. The term *simultaneously* might be a little ambiguous
    here, as it could mean multiple things – and that is because concurrency can occur
    at the hardware level, such as in multi-core processors, or at the software level.
    An OS could schedule threads to run on different cores.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Java应用程序来说，并发指的是同时执行程序的不同部分。这里的“同时”可能有点模糊，因为它可能意味着多种含义——这是因为并发可以在硬件级别发生，例如在多核处理器中，或者可以在软件级别发生。操作系统可以安排线程在不同的核心上运行。
- en: 'Which one we mean exactly depends on the type of concurrency being employed.
    An overview of them can be found in *Figure 17**.1*. These can be any of the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们具体指的是哪种并发类型取决于所采用的并发方式。它们的一个概述可以在*图17**.1*中找到。这些可以是以下任何一种：
- en: Multiprocessing
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多进程
- en: Multitasking
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多任务处理
- en: Multithreading
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: First off, let’s discuss multiprocessing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论多进程。
- en: Multiprocessing
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多进程
- en: In the context of **multiprocessing**, the simultaneous execution of diverse
    processes is facilitated by the presence of multiple CPUs. Each CPU independently
    executes its own process. To draw a parallel from our daily life, consider two
    individuals managing a household where one person is occupied with childcare,
    while the other is out for grocery shopping. They are both a “CPU,” each taking
    care of a unique task concurrently.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在**多进程**的背景下，多个 CPU 的存在使得同时执行多种进程变得容易。每个 CPU 独立执行自己的进程。为了从我们的日常生活中找到类比，考虑两个人管理一个家庭的情况，其中一个人忙于照顾孩子，而另一个人外出购物。他们都是“CPU”，同时并行处理独特的任务。
- en: Multitasking
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多任务
- en: The next concept is **multitasking**, where the term “simultaneous” obtains
    a slightly different connotation. It implies rapid alternating execution rather
    than literal simultaneous execution. Imagine a scenario where a person is cooking
    and intermittently stepping out to hang laundry while the pot is cooking (safely
    away from the kids, of course). They are the “CPU,” continuously switching between
    two (or more) tasks, giving the illusion of simultaneous progression. This, however,
    doesn’t exactly constitute parallel execution, but it is a very efficient use
    of resources for sure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的概念是**多任务**，其中“同时”这个词获得了一个稍微不同的含义。它意味着快速交替执行，而不是字面上的同时执行。想象一个场景，一个人在做饭的同时，不时地出去晾衣服（当然是在远离孩子的安全地方）。他们是“CPU”，在两个（或更多）任务之间不断切换，给人一种同时进步的错觉。然而，这并不完全构成并行执行，但确实是一种非常有效的资源利用方式。
- en: Multithreading
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程
- en: Last but not least, we have **multithreading** – and that happens to be our
    primary focus. Multithreading involves different sections of the program running
    on different threads of execution. This can take place in both single- and multi-CPU
    environments. Both previously mentioned everyday scenarios can exemplify multithreading.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们有**多线程**——这恰好是我们的主要关注点。多线程涉及程序的不同部分在不同的执行线程上运行。这可以在单 CPU 和多 CPU
    环境中发生。前面提到的两个日常场景都可以作为多线程的例子。
- en: '![Figure 17.1 - Schematic overview of multiprocessing, multitasking, and multithreading](img/B19793_17_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.1 - 多进程、多任务和多线程的示意图](img/B19793_17_01.jpg)'
- en: Figure 17.1 - Schematic overview of multiprocessing, multitasking, and multithreading
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 - 多进程、多任务和多线程的示意图
- en: We will delve deeper into the concept of threads shortly. Let’s first talk about
    why we need to have concurrency in our applications (or lives actually!).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将深入探讨线程的概念。首先，让我们谈谈为什么我们需要在我们的应用程序（或者实际上是我们生活中！）中实现并发。
- en: Importance of concurrency in modern applications
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代应用程序中并发的重要性
- en: To help you visualize concurrency in computing, consider the way your computer
    runs multiple programs at the same time. You might have a browser, an email client,
    a text editor, a code editor, and Slack running concurrently. This kind of operation
    demands the ability to manage multiple processes concurrently. It’s also seen
    within applications, such as an IDE processing your input while executing code.
    Without some sort of concurrency, stopping a script with an infinite loop would
    be impossible, as the IDE would be too consumed with the execution of the infinite
    loop to deal with your click on the button.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您可视化计算中的并发，考虑您的计算机同时运行多个程序的方式。您可能同时运行浏览器、电子邮件客户端、文本编辑器、代码编辑器和 Slack。这种操作需要能够同时管理多个进程的能力。这种操作也存在于应用程序中，例如
    IDE 在执行代码的同时处理您的输入。如果没有某种并发机制，停止具有无限循环的脚本将是不可能的，因为 IDE 会过于专注于无限循环的执行，而无法处理您点击按钮的操作。
- en: And let’s think of web services for a second; imagine a web server processing
    hundreds, even thousands, of requests concurrently. Such an operation would be
    unfeasible without concurrency, so it’s safe to say that concurrency is an essential
    aspect of our day-to-day computer use and even daily life!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再思考一下网络服务；想象一个网络服务器同时处理数百甚至数千个请求。没有并发机制，这样的操作将是不切实际的，所以可以说，并发是我们日常计算机使用甚至日常生活中的一个基本方面！
- en: 'Let’s sum up the advantages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下优势：
- en: '**Improved performance**: Applications can complete operations faster'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能提升**：应用程序可以更快地完成操作'
- en: '**Responsiveness**: Applications remain responsive even when performing resource-intensive
    tasks (as background threads can handle these tasks without blocking the main
    thread)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：即使在执行资源密集型任务时，应用程序也能保持响应（因为后台线程可以处理这些任务，而不会阻塞主线程）'
- en: '**Resource utilization**: More efficient use of system resources by taking
    advantage of multi-core processors and other hardware resources'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源利用**：通过利用多核处理器和其他硬件资源，更有效地使用系统资源'
- en: Advantages like this, make real-time execution use cases possible. At this point,
    you might be very enthusiastic about concurrency. And you should be! However,
    employing concurrency in our Java applications does come with its own set of costs
    and complexities. Let’s talk about it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的优势使得实时执行用例成为可能。在这个时候，你可能会非常热衷于并发。你应该这样！然而，在我们的 Java 应用程序中采用并发确实带来了一组自己的成本和复杂性。让我们来谈谈它。
- en: Challenges in concurrent programming
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发编程的挑战
- en: 'I’ve said it before, and I’ll say it again: every magic trick comes with a
    price. While concurrency offers many benefits, it also introduces challenges that
    can make concurrent programming complex and even error-prone. We even have some
    errors that are unique to concurrent environments. We’ll mention them in more
    detail later, but it’s good to keep these in mind before diving in:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我以前说过，现在再说一遍：每个魔术技巧都有代价。虽然并发提供了许多好处，但它也引入了可能使并发编程复杂甚至容易出错的挑战。我们甚至有一些在并发环境中独有的错误。我们稍后会更详细地提到它们，但在深入之前，记住这些是有好处的：
- en: '**Data race**: When multiple threads access the same memory location in a non-synchronized
    manner and at least one of these threads performs a write. For example, one thread
    wants to read the value and concludes the value is 5, but the other thread increments
    to 6\. This way, the former thread doesn’t have the latest value.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据竞争**：当多个线程以非同步方式访问同一内存位置，并且至少有一个线程执行写操作时。例如，一个线程想要读取值并得出结论该值是 5，但另一个线程将其增加到
    6。这样，前面的线程就没有最新的值。'
- en: '**Race condition**: A problem that occurs due to the timing and order of events.
    This problematic order of events can influence the correctness of the outcome.
    A race condition typically requires external input, from the OS, hardware, or
    even user. It can, for example, happen when two users try to sign up with the
    same username at the same. When not handled well, this can lead to unpredictable
    and undesirable results.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**：由于事件的时间和顺序而出现的问题。这种问题的事件顺序可能会影响结果的正确性。竞态条件通常需要来自操作系统、硬件甚至用户的输入。例如，当两个用户试图使用相同的用户名同时注册时，这种情况可能会发生。如果处理不当，这可能会导致不可预测和不受欢迎的结果。'
- en: '**Deadlocks**: When two or more threads are waiting for each other to release
    a resource, a deadlock can occur, causing the application to become unresponsive.
    For example, when you think your friend will call you and you wait until they
    do, and your friend thinks you’ll call them and they wait until you do, nothing
    happens, and the friendship is stuck.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**：当两个或更多线程都在等待对方释放资源时，可能会发生死锁，导致应用程序无响应。例如，当你认为你的朋友会给你打电话，你一直等到他们这样做，而你的朋友认为你会给他们打电话，他们也一直等到你这样做，什么也没有发生，友谊就陷入了僵局。'
- en: '**Livelocks**: Similar to deadlocks, livelocks occur when two or more threads
    are stuck in a loop, unable to progress due to constantly changing conditions.
    Let’s say you and your friend said you’d meet up at a church in the city center.
    You are at church *a*, and your friend is at church *b*. You wonder whether your
    friend is at church *b* and you walk there. Your friend wonders if you are at
    church *a* and walks there. (And you take a different path and don’t bump into
    each other.) You don’t find each other at the church and keep on walking from
    church *a* to church *b*. Not a very effective use of resources (but all the walking
    is probably great for your health!).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活锁**：与死锁类似，当两个或更多线程陷入循环，由于不断变化的条件而无法前进时，会发生活锁。比如说，你和你的朋友说你们会在市中心的一个教堂见面。你在教堂
    *a*，你的朋友在教堂 *b*。你怀疑你的朋友是否在教堂 *b*，于是你走去那里。你的朋友怀疑你是否在教堂 *a*，也走去那里。（而你选择了不同的路线，没有碰到彼此。）你们在教堂没有找到对方，继续从教堂
    *a* 走到教堂 *b*。这不是很有效的资源利用（但所有这些走路可能对你的健康都有好处！）'
- en: 'Starvation: When a thread is unable to obtain the resources it needs to progress,
    it can experience starvation, leading to poor application performance and inefficient
    use of resources. A real-life example could be a busy bar where multiple people
    are trying to acquire a drink from the bartender. There are a lot of people at
    the bar; the people represent threads. The bartender is serving the people who
    shout the loudest (comparable to threads with higher priority). The shy person
    that doesn’t stand out experiences “starvation” (or thirst) because he doesn’t
    get access to the shared resource (the bartender).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 饥饿：当一个线程无法获得其进步所需的资源时，它可能会经历饥饿，导致应用程序性能下降和资源使用效率低下。一个现实生活中的例子可能是一个繁忙的酒吧，许多人试图从酒保那里获取饮料。酒吧里的人很多；这些人代表线程。酒保正在为那些喊得最响亮的人服务（相当于具有较高优先级的线程）。那个不出众的害羞的人会经历“饥饿”（或渴望），因为他无法访问共享资源（酒保）。
- en: 'Challenges are there to be overcome! Java provides various concurrency constructs
    and tools, which we will explore throughout this chapter. I will refer to these
    aforementioned problems every now and then. At the end of the chapter, you’ll
    even see some examples of how to break things! But first, let’s talk about a key
    concept of concurrency: threads!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战是存在的！Java提供了各种并发构造和工具，我们将在本章中探讨这些内容。我会不时地提到上述问题。在本章结束时，你甚至将看到一些破坏事物的例子！但首先，让我们谈谈并发的一个关键概念：线程！
- en: Working with threads
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的工作
- en: Let’s finally get to explaining *threads*. Threads are sequences of executed
    instructions, representing the most fundamental units of execution. Each thread
    follows a certain path through the code. The threads perform specific tasks within
    processes. A process is typically composed of multiple threads.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最终来解释一下*线程*。线程是一系列执行指令的序列，代表着执行的最基本单元。每个线程都遵循代码中的特定路径。线程在进程内执行特定任务。一个进程通常由多个线程组成。
- en: To give you an example, the programs we’ve created so far had one user-created
    thread (and the user in this case is the developer). The thread went through the
    lines of code in a certain order; for example, when a method was called, the thread
    would execute that method before continuing with the code that was directly on
    the next line after the method call. This is the path of execution of the thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们迄今为止创建的程序都有一个用户创建的线程（在这种情况下，用户是开发者）。线程按照一定的顺序遍历代码行；例如，当调用一个方法时，线程会在继续执行方法调用后直接位于方法之后的下一行代码之前执行该方法。这是线程的执行路径。
- en: When multiple threads are running, multiple paths of execution are being walked
    through your code, and that’s why multiple things are happening at the same time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程运行时，代码中的多个执行路径正在被遍历，这就是为什么同一时间会发生多件事情的原因。
- en: In order to make this possible, we’ll need duplicates of certain Java constructs.
    For example, we cannot have two threads using the same stack. That’s why every
    thread has its own stack. We will not dive into the details of the Java memory
    model here. However, it helps to at least realize that while each thread has its
    own stack, they share the heap with other threads.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这成为可能，我们需要某些Java结构的副本。例如，我们不能有两个线程使用相同的栈。这就是为什么每个线程都有自己的栈。我们不会深入探讨Java内存模型的细节。然而，至少要意识到，尽管每个线程都有自己的栈，但它们与其他线程共享堆。
- en: In order to make this digestible for your brain, we’ll explain the theory with
    some not-too-interesting but easy-to-follow examples.. We’ll start with threads.
    There are multiple ways to create and start a thread. Let’s see how we can create
    a thread using the `Thread` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你们的大脑更容易消化，我们将用一些不太有趣但易于理解的例子来解释这个理论。我们将从线程开始。创建和启动线程有多种方式。让我们看看如何使用`Thread`类来创建一个线程。
- en: The Thread class
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Thread`类'
- en: 'Possibly the simplest way to create a thread is by extending the `Thread` class.
    The `Thread` class provides an entry point for your thread’s execution through
    the `run()` method. To create a custom thread, you need to define a subclass of
    `Thread` and override the `run()` method with the code that the thread should
    execute. Here’s a silly example to demonstrate this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程最简单的方法之一是通过扩展`Thread`类。`Thread`类通过`run()`方法为线程的执行提供了一个入口点。要创建一个自定义线程，你需要定义一个`Thread`的子类，并用线程应该执行的代码覆盖`run()`方法。以下是一个用于演示的愚蠢示例：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then in some other class (or even in the same but that might be confusing),
    we can create a new `MyThread` and kick off the thread execution with the `start()`
    method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在某个其他类（或者甚至是在同一个类中，但这可能会令人困惑），我们可以创建一个新的`MyThread`，并通过`start()`方法启动线程执行：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will output the following two lines, but we cannot be sure about the order:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下两行，但我们无法确定它们的顺序：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `start()` method is part of the `Thread` class that we inherited from and
    it is used to start a new thread. You could also execute the content of the `run()`
    method by calling `myThead.run()`, but that would not start a new thread! That
    would be the same thread as the one executing the `main` method, which would be
    executing the content of the `run()` method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()`方法是继承自我们的`Thread`类的一部分，用于启动一个新的线程。你也可以通过调用`myThread.run()`来执行`run()`方法的内容，但这不会启动一个新的线程！这将与执行`main`方法的同一个线程相同，这将执行`run()`方法的内容。'
- en: We started with this way to create a thread because it is easiest to understand.
    It’s definitely not the most common way. It’s more common to implement the `Runnable`
    interface. Let’s see how to do that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式创建线程是因为它最容易理解。这绝对不是最常见的方式。更常见的是实现`Runnable`接口。让我们看看如何实现它。
- en: The Runnable interface
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可运行的接口
- en: 'An alternative approach to creating threads is by implementing the `Runnable`
    interface. This is a built-in functional interface that can be used to create
    threads in Java. The `Runnable` interface has a single method, `run()`, that you
    must implement in your class when you extend this interface. Instead of extending
    the `Thread` class, you pass an instance of your `Runnable` implementation to
    a `Thread` object. Here’s an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程的另一种方法是实现`Runnable`接口。这是一个内置的函数式接口，可以用于在Java中创建线程。`Runnable`接口有一个单一的方法`run()`，当你扩展此接口时，必须在你的类中实现此方法。与扩展`Thread`类不同，你将你的`Runnable`实现实例传递给`Thread`对象。以下是一个示例：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And again, we can now instantiate `MyRunnable` at another spot. The second
    step is different though; we are going to instantiate the `Thread` class and pass
    our instance of `MyRunnable` to its constructor. This way, when we start the instance
    of the thread, whatever we specified in the `run()` method of the `Runnable` instance
    will be executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们现在可以在另一个位置实例化`MyRunnable`。然而，第二步是不同的；我们将实例化`Thread`类，并将我们的`MyRunnable`实例传递给其构造函数。这样，当我们启动线程实例时，我们在`Runnable`实例的`run()`方法中指定的任何内容都将被执行：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will output the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And again, to execute what is in `MyRunnable`’s `run` method, we could have
    written `myRunnable.run()`, but this also would not have started a new thread!
    Let’s prove that we actually start a new thread. Every thread has a unique ID.
    By outputting the ID of the thread in the `run` method, we can prove it’s a different
    thread. Here’s the adjusted example for that:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了执行`MyRunnable`的`run`方法中的内容，我们本来可以写`myRunnable.run()`，但这也不会启动一个新的线程！让我们证明我们实际上启动了一个新的线程。每个线程都有一个唯一的ID。通过在`run`方法中输出线程的ID，我们可以证明它是一个不同的线程。以下是调整后的示例：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here’s our adjusted `Main` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的调整后的`Main`类：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will print the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Please note that the IDs might be different for you, but they will also be
    two different threads. The thread IDs remain consistent across multiple executions
    due to some background threads started by Java such as the garbage collector.
    Say we change the `start()` method to `run()`, like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于你来说，ID可能不同，但它们也将是两个不同的线程。由于Java启动的一些后台线程（如垃圾收集器）的原因，线程ID在多次执行中保持一致。假设我们将`start()`方法改为`run()`，如下所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The IDs are the same; this is the result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ID是相同的；这是结果：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is already a bit more common, but more often we don’t create a class for
    `Runnable` and rather implement `Runnable` with a lambda expression. As you might
    be able to recall from the Lambda expression *Chapters 15* and *16*, we can implement
    any functional interface with a lambda expression. Let’s see how that is done.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经相当常见了，但更常见的情况是我们不创建一个`Runnable`的类，而是使用Lambda表达式实现`Runnable`。你可能还记得从第15章和第16章的Lambda表达式章节中，我们可以使用Lambda表达式实现任何函数式接口。让我们看看这是如何实现的。
- en: Lambda expressions with Runnable
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有Runnable的Lambda表达式
- en: 'Since the `Runnable` interface is a functional interface with a single method,
    you can use lambda expressions to create and run threads more concisely. Here’s
    an example using a lambda expression:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Runnable`接口是一个只有一个方法的函数式接口，你可以使用Lambda表达式更简洁地创建和运行线程。以下是一个使用Lambda表达式的示例：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we don’t need a separate class for `Runnable` anymore. We can
    just do it *on the fly*. Here’s the output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不再需要为`Runnable`创建一个单独的类。我们可以在*现场*完成它。以下是输出：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And as I mentioned a few times before, if you use `run()` instead of `start()`,
    you are getting the same output in this case, but this is not done by a new thread.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到过几次，如果你使用`run()`而不是`start()`，在这种情况下你会得到相同的输出，但这并不是由一个新线程完成的。
- en: These are the basics of how to create threads. Let’s see how we can control
    the execution with `sleep()` and `join()`. So, join me for some sleep!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建线程的基本方法。让我们看看我们如何通过`sleep()`和`join()`来控制执行。所以，和我一起进入睡眠状态吧！
- en: Thread management – sleep() and join()
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程管理——sleep()和join()
- en: This might be a weird statement, but threads can go to *sleep*. This means that
    the execution of the thread gets paused for a short while. Before we dive into
    how to do this, it is worth noting that this is something that is often considered
    to be a code smell. This means that it can be a problematic solution to, for example,
    a data race or a challenge with loading times. However, sometimes you will need
    this – for example, to slow down a background thread. Just make sure to proceed
    with caution here. Let’s see how we can make our threads go to sleep now.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个奇怪的说法，但线程可以进入*睡眠*状态。这意味着线程的执行会暂停一段时间。在我们深入探讨如何做到这一点之前，值得注意的是，这通常被认为是一种代码异味。这意味着它可能是解决数据竞争或加载时间挑战等问题的有问题的解决方案。然而，有时你将需要这样做——例如，为了减慢后台线程。只是确保在这里谨慎行事。现在让我们看看我们如何让我们的线程进入睡眠状态。
- en: The Thread.sleep() method
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Thread.sleep()方法
- en: 'The `Thread.sleep()` method is a static method that causes the currently executing
    thread to go to sleep. That means pausing its execution for a specified period.
    It is useful for simulating delays, allowing other threads to execute, or performing
    time-based operations. The `sleep()` method takes a single argument, the duration
    of the sleep in milliseconds. Here’s an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.sleep()`方法是一个静态方法，它会导致当前正在执行的线程进入睡眠状态。这意味着暂停其执行一段时间。这对于模拟延迟、允许其他线程执行或执行基于时间的操作很有用。`sleep()`方法接受一个单一参数，即睡眠的持续时间（以毫秒为单位）。以下是一个示例：'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need the `try`/`catch` block here because `sleep()` can be interrupted. This
    interrupt would result in the checked exception, `InterruptedException`, being
    thrown.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里使用`try`/`catch`块，因为`sleep()`可以被中断。这种中断会导致检查型异常`InterruptedException`被抛出。
- en: Handling InterruptedException
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`InterruptedException`
- en: Imagine if the main thread decides that the execution is taking too long and
    wants to end the program. It can suggest the secondary thread stops by using the
    `interrupt` method. If the instance is called t, this can be done with `t.interrupt()`.
    Interrupting a sleeping thread throws `InterruptedException`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设主线程决定执行时间过长并想要结束程序，它可以通过使用`interrupt`方法建议次级线程停止。如果实例被命名为t，这可以通过`t.interrupt()`来实现。中断一个正在睡眠的线程会抛出`InterruptedException`。
- en: This is a checked exception that you must handle if you use the `Thread.sleep()`
    method. We can also make our thread wait for another thread to be done. This is
    done with the `join()` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个检查型异常，如果你使用`Thread.sleep()`方法，你必须处理它。我们也可以让我们的线程等待另一个线程完成。这是通过`join()`方法完成的。
- en: Using the join() method
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`join()`方法
- en: 'Threads can wait until another thread is done. The `join()` method allows the
    calling thread to wait until the specified thread has finished its execution.
    This is useful when you need to ensure that a particular thread has completed
    its work before proceeding. Here’s an example where the main thread is waiting
    for thread `t1`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以等待另一个线程完成。`join()`方法允许调用线程等待直到指定的线程完成其执行。这在需要确保在继续之前特定线程已完成其工作时很有用。以下是一个示例，其中主线程正在等待线程`t1`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will output the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, as you can see, `t1.join()` is called. This makes the main thread wait until
    `t1` is done executing (and that includes 2 seconds of sleep) before the main
    thread continues. The main thread can also wait for a specified amount of time,
    for example, 1 second, by calling `t1.join(1000)` instead. This is a bit safer
    because our program would get stuck if `t1` for some reason hung indefinitely.
    You should go ahead and try to remove `join()` and run the program a few times
    to inspect the behavior and see if you can get it to hang indefinitely.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如您所见，调用了`t1.join()`。这使得主线程等待`t1`完成执行（包括2秒的睡眠时间）之后，主线程才继续。主线程也可以通过调用`t1.join(1000)`来等待指定的时间，例如1秒。这要安全一些，因为如果`t1`由于某种原因无限期地挂起，我们的程序会卡住。你应该尝试移除`join()`并运行程序几次，以检查行为并看你是否能让它无限期地挂起。
- en: As you can see, we also need to catch `InterruptedException` when we use the
    `join()` method. This is in case the calling thread gets interrupted while waiting
    for the other thread to be done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们使用`join()`方法时，也需要捕获`InterruptedException`。这是在调用线程在等待其他线程完成时被中断的情况下。
- en: Let’s have a look at how to avoid (or solve) some common issues with read and
    write operations in concurrent environments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何避免（或解决）并发环境中读写操作的一些常见问题。
- en: Atomic classes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子类
- en: Data integrity can easily be a problem in a concurrent program. Imagine two
    threads reading a value, and then both changing it and overwriting each other’s
    change right after. This could, for example, result in a counter that ends up
    being only one higher, while it should be two higher. Data integrity gets lost!
    This is where atomic classes come in.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发程序中，数据完整性可能很容易成为问题。想象两个线程读取一个值，然后都更改它，并在之后立即覆盖彼此的更改。例如，这可能导致计数器最终只增加了一个，而它应该是增加两个。数据完整性丢失！这就是原子类发挥作用的地方。
- en: Atomic classes are used for atomic operations. That means that the read (getting
    a value) and write (changing a value) are considered one operation instead of
    two separate ones. This avoids the problems with data integrity that we just demonstrated.
    We’ll briefly discuss how to use `AtomicInteger`, `AtomicLong`, and `AtomicReference`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 原子类用于原子操作。这意味着读取（获取值）和写入（更改值）被视为一个操作，而不是两个独立的操作。这避免了我们刚刚演示的数据完整性问题。我们将简要讨论如何使用`AtomicInteger`、`AtomicLong`和`AtomicReference`。
- en: AtomicInteger, AtomicLong, and AtomicReference
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AtomicInteger、AtomicLong和AtomicReference
- en: There are several atomic classes for basic data types. We have `AtomicInteger`
    to represent an integer value and support atomic operations on it. Similarly,
    we have `AtomicLong` for the `Long` type. We have `AtomicReference` for references
    to an object and to support atomic operations on it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原子类用于基本数据类型。我们有`AtomicInteger`来表示整数值并支持对其执行原子操作。同样，我们有`AtomicLong`用于`Long`类型。我们有`AtomicReference`用于对象的引用并支持对其执行原子操作。
- en: 'These atomic classes provide methods for performing atomic operations, such
    as `get`, `set`, `compareAndSet`, and various arithmetic operations. Let’s have
    a look at an example that would be problematic without `AtomicInteger`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原子类提供了执行原子操作的方法，例如`get`、`set`、`compareAndSet`以及各种算术操作。让我们看看一个没有`AtomicInteger`会出问题的例子：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code will print the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将打印以下输出：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Without `AtomicInteger`, the value of the `counter` at the end of the program
    would differ. It could be 14387, 15673, 19876, and so on. (It could not be more
    than 20000). This is because multiple threads would read it at the same time (so
    reading the same value) and then update it in the next operations, thereby potentially
    writing a lower value than the current value of the `counter`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`AtomicInteger`，程序结束时`counter`的值可能会有所不同。它可能是14387、15673、19876等等。（它不能超过20000）。这是因为多个线程会同时读取它（所以读取相同的值），然后在下一个操作中更新它，从而可能写入一个比`counter`当前值更低的值。
- en: To illustrate, picture this. You’re in a room with two friends. On the table
    is a hat with a piece of paper in it. The piece of paper is folded and has a number
    on it, the number 4\. All three of you need to increment the value by 1\. If your
    friend reads the value, then puts the number back in the hat, and then starts
    to search the house for a piece of paper and a pen. Your other friend might read
    the value right after, before your friend had a chance to increment the number.
    The other friend has a piece of paper and pen available (quite a friend to not
    share with the other friend) and replaces the piece of paper with the new value
    5\. You then go next, read the value, see that it is 5, get your piece of paper
    and pen, write down the number 6 and put it in the hat. The other friend then
    finally comes back, and updates the piece of paper with the new value, which,
    according to his knowledge from when he was reading, should be 5\. The final value
    in the hat is then 5\. Even though it has been 6 before, it went back down. You
    and your friends behave like threads that treat reading and writing as two different
    operations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，想象一下。你和两个朋友在一个房间里。桌子上有一个帽子，里面有一张纸。纸是折叠的，上面有一个数字，数字 4。你们三个人都需要将值增加 1。如果你的朋友读取了值，然后把它放回帽子，然后开始在房子里找纸和笔。你的另一个朋友可能在你的朋友有机会增加数字之前就读取了值。你的另一个朋友有一张纸和一支笔可用（真是个好朋友，不与另一个朋友分享），并用新值
    5 替换了纸条。然后你接着去，读取值，看到它是 5，拿出你的纸和笔，写下数字 6 并将其放入帽子。然后你的另一个朋友最后回来，并更新纸条的新值，根据他阅读时的知识，应该是
    5。帽子中的最终值是 5。尽管之前是 6，但它又回到了 5。你和你的朋友的行为就像线程，它们将读取和写入视为两个不同的操作。
- en: Let’s say that you are not just friends, but you are atomic friends. This would
    mean that you would treat reading and writing as one action. So instead of putting
    the piece of paper back in the hat right after reading it, you would not put it
    back before updating it with the new value. So now, if you would all have to increment
    it by 1, there would be no confusion and the value would end up being 7.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你们不仅是朋友，而且是原子朋友。这意味着你们会将读取和写入视为一个动作。所以，在读取之后，你们不会在更新新值之前将纸条放回帽子中。因此，现在，如果你们所有人都必须将其增加
    1，就不会有混淆，值最终会是 7。
- en: We have a Java way of doing this with the atomic classes. In the snippet above,
    the `getAndIncrement` method ensures that two threads cannot access the counter
    at the same time and guarantees that the counter will have the correct value.
    This is because getting and incrementing are not two separate operations, but
    one atomic operation. This is why atomic classes are particularly useful in multi-threaded
    environments where you need to ensure consume shared resources without using explicit
    synchronization. However, we can always work with explicit synchronization. Let’s
    explore the `synchronized` keyword next.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原子类以 Java 方式完成这项操作。在上面的代码片段中，`getAndIncrement` 方法确保两个线程不能同时访问计数器，并保证计数器将具有正确的值。这是因为获取和增加不是两个独立的操作，而是一个原子操作。这就是为什么原子类在需要确保在不使用显式同步的情况下消费共享资源的多线程环境中特别有用。然而，我们始终可以使用显式同步。接下来，让我们探讨
    `synchronized` 关键字。
- en: The synchronized keyword
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`synchronized` 关键字'
- en: As we’ve just seen, working with many threads can bring potential new problems,
    such as data integrity. The **synchronized** keyword is a Java keyword that uses
    a lock mechanism to achieve synchronization. It is used to control access to critical
    sections of code for different threads. When a thread is inside a synchronized
    method or block, no other thread can enter any of the synchronized methods for
    the same object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，与许多线程一起工作可能会带来潜在的新问题，例如数据完整性。`synchronized` 关键字是 Java 中的一个关键字，它使用锁机制来实现同步。它用于控制不同线程对代码关键部分的访问。当一个线程在同步方法或块内部时，其他线程不能进入同一对象的任何同步方法。
- en: 'To understand the need for synchronization, let’s consider another simple concurrent
    counting scenario where unexpected outcomes can occur. We have a class named `Count`
    with a static `counter` variable. This class also has a method, `incrementCounter`,
    which increments the value of `counter` by one:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解同步的需求，让我们考虑另一个简单的并发计数场景，其中可能会出现意外结果。我们有一个名为 `Count` 的类，其中有一个静态的 `counter`
    变量。这个类还有一个方法，`incrementCounter`，它将 `counter` 的值增加 1：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This program, when run in a `for` loop 10 times in a single-threaded environment,
    will behave as expected, incrementing the counter sequentially from 0 to 10\.
    The value of the id of the thread would also be the same since it’s a single thread.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序在单线程环境中以`for`循环运行10次，将按预期行为，将计数器顺序地从0增加到10。线程的ID值也将相同，因为它是单线程。
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, imagine instead of a single-threaded environment, we have 10 threads,
    and each thread is tasked to increment the `counter`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，我们不是在一个单线程环境中，而是有10个线程，每个线程的任务是增加`counter`：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And now we have a problem! Here’s the output I got (yours might be different!):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遇到了一个问题！这是我的输出（你的可能不同！）：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The output becomes unpredictable because of a phenomenon called *thread interference*.
    In a multithreaded environment, multiple threads may read and increment the value
    of `counter` concurrently. This concurrent modification can lead to unexpected
    results, causing a loss of data integrity. This is again due to a race condition.
    We have seen how to solve that by using an atomic class, but we could also solve
    it by synchronizing the method. The best option would be the one that allows multiple
    threads in most part of the code, without creating data integrity problems. For
    this case, that would be the atomic classes. However, this is a great example
    to demonstrate how the `synchronized` keyword is working.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出变得不可预测，这是因为一种称为*线程干扰*的现象。在多线程环境中，多个线程可能同时读取和增加`counter`的值。这种并发修改可能导致意外结果，造成数据完整性的丢失。这又是由于竞争条件引起的。我们已经看到如何通过使用原子类来解决这个问题，但我们也可以通过同步方法来解决。最佳选择是允许代码的大部分部分有多个线程，而不创建数据完整性问题。对于这种情况，那就是原子类。然而，这是一个很好的例子，可以展示`同步`关键字是如何工作的。
- en: Using synchronized methods
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用同步方法
- en: 'To create a synchronized method, you simply add the `synchronized` keyword
    before the method definition. This ensures that only one thread at a time can
    execute the method for a given object instance. Here’s the updated example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个同步方法，你只需在方法定义之前添加`同步`关键字。这确保了对于给定的对象实例，一次只有一个线程可以执行该方法。以下是更新后的示例：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, if multiple threads call the `incrementCounter()` method simultaneously,
    the `synchronized` keyword ensures that only one thread at a time can access the
    method. This prevents race conditions. Without any changes to the `Main` class,
    this will be the output (your thread IDs might differ):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果多个线程同时调用`incrementCounter()`方法，`同步`关键字确保一次只有一个线程可以访问该方法。这防止了竞争条件。在不修改`Main`类的情况下，这将产生以下输出（你的线程ID可能不同）：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can imagine that synchronizing an entire method can be inefficient. Since
    this makes all the threads wait outside of the method and it creates a possible
    bottleneck for your performance. It is very possible that part of the code in
    the method can be executed by multiple threads at the same time without being
    a threat(sorry) to data integrity. Sometimes, you only need to synchronize a part
    of the method. This can be done with a synchronized block.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，同步整个方法可能是不高效的。因为这会使所有线程在方法外部等待，并可能成为性能的瓶颈。很可能方法中的一部分代码可以在不威胁数据完整性的情况下由多个线程同时执行。有时，你可能只需要同步方法的一部分。这可以通过同步块来实现。
- en: Using synchronized blocks
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用同步块
- en: 'In some cases, you may want to synchronize only a portion of a method, rather
    than the entire method. To do this, you can use a *synchronized block*. A synchronized
    block requires an object to lock on, and the code inside the block is executed
    while holding the lock. Here’s an example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能只想同步方法的一部分，而不是整个方法。为此，你可以使用一个*同步块*。同步块需要一个对象来锁定，并且代码块在持有锁的情况下执行。以下是一个示例：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this code snippet, the `increment()` and `getCount()` methods use synchronized
    blocks instead of synchronized methods. The result is the same – the `count` variable
    is accessed and modified safely in a multi-threaded environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`increment()`和`getCount()`方法使用同步块而不是同步方法。结果是相同的——在多线程环境中，`count`变量被安全地访问和修改。
- en: Synchronized methods versus synchronized blocks
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步方法与同步块的比较
- en: It’s a best practice to minimize the scope of synchronization to improve performance
    and reduce contention among threads. This concept is closely related to **lock
    granularity**, which refers to the size or scope of the code that is being locked.
    The finer the granularity, the smaller the locked section, allowing more threads
    to execute in parallel without waiting for each other.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化同步的范围是一种最佳实践，可以提高性能并减少线程之间的竞争。这个概念与**锁粒度**密切相关，它指的是被锁定代码的大小或范围。粒度越细，锁定的部分越小，允许更多的线程并行执行，而不必互相等待。
- en: Synchronizing large sections of code or entire methods is considered coarse-grained
    locking and can lead to poorer performance. In this scenario, multiple threads
    may be queued up, waiting for a single lock to be released, which can create a
    bottleneck. While coarse-grained locking might be necessary for ensuring data
    integrity, it should be used with caution and only if there is no other option.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将大量代码或整个方法同步化被认为是粗粒度锁定，可能会导致性能下降。在这种情况下，多个线程可能会排队等待单个锁被释放，这可能会创建瓶颈。虽然粗粒度锁定对于确保数据完整性可能是必要的，但它应该谨慎使用，并且只有在没有其他选择的情况下才使用。
- en: On the other hand, fine-grained locking involves using synchronized blocks to
    limit the scope of synchronization to the smallest possible critical section.
    This allows for better concurrency, as threads are less likely to be blocked waiting
    for a lock, thereby improving the system’s throughput.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，细粒度锁定涉及使用同步块将同步的范围限制在最小的可能关键部分。这允许更好的并发性，因为线程不太可能因为等待锁而被阻塞，从而提高系统的吞吐量。
- en: So, to achieve optimal performance without compromising data integrity, aim
    for fine-grained locking by using synchronized blocks whenever possible. This
    aligns well with the principle of minimizing the scope of synchronization. The
    `synchronized` keyword provides a low-level mechanism for synchronization. For
    more complex scenarios, consider using higher-level concurrency constructs, such
    as the `Lock` interface or concurrent collections. Let’s see the `Lock` interface
    next!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在不牺牲数据完整性的情况下实现最佳性能，应尽可能使用同步块来实现细粒度锁定。这与最小化同步范围的原则相吻合。`synchronized`关键字提供了一种低级同步机制。对于更复杂的情况，考虑使用更高级的并发构造，例如`Lock`接口或并发集合。接下来，让我们看看`Lock`接口！
- en: The Lock interface
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定接口
- en: 'Let’s talk about the `Lock` interface. This is an alternative to the `synchronized`
    keyword for handling concurrency control. While synchronized helps us achieve
    thread safety, it also introduces some drawbacks:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈`Lock`接口。这是处理并发控制的`synchronized`关键字的替代方案。虽然`synchronized`帮助我们实现线程安全，但它也引入了一些缺点：
- en: Threads are blocked while waiting for a lock, potentially wasting processing
    time
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程在等待锁时会被阻塞，这可能会浪费处理时间
- en: There’s no mechanism to check whether a lock is available or to time out if
    a lock is held for too long
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有机制可以检查锁是否可用，或者如果锁被持有时间过长则超时
- en: 'If you need to overcome these limitations, you can use the built-in `Lock`
    interface with implementations that offer more control over synchronization. We
    will discuss one of the most common implementations: `ReentrantLock`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要克服这些限制，可以使用提供更多同步控制的内置`Lock`接口的实现。我们将讨论最常见的一种实现：`ReentrantLock`。
- en: ReentrantLock
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReentrantLock
- en: 'The `ReentrantLock` class is a popular implementation of the `Lock` interface.
    `ReentrantLock` is used to protect a section of code similar to `synchronized`
    but provides additional features through its methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReentrantLock`类是`Lock`接口的一个流行实现。`ReentrantLock`用于保护代码的一部分，类似于`synchronized`，但通过其方法提供了额外的功能：'
- en: '`lock()`: This method locks the lock'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock()`：此方法锁定锁'
- en: '`unlock()`: This method releases the lock'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unlock()`：此方法释放锁'
- en: '`tryLock()`: This method attempts to acquire the lock and returns a boolean
    indicating whether the lock was acquired'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryLock()`：此方法尝试获取锁，并返回一个布尔值，指示是否获取了锁'
- en: '`tryLock(time, unit)`: This method attempts to acquire the lock for a specified
    duration'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryLock(time, unit)`：此方法尝试在指定的时间内获取锁'
- en: 'Let’s update the example we used to demonstrate the synchronized keyword with
    `ReentrantLock`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们用来演示`ReentrantLock`的同步关键字的示例：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code snippet, we replace the `synchronized` block with `ReentrantLock`.
    We lock the `Lock` before the critical section and unlock it afterward in the
    `finally` block. This unlocking in the `finally` block is of utmost importance;
    otherwise, the lock won’t be released when an exception occurs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们用`ReentrantLock`替换了`synchronized`块。我们在临界区之前锁定`Lock`，并在`finally`块之后解锁。在`finally`块中的解锁至关重要；否则，当发生异常时，锁不会被释放。
- en: 'The `Main` class remains the same:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类保持不变：'
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And this works like a charm. Here is the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切运作得就像魔法一样。以下是输出结果：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But what if the block was locked already? We want to avoid waiting indefinitely.
    In that case, it may be better to use `tryLock`. If the lock is unavailable, the
    thread can continue with other tasks. This is one of the benefits compared to
    using the `synchronized` keyword! Here’s the updated code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果块已经被锁定呢？我们不想无限期地等待。在这种情况下，可能最好使用`tryLock`。如果锁不可用，线程可以继续执行其他任务。这是与使用`synchronized`关键字相比的一个优点！以下是更新后的代码：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we surround the `try` block with `tryLock()`. If the lock is
    not available, the thread proceeds to do other work. We could also have used the
    `tryLock(time, unit)` method to wait for the lock for a specific duration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们用`tryLock()`包围了`try`块。如果锁不可用，线程将继续执行其他工作。我们也可以使用`tryLock(time, unit)`方法等待特定时间的锁。
- en: We won’t go into detail due to the scope of this book, but there are other locks
    available – for example, the `ReadWriteLock` interface. It separates read and
    write operations, allowing multiple concurrent reads but exclusive writes. This
    can improve performance in read-heavy workloads.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的范围，我们不会深入探讨，但还有其他锁可用——例如，`ReadWriteLock`接口。它将读操作和写操作分开，允许多个并发读取但独占写入。这可以在读取密集型工作负载中提高性能。
- en: Best practices for working with locks
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用锁的最佳实践
- en: 'When working with the `Lock` interface, it’s important to keep a few best practices
    in mind:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Lock`接口工作时，需要牢记以下几点最佳实践：
- en: Always unlock in a `finally` block to ensure the lock is released even in the
    case of an exception.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是在`finally`块中解锁，以确保即使在异常情况下也能释放锁。
- en: Use `tryLock()` for non-blocking operations, which can help avoid deadlocks
    and improve performance.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tryLock()`进行非阻塞操作，这有助于避免死锁并提高性能。
- en: Even though we didn’t discuss it in detail, consider using `ReadWriteLock` for
    read-heavy workloads. This allows concurrent reads and exclusive writes. This
    improves the throughput of your application.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们没有详细讨论，但考虑在读取密集型工作负载中使用`ReadWriteLock`。这允许并发读取和独占写入。这可以提高应用程序的吞吐量。
- en: 'Enough about locks! Let’s talk about the another key tool for working with
    concurrency in Java: concurrent collections!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于锁的话题就到这里吧！让我们谈谈在Java中处理并发性的另一个关键工具：并发集合！
- en: Concurrent collections
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发集合
- en: Multi-threaded environments are important for performance, but in any multi-threaded
    environment, data integrity becomes an issue to consider. Imagine a situation
    where you have several threads interacting with a shared data structure, such
    as an `ArrayList` or `HashMap`. While one thread might be trying to read data
    from the structure, another could be writing to it. This can lead to data inconsistency
    and other types of errors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程环境对于性能很重要，但在任何多线程环境中，数据完整性都成为一个需要考虑的问题。想象一下这种情况：你有几个线程正在与一个共享数据结构（如`ArrayList`或`HashMap`）交互。当一个线程可能正在尝试从结构中读取数据时，另一个线程可能正在写入它。这可能导致数据不一致和其他类型的错误。
- en: One common problem that arises in such situations is known as a concurrent modification
    exception. This occurs when one thread is iterating over a data structure, and
    another thread attempts to modify it. Java recognizes that this can cause inconsistencies
    and throws an exception to prevent this dangerous operation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下出现的一个常见问题是并发修改异常。这发生在当一个线程正在遍历一个数据结构时，另一个线程试图修改它。Java意识到这可能导致不一致性，并抛出异常以防止这种危险的操作。
- en: 'Consider the following example, where a `HashMap` is being used:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中使用了`HashMap`：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we’re trying to iterate over `HashMap` and remove an entry
    during the process. This will throw `ConcurrentModificationException`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们试图在过程中遍历`HashMap`并删除一个条目。这将抛出`ConcurrentModificationException`。
- en: 'You might have guessed it; this is exactly why we have concurrent collections.
    A concurrent collection, such as `ConcurrentHashMap`, is a thread-safe alternative
    to `HashMap`, which means it can handle simultaneous reading and writing from
    multiple threads. With `ConcurrentHashMap`, you can modify the map while looping
    over it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了；这正是为什么我们有并发集合。并发集合，如 `ConcurrentHashMap`，是 `HashMap` 的线程安全替代品，这意味着它可以处理来自多个线程的并发读取和写入。使用
    `ConcurrentHashMap`，你可以在遍历地图的同时修改它：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We don’t get `ConcurrentModificationException` this time. `ConcurrentHashMap`
    allows us to remove items while iterating.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不会得到 `ConcurrentModificationException`。`ConcurrentHashMap` 允许我们在迭代时移除项目。
- en: And that’s not even all! Concurrent collections offer another advantage. They
    allow us to lock on a per-segment basis. This means that multiple threads can
    have read access simultaneously, which can enhance the performance without compromising
    data integrity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此！并发集合还提供了另一个优势。它们允许我们基于段进行锁定。这意味着多个线程可以同时具有读取访问权限，这可以在不牺牲数据完整性的情况下提高性能。
- en: Concurrent collection interfaces
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发集合接口
- en: Within the `java.util.concurrent` package, there are several interfaces designed
    to facilitate concurrent operations on collections. The two primary ones we will
    discuss are `ConcurrentMap` and `BlockingQueue`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.concurrent` 包中，有几个接口旨在促进集合上的并发操作。我们将讨论的两个主要接口是 `ConcurrentMap`
    和 `BlockingQueue`。
- en: ConcurrentMap
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentMap
- en: '`ConcurrentMap` is a sub-interface of the standard `java.util.Map`. It provides
    atomic operations for adding, removing, and replacing key-value pairs, enhancing
    thread safety. The two primary implementations of `ConcurrentMap` are `ConcurrentHashMap`
    and `ConcurrentSkipListMap`. It works very similarly to a regular `Map`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentMap` 是标准 `java.util.Map` 的子接口。它提供了对键值对进行添加、删除和替换的原子操作，增强了线程安全性。`ConcurrentMap`
    的两种主要实现是 `ConcurrentHashMap` 和 `ConcurrentSkipListMap`。它的工作方式与常规 `Map` 非常相似：'
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ConcurrentHashMap` is a thread-safe `Map` implementation that provides better
    performance than `Hashtable` (an older thread-safe alternative). It allows concurrent
    reads and writes with minimal contention.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 是一种线程安全的 `Map` 实现，其性能优于 `Hashtable`（一种较老的线程安全替代品）。它允许并发读取和写入，最小化竞争。'
- en: BlockingQueue
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻塞队列
- en: '`BlockingQueue` is another interface, a subtype of `Queue`, optimized for multi-threaded
    operations. Unlike standard queues, `BlockingQueue` will block or time out when
    attempting to add an element to a full queue or retrieve an element from an empty
    queue:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue` 是另一个接口，是 `Queue` 的子类型，针对多线程操作进行了优化。与标准队列不同，当尝试向满队列添加元素或从空队列中检索元素时，`BlockingQueue`
    将会阻塞或超时：'
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These interfaces provide additional functionality that becomes invaluable when
    working in a multi-threaded environment, enhancing both performance and data integrity.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口提供了在多线程环境中工作时非常有价值的功能，提高了性能和数据完整性。
- en: 'There are quite a few other concurrent implementations of collections that
    you might work with in the future, they work very similarly to their non-concurrent
    counterparts. We’ll talk about two categories: `SkipList` and `CopyOnWrite` collections.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，你可能会遇到相当多的其他并发集合实现，它们的工作方式与它们的非并发对应物非常相似。我们将讨论两个类别：`SkipList` 和 `CopyOnWrite`
    集合。
- en: Understanding SkipList collections
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 SkipList 集合
- en: '`ConcurrentSkipList` collections represent naturally ordered collections, which
    means they maintain their elements in a sorted manner. `ConcurrentSkipListSet`
    and `ConcurrentSkipListMap` are the two most common `ConcurrentSkipList` collections.
    They work very similar to the collections that we’re used to.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipList` 集合表示自然排序的集合，这意味着它们以排序的方式维护其元素。`ConcurrentSkipListSet`
    和 `ConcurrentSkipListMap` 是两种最常见的 `ConcurrentSkipList` 集合。它们的工作方式与我们习惯的集合非常相似。'
- en: ConcurrentSkipListSet
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentSkipListSet
- en: 'Using `ConcurrentSkipListSet` is the same as using `TreeSet`, but it’s optimized
    for concurrent usage. Let’s take a look at an example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentSkipListSet` 与使用 `TreeSet` 相同，但它针对并发使用进行了优化。让我们看看一个例子：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code block, when you print the set, the elements will be displayed
    in their natural order: `Adnane`, `Gaia`, and `Jonas`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，当你打印集合时，元素将以它们的自然顺序显示：`Adnane`、`Gaia` 和 `Jonas`。
- en: ConcurrentSkipListMap
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentSkipListMap
- en: '`ConcurrentSkipListMap` works similarly to `TreeMap`, but it’s designed for
    concurrent operations. Like `ConcurrentSkipListSet`, the map entries are maintained
    in the natural order of their keys:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListMap` 的工作方式与 `TreeMap` 类似，但它是为并发操作设计的。像 `ConcurrentSkipListSet`
    一样，映射条目按照其键的自然顺序维护：'
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this code, the map entries are printed in the alphabetical order of the
    keys: `Bass`, `Flute`, and `Piano`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，映射条目按照键的字母顺序打印：`Bass`、`Flute` 和 `Piano`。
- en: Understanding CopyOnWrite collections
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 CopyOnWrite 集合
- en: '`CopyOnWrite` collections, as the name suggests, make a fresh copy of the collection
    every time it is modified. This means they perform well when there are more read
    operations than write operations but can be inefficient when there are more writes.
    Let’s discuss the common implementations.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`CopyOnWrite` 集合在每次修改时都会创建集合的新副本。这意味着当读操作多于写操作时，它们表现良好，但当写操作多于读操作时，可能会效率低下。让我们讨论常见的实现。
- en: CopyOnWriteArrayList
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CopyOnWriteArrayList
- en: '`CopyOnWriteArrayList` works just like a regular `ArrayList` but creates a
    new copy of the list every time it gets modified:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList` 的工作方式与常规 `ArrayList` 相同，但每次修改列表时都会创建列表的新副本：'
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Even though we’re modifying the list during iteration, it doesn’t result in
    `ConcurrentModificationException` because a new copy of the list is created when
    it’s modified.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在迭代过程中修改列表，也不会导致 `ConcurrentModificationException`，因为修改时创建了一个列表的新副本。
- en: CopyOnWriteArraySet
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CopyOnWriteArraySet
- en: '`CopyOnWriteArraySet` is similar to `HashSet`, but it creates a new copy every
    time the set is modified:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArraySet` 与 `HashSet` 类似，但每次修改集合时都会创建一个新的副本：'
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, the size of the set remains the same after the loop because
    the set only contains unique objects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，由于集合只包含唯一对象，因此循环结束后集合的大小保持不变。
- en: Synchronized collections
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步集合
- en: '*Synchronized collections* are a different way to use collections in a multithreaded
    environment. The `Collections` class provides several static methods for returning
    synchronized versions of regular collections such as `List`, `Set`, and `Map`.
    Here’s an example for `List`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*同步集合* 是在多线程环境中使用集合的另一种方式。`Collections` 类提供了几个静态方法，用于返回常规集合（如 `List`、`Set`
    和 `Map`）的同步版本。以下是一个 `List` 的示例：'
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, `syncList` is a thread-safe version of `regularList`. These
    synchronized collections are a good choice when you need to turn an existing collection
    into a thread-safe one, but if you know a collection will be used in a multithreaded
    environment upon creation, it’s better to use concurrent collections as they perform
    better.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`syncList` 是 `regularList` 的线程安全版本。当需要将现有的集合转换为线程安全集合时，这些同步集合是一个不错的选择，但如果知道集合在创建时将在多线程环境中使用，则最好使用并发集合，因为它们的性能更好。
- en: The most important difference between synchronized and concurrent collections
    is that synchronized collections cannot be modified in a loop as they will throw
    `ConcurrentModificationException`. They are otherwise safe to use and don’t lead
    to issues with data integrity when used with multiple threads. Managing a lot
    of threads by hand would be quite a daunting task. Luckily, there is a special
    interface, `ExecutorService`, to help us with that!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同步集合和并发集合之间最重要的区别是，同步集合不能在循环中修改，否则会抛出 `ConcurrentModificationException`。在其他方面，它们是安全的，并且在使用多个线程时不会导致数据完整性问题。手动管理大量线程将是一项相当艰巨的任务。幸运的是，有一个特殊的接口
    `ExecutorService`，可以帮助我们完成这项任务！
- en: ExecutorService and thread pools
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExecutorService 和线程池
- en: Java’s `ExecutorService` is a mechanism for executing tasks asynchronously.
    As a part of the `java.util.concurrent` package, `ExecutorService` is an interface
    used to manage and control thread execution in a multithreaded environment. We
    have seen so far how we can manually control threads, and we’ll now see how we
    can use `ExecutorService` instead. We’ll see the details of `ExecutorService`
    and its implementations, such as `SingleThreadExecutor` and `ScheduledExecutorService`.
    Let’s see `SingleThreadExecutor` first.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 `ExecutorService` 是异步执行任务的机制。作为 `java.util.concurrent` 包的一部分，`ExecutorService`
    是一个用于在多线程环境中管理和控制线程执行的接口。我们迄今为止已经看到了如何手动控制线程，现在我们将看到如何使用 `ExecutorService`。我们将看到
    `ExecutorService` 及其实现（如 `SingleThreadExecutor` 和 `ScheduledExecutorService`）的详细信息。让我们首先看看
    `SingleThreadExecutor`。
- en: Executing tasks using SingleThreadExecutor
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SingleThreadExecutor 执行任务
- en: Firstly, let’s start with `SingleThreadExecutor`. This `ExecutorService` has
    one single worker thread to process tasks, guaranteeing that tasks are executed
    in the order they’re submitted. It’s useful when we need sequential execution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从`SingleThreadExecutor`开始。这个`ExecutorService`有一个单独的工作线程来处理任务，保证任务按照提交的顺序执行。当我们需要顺序执行时，它很有用。
- en: Consider a scenario with an election where votes are being counted. To mimic
    this process, we’ll represent each vote as a task. For simplicity, let’s assume
    we’re counting votes for one candidate.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个选举场景，其中正在计算选票。为了模拟这个过程，我们将每个投票表示为一个任务。为了简单起见，让我们假设我们正在计算一个候选人的选票。
- en: 'Here’s how we can do that:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做到：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code block, we first create a `SingleThreadExecutor` instance.
    We then submit four tasks, each representing a vote being counted. Notice that
    we use `executor.execute()`, passing a `Runnable` lambda function as an argument.
    This function prints the vote number and the thread ID handling it. At the end,
    we shut down `ExecutorService` using `executor.shutdown()`. This is crucial to
    terminate the non-daemon thread of the executor and failing to do so will prevent
    your application from terminating. A non-daemon thread is one that prevents the
    program from ending. When you forget to do that, you’ll see that once you run
    the program, it will not stop. The stop button will stay visible.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们首先创建了一个`SingleThreadExecutor`实例。然后提交了四个任务，每个任务代表一个正在计算的投票。请注意，我们使用`executor.execute()`，传递一个`Runnable`
    lambda函数作为参数。这个函数打印投票编号和处理的线程ID。最后，我们使用`executor.shutdown()`关闭`ExecutorService`。这是至关重要的，因为要终止执行器的非守护线程，否则将阻止您的应用程序终止。非守护线程是一种阻止程序结束的线程。当你忘记这样做时，你会看到一旦运行程序，它就不会停止。停止按钮将保持可见。
- en: 'This is what it outputs (for me):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我输出的结果（对我来说）：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, it will count four votes, printing the corresponding vote number
    and the same thread ID each time since all tasks are processed by a single thread.
    We can actually also invoke multiple tasks at the same time. Before we can do
    that, we need to understand `Callable` and `Future`. So, let’s see what that means
    first – is the future calling us?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它将计算四个投票，每次打印相应的投票编号和相同的线程ID，因为所有任务都由单个线程处理。实际上，我们也可以同时调用多个任务。在我们能够这样做之前，我们需要了解`Callable`和`Future`。那么，让我们首先看看这意味着什么——未来是在调用我们吗？
- en: The Callable interface and Future
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Callable接口和Future
- en: While the `Runnable` interface enables you to execute code concurrently, it
    does not return a result. In contrast, the `Callable` interface allows concurrent
    tasks to produce a result. It has a single `call` method that returns a value.
    So, it’s a functional interface too.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Runnable`接口允许你并发执行代码，但它不会返回结果。相比之下，`Callable`接口允许并发任务产生结果。它有一个单一的`call`方法，返回一个值。因此，它也是一个函数式接口。
- en: '`ExecutorService` not only executes `Runnable` tasks but also `Callable` tasks,
    which return a result. The `submit()` method is used to execute `Callable` tasks.
    This `submit()` method returns a `Future` object, which can be used to retrieve
    the result once it’s ready. If you’d like to think of a non-code example, you
    can compare it to placing an order at a restaurant: you receive a token (`Future`)
    and you can use it to collect your order (the result) when it’s ready.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`不仅执行`Runnable`任务，还执行返回结果的`Callable`任务。`submit()`方法用于执行`Callable`任务。这个`submit()`方法返回一个`Future`对象，可以在结果准备好后用来检索结果。如果你想用一个非代码的例子来思考，你可以将其比作在餐厅下订单：你收到一个代币（`Future`），你可以在它准备好时用它来取回你的订单（结果）。'
- en: The `Future` object represents the result of an ongoing computation—a placeholder
    of sorts. When you submit a `Callable` task to `ExecutorService`, it returns a
    `Future` object. You can use this `Future` object to check whether the computation
    is complete, wait for its completion, and retrieve the result. It’s time to see
    an example!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`对象代表一个正在进行的计算的结果——一种占位符。当你向`ExecutorService`提交一个`Callable`任务时，它返回一个`Future`对象。你可以使用这个`Future`对象来检查计算是否完成，等待其完成，并检索结果。现在是时候看看一个例子了！'
- en: Submitting tasks and handling results
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交任务和处理结果
- en: Let’s simulate counting votes and maintaining a tally using `Callable` tasks.
    Here, we’ll use the `submit()` method, which returns a `Future` object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟使用`Callable`任务计算选票并维护计票。在这里，我们将使用`submit()`方法，它返回一个`Future`对象。
- en: 'The code might look like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能看起来像这样：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And here is what it will output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它将输出的结果：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are still using `SingleExecutorService` in the preceding code. To our `ExecutorService`,
    we submit four `Callable` tasks using `executorService.submit()` in the `getRandomVote`
    method. Each task waits for one second (simulating vote counting) and then returns
    `1` (representing one vote). Each submission returns a `Future` object, which
    is stored in `vote1`, `vote2`, `vote3`, and `vote4`, respectively.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们仍在使用`SingleExecutorService`。在`getRandomVote`方法中，我们使用`executorService.submit()`向我们的`ExecutorService`提交了四个`Callable`任务。每个任务等待一秒钟（模拟投票计数）然后返回`1`（代表一票）。每个提交都返回一个`Future`对象，分别存储在`vote1`、`vote2`、`vote3`和`vote4`中。
- en: Then, we wait in a loop until all `Future` objects report they’re done. Once
    all votes are counted (all `Future` objects are done), we retrieve the results
    using the `get()` method on each `Future` object. This is wrapped in a `try`/`catch`
    block to handle potential exceptions. Finally, we add all the votes and print
    the total votes. Before we continue, let’s talk a bit more about the methods on
    the `Future` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们循环等待直到所有`Future`对象报告它们已完成。一旦所有投票都已计数（所有`Future`对象已完成），我们就使用每个`Future`对象的`get()`方法检索结果。这被包裹在一个`try`/`catch`块中，以处理可能出现的异常。最后，我们将所有投票相加并打印总票数。在我们继续之前，让我们再谈谈`Future`类上的方法。
- en: Future objects and their methods
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来对象及其方法
- en: 'The `Future` object provides several methods to handle the results of asynchronous
    computations. We already used `isDone()` to check whether the task was done and
    the result was in. And we already used `get()` to get the result of the task when
    it was done. This `get()` method waits until the task is done executing. Here
    are some other methods that are important to know:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`对象提供了几个方法来处理异步计算的结果。我们已使用`isDone()`来检查任务是否完成并且结果已就绪。并且我们已经使用`get()`在任务完成时获取任务的结果。这个`get()`方法会等待直到任务执行完成。以下是一些其他重要的方法：'
- en: '`get(long timeout, TimeUnit unit)`: Retrieves the result only if it’s ready
    within the provided timeout duration'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(long timeout, TimeUnit unit)`: 只有在提供的超时时间内就绪时才检索结果'
- en: '`isCancelled()`: Checks whether the computation was canceled'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCancelled()`: 检查计算是否被取消'
- en: '`cancel(boolean mayInterruptIfRunning)`: Attempts to cancel the task'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel(boolean mayInterruptIfRunning)`: 尝试取消任务'
- en: In the latest example, we submitted the four tasks one by one, but we can also
    submit multiple tasks at the same time. Let’s see how that is done.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的示例中，我们逐个提交了四个任务，但我们也可以同时提交多个任务。让我们看看这是如何完成的。
- en: Invoking multiple tasks and handling the results
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用多个任务并处理结果
- en: We can submit multiple tasks and handle their results. For this, we’ll use the
    `invokeAny()` and `invokeAll()` methods, and represent tasks as `Callable` tasks
    instead of `Runnable` tasks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提交多个任务并处理它们的结果。为此，我们将使用`invokeAny()`和`invokeAll()`方法，并将任务表示为`Callable`任务而不是`Runnable`任务。
- en: The `invokeAny()` method takes a collection of `Callable` objects and returns
    the result of a successfully executed task (the first one to finish), canceling
    all others. Conversely, `invokeAll()` executes all tasks and returns a list of
    `Future` objects representing the results.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeAny()`方法接受一个`Callable`对象的集合，并返回一个成功执行的任务的结果（第一个完成），取消所有其他任务。相反，`invokeAll()`执行所有任务，并返回一个表示结果的`Future`对象列表。'
- en: 'Consider the following code, which is counting our votes again. In this case,
    people can vote for option 1 or option 2\. Counting is now implemented with the
    use of `Callable` and `Future`. We will demonstrate the use of `invokeAny` (not
    very democratic) and `invokeAll` in this code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它再次计算我们的投票。在这种情况下，人们可以为选项1或选项2投票。计数现在使用`Callable`和`Future`实现。我们将在这个代码片段中演示`invokeAny`（不太民主）和`invokeAll`的使用：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And this is what the code outputs:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码输出的内容：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the code, we start by defining a list of `Callable` tasks. Each `Callable`
    returns an `Integer` after a certain sleep period (simulating the work done by
    the task). We then invoke the tasks using the `invokeAny()` and `invokeAll()`
    methods, displaying the results accordingly. The `try`/`catch` block is needed
    to handle potential exceptions that may arise during task execution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们首先定义了一个`Callable`任务的列表。每个`Callable`在一定的睡眠期后返回一个`Integer`（模拟任务完成的工作）。然后我们使用`invokeAny()`和`invokeAll()`方法调用任务，并相应地显示结果。`try`/`catch`块是必要的，以处理在任务执行过程中可能出现的异常。
- en: This example gives us a good understanding of invoking tasks and handling results
    using `ExecutorService`. So far, we’ve only seen `SingleThreadExecutor`. There
    are also `ExecutorService` available that use multiple threads. That’s going to
    make it a lot more interesting (and complicated, so stay focussed!). Let’s see
    these next.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例让我们对使用 `ExecutorService` 调用任务和处理结果有了很好的理解。到目前为止，我们只看到了 `SingleThreadExecutor`。还有其他使用多个线程的
    `ExecutorService` 可用。这将使事情变得更有趣（并且更复杂，所以请保持专注！）。让我们看看接下来的内容。
- en: Thread pools and task execution
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程池和任务执行
- en: Thread pools are a key concept of concurrent programming. Thread pools can be
    compared to a crew of workers—multiple threads waiting for tasks. When a task
    is available, each thread can pick it up from the queue, execute it, and wait
    for new tasks rather than being destroyed. This is a lot more efficient compared
    to creating a new thread for every task.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池是并发编程的一个关键概念。线程池可以比作一群工人——多个线程等待任务。当有任务可用时，每个线程都可以从队列中取出它，执行它，并等待新任务，而不是被销毁。与为每个任务创建新线程相比，这要高效得多。
- en: There are different `ExecutorServices` to manage thread pools, and each has
    its specific use case. Let’s explore `FixedThreadPool` first.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的 `ExecutorServices` 来管理线程池，并且每个都有其特定的用例。让我们首先探索 `FixedThreadPool`。
- en: FixedThreadPool
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FixedThreadPool
- en: '`FixedThreadPool` maintains a fixed number of threads. If a task is submitted
    and all threads are active, the task waits in a queue until a thread becomes available.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`FixedThreadPool` 维护固定数量的线程。如果提交了一个任务且所有线程都处于活动状态，该任务将等待在队列中，直到有线程可用。'
- en: 'So far, we’ve had a single thread do all the vote counting for us. Instead,
    consider an election scenario where you have three polling stations to count the
    votes from all 100 voting stations:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直让单个线程为我们进行所有投票计数。相反，考虑一个选举场景，其中你有三个投票站来计数所有 100 个投票站的投票：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will output something like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出类似以下内容：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Every time you run the program, it will be somewhat different! The count for
    each vote is carried out asynchronously, as demonstrated by the randomly assigned
    sleep times. This is because we’re simulating a scenario in which each of the
    three threads (in this case with id `22`, `23`, and `24`) corresponds to a polling
    station that starts counting the votes. Even if there is a large number of votes,
    there will still only be three threads (polling stations) performing the counting.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行程序时，它都会有所不同！每个投票的计数都是异步进行的，如随机分配的睡眠时间所示。这是因为我们在模拟一个场景，其中三个线程（在本例中为 id `22`、`23`
    和 `24`）对应于开始计数的投票站。即使有大量的投票，也仍然只有三个线程（投票站）进行计数。
- en: As you can see, the order of the voting stations is no longer the same. This
    is because multiple threads are working simultaneously. And that’s not a problem,
    as it doesn’t influence the end result.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，投票站顺序不再相同。这是因为有多个线程同时工作。这并不是问题，因为它不会影响最终结果。
- en: CachedThreadPool
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CachedThreadPool
- en: '`CachedThreadPool`, on the other hand, creates new threads as needed and reuses
    previously constructed threads if they are available. Threads in this pool that
    haven’t been used for a certain amount of time are terminated and removed from
    the cache.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`CachedThreadPool` 会根据需要创建新线程，并在可用的情况下重用之前构建的线程。在此池中未使用一定时间的线程将被终止并从缓存中移除。
- en: 'Imagine an election with numerous mobile polling stations that move around
    to different locations and count votes as needed:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个有众多移动投票站的选举，这些投票站会移动到不同的地点并按需计数投票：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code can output the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以输出以下内容：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, `CachedThreadPool` creates as many threads as needed to process
    the votes simultaneously, leading to faster vote counting. However, this comes
    at the cost of system resources since an uncontrolled number of threads could
    be created.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`CachedThreadPool` 会根据需要创建尽可能多的线程来同时处理投票，从而加快投票计数。然而，这会以系统资源为代价，因为可能会创建不受控制的线程数量。
- en: Another option that we have is to schedule commands to run after a given delay
    or to execute periodically. This is done with `ScheduledExecutorService`. Let’s
    see how we can schedule tasks to run after a certain delay or periodically.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个选择，即安排在给定延迟后或定期运行命令。这是通过 `ScheduledExecutorService` 实现的。让我们看看我们如何安排在特定延迟后或定期运行任务。
- en: ScheduledExecutorServices
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ScheduledExecutorServices
- en: Now, we’re going to take a look at `ScheduledExecutorService`. As the name suggests,
    `ScheduledExecutorService` allows you to schedule tasks to be executed after a
    certain delay, or to be executed periodically. This is incredibly useful when
    you need a task to be executed at regular intervals without having to manually
    reschedule it each time.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将来看看`ScheduledExecutorService`。正如其名所示，`ScheduledExecutorService`允许你在一段时间后安排任务执行，或者周期性地执行任务。当你需要定期执行任务而不必每次都手动重新安排时，这非常有用。
- en: To use `ScheduledExecutorService`, you first create one using the `Executors`
    class. There are multiple options, but we’ll only use `newScheduledThreadPool()`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ScheduledExecutorService`，你首先使用`Executors`类创建一个。有多种选择，但我们只会使用`newScheduledThreadPool()`。
- en: 'Let’s see some example code. Assume that we are building a simple voting system
    where we need to schedule a task to close the voting process after a certain period,
    say 1 hour. Here’s how we can do that:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例代码。假设我们正在构建一个简单的投票系统，我们需要在一段时间后安排一个任务来关闭投票过程，比如说1小时。我们可以这样操作：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This outputs the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出以下内容：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We create `ScheduledExecutorService` with a single thread. We then use the
    `schedule()` method to schedule the `closeVoting()` method to be executed after
    1 hour. The `schedule()` method takes three arguments: the method to execute,
    the delay before execution, and the time unit of the delay.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用单个线程创建`ScheduledExecutorService`。然后我们使用`schedule()`方法安排`closeVoting()`方法在1小时后执行。`schedule()`方法接受三个参数：要执行的函数、执行前的延迟，以及延迟的时单位。
- en: 'This is a simple example. You could also schedule tasks to be executed periodically.
    For example, if you wanted to remind voters every 15 minutes that voting will
    close soon, you could do this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子。你也可以安排周期性执行的任务。例如，如果你想每15分钟提醒选民投票即将关闭，你可以这样做：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this code, we use the `scheduleAtFixedRate()` method to schedule the `remindVoters()`
    method to be executed every 15 minutes. The `scheduleAtFixedRate()` method takes
    four arguments: the method to execute, the initial delay before execution, the
    period between executions, and the time unit of the delay and period.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用`scheduleAtFixedRate()`方法来安排`remindVoters()`方法每15分钟执行一次。`scheduleAtFixedRate()`方法接受四个参数：要执行的函数、执行前的初始延迟、执行之间的周期，以及延迟和周期的时单位。
- en: 'And this is what it outputs with these modifications:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些修改后，它输出的结果是：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Remember, when you are done with your `ScheduledExecutorService`, don’t forget
    to shut it down. This will stop any new tasks from being accepted and allow the
    existing tasks to complete. If you don’t shut down `ScheduledExecutorService`,
    your application might not terminate because the non-daemon threads in the pool
    will keep it running.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你完成你的`ScheduledExecutorService`时，不要忘记关闭它。这将停止接受任何新任务，并允许现有任务完成。如果你不关闭`ScheduledExecutorService`，你的应用程序可能无法终止，因为池中的非守护线程会保持其运行。
- en: And that’s all you need to know to get started with `ScheduledExecutorService`.
    Let’s explore the data race problem in a bit more detail before moving on to other
    Java tools, such as atomic classes for dealing with concurrency.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要了解的，以便开始使用`ScheduledExecutorService`。在继续介绍其他Java工具，如用于处理并发的原子类之前，让我们更详细地探讨数据竞争问题。
- en: Data races
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据竞争
- en: Instead of starting by explaining atomic classes, let’s start with explaining
    a problem called a data race with an example. We already have seen how to fix
    this problem with the use of atomic classes, synchronized keyword, and locks.
    Can you spot the problem in the following code snippet?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不如先从一个称为数据竞争的问题的例子开始解释，而不是从原子类开始解释。我们已经看到了如何使用原子类、同步关键字和锁来解决这个问题。你能在以下代码片段中找到问题吗？
- en: '`public class` `Main {`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`public class` `Main {`'
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We have a static `int` counter that is being incremented 10,000 times by two
    threads. You’d expect the counter to be 20,000 then, right? Yet, if we print the
    value of the counter, this is what we get:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个静态的`int`计数器，它被两个线程增加了10,000次。你可能会预期计数器会是20,000，对吧？然而，如果我们打印计数器的值，我们会得到以下结果：
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And if we run it again, this is what we get:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行它，我们会得到以下结果：
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A third time? This is what we get:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次了？我们得到的结果是：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Long story short, we have a problem! But why? Well, we are looking at the result
    of a data race. A data race occurs when two or more threads access shared data
    simultaneously, and at least one of them modifies the data. So, in our case, `thread1`
    reads the value and wants to increase it, but at the same time, `thread2` read
    the value and increases it too. Let’s say the value was 2,000 at the time. Both
    `thread1` and `thread2` increase it to 2,001\. There are a few other variations
    possible, for example, `thread1` writing 4,022, and then `thread2` overwriting
    the value with a much lower value, such as 3,785.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们有一个问题！但为什么呢？好吧，我们正在查看数据竞争的结果。数据竞争发生在两个或多个线程同时访问共享数据时，其中至少有一个线程修改了数据。所以，在我们的情况下，`thread1`读取值并想要增加它，但与此同时，`thread2`也在读取值并增加它。假设当时的值是2,000。`thread1`和`thread2`都将它增加到2,001。还有其他一些可能的变体，例如，`thread1`写入4,022，然后`thread2`用远低于该值的值覆盖它，比如3,785。
- en: This happens because these `++` and `--` operators are not atomic operators.
    This means that getting the value and increasing it are two separate operations,
    allowing it to be intersected by another thread. In order to avoid this, we can
    work with atomic classes. As we have seen, for atomic classes, getting and modifying
    the value is just one single operation, avoiding this issue.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这些`++`和`--`运算符不是原子运算符。这意味着获取值和增加它是两个独立的操作，允许另一个线程介入。为了避免这种情况，我们可以使用原子类。正如我们所见，对于原子类，获取和修改值只是一个单一的操作，避免了这个问题。
- en: A non-code data race
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 非代码数据竞争
- en: Let’s tell you a true story to give you a non-code example (and a first-world
    problem) about a data race I had to experience myself. I love it when my friends
    have wish lists for their birthdays so that I can get them something they want
    instead of spending lots of time thinking about what to get them. So apparently,
    I and another friend saw that the kid of one of our friends wanted an inflatable
    bouncy unicorn. So, we both checked the list at almost the same time and we saw
    that the bouncy unicorn was still an available gift option. We both crossed it
    off and got the unicorn. (Okay, to be honest, I remember that I had to cross it
    off twice actually, but I figured it was a glitch.)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给你讲一个真实的故事，给你一个非代码示例（以及一个第一世界问题），关于我亲身经历的数据竞争。我喜欢我的朋友们在生日时有愿望清单，这样我就可以给他们买他们想要的东西，而不是花很多时间去想送他们什么。所以显然，我和另一个朋友看到我们其中一个朋友的儿子想要一个充气弹跳独角兽。所以我们几乎同时查看清单，看到充气独角兽仍然是一个可选的礼物。我们俩都把它划掉，得到了独角兽。（好吧，说实话，我记得我实际上得划掉两次，但我认为是故障。）
- en: Turns out that we were looking at that list, at the very same time, ordering
    the unicorn and crossing it off. Can’t say it ended up being a real problem, because
    what is better to a 6-year-old than one inflatable bouncy unicorn? Yup, two inflatable
    bouncy unicorns!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们同时查看那个清单，订购独角兽并划掉它。不能说这最终成为一个真正的问题，因为对6岁的孩子来说，有什么比一个充气弹跳独角兽更好呢？是的，两个充气弹跳独角兽！
- en: Let’s see the common problems such as the data race mentioned here before we
    wrap up this chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，让我们看看这里提到的常见问题，如数据竞争。
- en: Threading problems
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程问题
- en: 'When working with concurrency, we have the opportunity to increase performance!
    However, with great power comes great responsibility; things can go awfully wrong
    as well. Therefore, we must be aware of several potential problems that can arise
    due to incorrect or inefficient synchronization. Let’s discuss four common threading
    problems: data races, race conditions, deadlocks, livelocks, and starvation.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理并发时，我们有提高性能的机会！然而，权力越大，责任越大；事情也可能出奇地糟糕。因此，我们必须意识到由于不正确或低效的同步可能出现的几个潜在问题。让我们讨论四个常见的线程问题：数据竞争、竞态条件、死锁、活锁和饥饿。
- en: Data races
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据竞争
- en: 'We have just talked quite a bit about data races already. They occur when two
    or more threads access shared data concurrently, and at least one of them modifies
    the data, leading to unpredictable results. Here’s an example of an innocent-looking
    snippet of code that can lead to a data race in multithreaded environments:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于数据竞争的内容。数据竞争发生在两个或多个线程并发访问共享数据时，其中至少有一个线程修改了数据，导致结果不可预测。以下是一个看似无害的代码片段示例，在多线程环境中可能导致数据竞争：
- en: '[PRE56]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If multiple threads call the `increment()` method simultaneously, the `count`
    variable’s value may not be updated correctly, resulting in an incorrect final
    count.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个线程同时调用`increment()`方法，`count`变量的值可能不会正确更新，导致最终计数不正确。
- en: Strategies to prevent data races
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止数据竞争的策略
- en: 'To prevent data races, you can use various synchronization techniques as we
    have seen in this chapter, such as the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止数据竞争，你可以使用我们在本章中看到的各种同步技术，例如以下内容：
- en: Using the `synchronized` keyword on methods or blocks of code
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法或代码块上使用 `synchronized` 关键字
- en: Using atomic classes, such as `AtomicInteger`, `AtomicLong`, and `AtomicReference`
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子类，例如 `AtomicInteger`、`AtomicLong` 和 `AtomicReference`
- en: Using locks, such as `ReentrantLock` or `ReadWriteLock`
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁，例如 `ReentrantLock` 或 `ReadWriteLock`
- en: Race conditions
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞态条件
- en: A race condition is a situation in concurrent programming where the program’s
    outcome can change based on the sequence or timing of thread scheduling and execution.
    It is a flaw that occurs when the timing or order of events affects the program’s
    correctness. Unlike a data race, where concurrent access to shared data is the
    issue, a race condition is about multiple threads sequencing their operations
    incorrectly.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件是在并发编程中，程序的结果可以根据线程调度的顺序或时间而改变的情况。当事件的时间或顺序影响程序的正确性时，就会发生这种缺陷。与数据竞争不同，数据竞争的问题在于对共享数据的并发访问，而竞态条件是关于多个线程错误地序列化它们的操作。
- en: 'Here’s an example code snippet to illustrate the problem:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例代码片段来说明这个问题：
- en: '[PRE57]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If two threads (representing two customers) called the `bookSeat` method at
    the same time when only one seat is left, they could both pass the `if(seatsAvailable
    > 0)` check before either of them had the chance to decrement `seatsAvailable`.
    As a result, two customers might book the last seat, which is a race condition.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个线程（代表两个客户）同时在只剩下一个座位时调用 `bookSeat` 方法，它们都可能通过 `if(seatsAvailable > 0)` 检查，在任何一个线程有机会减少
    `seatsAvailable` 之前。结果，两个客户可能会预订最后一个座位，这是一个竞态条件。
- en: This situation is an example of a race condition because the order of operations
    (checking the availability and then decrementing the number of seats) matters
    for correctness. Specifically, there is a critical section of code (`if(seatsAvailable
    > 0)` and `seatsAvailable--;`) that needs to be executed atomically (without interruption)
    to prevent errors.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是一个竞态条件的例子，因为操作的顺序（检查可用性然后减少座位数）对于正确性很重要。具体来说，有一个关键代码段（`if(seatsAvailable
    > 0)` 和 `seatsAvailable--;`），它需要原子性地（无中断地）执行，以防止错误。
- en: To make sure that we understand the difference from a data race, a data race
    specifically involves simultaneous access to shared data where at least one operation
    is a write operation. A data race could occur in our example if multiple threads
    attempted to decrement `seatsAvailable` at the same time, potentially leading
    to one thread reading the value of `seatsAvailable` before another thread had
    finished decrementing it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们理解数据竞争的差异，数据竞争特别涉及对共享数据的并发访问，其中至少有一个操作是写操作。在我们的例子中，如果多个线程同时尝试减少 `seatsAvailable`，可能会导致一个线程在另一个线程完成减少之前读取
    `seatsAvailable` 的值，从而引发数据竞争。
- en: Strategies to prevent race conditions
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止竞态条件的策略
- en: 'To avoid these types of problems, we need to ensure that the critical section
    of code is executed atomically, which can be achieved by synchronization. For
    instance, we can use the `synchronized` keyword to prevent multiple threads from
    executing the critical section simultaneously. You should consider these general
    strategies:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些类型的问题，我们需要确保关键代码段是原子性地执行的，这可以通过同步来实现。例如，我们可以使用 `synchronized` 关键字来防止多个线程同时执行关键部分。你应该考虑以下一般策略：
- en: '`synchronized` keyword or explicit locks to ensure that only one thread can
    execute a critical section at a time.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `synchronized` 关键字或显式锁来确保一次只有一个线程可以执行关键部分。
- en: '**Atomic operations**: Use atomic operations that are completed in a single
    step without the possibility of being interrupted.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子操作**：使用单步完成且不可能被中断的原子操作。'
- en: '**Sequential design**: Design your program so that thread access to shared
    data is sequenced or coordinated in a manner that eliminates the timing or order
    of events as a factor, reducing the chance of race conditions'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序设计**：设计你的程序，使得线程对共享数据的访问是有序的或协调的，从而消除事件的时间或顺序作为因素，减少竞态条件的发生机会'
- en: '`java.util.concurrent` package provides higher-level synchronization utilities
    such as `Semaphores`, `CountDownLatches`, and `CyclicBarriers`, which can be used
    to coordinate operations between threads and thus prevent race conditions.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包提供了高级同步工具，如 `Semaphores`、`CountDownLatches` 和 `CyclicBarriers`，这些工具可以用来协调线程间的操作，从而防止竞态条件。'
- en: Deadlocks
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: 'A deadlock occurs when two or more threads wait for each other to release a
    resource, resulting in a circular waiting pattern. Here’s an example of a deadlock:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程等待其他线程释放资源，从而形成一个循环等待模式时，就会发生死锁。这里是一个死锁的例子：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: So, please mind the problem here is the incorrect use of the `synchronized`
    keyword! The `thread1` variable acquires a lock on `resourceA` and `thread2` acquires
    a lock on `resourceB`. Then, both threads attempt to acquire a lock on the other
    resource, leading to a deadlock. Meaning that both threads are stuck indefinitely.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请注意这里的问题是 `synchronized` 关键字的错误使用！`thread1` 变量获取了 `resourceA` 的锁，而 `thread2`
    获取了 `resourceB` 的锁。然后，两个线程都试图获取另一个资源的锁，导致死锁。这意味着两个线程都会无限期地卡住。
- en: Strategies to prevent and resolve deadlocks
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止和解决死锁的策略
- en: 'To prevent and resolve deadlocks, you can employ the following strategies:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止和解决死锁，你可以采用以下策略：
- en: '**Avoid nested locks**: Ensure that you only lock one resource at a time, or
    acquire locks in a specific order.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免嵌套锁**：确保一次只锁定一个资源，或者按照特定的顺序获取锁。'
- en: '**Use lock timeouts**: Set a timeout for acquiring locks and release them if
    the timeout expires.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用锁超时**：为获取锁设置超时，如果超时到期则释放锁。'
- en: Livelocks
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活锁
- en: 'A livelock occurs when two or more threads are stuck in a loop, repeatedly
    releasing and re-acquiring resources, without making any progress. Here’s a silly
    example of a livelock:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程陷入一个循环，反复释放和重新获取资源，而没有取得任何进展时，就会发生活锁。这里有一个荒谬的活锁例子：
- en: '[PRE59]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, two `PhoneCall` objects, `Patricia` and `Patrick`, are trying
    to hang up a phone call using a shared `hangUpButton` object. The `hangUpButton`
    object can have only one owner at a time. `Patricia` and `Patrick` both seem to
    have the rule that if they own `hangUpButton` and the other person hasn’t hung
    up yet, they will pass `hangUpButton` to the other person. This leads to a situation
    where the two of them are perpetually passing `hangUpButton` back and forth to
    each other because they’re always seeing that the other person hasn’t hung up
    yet, which is a livelock situation.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个 `PhoneCall` 对象，`Patricia` 和 `Patrick`，正在尝试使用一个共享的 `hangUpButton` 对象挂断电话。`hangUpButton`
    对象一次只能有一个所有者。`Patricia` 和 `Patrick` 都似乎有这样一个规则：如果他们拥有 `hangUpButton` 而对方还没有挂断电话，他们就会将
    `hangUpButton` 传递给对方。这导致他们两个不断地互相传递 `hangUpButton`，因为他们总是看到对方还没有挂断电话，这是一个活锁情况。
- en: Please note that in this particular silly code, there is no mechanism to break
    out of the livelock (the infinite `while` loop in the `callWith` method). In real-world
    scenarios, a mechanism to detect and recover from the livelock should be implemented.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个特定的荒谬代码中，没有机制可以跳出活锁（`callWith` 方法中的无限 `while` 循环）。在实际场景中，应该实现一个检测和从活锁中恢复的机制。
- en: Strategies to prevent and resolve livelocks
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止和解决活锁的策略
- en: 'To prevent and resolve livelocks, consider the following strategies:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止和解决活锁，可以考虑以下策略：
- en: '**Use a backoff algorithm**: Introduce a (very small) random delay or an exponential
    backoff before retrying an operation to minimize the chances of livelock.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用退避算法**：在重试操作之前引入（非常小的）随机延迟或指数退避，以最小化活锁的可能性。'
- en: '**Prioritize resources or threads**: Assign priorities to resources or threads
    to avoid contention and ensure that higher-priority tasks can proceed.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级资源或线程**：为资源或线程分配优先级，以避免竞争并确保高优先级任务可以继续进行。'
- en: '**Detect and recover from livelocks**: Monitor the application for livelocks
    and take corrective action, such as restarting threads or reassigning priorities.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测和从活锁中恢复**：监控应用程序中的活锁，并采取纠正措施，例如重启线程或重新分配优先级。'
- en: A livelock is a special case of resource starvation. It’s a condition where
    two or more processes continuously change their state in response to changes in
    the other process(es) without doing any useful work. Let’s talk about starvation
    next.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 活锁是资源饥饿的特殊情况。这是一种状态，其中两个或多个进程不断地根据其他进程（或多个进程）的变化改变自己的状态，而不做任何有用的工作。接下来，让我们谈谈饥饿问题。
- en: Starvation
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饥饿
- en: 'Starvation occurs when a thread is unable to access shared resources for an
    extended period, hindering its progress. This usually happens when higher-priority
    threads monopolize resources, causing lower-priority threads to be starved. Here’s
    an example of starvation:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程无法在较长时间内访问共享资源时，就会发生饥饿，阻碍其进展。这通常发生在高优先级线程垄断资源，导致低优先级线程饥饿。以下是一个饥饿的例子：
- en: '[PRE60]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, the high-priority thread monopolizes the shared resource for
    a long time, causing the low-priority thread to be starved. Please mind that thread
    priorities are only hints of how to the scheduler. It’s up to the OS implementation
    to decide.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，高优先级线程长时间垄断共享资源，导致低优先级线程饥饿。请注意，线程优先级只是给调度器的提示。具体由操作系统实现来决定。
- en: Strategies to prevent and resolve starvation
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止和解决饥饿的策略
- en: 'To prevent and resolve starvation, you can employ the following strategies:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止和解决饥饿，你可以采用以下策略：
- en: '`ReentrantLock` with the `fair` parameter set to `true`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock` 将 `fair` 参数设置为 `true`。'
- en: '**Monitor resource usage**: Keep track of resource usage and adjust thread
    priorities or access patterns to avoid monopolization.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控资源使用**：跟踪资源使用情况，并调整线程优先级或访问模式以避免资源垄断。'
- en: '**Use time-sharing**: Limit the time for which a thread can hold a resource
    or ensure that each thread gets a chance to access the resource periodically.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用时间共享**：限制线程持有资源的时间，或确保每个线程定期有机会访问资源。'
- en: And that’s it for now! There’s a lot more to know about concurrency in fact,
    we could write an entire book on it – but this will be enough to get you started.
    Time to roll up your sleeves and get started with the hands-on part!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止就这些了！实际上关于并发还有很多知识要了解，我们甚至可以为此写一本书——但这些都足以让你开始。现在是时候卷起袖子，开始动手实践部分了！
- en: Exercises
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '`FeedingActivity` and `CleaningActivity`. Make `FeedingActivity` extend the
    `Thread` class and `CleaningActivity` implement the `Runnable` interface. In both,
    override the `run` method to print out the activity’s name and a message indicating
    that the activity is happening.'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FeedingActivity` 和 `CleaningActivity`。让 `FeedingActivity` 继承 `Thread` 类，而
    `CleaningActivity` 实现 `Runnable` 接口。在这两个类中，重写 `run` 方法以打印出活动的名称和表示活动正在进行的消息。'
- en: '`ParkOperations` class with two threads, one for feeding and another for cleaning.
    Start both threads and then use `sleep()` to simulate a time delay for the feeding
    activity. Use `join()` to ensure cleaning only happens after feeding is complete.'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ParkOperations` 类有两个线程，一个用于喂食，另一个用于清洁。启动这两个线程，然后使用 `sleep()` 模拟喂食活动的延迟。使用
    `join()` 确保清洁只在喂食完成后进行。'
- en: '`TaskAssigner` class where you use `ExecutorService` to assign tasks to employees.
    Tasks could be represented as `Runnable` or `Callable` objects, and employees
    could be represented as threads.'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskAssigner` 类，其中使用 `ExecutorService` 将任务分配给员工。任务可以用 `Runnable` 或 `Callable`
    对象表示，员工可以用线程表示。'
- en: 'Solve race conditions in the following code snippet. `updater1` and `updater2`
    both are trying to update the status of the same dinosaur object. Since they run
    concurrently, it might lead to inconsistent outputs. Use the `synchronized` keyword
    or `AtomicReference` to prevent data inconsistency:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决以下代码片段中的竞态条件。`updater1` 和 `updater2` 都试图更新同一个恐龙对象的状态。由于它们是并发运行的，可能会导致输出不一致。使用
    `synchronized` 关键字或 `AtomicReference` 防止数据不一致：
- en: '[PRE61]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Project – Park Operations System – the calm before the storm
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 - 公园运营系统 - 暴风雨前的平静
- en: While our park thrives with lively dinosaurs and excited visitors, our behind-the-scenes
    operations must run concurrently and seamlessly. The use of concurrency can ensure
    that tasks such as feeding dinosaurs, tracking dinosaur movements, and scheduling
    staff shifts are handled efficiently.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的公园因充满活力的恐龙和兴奋的游客而繁荣时，幕后的运营必须并发且无缝进行。使用并发可以确保像喂食恐龙、跟踪恐龙移动和安排员工班次等任务得到有效处理。
- en: However, despite our best efforts, things start to go awry. A few dinosaurs
    become restless, security systems begin to glitch, and staff reports mysterious
    occurrences. Could this be the calm before the storm, and will we relive what
    happened in a famous competing park they made a movie about?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们尽了最大努力，事情开始变得不顺利。一些恐龙变得不安分，安全系统开始出现故障，员工报告了神秘事件。这可能是暴风雨前的平静，我们是否会再次经历那个著名的竞争公园发生的事情？
- en: Update the following *Park Operations System* so that it concurrently safely
    handles different park operations. Use low-level threading, `ExecutorService`,
    atomic classes, synchronized blocks, and the `Lock` interface to manage concurrent
    access to shared resources. Prevent and handle race conditions, deadlocks, livelocks,
    and starvation scenarios to keep things under control as tensions rise.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 更新以下 *公园运营系统*，以便它能够并发安全地处理不同的公园运营。使用低级线程、`ExecutorService`、原子类、同步块和 `Lock` 接口来管理对共享资源的并发访问。防止和处理竞争条件、死锁、活锁和饥饿场景，以保持事物在紧张局势上升时处于控制之下。
- en: 'Here’s the problematic code that causes the issues:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是导致问题的有问题的代码：
- en: '[PRE62]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, there is a race condition when accessing and modifying `foodStock`.
    Additionally, these threads will run indefinitely, creating the potential for
    starvation of other threads in the system.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在访问和修改 `foodStock` 时存在竞争条件。此外，这些线程将无限运行，可能会造成系统中其他线程的饥饿。
- en: 'Here are some hints for modifications:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些修改的提示：
- en: '`Lock` interface, or an atomic class. Remember, the goal is to ensure that
    the `reduceFood()` method and the reading of `foodStock` happen atomically.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock` 接口，或一个原子类。记住，目标是确保 `reduceFood()` 方法和对 `foodStock` 的读取是原子性的。'
- en: '`ExecutorService`: Rather than creating threads directly, you could use `ExecutorService`
    to manage the threads. This provides more flexibility and utility methods for
    handling threads.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`：而不是直接创建线程，你可以使用 `ExecutorService` 来管理线程。这提供了更多的灵活性和线程处理实用方法。'
- en: '`run` methods of `FeedingDinosaurs` and `TrackingMovements` run indefinitely.
    You could use conditions to control these loops and ensure `ExecutorService` shuts
    down after the operations are complete.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FeedingDinosaurs` 和 `TrackingMovements` 的 `run` 方法会无限运行。你可以使用条件来控制这些循环，并确保在操作完成后
    `ExecutorService` 关闭。'
- en: '**Deadlocks, livelocks, and starvation**: To simulate and prevent these, consider
    adding more shared resources and threads, and experiment with different locking
    orders, lock-releasing mechanisms, and thread priorities.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁、活锁和饥饿**：为了模拟和防止这些情况，请考虑添加更多共享资源和线程，并尝试不同的锁定顺序、锁定释放机制和线程优先级。'
- en: Remember to be cautious when modifying the code to prevent and handle these
    concurrency issues. Incorrect modifications could cause more problems than they
    solve. Thank you for saving the day!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 修改代码时请谨慎，以防止和处理这些并发问题。不正确的修改可能会造成比解决的问题更多的问题。感谢您挽救了这一天！
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Concurrency is a fundamental concept in modern software development, allowing
    applications to perform multiple tasks simultaneously, and efficiently utilizing
    system resources. In this chapter, we explored various aspects of concurrent programming
    in Java, from basic thread creation and management to advanced techniques for
    handling synchronization and shared data.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是现代软件开发中的一个基本概念，它允许应用程序同时执行多个任务，并有效地利用系统资源。在本章中，我们探讨了 Java 中并发编程的各个方面，从基本的线程创建和管理到处理同步和共享数据的高级技术。
- en: 'We started by introducing concurrency and its importance, followed by walking
    through creating threads using the `Thread` class, the `Runnable` interface, and
    implementing the `Runnable` interface with lambda expressions. We then moved on
    to two thread management methods: `sleep()` and `join()`. Next, we talked about
    `ExecutorService`, which provides a higher level of abstraction for managing thread
    execution and made our lives a little easier (after making it harder first).'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了并发及其重要性，然后通过使用 `Thread` 类、`Runnable` 接口以及使用 lambda 表达式实现 `Runnable` 接口来创建线程。然后，我们转向了两种线程管理方法：`sleep()`
    和 `join()`。接下来，我们讨论了 `ExecutorService`，它为管理线程执行提供了更高层次的抽象，使我们的生活变得稍微容易一些（在使其变得更难之后）。
- en: A crucial aspect of concurrent programming is avoiding data races. We demonstrated
    a data race example and discussed strategies to resolve them, including the use
    of atomic classes and the `synchronized` keyword. We also explore the `Lock` interface
    as an alternative to the `synchronized` keyword. This gave us more flexibility
    and control.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的一个关键方面是避免数据竞争。我们演示了一个数据竞争示例，并讨论了解决策略，包括使用原子类和 `synchronized` 关键字。我们还探讨了
    `Lock` 接口作为 `synchronized` 关键字的替代方案。这给了我们更多的灵活性和控制力。
- en: Concurrent collections, such as `ConcurrentHashMap`, `CopyOnWriteArrayList`,
    and `ConcurrentLinkedQueue`, provide thread-safe alternatives to standard Java
    collections. We briefly mentioned their benefits and use cases and saw some examples
    of their usage.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 并发集合，如`ConcurrentHashMap`、`CopyOnWriteArrayList`和`ConcurrentLinkedQueue`，提供了对标准Java集合的线程安全替代方案。我们简要介绍了它们的优点和用例，并看到了一些它们的使用示例。
- en: Finally, we examined common threading problems, including data races, race conditions,
    deadlocks, livelocks, and starvation. We provided examples and strategies to prevent
    and resolve these issues. By this point, you should have a solid understanding
    of concurrent programming in Java and be equipped with the skills to deal with
    multi-threaded applications.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了常见的线程问题，包括数据竞争、竞态条件、死锁、活锁和饥饿。我们提供了示例和策略来预防和解决这些问题。到这一点，你应该对Java中的并发编程有了扎实的理解，并且具备了处理多线程应用程序的技能。
