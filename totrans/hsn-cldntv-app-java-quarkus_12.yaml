- en: Unifying Imperative and Reactive with Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest challenges for enterprise applications has traditionally
    been combining business operations, which are inherently synchronous, with dispatching
    the results of these operations, which can be also asynchronous and event-driven.
    In this chapter, we will learn how the Vert.x toolkit can address this challenge
    in Quarkus applications by combining standard imperative programming with asynchronous
    data streams that can be created, changed, or combined at runtime. By the end
    of this chapter, you should be proficient in writing reactive applications on
    the JVM using Vert.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Reactive Programming and the Vert.x toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vert.x API models available in Quarkus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the Reactive SQL Client with Vert.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying Reactive Programming and Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imperative programming is the way most programmers write their code every day.
    Wait a minute â€“ what does imperative programming mean? In a concise statement,
    we can say that imperative programming means that lines of code get executed in
    a sequence, statement by statement, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, imperative programming can use loops or conditional statements
    to jump to different parts of code. Don't be fooled by this, though. As long as
    your debugger clearly points to a statement in your code (and thus it's obvious
    what line will be executed next), you are definitely using imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: While the imperative programming model is clearly simpler to understand, it
    can badly impact scalability as the number of connections tends to grow. As a
    matter of fact, the number of system threads will have to be increased accordingly,
    causing your OS to spend significant CPU cycles just for thread scheduling management.
    That's where Vert.x comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a definition: what exactly is Vert.x? Vert.x is not an application
    server or a framework but merely a toolkit or, if you prefer, a set of plain JAR
    files that can be added as a dependency to your projects. Easy-peasy. You don''t
    need a specific development environment or plugin to develop applications with
    Vert.x either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, Vert.x is a reactive toolkit that fulfills the requirements dictated
    by the **Reactive Manifesto** ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)).
    These requirements can be summarized in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: A reactive system needs to be capable of handling requests
    in a reasonable time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: A reactive system must be designed to handle failures and deal
    with them appropriately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic**: A reactive system must be able to scale up and down according
    to loads without compromising the responsiveness of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven**: The reactive system''s components interact with each other
    by exchanging asynchronous messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on the preceding points, it''s clear that Vert.x promotes a new way of
    designing and building distributed systems while infusing asynchrony, scalability,
    and reactiveness into the core of your applications. Therefore, with regard to
    our former example, it can be rewritten in a reactive way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the former example, by using Vert.x, the running thread is released while
    the connection with the HTTP server is being established. Then, when the response
    has been received, a handler coded as a Lambda expression ([https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html))
    is called back to deal with the response.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `vertx` field can be used in your code each time
    you extend the Vert.x basic unit of deployment, which is called a **Verticle**.
    In essence, a Verticle processes incoming events over an event loop, creating
    the foundation for an asynchronous programming model. Verticles can be written
    in various languages, not only Java, so you can mix different environments as
    part of a larger reactive system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main tool for allowing different Verticles to communicate with each other
    is called the **Event Bus**, and communication happens through asynchronous message
    passing. The following diagram shows how the **Event Bus** fits into this schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/453ec3ac-428a-4835-9e16-02e973e72744.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Event Bus doesn''t pose any restrictions on the kind of data format you
    use, although JSON is the preferred exchange format since it is a popular option
    for structuring data, allowing Verticles written in different languages to communicate.
    The Event Bus supports the following communication patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point-to-point** messaging, which means that messages are routed to just
    one of the handlers registered at that address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request-respon****se** messaging, which is similar to point-to-point messaging,
    except that it includes an optional reply handler that can be specified while
    sending the message so that the recipient can decide whether to reply to the message.
    If they do so, the reply handler will be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish-subscribe**, which allows you to broadcast messages using a publish
    function. In this case, the event bus will route messages to all the handlers
    that are registered against that address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there are multiple communication patterns, several API models have been
    designed for Vert.x and are all based around the concept of executing the flow
    in an asynchronous way via callbacks. The next section discusses a variety of
    Vert.x API models that are available in Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: Vert.x API models in Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vert.x provides a large ecosystem of reactive APIs that are integrated into
    Quarkus. More specifically, Quarkus uses Vert.x as the reactive engine by providing
    a single dependency to your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to access a managed Vert.x instance with simple code injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Vertx` object is the control center of a Vert.x application. It's your
    pass to Vert.x land and allows you to create an asynchronous and non-blocking
    client and servers, get a reference to the Event Bus, and many other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Vert.x API in Quarkus, however, there''s no `Vertx` object for you
    to access. As a matter of fact, Quarkus provides three different Vert.x APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io.vertx.core.Vertx`: This is the entry point into the Vert.x core API and
    allows you to achieve asynchronous and non-blocking clients and servers using
    callbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.vertx.reactivex.core.Vertx`: This API allows us to use observable patterns
    in our Vert.x applications wherever we can use streams or asynchronous results.
    Additionally, it allows us to use a large set of data transformation operators
    on our streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.vertx.axle.core.Vertx`: This API has been specifically designed to integrate
    with Quarkus'' MicroProfile patterns, proving a solid foundation for sending and
    receiving asynchronous messages, thus enforcing loose coupling between services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to learn about all three different variations of Vert.x, we have provided
    an equal number of examples in the `Chapter09` folder in this book's GitHub repository.
    Let's take a look at them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Vert.x core API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of learning about the Vert.x core API, we will be using a modified
    version of our basic customer service application, which we discussed in [Chapter
    4](1eb0a987-ab8b-40a1-ab16-6562b8a45344.xhtml), *Adding Web Interfaces to Quarkus
    Services*. You can find the source code for this example of the `Chapter09/core/customer-service`
    folder in this book's GitHub repository. We recommend that you import the project
    into your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s dive straight into the code. Since the Vert.x core API is based
    around the callback mechanism, in order to leverage asynchronous and non-blocking
    APIs, for our customer service example we have added two functions that will read
    and write a list of customers from the filesystem in JSON format. Where shall
    we write our customer list? The answer is into the `application.properties` file,
    which defines a property named `file.path`, which is where the customer list will
    be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the code. The core class that''s responsible for providing
    customer data is `CustomerRepository`. There we''ll inject an instance of `io.vertx.core.Vertx`
    at this point. We will also inject the path where the data will be stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the interesting bit, that is, writing a method that uses the `vertx`
    instance to flatten our list of customers on the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you may have noticed is the `CompletionStage` method''s signature.
    If you have been programming async Java code, you may be familiar with the `java.util.concurrent.Future`
    API. It''s used to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the execution has completed via the `isDone()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel the execution using the `cancel()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch the result of the execution using the blocking `get()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The major limitation of this approach is that the caller cannot manually complete
    the task, nor can it chain multiple `Future` executions.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `CompletionStage` is based on the concept of stages, which
    are thought of as multiple intermediate computations and may or may not be asynchronous.
    In any case, we have to complete them before we reach the final result. These
    intermediate computations are known as **completion stages**.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `CompletionStage` stage, you can easily address the `java.util.concurrent.Future`
    API''s limitations by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually completing `CompletableStage` using `complete(T value)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining multiple `CompletableStage` in a block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get back to our example. Once we have created `JsonArray` out of our customer
    list, we can access our `FileSystem` using the Vert.x core API. We can also register
    a handler that is in charge of completing our `CompletionStage` as soon as the
    file has been successfully written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `readFile` method, which is in charge of reading
    the file that contains the customer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readFile` method is intentionally a bit more complex. As a matter of fact,
    we have chained two different stages into it. The first one executes a one-time
    timer that will fire the next execution in 100 ms. Timers are a core construct
    of Vert.x and should be used wherever you want to delay the execution of some
    code or execute it repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In any case, timers are how you can delay the execution in Vert.x terms in place
    of other mechanisms, such as `Thread.sleep`, which would block the event loop
    and therefore should **never**, ever be used in the Vert.x context.
  prefs: []
  type: TYPE_NORMAL
- en: If you forget our gentle warning, Vert.x will remind you each time you attempt
    to use a blocking code in the Vert.x context with a log message similar to *Thread
    vertx-eventloop-thread-1 has been blocked for 22258 ms.*
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the `readFile` method does exactly the opposite of the
    `writeFile` method; that is, it reads the JSON file and completes the stage as
    soon as the file has been read.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to expose this feature to the client application, we have added two
    wrapper methods to our `CustomerEndpoint` class in order to expose the functions
    via the REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting that the `writeFile` method produces text information since
    it's supposed to return a simple text message to the caller. On the other hand,
    the `readFile` method relies on the class' default `application/json` format to
    display the JSON text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to the client-side. We can easily capture the `CompletionStage`
    event using two more AngularJS handlers, which will capture the result as soon
    as it''s available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions will be triggered with the addition of two simple buttons to
    our home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides doing this, we have also added a `div` section to our HTML schema,
    which is where information will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Without further ado, let''s build and run the application with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is our new UI, which includes the Read File and Write File buttons.
    We have just saved a set of `Customer` objects, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59ac264c-73dd-44c5-a54a-7bcaa4ff5403.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Conversely, if we hit the Read File button, its content will be displayed in
    the lower `div` of the page in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f5fce28-facd-48b1-85f0-da83b7380be5.png)'
  prefs: []
  type: TYPE_IMG
- en: We have completed the first round with Vert.x core. Now, let's move on and look
    at using Vert.x with **ReactiveX** (**RxJava**).
  prefs: []
  type: TYPE_NORMAL
- en: Managing Vert.x API for RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RxJava ([https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava))
    is a Java library that lets you create asynchronous and event-based applications
    using `Observable` sequences for the Java VM. In order to understand the core
    features of this framework, we need to define the core actors of ReactiveX, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**: These represent the source of data to be emitted. An observable
    starts providing data once a subscriber starts to listen. An observable may emit
    a variable number of items and will eventually terminate with success or with
    an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers:** These listen to events that are emitted by observables. There
    can be one or more subscribers for one observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the relationship between these two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae69de57-5da3-409c-a331-3cb57443f8f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the number of items emitted and the control of the flow of items,
    we can distinguish between different types of observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observable type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Flowable<T>` | Emits *0* or *n* items and terminates with a success or an
    error event. Supports backpressure, which allows us to control the rate of source
    emission. |'
  prefs: []
  type: TYPE_TB
- en: '| `Observable<T>` | Emits *0* or *n* items and terminates with a success or
    an error event. |'
  prefs: []
  type: TYPE_TB
- en: '| `Single<T>` | Emits either one value or an error notification. |'
  prefs: []
  type: TYPE_TB
- en: '| `Maybe<T>` | Emits a single item, no items, or an error event. The reactive
    version of an optional call. |'
  prefs: []
  type: TYPE_TB
- en: '| `Completable` | Wraps the deferred computation without any value but only
    as an indication of completion or an exception. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s provide a minimalist example of this. The following is a `Hello world`
    example of an `Observable` that emits a single item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the subscriber receives the item, it simply prints it on the out stream.
    The following code is slightly different as it uses a `Flowable` observable to
    control the flow of items in the event you are pushing out data at a high rate,
    which could overflood your subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One important concept of RxJava programming is **operators**; an operator is
    a function that defines an `Observable` and how and when it should emit the data
    stream. We have already met one, that is, the `just` operator, which allows you
    to convert an object or a set of objects into an `Observable`. In our first example,
    the object was the `Hello world` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many more operators, all of which can be found in RxJava''s documentation
    ([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)).
    For example, you can suppress duplicates in a stream of data using the `distinct`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the expected output from the subscriber will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also chain another operator to filter out items that don''t meet a
    pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have guessed, the output will be further restricted to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although we have barely scratched the surface of RxJava's power, we have a minimal
    background to how we plug these concepts into our example application.
  prefs: []
  type: TYPE_NORMAL
- en: Using RxJava with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to learn about RxJava, we will go through the example contained in
    the `Chapter09/rx2java/customer-service` folder in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you should be aware of is that, in order to use RxJava with
    Quarkus, you have to add an instance of `Vertx`, which can be found under the
    `io.vertx.reativex.core` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That being said, one of the main advantages of including ReactiveX in our project
    is that it will greatly enhance the capability of **transforming** data that flows
    between the observable and the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s take a look at the following use case:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to produce a file with a list of customers to be imported in a spreadsheet.
    Therefore, we will create a plain CSV file out of our customer list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we want to convert the CSV file into any other format is coded in the
    customer's `toString` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s learn how to operate the right changes on the `CustomerRepository` class.
    As we mentioned previously, the first change is to replace the `io.vertx.core.Vertx`
    instance with the corresponding `io.vertx.reativex.core.Vertx`. Then, we will
    apply some changes to the `writeFile` and `readFile` methods. Let''s begin with
    the `writeFile` method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you have found our introduction to observables intuitive, the preceding code
    won't look overly complex, in spite of the proliferation of Lambda expressions.
    Here, we have added a long list of operators to produce the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have produced a set of observables by iterating over the customer
    list using the `Observable.fromIterable` operator. Since we need to produce a
    CSV file, we need to map single customer fields with the CSV format, which uses
    a comma (`,`) to separate the values. We have used the `map` operator for this
    purpose. Then, we are done with transformation and the result will be a list of
    observables that are in the format we have chosen.
  prefs: []
  type: TYPE_NORMAL
- en: For an observer (or subscriber) to see items that are being emitted by `Observable`,
    along with errors or completed notifications from `Observable`, it must subscribe
    to that `Observable` using the `subscribe` operator. In a nutshell, the `subscribe`
    operator is the glue that connects a subscriber to an `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: Our subscriber will receive notifications when new items are added so that they
    can be appended to `StringBuffer`, which has already been initialized with the
    CSV header. The subscriber will also receive notifications in case of errors and
    eventually, when the stream of items gets completed, via the `()` handler. In
    this case, the CSV file will be written to the filesystem using the `writeFile`
    function, which is also available in the `io.vertx.reativex.core.Vertx` filesystem
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `readFile` method will need to reverse the CSV file we have already
    written into the representation of the `Customer` object, as provided by its `toString`
    method. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have to familiarize ourselves with some more operators. Since we want
    to read and process the file line by line, we are using the `flatMapObservable`
    operator to produce our array of multiple `Observable` instances. In practice,
    this operator allows us to produce a set of `Observable` instances that are the
    result of a function being emitted by a single item the line in our CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have conveniently split the file into an array using the `split` method
    of the string''s class. Then, we used the `skip` operator to skip the first item,
    which is the CSV header. After, we applied two `map` transformations to the data:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one creates an array of string objects, out of the CSV line, using
    the comma (`,`) as a separator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we created an instance of the `Customer` object using the data arriving
    from the string array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have collected our target data, which is a `Customer` object, we
    are ready to stream this data, which will eventually be collected by the subscriber.
    The subscriber, in turn, receives each item and adds the `toString()` output from
    it to the `StringBuffer`. You can include any format in your `toString()` method,
    but to keep it simple, we have let our IDE (IntelliJ IDEA) self-generate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we''ll do is set the media type of `readFile` so that it''s
    consistent with the format of our `toString` data. Since we are producing simple
    text, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can just run the application and check the new outcome. The following
    is what your UI should look like once you''ve added some customers and clicked
    on the Write File button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/579d5247-c8fd-4625-adfe-e1db4b6f2a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, by hitting the Read File button, the lower HTML `div` will contain the
    `toString` data for each customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/173ae975-e619-49b2-8c73-92b4d6fbc23d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, in spite of the minimalist UI log, there is plenty of work being
    done under the hood to manage the transformation of data in different kinds of
    format.
  prefs: []
  type: TYPE_NORMAL
- en: That was our second implementation of Vert.x and Quarkus. We still have to deal
    with the third beast, which is `io.vertx.axle.core.Vertx`.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling events with Vert.x axle libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, we want to separate our service entry points (adapters) from the
    business logic, which is part of the application. A common pattern is to keep
    the service in a distinct bean, which is injected into our service REST entry
    point. When approaching Reactive Programming, however, we can decouple even more
    of our components by bringing the Vert.x Event Bus into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this kind of architecture, components communicate with each other by sending
    messages to virtual addresses. To manage the distribution of messages, the following
    components are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EventBus**: This is a lightweight distributed messaging system that allows
    communication between the different parts of your application in a loosely coupled
    way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message**: This contains data that is received from the Event Bus in a handler.
    Messages have a body and a header, both of which can be null. By adding a reply
    handler in the message, it is possible to apply a request-response pattern to
    the communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn how we can instrument a simple messaging pattern by using the example
    application that's available in the `Chapter09/axle/customer-service` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an EventBus layer to Quarkus applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To include a distributed peer-to-peer messaging pattern in our application,
    we will need to inject the `EventBus` instance into a CDI bean, which will act
    as a receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we will add the `EventBus` to the `CustomerEndpoint` class.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that there is only one single instance of the Event Bus per Vert.x
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the same class, let''s create a new endpoint method, which will be
    in charge of dispatching messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We are conveying messages on the bus through the `"callcustomer"` address. The
    body of the message contains the `Customer` object, which is retrieved by the
    `findCustomerById` method. In the event of an error, a throwable with the error's
    `getMessage` content will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a consumer for messages, so we will add another class named `CustomerService`,
    which contains a method annotated as `@ConsumeEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Within the `@ConsumeEvent` annotation, we are specifying the address where messages
    are consumed. At the end of the day, we are merely returning a response containing
    a message from the customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the loop, we need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add one more button to the `index.html` page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add one more AngularJS controller to handle the response, which
    will display (in an alert window) the message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have added everything, let's run our application.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling up the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When all the changes are in place, you should be able to see that the Call
    button has been added to each customer''s row, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65752cf0-e3d0-4b77-b5b4-9e388c6ea837.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on the Call button, a message will be sent through the Event
    Bus. As soon as it''s consumed, you should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/505134b9-4543-446a-be13-13b64b9f08be.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides peer-to-peer messaging, you can also use the Vert.x axle API to stream
    **Server-Side Events** (**SSEs**).
  prefs: []
  type: TYPE_NORMAL
- en: Streaming SSE with Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, web applications are capable of sending a request to servers
    to receive a response; that is the standard paradigm. With server-send events,
    however, it's possible for the server application to send new data to a web page
    at any time by pushing events (messages) to the web page. These incoming messages
    are treated as events combined with data inside the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s demonstrate how to use the Vert.x axle API to stream SSEs in Quarkus.
    The following class, which has been included in our project, is in charge of sending
    an SSE to the home page every two seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First off, notice that we are using an instance of `io.vertx.axle.core.Vertx`
    to handle the streaming of events. Then, our REST method, which is bound to the
    `"/streaming"` URI, is annotated with a different media type, that is, `SERVER_SENT_EVENTS`.
    The method returns a publisher type, which is required in order to publish Reactive
    Streams.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `ReactiveStreams.fromPublisher` method, we push stream events based
    on the frequency specified by `vert.xperiodicStream`. In our case, messages will
    be dispatched every two seconds. Before sending the actual event, the content
    will be transformed by the `map` operator, which will create a message with some
    `Customer` statistics, such as the number of customers and the last one added.
    By using the ternary operator, we managed to compress this login into just one
    statement, at the expense of slightly more complex readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all you need on the server-side. On the client-side, we made some other
    adaptations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We added one more button to trigger the SSE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a callback method, in JavaScript, to handle the event that was received:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a `div` where messages will be displayed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the updated application, the expected outcome is a UI that includes
    the Stats button at the bottom of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2901875-bcc9-49ee-a8ba-810a390dbf2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The lower `div` will be updated every two seconds, based on the data contained
    in the customer list.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that SSE subscriptions can be canceled by keeping a
    reference to the `Subscription` object so that you can cancel your subscription
    at any time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, when the event is emitted, the observer's `onNext`
    method is called with the item and the `onComplete` method is invoked immediately
    after. On the other hand, when the callback is a failure, the observer's `onError`
    method is called. Within any callback method, we can cancel the subscription using
    the `cancel` method on the subscription object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was our last piece of work with Reactive Events, but not the last with
    Vert.x. We still have one more thing to cover: Quarkus'' Reactive SQL Clients.
    This is an API that focuses on scalable JDBC connections with minimal overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Reactive SQL Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Reactive SQL Client is an API that allows you to use reactive and non-blocking
    features of Vert.x to access a relational database. This brings some changes in
    terms of how you access your data. Let''s put the costs and benefits on the table:'
  prefs: []
  type: TYPE_NORMAL
- en: On one side, you will need to use SQL statements to enable your RDBMS to access
    data, instead of the abstract HQL. Also, automatic mapping between Java classes
    and DB is not available anymore since Hibernate is out of the game here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, you will be able to use a fully event-driven, non-blocking,
    lightweight alternative to stream the result of your SQL statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on your requirements, you may stick with Hibernate's API or switch to
    Reactive's SQL Client. Let's say you're brave and want to switch to Reactive SQL.
    To do that, you will need to configure your application so that it can use the
    PostgreSQL Reactive Client API.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your application to use the PostgreSQL reactive client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to delve into the reactive Client API, please refer to the example
    contained in the `Chapter09/pgpool` folder in this book''s GitHub repository.
    Since this example won''t use the PostgreSQL JDBC driver, the following dependency
    has been added as a replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The other configuration we added was the JDBC URL, which needs to be in the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, in our example, we will add this setting in `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the changes in our application. To keep things as simple
    as possible, we have broken down our example so that it just uses the `CustomerEndpoint`
    and the `Customer` POJO class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the `CustomerEndpoint`, which requires access to `io.vertx.axle.pgclient.PgPool`
    and `io.vertx.core.Vertx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the same class, we have added an `init` method to create some data at
    startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Pgpool's `query` method returns a `CompletionStage` object with a `RowSet` of
    data, as a result of the query. Please note how we can chain multiple statements
    to produce a `CompletableFuture`, which spins off the execution in another thread.
    Within this simple method, you can experience how powerful reactive SQL clients
    can be when it comes to creating event-driven, non-blocking SQL executions. You
    will eventually get the combined result of all the statements by executing the
    `join` method of `CompletableFuture` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other methods of `CustomerEndpoint` delegate the execution of CRUD statements
    to the `Customer` class using the same composition pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `Customer` class, we have coded all the methods that are required
    to perform CRUD operations. The first one, `create`, performs an `INSERT` in the
    `CUSTOMER` table by using `PreparedStatement`, which applies a tuple containing
    the name and surname as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In much the same way, the `update` method executes an `UPDATE` through a `PreparedStatement`,
    and applies the customer''s tuple of data as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a customer, the `delete` method executes `PreparedStatement`, which
    uses the customer `id` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `findAll` method is used to query a list of customers from the
    database and returns them as a Java list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have finished coding our application. Let's get it running!
  prefs: []
  type: TYPE_NORMAL
- en: Running the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before running the example, make sure you have bootstrapped the PostgreSQL
    database; otherwise, the initial statements will fail when the application is
    deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the application as usual with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI hides the fact that we have switched from plain objects to a real database,
    though you can work out that this has happened from the page title, which is now
    Quarkus Vert.X PgPool Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd40a029-5c1c-4dcf-ba2b-0e2af385763d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if you log in to the database container, you verify sure that the
    `Customer` table has been created with its items. Let''s find the container ID
    for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go into the bash shell of the PostgreSQL container by using the
    `docker exec` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the list of relationships using the `\dt` shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also query the `Customer` table''s rows, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have completed our first reactive SQL application with Quarkus. This
    also marks the end of our journey into the land of Vert.x.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this whirlwind tour of Reactive Programming, you should be proficient in
    writing reactive applications on the JVM. Your programming skills now include
    how to use the Vert.x core API to write asynchronous and non-blocking services.
    You have also learned how to combine the `Observable` pattern with streams or
    asynchronous results using the Vert.x Reactive API. Then, we quickly explored
    the last Vert.x paradigm, Vert.x Axle, which allows different beans to interact
    using asynchronous messages and enforces loose coupling. Finally, we applied a
    reactive API to access a relational database using the PostgreSQL client extension
    for Vert.x.
  prefs: []
  type: TYPE_NORMAL
- en: Although you've gotten to grips with the Reactive Programming API, note that
    much of its power can only be unleashed when building real-time data pipelines
    and streaming data. We will cover these in the next chapter.
  prefs: []
  type: TYPE_NORMAL
