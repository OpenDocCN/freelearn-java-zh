- en: Part 1. Module 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Clojure for Java Developers**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Transition smoothly from Java to the most widely used functional JVM-based
    language – Clojure*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Chapter 1. Getting Started with Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the world of Clojure! If you are here, you probably know a little
    about Lisp or Clojure, but you don't really have an idea of how things work in
    this world.
  prefs: []
  type: TYPE_NORMAL
- en: We will get to know Clojure by comparing each feature to what you already know
    from Java. You will see that there are lists, maps and sets just like in Java,
    but they are immutable. To work with these kinds of collections, you need a different
    approach; a different paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we will try to accomplish in this book, to give you a different
    way to approach problems. We hope you end up using Clojure in your every day life,
    but if you don't, we hope you use a new approach toward problem solving.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Leiningen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a **Read Eval Print Loop** (**REPL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using Cursive Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure's simple syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure's data types and their relationship to the JVM's data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special syntax for functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started with Clojure, you should know some of its features and
    what it shares with Java.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is a programming language that inherits a lot of characteristics from
    Lisp. You might think of Lisp as that weird programming language with all the
    parentheses. You need to keep in mind that Clojure chooses to embrace functional
    programming. This makes it very different from current mainstream programming
    languages. You will get to know about immutable data structures and how to write
    programs without changing variable values.
  prefs: []
  type: TYPE_NORMAL
- en: You will also find that Clojure is a dynamic programming language, which makes
    it a little easier and faster to write programs than using statically typed languages.
    There is also the concept of using a REPL, a tool that allows you to connect to
    a program running environment and change code dynamically. It is a very powerful
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: At last, you will find out that you can convert Clojure to anything you like.
    You can create or use a statically typed system and bend the language to become
    what you like. A good example of this is the `core.typed` library, which allows
    you to specify the type information without adding support to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Leiningen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are used to having certain tools to help us build our code, such as Ant,
    Maven, and Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Clojure ecosystem, the de facto standard for dependency and build management
    is Leiningen (affectionately named after the short story "Leiningen versus the
    Ants", which I recommend reading at [http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants](http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants));
    Leiningen strives to be a familiar to Java developers, it gets the best ideas
    from Maven, like: convention over configuration. It also gets ideas from Ant like
    custom scripting and plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing it is very simple, let's check how to do it on Mac OS X (installing
    on Linux should be the same) using bash as your default shell.
  prefs: []
  type: TYPE_NORMAL
- en: You should also have Java 7 or 8 already installed and configured in your path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the detailed instructions on the Leiningen project page [http://leiningen.org/](http://leiningen.org/).
    If you want to get a Leiningen installation up and running, this is what you would
    have to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first time you run the `lein` command, it downloads everything needed from
    the internet. This makes it very easy to distribute your code, you can even include
    the `lein` script with your own projects and make it easier for other developers
    to get up and running, the only real requirement is the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Using a REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main advantages of Clojure (and Lisp) is interactive development,
    the REPL is the base of what can be achieved with interactive programming, it
    allows you to connect to a running VM running Clojure and execute or modify code
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: There is a story about how NASA was able to debug and correct a bug on a $100
    million piece of hardware that was 100 million miles away ([http://www.flownet.com/gat/jpl-lisp.html](http://www.flownet.com/gat/jpl-lisp.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have that same power with Clojure and Leiningen and invoking it is very
    simple, you just need a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you''ll get after running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a REPL](img/B04289_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go into a bit more detail, as we can see we are running with the following
    programs:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure 1.6.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also get some nice suggestions on how to see documentation, `source`,
    `Javadoc`, and previous errors.
  prefs: []
  type: TYPE_NORMAL
- en: The nREPL protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One particular thing that is important to note is the nREPL protocol; Someday
    it might grant us the power to go into a machine running 100 million miles away.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you fire up your REPL, the first thing you see is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What it is saying is that there's a Clojure process running an nREPL server
    on port `55995`. We have connected to it using a very simple client that allows
    us to interact with the Clojure process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The really interesting bit is that you can connect to a remote host just as
    easily; let''s try attaching an REPL to the same process by simply typing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Most IDEs have a good integration with Clojure and most of them use this exact
    mechanism, as clients that work a little more intelligently.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are inside the REPL, (any of the two) let''s try writing our first
    expression, go on and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should get back a value from the REPL saying `Hello world`, this is not
    really a program, and it is the `Hello world` value printed back by the print
    phase of the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now try to write our first Lisp form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This first expression looks different from what we are used to, it is called
    an S-expression and it is the standard Lisp way.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to remember with S-expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: They are lists (hence, the name, Lisp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first element of the list is the action that we want to execute, the rest
    are the parameters of that action (one two three).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we are asking for the string `Hello world` to be printed, but if we look
    a bit closer at the output, as shown in the following screenshot, there is a `nil`
    that we weren''t expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello world](img/B04289_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason for this is that the `println` function returns the value `nil` (Clojure's
    equivalent for null) after printing `Hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Clojure, everything has a value and the REPL will always print it back for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: REPL utilities and conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw, the Leiningen nREPL client prints help text; but how does that work?
    Let's explore some of the other utilities that we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try each of them to get a feeling of what it does with the help of the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description | Sample |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `doc` | Prints out a function''s `docstring` | (`doc println`) |'
  prefs: []
  type: TYPE_TB
- en: '| `source` | Prints a function''s source code, it must be written in Clojure
    | (`source println`) |'
  prefs: []
  type: TYPE_TB
- en: '| `javadoc` | Open the `javadoc` for a class in the browser | (`javadoc java.lang.Integer`)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s check how these functions work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What you are seeing here is metadata pertaining to the `doc` function; Clojure
    has the ability to store metadata about every function or `var` you use. Most
    of the Clojure core functions include a doc string and the source of the function
    and this is something that will become very handy in your day to day work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides these functions, we also get easy access to the latest three values
    and the latest exceptions that happened in the REPL, let''s check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`*e` gives you access to the actual plain old Java exception object, so you
    can analyze and introspect it at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine the possibilities of being able to execute and introspect code
    with this, but what about the tools that we are already used to? How can we use
    this with an IDE?
  prefs: []
  type: TYPE_NORMAL
- en: Let's check now how to create a new Clojure project, we'll use Leiningen from
    the command line to understand what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leiningen can help us create a new project using templates, there is a wide
    variety of templates available and you can build and distribute your own in Maven.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most common types of templates are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `jar` library (the default template)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a command-line app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Clojure web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a new Clojure command-line app and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leiningen is similar to other Java development tools; it uses a similar convention
    and allows for heavy customizations in the `project.clj` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Maven or Gradle, you can think of it as `pom.xml` or
    `build.gradle` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/B04289_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, there are four main folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources`: It holds everything that should be in the class path, such as
    files, images, configuration files, properties files, and other resources needed
    at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: Your Clojure source files; they are ordered in a very similar fashion
    to the `classpath`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev-resources`: Everything that should be in the `classpath` in development
    (when you are running Leiningen). You can override your "production" files here
    and add files that are needed for tests to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: Your tests; this code doesn''t get packaged but it is run every time
    you execute the Leiningen test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a standalone app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your project is created, you can build and run a Java standalone command-line
    app quite easily, let''s try it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is quite easy to create a standalone app and it is very similar
    to using Maven or Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cursive Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java already has some great tools to help us be more productive and write higher
    quality code and we don''t need to forget about those tools. There are several
    plugins for Clojure depending on what your IDE is. Have a look at them from the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| IDE | Plugins |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| IntelliJ | Cursive Clojure, La Clojure |'
  prefs: []
  type: TYPE_TB
- en: '| NetBeans | NetBeans Clojure (works with NetBeans 7.4) |'
  prefs: []
  type: TYPE_TB
- en: '| Eclipse | CounterClockwise |'
  prefs: []
  type: TYPE_TB
- en: '| Emacs | Cider |'
  prefs: []
  type: TYPE_TB
- en: '| VIM | vim-fireplace, vim-leiningen |'
  prefs: []
  type: TYPE_TB
- en: A lot of people writing real Clojure code use Emacs and I actually like using
    vim as my main development tool, but don't worry, our main IDE will be IntelliJ
    + Cursive Clojure throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cursive Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can check the full documentation for Cursive at their website ([https://cursiveclojure.com/](https://cursiveclojure.com/)),
    it is still under development but it is quite stable and a great aid when writing
    Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the latest IntelliJ Community Edition release, which at
    the time of this writing is version 14.
  prefs: []
  type: TYPE_NORMAL
- en: You can download IntelliJ from here [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Cursive Clojure is very simple, you need to add a repository for
    IntelliJ. You''ll find the instructions to your specific IntelliJ version here:
    [https://cursiveclojure.com/userguide/](https://cursiveclojure.com/userguide/).'
  prefs: []
  type: TYPE_NORMAL
- en: After you have installed Cursive Clojure, we are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to import our getting started project into Cursive Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cursive Clojure doesn't currently have support to create Leiningen projects
    from within the IDE; however, support is great in order to import them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you will do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the folder or the `project.clj` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the **Next** steps in the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are ready to go, you can use the Cursive Clojure as your main development
    tool. There are a few more things to do with your IDE but I recommend you to look
    for them; they are important and will come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: To know how to execute the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To know how to execute the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To open an REPL connected to some project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key binding to execute some given piece of code (run form before cursor
    in REPL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key binding to execute a given file (load file in REPL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important part of Clojure programming is that it can modify and reevaluate
    code in runtime. Check the manual of your current version of Clojure and check
    for the structural editing section ([https://cursiveclojure.com/userguide/paredit.html](https://cursiveclojure.com/userguide/paredit.html)).
    It is one of the most useful functionalities of Clojure IDEs and a direct consequence
    of the Clojure syntax.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you to check other functionalities from the manual. I really recommend
    checking the Cursive Clojure manual, it includes animations of how each functionality
    works.
  prefs: []
  type: TYPE_NORMAL
- en: You will use the last two key bindings quite a lot, so it is important to set
    them up correctly. There is more information about keybindings at [https://cursiveclojure.com/userguide/keybindings.html](https://cursiveclojure.com/userguide/keybindings.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Clojure code and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a deep dive into Clojure's syntax now, it is pretty different from
    other languages but it is actually much simpler. Lisps have a very regular syntax,
    with few special rules. As we said earlier, Clojure code is made of S-expressions
    and S-expressions are just lists. Let's look at some examples of lists to become
    familiar with lists in Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the above are lists, but not all of them are valid code. Remember, only
    lists where the first element is a function can be considered valid expressions.
    So, here only the following could be valid expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If `println` and `one` are defined as functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a piece of Clojure code, to finally explain how everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Lists in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clojure is based around "forms" or lists. In Clojure, same as every Lisp, the
    way to denote a list is with parentheses, so here are some examples of lists in
    the last code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists are one data type in Clojure and they are also the way to express code;
    you will learn later about all the benefits of expressing code as data. The first
    one is that it is really simple, anything you can do must be expressed as a list!
    Let''s look at some other examples of executable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to write everything into the REPL, so you get a good notion
    of what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: Operations in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Clojure, `MOST` of the executable forms have this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`op` is the operation to be executed followed by all the parameters it needs,
    let''s analyze each of our previous forms in this new light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are asking to execute the `+` (addition) operation with the parameters `1`,
    `2`, and `3`. The expected result is `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze something a bit more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this, we are asking to execute the `clojure.core/map` function with two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inc` is a function name, it takes a number and increments it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[1 2 3 4 5 6]` is a collection of numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map applies the `inc` function to each member of the passed collection and returns
    a new collection, what we expect is a collection containing `[2 3 4 5 6 7]`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s check how a function definition is essentially the same as the previous
    two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defn` is the operation that we are asking for. It has several parameters,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`some-function` is the name of the function that we are defining'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[times parameter]` is a collection of parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Prints a string certain number of times"` is the docstring, it is actually
    an optional parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(dotimes [x times] (println parameter))` is the body of the function that
    gets executed when you call `some-function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defn` calls a function into existence. After this piece of code is executed,
    `some-function` exists in the current namespace and you can use it with the defined
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defn` is actually written in Clojure and supports a few nice things. Let''s
    now define a `multi-arity` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Over here we are defining a function with two bodies, one of them has no arguments
    and the other one has one argument. It is actually pretty simple to understand
    what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the source in your project''s `core.clj` file similar to the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now run it, you'll get three different Hello outputs.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Clojure has a very regular syntax and even if it's a little
    strange for newcomers, it is actually quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used a few data types that we haven't properly introduced; in
    the next section we'll take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure's data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now is when everything you know about Java pays off; even the list forms that
    you saw earlier implement the `java.util.List` interface. Clojure was designed
    to be embeddable and to have a great integration with the host platform, so it's
    only natural that you can use everything you already know about Java types and
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two data types in Clojure: scalars and collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Scalars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In every language you need primitive types; you use them in everyday life as
    they represent numbers, strings, and Booleans. These primitive types are called
    scalars in the Clojure world.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has a couple of very interesting types like ratios and keywords. In
    the following table, you get to know the different types of scalars, how they
    compare to Java and a simple example of how to use each of them.
  prefs: []
  type: TYPE_NORMAL
- en: '| Clojure data type | Java data type | Sample | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| String | String | "This is a string""This is a multiline string" | A string
    of characters; in Clojure you can use multiline strings without a problem |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | Boolean | truefalse | Literal Boolean values |'
  prefs: []
  type: TYPE_TB
- en: '| Character | Character | `\c``\u0045 ;; Unicode char 45 E` | Character values,
    they are `java.lang.Character` instances, you can define Unicode characters |'
  prefs: []
  type: TYPE_TB
- en: '| Keywords | Doesn''t exist in java | `:key``:sample``:some-keyword` | They
    evaluate themselves and they are often used as keys. They are also functions that
    look for themselves in a map. |'
  prefs: []
  type: TYPE_TB
- en: '| Number | Numbers are automatically handled as `BigDecimal`, `BigInteger`
    or lower precision depending on what''s necessary | `42N ;;Big Integer``42 ;;long``0.1M
    ;;BigDecimal` | It is important to remember the trade-offs of Java numbers, if
    precision is important, you should always use big decimals and `bigintegers`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Ratio | Doesn''t exist | `22/7` | Clojure provides great numerical precision;
    if necessary it can retain the ration and execute exact operation. The tradeoff
    when using ratios is speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Symbol | Doesn''t exist | some-name | Symbols are identifiers in Clojure,
    very similar to a variable name in Java. |'
  prefs: []
  type: TYPE_TB
- en: '| nil | null | nil | The null value |'
  prefs: []
  type: TYPE_TB
- en: '| Regular expressions | `java.util.regex.Pattern` | `#"\d"` | Regular expressions,
    in Clojure you get free syntax to define regular expressions, but in the end it
    is a plain old Java reggae Pattern |'
  prefs: []
  type: TYPE_TB
- en: Collection data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Clojure there are two types of collections: sequential and associative collections.
    Sequential are things you can iterate, such as lists. Associative collections
    are maps, sets, and things you can access by a certain index. Clojure''s collections
    are fully compatible with Java and it can even implement the `java.util` interfaces,
    such as `java.util.List` and `java.util.Map`.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main characteristics of collections in Clojure is that they are immutable;
    it has a lot of benefits that we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the characteristics of each collection data type available
    in Clojure and compare them with Java with the help of a sample (in Clojure) and
    its description.
  prefs: []
  type: TYPE_NORMAL
- en: '| Clojure data type | Java data type | Sample | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | `List` | `(1 2 3 4 5)` | A simple list, notice the quote character
    before the list, if you don''t specify it Clojure will try to evaluate the form
    as an instruction |'
  prefs: []
  type: TYPE_TB
- en: '| `Vector` | `Array` | `[1 2 3 4 5]` | It is the main workhorse in Clojure,
    it is similar to an array because you can access elements in a random order |'
  prefs: []
  type: TYPE_TB
- en: '| `Set` | `HashSet` | `#{1 2 3 4}` | A normal Java hash set |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` | `HashMap` | `{:key 5 :key-2 "red"}` | A Clojure map |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, Clojure has a mature development environment that is always
    evolving. You can set up command-line tools and your IDE in a very similar fashion
    to the way you will do in a normal Java development.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned a little about Clojure's regular syntax, its data types and
    how they relate to Java's own data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, you should now be comfortable with:'
  prefs: []
  type: TYPE_NORMAL
- en: Lisp syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Leiningen project from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and packaging your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a Leiningen project into IntelliJ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the relationship between Clojure types and Java types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will get an idea of how to organize our code and how
    that organization takes advantage of Java packages.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Namespaces, Packages, and Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a working installation of Clojure and IntelliJ.
  prefs: []
  type: TYPE_NORMAL
- en: As a Java developer, you are used to working with classes as the minimal unit
    of organization. Clojure has a very different sense and gives you different tools
    to organize your code.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, you should keep in mind that code and data are separate; you don't
    have a minimal unit with attributes and functions that work over those attributes.
    Your functions can work on any data structure that you wish, as long as you follow
    the rules of how the function works.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start writing some simple functions to illustrate how
    separation of functions and data works and we will have a look at the tools Clojure
    gives us to make the separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topic:'
  prefs: []
  type: TYPE_NORMAL
- en: How namespaces work compared to the classpath and Java packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More Clojure examples and syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure namespaces might be familiar to you, as a Java developer, and for a
    very good reason, they have a very deep relationship with Java's packages and
    the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's review what we already know from Java.
  prefs: []
  type: TYPE_NORMAL
- en: Packages in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java code is organized in packages, a package in Java is a namespace that
    allows you to group a set of similar classes and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a package as something very similar to a folder in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some common packages that you use a lot when programming
    in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang`: Everything that''s native to Java, including basic types (integer,
    long, byte, boolean, character, string, number, short, float, void, and class),
    the basic threading primitives (runnable, thread), the basic primitives for exceptions
    (throwable, error, exception), the basic exceptions and errors (`NoSuchMethodError`,
    `OutOfMemoryError`, `StackOverflowError`, and so on) and runtime access classes
    like runtime and system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io`: This package includes the primitives for input and output, such
    as console, file, readers, input streams, and writers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util`: This is one of the most heavily used packages besides `java.lang`.
    This includes the classic data structures (map, set, list) along with the most
    common implementations of such data structures. This package also includes utilities
    like properties tools, scanner for reading from various input resources, `ServiceLoader`
    to load custom services from the `classloader`, UUID generator, timers, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.logging`: The logging utilities, you normally use them to give you
    different levels of alert, from a debug to serious conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.text`: These are utilities to manage text, dates, and numbers in a language
    independent way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.servlet`: This includes the primitives to create web apps and deployment
    in standard web containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of these packages groups several related functionalities, the `java.lang`
    package is particularly important, since it has every Java core type, such as
    string, long, and integer. Everything inside the `java.lang` package is available
    automatically everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.lang` package provides a bit more than just code organization, it
    also provides access security. If you remember about Java, there are three security
    access levels:'
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of packages, we are concerned with the protected level of access.
    The classes in the same package allow every other class in the same package to
    access its protected attributes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: There are also ways to analyze a package in runtime but they are involved and
    allow for very little to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Packages are implemented at the top of Java's classpath and the classloader.
  prefs: []
  type: TYPE_NORMAL
- en: The classpath and the classloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java was designed to be modular and for that it needs some way to load your
    code easily. The answer to this was the classloader, the classloader allows you
    to read resources from every entry of the classpath; you can look at resources
    in the classpath as a hierarchical structure similar to the file system.
  prefs: []
  type: TYPE_NORMAL
- en: The classloader is just a list of entries; each entry can be a directory in
    the filesystem or a JAR file. At this point, you should also know that JAR files
    are just zip files.
  prefs: []
  type: TYPE_NORMAL
- en: The classloader will treat each entry as a directory (JAR files are just zipped
    directories) and it will look for files in each directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of concepts here to remember, let''s try to summarize them:'
  prefs: []
  type: TYPE_NORMAL
- en: JAR files are ZIP files; they might contain several classes, properties, files,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classpath is a list of entries; each entry is a JAR file or a system directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classloader looks for resources in each entry of the classpath, so you can
    think of classpath resources as a combination of all the directories in the classpath
    (repeated resources are not overwritten)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are not already familiar with how classloaders look for resources in
    classpath entries, this is the general process; let''s imagine that you want to
    load a class: `test.Test`, what happens next?'
  prefs: []
  type: TYPE_NORMAL
- en: You tell the JVM that you want to load `test.Test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM knows to look for the `test`/`Test.class` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It starts looking for it in each entry of the classpath.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the resource is a ZIP file, it "unzips" the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It looks for the resource in the directory which represents the entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you were to see the default classpath resources, you will probably see something,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that each entry in the classpath doesn't just store
    class files, it can actually store any type of resource, It is a commonplace to
    store configuration files, such as `.properties` or `.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing forbids you from storing anything else in the classpath resources, such
    as images, mp3 or even code! You can read and access anything from the classpath's
    resource like you can from the filesystem at runtime. The one thing that you can't
    do is modify the classpath's resource contents (at least not without some esoteric
    magic).
  prefs: []
  type: TYPE_NORMAL
- en: Back to Clojure namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have had our little review of how packages and the classpaths work
    in Java, it''s time to go back to Clojure. You should understand that Clojure
    attempts to make the hosting platform transparent; this means a couple of very
    important things:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything that you can do with the classpath from Java, you can also do with
    Clojure (you can read configuration files, images, etc).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces use the classpath just as Java does with packages, which makes them
    easy to understand. Nevertheless, don't underestimate them, Clojure namespace
    declarations can be more involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get practical and play a little with namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lets create a new Playground, in order to create it use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can open this project with IntelliJ, as we did in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Clojure"), *Getting Started with Clojure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look in detail at what was created for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with namespaces](img/4289_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This project structure looks similar to Java projects, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources`: These are the non-source files that get added to the classpath'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: Our source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: Our testing code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code inside `src` and `test` is already structured into namespaces: by
    having a quick look, we could say that the name of the namespace is `ns_playground`.
    Let''s check the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`:gen-class` was added here in order to create a Java class and allow the Java
    interpreter to start a static main method. It is not needed if you don''t intend
    to create a standalone program.'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the (`ns ns-playground.core`) form has been used at the top,
    as you might have guessed, this is how we declare a namespace in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: If you are observant, you will notice something odd; the namespace has a dash
    instead of an underscore like the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some reasons that lead to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Clojure like most lisp variable names can have dashes in it (it is actually
    the preferred style to name the variables, as opposed to camel case in Java).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every namespace in Clojure is represented as a package containing several Java
    classes. The namespace is used as a name of the Java package and as you know,
    the dash is not acceptable in class or package names; so every filename and folder
    name must have low dashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the nature of Lisp, you can use dashes in variable names (they will get
    converted to underscores at compile time). In fact, this is the recommended way
    to name your variables. In Clojure, (and most Lisps) `some-variable-name` is a
    more idiomatic style than `someVariableName`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new namespace; in Cursive Clojure it is easy to do so, just right-click
    on the `ns_playground` package and go to **New** | **Clojure Namespace**, it asks
    for a name and we can call it `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a `hello.clj` file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, namespace creation is quite easy; you can do it by hand with
    two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file; it doesn't have to follow the package naming specification,
    but it helps to maintain your code order and it is a de facto practice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your namespace declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! It is true, even though a namespace definition can become quite complex,
    as it is the place where you define the Java packages that you wish to import,
    namespaces or functions from those namespaces that you intend to use. But you
    will normally just use a subset of those capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that a namespace in Clojure is normally represented by a single
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your initial namespaces, I will advice you to have two of those capabilities
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `:import` | Allows you to import the Java classes from a package that you
    wish to use |'
  prefs: []
  type: TYPE_TB
- en: '| `:require` | Allows you to bring in whatever Clojure namespace that you wish
    to use |'
  prefs: []
  type: TYPE_TB
- en: The syntax of both `require` and the `import` is simple, let's look at a couple
    of examples before we actually use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `import` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that this is similar to what you can do in Java, we are importing
    the `List` interface here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing with Clojure is that it allows you to do some more specific
    things. Let''s check how to import two classes at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can extend this to the number of classes you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `require` option uses a similar syntax and then builds some more on it.
    Let''s check requiring a single function from a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is familiar and the interesting part is when you start importing
    everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a custom name for everything inside your package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could even combine different keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try a bit of what we just learned, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You must have noticed the `&` operator in the arguments of the `<3` and `sum-something`
    functions; this allows those functions to receive any number of arguments and
    we can call them, as shown: (`sum-something 1 2 3 4 5 6 7 8`) or (`sum-something`)
    They are called **variadic** functions. In Java you will call this feature **varargs**.'
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks great, but we haven't yet seen how to require and use these
    functions from some other package. Let's write a test to see how this will be
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Working with namespaces on the REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great way of playing with namespaces is by using the REPL and we'll also get
    the benefit of getting to know it better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to play with namespace, we need to know of a few functions
    that will help us move between namespaces and require other namespaces. The functions
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description | Sample usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `in-ns` | Sets `*ns*` to the namespace named by the symbol, creating it if
    needed. | (`in-ns ''ns-playground.core`) |'
  prefs: []
  type: TYPE_TB
- en: '| `require` | Loads `libs`, skipping any that are already loaded. | (`require
    ''[clojure.java.io :as io]`) |'
  prefs: []
  type: TYPE_TB
- en: '| `import` | For each name in `class-name-symbols`, adds a mapping from name
    to the class named by `package.name` to the current namespace. | (`import java.util.Date`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `refer` | refers to all public `vars` of `ns`, subject to filters. | (`refer
    ''clojure.string :only ''[capitalize trim]`) |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s go into the REPL window of our IntelliJ. We can check what namespace
    we are in with the `*ns*` instruction. Let''s try now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we need to execute a code and test the code from within the `ns-playground.hello`
    namespace, we can do that with the `in-ns` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to know what `str` does, it seems to receive three strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the `for` form now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `for` macro takes a collection of items and returns a new lazy sequence
    applying the body of the `for` to each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, understanding the `<3` function is easy, let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've used the REPL to test some simple functions, but let's now try to test
    something else like reading a properties file from the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a `test.properties` file to the resources folder with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember to restart the REPL, as the changes to the contents that some piece
    of the classpath points to are not visible to a running REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try reading our properties file as an input stream, we can use the `clojure.java.io`
    namespace to do it, and we can check it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define our function for reading properties, we can input this into
    the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `let` form lets us create local 'variables', instead of using the (`io/resource
    path`) directly in the code. We can create a reference once and use it through
    the code. It allows us to use simpler code and to have a single reference to an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we can redefine the `hello` namespace to include everything we''ve
    checked, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Remember to include the `Properties` class in the `import` and to define the
    `:require` keyword for `clojure.java.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure already comes with a unit testing support built-in, as a matter of fact
    Leiningen has already created a test for us; let's take a look at it right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `test/ns_playground/core_test.clj` file, you should be able to see
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Again, as you can see, we are using `:require` to include functions from the
    `clojure.test` and the `ns-playground.core` packages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the `:refer :all` works similar to how `char import static clojure.test.*`
    will work in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Testing from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first learn how to run these tests. From the command line, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We see that there is one test failing, we will go back to this in a bit; for
    now, let's see how to test in IntelliJ.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in IntelliJ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need a new REPL configuration. You can do it as you learned
    in the previous chapter. You just need to follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right click on the `project.clj` file and select **Create REPL for ns-playground,**
    as shown in the following screenshot:![Testing in IntelliJ](img/4289_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click on **OK** in the next dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, you should run the REPL again by right clicking the `project.clj`
    file and selecting **Run REPL for ns-playground**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that you can run any tests, just open your test file and go to **Tools**
    | **Run Tests** in the current NS in REPL. You should see something similar to
    the following screenshot:![Testing in IntelliJ](img/4289_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, it signals that your test is currently failing. Let's fix it
    and run our test again. Change the `(is (= 0 1))` line to `(is (= 1 1))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s try some real tests for our previously defined functions; don''t
    worry if you can''t understand all the code for now, you are not supposed to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can't use the Clojure contents function here because it has a different function.
    It looks for keys in a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests and you''ll see that everything passes correctly but there''s
    a lot going on over here, let''s go over it little by little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the namespace declaration, let''s list everything it does:'
  prefs: []
  type: TYPE_NORMAL
- en: It declares the `ns-playground.core-test` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It imports the `java.util.Date` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes everything in the `clojure.test` namespace available in the current
    namespace, if we were in Java we might have used `import static clojure.test.*`
    to get a similar effect. We can achieve this with the `:refer :all` keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes everything in the `ns-playground.hello` namespace available with the
    hello shortcut but we need to prefix every function or value defined in `ns-playground.hello`
    with hello and it also makes the `<3` function available without a prefix. To
    generate an alias and make everything available with the `hello` alias, we use
    the `:as` keyword and then pass a vector to `:refer` to include certain elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes everything in the `ns-playground.core` namespace available in the current
    namespace. We achieve this with the `:refer :all` keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the declaration of a function called `lazy-contains?`, it is a `boolean`
    function and it is customary in Clojure to call it a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of the function including the question mark might be something that
    looks awkward to you. In Clojure and Lisp, you can use question marks in the names
    of functions and it is common to do it for functions that return Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: 'It receives two parameters: `col` and `element`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual body of the function looks a bit complicated but it is actually
    very simple. Whenever you encounter a function that looks similar to the one mentioned
    in the preceding section, try to read it from the inside out. The innermost part
    is, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a shorter way of writing an anonymous function which has a single parameter.
    If we want to write another function that compares its argument against the `element`,
    without the syntactic sugar, we can do it in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is an anonymous function or in other words it is a function that has no
    name, but it works as every other function; we will read more about anonymous
    functions when we get back to functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our anonymous function is a parameter to the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This new form filters the collection `col` and returns a new collection with
    only the elements that pass the test. Let''s see an example where we have used
    the predefined Clojure function `even?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our filter function now returns every element in the collection that passes
    the `#(= element %)`test. So we get every element that is equal to the element
    passed to `lazy-contains?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then ask if none of the elements equal to `element` in `col` with the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'But we want to know if there is some element equal to element, so at last we
    negate the previous form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that if you had to write this in Java (and I asked to add every element
    that matches the element to a list), you will have something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There is a big difference, it is more verbose and to understand it we need to
    "run" the algorithm in our heads. This is called imperative programming, Clojure
    allows us to do imperative programming as well as functional programming, which
    is a type of declarative programming. When you get used to it, you'll see that
    it's easier to reason about than loops.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interactive programming means, telling every step of how something should be
    done to a computer. Declarative programming just asks for a result and doesn't
    give details of how to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual tests are simple to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This test checks the current date returns an instance of `java.util.Date`,
    the `is` form works as the Java assert instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This test checks the `<3` function, it checks that the returned collection contains
    `I love Clojure`, `I love doggies`, `I love chocolate` and `I love you` and it
    should not contain `I love Vogons`.
  prefs: []
  type: TYPE_NORMAL
- en: This test is simple to understand. What might be not so simple to understand
    is the `<3` function, we'll look into it with the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we got to know some utilities that we can use for better management
    of our code and we have some more examples of everyday Clojure code. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Working of namespace in Clojure and their relation to Java packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing out-of-the-box unit tests and executing them with Leiningen and Cursive
    Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into the Clojure Interactive development workflow and a bit of the Clojure
    mindset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing very simple functions and testing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Java interop, so we can start using
    the familiar classes and libraries we already know in our Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to use Clojure from Java, so you can start using it in
    your everyday Java projects.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Interacting with Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know a bit about how to organize our code and how that relates to packages
    in Java. Now, you surely need to use your old Java code and all the libraries
    you already know; Clojure encourages a new way to think about programming and
    it also allows you to use all the dependencies and code that you've already generated.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is a **Java Virtual Machine** (**JVM**) language and as such it is compatible
    with most Java dependencies and libraries out there; you should be able to use
    all the tools out there. You should also be able to use your Clojure programs
    with Java-only programs, this requires a bit of custom coding but in the end you
    can use Clojure in the right places of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to do this, we''ll have to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using plain old Java classes from your Clojure code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit more about the Clojure language, in particular the `let` statements and
    destructuring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Java interface for your Clojure code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Java interface from other Java projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we want to write an image manipulation program; it is a very
    simple program that should be able to create thumbnails. Most of our codebase
    is in Clojure, so we want to write this in Clojure too.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of Java libraries meant to manipulate images, we decide to
    use imgscalr, which is very simple to use and it looks like it is available in
    Maven Central ([http://search.maven.org/](http://search.maven.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new Leiningen project, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to edit the `project.clj` file in the thumbnails project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add the `imgscalr` dependency similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you just need to add a dependency to the `:dependencies` vector,
    the dependencies are automatically resolved from:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven Local
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven Central
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Maven Local points to your local maven repository that is in the `~/.m2`
    folder. If you wish, you can change it with Leiningen's `:local-repo` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add your own repositories, let''s say you need to add **jcenter** (Bintray''s
    Java repository) you can do so, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Leiningen supports a wide array of options to configure your project, for more
    information you can check the sample at Leiningen''s official repository: [https://github.com/technomancy/leiningen/blob/master/sample.project.clj](https://github.com/technomancy/leiningen/blob/master/sample.project.clj).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to download the dependencies, you have to execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't need to execute `lein deps` every time you want to download dependencies,
    you can do it to force a download but Leiningen will automatically download them
    when it needs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the current dependencies by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This lists your current dependency tree.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure interop syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure was designed to be a Hosted Language, which means that it can run in
    different environments or runtimes. One important philosophy aspect is that Clojure
    does not attempt to get in the way of your original host; this allows you to use
    your knowledge of the underlying platform to your advantage.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the Java platform. Let's look at the basic interrupt
    syntax that we need to know.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to create an object in Clojure; for example, let's have a
    look at how to create an instance of `java.util.ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `new` special form, as you can see it receives a symbol
    (the name of the class `java.util.ArrayList`) and in this case it is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: The symbol `java.util.ArrayList` represents the `classname` and any Java class
    name will do here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can actually pass any number of parameters (including `0` parameters).
    The next parameters are the parameters of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets have a look at the other special syntax that is available to create objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that we have a trailing dot; we prefer to see this syntax
    since it is shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an instance method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have created our object we can call instance methods. This is done similar
    to how we call Clojure functions, using the special dot form.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add an element to our newly created list, we will have to do
    it, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax might look a little strange; here is how this syntax is formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the two different options that we had when creating an object, we
    have another way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You might think that this is more familiar, since the method name starting with
    a dot resembles how we write the Java method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a static method or function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to call methods and create objects gives us a great deal of power,
    with this simple construct we have gained a lot of power; we can now use most
    of the Java standard libraries and also the custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: However, we still need a few more things; one of the most important ones is
    calling static methods. The static methods have a feel similar to Clojure functions,
    there is no `this` instance, you can simply call them as normal Clojure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we want an `emptyMap` from the `Collections` class, we can
    do it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You can think of static methods as functions and the class as a namespace. It
    is not exactly right but the mental model will help you understand it easily.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing inner classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common doubt when using Java – Clojure interop is how to access inner
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want to represent a single entry from a map with the `java.util.AbstractMap.SimpleEntry`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that we have to do something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s what you will normally do when writing Java, but in Clojure you might
    need to do something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are seeing here is actually an exposed implementation detail; if you
    look at the classes in the JAR files or in your classpath, you will see the precise
    file name `AbstractMap$SimpleEntry`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing inner classes](img/B04289_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is what you need to keep in mind, always prefix the inner classes with
    the parent (or more correctly containing) class (in this case `java.util.AbstractMap`)
    and the dollar sign.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple image namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now write some Clojure code and create a file in `src/thumbnails/image.clj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to do this the Clojure way. First of all, write the namespace declaration
    and evaluate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open up a REPL and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have an image instance and you can call all of the Java methods in the
    REPL. This is one of Clojure''s core concepts, you can play with the REPL and
    check your code before really writing it and you can do it in an interactive way,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a simple image namespace](img/B04289_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the end, we want to stickwith the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see that in this code we use the inner class syntax, with `Scalr$Mode`.
    Mode is not actually a class but an `enum`, you can use the same syntax for all
    other inner types.
  prefs: []
  type: TYPE_NORMAL
- en: The code is pretty simple, it is very similar to what you've already seen; we'll
    go through the differences either way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can import the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.imageio.ImageIO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.awt.image.BufferedImageOp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.imgscalr.Scalr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.imgscalr.Scalr.Mode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to be careful with the `Mode` class, since it is an inner class (it
    is inside another class) Clojure uses the special name `Scalr$Mode`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When importing inner classes, you have to be careful with the naming process,
    in Java you will use the name: `org.imgscalr.Scalr.Mode`; in Clojure you use the
    name: `org.imgscalr.Scalr$Mode`. The `load-image`, `save-image`, and `image-size`
    functions are self explanatory and the `generate-thumbnail` function is pretty
    simple as well; however, it has a special detail, it calls the following as the
    last argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the ImageScalr javadoc, ([http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html](http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html))
    you can see that the `resize` method has several overloaded implementations; most
    of them have a `varargs` argument as their last argument. In Clojure, you have
    to declare these `varargs` arguments as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have written your image processing code, it is a good time to write
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let's just check if we can generate a thumbnail. Create a new `thumbnails.thumbnail-test`
    namespace, in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, if you create the file, it must be named `test/thumbnails/thumbnail_test.clj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following contents to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using some unknown features, such as the `let` form and destructuring.
    We will see this in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The let statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure gives us a `let` statement to name things; it allows us to do something
    very similar to variable declaration in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that we are not actually creating a variable in the same sense,
    as in Java. In Java, whenever we declare a variable. We state that we want to
    reserve a certain amount of memory to store something in the later stages; it
    can be a value for primitives or a memory location for objects. What we do here
    is simply name a value. This is a local scope that is useful to write cleaner
    and easier to understand code. Lets have a look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest `let` statement that we could write and it is exactly
    the same as just writing `42`. However, we can write something a little more complex,
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks self explanatory; to value `42` and `y,` we are assigning the value
    of multiplying `42` by `42`. In the end, we print `x is 42 and y 1764`. It is
    important to note two things here:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a previously defined value in the `let` statement; for example, we
    use `x` when defining `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `let` statement creates a scope, we can't use `x` or `y` outside of our
    `let` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `let` statement can even be nested, we could do something similar to the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: It is a bit more complicated, since we are opening an unneeded set of parentheses
    and also writing more code; however, it allows us to see how lexical scope works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets have a look at another interesting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In here, we are masking the value of `x` with `41` and again these are not variables.
    We are not changing a memory region, we are merely creating a new scope with a
    new *X* value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our test, the `let` statement begins with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'It is pretty clear to understand, but the next line might prove a bit more
    difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It looks pretty strange; we are assigning the value of (`image-size image`)
    to `[w _]` but `[w _]` is not a symbol name!
  prefs: []
  type: TYPE_NORMAL
- en: What is happening here is that we are using a mechanism called destructuring
    to take the result of (`image-size image`) apart and just use the piece of information
    that we are interested in, which in this case is the width of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring is one of the key features of Clojure, it can be used almost
    everywhere where symbol binding happens, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Let expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function parameter lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring helps write more concise code but it might strike you as strange
    when you are not used to it. Let's talk about it in depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Destructuring is a feature in Clojure that is not common in other lisps; the
    idea is to allow you to write more concise code in scenarios where code doesn't
    really add value (for example, getting the first element from a list or the second
    parameter from a function) and concentrating only on what is important to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand this better, let''s see an example of why destructuring
    can help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: What's wrong with the previous code? Nothing really, but you need to start thinking
    about what is `v`, what the first value of `v` is, what the nth function does,
    and at what index `v` starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Once you are used to destructuring, you will see that you don't need to think
    about how to get the elements you need. In this case, we directly access the first,
    second, and third elements from our vector and use the first and third out of
    the three elements. With good naming it can become even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Lets now take a deep dive into what destructuring is.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequential destructuring**: It allows us to take sequential data structures
    apart and bind the values that you are interested in directly to symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associative destructuring**: It allows us to take maps apart and bind only
    the key reference values that you are interested in directly to symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sequential destructuring should be easy to understand with some examples; lets
    have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, as convention, we use `f` for first, `s` for second, `t`
    for third, and `a` for all the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same destructuring idea and syntax can be used with function parameters,
    as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we use the symbol `_`, there is a convention in Clojure to use the `_`
    symbol whenever you are not interested in some value and you don't need to use
    it in the future. In the previous example, we aren't interested in the second
    parameter of the `func` function.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it lets us write a much more concise code and focus only on
    what's important, which is the algorithm or business.
  prefs: []
  type: TYPE_NORMAL
- en: Associative destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already seen sequential destructuring that allows getting certain elements
    of a sequence by index. In Clojure, there is also associative destructuring, which
    allows you to take just the keys of the map in which you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, an example is worth more than a thousand words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking of symbols as keys to a map can feel strange, nonetheless it is important
    to remember this feature; it could come in handy at some point.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it''s pretty simple too, but we have a few more options:'
  prefs: []
  type: TYPE_NORMAL
- en: We can reference some keys and assigning them a name, as shown in the first
    and second example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reference keyword keys, as in the third example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reference string keys, as in the fourth example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can define default values with the `:or` keyword!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring is one of the most used features of Clojure and it allows you
    to write very concise code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our test code, it should now be pretty easy to understand the
    get-`image-width` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it sets the image value as the loaded image and then it calculates
    the width, gets the width only and returns that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now understand the `test-load-image` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: It just initializes an `image-stream` value, it then loads an image from that
    stream and generates a thumbnail. It finally loads the generated thumbnail and
    checks that the image width is 50px.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've written our tests and we are sure that everything works, we can
    use our little library from the Clojure projects, but what happens if we want
    to use it from a pure Java (or groovy, or scala) project?
  prefs: []
  type: TYPE_NORMAL
- en: Exposing your code to Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to be able to use Clojure code from other JVM languages, in Clojure,
    there are a couple of ways in which you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: You can generate new Java classes and use them as you normally would; it can
    implement some interface or extend from some other class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generate a proxy on the fly, this way you can implement a contract (in
    the form of a class or an interface) that some framework requires with little
    code and effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `clojure.java.api` package to call Clojure functions directly
    from Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find more information on how this works at the following location:
    [http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html](http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how we can define a Java class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new namespace called `thumbnails.image-java` and write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This code is very similar to the Clojure code that we have already seen, except
    for the `gen-class` directive and the function names starting with a dash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the `gem-class` in better detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: When the Clojure compiler sees this, it generates the byte code of a class but
    it needs a little help from the keywords to know how to generate the class.
  prefs: []
  type: TYPE_NORMAL
- en: The name key defines the name of the class, it is a symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main key defines whether this class should have a main method or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method key defines all the methods and their signatures, it is a vector
    with three parts: `[methodName [parameterTypes] returnType]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods are then implemented as functions starting with the (`-`) character,
    the prefix can be changed with the prefix key.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to tell Clojure to compile this class in advance, in Leiningen
    it can be achieved with `:aot`, go to your `project.clj` file and add an `:aot`
    key with the namespace or namespaces to be compiled in a vector; if you want everything
    to be compiled in advance, you could use the special `:all` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, you should have something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing your code to Java](img/B04289_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want all of your code to be compiled in advance, you can use `:aot :all`
    in your `project.clj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can install our library to our Maven local repository. Go to the command
    line and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get an output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing your code to Java](img/B04289_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, you are good to go; you should have a `thumbnails:thumbnails:0.1.0-SNAPSHOT`
    dependency in your Maven local repository.
  prefs: []
  type: TYPE_NORMAL
- en: Testing from Groovy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to see how this works with several JVM languages, we will use Groovy
    and Gradle to test. We can use Java and Maven just as easily. Remember that you
    can get the source from the code bundle so that you don't need to know everything
    that's happening here.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two files here; in the `build.gradle` file, we specify that we want
    to use our local Maven repository and we specify our dependency, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can write our test, as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very easy to run your code from Java, Groovy, or even
    Scala. There are other ways to use Clojure with Java, particularly, if you want
    to implement an interface or generate a class dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy and reify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are situations when you are interacting with Java libraries, where you
    must send an instance of a specific Java class to some method; writing a class
    isn''t the best option, you should rather create an instance that conforms to
    a contract expected by some framework on the fly. We have two options to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proxy**: It allows you to implement a Java interface or extend from some
    super class. In reality, it creates a new object that calls your Clojure functions
    when needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reify**: Reify allows you to implement interfaces and Clojure protocols (we
    will see them later). It is not capable of extending classes. It is a better performant
    than the proxy and should be used whenever possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a minimal example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`doto` is a macro that allows us to call several methods on an instance; you
    can think of it as a way to call all of the methods separately. It works great
    with Java Beans!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up an REPL and write the code; it should show a window with a button that
    prints `Hello world` (in the terminal) when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxy and reify](img/B04289_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are familiar with swing, then you know that the `addActionListener` of
    `JButton` needs a callback which is an instance of `ActionListener` and we are
    creating said instance with the `reify` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java code, you might normally do something similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We call this an anonymous class and it is essentially the same as a closure
    in functional languages. In the previous example, the code was replaced by a reify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `reify` statement receives the interface that you are implementing and all
    the methods that you are implementing as you list. In this case, we just implement
    `actionPerformed` to receive the action event.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This creates an instance of `ActionListener`, you can do the same with servlets,
    threads, collections, lists, or any other Java interface defined by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: One particular thing that you need to remember here is that you need to always
    add `self` as the first parameter to your method implementations; it takes the
    place of the `this` keyword that works in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have gained a lot of power from Clojure with a few new
    primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are plenty of ways to interact with your current codebase;
    specifically, you can now:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Java code from Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Clojure code from Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse Java frameworks by creating objects that adhere to their contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of our new tools in mind, we are ready to tackle more concepts and
    a little bit more complexity with collections and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Collections and Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now comfortable with using Java code from our Clojure programs, and we
    also know how to expose our Clojure programs with a Java API. However, we need
    to take a deeper look at Clojure and its true nature, which is functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential and associative collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequence abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying functional programming to collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a topic that you can read about in lots of different places, and it
    seems that everyone has their own opinion of what functional programming is. There
    is however, some common ground that you will find in almost every definition,
    which relates to the benefits you gain from functional programming, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are easier to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are easier to reason about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to get these benefits, you need to take into account the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: You should think of functions as first class citizens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions should minimize side effects (they shouldn't change any state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions should only depend on their parameters (this is called referential
    transparency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lets take a look at two examples of functions (or methods) in Java to illustrate
    how, even in Java, you can get benefits from writing functions without side effects
    and context dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine you had to test the preceding function; you might have a number of
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to know how to get the current user; you might need to mock a database,
    or session storage. Or in the worst case scenario, you might need a real session
    storage service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you know if something was paid for or not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, look at this other example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is easier to test; you can create a user instance any way
    you want and with the `ValidateStrategy` class (or interface) you could do whatever
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, instead of a side-effect you get a return value stating if the action
    was possible or not. This way you don't need to mock and you can reuse it in different
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen some common ground for functional programming, let''s
    take a look at Clojure''s value proposition for functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are first class citizens or values. The same as with integers or strings,
    you can create them in runtime, pass them around, and receive them in other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same way that functions are values, the data structures are also values;
    they can't be modified in the sense that they can be modified in Java but they
    are a fixed value, just as an integer is a fixed value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable data structures are very important, they allow for safe and simple
    multithreaded code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laziness (of data structures) allows deferring evaluation until needed, to execute
    just what you must.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features in Clojure is that collections are persistent.
    That does not mean that they are persistent to disk, it means that you can have
    several historical versions of a collection with the guarantee that updating or
    looking for something in any of those versions is going to have the same effort
    (complexity). You get all this with very little extra memory.
  prefs: []
  type: TYPE_NORMAL
- en: How? It is actually pretty simple. Clojure shares a common structure between
    several different data structures. If you add a single element to a data structure,
    Clojure shares the common part between the two structures and keeps track of the
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we mean with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when you `conj` a new item into a collection, or even when you
    replace some elements from it, you aren't changing the original collection, you
    are just generating a new version of it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Clojure, you can use `conj(conjoin)` as a verb. It means adding new elements
    into a collection in an efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: This new version doesn't modify the previous collections you had in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a big difference from how common imperative languages work and at the
    first glance it might seem like a bad idea, but Clojure uses efficient algorithms
    that give us a couple of advantages, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Different versions of the same collection share common parts, allowing us to
    use little memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When some part of the collection is not visible it gets garbage collected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you get out of this is similar memory usage to what you would have with
    a mutable collection. Remember that there is a cost in space and time but it is
    negligible for most use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to have an immutable data collection? The main advantage
    is that it is simple to reason about them; passing them around to functions does
    not change them and when you are writing concurrent code, there is no chance that
    some other thread has modified your collection and you don't need to worry about
    explicitly handling locks.
  prefs: []
  type: TYPE_NORMAL
- en: Types of collections in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three types of collections in Clojure: counted, sequential, and associative.
    They are not mutually exclusive, meaning one collection might be any.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counted collection**: A counted collection is a collection which knows its
    size in constant time. It doesn''t need to traverse its elements to get a count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequential collection**: A sequential collection can be traversed sequentially;
    it''s the most common approach that you would use for a list. The easiest way
    to think about this is similar to Java''s list, which you can traverse with a
    for-loop or an iterator. In Clojure vectors, lists and lazy sequences are sequential
    collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associative collections**: Associative collections can be accessed by keys;
    maps are the natural choice here. We said that one collection can be of any type;
    Clojure''s vectors can also be used as associative collections, and each element
    index can be used as a key. You can think of it as a map where the keys are 0,
    1, 2, 3, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clojure has some functions that tell us if a given collection is of each type,
    sequential or associative. As you can guess, vectors return true for both. The
    following are those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | List | Vector | Map | Lazy sequence | Set |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| counted? | true | true | true | false | true |'
  prefs: []
  type: TYPE_TB
- en: '| sequential? | true | true | false | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| associative? | false | true | true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '![Types of collections in Clojure](img/B04289_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous table and diagram, you can see that we take **Set** into account
    and as you can see, it's neither sequential nor associative.
  prefs: []
  type: TYPE_NORMAL
- en: We should look at another property; whether a collection is counted or not.
    It means that a collection knows how many elements it has. Lists, vectors, maps,
    and sets are all counted; lazy sequences are not counted, since they are generated
    on the fly and they could even be infinite sequences.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about all of these sequences in the later sections of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The sequence abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clojure has some unique features that make it different from other Lisps; one
    of them is the sequence abstraction. You can think of it as an interface that
    collections comply with. Clojure has a standard API of functions that you can
    use with sequences. Here are some examples of those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `distinct` function: This function returns a sequence that includes each
    element of the original sequence just once:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `take` function: This function takes a number of elements from the original
    sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `map` function: This function applies a function to each element of a sequence
    and creates a new sequence with these elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The interesting part here is that these functions receive and return sequences
    and you can compose them together. It can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'These are just some functions that accept and return sequences, but there are
    a lot more that you can use out of the box. The only assumption is that your sequence
    argument can respond to three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first`: This function returns the first of a sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rest`: This function returns another sequence, containing everything but the
    first element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cons`: This function receives two parameters, an item and another `seq` and
    returns a new `seq` containing the item followed by all the items in the second
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the functions that you'll find yourself using more is the `seq` function,
    it can convert any collection to a seq, even Java native arrays and objects that
    implement the `java.util.Iterable` interface. One of its main uses is to test
    a collection for emptiness.
  prefs: []
  type: TYPE_NORMAL
- en: Specific collection types in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know about Clojure's general collection properties and the sequence
    abstraction, it is a good time to get to know about Clojure's specific collection
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vectors are Clojure's workhorse; together with map, it is the most used collection.
    Don't be afraid of them; they have nothing to do with Java's `java.util.Vector`.
    They are just a series of ordered values, such as a list or an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'They have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be accessed sequentially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are associative (they are maps of their indices, meaning that their keys
    are 0, 1, 2, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are counted, meaning they have a finite size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have random access, so you can access any element with almost constant
    time (with the nth function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `conj` function appends a given element to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nth function allows us to get the nth element of any `seq`, but you shouldn't
    use it without care. It has no problem handling vectors and it returns in constant
    time, but it takes linear time when used with a list, since it has to traverse
    all the collections looking for the element you asked. Try to use it just with
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'They have a literal syntax; you can define a vector with square brackets, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the literal syntax, there''s another function that you can use to build
    a vector. The `vec` function can build a vector out of any sequence passed to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Another important benefit of vectors is that they are used for function arguments
    for declarations and for `let` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the parameters in the function are defined as a vector, same
    as the `let` binding.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main complaints about Lisps is that they use too many parentheses,
    Clojure's decision to use vectors instead in these structures is welcomed and
    makes the code much easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to access a certain element of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the vector as a function**: Vectors can be used as functions of their
    keys; we haven''t discussed maps yet but you will see that this is because they
    are associative:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The nth function**: The `nth` function can receive an extra parameter for
    signaling when an index is not found and can be used, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The get function**: The `get` function can receive an extra parameter for
    signaling when an index is not found, it is used as shown. An important thing
    to keep in mind is that unlike nth, `get` cannot be used in sequences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should use vectors almost always; in particular, if you want to do any
    of the following there is no other way to go:'
  prefs: []
  type: TYPE_NORMAL
- en: You need random access to a collection (either modifying or accessing it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to add elements at the tail of the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are the most important collection type in other Lisps. In Clojure, they
    are used to represent code, but their functionality is almost limited to that.
  prefs: []
  type: TYPE_NORMAL
- en: Lists in Clojure are single linked lists; as you can imagine, this means that
    they are not good for random access (you need to iterate the list until you get
    to the wanted index). That said, you can still use lists as sequences with every
    function of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be accessed sequentially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not associative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are counted, meaning they have a finite size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They shouldn't be accessed in random order. If you want the 99th element, then
    Clojure will have to visit all the first 98 elements to get the 99th.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `conj` function prepends a given element to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use destructuring with lists, as seen in the previous chapter. You shouldn't
    be afraid to use the first function (or even nth with a small index).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists have their use cases and as you learn more you'll probably be comfortable
    using them in some places (such as macros), but as a rule of thumb, try to use
    vectors instead.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are probably the most important collection type across all languages. They
    are also very important in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Maps are collections of key value pairs, which mean that you can access or store
    an element by a key. We have been calling this type of collection an associative
    collection. Keys can be of any type of value in Clojure, even functions, lists,
    sets, vectors, or other maps.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted maps and hash maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two types of maps in Clojure, each one of them with its own advantages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash maps**: They are the most used form of map in Clojure; the literal syntax
    of maps creates this type of maps. They have a nearly constant lookup time, which
    makes them extremely fast and usable in most scenarios. Their down-side is that
    you can''t access them in an ordered fashion. You can create them, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Sorted maps**: If you need to be able to access a map''s key-value pairs
    in a certain order, then you have to use a sorted map. The downside of sorted
    maps is that the lookup time is *not* constant, which means that they are a little
    slower to access by key. However, when you need to traverse a map in the order
    of the keys, then this is the only way to go. A strong constraint here is that
    the keys must be comparable between them. Sorted maps can be created, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparable objects are the ones that implement the `compareTo` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Common properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Associative objects, including maps have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are functions of their keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can be used with associative destructuring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can be accessed with the `get` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can convert a map to a `seq` with the `seq` function; you will get a sequence
    where each element is a vector representing a key-value pair in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '`Doseq` is similar to Java''s for-each loop. It executes the body for each
    element in a sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It works as shown: `(doseq [x sequence] ;;`. This works the same way as the
    let statement, you can use destructuring if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure sets are a collection of unique elements. You can think of them as mathematical
    sets and as such, Clojure has operations, such as union intersection and difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the properties of sets:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are associative (their keys are their elements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are counted, meaning they have a finite size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their elements are unique (contained at most once)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted sets and hash sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two kinds of sets: hash-sets and sorted-sets.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash-set**: Besides the properties that we already saw, hash-sets are unordered.
    They are implemented using a hash map as a backing implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorted-set**: Besides the properties that we already saw, sorted-sets are
    sorted. They can be used as a parameter to all the functions that expect a sorted
    `seq`. They can be accessed sequentially in sorted order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also reverse them without problems, filter them, or map them similarly
    to a vector or list.
  prefs: []
  type: TYPE_NORMAL
- en: Common properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets are associative, which gives them some properties of maps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are functions of their elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can be used with map destructuring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `get` function can be used to access their elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Union, difference, and intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you remember mathematical sets, you''ll know that the three main operations
    you can execute on them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Union** (`union a b`): The union includes all of the elements both in `a`
    and `b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difference** (`difference a b`): The difference is all the elements that
    are in `a` except for the elements that are also in `b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intersection** (`intersection a b`): It includes only the elements that are
    both in `a` and `b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Applying functional programming to collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how collections work, we have a better
    foundation to understand functional programming and how to make the most out of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This requires a different way of thinking about how to solve problems and you
    should keep your mind open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something that you might have found really strange about all of the collections
    is this feature: *They are immutable*.'
  prefs: []
  type: TYPE_NORMAL
- en: This is indeed something quite strange; if you are used to Java, how can you
    possibly write programs without adding or removing elements from a list or set?
  prefs: []
  type: TYPE_NORMAL
- en: How is that even possible? In Java, we are used to writing `for` and `while`
    loops. We are used to mutating variables every step of the way.
  prefs: []
  type: TYPE_NORMAL
- en: How can we cope with immutable data structures? Let's find out in the subsequent
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The imperative programming model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The software industry has been using a single software paradigm for a long time;
    this paradigm is an imperative programming model.
  prefs: []
  type: TYPE_NORMAL
- en: In the imperative paradigm, you have to tell the computer what to do at every
    single step. You are responsible for how the memory works, for whether it is running
    in a single core or multi core and, if you want to use multi core, you need to
    make sure that you change the program state correctly and avoid concurrency problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how you would calculate the factorial in an imperative style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: You are creating a variable result and a variable `i`. You change the variable
    `i` each time by assigning it the value `i + 1`. You can change the result by
    multiplying by `i`. The computer just executes your orders, comparing, adding,
    and multiplying. This is what we call the imperative programming model, because
    you need to tell the computer the exact commands it needs to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has worked fine in the past for various reasons, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The tight constraints of memory size forced programmers to make use of the memory
    as efficient as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was easier to think about a single thread of execution and how the computer
    executes it step-by-step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there were some drawbacks. A code can get complicated easily and
    the world has changed; the constraints that existed many years ago are gone. In
    addition, most of today's computers have more than one CPU. Multi-threading with
    shared mutable states is burdensome.
  prefs: []
  type: TYPE_NORMAL
- en: This makes thinking about this complicated. We get in trouble even in single
    threaded programs; just think, what would be the outcome of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Is it `0`? You can't possibly know because the `doSomething` method gets the
    list by reference and it can add or remove things without you knowing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that you have a multithreaded program and a single `List` that
    can be modified by any of the threads. In the Java world, you have to know about
    `java.util.concurrent.CopyOnWriteArrayList` and you need to know about its implementation
    details to know when it's a good idea to use it and when not to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Even with these structures, it is difficult to think about multithreaded code.
    You still need to think about semaphores, locks, synchronizers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The imperative world might be easy for the easy case, but it is not simple.
    The whole industry has realized this and there are many new languages and technologies
    that take ideas from other places. Java 8 has the streaming API and it includes
    lambda blocks, which are essentially functions. All these ideas are taken from
    the functional world.
  prefs: []
  type: TYPE_NORMAL
- en: The functional paradigm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other ways of thinking about how to solve a problem; in particular,
    the functional paradigm has become important lately. It is nothing new; Lisp has
    supported this kind of programming since it was conceived in 1958\. It has probably
    not been strong until recently, as it requires a more abstract way of thinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'For you to get a better idea, let''s see a couple of examples of how functional
    programming looks similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it looks quite different; in the first case, we are passing
    the `str` function to another function called map.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we are passing the `*` function to another function called
    reduce. In both cases, we are using functions as you would pass a list or a number,
    they are **first level citizens**.
  prefs: []
  type: TYPE_NORMAL
- en: One important difference in functional programming is that you don't need to
    tell the machine how to do things. In the first case, the map traverses the vector
    and applies the `str` function to each element, converting it to a `seq` of strings.
    You don't have to increment the index, you just need to tell the map what function
    you want to be applied to each element.
  prefs: []
  type: TYPE_NORMAL
- en: In the factorial case, there is a reduce function that receives the `*` and
    a `seq` from `1` to `n`.
  prefs: []
  type: TYPE_NORMAL
- en: It just works, you don't need to tell it how to do anything, just what you want
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Both `map` and `reduce` are **higher order functions** because they accept functions
    such as parameters; they are also higher level abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Higher order functions are functions that either accept a function as an argument,
    return a function as result, or both.
  prefs: []
  type: TYPE_NORMAL
- en: You need to think on another level of abstraction and you don't care how things
    are really done, just that it gets the work done.
  prefs: []
  type: TYPE_NORMAL
- en: This comes with some benefit, if the implementation of a map someday changes
    to become multithreaded, you would just need to update the versions and you would
    be ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have also noticed that functional programming makes working with immutable
    structures necessary, because you can't mutate some or the other state in every
    step; you can just describe how you want to create a new collection based on some
    other collection and then get it. Clojure's efficient collections make it possible
    to share pieces of collections to keep memory usage at a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other benefits to immutability:'
  prefs: []
  type: TYPE_NORMAL
- en: You can share your data structures with anyone you want because you are certain
    that nobody can change your copy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging is simpler because you can test the program with some immutable value
    instead of some mutating state. When you get a value, you can find out which function
    returned the value that you got; there are not multiple places where a collection
    was mutated for you to check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent programming is simpler; again being certain that nobody can change
    your copy, even in other concurrently running threads, makes reasoning about your
    program simpler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laziness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clojure also supports lazy evaluation of transformations of sequences. Let''s
    take a look at the `range` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: When running this function without parameters, you are creating an infinite
    sequence starting from `0`.
  prefs: []
  type: TYPE_NORMAL
- en: It is an infinite sequence; so why does the Clojure REPL return automatically?
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure doesn''t compute a collection value until needed, so in order to get
    a value you would have to do something, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you try to print an infinite sequence at the REPL, it will freeze.
  prefs: []
  type: TYPE_NORMAL
- en: Here, Clojure is resolving first one element and then five of the collection
    `r` because it needs to print them in the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lazy evaluation just works for collections and for sequence processing. Other
    operations (such as additions, method calls, and so on), are executed eagerly.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is that you can define a new lazy collection by applying
    functions like filter and map to a certain collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s get a new collection that contains all odd numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `odd-numbers` is an infinite sequence of odd numbers and we have just
    asked for three of them. Whenever a number is already computed, it is not computed
    again. Let''s change our collection a little bit in order to understand how this
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, some numbers get calculated first; you shouldn't expect or rely
    on a particular number of elements to be precomputed at a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that the computation isn't executed again when we ask for
    the same number of elements, since it has been already cached.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections and functional programming in Clojure are extremely powerful tools
    that allow us to use a completely different paradigm of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we have learned so far:'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics of immutable collections and what each collection type in Clojure
    is best for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How sequence abstraction and how a lot of Clojure functions are available to
    work on collections, using this abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How functional programming enables us to write simpler programs that work better
    in parallel environments and help us save resources using laziness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent chapters, we will learn about other new Clojure features that
    give us a new and much more powerful way to implement polymorphism than what Java
    offers.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Multimethods and Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a better understanding of how Clojure works; we understand how to
    perform simple operations with immutable data structures but we are missing some
    features that could make our lives much easier.
  prefs: []
  type: TYPE_NORMAL
- en: If you have been a Java programmer for a while, you are probably thinking about
    polymorphism and its particular flavor in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is one of the concepts that enable us to reuse a code. It gives
    us the ability to interact with different objects with the same API.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has a powerful polymorphism paradigm that allows us to write simple
    code, create code that interacts with types that don't exist yet, and extend code
    in ways it wasn't devised for when a programmer wrote it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us with polymorphism in Clojure, we have two important concepts that
    we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of them has its own use cases and things it is best at; we will look into
    them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn each of these different concepts by reviewing what we already
    know from Java and then we will learn similar concepts from Clojure that give
    us much more power.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java uses polymorphism heavily, its collection API is based on it. Probably
    the best examples of polymorphism in Java are the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.List`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know that depending on our use case we should use a particular implementation
    of these data structures.
  prefs: []
  type: TYPE_NORMAL
- en: If we prefer to use an ordered Set, we might use a TreeSet.
  prefs: []
  type: TYPE_NORMAL
- en: If we need a Map in a concurrent environment, we will use a `java.util.concurrent.ConcurrentHashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: The beautiful thing is that you can write your code using the `java.util.Map`
    and `java.util.Set` interfaces and if you need to change to another type of Set
    or Map, because the conditions have changed or someone has created a better version
    of the collection for you, you don't need to change any code!
  prefs: []
  type: TYPE_NORMAL
- en: Lets look at a very simple example of polymorphism in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a Shapes hierarchy; it might look similar to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'You surely are aware of the power of this concept, you can now calculate the
    summation of all the areas of a collection of figures, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymorphism in Java](img/B04289_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `totalArea` method doesn't care about the specific types of shapes that
    you pass to it and you can add new types of shapes, such as rectangles or trapezoids.
    Your same code will now work with new data types.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the same Java code base, imagine that you wanted to add a new function
    to your shape interface, something simple, such as a `getPerimeter` method.
  prefs: []
  type: TYPE_NORMAL
- en: This seems quite simple; you will have to modify each class that implements
    the Shape interface. I'm sure you've faced this problem a lot of times when you
    don't have access to the base source. The solution is to write a wrapper around
    your Shape objects but this introduces more classes and incidental complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has its own idea of polymorphism, it is much simpler but also very powerful;
    you can in fact solve the perimeter problem with it in a very simple way.
  prefs: []
  type: TYPE_NORMAL
- en: One way to solve this is with multimethods; lets have a look at how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multimethods are similar to interfaces, they allow you to write a common contract
    and then a family of functions can fulfill that interface with a specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: They are extremely flexible, as you will see they grant you a very fine control
    over what function is going to get invoked for a specific data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multimethods consist of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A function (or method) declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dispatch function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each possible implementation of the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most interesting features of multimethods is that you can implement
    new functions for already existing types without having to write wrappers around
    your currently existing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multimethod declaration works the same way as the interface; you define
    a common contract for the polymorphic function, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defmulti` macro defines the contract for your multimethod, it consists
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: The multimethod's name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `doctstring` (this is the documentation string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dispatch-fn` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dispatch` function gets called for every piece of content; it generates
    a dispatch key that is later checked against its function implementation. When
    the dispatch key and the key in the function implementation match, the function
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `dispatch` function receives the same parameters that the function you are
    calling receives and returns a dispatch key that is used to determine the function
    that should dispatch the request.
  prefs: []
  type: TYPE_NORMAL
- en: Each implementation function must define a dispatch key, if it matches with
    the `dispatch` function's result, then this function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example should clarify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a multimethod called `area`; the `defmulti` statement
    has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the multimethod is called `area` and the `dispatch` function is
    the `:shape` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, keywords can be used as functions that look up themselves in maps.
    So, for example, the result of (`:shape {:shape :square}`) is `:square`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterwards, we define a method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `dispatch-key` is always the result of invoking the `dispatch-function`
    with `params` as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the invocation, `(area {:shape :square :side 5})` which
    is calling a multimethod. The first thing that happens is that we call the dispatch
    function `:shape`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The `:square` function is now the dispatch key, we need to look for the method
    that has that dispatch key; in this case, the only method that we defined works.
    So, the function is executed and we get the result of `25`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is pretty simple to add the area and perimeter for both square and circle,
    lets check the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have defined how to calculate the perimeter and area of circles and
    squares with very little effort and without having to define a very strict object
    hierarchy. However, we are just starting to uncover the power of multimethods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keywords can be namespaced, it allows you to keep your code better organized.
    There are two ways to define a namespaced keyword, such as `:namespace/keyword`
    and `::keyword`. When using the `::` notation, the used namespace is the current
    namespace. So if you write `::test` in the REPL, you will be defining `:user/test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another example, copy the following code into your REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multimethods in Clojure](img/B04289_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it just works as you might expect it to. However, let's see
    how you can create a keyword hierarchy to be a little bit more flexible than this.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can declare that a keyword derives from another keyword and then respond
    to other dispatch keys, for that you can use the `derive` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining a keyword hierarchy, you have to use namespaced keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you are declaring that the `::hominid` key is derived from the `::animal`
    key and you can now use `::hominid` as `::animal`; let''s see that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'We do have some problems when defining hierarchies, for instance what will
    happen if the same keyword were to be derived from two conflicting keywords? Let''s
    give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: We get an error that says, there are two methods that match the dispatch value.
    Since our hominid derives both from animal and primate, it doesn't know which
    to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can work this out explicitly with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything works correctly. We know that we prefer to resolve to a primate
    when calling the walk multimethod with the hominid key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define a more specific method, just for the `hominid` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The derivation hierarchy can get a little complex and we might need some functions
    to introspect relationships. Clojure has the following functions to work with
    type hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: '`isa?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parents`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`descendants`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`underive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: isa?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `isa` function checks if a type derives from some other type, it works with
    Java classes as well as Clojure keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is simple to explain with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: parents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `parent` function returns a set of a type''s parents, they might be Java
    or Clojure keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: descendants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `descendants` function, as you can imagine, returns a set of descendants
    of the `passd` keyword; it is important to keep in mind that in this case only
    Clojure keywords are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: underive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `underive` function breaks the relation between two types, as you can imagine
    it only works with the Clojure keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: This function will normally be used at development time and they allow you to
    play around with your type hierarchy in a very simple and dynamic way.
  prefs: []
  type: TYPE_NORMAL
- en: A la carte dispatch functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we have used a keyword as a dispatch function but you can use any
    function you like with as many arguments as you want. Let''s take a look at some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple function, but it shows two important facts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `dispatch` function can receive more than one argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dispatch` key can be anything, not just a keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets have a look at how we can use this `dispatch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: We are getting to know the `dispatch` function a little bit better; now that
    you know that you can implement any `dispatch` function, you have a very fine
    grained control over what function gets called and when.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets look at one more example, so we can finally grasp the complete idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A la carte dispatch functions](img/B04289_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now the true power of multimethods becomes apparent. You now have an adhoc way
    of defining polymorphic functions which has the possibility to define type hierarchies
    and even execute your own logic to determine the function that is going to be
    called finally.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multimethods are just one of the options for polymorphism you have in Clojure,
    there are other ways to implement polymorphic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols are a little easier to understand and they might feel more similar
    to Java interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets try to define our shape program using protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a protocol and it is called shaped and everything that
    implements this protocol must implement the following two functions: `perimeter`
    and `area`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to implement a protocol; one interesting feature
    is that you can even extend Java classes to implement a protocol without an access
    to the Java source and without having to recompile anything.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a record that implements the type.
  prefs: []
  type: TYPE_NORMAL
- en: Records in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Records work exactly like maps, but they are much faster if you stick to the
    predefined keys. Defining a record is similar to defining a class, Clojure knows
    beforehand about the fields that the record will have, so it can generate byte
    code on the fly and the code that uses the records is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets define a `Square` record, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining the `Square` record and it has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It has only one field, `size`; this is going to work as a map with only the
    side key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It implements the `Shape` protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets have a look at how a record is instantiated and how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see it works exactly like a map, you can even associate things to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The downside of doing this is that we no longer have the performance guarantees
    that we had when defining just the record fields; nonetheless, it is a great way
    of giving some structure to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have to check how we can use our perimeter and area functions, it
    is pretty simple. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to continue with the example, let''s define the `Circle` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: One of the promises was that we will be able to extend our existing records
    and types without having to touch the current code. Well, lets keep to that promise
    and check how to extend our records without having to touch existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine, we need to add a predicate telling us whether a shape has an area
    or not; we might then define the next protocol, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get directly to the extend type, which is going to help us define this
    `num-sides` function for our old protocols. Note that with `extend-type` we can
    even define functions for existing Java types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Protocols become much more interesting when you extend them for Java types.
    Lets create a protocol that includes some functions for list like structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'And now you can use the positive values, negative values and `non-zero-values`
    with anything that extends from `java.util.List`, including Clojure''s vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: It might not be very exciting to extend `java.util.List`, since you can define
    these three as functions and it works the same way but you can extend any custom
    Java type with this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we understand Clojure''s way a little bit better and we have a better grasp
    of what to look for when we need polymorphism. We understand that when needing
    a polymorphic function we have several options:'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement multimethods if we need a highly customized dispatching mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement multimethods if we need to define a complex inheritance structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement a protocol and define a custom type that implements that protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can define a protocol and extend existing Java or Clojure types with our
    custom functions for each type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism in Clojure is very powerful. It allows you to extend the functionality
    of Clojure or Java types that already exist; it feels like adding methods to an
    interface. The best thing about it is that you don't need to redefine or recompile
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about concurrency—one of the key features
    of Clojure. We will learn about the idea of what the identity and values are and
    how those key concepts make writing concurrent programs much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming has changed, in the past we could just rely on computers getting
    faster year after year. This is proving to be more and more difficult; so, hardware
    manufacturers are taking a different approach. Now, they are embedding more processors
    into computers. Nowadays, it's not uncommon to see phones with just or four cores.
  prefs: []
  type: TYPE_NORMAL
- en: This calls for a different way of writing software, one in which we are able
    to execute some tasks in other processes, explicitly. The modern languages are
    trying to make this task feasible and easier for modern developers, and Clojure
    is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see how Clojure enables you to write simple concurrent
    programs by reviewing Clojure''s core concepts and primitives; in particular,
    we need to understand the concept of identity and value that Clojure has embedded
    into the language. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using your Java knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Clojure model of state and identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software transactional memory and refs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your Java knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing Java and your way around Java's threading APIs gives you a great advantage,
    since Clojure relies on the tools that you already know.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you'll see how to use threads and you can extend everything you see here
    to execute other services.
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further, let's create a new project that we'll use as a sandbox
    for all of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using your Java knowledge](img/B04289_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Modify the `clojure-concurrency.core` namespace, so that it looks similar to
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to understand what''s happening here. We are creating a thread with
    our function and then starting it; so that we can use it in the REPL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using your Java knowledge](img/B04289_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`java.lang.Thread` has a constructor, which receives an object implementing
    the runnable interface. You can just pass a Clojure function because every function
    in Clojure implements runnable and callable interfaces. This means that you can
    also use the executors transparently in Clojure!'
  prefs: []
  type: TYPE_NORMAL
- en: We'll see a `nil` and `Hello threaded world` values in any random order. The
    `nil` value is what the start thread returns.
  prefs: []
  type: TYPE_NORMAL
- en: The `Hello threaded world` is a message from another thread. With this, we now
    have the basic tools to get to know and understand how threads work in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: The Clojure model of state and identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure has very strong opinions about concurrency, in order to take it in a
    simpler way it redefines what state and identity mean. Let's explore the meaning
    of this concepts in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about state in Java, you probably think about the values of the
    attributes of your Java classes. The state in Clojure is similar to Java, it refers
    to the values of objects but there are very important differences that allow simpler
    concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, identity is an entity that might have different values over time.
    Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: I have an identity; I will be and continue being this particular individual,
    my opinions, ideas, and appearance might change over time but I am the same individual
    with the same identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a bank account; it has a particular number and is run by a particular
    bank. The amount of money you have in it changes over time, but it is the same
    bank account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a ticker symbol (such as GOOG), it identifies a stock in the stock
    market; the value associated with it changes over time, but not its identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State** is a value that an identity took at some point in time. One of its
    important features is that it is immutable. State is a snapshot of an identity''s
    value at some given time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Who you are right now, how you feel, how you look, and what you think is your
    current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The money you currently have in your bank account is its current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the GOOG stock is its current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these states are immutable; it doesn't matter who you are tomorrow or
    how much you win or spend. It is true and it will always be true that in this
    particular moment in time you have a certain state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rich Hickey, Clojure's author, is a great talker and has several talks in which
    he explains the ideas and philosophy behind Clojure. In one of them, (Are We There
    Yet?) he explains this idea of state, identity, and time very extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explain the two key concepts in Clojure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**: Throughout your whole life, you have a single identity; you never
    stop being you, even if you keep changing throughout your whole life.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: At any given moment in your life, you are a certain person with
    likes, dislikes, and some beliefs. We call this way of being at a moment of your
    life, the state. If you look at a particular moment in your life, you will see
    a fixed value. Nothing will change the fact that you were the way you were in
    that moment in time. That particular state is immutable; over time, you have different
    states or values, but each of those states is immutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use this fact to write simpler concurrent programs. Whenever you want to
    interact with an identity, you look at it and you get its current value (a snapshot
    at the time), and then you operate with what you have.
  prefs: []
  type: TYPE_NORMAL
- en: In imperative programming, you normally have a guarantee that you have the latest
    value but it is very difficult to keep it in a consistent state. The reason for
    this is that you are relying on a shared mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: A shared mutable state is the reason why you need to use a synchronized code,
    locks, and mutexes. It is also the reason for very complex programs, with difficult
    bugs to track.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, Java is learning the lessons from other programming languages and
    now it has primitives that allow simpler concurrent programming. These ideas are
    taken from other languages and newer ideas, so there is a good chance that someday
    you'll see similar concepts to what you'll study here in other mainstream programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: There is no guarantee that you'll always have the latest value, but don't worry,
    you just have to think about things differently and use the concurrency primitives
    that Clojure gives you.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to how you work in real life, you don't know exactly what's
    happening with all of your friends or co-workers when you do something for them;
    you talk to them, get the current facts, and then go and get working. While you
    are at it, something needs to change; in this case we need a coordination mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has various such coordination mechanisms, let's have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a full stack Java developer, there is a good chance that you have
    met promises in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are simple abstractions that don't impose strict requirements on you;
    you can use them to calculate the result on some other thread, light process,
    or anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there are a couple of ways to achieve this; one of them is with futures
    (`java.util.concurrentFuture`) and if you want something more similar to JavaScript's
    promise there is a nice implementation called **jdeferred** ([https://github.com/jdeferred/jdeferred](https://github.com/jdeferred/jdeferred)),
    which you might have used before.
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence a promise is just a promise that you can give to your caller, the
    caller can use it at any given time. There are two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: If the promise has already been fulfilled, the call returns immediately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not, the caller will block until the promise is fulfilled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example; remember to use the start-thread function
    in the `clojure-concurrency.core` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises](img/B04289_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Promises are only calculated once and then cached. So don't worry about using
    them as many times as you like once it has been calculated, there is no runtime
    cost associated!
  prefs: []
  type: TYPE_NORMAL
- en: Let's stop here and analyze the code, we are creating a promise called `p` and
    then we start a thread that does two things.
  prefs: []
  type: TYPE_NORMAL
- en: It tries to get a value from `p` (the `deref` function tries to read the value
    from a promise) and then prints `Hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: We won't see the `Hello world` message just yet; we will instead see a `nil`
    value. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: The start thread returns the `nil` value and what happens now is what we described
    in the first place; `p` is the promise and our new thread will block it until
    it gets a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see the `Hello world` message, we need to deliver the promise.
    Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises](img/B04289_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we now get the `Hello world` message!
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, there is no need to use another thread. Let''s now see another example
    in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises](img/B04289_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use `@p` instead of (`deref p`), it works for every identity in this
    chapter too.
  prefs: []
  type: TYPE_NORMAL
- en: In this example we don't create separate threads; we create the promise, deliver
    it, and then use it in the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, promises are an extremely simple type of synchronization mechanism,
    you can decide whether to use threads, executor services (which are just thread
    pools), or some other mechanism, such as lightweight threads.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at Pulsar library for creating lightweight threads.
  prefs: []
  type: TYPE_NORMAL
- en: Pulsar and lightweight threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a thread is an expensive operation and it consumes RAM memory. To
    know how much memory creating a thread consumes in Mac OS X or Linux, run the
    next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'What you see here will depend on the OS and JVM version that you are using,
    with Java 1.8u45 on Mac OS X, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pulsar and lightweight threads](img/B04289_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I am getting a stack size of 1024 kilobytes per thread. What can we do to improve
    the numbers? Other languages, such as Erlang and Go create a few threads from
    the beginning and then execute their tasks using those threads. It becomes important
    to be able to suspend a particular task and run another in the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure there is a library called **Pulsar** ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)),
    which is an interface for a Java API called **Quasar** ([https://github.com/puniverse/quasar](https://github.com/puniverse/quasar)).
  prefs: []
  type: TYPE_NORMAL
- en: In order to support Pulsar, as of version 0.6.2, you need to do two things.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `[co.paralleluniverse/pulsar "0.6.2"]` dependency to your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an instrumentation agent to your JVM (`adding :java-agents [[co.paralleluniverse/quasar-core
    "0.6.2"]]` to your `project.clj`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The instrumentation agent should be able to suspend functions in a thread and
    then change them for other functions. In the end, your `project.clj` file should
    look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Let's write our last example with promises using Pulsar's lightweight threads
    called fibers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pulsar comes with its own promises in the `co.paralleluniverse.pulsar.core`
    package and they can be used as a drop-in replacement for promises in `clojure.core`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is a bit more interesting, we use two of Pulsar''s functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spawn-fiber`: This function creates a light thread, you can create thousands
    of fibers if you want in a single program. They are cheap to create and as long
    as you program them carefully, there shouldn''t be many problems coming from this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span-thread`: This is Pulsar''s version of start-thread, it creates a real
    thread and runs it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this particular example, we calculate `p2` and `p3` in two fibers and then
    `p3` in a thread. At this point, everything is waiting for us to deliver the value
    of `p1`; we do it with the `deliver` function.
  prefs: []
  type: TYPE_NORMAL
- en: Pulsar has other very interesting features that allow for simpler parallel programming,
    have a look at the documentation if you are interested. In the last part of this
    chapter, we will have a look at `core.async`. Pulsar has an interface modelled
    after `core.async`, which you can use if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been using Java for a while, you might know the `java.util.concurrent.Future`
    class, this is Clojure's implementation of futures and it is extremely similar
    to Java, only a bit simpler. Its interface and usage are almost identical to promises
    with a very important difference, when using futures everything will run in a
    different thread automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example using futures, in any REPL do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Your REPL should freeze for 20 seconds and then print `Hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Futures are also cached, so you only need to pay once for the cost of calculation
    and then you can use them any number of times you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, futures look much easier than promises. You don''t need to
    worry about creating threads or fibers, but there are downsides to this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: You have less flexibility; you can only run futures in a predefined thread pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be careful if your futures take too much time, they could end up
    NOT running because the implicit thread pool has a number of threads available.
    If they are all busy some of your tasks will end up queued and waiting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Futures` have their use cases, if you have very few processor intensive tasks,
    if you have IO bound tasks, maybe using promises with fibers is a good idea, since
    they allow you to keep your processor free to run more tasks concurrently.'
  prefs: []
  type: TYPE_NORMAL
- en: Software transactional memory and refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Clojure's most interesting features is **software transactional memory**
    (**STM**). It uses **multiversion concurrency control** (**MVCC**), in a very
    similar fashion to how databases work, implementing a form of optimistic concurrency
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MVCC is what databases use for transactions; what this means is that every operation
    within a transaction has its own copy of variables. After executing its operations,
    it checks if any of the used variables changed during the transaction and if they
    did the transaction fails. This is called optimistic concurrency control because
    we are optimistic and we don't lock any variable; we let every thread do its work
    thinking that it's going to work correctly and then check if it was correct. In
    practice, this allows for greater concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the most obvious example, a bank account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code now, enter into the REPL and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Try to write the future and the `dosync` functions at the same time so you have
    the same results.
  prefs: []
  type: TYPE_NORMAL
- en: We have just three lines of code here but there are quite a few things happening.
  prefs: []
  type: TYPE_NORMAL
- en: First of all we define a `ref (account)`; refs are the managed variables in
    transactions. They are also the first implementation we see of Clojure's identity
    idea. Note that the account is an identity now and it might take multiple values
    throughout its life.
  prefs: []
  type: TYPE_NORMAL
- en: We now modify its value, we do this within a transaction since refs cannot be
    modified outside of transactions; thus, the `dosync` block.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we print the account and we can use (`deref` account) or `@account`,
    as we did for promises and futures.
  prefs: []
  type: TYPE_NORMAL
- en: Refs can be read from anywhere, there is no need for it to be within a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at something a little bit more interesting now, write or copy the
    next code into the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, you should have an output similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software transactional memory and refs](img/B04289_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This might seem a little strange, what is happening?
  prefs: []
  type: TYPE_NORMAL
- en: The first transaction starts its process using the current value for account,
    the other transaction then modifies the value of account before the first transaction
    is finished; Clojure realizes this and it restarts the first transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You shouldn't execute functions with side effects within transactions, as there
    is no guarantee that they will be executed only once. If you need to do something
    like that you should use an agent.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first example of how a transaction works, but using `ref-set` is
    not a good idea in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example, the classic example of moving money
    from an account *A* to an account *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a better example of how transactions work; you will probably see something
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software transactional memory and refs](img/B04289_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First of all, you need to understand how the `alter` function works; it''s
    simple and it receives:'
  prefs: []
  type: TYPE_NORMAL
- en: The ref that it has to modify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that it has to apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extra arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Is translated to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This is the preferred way to modify the current value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a step by step description of what''s going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: We define two accounts with a balance of 10000 and 2000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We try to move 500 units from the first account to the second but first we sleep
    for 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We announce (using the promise) that we have started the transaction. The current
    thread moves on, since it was waiting for the started value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the balance of account-a to 20.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first transaction realizes that something has changed and restarts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transaction goes on and is finished this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nothing happens, since the new balance is not enough to move 50 units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, if you check the balance, like `[@account-a @account-b]`, you will
    see that the first account has 20 and the second account has 2000.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another use case that you should take into account; let''s check the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that if `secured` is set to true, you shouldn't be able to withdraw
    any money.
  prefs: []
  type: TYPE_NORMAL
- en: If you run it and then check for the value of `@account`, you'll see that even
    after changing the value of `secured` to true a withdrawal occurs. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that transactions only check for values that you modify within
    a transaction or values that you read; here we are reading the secured value before
    the modification, so the transaction doesn''t fail. We can tell the transaction
    to be a little bit more careful by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Here almost the same thing happened. What is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: There is one subtle difference, the second transaction can't finish until the
    first transaction is done. If you look at it in detail, you will notice that you
    can't modify the secured value until after the other transaction runs.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to a lock; not the best idea but useful in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now seen how promises, futures, and transactions work in Clojure. We'll
    now see atoms.
  prefs: []
  type: TYPE_NORMAL
- en: Even though STM is very useful and powerful you'll see that in practice it is
    not very commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms are one of Clojure's workhorses, when it comes to concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of atoms as transactions that modify one single value. You might
    be thinking, what good is that? Imagine you had lots of events that you want to
    store in a single vector. If you are used to Java, you probably know that using
    a `java.util.ArrayList` package is bound to have problems; since, you are almost
    surely going to lose data.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, you probably want to use a class from the `java.util.concurrent`
    package, how can you guarantee that you'll have no data loss in Clojure?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy, atoms come to the rescue! Let''s try this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: We are again using Pulsar and its lightweight threads. Here, we define an events
    atom and a `log-events` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `log-events` execute a `swap!` a given number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '`Swap!` is similar to the `alter` function it receives:'
  prefs: []
  type: TYPE_NORMAL
- en: The atom that it should modify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that it applies to the atom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extra arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, it gives the atom the new value that comes from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: We then spawn five fibers, each fiber adds 500 events to the events atom.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this, we can check for the number of events from each fiber like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have 500 elements from each fiber with no data loss and using
    Clojure's default data structures. There is no need to use special data structures
    for each use case, locks, or mutexes. This allows for greater concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: When you modify an atom, you need to wait for the operation to be complete meaning
    it is synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if you don't care about the result of some operation? You just need to
    fire something and then forget it. In that case agents are what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Agents also run in separate thread pools, there are two functions that you
    can use to fire an agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`send`: This executes your function in an implicit thread pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send-off`: This tries to execute your function in a new thread but there''s
    a change, it will reuse another thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents are the way to go if you want to cause side effects in a transaction;
    since, they will only be executed after the transaction has completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'They work in a very simple manner, here is an example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: If you copy and paste the exact previous code you will see a `0` and then a
    `:done` message, if you check for the value of `@agt`, then you will see the value
    `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Agents are a good way to execute a given task and modify some value in a different
    thread with simpler semantics than those of futures or manually modifying values
    in another thread.
  prefs: []
  type: TYPE_NORMAL
- en: Validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the primary concurrency primitives now, let's see some utilities
    that apply to all of them at once.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a validator that checks if the new value of some function is desirable
    or not; you can use them for refs, atoms, agents, and even vars.
  prefs: []
  type: TYPE_NORMAL
- en: The `validator` function must receive a single value and return true if the
    new value is valid or false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple `validator` that checks if the new value is lower than
    `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: We get an exception. The reason is that the new value (`10`) is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add `4` without a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful with the validator and agents, since you will probably not know
    when an exception occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Watchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to validators, there are also watchers. Watchers are functions that
    are executed whenever Clojure''s identities get a new value. An important question
    is the thread in which watchers run. Watchers run in the same thread as the watched
    entity (if you add a watcher to an agent it will be run in the agent''s thread),
    it will be run before the agent code executes, so you should be careful and use
    the old-value new-value instead of reading the value with `deref`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add-watch` function receives:'
  prefs: []
  type: TYPE_NORMAL
- en: The ref, atom, agent, or var that should be watched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key that will be passed to the watcher function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function with four parameters: the key, the reference itself, the old value,
    and the new value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After executing the previous code we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: core.async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `core.async` is yet another way of programming concurrently; it uses the
    idea of lightweight threads and channels to communicate between them.
  prefs: []
  type: TYPE_NORMAL
- en: Why lightweight threads?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lightweight threads are used in languages, such as go and Erlang. They excel
    in being able to run thousands of threads in a single process.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the lightweight threads and traditional threads?
  prefs: []
  type: TYPE_NORMAL
- en: The traditional threads need to reserve memory. This also takes some time. If
    you want to create a couple of thousand threads, you will be using a noticeable
    amount of memory for each thread; asking the kernel to do that also takes time.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference with lightweight threads? To have a couple of hundred
    lightweight threads, you only need to create a couple of threads. There is no
    need to reserve memory and lightweight threads are a mere software idea.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved with most languages and Clojure is adding first class support
    (without changing the language this is part of the Lisp power) with using `core.async`!
    Let's have a look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two concepts that you need to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goblocks**: They are the lightweight threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channels**: Channels are a way to communicate between goblocks, you can think
    of them as queues. Goblocks can publish a message to the channel and other goblocks
    can take a message from them. Just as there are integration patterns for queues,
    there are integration patterns for channels and you will find concepts similar
    to broadcasting, filtering, and mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's play a little with each of them so you can understand better how
    to use them for our program.
  prefs: []
  type: TYPE_NORMAL
- en: Goblocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find goblocks in the `clojure.core.async` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Goblocks are extremely easy to use, you need the go macro and you will do something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: They are similar to threads; you just need to remember that you can create goblocks
    freely. There can be thousands of running goblocks in a single JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can actually use anything you like to communicate between goblocks, but
    it is recommended that you use channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels have two main operations: putting and getting. Let''s check how to
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it!! It looks pretty simple, as you can see there are three main functions
    that we are using with channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chan`: This function creates a channel and the channels can store some messages
    in a buffer. If you want this functionality, you should just pass the size of
    the buffer to the `chan` function. If no size is specified, the channel can store
    only one message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>!`: The put function must be used within a goblock; it receives a channel
    and the value you want to publish to it. This function blocks, if a channel''s
    buffer is already full. It will block until something is consumed from the channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<!`: This takes function; this function must be used within a goblock. It
    receives the channel you are taking from. It is blocking and if you haven''t published
    something in the channel it will park until there''s data available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are lots of other functions that you can use with channels, for now let''s
    add two related functions that you will probably use soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>!!`: The blocking put, works exactly the same as the `put` function; except
    it can be used from anywhere. Note that if a channel cannot take more data, this
    function will block the entire thread from where it runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<!!`: The blocking works exactly the same as the `take` function, except you
    can use this from anywhere and not just from inside goblocks. Just keep in mind
    that this blocks the thread where it runs until there''s data available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look into the `core.async` API docs ([http://clojure.github.io/core.async/](http://clojure.github.io/core.async/))
    you will find a fair amount of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of them look similar to the functions that give you functionalities similar
    to queues, let''s take a look at the `broadcast` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: With this you can publish it to several channels at the same time, this is helpful
    if you want to subscribe multiple processes to a single source of events with
    a great amount of separation of concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a good look, you will also find familiar functions over there:
    `map`, `filter`, and `reduce`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the version of `core.async`, some of these functions might not
    be there anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Why are these functions there? Those functions are meant to modify collections
    of data, right?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that there has been a good amount of effort towards using channels
    as higher-level abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to see channels as collections of events, if you think of them that
    way it's easy to see that you can create a new channel by mapping every element
    of an old channel or you can create a new channel by filtering away some elements.
  prefs: []
  type: TYPE_NORMAL
- en: In recent versions of Clojure, the abstraction has become even more noticeable
    with transducers.
  prefs: []
  type: TYPE_NORMAL
- en: Transducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transducers are a way to separate the computations from the input source. Simply,
    they are a way to apply a sequence of steps to a sequence or a channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: The `comp` feels similar to the threading macros, it composes functions and
    stores the steps of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part is that we can use the same odd-counts transformation
    with a channel, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have checked the core Clojure mechanisms for concurrent programming, as
    you can see, they feel natural and they build on already existing paradigms, such
    as immutability. The most important idea is what an identity and value is; we
    now know that we can have the following values as identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: Refs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also get the snapshot of their value with the defer function or the `@`
    shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to use something a little more primitive, we can use promises or
    futures.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how to use threads, or Pulsar's fibers. Most of Clojure's
    primitives aren't specific to some concurrency mechanism, so we can use any parallel
    programming mechanism with any type of Clojure primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Macros in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will get to know one of Clojure''s most complicated facilities:
    macros. We will learn what they are for, how to write them, and how to use them.
    It can be a little challenging, but there is good news too. You should be aware
    of some tools from your knowledge of the Java language that can help you understand
    macros better. We will progress little by little with comparisons to other JVM
    languages, and in the end, we will write some macros and understand that we have
    been using them for a while.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Lisp's foundational ideas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros as code modification tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying code in Groovy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your first macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros in the real world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp's foundational ideas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lisp is a very different beast from what you used to know. According to Paul
    Graham, there are nine ideas that make Lisp different (these ideas have existed
    since the late 1950s), and they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals (remember, we are talking 1950s–1960s)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions as first-class citizens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic typing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programs as sequences of expressions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The symbol type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lisp's syntax
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The whole language is there all the time: at compilation, runtime—always!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you can, read Paul Graham's essay *Revenge of the Nerds* ([http://www.paulgraham.com/icad.html](http://www.paulgraham.com/icad.html)),
    where he talks about Lisp, what makes it different, and why the language is important.
  prefs: []
  type: TYPE_NORMAL
- en: These ideas have thrived even after the Lisp age; most of them are common nowadays
    (can you imagine a language without conditionals?). But the last couple of ideas
    are what makes us Lisp lovers love the syntax (we will fully understand what they
    mean through this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Common languages are trying to achieve the very same things now with a slightly
    different approach, and you, as a Java developer, have probably seen this.
  prefs: []
  type: TYPE_NORMAL
- en: Macros as code modification tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first and most common uses of macros is to be able to modify code;
    they work on the code level, as you will see. Why should we do that? Let's try
    to understand the problem with something that you are more familiar with—Java.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying code in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever used AspectJ or Spring AOP? Have you ever had problems with tools
    such as ASM or Javassist?
  prefs: []
  type: TYPE_NORMAL
- en: You have probably used code modification in Java. It is common in Java EE applications,
    just not explicit. (Have you ever thought about what the `@Transactional` annotation
    does in Java EE or Spring applications?)
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we try to automate everything we can, so how could we leave out
    our own devtools?
  prefs: []
  type: TYPE_NORMAL
- en: We have tried to create ways to modify the bytecode at runtime so that we don't
    have to remember to open and close resources, or so that we can decouple dependencies
    and get dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Spring, you probably know about the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Transactional` annotation modifies the annotated method to ensure that
    your code is wrapped in a database transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Autowired` annotation looks for the required bean and injects it into
    the annotated property or method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Value` annotation looks for a configuration value and then injects it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could probably think of several other annotations that modify the way your
    classes work.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing here is that you understand why we want to modify code,
    and you probably already know a few mechanisms for doing it, including AspectJ
    and Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how it is done in the Java world; this is what an aspect
    in Java looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Aspects have the advantage that you can modify any code you like without having
    to touch it. This also has its drawbacks since you could modify the code in ways
    the original author didn't expect and thus cause bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback is that you have an extremely limited field of action; you
    can wrap your modifications around some code or execute something before or after.
  prefs: []
  type: TYPE_NORMAL
- en: The libraries that generate this code are extremely complex and they can either
    create a proxy around your objects or modify the bytecode, at runtime or compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, there are lots of things that you must be aware of, and
    anything could go wrong. Hence, debugging could prove complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying code in Groovy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Groovy has gone further down the road and it provides us with more solutions
    and more macro-like features.
  prefs: []
  type: TYPE_NORMAL
- en: Since Groovy 1.8, we have got a lot of AST transformations. What does AST stand
    for? It stands for **abstract syntax tree**—sounds complicated, right?
  prefs: []
  type: TYPE_NORMAL
- en: Before explaining it all, let's check what some of them do.
  prefs: []
  type: TYPE_NORMAL
- en: The @ToString annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@ToString` annotation generates a simple `toString` method that includes
    information about the class of the object and the value of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: The @TupleConstructor annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@TupleConstructor` creates a constructor that is able to take all of the
    values of your class at once. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: The @Slf4j annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Slf4j` annotation adds an instance of a logger, called log by default,
    to your class, so you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: This can be done without having to manually declare the log instance, the class
    name, and so on. There are lots of other things that you can do with this type
    of annotation, but how do they work?
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is AST and what does it have to do with Clojure macros? Come to think
    of it, it actually has a lot to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: To answer that last question, you'll have to understand a little bit about how
    compilers work.
  prefs: []
  type: TYPE_NORMAL
- en: We all know that machines (your machine, the JVM, the Erlang BEAM machine) are
    not capable of understanding human code, so we need a process to convert whatever
    developers write into what machines understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important steps of the process is to create a syntax tree,
    something similar to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The @Slf4j annotation](img/B04289_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a very simple example of the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'This tree is what we call the abstract syntax tree. Let''s see the tree of
    something that''s a bit more complicated, such as this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the tree will look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The @Slf4j annotation](img/B04289_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the figure is still pretty straightforward, and you can probably
    understand how someone would execute code from a structure like this one.
  prefs: []
  type: TYPE_NORMAL
- en: Groovy's AST transformation is a way to meddle with such generated code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this is a much more powerful approach, but you are now messing
    with what the compiler generated; the probable downside to this is the complexity
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check, for instance, the code of the `@Slf4j` AST. It should be pretty
    simple, right? It just adds a log property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can check the complete code at [https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java](https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java),
    and it's also included with the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't look simple at all. It is just a fragment and still looks very
    complicated. What happens here is that you have to deal with the Java bytecode
    format and with compiler complications.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should remember point number 8that Paul Graham made about the syntax
    of Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our last code example in Clojure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s something peculiar about this piece of code: it feels very similar
    to the AST! This is not a coincidence. Actually, in Clojure and Lisp, you are
    directly writing the AST. This is one of the features that make Lisp a very simple
    language; you directly write what the computer understands. This might help you
    understand a little more about why code is data and data is code.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if you could modify the AST the same way that you modify any other data
    structure in your programs. But you can, and that's what macros are for!
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a clear understanding of how macros work and what they are
    for, let's start working with Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me present you with a challenge: write an `unless` function in Clojure,
    something that works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give it a first try; maybe with something like the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you know what would happen if you wrote this code and then ran it? If you
    test it, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here? Let''s modify it a bit so that we get a value and we
    can understand what''s happening. Let''s define it a bit differently, and let''s
    return a value so that we see something different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: What's going on here?
  prefs: []
  type: TYPE_NORMAL
- en: When you pass parameters to a function, everything is evaluated before the actual
    code of the function runs, so over here, before the body of your function runs,
    you execute both of the `println` methods. After that, the `if` runs correctly
    and you get `:bigger`, but we still got an output for the positive and negative
    cases of our `if`. It looks like our code is not working!
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we fix this? With our current tools, we probably need to write closures
    and change the `my-if` code to accept functions as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but there are several disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of constraints now for the code (both clauses should now be
    functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't work for every single case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very complicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to solve this problem, Clojure gives us macros. Let''s have a look
    at how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: This is great! It works, but what just happened? Why did we just use a macro
    and why did it work?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Macros are not normal Clojure functions; they are supposed to generate code
    and should return a Clojure form. This means that they should return a list that
    we can use as normal Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros return code that will be executed later. And here is where point number
    nine of Paul Graham''s list comes into play: you have all of the language all
    the time.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++, you have a mechanism called a macro; when you use it, you have a very
    limited set of things that you can do compared to actual C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, you can manipulate the Clojure code any way you want, and you can
    use the full language here too! Since Clojure code is data, manipulating the code
    is as easy as manipulating any other data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Macros are run at compile time, which means that at the time of running the
    code, there is no trace of macros; every macro call is replaced with the generated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your first macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, as you can imagine, since things can get complicated when using macros,
    there should be some way to debug them. We have two functions to accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`macroexpand`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`macroexpand-1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between them has to do with recursive macros. There is no rule
    telling you that you can't use a macro from a macro (the whole language is there
    all the time, remember?). If you wish to go all the way through any macro, you
    can use `macroexpand`; if you wish to go a single step forward, you can use `macroexpand-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Both of them show you the code generated by a macro call; this is what happens
    when you compile your Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give this a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: There is not much more to macros than this; you now understand them to a good
    level of detail.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, many common problems that you will come across and tools
    for solving them that you should know about. Let's have a look.
  prefs: []
  type: TYPE_NORMAL
- en: Quote, syntax quote, and unquoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see, the `my-if` macro uses a quote in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: This happens because you need the `if` symbol as the first element in the resulting
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Quoting is very common in macros, since we need to build code instead of evaluating
    it on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another type of quoting very common in macros—syntax quoting—that
    makes it easier to write code similar to the final code you want to generate.
    Let''s change the implementation of our macro to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what happens here. For one,`(if test positive negative)` looks much
    more beautiful than the `list` function we had before, but the code generated
    with `macroexpand-1` looks pretty strange. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: We just used a different form of quoting that allows us to quote full expressions.
    It does some interesting things. As you can see, it changes the parameters to
    fully qualified `var` names (`clojure.core/test`, `user/positive`, `user/negative`).
    This is something that you'll be grateful for in the future, but you don't need
    this for now.
  prefs: []
  type: TYPE_NORMAL
- en: What you need are the values of test, positive, and negative. How can you get
    them in this macro?
  prefs: []
  type: TYPE_NORMAL
- en: 'Using syntax quotes, you can ask for something to be evaluated inline with
    the unquote operator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try our macro expansion again and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quote, syntax quote, and unquoting](img/B04289_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unquote splicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some other cases that become common in macros. Let's imagine we want
    to reimplement the `>` function as a macro and retain the ability to compare several
    numbers; what would that look like?
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe a first attempt could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unquote splicing](img/B04289_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Do you see the problem here?
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that we are trying to pass a list of values to `clojure.core/>`
    instead of passing the values themselves.
  prefs: []
  type: TYPE_NORMAL
- en: This is easily solved with something called **unquote splicing**. Unquote splicing
    takes a vector or list of parameters and expands it as if you had used the `as`
    parameter on a function or macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unquote splicing](img/B04289_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will use unquote splicing almost every time you have a variable number of
    arguments to a macro.
  prefs: []
  type: TYPE_NORMAL
- en: gensym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating code can be troublesome, and we end up discovering common issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'See if you can find the issue in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common issue when generating code. You overwrite another value, Clojure
    doesn''t even let you run this, and it displays something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![gensym](img/B04289_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But don''t worry; there''s another way in which you can make sure you are not
    messing with your environment, which is the `gensym` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gensym` function creates a new `var-name` each time the macro is run,
    which guarantees that there is no other `var-name` that it obscures. If you try
    the macro expansion now, you will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![gensym](img/B04289_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Macros in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you want to know when it is that macros are used extensively? Think about
    `defn`; what''s more, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Did you know that `defn` is a macro in `clojure.core` that creates a function
    and binds it to a `var` in the current namespace?
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is filled with macros; if you want some samples, you can look at Clojure
    core, but what else can you do with macros?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at some interesting libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yesql`: The `yesql` library is a very interesting sample of code generation.
    It reads SQL code from a SQL file and generates the Clojure functions accordingly.
    Look for the `defquery` and `defqueries` macros in the `yesql` project on GitHub;
    it can be very enlightening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core.async`: If you are familiar with the `go` language and `goroutines`,
    you would probably like to have that same functionality in the Clojure language.
    This isn''t necessary since you could have provided them yourself! The `core.async`
    library is just `goroutines` for Clojure, and it is provided as a library (no
    obscure language change is needed). This shows a great example of the power of
    macros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core.typed`: With macros, you can even change the dynamic nature of Lisp.
    The `core.typed` library is an effort that allows you to define type constraints
    for your Clojure code; macros are extensively used here to generate boilerplate
    code and checks. This is probably much more complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need further references, you can look at the following list. There are
    entire books committed to the topic of macros. I recommend two in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Clojure Macros ([https://pragprog.com/book/cjclojure/](https://pragprog.com/book/cjclojure/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let over Lambda ([http://letoverlambda.com/](http://letoverlambda.com/)).It
    talks about common Lisp, but the knowledge is very valuable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now understand the power of macros and have a very strong grasp of how they
    work, but we just touched the tip of the iceberg when it comes to macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of how macros work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying your code in Groovy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relation of macros to other tools in the Java world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am sure you've enjoyed working with Clojure so far, and moving forward, I'd
    recommend you to keep reading and exploring this amazing language.
  prefs: []
  type: TYPE_NORMAL
