<html><head></head><body>
		<div id="_idContainer043">
			<h1 class="chapter-number" id="_idParaDest-63"><a id="_idTextAnchor066"/>2</h1>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor067"/>Securing Spring Boot Applications with OAuth2</h1>
			<p><strong class="bold">Open Authorization 2.0</strong> (<strong class="bold">OAuth 2.0</strong>) is an open standard protocol<a id="_idIndexMarker097"/> that provides secure authorization for web and mobile applications. It allows users to grant<a id="_idIndexMarker098"/> limited access to their resources on one website (called the “resource server”) to another website or application (called the “client”) without sharing their<a id="_idIndexMarker099"/> credentials, such as usernames and passwords. This means that the resource server will never see a user’s credentials. OAuth 2.0 is widely used for enabling <strong class="bold">single sign-on</strong> (<strong class="bold">SSO</strong>), accessing third-party APIs, and implementing secure<a id="_idIndexMarker100"/> authorization mechanisms. SSO allows a user to log in to any of several related, yet independent, applications with a single ID. Once logged in to an application, the user is not required to reenter the credentials to access the rest of <span class="No-Break">the applications.</span></p>
			<p><strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) is an open standard for user authentication<a id="_idIndexMarker101"/> that’s built on top of OAuth 2.0. It’s used with OAuth 2.0 to enable secure access to user data. An example of this is when an application allows you to sign in with your Google Account. Usually, they can request access to certain parts of your Google Account profile or permissions to interact with your account on <span class="No-Break">your behalf.</span></p>
			<p>In this chapter, we will learn how to deploy a basic Spring Authorization Server that we’ll be using in most of the recipes in this book. Then, we’ll learn about the most common scenarios to protect an application, from a RESTful API to a web application. Finally, we’ll apply the same concepts but using two popular cloud solutions: Google Accounts for user authentication and Azure AD B2C for an extensible end-to-end <span class="No-Break">authentication experience.</span></p>
			<p>Spring Boot offers great support for OAuth2 and OIDC, regardless of the Identity/Authorization server used. It manages the standard OAuth2/OpenID concepts that are implemented by <span class="No-Break">all vendors.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Setting up Spring <span class="No-Break">Authorization Server</span></li>
				<li>Protecting a RESTful API <span class="No-Break">using OAuth2</span></li>
				<li>Protecting a RESTful API using OAuth2 with <span class="No-Break">different scopes</span></li>
				<li>Configuring an MVC application with <span class="No-Break">OpenID authentication</span></li>
				<li>Logging in with <span class="No-Break">Google Accounts</span></li>
				<li>Integrating a RESTful API with a cloud <strong class="bold">identity </strong><span class="No-Break"><strong class="bold">provider</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IdP</strong></span><span class="No-Break">)</span></li>
			</ul>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>Technical requirements</h1>
			<p>This chapter has the same technical requirements as <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. So, we will need an editor such as Visual Studio Code or IntelliJ, Java OpenJDK 21 or higher, and a tool to perform HTTP requests, such as <strong class="source-inline">curl</strong> <span class="No-Break">or Postman.</span></p>
			<p>For some scenarios, you will need a Redis server. The easiest way to run a Redis server locally is by <span class="No-Break">using Docker.</span></p>
			<p>For the <em class="italic">Logging in with Google Accounts</em> recipe, you will need a <span class="No-Break">Google Account.</span></p>
			<p>For the <em class="italic">Integrating a RESTful API with a cloud IdP</em> recipe, I used<a id="_idIndexMarker102"/> Azure Entra (formerly known as Azure Active Directory) as an authentication<a id="_idIndexMarker103"/> provider. You can create a free account with 200 USD credit <span class="No-Break">at </span><a href="https://azure.microsoft.com/free/search"><span class="No-Break">https://azure.microsoft.com/free/search</span></a><span class="No-Break">/</span><span class="No-Break">.</span></p>
			<p>All the recipes that will be demonstrated in this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter2</span></a></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor069"/>Setting up Spring Authorization Server</h1>
			<p>Spring Authorization Server<a id="_idIndexMarker104"/> is a project under the umbrella of Spring Framework that provides the components you need to create an Authorization Server. In this recipe, you will deploy a very simple Authorization Server that you will use for most of the recipes in this chapter. In the following recipes, you will continue to customize this server to achieve the goals of <span class="No-Break">each exercise.</span></p>
			<p>The configuration of this server is just for demo purposes. The Authorization Server plays a crucial role in managing and granting access to protected resources. If you plan to use it in production, I recommend<a id="_idIndexMarker105"/> following the instructions from the project at <a href="https://docs.spring.io/spring-authorization-server/reference/overview.html">https://docs.spring.io/spring-authorization-server/reference/overview.html</a>. In any case, the principles that we will explain in this book have been adjusted to the OAuth2 specification and well-known practices. For this reason, you will be able to apply what you learn here to any other <span class="No-Break">Authorization Server.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>Getting ready</h2>
			<p>To create the Spring Authorization Server, we will use Spring Initializr. You can open this tool in your browser using <a href="https://start.spring.io/">https://start.spring.io/</a> or use it in your code editor if it’s <span class="No-Break">been integrated.</span></p>
			<p>I assume that you have basic knowledge<a id="_idIndexMarker106"/> of OAuth2. However, I have added some links in the <em class="italic">See also</em> section that can be useful if you need to go through <span class="No-Break">some concepts.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>How to do it…</h2>
			<p>In this recipe, we will create a Spring Authorization Server using Spring Initializr and do a very basic configuration to create an application registration. Finally, we’ll test the application registration and analyze the results. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Open <a href="https://start.spring.io">https://start.spring.io</a>, as you did in the <em class="italic">Creating a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, and use the same parameters, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">footballauth</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">OAuth2 </strong><span class="No-Break"><strong class="bold">Authorization Server</strong></span><span class="No-Break">:</span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 2.1: Spring Initializr options for Spring Authorization Server" src="image/B21646_02_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: Spring Initializr options for Spring Authorization Server</p>
			<p class="list-inset">Click on the <strong class="bold">GENERATE</strong> button to download<a id="_idIndexMarker107"/> the project, then unzip the content to your <span class="No-Break">working folder.</span></p>
			<ol>
				<li value="2">Now, we need to configure the authorization server. For that, we will create an <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder with the <span class="No-Break">following content:</span><pre class="source-code">
server:
  port: 9000
spring:
  security:
    oauth2:
      authorizationserver:
        client:
          basic-client:
            registration:
              client-id: "football"
              client-secret: "{noop}SuperSecret"
              client-authentication-methods:
                - "client_secret_post"
              authorization-grant-types:
                - "client_credentials"
              scopes:
                - "football:read"</pre><p class="list-inset">We just defined an application that can be authenticated using the client <span class="No-Break">credential flow.</span></p></li>				<li>Now, you can execute<a id="_idIndexMarker108"/> your Authorization Server. You can retrieve the configuration of our server by making a request to http://localhost:9000/.well-known/openid-configuration. As the path indicates, this is a well-known endpoint that all OAuth2-compliant vendors implement to expose the relevant configuration for client applications. Most of the client libraries can configure themselves just from <span class="No-Break">this endpoint.</span></li>
				<li>To verify that it works, we can execute the authentication of our client. You can do this by executing the following <strong class="source-inline">POST</strong> request <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break">:</span><pre class="source-code">
curl --location 'http://localhost:9000/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=client_credentials' \
--data-urlencode 'client_id=football' \
--data-urlencode 'client_secret=SuperSecret' \
--data-urlencode 'scope=football:read'</pre><p class="list-inset">You should see a response that looks similar <span class="No-Break">to this:</span></p><pre class="source-code">{"access_token":"eyJraWQiOiIyMWZkYzEyMy05NTZmLTQ5YWQtODU2 Zi1mNjAxNzc4NzAwMmQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJiYXNp Yy1jbGllbnQiLCJhdWQiOiJiYXNpYy1jbGllbnQiL CJuYmYiOjE2OTk1NzIwNjcsInNjb3BlIjpbInByb2ZpbGUiXSwiaXNzIj oiaHR0cDovL2xvY2FsaG9zdDo5MDAwIiwiZXhwIjoxNjk5NTcyMzY3LCJ pYXQiOjE2OTk1NzIwNjd9.TavlnbirP_4zGH8WaJHrcCrNs5ZCnStqqiX Kc6pakfvQPviosGdgo9vunq4ogRZWYNjXOS5GYw0XlubSj0UDznnxSLyx 7tR7cEZJSQVHc6kffuozycJ_xl5yzw6_Kv_pJ4fP00b7pbHWO8ciZKUhmW -Pvt5TV8sMFY-uNzgsCtiN5EYdplMUfZdwHMy8yon3bUah8Py7RoAw1bIE ioGUEiK5XLDaE4yGdo8RyyBv4wj3mw6Bs8dcLspLKWXG5spXlZes6XCaSu 0ZXtLE09AgA_Gmq0kwmhWXgnpGKuCkhkXASyJXboQD9TR0y3yTn_aNeiuV MPzX4DQ7IaCKzgmaYg","scope":"profile","token_type":"Bearer","expires_in":299}</pre></li>				<li>Now, you can copy<a id="_idIndexMarker109"/> the value of the <strong class="source-inline">access_token</strong> field, open <a href="https://jwt.ms">https://jwt.ms</a> in your browser, and paste the value there. In the <strong class="bold">Decoded Token</strong> tab, you can see the token in its decoded form, while if you click on the <strong class="bold">Claims</strong> tab, you can see an explanation of <span class="No-Break">each field:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer013">
					<img alt="Figure 2.2: JWT token decoded in jwt.ms" src="image/B21646_02_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: JWT token decoded in jwt.ms</p>
			<ol>
				<li value="6">Congratulations – you’ve deployed a Spring Authorization Server and successfully configured an application <span class="No-Break">for authorization.</span></li>
			</ol>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor072"/>How it works…</h2>
			<p>Spring OAuth2 Authorization Server<a id="_idIndexMarker110"/> contains all the components you need to create an authorization server. With the configuration provided in <strong class="source-inline">application.yml</strong>, it created an application with a <strong class="source-inline">client-id</strong> value of <strong class="source-inline">basic-client</strong>. Let’s look at the parameters that were used for the application and see how <span class="No-Break">they work:</span></p>
			<ul>
				<li>The <strong class="source-inline">client-id</strong> is the identifier of the application we create d. In this case, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">client-secret</strong> is the secret of the application. By using the <strong class="source-inline">{noop}</strong> prefix in the secret, we tell Spring Security that the password is not encrypted and can be <span class="No-Break">used as-is.</span></li>
				<li>The <strong class="source-inline">client-authentication-methods</strong> is used to specify how this application can authenticate. By using the <strong class="source-inline">client_secret_post</strong> method, we can ensure that the client ID and secret will be sent in a <strong class="source-inline">POST</strong> request. We could configure additional methods, such as <strong class="source-inline">client_secret_basic</strong>, in which case the client ID and secret will be sent as HTTP basic schema – that is, in <span class="No-Break">the URL.</span></li>
				<li>With the <strong class="source-inline">authorization-grant-types</strong>, we specify what grant flows are allowed for this application. By setting <strong class="source-inline">client_credentials</strong>, we are configuring an application that won’t have a user interface, such as a background server application. If you have an application that will interact with users, you could configure other options, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">authorization_code</strong></span><span class="No-Break">.</span></li>
				<li>Finally, with the <strong class="source-inline">scopes</strong>, we are configuring the scopes that are allowed for this application. In this case, it is just the <span class="No-Break"><strong class="source-inline">football:read</strong></span><span class="No-Break"> scope.</span></li>
			</ul>
			<p>Spring OAuth2 Authorization Server<a id="_idIndexMarker111"/> keeps this configuration in memory. As you may have guessed, this is just for demonstration and development purposes. In a production environment, you will need to persist this data. Spring OAuth2 Authorization Server provides support for <span class="No-Break">JPA repositories.</span></p>
			<p>We used <strong class="bold">JWT MS</strong> (<a href="https://jwt.ms">https://jwt.ms</a>) to inspect the access<a id="_idIndexMarker112"/> token that was issued by our authorization server. This tool just decodes the token and describes the standard fields. There<a id="_idIndexMarker113"/> is another popular tool named <strong class="bold">JWT IO</strong> (<a href="https://jwt.io">https://jwt.io</a>) that also allows you to validate the token, but it doesn’t explain <span class="No-Break">each field.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor073"/>There’s more…</h2>
			<p>You can follow the instructions from the Spring OAuth2 Authorization Server project to implement the core services with <span class="No-Break">JPA: </span><a href="https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html"><span class="No-Break">https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-jpa.html</span></a><span class="No-Break">.</span></p>
			<p>You can use any relational database supported by Spring Data JPA, such as PostgreSQL, which we used in <a href="B21646_05.xhtml#_idTextAnchor203"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor074"/>See also</h2>
			<p>In this chapter, we’ll manage many OAuth2 concepts, something that can be difficult to understand if you don’t have <span class="No-Break">previous knowledge.</span></p>
			<p>For instance, it is very important to understand the different <span class="No-Break">token types:</span></p>
			<ul>
				<li><strong class="source-inline">access_token</strong>: This contains all authorization information granted by the authorization server that the resource server <span class="No-Break">will verify.</span></li>
				<li><strong class="source-inline">id_token</strong>: This token is used for session management, normally in client applications, to customize the user interface, <span class="No-Break">for example.</span></li>
				<li><strong class="source-inline">refresh_token</strong>: This token is used to get new <strong class="source-inline">access_tokens</strong> and <strong class="source-inline">id_tokens</strong> when they are about to expire. <strong class="source-inline">refresh_token</strong> is considered a secret as its lifetime is larger than the others and can be used not only to get fresher tokens for the already authorized applications but also for new ones. It is important to protect this <span class="No-Break">token accordingly.</span></li>
			</ul>
			<p>I strongly recommend getting familiar with the basic OAuth2 flows and their <span class="No-Break">main purposes:</span></p>
			<ul>
				<li><strong class="bold">Client </strong><span class="No-Break"><strong class="bold">credential flow</strong></span><span class="No-Break">:</span><p class="list-inset">This is the simplest flow<a id="_idIndexMarker114"/> and was used in this recipe. It is intended for applications without user interaction – for instance, for server applications communicating with other applications. They can be authenticated in different ways, such as with a secret, as seen in this recipe, a certificate, or other more <span class="No-Break">sophisticated techniques.</span></p></li>
				<li><strong class="bold">Authorization code </strong><span class="No-Break"><strong class="bold">grant flow</strong></span><span class="No-Break">:</span><p class="list-inset">This is intended to authenticate<a id="_idIndexMarker115"/> web and mobile applications. This is the two-leg authentication flow, where the user authenticates and allows the application to access the requested scopes. Then, the authentication endpoint issues a short-lived piece of code that should be redeemed in the token endpoint to get an access token. After, the application (not the user) should be authenticated. There are two variants of this flow, depending on how <span class="No-Break">it authenticates:</span></p><ul><li>Using a client ID and a secret. This is intended for confidential applications, such as those that can keep secrets. This includes <span class="No-Break">server applications.</span></li><li>Using a client ID<a id="_idIndexMarker116"/> and a challenge, also known as <strong class="bold">Proof Key Challenge Exchange</strong> (<strong class="bold">PKCE</strong>). This is intended for public applications, such as those that cannot keep a secret, such as mobile applications, or applications<a id="_idIndexMarker117"/> that just live in the browser, such as <strong class="bold">single-page </strong><span class="No-Break"><strong class="bold">applications</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SPAs</strong></span><span class="No-Break">).</span></li></ul></li>
				<li><strong class="bold">Refresh </strong><span class="No-Break"><strong class="bold">token flow</strong></span><span class="No-Break">:</span><p class="list-inset">As its name suggests, it is used<a id="_idIndexMarker118"/> to refresh access and ID tokens when they are about to expire. For that, it <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">refresh_token</strong></span><span class="No-Break">.</span></p></li>
			</ul>
			<p>There are more flows, but these are the basic ones that will be used in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor075"/>Protecting a RESTful API using OAuth2</h1>
			<p>Protecting a resource – in this case, a RESTful<a id="_idIndexMarker119"/> API – is the core functionality<a id="_idIndexMarker120"/> of OAuth. In OAuth2, a resource server delegates authorization to access a third-party server – that is, the authorization server. In this recipe, you’ll learn how to configure a RESTful API application so that it can authorize the requests that are issued by your Spring <span class="No-Break">Authorization Server.</span></p>
			<p>We will continue with our samples for football data management. You will protect your Football API by only allowing clients who have been granted access by our <span class="No-Break">Authorization Server.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor076"/>Getting ready</h2>
			<p>In this recipe, you will reuse<a id="_idIndexMarker121"/> the Authorization<a id="_idIndexMarker122"/> Server you created in the <em class="italic">Setting up Spring Authorization Server</em> recipe. If you haven’t completed that yet, you can use the authorization server that I’ve prepared. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor077"/>How to do it…</h2>
			<p>In this recipe, you will create a new RESTful API and configure it as a <em class="italic">resource server</em> using the client registration you created in the previous recipe. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>First, create a RESTful API using Spring Initializr (<a href="https://start.spring.io">https://start.spring.io</a>). Use the same options that you did in the <em class="italic">Creating a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">footballresource</strong></span><span class="No-Break">.</span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong> and <strong class="bold">Oauth2 </strong><span class="No-Break"><strong class="bold">Resource Server</strong></span><span class="No-Break">:</span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 2.3: Spring Initializr options for a protected RESTful API" src="image/B21646_02_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: Spring Initializr options for a protected RESTful API</p>
			<p class="list-inset">Click <strong class="bold">GENERATE</strong> to download a ZIP file that contains your project template. Unzip it in your working folder and open it in your <span class="No-Break">code editor.</span></p>
			<ol>
				<li value="2">We can create a simple REST<a id="_idIndexMarker123"/> controller with a method<a id="_idIndexMarker124"/> that returns a list of teams. For that, create a class named <strong class="source-inline">Football.java</strong> with the <span class="No-Break">following content:</span><pre class="source-code">
@RequestMapping("/football")
@RestController
public class FootballController {
    @GetMapping("/teams")
    public List&lt;String&gt; getTeams() {
        return List.of("Argentina", "Australia",
                       "Brazil");
    }
}</pre><p class="list-inset">Now, let’s configure our application<a id="_idIndexMarker125"/> for authorization by using<a id="_idIndexMarker126"/> the Authorization Server we created in the previous recipe. For that, create an <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder with the <span class="No-Break">following content:</span></p><pre class="source-code">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          <strong class="bold">audiences:</strong>
<strong class="bold">          - football</strong>
<strong class="bold">          issuer-uri: http://localhost:9000</strong></pre><p class="list-inset">You can now execute the application. If you try to invoke the RESTful API using <strong class="source-inline">curl</strong>, this is what you’ll have <span class="No-Break">to do:</span></p><pre class="source-code">curl http://localhost:8080/football/teams</pre><p class="list-inset">You will receive an <strong class="source-inline">HTTP Error 401 </strong><span class="No-Break"><strong class="source-inline">Unauthorized</strong></span><span class="No-Break"> error.</span></p></li>				<li>We need to get an access token from our Authorization Server first. For that, you can execute the following request <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break">:</span><pre class="source-code">
curl --location 'http://localhost:9000/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=client_credentials' \
--data-urlencode 'client_id=football' \
--data-urlencode 'client_secret=SuperSecret' \
--data-urlencode 'scope=football:read'</pre><p class="list-inset">The response will look <span class="No-Break">like this:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 2.4: Access token issued by the Authorization Server" src="image/B21646_02_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: Access token issued by the Authorization Server</p>
			<ol>
				<li value="4">Copy the access token<a id="_idIndexMarker127"/> value and use it in the <span class="No-Break">next</span><span class="No-Break"><a id="_idIndexMarker128"/></span><span class="No-Break"> request:</span><pre class="source-code">
curl -H "Authorization: Bearer <strong class="bold">&lt;access_token&gt;</strong>" http://localhost:8080/football/teams</pre><p class="list-inset">In the preceding request, replace <strong class="source-inline">&lt;access_token&gt;</strong> with the value of the access token you obtained in the previous request, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p><p class="list-inset">Now, the resource server will return the expected result, along with a list <span class="No-Break">of teams.</span></p></li>				<li>You now have our RESTful API that’s protected by the tokens that were issued by the <span class="No-Break">authorization server.</span></li>
			</ol>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor078"/>How it works…</h2>
			<p>In this simplified<a id="_idIndexMarker129"/> example, you saw how authorization<a id="_idIndexMarker130"/> works in OAuth2. There’s an authorization server issuing a token with authorization information. A resource server – our RESTful API – then checks the token’s validity and applies the provided configuration. The authorization server can issue the token<a id="_idIndexMarker131"/> in different formats, but the most common is via <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWT</strong>). A JWT consists of three parts: a header, a payload, and a signature. These parts are encoded in base64 and are separated by period (<strong class="source-inline">.</strong>) <span class="No-Break">signs:</span></p>
			<ul>
				<li>The header contains the metadata needed to manage the token. It is encoded <span class="No-Break">in base64.</span></li>
				<li>The payload contains the actual data and claims about the token. It carries information such as the expiration time, issuer, and custom claims. It is encoded <span class="No-Break">in base64.</span></li>
				<li>The signature is created by taking the encoded header and encoded payload, along with a secret, and signing them using the signing algorithm specified in the header. The signature is used to verify the <em class="italic">authenticity</em> and <em class="italic">integrity</em> of the token so that we can ensure the token was issued by the authorization server and was not modified by <span class="No-Break">anyone else.</span></li>
			</ul>
			<p>The resource needs to validate the authenticity and integrity of the token. For that, it needs to verify the signature. The Authorization Server provides an endpoint to download the public key of the certificate being used to sign the token. So, the first thing that the authorization server needs to know is where that endpoint is. We can configure this manually in the <strong class="source-inline">application.yml</strong> file, but luckily, Spring Resource Server knows how to retrieve all the information about the authorization server automatically. Just by configuring the <strong class="source-inline">issuer-uri</strong> property, it knows how to retrieve the rest of <span class="No-Break">the information.</span></p>
			<p>Almost all authorization servers in the market can provide the well-known <strong class="source-inline">OpenId</strong> endpoint if we add the following path to the issuer URI: <strong class="source-inline">.well-known/openid-configuration</strong>. The first time the resource server needs to validate a JWT, it calls that endpoint – in our case, http://localhost:9000/.well-known/openid-configuration – and retrieves all the information it needs, such as the authorization and token endpoint, the <strong class="bold">JSON Web Key Set</strong> (<strong class="bold">JWKS</strong>) endpoint, which contains the sign-in<a id="_idIndexMarker132"/> key, and so on. JWKSs are the public keys that the authorization server can use to sign a token. The clients can download these keys to validate the signature of <span class="No-Break">the JWT.</span></p>
			<p>Now that we know how the resource<a id="_idIndexMarker133"/> server validates that the token has been issued<a id="_idIndexMarker134"/> by the authorization server, we need to know how we can validate that the token is intended for our RESTful APIs. In the <strong class="source-inline">application.yml</strong> file, we’ve configured the <strong class="source-inline">audiences</strong> field. This indicates the entity for which the token is valid and who or what the token is intended for. The <strong class="source-inline">aud</strong> claim helps ensure that a JWT is only accepted by the intended recipient or resource server. The <strong class="source-inline">aud</strong> claim is part of the payload of the JWT. In our case, the payload, after decoding the base64, looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
  "sub": "football",
  <strong class="bold">"aud": "football",</strong>
  "nbf": 1699671850,
  "scope": [
    "football:read"
  ],
  "iss": "http://localhost:9000",
  "exp": 1699672150,
  "iat": 1699671850
}</pre>			<p>Just by setting <strong class="source-inline">issuer-uri</strong> and <strong class="source-inline">audiences</strong>, we ensure that only JWT issued by our Authorization Server and those that are intended for our application/audience will be accepted. Spring Resource Server performs other standard checks, such as for the expiration time (the <strong class="source-inline">exp</strong> claim) and not valid before (the <strong class="source-inline">nbf</strong> claim). Anything else will be rejected with an <strong class="source-inline">HTTP 401 Unauthorized</strong> error. In the <em class="italic">Protecting a RESTful API using OAuth2 with different scopes</em> recipe, we’ll learn how to use other claims to <span class="No-Break">enhance protection.</span></p>
			<p>It is important to note that from a Spring Resource Server perspective, it’s not important how the client obtained the access token as that responsibility is delegated to the Authorization Server. The Authorization Server may require different levels of validations, depending on the kind <a id="_idIndexMarker135"/>of resource being accessed. Some examples<a id="_idIndexMarker136"/> of validations are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Client ID and secret, as shown in <span class="No-Break">this example.</span></li>
				<li>Multiple factors of authentication. For applications with user interaction, the authorization server may consider that the username and password are not enough and force using a second factor of authentication, such as an authentication application, a certificate, and <span class="No-Break">so on.</span></li>
				<li>If an application tries to access specific scopes, it may require explicit consent. We see this often with social networks when a third-party application needs to access certain parts of our profile or tries to perform special actions<a id="_idTextAnchor079"/>, such as publishing on <span class="No-Break">our behalf.</span></li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor080"/>Protecting a RESTful API using OAuth2 with different scopes</h1>
			<p>In the previous recipe, we learned<a id="_idIndexMarker137"/> how to protect<a id="_idIndexMarker138"/> our application. In this recipe, we’ll learn how to apply more fine-grained security. We need to apply different levels of access to the application: one general form of read access for the consumers of our RESTful API and administrative access so that we can make changes to <span class="No-Break">the data.</span></p>
			<p>To apply different levels of access to the API, we’ll use the standard OAuth2 concept of <em class="italic">scopes</em>. In OAuth 2.0, <strong class="source-inline">scope</strong> is a parameter that’s used to specify the level of access and permissions that a client application is requesting from the user and the authorization server. It defines what actions or resources the client application is allowed to perform on behalf of the user. Scopes help ensure that users have control over which parts of their data and resources they grant access to, and they allow for fine-grained access control. In applications with user interaction, granting a scope may imply explicit consent from the user. For applications with no user interaction, it can be configured with <span class="No-Break">administrative consent.</span></p>
			<p>In our football application, you will create two access levels: one for read-only access and another for <span class="No-Break">administrative access.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/>Getting ready</h2>
			<p>In this recipe, we’ll reuse<a id="_idIndexMarker139"/> the Authentication Server<a id="_idIndexMarker140"/> from the <em class="italic">Setting up Spring Authorization Server</em> recipe and the resource server we created in the <em class="italic">Protecting a RESTful API using OAuth2</em> recipe. If you haven’t completed these recipes yet, you can find a working version in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-3/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor082"/>How to do it…</h2>
			<p>Let’s create the <strong class="source-inline">football:read</strong> and <strong class="source-inline">football:admin</strong> scopes in the Authorization Server and apply the configuration for managing them in the <span class="No-Break">resource server:</span></p>
			<ol>
				<li>The first thing you should do is ensure that the scopes are defined in the authorization server. For that, go to the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder of the project you created in the <em class="italic">Setting up Spring Authorization Server</em> recipe. If you’re using the implementation I provided, as explained in the <em class="italic">Getting ready</em> section of that recipe, you can find the project in the <strong class="source-inline">footballauth</strong> folder. Ensure that the application mentions the <strong class="source-inline">football:read</strong> and <strong class="source-inline">football:admin</strong> scopes. The application configuration in the <strong class="source-inline">application.yml</strong> file should look <span class="No-Break">like this:</span><pre class="source-code">
spring:
  security:
    oauth2:
      authorizationserver:
        client:
          football:
            registration:
              client-id: "football"
              client-secret: "{noop}SuperSecret"
              client-authentication-methods:
                - "client_secret_post"
              authorization-grant-types:
                - "client_credentials"
              <strong class="bold">scopes:</strong>
<strong class="bold">                - "football:read"</strong>
<strong class="bold">                - "football:admin</strong></pre></li>				<li>Let’s create an action<a id="_idIndexMarker141"/> that requires administrative<a id="_idIndexMarker142"/> access to the RESTful API. For instance, you can create a method to create a team. For that, in the <strong class="source-inline">FootballController</strong> controller class, create a method named <strong class="source-inline">addTeam</strong> that’s mapped to a <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> action:</span><pre class="source-code">
@PostMapping("/teams")
public String addTeam(@RequestBody String teamName){
  return teamName + " added";
}</pre><p class="list-inset">You can do a more complex implementation, but for this exercise, we can keep this <span class="No-Break">emulated implementation.</span></p></li>				<li>Now, configure the resource server so that it can manage the scopes. For that, create a configuration class that exposes a <span class="No-Break"><strong class="source-inline">SecurityFilterChain</strong></span><span class="No-Break"> bean:</span><pre class="source-code">
<strong class="bold">@Configuration</strong>
public class SecurityConfig {
    <strong class="bold">@Bean</strong>
    public <strong class="bold">SecurityFilterChain</strong>
    filterChain(HttpSecurity http) throws Exception {
        return http.authorizeHttpRequests(authorize -&gt;
            <strong class="bold">authorize.requ<a id="_idTextAnchor083"/>estMatchers(HttpMethod.GET,</strong>
<strong class="bold">            "/football/teams/**").hasAuthority(</strong>
<strong class="bold">            "SCOPE_football:read").requestMatchers(</strong>
<strong class="bold">            HttpMethod.POST, "/football/teams/**")</strong>
<strong class="bold">            .hasAuthority("SCOPE_football:admin")</strong>
            .anyRequest().authenticated())
            .oauth2ResourceServer(oauth2 -&gt;
            oauth2.jwt(Customizer.withDefaults()))
            .build();
    }
}</pre><p class="list-inset">Note that as part of <strong class="source-inline">SecurityFilterChain</strong>, we defined a couple of <strong class="source-inline">requestMatchers</strong> with <strong class="source-inline">HttpMethod</strong>, the request path, and the required authority using <span class="No-Break">both scopes.</span></p></li>				<li>Now that we have<a id="_idIndexMarker143"/> the required<a id="_idIndexMarker144"/> configuration, let’s run the application and perform some tests to validate <span class="No-Break">its behavior:</span><ol><li class="upper-roman">First, get an access token from the authorization server, requesting just the <strong class="source-inline">football:read</strong> scope. You can execute the request by running the following <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> command:</span></li></ol><pre class="source-code">
curl --location 'http://localhost:9000/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=client_credentials' \
--data-urlencode 'client_id=football' \
--data-urlencode 'client_secret=SuperSecret' \
--data-urlencode '<strong class="bold">scope=football:read</strong>'</pre><ol><li class="upper-roman" value="2">Take the access token<a id="_idIndexMarker145"/> that was returned<a id="_idIndexMarker146"/> and use it in the authorization header of the <span class="No-Break">following request:</span></li></ol><pre class="source-code">curl -H "Authorization: Bearer &lt;access_token&gt;" http://localhost:8080/football/teams</pre><p class="list-inset">It should return the data normally and the HTTP response code should <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">200</strong></span><span class="No-Break">.</span></p><p class="list-inset">However, let’s say you try to perform the POST request to create <span class="No-Break">a team:</span></p><pre class="source-code">curl -H "Authorization: Bearer &lt;access_token&gt;" -H "Content-Type: application/text" <strong class="bold">--request POST</strong> --data 'Senegal' http://localhost:8080/football/teams -v</pre></li>			</ol>
			<p class="callout-heading">A note on curl</p>
			<p class="callout">Note that we’re starting to use the <strong class="source-inline">-v</strong> parameter. It provides a verbose response so that we can see the reasons <span class="No-Break">something fails.</span></p>
			<p class="list-inset">It will return an HTTP 403 forbidden error, and the details will look <span class="No-Break">as this:</span></p>
			<pre class="source-code">
WWW-Authenticate: Bearer error="insufficient_scope", error_description="The request requires higher privileges than provided by the access token.", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"</pre>			<ol>
				<li class="upper-roman" value="3">Now, let’s retrieve another access token with the <span class="No-Break">appropriate scopes:</span></li>
			</ol>
			<pre class="source-code">
curl --location 'http://localhost:9000/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=client_credentials' \
--data-urlencode 'client_id=football' \
--data-urlencode 'client_secret=SuperSecret' \
--data-urlencode '<strong class="bold">scope=football:read football:admin</strong>'</pre>			<p class="list-inset">Note that we can request more than one scope at <span class="No-Break">a time.</span></p>
			<p class="list-inset">If we execute the request to create a team with the new access token, we’ll see that it works as expected and will return something like <span class="No-Break"><strong class="source-inline">Senegal added</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">With that, our application is protected and we’ve applied different levels of protection to our <span class="No-Break">resource server.</span></li>
			</ol>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor084"/>How it works…</h2>
			<p>The <strong class="source-inline">SecurityFilterChain</strong> bean is a component<a id="_idIndexMarker147"/> that’s used for configuring<a id="_idIndexMarker148"/> the security filters that intercept and process incoming HTTP requests. Here, we created a <strong class="source-inline">SecurityFilterChain</strong> bean that looks for two matching patterns: <strong class="source-inline">GET</strong> requests that match the <strong class="source-inline">/football/teams/**</strong> path pattern and <strong class="source-inline">POST</strong> requests that match the same path pattern. <strong class="source-inline">GET</strong> requests should have the <strong class="source-inline">SCOPE_football:read</strong> authority and <strong class="source-inline">POST</strong> should have the <strong class="source-inline">SCOPE_football:admin</strong> authority. Once you configure <strong class="source-inline">SecurityFilterChain</strong>, it is applied to all incoming HTTP requests. Then, if a request matching the pattern doesn’t have the required scope, it will raise an <strong class="source-inline">HTTP 403 </strong><span class="No-Break"><strong class="source-inline">forbidden</strong></span><span class="No-Break"> response.</span></p>
			<p>Why is <strong class="source-inline">SCOPE_ prefix</strong> used? It is created by the default <strong class="source-inline">JwtAuthenticationConverter</strong>. This component transforms the JWT into an <strong class="source-inline">Authentication</strong> object. The default <strong class="source-inline">JwtAuthenticationConverter</strong> is wired by Spring Security, but you<a id="_idIndexMarker149"/> can also register your own converter<a id="_idIndexMarker150"/> if you want a <span class="No-Break">different behavior.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor085"/>There’s more…</h2>
			<p>More validations can be performed<a id="_idIndexMarker151"/> on JWT. For instance, a common way of validating a request is by checking <span class="No-Break">its roles.</span></p>
			<p>You can validate a request’s roles by registering a <strong class="source-inline">SecurityFilterChain</strong> bean. Let’s say you have an administrator role defined in your Authorization Server. Here, you can configure a <strong class="source-inline">SecurityFilterChain</strong> bean in the resource server to ensure that only users with the <strong class="source-inline">ADMIN</strong> role can perform <strong class="source-inline">POST</strong> requests on <strong class="source-inline">football/teams path</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@Bean
public SecurityFilterChain filterChainRoles(HttpSecurity
http) throws Exception {
    return http.authorizeHttpRequests(authorize -&gt;
    authorize.requestMatchers(HttpMethod.POST,
    "football/teams/**")<strong class="bold">.hasRole("ADMIN")</strong>
    .anyRequest().authenticated())
    .oauth2ResourceServer(oauth2 -&gt;
    oauth2.jwt(Customizer.withDefaults()))
    .build();
}</pre>			<p>You can make other checks to validate your token. In this case, you can use <strong class="source-inline">OAuth2TokenValidator</strong>. For instance, you may want to validate that a given claim is present in your JWT. For that, you can create a class that <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">OAuth2TokenValidator</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
class CustomClaimValidator implements
OAuth2TokenValidator&lt;Jwt&gt; {
    OAuth2Error error = new OAuth2Error("custom_code",
    "This feature is only for special football fans",
    null);
    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        <strong class="bold">if (jwt.getClaims().containsKey("specialFan"))</strong>{
            return OAuth2TokenValidatorResult.success();
        }
        else{
            return
                OAuth2TokenValidatorResult.failure(error);
        }
    }
}</pre>			<h2 id="_idParaDest-81"><a id="_idTextAnchor086"/>See also</h2>
			<p>I recommend that you look<a id="_idIndexMarker152"/> at the Spring OAuth2 Resource Server project documentation at <a href="https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html">https://docs.spring.io/spring-security/reference/servle<span id="_idTextAnchor087"/>t/oauth2/resource-server/jwt.html</a> for <span class="No-Break">more details.</span></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor088"/>Configuring an MVC application with OpenID authentication</h1>
			<p>We want to create a new web<a id="_idIndexMarker153"/> application for our football<a id="_idIndexMarker154"/> fans. To do so, we must authenticate the users when they’re accessing the application. We’ll use access tokens to access the protected <span class="No-Break">RESTful API.</span></p>
			<p>In this recipe, we’ll learn how to use Spring OAuth2 Client to protect an MVC web application and get access tokens for other <span class="No-Break">protected resources.</span></p>
			<p>If you plan to use an SPA, you will need to look for OpenID-certified libraries for your <span class="No-Break">target environment.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor089"/>Getting ready</h2>
			<p>For this recipe, you will reuse the Authorization Server application you created in the <em class="italic">Setting up Spring Authorization Server</em> recipe and the application you created in the <em class="italic">Protecting a RESTful API using OAuth2 with different scopes</em> recipe. I’ve prepared a working version of both projects in case you haven’t completed them yet. You can find them in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>The authentication process involves some redirections and requires managing sessions for the protected application. We’ll use Redis to maintain the sessions for the application. You can download Redis and execute it on your computer, but as we did for other recipes, you can deploy Redis on Docker. For that, just execute the following command in <span class="No-Break">your terminal:</span></p>
			<pre class="console">
docker run --name spring-cache -p 6379:6379 -d redis</pre>			<p>This command will download the Redis community image if it is not yet present on your computer and will start the Redis server so that it’s listening on port <strong class="source-inline">6379</strong> without any credentials. In a production environment, you probably want to secure this service, but in this recipe, we’ll keep it open <span class="No-Break">for simplicity.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor090"/>How to do it…</h2>
			<p>In this recipe, you’ll create<a id="_idIndexMarker155"/> a new web application<a id="_idIndexMarker156"/> and integrate it with the existing authorization server and the RESTful API you created in previous recipes. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>First, you’ll need to create the client registration in the Authorization Server. For that, open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder of the Authorization Server – that is, the project you created in the <em class="italic">Setting up Spring Authorization Server</em> recipe. Add the new client registration, <span class="No-Break">as follows:</span><pre class="source-code">
spring:
  security:
    oauth2:
      authorizationserver:
        client:
          football-ui:
            registration:
              client-id: "football-ui"
              client-secret: "{noop}TheSecretSauce"
              client-authentication-methods:
                - "client_secret_basic"
              authorization-grant-types:
                - "authorization_code"
                - "refresh_token"
                - "client_credentials"
              redirect-uris:
                - "http://localhost:9080/login/oauth2/code/football-ui"
              scopes:
                - "openid"
                - "profile"
                - "football:read"
                - "football:admin"
            require-authorization-consent: true</pre></li>				<li>As we want to authenticate <a id="_idIndexMarker157"/>users, you will need<a id="_idIndexMarker158"/> to create at least one user. To do that, in the same <strong class="source-inline">application.yml</strong> file in the Authorization Server, add the <span class="No-Break">following configuration:</span><pre class="source-code">
User:
    name: "user"
    password: "password"</pre><p class="list-inset">The <strong class="source-inline">user</strong> element should be aligned with the <strong class="source-inline">oauth2</strong> element. Remember that the indentation in <strong class="source-inline">.yml</strong> files is very important. You can change the username and password and set the values <span class="No-Break">you wish.</span></p><p class="list-inset">Keep this configuration as you’ll use it later in the <span class="No-Break">web application.</span></p></li>				<li>Now, let’s create<a id="_idIndexMarker159"/> a new Spring Boot application<a id="_idIndexMarker160"/> for our web application. You can use <em class="italic">Spring Initializr</em>, as you did in the <em class="italic">Creating a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, but change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">footballui</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong>, <strong class="bold">Thymeleaf</strong>, <strong class="bold">Spring Session</strong>, <strong class="bold">Spring Data Redis (Access+Driver)</strong>, <strong class="bold">OAuth2 Client</strong>, and <span class="No-Break"><strong class="bold">OAuth2 Security</strong></span><span class="No-Break">:</span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 2.5: Spring Initializr options for the web application" src="image/B21646_02_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Spring Initializr options for the web application</p>
			<p class="list-inset">Click <strong class="bold">GENERATE</strong> to download<a id="_idIndexMarker161"/> the project template<a id="_idIndexMarker162"/> as a ZIP file. Unzip the file in your development folder and open it in your preferred <span class="No-Break">code editor.</span></p>
			<ol>
				<li value="4">There is a known incompatibility between <strong class="bold">Thymeleaf</strong> and <strong class="bold">Spring Security</strong>. To integrate both components, it is necessary to add an additional dependency to <strong class="source-inline">org.thymeleaf.extras: thymeleaf-extras-springsecurity6</strong>. For that, open the project’s <strong class="source-inline">pom.xml</strong> file and add the <span class="No-Break">following dependency:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-extras-springsecurity6
        &lt;/artifactId&gt;
    &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</pre></li>				<li>Let’s start by creating<a id="_idIndexMarker163"/> our web pages. Since we’re following the <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) approach, we’ll need to create the <strong class="source-inline">Controller</strong> class, which will populate a model and then be presented in the view. The view is rendered using the Thymeleaf <span class="No-Break">template engine:</span><ol><li class="upper-roman">First, create the <strong class="source-inline">Controller</strong> class<a id="_idIndexMarker164"/> and name<a id="_idIndexMarker165"/> it <strong class="source-inline">FootballController</strong> while providing a simple method for the <span class="No-Break">home page:</span></li></ol><pre class="source-code">
@Controller
public class FootballController {
    @GetMapping("/")
    public String home() {
        return "home";
    }
}</pre><ol><li class="upper-roman" value="2">This method returns the name of the view. Now, we need to create <span class="No-Break">the view.</span></li><li class="upper-roman">For the view, we should create a new template for Thymeleaf. The default template location is the <strong class="source-inline">resources/template</strong> folder. In the same folder, create a file named <strong class="source-inline">home.html</strong> with the <span class="No-Break">following content:</span></li></ol><pre class="source-code">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;The great football app&lt;/title&gt;
    &lt;meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;Let's see <strong class="bold">&lt;a href="/myself"&gt;</strong> who you are &lt;/a&gt;.
    You will need to login first!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p class="list-inset">This is a very basic page, but it now contains a link that we want <span class="No-Break">to protect.</span></p></li>				<li>Now, we must configure<a id="_idIndexMarker166"/> the application so that it can be authenticated<a id="_idIndexMarker167"/> using the Authorization Server and force it to be authenticated for all pages except for the home page we <span class="No-Break">just created:</span><ol><li class="upper-roman">To integrate the web application with the Authorization Server, open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and configure the OAuth2 client application, <span class="No-Break">as follows:</span></li></ol><pre class="source-code">
spring:
  security:
    oauth2:
      client:
        registration:
          football-ui:
            <strong class="bold">client-id: "football-ui"</strong>
<strong class="bold">            client-secret: "TheSecretSauce"</strong>
            redirect-uri:
              "{baseUrl}/login/oauth2/code/
              {registrationId}"
            authorization-grant-type:
              authorization_code
            scope:
              openid,profile,football:read,
              football:admin
        provider:
          <strong class="bold">football-ui:</strong>
<strong class="bold">            </strong><strong class="bold">issuer-uri: http://localhost:9000</strong></pre><ol><li class="upper-roman" value="2">You’ll need the parameters that you defined in the <span class="No-Break">Authorization Server.</span></li><li class="upper-roman">Now, configure the application<a id="_idIndexMarker168"/> so that it protects<a id="_idIndexMarker169"/> all pages except the home page and uses the OAuth2 login credentials. For that, create a new configuration class named <strong class="source-inline">SecurityConfiguration</strong> and create a <span class="No-Break"><strong class="source-inline">SecurityFilterChain</strong></span><span class="No-Break"> bean:</span></li></ol><pre class="source-code"><strong class="bold">@Configuration</strong>
<strong class="bold">@EnableWebSecurity</strong>
public class SecurityConfiguration {
    @Bean
    public <strong class="bold">SecurityFilterChain</strong>
    defaultSecurityFilterChain(HttpSecurity http)
    throws Exception {
        http.authorizeHttpRequests(
            (authorize) -&gt; authorize
            <strong class="bold">.requestMatchers("/").permitAll()</strong>
            <strong class="bold">.anyRequest().authenticated()</strong>)
            .<strong class="bold">oauth2Login</strong>(Customizer.withDefaults());
        return http.build();
    }
}</pre><p class="list-inset">With this configuration, you’ve protected all pages, except the root. So, let’s create the rest of <span class="No-Break">the pages.</span></p></li>				<li>Next, we need to create<a id="_idIndexMarker170"/> a page to show the user<a id="_idIndexMarker171"/> information. To do that, in the same <strong class="source-inline">FootballController</strong> controller, create a new method, <span class="No-Break">as follows:</span><pre class="source-code">
@GetMapping("/myself")
public String user(Model model,
<strong class="bold">@AuthenticationPrincipal OidcUser</strong> oidcUser) {
    model.addAttribute("userName",
        oidcUser.getName());
    model.addAttribute("audience",
        oidcUser.getAudience());
    model.addAttribute("expiresAt",
        oidcUser.getExpiresAt());
    model.addAttribute("claims",
        oidcUser.getClaims());
    return "myself";
}</pre><p class="list-inset">Here, we are asking Spring Boot to inject <strong class="source-inline">OidcUser</strong> as a method parameter and we are creating a model that we’ll use in the view <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">myself</strong></span><span class="No-Break">.</span></p><p class="list-inset">Now, create a file<a id="_idIndexMarker172"/> named <strong class="source-inline">myself.html</strong> in the <strong class="source-inline">resources/templates</strong> folder. Put the following<a id="_idIndexMarker173"/> content in <strong class="source-inline">&lt;body&gt;</strong> to show the <span class="No-Break"><strong class="source-inline">Model</strong></span><span class="No-Break"> data:</span></p><pre class="source-code">&lt;body&gt;
    &lt;h1&gt;This is what we can see in your OpenId
        data&lt;/h1&gt;
    &lt;p&gt;Your username &lt;span style="font-weight:bold"
        th:text="${userName}" /&gt;! &lt;/p&gt;
    &lt;p&gt;Audience &lt;span style="font-weight:bold"
        th:text="${audience}" /&gt;.&lt;/p&gt;
    &lt;p&gt;Expires at &lt;span style="font-weight:bold"
        th:text="${expiresAt}" /&gt;.&lt;/p&gt;
    &lt;/div&gt;
    &lt;h2&gt;Here all the claims&lt;/h2&gt;
    &lt;table&gt;
        &lt;tr th:each="claim: ${claims}"&gt;
            &lt;td th:text="${claim.key}" /&gt;
            &lt;td th:text="${claim.value}" /&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;h2&gt;Let's try to use your rights&lt;/h2&gt;
    &lt;a href="<strong class="bold">/teams</strong>"&gt;Teams&lt;/a&gt;
&lt;/body&gt;</pre><p class="list-inset">As you can see, there<a id="_idIndexMarker174"/> is a link to <strong class="source-inline">/teams</strong>. This link<a id="_idIndexMarker175"/> will open a new page showing the teams. The teams page retrieves data from the RESTful API you created in the <em class="italic">Protecting a RESTful API using OAuth2 with different </em><span class="No-Break"><em class="italic">scopes</em></span><span class="No-Break"> recipe.</span></p></li>				<li>Let’s create a new method in <strong class="source-inline">FootballController</strong> so that we can get the teams. For that, you will get an access token by using the Spring Boot <span class="No-Break">OAuth2 client:</span><pre class="source-code">
@GetMapping("/teams")
public String teams(<strong class="bold">@RegisteredOAuth2AuthorizedClient("football-ui") OAuth2AuthorizedClient authorizedClient</strong>, Model model) {
    RestTemplate restTemplate = new RestTemplate();
    HttpHeaders headers = new HttpHeaders();
    <strong class="bold">headers.add(HttpHeaders.AUTHORIZATION,</strong>
<strong class="bold">        "Bearer " + authorizedClient.getAccessToken()</strong>
<strong class="bold">        .getTokenValue());</strong>
    HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(null,
        headers);
    ResponseEntity&lt;String&gt; response =
        restTemplate.exchange(
        "http://localhost:8080/football/teams",
        HttpMethod.GET, entity, String.class);
    model.addAttribute("teams", response.getBody());
   return "teams";
}</pre><p class="list-inset">You need to pass the access token in the <strong class="source-inline">Authorization</strong> header, with the <strong class="source-inline">Bearer</strong> string as <span class="No-Break">a prefix.</span></p></li>				<li>To allow the web application<a id="_idIndexMarker176"/> to use the RESTful API, you’ll need<a id="_idIndexMarker177"/> to include <strong class="source-inline">football-ui</strong>, the web application audience, as an accepted audience. For that, in the project you created in the <em class="italic">Protecting a RESTful API using OAuth2 with different scopes</em> recipe, open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and add <strong class="source-inline">football-ui</strong> to the <strong class="source-inline">audiences</strong> property. The <strong class="source-inline">application.yml</strong> file should look <span class="No-Break">like this:</span><pre class="source-code">
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          <strong class="bold">audiences:</strong>
          - football
          <strong class="bold">- football-ui</strong>
          issuer-uri: http://localhost:9000</pre></li>				<li>There is still an important<a id="_idIndexMarker178"/> detail we must cover<a id="_idIndexMarker179"/> before we start the new application: we need to configure Redis. The only settings that are required for it are <strong class="source-inline">hostname</strong> and <strong class="source-inline">port</strong>. For that, open the <strong class="source-inline">application.yml</strong> file of the <strong class="source-inline">football-ui</strong> project again and set the <span class="No-Break">following configuration:</span><pre class="source-code">
spring:
  data:
    redis:
      host: localhost
      port: 6379</pre></li>				<li>The last setting to configure is the application port. The resource server is already using port <strong class="source-inline">8080</strong>. To avoid port conflicts, we need to change the port of the <strong class="source-inline">football-ui</strong> project. For that, in the same <strong class="source-inline">application.yml</strong> file, add the <span class="No-Break">following setting:</span><pre class="source-code">
server:
  port: 9080</pre><p class="list-inset">You can set any port that is not being used yet. Keep in mind that it’s part of the configuration in the Authorization Server. If you modify the port, you will need to modify the configuration in the <span class="No-Break">authorization server.</span></p></li>				<li>Now, you can run the application. Go to http://localhost:9080 in <span class="No-Break">your browser:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 2.6: The application’s home page" src="image/B21646_02_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: The application’s home page</p>
			<p class="list-inset">Here, you will see the home page, which<a id="_idIndexMarker180"/> is the only route<a id="_idIndexMarker181"/> that is not protected. If you click on the <strong class="bold">who you are</strong> link, you will be redirected to the login page in the <span class="No-Break">Authorization Server:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 2.7: Login page in the authorization server" src="image/B21646_02_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: Login page in the authorization server</p>
			<p class="list-inset">Apply the username and password you configured in <em class="italic">Step 2</em> and click on the <strong class="bold">Sign in</strong> button. You’ll be redirected<a id="_idIndexMarker182"/> to the consent<a id="_idIndexMarker183"/> page, where you should permit the scopes being requested by <span class="No-Break">the application:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 2.8: Consent page in the authorization server" src="image/B21646_02_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: Consent page in the authorization server</p>
			<p class="list-inset">Click <strong class="bold">Submit Consent</strong>; you<a id="_idIndexMarker184"/> will be redirected<a id="_idIndexMarker185"/> to the application. The OAuth client application will complete the process by redeeming the access code generated by the authentication endpoint to obtain the ID token, access token, and refresh token. This part of the process is transparent for you as it’s managed by the <span class="No-Break">OAuth2 client.</span></p>
			<p class="list-inset">Once it’s done this, you’ll be returned<a id="_idIndexMarker186"/> to the application<a id="_idIndexMarker187"/> on the page you created to show the user <span class="No-Break">authentication data:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 2.9: Application page with user OpenID data" src="image/B21646_02_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Application page with user OpenID data</p>
			<p class="list-inset">If you click on the <strong class="bold">Teams</strong> link, it will call the RESTful API to get the <span class="No-Break"><strong class="source-inline">teams</strong></span><span class="No-Break"> data:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 2.10: The application page showing the data from the RESTful API" src="image/B21646_02_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: The application page showing the data from the RESTful API</p>
			<p>With that, your web application is protected by OpenID and it can call another <span class="No-Break">OAuth2-protected resource.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor091"/>How it works…</h2>
			<p>In this project, you protected<a id="_idIndexMarker188"/> your web application<a id="_idIndexMarker189"/> by using OIDC. It is an authentication protocol that is an extension of OAuth 2.0. It provides a standardized way for users to log in to web applications or mobile apps using their existing accounts with IdPs. In our exercise, we used the Authorization Server as an IdP <span class="No-Break">as well.</span></p>
			<p>The OIDC server normally provides a discovery endpoint at <strong class="source-inline">.well-known/openid-configuration</strong>. If this is not provided, then it was likely hidden intentionally by the administrator. That endpoint provides all the information the client applications need to authenticate. In our application, we used the <em class="italic">authorization code grant flow</em>. It involves <span class="No-Break">several steps:</span></p>
			<ol>
				<li>First, the client application redirects the user for authentication, requesting the required scopes for <span class="No-Break">application usage.</span></li>
				<li>Then, the user is authenticated. Depending on the features provided by the authorization server, it could use sophisticated mechanisms to validate the user, such as certificates, multiple authentication factors, or even <span class="No-Break">biometric features.</span></li>
				<li>If the user is authenticated, the authorization server may ask the user for consent or not, depending on the scopes requested by the <span class="No-Break">client application.</span></li>
				<li>Once authenticated, the Authorization Server <a id="_idIndexMarker190"/>will redirect the user<a id="_idIndexMarker191"/> to the client application, providing a short-lived authorization code. Then, the client application will redeem the authorization code on the token endpoint (provided by the discovery endpoint). The authorization server will return the tokens with the scopes that have been consented to. The scopes that have not been consented by the user won’t be present in the issued tokens. The following tokens are returned by the <span class="No-Break">authorization server:</span><ul><li>An ID token containing the session information. This token should not be used for authorization, just for <span class="No-Break">authentication purposes.</span></li><li>An access token, which contains the authorization information, such as the scopes that have been consented. If the application requires a scope, it should validate the scopes returned and manage <span class="No-Break">them accordingly.</span></li><li>A refresh token, which is used to get new tokens before <span class="No-Break">they expire.</span></li></ul></li>
			</ol>
			<p>Since many redirects are involved in this process, the client application needs to keep the state of the user, hence the requirement for session management. The Spring Framework provides a convenient way to manage sessions <span class="No-Break">using Redis.</span></p>
			<p>Keep in mind that the client application needs to access the discovery endpoint when it starts. For that reason, remember to start your authorization server before the <span class="No-Break">client application.</span></p>
			<p>In this exercise, you configured the root page as the only permitted page without authentication. To access any other page, it must be authenticated. For that reason, just by trying to navigate to <strong class="source-inline">/myself</strong> or <strong class="source-inline">/teams</strong>, the authorization process <span class="No-Break">is initiated.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor092"/>See also</h2>
			<p>Many modern applications are SPA. This type of application runs mostly in the browser. Also, note that many libraries implement OIDC. I recommend using an OpenID-certified library as they are validated <span class="No-Break">by peers.</span></p>
			<p>Even with the growing popularity of SPA, I haven’t explained the authentication of this type of application as it is not related to Spring Boot. However, if you are interested in integrating an SPA with Spring Authorization Server, I recommend following the guidelines from the Spring OAuth2 Authorization Server project <span class="No-Break">at </span><span class="No-Break">https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-pkce.html</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor093"/>Logging in with Google Accounts</h1>
			<p>You have a new requirement<a id="_idIndexMarker192"/> for your football application: your users want to log in to your application using their <span class="No-Break">Gmail accounts.</span></p>
			<p>To implement this scenario, you will configure your Authorization Server as an OAuth2 client, with Google Accounts being their IdP. You will learn how to create an OAuth2 Client ID in Google Cloud and integrate it into <span class="No-Break">your application.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor094"/>Getting ready</h2>
			<p>For this recipe, you will reuse the Spring Authorization Server you created in the <em class="italic">Setting up Spring Authorization Server</em> and <em class="italic">Protecting a RESTful API using OAuth2 with different scopes</em> recipes, as well as the web application you created in the <em class="italic">Configuring an MVC application with OpenID authentication</em> recipe. The MVC application stores sessions in Redis. You can run a Redis server in Docker, as explained in the <em class="italic">Configuring an MVC application with OpenID </em><span class="No-Break"><em class="italic">authentication</em></span><span class="No-Break"> recipe.</span></p>
			<p>I’ve prepared a working version of the required recipes in case you haven’t completed them yet. You can find them in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-5/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>As you will integrate the application with Google Accounts, you will need a Google Account. If you don’t have a Google Account yet, you can create one <span class="No-Break">at </span><a href="https://accounts.google.com"><span class="No-Break">https://accounts.google.com</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor095"/>How to do it…</h2>
			<p>Let’s start by creating an OAuth2 client in Google and then use the configuration provided to configure our Authorization Server<a id="_idIndexMarker193"/> so that it can log in to your application <span class="No-Break">using GoogleAaccounts:</span></p>
			<ol>
				<li>Let’s start by opening the Google Cloud console at <a href="https://console.cloud.google.com/">https://console.cloud.google.com/</a>. You will need to log in using your Google Account. Once you’ve done this, you will see the Google Cloud <span class="No-Break">home page:</span><ol><li class="upper-roman">First, you’ll need to create <span class="No-Break">a project:</span></li></ol></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer022">
					<img alt="Figure 2.11: The Google Cloud home page" src="image/B21646_02_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: The Google Cloud home page</p>
			<ol>
				<li class="upper-roman" value="2">To create the project, click <strong class="bold">Select </strong><span class="No-Break"><strong class="bold">a project</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">In the <strong class="bold">Select a project</strong> dialogue, click <span class="No-Break"><strong class="bold">NEW PROJECT</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 2.12: Creating a new project" src="image/B21646_02_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12: Creating a new project</p>
			<ol>
				<li class="upper-roman" value="4">Name the project – for<a id="_idIndexMarker194"/> <span class="No-Break">instance, </span><span class="No-Break"><strong class="source-inline">springboot3-cookbook</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 2.13: New Project settings" src="image/B21646_02_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13: New Project settings</p>
			<ol>
				<li class="upper-roman" value="5">Click <strong class="bold">CREATE</strong>. This process will take a few moments. A notification will appear when it is completed. Once created, select <span class="No-Break">the project.</span></li>
			</ol>
			<ol>
				<li value="2">Now that we have a project, let’s configure the consent page for our web application. For that, open<a id="_idIndexMarker195"/> the <strong class="bold">APIs &amp; Services</strong> menu and <span class="No-Break">choose </span><span class="No-Break"><strong class="bold">Credentials</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 2.14: The Credentials menu" src="image/B21646_02_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14: The Credentials menu</p>
			<p class="list-inset">On the <strong class="bold">Credentials</strong> page, you will see a reminder to create the consent page for <span class="No-Break">the application:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 2.15: The Credentials home page with a reminder to configure the OAuth consent screen highlighted" src="image/B21646_02_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15: The Credentials home page with a reminder to configure the OAuth consent screen highlighted</p>
			<p class="list-inset">Click on the <strong class="bold">CONFIGURE CONSENT SCREEN</strong> button and follow the instructions to configure<a id="_idIndexMarker196"/> the consent page. For <strong class="bold">User Type</strong>, select <strong class="bold">External</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">CREATE</strong></span><span class="No-Break">.</span></p>
			<p class="list-inset">With this type of user, the application will start in testing mode. This means that only some test users will be able to use it. Once you’ve completed the development process and the application is ready, you can publish it. To do this, your site must be verified. We won’t publish the application in this recipe, but if you plan to use it in your application, you’ll need to complete <span class="No-Break">this step.</span></p>
			<p class="list-inset">After selecting <strong class="bold">External</strong> for <strong class="bold">User Type</strong>, there is a four-step process you must <span class="No-Break">go through:</span></p>
			<ol>
				<li class="upper-roman">First, we<a id="_idIndexMarker197"/> have the <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">consent</strong></span><span class="No-Break"> screen:</span><ul><li>Here, you should configure the application’s name. You can set it as <strong class="bold">Spring Boot 3 Cookbook</strong>, <span class="No-Break">for instance.</span></li><li>You should configure a user support email. You can use the same email address that you use for your <span class="No-Break">Google Account.</span></li><li>You should also configure<a id="_idIndexMarker198"/> the Developer Contact Information email. Again, you can use the same email address that you use for your <span class="No-Break">Google Account.</span></li><li>The rest of the parameters are optional. We don’t need to configure them <span class="No-Break">for now.</span></li></ul></li>
				<li class="upper-roman">For <strong class="bold">Update selected scopes</strong>, click <strong class="bold">ADD OR REMOVE SCOPES</strong> and select <strong class="bold">openid</strong>, <strong class="bold">userinfo.email</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">userinfo.profile</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 2.16: Selecting scopes" src="image/B21646_02_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16: Selecting scopes</p>
			<ol>
				<li class="upper-roman" value="3">Then, <span class="No-Break">click </span><span class="No-Break"><strong class="bold">UPDATE</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">In <strong class="bold">test users</strong> step, click <strong class="bold">ADD USERS</strong> to add some testing users who will be able to access the application before it’s published. You can add a different Google Account to test <span class="No-Break">the application.</span></li>
				<li class="upper-roman">In the <strong class="bold">summary</strong> step, you will see a summary of your consent screen. You can click <strong class="bold">BACK TO DASHBOARD</strong> to return to the <strong class="bold">OAuth consent </strong><span class="No-Break"><strong class="bold">screen</strong></span><span class="No-Break"> page.</span></li>
			</ol>
			<ol>
				<li value="3">Next, we will create the client<a id="_idIndexMarker199"/> credentials. For that, once again, navigate to the <strong class="bold">Credentials</strong> page, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.17</em>. Once you are on the <strong class="bold">Credentials</strong> page, click <strong class="bold">+ CREATE CREDENTIALS</strong> and select <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">client ID</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer028">
					<img alt="Figure 2.17: Selecting OAuth client ID credentials" src="image/B21646_02_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17: Selecting OAuth client ID credentials</p>
			<ul>
				<li>For <strong class="bold">Application type</strong>, select <span class="No-Break"><strong class="bold">Web application</strong></span></li>
				<li>For <strong class="bold">Name</strong>, <span class="No-Break">set </span><span class="No-Break"><strong class="source-inline">football-gmail</strong></span></li>
				<li>For <strong class="bold">Authorized redirect URIs</strong>, <span class="No-Break">add </span><span class="No-Break">http://localhost:9000/login/oauth2/code/football-gmail</span><span class="No-Break">:</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure 2.18: Creating an OAuth client ID" src="image/B21646_02_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18: Creating an OAuth client ID</p>
			<p class="list-inset">Click <strong class="bold">CREATE</strong>. A dialogue box<a id="_idIndexMarker200"/> will appear, informing you that the client was created and showing you the <strong class="bold">Client ID</strong> and <strong class="bold">Client secret</strong> details. We’ll need this data to configure the Authorization Server, so keep <span class="No-Break">it safe:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure 2.19: OAuth client created" src="image/B21646_02_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19: OAuth client created</p>
			<p class="list-inset">There is a button to download a JSON file containing the configuration. Click on it and save the JSON file in a secure place as it contains the credentials that are required to use <span class="No-Break">the client.</span></p>
			<ol>
				<li value="4">Now, we can configure<a id="_idIndexMarker201"/> the Spring OAuth2 <span class="No-Break">Authorization Server:</span><ol><li class="upper-roman">First, we need to add the OAuth2 client dependency. For that, open the <strong class="source-inline">pom.xml</strong> file and add the <span class="No-Break">following dependency:</span></li></ol><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-oauth2-client
        &lt;/artifactId&gt;
&lt;/dependency&gt;</pre><ol><li class="upper-roman" value="2">Next, open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and add the client configuration <span class="No-Break">for Google:</span></li></ol><pre class="source-code">spring
  security:
    oauth2:
      client:
        registration:
          football-gmail:
            <strong class="bold">client-id: "replace with your client id"</strong>
<strong class="bold">            client-secret: "replace with your secret"</strong>
            redirect-uri:
              "{baseUrl}/login/oauth2/code/
              {registrationId}"
            authorization-grant-type:
              authorization_code
            scope: openid,profile,email
        provider:
          football-gmail:
            issuer-uri: https://accounts.google.com
            user-name-attribute: given_name</pre><ol><li class="upper-roman" value="3">Replace the <strong class="source-inline">client-id</strong> and <strong class="source-inline">client-secret</strong> fields with the values you obtained in <span class="No-Break"><em class="italic">Step 2</em></span><span class="No-Break">.</span></li><li class="upper-roman">The last step to configure<a id="_idIndexMarker202"/> the Authorization Server is defining the behavior of the security checks. For that, create a configuration class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">SecurityConfig</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code"><strong class="bold">@Configuration</strong>
<strong class="bold">@EnableWebSecurity</strong>
public class SecurityConfig {
}</pre><ol><li class="upper-roman" value="5">Then, add a <span class="No-Break"><strong class="source-inline">SecurityFilterChain</strong></span><span class="No-Break"> bean:</span></li></ol><pre class="source-code">@Bean
<strong class="bold">@Order(1)</strong>
public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)
        throws Exception{
    OAuth2AuthorizationServerConfiguration
        .applyDefaultSecurity(http);
    http.getConfigurer(
        OAuth2AuthorizationServerConfigurer.class)
        .oidc(Customizer.withDefaults());
    http
        .exceptionHandling((exceptions) -&gt; exceptions
            .defaultAuthenticationEntryPointFor(
                new LoginUrlAuthenticationEntryPoint(
                    "/oauth2/authorization/
                    football-gmail"),
                new MediaTypeRequestMatcher(
                    MediaType.TEXT_HTML)
            )
        )
        .oauth2ResourceServer((oauth2) -&gt;
            oauth2.jwt(Customizer.withDefaults()));
    return http.build();
}</pre><p class="list-inset">The preceding code configures<a id="_idIndexMarker203"/> Spring Security to use OAuth 2.0 and OpenID Connect 1.0 for authentication, as well as to accept JWT access tokens for certain requests. For instance, it will accept requests that provide JWT access tokens to get <span class="No-Break">user information.</span></p><p class="list-inset">You will also need to add another <strong class="source-inline">SecurityFilterChain</strong> bean but with less priority. It will initiate the OAuth2 login process, which means it will initiate the authentication as a client application in Google, as configured in the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span></p><pre class="source-code">@Bean
<strong class="bold">@Order(2)</strong>
public SecurityFilterChain
defaultSecurityFilterChain(HttpSecurity http)
        throws Exception {
    http
        .authorizeHttpRequests((authorize) -&gt;
            authorize
            .anyRequest().authenticated())
        .oauth2Login(Customizer.withDefaults());
    return http.build();
}</pre><p class="list-inset">The preceding code configures Spring Security to require authentications for all requests and to use OAuth 2.0 for <span class="No-Break">logging in.</span></p></li>				<li>With that, your OAuth2 Authorization Server<a id="_idIndexMarker204"/> has been configured to require authentication using Google Accounts. Now, you can run all <span class="No-Break">your environments:</span><ul><li>Run the Authorization Server you <span class="No-Break">just configured</span></li><li>Run the RESTful API server you created in the <em class="italic">Protecting a RESTful API using OAuth2 with different </em><span class="No-Break"><em class="italic">scopes</em></span><span class="No-Break"> recipe</span></li><li>Run the web application you created in the <em class="italic">Configuring an MVC application with OpenID </em><span class="No-Break"><em class="italic">authentication</em></span><span class="No-Break"> recipe</span></li></ul><p class="list-inset">When you navigate to <strong class="source-inline">http://localhost:9080/myself</strong>, you will be asked to log in using a <span class="No-Break">Google Account:</span></p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 2.20: Logging in using a Google Account" src="image/B21646_02_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20: Logging in using a Google Account</p>
			<p class="list-inset">Once you’ve logged in, you will see that the application is the same. You can now use the claims issued<a id="_idIndexMarker205"/> by the Authorization Server and invoke the <span class="No-Break">RESTful API.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor096"/>How it works…</h2>
			<p>Because we’re using the Authorization Server with just the login delegated in Google, the Authorization Server doesn’t need to maintain a user repository, though it still has the responsibility of issuing tokens. This means that when the application requests to identify a user, the Authorization Server redirects the login to Google. Once back, the Authorization Server continues issuing tokens. Due to this, you didn’t need to change the code in the MVC web application or the <span class="No-Break">RESTful API.</span></p>
			<p>It is possible to configure the MVC application so that it bypasses the authorization server and logs in to Google Accounts directly. You just need to replace the OAuth2 client configuration in the MVC web application with the client configuration you used in the Authorization server. However, in that case, you won’t be able to use the access tokens that have been issued by Google to protect your RESTful API. This is because Google access tokens are intended to be used with Google services only and they are not <span class="No-Break">standard JWT.</span></p>
			<p>The main complexity is configuring the security chain as there are many options available. In the <strong class="source-inline">SecurityConfig</strong> class, there are two <strong class="source-inline">Beans</strong> with <span class="No-Break">different priorities.</span></p>
			<p>The <strong class="source-inline">SecurityConfig</strong> class defines two <strong class="source-inline">SecurityFilterChain</strong> beans. Here, <strong class="source-inline">SecurityFilterChain</strong> is essentially a chain of filters that Spring Security uses to perform various security checks. Each filter in the chain has a specific role, such as authenticating <span class="No-Break">the user.</span></p>
			<p>The first <strong class="source-inline">SecurityFilterChain</strong> bean is defined with an order of 1, meaning it will be the first filter chain to be consulted. This filter chain has been configured to apply default security settings for an OAuth 2.0 authorization server. It also enables OpenID Connect 1.0 via the <strong class="source-inline">oidc(Customizer.withDefaults())</strong> <span class="No-Break">method call.</span></p>
			<p>The configuration also specifies<a id="_idIndexMarker206"/> that if a user is not authenticated, they should be redirected to the OAuth 2.0 login endpoint. This is done using <strong class="source-inline">LoginUrlAuthenticationEntryPoint</strong> with a URL <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">/oauth2/authorization/football-gmail</strong></span><span class="No-Break">.</span></p>
			<p>The filter chain is also configured to accept JWT access tokens for user info and/or client registration. This is done using the <strong class="source-inline">oauth2ResourceServer((oauth2) -&gt; oauth2.jwt(Customizer.withDefaults()))</strong> <span class="No-Break">method call.</span></p>
			<p>The second <strong class="source-inline">SecurityFilterChain</strong> bean is defined with an order of 2, meaning it will be consulted if the first filter chain does not handle the request. The <strong class="source-inline">anyRequest().authenticated()</strong> chain of methods means that any request must <span class="No-Break">be authenticated.</span></p>
			<p>The <strong class="source-inline">oauth2Login(Customizer.withDefaults())</strong> method call configures the application to use OAuth 2.0 for authentication. The <strong class="source-inline">Customizer.withDefaults()</strong> method call is used to apply the default configuration<a id="_idIndexMarker207"/> for OAuth <span class="No-Break">2.0 login.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor097"/>See also</h2>
			<p>As you can see, integrating a third-party authentication in the Authorization Server just requires configuring the client application for the IdP. So, if you need to integrate with another social provider, you will need to obtain the client <span class="No-Break">application data.</span></p>
			<p>If you want to integrate with GitHub, you can create an application registration on the <span class="No-Break">https://github.com/settings/developers</span><span class="No-Break"> page.</span></p>
			<p>For Facebook, you can create your application on the developer’s page <span class="No-Break">at </span><span class="No-Break">https://developers.facebook.com/apps</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor098"/>Integrating a RESTful API with a cloud IdP</h1>
			<p>Now that your application<a id="_idIndexMarker208"/> is becoming more and more popular, you decide<a id="_idIndexMarker209"/> to delegate your authentication to a cloud IdP as they offer advanced protection for sophisticated threats. You decide to use Azure AD B2C. This service is intended for public-facing applications, allowing customers to sign in and sign up, as well as customize the user journey, social network integration, and other <span class="No-Break">interesting features.</span></p>
			<p>What you’ll learn in this recipe can be applied to other cloud IdPs, such as Okta, AWS Cognito, Google Firebase, and many others. Spring Boot offers specialized starters that simplify the process of integrating with an IdP <span class="No-Break">even more.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor099"/>Getting ready</h2>
			<p>In this recipe, we’ll integrate the application you prepared in the <em class="italic">Configuring an MVC application with OpenID authentication</em> recipe. If you haven’t completed that recipe yet, I’ve prepared a working version that you can find in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <strong class="source-inline">chapter4/recipe4-6/start</strong> folder. This recipe also requires Redis, as explained in the <em class="italic">Configuring an MVC application with OpenID authentication</em> recipe. The easiest way to deploy it on your computer is by <span class="No-Break">using Docker.</span></p>
			<p>As we’ll be integrating with Azure AD B2C, you will need an Azure subscription. If you don’t have one, you can create a free account at https://azure.microsoft.com/free. Azure AD B2C offers a free tier that allows up to 50,000 monthly <span class="No-Break">active users.</span></p>
			<p>If you don’t have an Azure AD B2C tenant, please<a id="_idIndexMarker210"/> follow the instructions at <a href="https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant">https://learn.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant</a> to create one before starting <span class="No-Break">this recipe.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor100"/>How to do it…</h2>
			<p>Follow these steps to build<a id="_idIndexMarker211"/> a smooth sign-in/signup process with Azure AD B2C<a id="_idIndexMarker212"/> and learn how to connect it seamlessly with your Spring Boot application for large-scale <span class="No-Break">user authentication:</span></p>
			<ol>
				<li>The first thing you’ll need to do is create an application registration in Azure AD B2C. An application registration is the same as the client registration you created in Spring Authorization Server in previous recipes. You can create the application registration in the <strong class="bold">App </strong><span class="No-Break"><strong class="bold">registrations</strong></span><span class="No-Break"> section:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 2.21: Creating an app registration in Azure AD B2C" src="image/B21646_02_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21: Creating an app registration in Azure AD B2C</p>
			<ol>
				<li value="2">On the <strong class="bold">App registrations</strong> page, set the <span class="No-Break">following parameters:</span><ul><li>For <strong class="bold">Name</strong>, set the name<a id="_idIndexMarker213"/> of the application. I suggest<a id="_idIndexMarker214"/> that you use <span class="No-Break"><strong class="source-inline">Football UI</strong></span><span class="No-Break">.</span></li><li>For <strong class="bold">Supported account types</strong>, select <strong class="bold">Accounts in any identity provider or organizational directory (for authenticating users with user flows)</strong>. It’s the <span class="No-Break">default option.</span></li><li>For <strong class="bold">Redirect URI (recommended)</strong>, configure <strong class="bold">Web</strong> as the platform and <strong class="source-inline">http://localhost:9080/login/oauth/code</strong> as the value of the <span class="No-Break">redirect UI:</span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 2.22: Application registration options in Azure AD B2C" src="image/B21646_02_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22: Application registration options in Azure AD B2C</p>
			<p class="list-inset">Click <strong class="bold">Register</strong> to continue<a id="_idIndexMarker215"/> with the application <span class="No-Break">registration</span><span class="No-Break"><a id="_idIndexMarker216"/></span><span class="No-Break"> process.</span></p>
			<ol>
				<li value="3">Once you have created the application registration, you need to configure a client secret. You can do this in the <strong class="bold">Certificates &amp; secrets</strong> section of the application registration <span class="No-Break">you’ve created:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 2.23: Creating a new client secret" src="image/B21646_02_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.23: Creating a new client secret</p>
			<ol>
				<li value="4">Once you’ve created the secret, the secret value generated by Azure AD B2C will appear. You should copy the value now as it won’t be accessible again. Keep it safe as you’ll need <span class="No-Break">it later.</span></li>
				<li>Finally, we must create a user flow. A user flow is a configuration policy that can be used to set up the authentication experience for end users. Set the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">User flow type</strong>, select <strong class="bold">Sign up and sign in</strong>. Set the <span class="No-Break">version </span><span class="No-Break"><strong class="bold">Recommended</strong></span><span class="No-Break">.</span></li><li>For <strong class="bold">Name</strong>, type <strong class="source-inline">SUSI</strong>; this<a id="_idIndexMarker217"/> is an acronym<a id="_idIndexMarker218"/> for “sign up and <span class="No-Break">sign in.”</span></li><li>For <strong class="bold">Identity providers</strong>, select <span class="No-Break"><strong class="bold">Email signup</strong></span><span class="No-Break">.</span></li><li>For <strong class="bold">User attributes and token claims</strong>, select <strong class="bold">Given Name</strong> and <strong class="bold">Surname</strong>. For both attributes, check the <strong class="bold">Collect attribute</strong> and <strong class="bold">Return </strong><span class="No-Break"><strong class="bold">claim</strong></span><span class="No-Break"> boxes.</span></li><li>Keep the rest of the <span class="No-Break">options as-is:</span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 2.24: The Create a user flow page" src="image/B21646_02_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.24: The Create a user flow page</p>
			<p class="list-inset">Click <strong class="bold">Create</strong> to create the <span class="No-Break">user flow.</span></p>
			<ol>
				<li value="6">Now, let’s configure<a id="_idIndexMarker219"/> our application. First, you’ll need<a id="_idIndexMarker220"/> to add the appropriate dependencies. For that, open the <strong class="source-inline">pom.xml</strong> file of the web application and add the <span class="No-Break"><strong class="source-inline">org.springframework.boot:spring-boot-starter-oauth2-client</strong></span><span class="No-Break"> dependency:</span><pre class="source-code">
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-oauth2-client
      &lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>Then, you’ll need to configure<a id="_idIndexMarker221"/> the Azure AD B2C settings<a id="_idIndexMarker222"/> in the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder. Replace the Oauth2 client settings with the B2C ones. The file should look <span class="No-Break">as follows:</span><pre class="source-code">
server:
  port: 9080
<strong class="bold">spring:</strong>
  <strong class="bold">cloud:</strong>
<strong class="bold">    azure:</strong>
<strong class="bold">      active-directory:</strong>
<strong class="bold">        b2c:</strong>
<strong class="bold">          enabled: true</strong>
<strong class="bold">          base-uri:</strong>
<strong class="bold">            </strong>https://sb3cookbook.b2clogin.com/
              sb3cookbook.onmicrosoft.com/
<strong class="bold">          credential:</strong>
<strong class="bold">            client-id:</strong>
<strong class="bold">              aa71b816-3d6e-4ee1-876b-83d5a60c4d84</strong>
<strong class="bold">            </strong><strong class="bold">client-secret: '&lt;the secret&gt;</strong>'
<strong class="bold">          login-flow: sign-up-or-sign-in</strong>
<strong class="bold">          logout-success-url: </strong>http://localhost:9080
<strong class="bold">          user-flows:</strong>
<strong class="bold">            sign-up-or-sign-in: B2C_1_SUSI</strong>
<strong class="bold">          user-name-attribute-name: given_name</strong>
  data:
    redis:
      host: localhost
      port: 6379</pre><p class="list-inset">In the <strong class="source-inline">client-secret</strong> field, set the value<a id="_idIndexMarker223"/> you kept in <em class="italic">Step 4</em>. I recommend enclosing<a id="_idIndexMarker224"/> the secret value in quotation marks since the secret likely contains reserved characters that can cause unexpected behavior when the <strong class="source-inline">application.yaml</strong> file is <span class="No-Break">being processed.</span></p></li>				<li>To complete the OpenID configuration to allow users to log in to your application with Azure AD B2C, you’ll need to adjust the security chain by applying an Azure AD OIDC configurer. To do this, modify the <strong class="source-inline">SecurityConfiguration</strong> class by adding <strong class="source-inline">AadB2cOidcLoginConfigurer</strong> in the constructor to allow bean injection, and then use it in the existing <strong class="source-inline">defaultSecurityFilterChain</strong> method, <span class="No-Break">as follows:</span><pre class="source-code">
private final <strong class="bold">AadB2cOidcLoginConfigurer configurer</strong>;
public SecurityConfiguration(<strong class="bold">AadB2cOidcLoginConfigurer</strong>
<strong class="bold">configurer</strong>) {
    this.configurer = configurer;
}
@Bean
public SecurityFilterChain
defaultSecurityFilterChain(HttpSecurity http) throws
Exception {
    http
        .authorizeHttpRequests((authorize) -&gt;
            authorize
            .requestMatchers("/").permitAll()
            .anyRequest().authenticated())
        .apply(<strong class="bold">configurer</strong>);
    return http.build();
}</pre></li>				<li>At this point, you can run<a id="_idIndexMarker225"/> your web application and authenticate<a id="_idIndexMarker226"/> with Azure AD B2C. However, there’s still something pending that’s protecting the RESTful API server with Azure <span class="No-Break">AD B2C.</span><p class="list-inset">To get around this, you can modify the dependencies. For that, open the <strong class="source-inline">pom.xml</strong> file of the RESTful API project and replace the <strong class="source-inline">org.springframework.boot: spring-boot-starter-oauth2-resource-server</strong> dependency <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">com.azure.spring:spring-cloud-azure-starter-active-directory-b2c</strong></span><span class="No-Break">:</span></p><pre class="source-code">
&lt;dependency&gt;
  &lt;groupId&gt;com.azure.spring&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-azure-starter-active-
    directory-b2c&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>Now, modify the <strong class="source-inline">application.yml</strong> file so that it configures the Azure B2C <span class="No-Break">client registration:</span><pre class="source-code">
spring:
  cloud:
    azure:
      active-directory:
        b2c:
          enabled: true
          profile:
            tenant-id:
              b2b8f451-385b-4b9d-9268-244a8f05b32f
          credential:
            client-id:
              aa71b816-3d6e-4ee1-876b-83d5a60c4d84
          base-uri: https://sb3cookbook.b2clogin.com
          user-flows:
            sign-up-or-sign-in: B2C_1_SISU</pre></li>				<li>Now, you can run both the web application<a id="_idIndexMarker227"/> and the RESTful server<a id="_idIndexMarker228"/> since both are protected with Azure <span class="No-Break">AD B2C:</span><ol><li class="upper-roman">Open your browser and navigate to <strong class="source-inline">http://localhost:8080/myself</strong>. As the method is protected, you will be redirected to the <strong class="bold">Azure AD B2C Sign up or sign </strong><span class="No-Break"><strong class="bold">in</strong></span><span class="No-Break"> page:</span></li></ol></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer036">
					<img alt="Figure 2.25: The Azure AD B2C default Sign up or sign in page" src="image/B21646_02_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.25: The Azure AD B2C default Sign up or sign in page</p>
			<ol>
				<li class="upper-roman" value="2">If you click<a id="_idIndexMarker229"/> on the <strong class="bold">Sign up now</strong> link, you can create<a id="_idIndexMarker230"/> a <span class="No-Break">new user:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="Figure 2.26: Sign-up page" src="image/B21646_02_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.26: Sign-up page</p>
			<ol>
				<li class="upper-roman" value="3">The first step is to provide<a id="_idIndexMarker231"/> a valid email<a id="_idIndexMarker232"/> address. Once you’ve done this click <strong class="bold">Send verification code</strong>. You will receive an email containing a verification code that you will need to provide on this page. Once verified, you can introduce the rest of <span class="No-Break">the fields.</span></li>
				<li class="upper-roman">When you return<a id="_idIndexMarker233"/> to the page, you will see the claims<a id="_idIndexMarker234"/> that have been provided by Azure <span class="No-Break">AD B2C:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 2.27: Our web page showing the claims from Azure B2C" src="image/B21646_02_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.27: Our web page showing the claims from Azure B2C</p>
			<ol>
				<li class="upper-roman" value="5">If you click on the <strong class="bold">Teams</strong> link, you will see the same data that you did in the <em class="italic">Configuring an MVC application with OpenID </em><span class="No-Break"><em class="italic">authentication</em></span><span class="No-Break"> recipe.</span></li>
				<li class="upper-roman">If you click on the <strong class="bold">Logout</strong> link, you<a id="_idIndexMarker235"/> will be redirected<a id="_idIndexMarker236"/> to the default <span class="No-Break">logout page:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Figure 2.28: The default logout page" src="image/B21646_02_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.28: The default logout page</p>
			<ol>
				<li class="upper-roman" value="7">Finally, if you click on the <strong class="bold">Log Out</strong> button, you will be redirected to the logout endpoint in Azure <span class="No-Break">AD B2C.</span></li>
			</ol>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor101"/>How it works…</h2>
			<p>The <strong class="source-inline">com.azure.spring:spring-cloud-azure-starter-active-directory-b2c</strong> dependency includes both the Spring OAuth2 client and Spring OAuth2 resource starters that we used in previous recipes. On top of those starters, it also includes specific components to adapt the Azure AD B2C-specific features. For instance, the discovery endpoint cannot be inferred just from the issuer URL as it is dependent on the Azure AD B2C policy <span class="No-Break">being used.</span></p>
			<p>The Azure AD B2C starter maps the configuration used in the Azure portal to the configuration on your <strong class="source-inline">application.yml</strong> file. Apart from that, the application doesn’t require specific changes as it follows the <span class="No-Break">OAuth2 specification.</span></p>
			<p>In Azure AD B2C, we defined an app registration. This is equivalent to the concept of a client in Spring <span class="No-Break">Authorization Server.</span></p>
			<p>Azure AD B2C allows us to define different policies so that we can customize the user experience. We created a policy that performs the sign-up and sign-in process using the default settings, but you can define an edit profile or reset password policy as well. Other interesting capabilities include defining custom interfaces and integrating other IdPs. For instance, it’s quite easy to integrate with cloud providers such as Google Accounts, social network providers such as Facebook and Instagram, and enterprise IdPs such as <span class="No-Break">Azure Entra.</span></p>
			<p>One of the main advantages of this solution is that users can register themselves; they don’t need an administrator to do this <span class="No-Break">for them.</span></p>
			<p>This recipe doesn’t intend to review<a id="_idIndexMarker237"/> all the possibilities of Azure AD B2C – it’s been provided<a id="_idIndexMarker238"/> to help you understand how to integrate your Spring Boot application with Azure <span class="No-Break">AD B2C.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor102"/>There’s more…</h2>
			<p>An interesting and probably more frequent scenario is when our RESTful API uses a different application registration than the UI application. When I build a RESTful API, I usually design it while keeping one thing in mind: more than one client should be able to consume it. This works for different scenarios, such as the web and mobile versions, or allowing a third-party application to consume some of the APIs. In that scenario, you can create a dedicated application registration for your RESTful API and create different application roles with different access levels. Then, you can assign the corresponding role to the <span class="No-Break">consumer applications.</span></p>
			<p>When you create the application registration<a id="_idIndexMarker239"/> for the RESTful API, you can create the roles by opening the manifest and including the desired roles of your application. For instance, we can create the <strong class="source-inline">football.read</strong> role for general consumer access and the <strong class="source-inline">football.admin</strong> role for administrative access. It would look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure 2.29: The application registration manifest with two application roles" src="image/B21646_02_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.29: The application registration manifest with two application roles</p>
			<p>Then, in the RESTful application<a id="_idIndexMarker240"/> registration area, go to <strong class="bold">Expose an API</strong> and assign an <strong class="bold">Application ID </strong><span class="No-Break"><strong class="bold">URI</strong></span><span class="No-Break"> value:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Figure 2.30: Assigning an Application ID URI value" src="image/B21646_02_30.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.30: Assigning an Application ID URI value</p>
			<p>Then, we can assign permissions<a id="_idIndexMarker241"/> to the RESTful API. Go to <strong class="bold">API permissions</strong> and assign <span class="No-Break"><strong class="bold">Application permissions</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer042">
					<img alt="Figure 2.31: Assigning application permissions to the consumer application" src="image/B21646_02_31.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.31: Assigning application permissions to the consumer application</p>
			<p>Now, the RESTful API<a id="_idIndexMarker242"/> has its own application registration. This means that you can configure the application with its own audience, instead of the UI application. To configure that, go to the <strong class="source-inline">application.yml</strong> file of the RESTful API and change the <strong class="source-inline">client-id</strong> property to the client ID of the application registration of the <span class="No-Break">RESTful API.</span></p>
			<p>If you want to use the application roles to provide different access levels, you will need to use <strong class="source-inline">AadJwtGrantedAuthoritiesConverter</strong> from the Azure AD B2C starter. You can register the bean in the <strong class="source-inline">SecurityConfig</strong> class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@Bean
public Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt;
aadJwtGrantedAuthoritiesConverter() {
    return new <strong class="bold">AadJwtGrantedAuthoritiesConverter</strong>();
}
@Bean
public JwtAuthenticationConverter
aadJwtAuthenticationConverter() {
    JwtAuthenticationConverter converter = new
        JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(
            <strong class="bold">aadJwtGrantedAuthoritiesConverter</strong>());
    return converter;
}</pre>			<p>By default, the Spring OAuth2 resource server only converts the <strong class="source-inline">scope</strong> claim and the application roles will be provided in the <strong class="source-inline">roles</strong> claim. The converter generates authorities for each role with the <strong class="source-inline">APPROLE_</strong> prefix. So, you can restrict access using these authorities <span class="No-Break">like so:</span></p>
			<pre class="source-code">
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http
        .authorizeHttpRequests(authorize -&gt; authorize
            .requestMatchers(HttpMethod.GET,
                "/football/teams/**").hasAnyAuthority(
                "APPROLE_football.read",
                "APPROLE_football.admin")
            .requestMatchers(HttpMethod.POST,
                "/football/teams/**").hasAnyAuthority(
                "APPROLE_football.admin")
            .anyRequest().authenticated())
        .oauth2ResourceServer(oauth2 -&gt;
            oauth2.jwt(Customizer.withDefaults()))
        .build();
}</pre>			<p>Here’s what the payload of an access token with the application roles <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
{
  <strong class="bold">«aud»: «fdc345e8-d545-49af-aa1a-04a087364c8b»,</strong>
  "iss": "https://login.microsoftonline.com/b2b8f451-385b-
    4b9d-9268-244a8f05b32f/v2.0",
  "iat": 1700518483,
  "nbf": 1700518483,
  "exp": 1700522383,
  "aio": "ASQA2/8VAAAAIXIjK+
    28DPOc4epV22pKGfqdRSnps2dtReyZY7MPhpk=",
  "azp": "aa71b816-3d6e-4ee1-876b-83d5a60c4d84",
  "azpacr": "1",
  "oid": "d88d83d6-421f-41e2-ba99-f49516fd439a",
  "rh": "0.ASQAUfS4sls4nUuSaCRKjwWzL-hFw_
    1F1a9JqhoEoIc2TIskAAA.",
  <strong class="bold">«roles»: [</strong>
<strong class="bold">    "football.read",</strong>
<strong class="bold">    "football.admin"</strong>
<strong class="bold">  ],</strong>
  "sub": "d88d83d6-421f-41e2-ba99-f49516fd439a",
  "tid": "b2b8f451-385b-4b9d-9268-244a8f05b32f",
  "uti": "JSxYHbHkpUS91mwBtxNaAA",
  "ver": "2.0"
}</pre>			<p>By doing this, only the allowed client<a id="_idIndexMarker243"/> applications will be able to consume the <span class="No-Break">RESTful API.</span></p>
		</div>
	</body></html>