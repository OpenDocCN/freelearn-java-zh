- en: 4\. Collections, Lists and Java's Built-In APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the powerful Java collections framework, which
    is used to store, sort, and filter data. It will first take you through the structure
    of the built-in Collections **Application Programming Interface** (**API**), the
    Java collections framework, which will simplify your dealings with complex data
    structures and allow you to use and create APIs with minimal effort. Through this
    framework, you will examine the relationship between lists and arrays, and learn
    to populate lists from arrays. Finally, in this chapter's final activity, you
    will create and complete a program in which you will be asked to perform standard
    operations on data stored in sets, lists, and maps in preparation for future chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java comes with a built-in Collections API, allowing you to manipulate data
    structures with very little effort. A collection is an object that contains multiple
    elements. Collections are used to store, share, process, and communicate aggregated
    data. We call this system the **Java collections framework**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this framework, there are different components that are used to
    optimize our interaction with the actual data:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfaces**: Abstract data types that represent collections'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementations**: Specific implementations of the collection interfaces'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms**: Polymorphic methods used to process the data within a collection
    for operations such as sorting and searching'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other programming languages have their own collection frameworks. For example,
    C++ has the **Standard Template Library** (**STL**). Java boasts simplicity when
    it comes to its collection framework.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the collections framework has many benefits, including a reduction in
    the complexity of creating programs that deal with data structures, an increase
    in the performance of programs, a simplification of API creation and use, and
    an increase in the reuse of functioning software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework is relevant even when handling data that can be accessed
    by several processes simultaneously, as this would be the case in multithreaded
    programming scenarios. However, it is not the intention of this chapter to deal
    with concurrent programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The Collections API comes with five main interfaces:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`Set`: A collection that contains no duplicates'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`: An ordered collection or sequence, allowing for duplicates'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Queue`: A collection that sorts data in the order of its arrival, typically
    handled as a **First In First Out** (**FIFO**) process'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deque`: Essentially a queue that allows for data insertion at both ends, meaning
    that it can be handled both as FIFO and **Last In First Out** (**LIFO**)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`: Relates keys—which must be unique—to values'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will define the main interfaces (lists, sets, and maps),
    and explore examples of their respective uses. The framework has even more interfaces
    than the ones listed previously, but the others are either just variations of
    those listed or are outside the scope of this chapter. Furthermore, we will look
    at how arrays work in much more depth than we have previously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义主要接口（列表、集合和映射），并探讨它们各自的使用示例。该框架比之前列出的接口更多，但其他接口要么是那些列出的变体，要么超出了本章的范围。此外，我们将比以前更深入地探讨数组的工作原理。
- en: 'The definition of a simple collection—in this case, a specific type of set
    would be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简单集合的定义——在这种情况下，特定类型的集合的定义如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The different available classes for sets, lists, queues, deques, and maps are
    named after the interfaces. The different classes present different properties,
    as we will see later in the chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的不同集合类（集合、列表、队列、双端队列和映射）以接口命名。不同的类具有不同的属性，我们将在本章后面看到。
- en: Arrays
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays are part of the collections framework. There are some static methods
    that can be used to manipulate arrays. The operations you can perform are creating,
    sorting, searching, comparing, streaming, and transforming arrays. You were introduced
    to arrays in *Chapter 2*, *Learning the Basics*, where you saw how they can be
    used to store data of the same type. The declaration of an array is quite straightforward.
    Let''s see what an array of strings would look like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是集合框架的一部分。有一些静态方法可以用来操作数组。您可以执行的操作包括创建、排序、搜索、比较、流式传输和转换数组。您在*第二章*，*学习基础知识*中介绍了数组，您看到了它们如何用于存储相同类型的数据。数组的声明相当简单。让我们看看字符串数组会是什么样子：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running operations on an array is as easy as calling some of the methods contained
    in the `java.util.Arrays` package. For example, sorting the previous array would
    require calling the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上运行操作与调用`java.util.Arrays`包中包含的一些方法一样简单。例如，对前面的数组进行排序需要调用以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The methods dedicated to handling arrays include one method that could be used
    to print out full arrays as if they were strings. This can be very handy when
    debugging a program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 专门用于处理数组的函数包括一个可以用来打印完整数组的方法，就像它们是字符串一样。这在调试程序时非常有用：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will print the arrays and display each element separated by commas and
    within square brackets, `[]`. If you executed the previous command after sorting
    the declared array of strings, the outcome would be:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印数组并显示每个元素，用逗号分隔，并用方括号括起来，`[]`。如果您在排序声明的字符串数组之后执行前面的命令，结果将是：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the array has been sorted in ascending alphabetical order.
    There is a difference between that way of printing out an array and using a `for`
    loop to iterate throughout an array:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数组已按升序字母顺序排序。打印数组的方式与使用`for`循环遍历数组的方式不同：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This would give the following as the result:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下结果：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to write your code in a slightly cleaner way, you could import
    the whole `java.util.Arrays` API at the beginning of your program, which would
    allow you to call the methods by omitting the `java.util` part of the command.
    See the following example highlighting this technique:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以稍微干净一些的方式编写代码，可以在程序开始时导入整个`java.util.Arrays` API，这将允许您通过省略命令中的`java.util`部分来调用方法。以下示例突出了这一技术：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The outcome will be:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you were to make a new array that you wanted to be filled up with the same
    data for all cells, there is the possibility of calling the `java.util.Arrays.fill()`
    method, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要创建一个新数组，希望所有单元格都填充相同的数据，可以使用`java.util.Arrays.fill()`方法，如下所示：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Such a command would create an array filled with zeros:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的命令将创建一个填充为零的数组：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Creating arrays with prefilled data can also be done with a copy of a preexisting
    array. It is possible to create an array by copying part of one array, or by instantiating
    a larger one where the old one would just be part of it. Both methods are shown
    in the following example, which you can test in your editor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有数组的副本也可以创建带有预填充数据的数组。可以通过复制一个数组的部分来创建一个数组，或者实例化一个更大的数组，其中旧数组只是它的一部分。以下示例展示了这两种方法，您可以在您的编辑器中测试：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example will print the `numbers`, `shortNumbers` (which is shorter), and
    `longNumbers` (which is longer) arrays. The newly added positions in the array
    will be filled with zeros. If it was an array of strings, they would be filled
    up with `null`. The outcome of this example is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将打印`numbers`、`shortNumbers`（较短）和`longNumbers`（较长）数组。数组中新添加的位置将被零填充。如果它是一个字符串数组，它们将被`null`填充。此示例的结果是：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can compare arrays by calling the `java.utils.Arrays.equals()` or `java.util.Arrays.deepEquals()`
    methods. The difference between them is that the latter can look through nested
    arrays. A simple comparison example of the former method in use follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`java.utils.Arrays.equals()`或`java.util.Arrays.deepEquals()`方法来比较数组。它们之间的区别在于后者可以查看嵌套数组。以下是一个使用前者的简单比较示例：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we create four arrays: `numbers1`, `numbers2`, `numbers3`,
    and `numbers4`. Only two of them are the same, containing three instances of `1`.
    In the example, you can see how the last three arrays are compared to the first
    one. You can also see how the last array differs not in content, but in size.
    The outcome of this code is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了四个数组：`numbers1`、`numbers2`、`numbers3`和`numbers4`。其中只有两个数组相同，包含三个`1`的实例。在示例中，您可以看到最后三个数组是如何与第一个数组进行比较的。您还可以看到最后一个数组在内容上没有区别，但大小不同。此代码的结果是：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since this chapter is not looking into such a complex data structure as nested
    arrays, we will not show an example of `java.util.Arrays.deepEquals()`. If you're
    interested, you should consider checking the Java reference at [https://packt.live/2MuRrNa](https://packt.live/2MuRrNa).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章没有探讨像嵌套数组这样复杂的数据结构，因此我们不会展示`java.util.Arrays.deepEquals()`的示例。如果您感兴趣，应该考虑查阅[https://packt.live/2MuRrNa](https://packt.live/2MuRrNa)上的Java参考文档。
- en: 'Searching within arrays is done through different algorithms behind the scenes.
    It is obviously a lot faster to perform searches on sorted arrays than on unsorted
    ones. The method to be invoked to run such a search on a sorted array is `Arrays.binarySearch()`.
    As it has many possible parameter combinations, it is recommended to visit the
    official documentation for the method. The following example illustrates how it
    works:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中进行搜索是通过后台的不同算法完成的。显然，在排序数组上执行搜索比在未排序数组上要快得多。要在排序数组上运行此类搜索，应调用`Arrays.binarySearch()`方法。由于它有许多可能的参数组合，建议访问该方法的官方文档。以下示例说明了它是如何工作的：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code is going to search for the word `the` inside the array text. The
    result is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在数组text中搜索单词`the`。结果是：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is wrong! `binarySearch` is an optimized search algorithm within the collections
    framework, but it is not optimal when used with unsorted arrays. This means that
    `binarySearch` is mainly very useful for determining whether an object can be
    found within an array (by sorting it first). At the same time, we will need a
    different algorithm when we must search through unsorted arrays and when there
    are multiple occurrences of a value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的！`binarySearch`是集合框架内的优化搜索算法，但与未排序数组一起使用时并不最优。这意味着`binarySearch`主要用于确定是否可以在数组中找到对象（通过先对其进行排序）。同时，当我们必须搜索未排序的数组或存在多个值时，我们需要不同的算法。
- en: 'Try the following modification of the previous example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下对先前示例的修改：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The outcome, since the array is sorted, will be:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组已排序，结果将是：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is only a coincidence in this case that "`is`" happens to be in the same
    place in the unsorted and the sorted versions of the array. Making use of the
    tools you've been learning about, it should be possible for you to create an algorithm
    that can iterate throughout an array and count all the existing items, even if
    they are repeated, as well as locating their positions within the array. See *Activity
    1*, *Searching for Multiple Occurrences in an Array* in this chapter, where we
    challenge you to write such a program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，"`is`"恰好出现在未排序和排序数组版本中的相同位置只是一个巧合。利用您一直在学习的工具，您应该能够创建一个算法，该算法可以遍历数组并计算所有现有项目，即使它们是重复的，以及它们在数组中的位置。请参阅本章中的*活动1*，*在数组中搜索多个出现*，其中我们挑战您编写这样的程序。
- en: You can also transform objects of the `java.util.Arrays` class into strings
    with the `Arrays.toString()` method, as we saw at the beginning of this section,
    into a list with `Arrays.asList()` (we will see this in a later section, as well
    as in `Example05`) or into a set with `Arrays.setAll()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`java.util.Arrays`类的`Arrays.toString()`方法将对象转换为字符串，就像我们在本节开头看到的那样，使用`Arrays.asList()`（我们将在后面的章节中看到，以及`Example05`）或使用`Arrays.setAll()`转换为集合。
- en: 'Arrays and collections play important roles in software development. This section
    of the chapter dives into the differences between them as well as how they can
    be used together. If you search the internet for the relationship between these
    two constructs, most references you find will be focused on the differences, such
    as:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和集合在软件开发中扮演着重要的角色。本章的这一部分深入探讨了它们之间的区别以及它们如何一起使用。如果你在网上搜索这两个构造之间的关系，你找到的大多数参考资料都将集中在它们的区别上，例如：
- en: Arrays have fixed sizes, while collections have variable sizes.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组有固定的大小，而集合有可变的大小。
- en: Arrays can hold objects of any kind, but also primitives; collections cannot
    contain primitives.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以持有任何类型的对象，也可以持有原始数据类型；集合不能包含原始数据类型。
- en: Arrays will hold homogeneous elements (elements that are all the same nature),
    while collections can hold heterogeneous elements.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组将持有同质元素（所有元素性质相同），而集合可以持有异质元素。
- en: Arrays have no underlying data structure, while collections are implemented
    using standard structures.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组没有底层的数据结构，而集合使用标准结构实现。
- en: If you know the amount of data you are going to be dealing with, arrays are
    the preferred tool, mainly because arrays perform better than lists or sets in
    such cases. However, there will be countless occasions when you don't know the
    amount of data you will be dealing with, which is where lists will be handy.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你将要处理的数据量，数组是首选的工具，主要是因为在这种情况下数组的表现优于列表或集合。然而，会有无数的情况，你不知道你将要处理的数据量，这时候列表就会变得很有用。
- en: 'Also, arrays can be used to programmatically populate collections. We will
    be doing this throughout this chapter as a way of saving you the time of having
    to manually type all the data that will end up inside a collection, for example.
    The following example shows how to populate a set using an array:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数组还可以用于以编程方式填充集合。我们将在本章中这样做，以节省你手动输入最终将存储在集合中的所有数据的时间，例如。以下示例显示了如何使用数组填充一个集合：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this program, there is an array of `Integer` used to initialize an object
    of the `HashSet` class, which is later printed out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，有一个`Integer`类型的数组被用来初始化`HashSet`类的一个对象，这个对象随后被打印出来。
- en: 'The outcome of this example is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果是：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous code listing shows a couple of interesting things. First of all,
    you will notice that the output to the program is sorted; that is because the
    conversion of the array to a list using `Arrays.asList()` will make the dataset
    inherit the properties of a list, which means that it will be sorted. Also, since
    the data has been added to a set and sets do not include duplicates, duplicate
    number two is left out.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例显示了几个有趣的事情。首先，你会注意到程序输出的结果是排序的；这是因为使用`Arrays.asList()`将数组转换为列表会使数据集继承列表的性质，这意味着它将是排序的。此外，由于数据已经添加到集合中，而集合不包含重复项，所以第二个重复的数字被省略了。
- en: 'It is important to note that with collections, you can specify the type to
    be stored. As such, there would be a difference between the declaration in the
    previous example, where we displayed a generic declaration, and what follows.
    The type is declared here using the name given within angle brackets, `<>`. In
    this case, it is `<Integer>`. You could rewrite the instantiation of the object
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用集合，你可以指定要存储的类型。因此，在之前的示例中，我们展示了泛型声明，以及接下来的声明之间会有所不同。类型在这里使用尖括号内的名称声明，即`<>`。在这种情况下，它是`<Integer>`。你可以将对象的实例化重写如下：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will see that the result of executing the program will be the same.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现程序执行的结果将是相同的。
- en: 'Activity 1: Searching for Multiple Occurrences in an Array'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1：在数组中搜索多个出现
- en: 'Write a program that will search for multiple occurrences of a certain word
    in an array of strings, where each one of the objects is a single word. Use the
    following array, a famous quote by Frank Zappa, as a point of departure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，用于在字符串数组中搜索某个单词的多个出现，其中每个对象都是一个单独的单词。以下是一个著名的弗兰克·扎帕语录的数组，作为出发点：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The word to search for is `so`. but you will have to consider that it shows
    up twice and that one instance is not in lowercase. As a hint, the method to compare
    two strings without looking at the specific casing of any of the letters in them
    is `text1.compareToIgnoreCase(text2)`. To do so, perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索的单词是 `so`，但您必须考虑到它出现了两次，并且其中一个实例不是小写。作为一个提示，比较两个字符串而不看它们中任何字母的具体大小写的方方法是
    `text1.compareToIgnoreCase(text2)`。为此，请执行以下步骤：
- en: Create the `text` array.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `text` 数组。
- en: 'Create the variable that contains the word to be searched for: `so`'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含要搜索的单词的变量：`so`
- en: Initialize the variable `occurrence` to -1.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量 `occurrence` 初始化为 -1。
- en: Create a for loop to iterate through the array to check for the occurrence.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环来遍历数组以检查出现。
- en: 'That will give the following result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下结果：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 538.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 538 页找到。
- en: Sets
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Sets within the collections framework are the programmatic equivalent of mathematical
    sets. This means that they can store objects of a specific type while avoiding
    duplicates. In the same way, sets offer methods that will let you handle data
    as you would in mathematics. You can add objects to a set, check whether a set
    is empty, combine the elements of two sets to add all their elements into a single
    set, see what objects coincide with each other between two sets, and calculate
    the difference between two sets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架中的集合是数学集合的程序等效。这意味着它们可以存储特定类型的对象，同时避免重复。同样，集合提供的方法将允许您以数学的方式处理数据。您可以将对象添加到集合中，检查集合是否为空，将两个集合的元素合并以将所有元素添加到单个集合中，查看两个集合之间有什么对象是相同的，以及计算两个集合之间的差异。
- en: 'In the `java.util.Sets` class, we find three interfaces used to represent sets:
    `HashSet`, `TreeSet`, and `LinkedHashSet`. The differences between them are straightforward:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.Sets` 类中，我们发现有三个接口用于表示集合：`HashSet`、`TreeSet` 和 `LinkedHashSet`。它们之间的区别是直接的：
- en: '`HashSet` will store data without guaranteeing the order of iteration.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet` 将存储数据，但不保证迭代顺序。'
- en: '`TreeSet` orders a set by value.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreeSet` 按值对集合进行排序。'
- en: '`LinkedHashSet` orders a set by arrival time.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedHashSet` 按到达时间对集合进行排序。'
- en: 'Each of these interfaces is meant to be used under specific circumstances.
    Let''s look at a couple of examples of sets, departing from the one in `Example05`,
    and look at how we can add other methods to check how to operate sets. The first
    step is populating a set from an array. There are several methods for doing so;
    let''s use the one that is probably the quickest to implement:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口都旨在在特定情况下使用。让我们从 `Example05` 中的集合出发，看看我们如何添加其他方法来检查如何操作集合。第一步是从数组中填充集合。有几种方法可以做到这一点；让我们使用最快速实现的方法：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The above line of code shows how to add all the elements of the array to the
    set; when printing the results, we get:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行显示了如何将数组的所有元素添加到集合中；当打印结果时，我们得到：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Please note that the order of the resulting print may vary for you. As explained
    earlier, `HashSet`, because of the way it is implemented, cannot guarantee any
    sorting of the content. If you performed the following example using `Integer`
    instead of `String` for the data, it would end up being sorted:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出的顺序可能因您而异。如前所述，`HashSet` 由于其实现方式，无法保证内容的任何排序。如果您使用 `Integer` 而不是 `String`
    作为数据执行以下示例，最终结果将是排序的：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result of this program is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的结果如下：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means that the results end up being sorted, even if we don't request it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着结果最终是排序的，即使我们没有请求它。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that the set in this example is sorted is a mere coincidence. Please
    be aware that this may not be the case in other situations. `Example08` will show
    the union operation between two sets, and there the data will not be sorted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，集合是排序的只是一个巧合。请意识到在其他情况下可能并非如此。`Example08` 将展示两个集合之间的并集操作，那里的数据将不会排序。
- en: 'Working with sets involves working with packages of data and performing operations
    with them. The union operation for two sets is displayed in the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合一起工作涉及处理数据包并对其执行操作。以下示例显示了两个集合的并集操作：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This program will print, as its output, the resulting set from the union of
    the two sets described by the two arrays at the beginning of the main method of
    the example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将打印出两个数组在示例主方法开头描述的集合的并集的结果：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Besides `HashSet`, we also find `TreeSet`, and here is where data will be sorted
    by value. Let''s simply change the types of the sets in the previous example and
    see the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`HashSet`，我们还发现`TreeSet`，在这里数据将按值排序。让我们简单地改变上一个例子中集合的类型，看看结果：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This, when changed in the previous example, will give the following sorted
    set as a result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当在上一个例子中改变时，这将给出以下排序后的集合作为结果：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You might be wondering about the pros and cons of using each type of set. When
    sorting, you are trading speed for tidiness. Therefore, if you are working with
    large sets of data and speed is a concern, you will have to decide whether it
    is more convenient to have the system operate faster, or have the results sorted,
    which would allow faster binary searches through the dataset.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道使用每种类型集合的优缺点。在排序时，你是在速度和整洁之间做权衡。因此，如果你正在处理大量数据且速度是一个问题，你必须决定是让系统运行得更快，还是让结果排序，这样就可以更快地通过数据集进行二分搜索。
- en: 'Given this last modification, we could perform other operations with the data,
    such as the intersection operation, which is invoked with the `set1.retainAll(set2)`
    method. Let''s see it in action:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 给了最后一个修改，我们可以对数据进行其他操作，例如交集操作，该操作通过`set1.retainAll(set2)`方法调用。让我们看看它的实际效果：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the output, given that the arrays are used to populate the arrays, we will
    get only those numbers that exist in both arrays; in this case, it is just the
    number `79`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出，由于数组被用来填充数组，我们只会得到存在于两个数组中的那些数字；在这种情况下，只是数字`79`：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The third type of set, `LinkedHashSet`, will sort the objects in order of their
    arrival. To demonstrate this behavior, let's make a program that will add elements
    to the set one by one using the `set.add(element)` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型的集合，`LinkedHashSet`，将按对象到达的顺序对对象进行排序。为了演示这种行为，让我们编写一个程序，该程序将使用`set.add(element)`命令逐个向集合中添加元素。
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When running this example, the result will be sorted by the way the data arrived
    in the set:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个例子时，结果将按数据到达集合的方式排序：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the sake of experimentation, use the next 2 minutes to chalk out the set
    construction into `HashSet` once more:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验，请用接下来的2分钟再次将集合构造为`HashSet`：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result of this modified program is uncertain. For example, we get:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改后的程序的结果是不确定的。例如，我们得到：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is, again, an unsorted version of the same set of data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是同一组数据的未排序版本。
- en: To close our explanation of the possible methods that you can use with sets,
    let's use `LinkedHashSet` to run an experiment where we will find the difference
    between two sets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们对你可以与集合一起使用的可能方法的解释，让我们使用`LinkedHashSet`运行一个实验，我们将找到两个集合之间的差异。
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this case, both sets are slightly different, and by determining the difference,
    the algorithm behind `set1.removeAll(set2)` will look for the occurrences of each
    item in `set2` within `set1` and eliminate them. The result of this program is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个集合略有不同，通过确定差异，`set1.removeAll(set2)`算法背后的算法将在`set1`中查找`set2`中每个项目的出现，并将它们消除。这个程序的结果是：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, if you just want to check whether the whole of a set is contained within
    another set, you can call the `set1.containsAll(set2)` method. We'll leave that
    for you to explore – just be aware that the method simply responds with a Boolean
    stating whether the statement is true or false.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你只想检查一个集合是否完全包含在另一个集合中，你可以调用`set1.containsAll(set2)`方法。我们将把这个留给你去探索——只需注意，该方法简单地返回一个布尔值，表示该语句是真是假。
- en: Lists
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are ordered collections of data. Unlike sets, lists can have repeated
    data. Having data contained within lists allows you to perform searches that will
    give the locations of certain objects within a given list. Given a position, it
    is possible to directly access an item in a list, add new items, remove items,
    and even add full lists. Lists are sequential, which makes them easy to navigate
    using iterators, a feature that will be explored in full in a later section in
    the chapter. There are also some methods for performing range-based operations
    on sublists.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的数据集合。与集合不同，列表可以有重复的数据。在列表中包含数据允许你执行搜索，这将给出给定列表中某些对象的位置。给定一个位置，你可以直接访问列表中的项目，添加新项目，删除项目，甚至添加完整的列表。列表是顺序的，这使得它们很容易通过迭代器进行导航，这一特性将在本章后面的部分中详细探讨。还有一些方法可以对子列表执行基于范围的操作。
- en: 'There are two different list implementations: `ArrayList` and `LinkedList`.
    Each of them is ideal depending on the circumstances. Here, we will work with
    `ArrayList` mainly. Let''s start by creating and populating an instance, then
    search for a certain value, and given its location within the list, we''ll print
    out the value.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的列表实现：`ArrayList`和`LinkedList`。根据情况，每个都是理想的。在这里，我们将主要使用`ArrayList`。让我们首先创建并填充一个实例，然后搜索列表中的某个值，并根据其在列表中的位置打印出该值。
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this example is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `indexOf` method informs you about the location of an object passed to the
    method as a parameter. It's sibling method, `lastIndexOf`, reports the location
    of the last occurrence of an object in the list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`方法会告诉你传递给方法的对象的位置。它的兄弟方法`lastIndexOf`报告列表中对象的最后一个出现位置。'
- en: You should look at a list as a series of nodes connected by links. If one of
    the nodes is eliminated, the link that used to point to it will be redirected
    to the following item in the list. When adding nodes, they will be attached by
    default at the end of the list (if they are not duplicated). As all the nodes
    in the collection are of the same type, it should be possible to exchange the
    locations of two nodes in a list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将列表视为由链接连接的一系列节点。如果一个节点被消除，曾经指向它的链接将被重定向到列表中的下一个项目。当添加节点时，它们默认附加到列表的末尾（如果它们不是重复的）。由于集合中的所有节点都是同一类型，因此应该可以在列表中交换两个节点的位置。
- en: 'Let''s experiment with removing an item from a list and ascertaining the locations
    for objects located immediately before and after the removed item:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实验一下从列表中删除一个项目，并确定删除项目前后立即定位的对象的位置：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This program creates a list, prints it out, looks for a node in the list, and
    prints its location. Then, it removes an item in the list and repeats the previous
    process to show that the node has been removed from the list. This is a clear
    difference from the case with arrays, where it is not possible to remove items
    from them, and thus it is not possible to change their size. Observe the output
    of the previous example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建了一个列表，将其打印出来，然后在列表中查找一个节点并打印其位置。然后，它从列表中删除一个项目，并重复之前的步骤以显示该节点已从列表中删除。这与数组的情况明显不同，在数组中无法删除项目，因此无法更改其大小。观察前一个示例的输出：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is also possible to change the content of a node. In the previous example,
    instead of removing a node, change `list.remove(index-1);` to the following and
    check the outcome:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以更改节点的内容。在前面的示例中，不是删除节点，而是将`list.remove(index-1);`更改为以下内容并检查结果：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The final array will have substituted `11` for `99`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最终数组将用`11`替换`99`。
- en: 'If instead of deleting one node, you wanted to empty the whole list, the command
    to the issue would be:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想删除一个节点，而是想清空整个列表，那么向其发出的命令将是：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using `subList()`, an operator that generates lists from lists, it is possible
    to, for example, delete a range of cells within a list. See the following example,
    which deletes part of a string array, changing its meaning when printing it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`subList()`操作符，可以从列表生成列表，例如，可以删除列表中一系列单元格。请看以下示例，它删除了字符串数组的一部分，在打印时改变了其含义：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Look at the following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下结果：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `list` object has been modified by running the example code so that it becomes
    shorter. The two index numbers used in the `subList()` method is the places in
    the list where the method starts and stops. The result of `subList()` can also
    be assigned to a different variable of the same `List` type, resulting in a reduced
    copy of the list in the code, after performing the `subList()` operation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行示例代码修改了`list`对象，使其变短。`subList()`方法中使用的两个索引数字是列表中方法开始和停止的位置。`subList()`的结果也可以分配给相同类型的另一个变量，在执行`subList()`操作后，代码中的列表将减少一个副本。
- en: 'Look at the following modification in the latest code listing:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看看最新代码列表中的以下修改：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will print out the list that was made of the nodes that were deleted in
    the previous example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出由前一个示例中删除的节点组成的列表。
- en: 'There are a lot of interesting algorithms within the collections framework
    that offers relevant functionality for operating with lists:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架中有许多有趣的算法，提供了操作列表的相关功能：
- en: '`sort`: Put the elements of a list in a certain order.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`：将列表的元素按特定顺序排列。'
- en: '`shuffle`: Randomize the locations of all objects in a list.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shuffle`：随机化列表中所有对象的位置。'
- en: '`reverse`: Invert the order of a list.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse`：反转列表的顺序。'
- en: '`rotate`: Move objects to the end of a list, and when they reach the end, have
    them show up at the other end.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate`：将对象移动到列表的末尾，当它们到达末尾时，在另一端显示。'
- en: '`swap`: Swap two elements with one another.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap`：交换两个元素。'
- en: '`replaceAll`: Replace all occurrences of an element in a list using a parameter.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceAll`：使用参数替换列表中所有元素的出现。'
- en: '`fill`: Fill the content of a list with one value.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`：使用一个值填充列表的内容。'
- en: '`copy`: Make more instances of a list.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`：创建列表的更多实例。'
- en: '`binarySearch`: Perform optimized searches within a list.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binarySearch`：在列表中执行优化的搜索。'
- en: '`indexOfSubList`: Search for the occurrence of a piece (a set of consecutive
    nodes) of a list.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOfSubList`：搜索列表中某个片段（一组连续节点）的出现。'
- en: '`lastIndexOfSubList`: Search for the last occurrence of a piece of a list.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOfSubList`：搜索列表中某个片段的最后一个出现位置。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Lists generated from arrays using `Arrays.asList()` do not behave in the same
    way as the objects of the `List` class described in this section. The lists coming
    from arrays have a fixed length, which means that elements cannot be removed from
    the array. The reason for this is that `java.util.Arrays` implement its own `ArrayList`
    class inside the package, one that is different from the one in the collections
    framework. Confusing, isn't it?
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `Arrays.asList()` 从数组生成的列表与本章中描述的 `List` 类对象的行为不同。来自数组的列表具有固定长度，这意味着无法从数组中删除元素。这是因为
    `java.util.Arrays` 在包内部实现了自己的 `ArrayList` 类，它与集合框架中的类不同。这不是很令人困惑吗？
- en: 'Exercise 1: Creating the AnalyzeInput Application'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：创建 AnalyzeInput 应用程序
- en: 'In this exercise, we will create a new application that will respond to the
    CLI by storing whatever strings are provided to it, then run some statistical
    operations on the data, such as word counting (determining the most frequent word
    or the most frequent letter, and so on). The intent is to give you an idea of
    how to use the collections framework instead of other tools to do such operations.
    This time, we will do something special; instead of getting the data from the
    CLI as arguments to the script, we will use the `java.io.Console` API, which allows
    the reading of different types of strings from the terminal, such as usernames
    (plain strings) and passwords. The goal of this application is to read the input
    until a line with only the "`*`" symbol (asterisk) is captured. Once the termination
    symbol is entered, the text will be processed, and the statistics will be delivered
    to the terminal:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的应用程序，该应用程序将通过存储提供给它的任何字符串来响应 CLI，然后对数据进行一些统计操作，例如单词计数（确定最频繁的单词或最频繁的字母等）。目的是让你了解如何使用集合框架而不是其他工具来完成此类操作。这次，我们将做一些特别的事情；而不是从
    CLI 作为脚本的参数获取数据，我们将使用 `java.io.Console` API，它允许从终端读取不同类型的字符串，例如用户名（普通字符串）和密码。这个应用程序的目标是读取输入，直到捕获到只有
    "`*`" 符号（星号）的行。一旦输入了终止符号，文本将被处理，并将统计结果发送到终端：
- en: Open IntelliJ and create a new Java program using the CLI template. Name the
    project `AnalyzeInput`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IntelliJ 并使用 CLI 模板创建一个新的 Java 程序。将项目命名为 `AnalyzeInput`。
- en: 'Start by creating a simple program that can read a line from the terminal and
    printing it out:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个简单的程序，可以从终端读取一行并将其打印出来：
- en: '[PRE49]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Execute the program from the CLI by calling `java AnalyzeInput` from the right
    folder and interact with it:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 CLI 中执行程序，通过在正确的文件夹中调用 `java AnalyzeInput` 来与之交互：
- en: '[PRE50]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You must import `java.io.Console`, which allows you to instantiate objects of
    the `Console` class. You can also see the call to `cons = System.console()`, which
    will make sure that the terminal is ready for you to read the data, and `line
    = cons.readLine()`, which will ensure that when hitting the *Enter* key on the
    keyboard, the resulting data is not empty.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须导入 `java.io.Console`，这允许您实例化 `Console` 类的对象。您还可以看到对 `cons = System.console()`
    的调用，这将确保终端已准备好供您读取数据，以及 `line = cons.readLine()`，这将确保在按下键盘上的 *Enter* 键时，结果数据不为空。
- en: 'The next step is storing the data we are capturing in a collection. Since we
    don''t know the size this could be, we should be using `ArrayList <String>` to
    store the data. Also, to store data for as long as we want, we can modify the
    `if` statement and make it into a `while` loop. Finally, use the `add` method
    to add the lines into a list (note that the following code listing will never
    exit, so bear with us and do not execute it yet):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Modify the `while` loop to include the condition we established for finishing
    the data capture process – the arrival of a line with only an asterisk symbol:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The outcome will happen only when you type the asterisk symbol alone in a line,
    as seen in this log while interacting with the program:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since we used `ArrayList` to store the different strings, you could be typing
    until you exhaust the computer''s memory. Now it is possible to execute some commands
    to work with the strings. The first step will be turning the whole of the text
    into a list. This will require going through the different strings and splitting
    them into parts that will be added to a larger list. The easiest trick is to use
    the `split()` method using a whitespace character as a separator. Modify the `main`
    method to look like the following, and you will see that the result is now a list
    with all the words separated as single nodes in the list:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Having all the data stored in this way allows for the use of a lot of the methods
    available in the collections framework that will let you do operations with data.
    Let''s start by counting all the words in the text (including the closing symbol,
    "`*`"). Just add the following at the end of the `main` method:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The result of this exercise is a program that is ready to be used for further
    analysis of the data. But in order to continue doing so, we need to make use of
    a tool that has not yet been introduced—the iterator. We will come back to this
    example later in the chapter and finish off the application by adding some extra
    functionality to it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collections framework offers one more interface, `java.util.Map`, which
    can be used when dealing with data that is stored as key-value pairs. This type
    of data storage is becoming more and more relevant as data formats such as JSON
    are slowly taking over the internet. JSON is a data format that is based on having
    data stored in the form of nested arrays that always respond to the key-value
    structure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Having data organized in this way offers the possibility of having a very simple
    way to look for data – by means of the keys instead of using, for example, an
    index, as we would do in an array. Keys are the way we can identify the block
    of data we are looking for within a map. Let''s look at a simple example of a
    map before looking at alternatives to maps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to create a simple map and how to print some
    messages based on the information available within it. The first thing that you
    will notice in comparison to other interfaces in the collections framework is
    that we do not *add* elements to the map – we *put* elements in the map. Also,
    elements have two parts: the **key** (in our case, we are using strings) and the
    **value** (which can be heterogeneous in nature):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This program will give the following result:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since there is no key named "`bytes`" in the code, the `maps.containsKey()`
    method will answer accordingly, and the program will inform the user about it.
    The main methods available in this interface are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`put` (Object key, Object value)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putAll` (Map map)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove` (Object key)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get` (Object key)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsKey` (Object key)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keySet()`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entrySet()`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All but the last two are self-explanatory. Let''s focus on augmenting our previous
    example to see what those two methods do. Make the following addition to the code
    to see what `keySet()` and `entrySet()` have to offer:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The outcome of the modified code listing will be:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In other words, `entrySet()` will print the whole map using the key = value
    formula, while `keySet()` will respond with the set of keys within the map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have realized this by now: keys must be unique – there cannot be
    two of the same keys in a map.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not go deeper into maps at this point because they are, to an extent,
    a repetition of what we saw with sets. There are three different classes for maps:
    `HashMap`, `TreeMap`, and `LinkedHashMap`. The last two are put in order, while
    the first one is neither sorted nor arranged in order of arrival. You should use
    these classes according to your needs.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through Collections
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, when working with *Exercise 01, Creating the AnalyzeInput
    Application* we stopped when we were about to make searches through the data.
    We made it to the point where we had to iterate through the data and look for
    characteristics such as word frequency.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are used in Java to browse through collections. Let's look at a simple
    example that involves extracting the elements from a simple list one by one and
    printing them out.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of this program is:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Iterators such as this one are the most generic ones in the collections framework
    and can be used with lists, sets, queues, and even maps. There are other less-broad
    implementations of the iterators that allow for different ways to browse through
    data, for example, in lists. As you saw in the latest code listing, the `iterator.hasNext()`
    method checks whether there is a node after the one we are at in the list. When
    starting the iterator, the object points to the first element in the list. Then,
    `hasNext()` responds with a Boolean stating whether there are more nodes hanging
    from it. The `iterator.next()` method will move the iterator to the following
    node in the collection. This kind of iterator does not have the possibility of
    going back in the collection; it can only move forward. There is one final method
    in the iterator, called `remove()`, which will eliminate the current element that
    the iterator is pointing to from the collection.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used `listIterator()` instead, we would have had a lot more options for
    navigating collections, such as adding new elements and changing elements. The
    following code listing demonstrates how to go through a list, add elements, and
    modify them. `listIterator` works only with lists:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this example, we create a list of `Double`, iterate through the list, and
    round up each of the numbers. The outcome of this program is:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: By calling `listIterator.set()`, we modify each of the items in the list and
    the second `System.out.println()` command shows where the numbers have been rounded
    up or down.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The final iterator example we are going to see in this section is a trick to
    iterate through a map. This could come in handy in scenarios where you want to
    perform some operations on data within a map. By using the `entrySet()` method
    – which returns a list – it is possible to have an iterator over a map. See the
    following example to understand how this works:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This program will iterate through a map and print the contents as they were
    stored in `HashMap`. Remember that these types of objects are not sorted in any
    specific way. You can expect an output like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Given that we now have ways to iterate through collections, we can move on
    to an exercise that picks up where we left off: iterating through a list for data
    analysis.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Bringing Analytics into the AnalyzeInput Application'
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start from where we left off at the end of *Exercise 1*, *Creating
    the AnalyzeInput Application*. We managed to capture the text typed in the terminal
    and store it as a list of strings. This time, we are going to use a method from
    the collections framework called `frequency`, which will respond with the number
    of times a certain object can be found inside a list. As words could be repeated
    in a sentence, we first need to figure out a way to extract the unique elements
    in a list:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are objects in the collections framework that keep only one copy of each
    element. We saw an example of this earlier in the chapter. We will create a `HashSet`
    instance and copy all the elements from the list into it. This will automatically
    eliminate duplicates:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The next step, now that we have the set, is to create an iterator that will
    check how many copies of each element from the set can be found in the list:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Using the same technique that we saw in previous examples for how to iterate
    through a set, we will find the next node in the set and check in the list for
    the frequency of the string stored in the node:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final code can be referred at: [https://packt.live/2BrplvS](https://packt.live/2BrplvS).'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The outcome will depend on the kind of text you type. For the sake of testing,
    try the following (we will stick to this data entry for the rest of the chapter
    – you can copy and paste it to the terminal each time you call the application):'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The full outcome of this input will be:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: While the result is correct, it is not easy to read through. Ideally, results
    should be sorted. For example, by descending values of frequency, so that it is
    easy to see at a glance the most and least frequent words. This is the time to
    make yet another stop in the exercise as we need to introduce the idea of sorting
    before we move on with it.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sorting Collections
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, there are some classes in the collections framework that force
    the items within them to be sorted. Examples of that are `TreeSet` and `TreeMap`.
    The aspect to explore in this section is how to use existing sorting mechanisms
    for lists, but also for cases that have datasets with more than one value per
    data point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The exercise we are doing throughout this chapter is a good example of a case
    where there are data points with more than one value. For each data point, we
    need to store the word for which we are calculating the frequency and the frequency
    itself. You might think that a good technique to sort that out is by storing the
    information in the form of maps. The unique words could be the keys, while the
    frequencies could be the values. This could be achieved by modifying the final
    part of the previous program to look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'While this is an interesting and simple approach to sorting (copying the data
    into a structure that is sorted by nature), it presents the problem that data
    is sorted by key and not by value, as the following result of the previous code
    highlights:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So, if we want to sort these results by value, we need to figure out a different
    strategy.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s step back for a second and analyze what tools are offered in the
    collections framework for sorting. There is a method called `sort()` that can
    be used to sort lists. An example of this is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The result of this program is:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Given a list, we could sort it this way just fine; it would even be possible
    to navigate through it backward using `listIterator` to sort a list in descending
    order. However, these methods do not solve the issue of sorting data points with
    multiple values. In such a case, we would need to create a class to store our
    own key-value pair. Let's see how to implement this by continuing with the exercise
    we have been dealing with throughout the chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Sort the Results from the AnalyzeInput Application'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have a program that, given some input text, identifies some basic characteristics
    of the text, such as the number of words in the text or the frequency of each
    of the words. Our goal is to be able to sort the results in descending order to
    make them easier to read. The solution will require the implementation of a class
    that will store our key-value pairs and make a list of objects from that class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class containing the two data points: the word and its frequency.
    Implement a constructor that will take values and pass them to class variables.
    This will simplify the code later:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When calculating the frequency for each word, store the results in a newly
    created list of objects of the new class:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Sorting is going to require the creation of a new class using the `Comparator`
    interface, which we are just introducing now. This interface should implement
    a method that will be used to run comparisons within the objects in the array.
    This new class must implement `Comparator <DataPoint>` and include a single method
    called `compare()`. It should have two objects of the class being sorted as parameters:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The way we call the `Collections.sort()` algorithm using this new comparator
    is by adding an object of that class as a parameter to the `sort` method. We instantiate
    it directly in the call:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This will sort the frequencies list in ascending order. To print the results,
    it is no longer valid to make a direct call to `System.out.println(frequencies)`
    because it is now an array of objects and it will not print the contents of the
    data points to the terminal. Iterate through the list in the following way instead:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you run the program using the same input that we have been using for the
    last couple of examples, the outcome will be:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Our goal is to sort the results in descending order and, to do that, we will
    need to add one more thing to the call to the `sort` algorithm. When instantiating
    the `SortByValue()` class, we need to tell the compiler that we want the list
    to be sorted in reverse order. The collections framework already has a method
    for this:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the sake of clarity, the final code can be referred at: [https://packt.live/2W5qhzP](https://packt.live/2W5qhzP).'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A full interaction path with this program, from the moment we call it to include
    the data entry, would be as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Properties
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Properties in the collections framework are used to maintain lists of key-value
    pairs where both are of the `String` class. Properties are relevant when obtaining
    environmental values from the operating system, for example, and are the grounding
    class for many other classes. One of the main characteristics of the `Properties`
    class is that it allows the definition of a default response in the case of a
    search for a certain key not being satisfactory. The following example highlights
    the basics of this case:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Before diving into the results, you will notice that in properties, we put rather
    than add new elements/nodes. This is the same as we saw with maps. Also, you will
    have noticed that to iterate, we used the `keySet()` technique that we saw when
    iterating through maps earlier. Finally, the particularity of `Properties` is
    that you can set a default response in the case of the searched-for property not
    being found. This is what happens in the example when searching for `getProperty()`
    method will answer with its default message without crashing the program.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this program is:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Another interesting method to be found in the `Properties` class is the `list()`;
    it comes with two different implementations that allow you to send the contents
    of a list to different data handlers. We can stream the whole properties list
    to a `PrintStreamer` object, such as `System.out`. This offers a simple way of
    displaying what is in a list without having to iterate through it. An example
    of this follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'That will result in:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `propertyNames()` method returns an `Enumeration` list, and by iterating
    through it, we will obtain the keys to the whole list. This is an alternative
    to creating a set and running the `keySet()` method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'That will result in:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The final method we will introduce you to from `Properties` at this point is
    `setProperty()`. It will modify the value of an existing key, or will eventually
    create a new key-value pair if the key is not found. The method will answer with
    the old value if the key exists, and answer with `null` otherwise. The next example
    shows how it works:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here is the outcome:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: There are more methods in the `Properties` class that deals with storing and
    retrieving lists of properties to/from files. While this is a very powerful feature
    from the Java APIs, as we haven't yet introduced the use of files in this book,
    we will not discuss those methods here. For more information at this point, please
    refer to Java's official documentation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Iterating through Large Lists'
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contemporary computing, we deal with large sets of data. The purpose of this
    activity is to create a random-sized list of random numbers to perform some basic
    operations on data, such as obtaining the average.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: To start, you should create a random list of numbers.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To compute the average, you could create an iterator that will go through the
    list of values and add the weighted value corresponding to each element.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value coming from the `iterator.next()` method must be cast into a `Double`
    before it can be weighed against the total number of elements.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''ve implemented everything properly, the results of the averaging should
    similar to:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Or, it could be:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 539.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: If you managed to make this program work, you should think about how to take
    advantage of being able to simulate large sets of data like this one. This data
    could represent the amount of time between different arrivals of data in your
    application, temperature data from the nodes in an Internet of Things network
    being captured every second. The possibilities are endless. By using lists, you
    can make the size of the dataset as endless as their working possibilities.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the Java collections framework, which is a very
    powerful tool within the Java language that can be used to store, sort, and filter
    data. The framework is massive and offers tools in the form of interfaces, classes,
    and methods, some of which are beyond the scope of this chapter. We have focused
    on `Arrays`, `Lists`, `Sets`, `Maps`, and `Properties`. But there are others,
    such as queues and dequeues, that are worth exploring on your own.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Sets, like their mathematical equivalents, store unique copies of items. Lists
    are like arrays that can be extended endlessly and support duplicates. Maps are
    used when dealing with key-value pairs, something very common in contemporary
    computing, and do not support the use of two of the same keys. Properties work
    very much like `HashMap` (a specific type of `Map`) but offer some extra features,
    such as the listing of all their contents to streams, which simplifies the printing
    out of the contents of a list.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Some of the classes offered in the framework are sorted by design, such as `TreeHash`
    and `TreeMap`, while others are not. Depending on how you want to handle data,
    you will have to decide which is the best collection.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: There are standard techniques for looking through data with iterators. These
    iterators, upon creation, will point to the first element in a list. Iterators
    offer some basic methods, such as `hasNext()` and `next()`, that state whether
    there is more data in the list and extract data from the list, respectively. While
    those two are common to all iterators, there are others, such as `listIterator`,
    that are much more powerful and allow, for example, the addition of new elements
    to a list while browsing through it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at a chapter-long example that used many of these techniques,
    and we have introduced the use of the console to read data through the terminal.
    In the next chapter, we will cover exceptions and how to handle them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
