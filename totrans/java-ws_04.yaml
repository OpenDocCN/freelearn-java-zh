- en: 4\. Collections, Lists and Java's Built-In APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the powerful Java collections framework, which
    is used to store, sort, and filter data. It will first take you through the structure
    of the built-in Collections **Application Programming Interface** (**API**), the
    Java collections framework, which will simplify your dealings with complex data
    structures and allow you to use and create APIs with minimal effort. Through this
    framework, you will examine the relationship between lists and arrays, and learn
    to populate lists from arrays. Finally, in this chapter's final activity, you
    will create and complete a program in which you will be asked to perform standard
    operations on data stored in sets, lists, and maps in preparation for future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java comes with a built-in Collections API, allowing you to manipulate data
    structures with very little effort. A collection is an object that contains multiple
    elements. Collections are used to store, share, process, and communicate aggregated
    data. We call this system the **Java collections framework**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this framework, there are different components that are used to
    optimize our interaction with the actual data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfaces**: Abstract data types that represent collections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementations**: Specific implementations of the collection interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms**: Polymorphic methods used to process the data within a collection
    for operations such as sorting and searching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other programming languages have their own collection frameworks. For example,
    C++ has the **Standard Template Library** (**STL**). Java boasts simplicity when
    it comes to its collection framework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the collections framework has many benefits, including a reduction in
    the complexity of creating programs that deal with data structures, an increase
    in the performance of programs, a simplification of API creation and use, and
    an increase in the reuse of functioning software.
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework is relevant even when handling data that can be accessed
    by several processes simultaneously, as this would be the case in multithreaded
    programming scenarios. However, it is not the intention of this chapter to deal
    with concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Collections API comes with five main interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set`: A collection that contains no duplicates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`: An ordered collection or sequence, allowing for duplicates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Queue`: A collection that sorts data in the order of its arrival, typically
    handled as a **First In First Out** (**FIFO**) process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deque`: Essentially a queue that allows for data insertion at both ends, meaning
    that it can be handled both as FIFO and **Last In First Out** (**LIFO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`: Relates keys—which must be unique—to values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will define the main interfaces (lists, sets, and maps),
    and explore examples of their respective uses. The framework has even more interfaces
    than the ones listed previously, but the others are either just variations of
    those listed or are outside the scope of this chapter. Furthermore, we will look
    at how arrays work in much more depth than we have previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a simple collection—in this case, a specific type of set
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The different available classes for sets, lists, queues, deques, and maps are
    named after the interfaces. The different classes present different properties,
    as we will see later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are part of the collections framework. There are some static methods
    that can be used to manipulate arrays. The operations you can perform are creating,
    sorting, searching, comparing, streaming, and transforming arrays. You were introduced
    to arrays in *Chapter 2*, *Learning the Basics*, where you saw how they can be
    used to store data of the same type. The declaration of an array is quite straightforward.
    Let''s see what an array of strings would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running operations on an array is as easy as calling some of the methods contained
    in the `java.util.Arrays` package. For example, sorting the previous array would
    require calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods dedicated to handling arrays include one method that could be used
    to print out full arrays as if they were strings. This can be very handy when
    debugging a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the arrays and display each element separated by commas and
    within square brackets, `[]`. If you executed the previous command after sorting
    the declared array of strings, the outcome would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the array has been sorted in ascending alphabetical order.
    There is a difference between that way of printing out an array and using a `for`
    loop to iterate throughout an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give the following as the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to write your code in a slightly cleaner way, you could import
    the whole `java.util.Arrays` API at the beginning of your program, which would
    allow you to call the methods by omitting the `java.util` part of the command.
    See the following example highlighting this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to make a new array that you wanted to be filled up with the same
    data for all cells, there is the possibility of calling the `java.util.Arrays.fill()`
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a command would create an array filled with zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating arrays with prefilled data can also be done with a copy of a preexisting
    array. It is possible to create an array by copying part of one array, or by instantiating
    a larger one where the old one would just be part of it. Both methods are shown
    in the following example, which you can test in your editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will print the `numbers`, `shortNumbers` (which is shorter), and
    `longNumbers` (which is longer) arrays. The newly added positions in the array
    will be filled with zeros. If it was an array of strings, they would be filled
    up with `null`. The outcome of this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compare arrays by calling the `java.utils.Arrays.equals()` or `java.util.Arrays.deepEquals()`
    methods. The difference between them is that the latter can look through nested
    arrays. A simple comparison example of the former method in use follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create four arrays: `numbers1`, `numbers2`, `numbers3`,
    and `numbers4`. Only two of them are the same, containing three instances of `1`.
    In the example, you can see how the last three arrays are compared to the first
    one. You can also see how the last array differs not in content, but in size.
    The outcome of this code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since this chapter is not looking into such a complex data structure as nested
    arrays, we will not show an example of `java.util.Arrays.deepEquals()`. If you're
    interested, you should consider checking the Java reference at [https://packt.live/2MuRrNa](https://packt.live/2MuRrNa).
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching within arrays is done through different algorithms behind the scenes.
    It is obviously a lot faster to perform searches on sorted arrays than on unsorted
    ones. The method to be invoked to run such a search on a sorted array is `Arrays.binarySearch()`.
    As it has many possible parameter combinations, it is recommended to visit the
    official documentation for the method. The following example illustrates how it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is going to search for the word `the` inside the array text. The
    result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is wrong! `binarySearch` is an optimized search algorithm within the collections
    framework, but it is not optimal when used with unsorted arrays. This means that
    `binarySearch` is mainly very useful for determining whether an object can be
    found within an array (by sorting it first). At the same time, we will need a
    different algorithm when we must search through unsorted arrays and when there
    are multiple occurrences of a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following modification of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome, since the array is sorted, will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is only a coincidence in this case that "`is`" happens to be in the same
    place in the unsorted and the sorted versions of the array. Making use of the
    tools you've been learning about, it should be possible for you to create an algorithm
    that can iterate throughout an array and count all the existing items, even if
    they are repeated, as well as locating their positions within the array. See *Activity
    1*, *Searching for Multiple Occurrences in an Array* in this chapter, where we
    challenge you to write such a program.
  prefs: []
  type: TYPE_NORMAL
- en: You can also transform objects of the `java.util.Arrays` class into strings
    with the `Arrays.toString()` method, as we saw at the beginning of this section,
    into a list with `Arrays.asList()` (we will see this in a later section, as well
    as in `Example05`) or into a set with `Arrays.setAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays and collections play important roles in software development. This section
    of the chapter dives into the differences between them as well as how they can
    be used together. If you search the internet for the relationship between these
    two constructs, most references you find will be focused on the differences, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays have fixed sizes, while collections have variable sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays can hold objects of any kind, but also primitives; collections cannot
    contain primitives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays will hold homogeneous elements (elements that are all the same nature),
    while collections can hold heterogeneous elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays have no underlying data structure, while collections are implemented
    using standard structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you know the amount of data you are going to be dealing with, arrays are
    the preferred tool, mainly because arrays perform better than lists or sets in
    such cases. However, there will be countless occasions when you don't know the
    amount of data you will be dealing with, which is where lists will be handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, arrays can be used to programmatically populate collections. We will
    be doing this throughout this chapter as a way of saving you the time of having
    to manually type all the data that will end up inside a collection, for example.
    The following example shows how to populate a set using an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this program, there is an array of `Integer` used to initialize an object
    of the `HashSet` class, which is later printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outcome of this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous code listing shows a couple of interesting things. First of all,
    you will notice that the output to the program is sorted; that is because the
    conversion of the array to a list using `Arrays.asList()` will make the dataset
    inherit the properties of a list, which means that it will be sorted. Also, since
    the data has been added to a set and sets do not include duplicates, duplicate
    number two is left out.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that with collections, you can specify the type to
    be stored. As such, there would be a difference between the declaration in the
    previous example, where we displayed a generic declaration, and what follows.
    The type is declared here using the name given within angle brackets, `<>`. In
    this case, it is `<Integer>`. You could rewrite the instantiation of the object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the result of executing the program will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Searching for Multiple Occurrences in an Array'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a program that will search for multiple occurrences of a certain word
    in an array of strings, where each one of the objects is a single word. Use the
    following array, a famous quote by Frank Zappa, as a point of departure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The word to search for is `so`. but you will have to consider that it shows
    up twice and that one instance is not in lowercase. As a hint, the method to compare
    two strings without looking at the specific casing of any of the letters in them
    is `text1.compareToIgnoreCase(text2)`. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `text` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the variable that contains the word to be searched for: `so`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the variable `occurrence` to -1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a for loop to iterate through the array to check for the occurrence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That will give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 538.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sets within the collections framework are the programmatic equivalent of mathematical
    sets. This means that they can store objects of a specific type while avoiding
    duplicates. In the same way, sets offer methods that will let you handle data
    as you would in mathematics. You can add objects to a set, check whether a set
    is empty, combine the elements of two sets to add all their elements into a single
    set, see what objects coincide with each other between two sets, and calculate
    the difference between two sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `java.util.Sets` class, we find three interfaces used to represent sets:
    `HashSet`, `TreeSet`, and `LinkedHashSet`. The differences between them are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashSet` will store data without guaranteeing the order of iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TreeSet` orders a set by value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinkedHashSet` orders a set by arrival time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these interfaces is meant to be used under specific circumstances.
    Let''s look at a couple of examples of sets, departing from the one in `Example05`,
    and look at how we can add other methods to check how to operate sets. The first
    step is populating a set from an array. There are several methods for doing so;
    let''s use the one that is probably the quickest to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The above line of code shows how to add all the elements of the array to the
    set; when printing the results, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that the order of the resulting print may vary for you. As explained
    earlier, `HashSet`, because of the way it is implemented, cannot guarantee any
    sorting of the content. If you performed the following example using `Integer`
    instead of `String` for the data, it would end up being sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This means that the results end up being sorted, even if we don't request it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the set in this example is sorted is a mere coincidence. Please
    be aware that this may not be the case in other situations. `Example08` will show
    the union operation between two sets, and there the data will not be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with sets involves working with packages of data and performing operations
    with them. The union operation for two sets is displayed in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will print, as its output, the resulting set from the union of
    the two sets described by the two arrays at the beginning of the main method of
    the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides `HashSet`, we also find `TreeSet`, and here is where data will be sorted
    by value. Let''s simply change the types of the sets in the previous example and
    see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This, when changed in the previous example, will give the following sorted
    set as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering about the pros and cons of using each type of set. When
    sorting, you are trading speed for tidiness. Therefore, if you are working with
    large sets of data and speed is a concern, you will have to decide whether it
    is more convenient to have the system operate faster, or have the results sorted,
    which would allow faster binary searches through the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this last modification, we could perform other operations with the data,
    such as the intersection operation, which is invoked with the `set1.retainAll(set2)`
    method. Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For the output, given that the arrays are used to populate the arrays, we will
    get only those numbers that exist in both arrays; in this case, it is just the
    number `79`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The third type of set, `LinkedHashSet`, will sort the objects in order of their
    arrival. To demonstrate this behavior, let's make a program that will add elements
    to the set one by one using the `set.add(element)` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this example, the result will be sorted by the way the data arrived
    in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of experimentation, use the next 2 minutes to chalk out the set
    construction into `HashSet` once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this modified program is uncertain. For example, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is, again, an unsorted version of the same set of data.
  prefs: []
  type: TYPE_NORMAL
- en: To close our explanation of the possible methods that you can use with sets,
    let's use `LinkedHashSet` to run an experiment where we will find the difference
    between two sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, both sets are slightly different, and by determining the difference,
    the algorithm behind `set1.removeAll(set2)` will look for the occurrences of each
    item in `set2` within `set1` and eliminate them. The result of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you just want to check whether the whole of a set is contained within
    another set, you can call the `set1.containsAll(set2)` method. We'll leave that
    for you to explore – just be aware that the method simply responds with a Boolean
    stating whether the statement is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are ordered collections of data. Unlike sets, lists can have repeated
    data. Having data contained within lists allows you to perform searches that will
    give the locations of certain objects within a given list. Given a position, it
    is possible to directly access an item in a list, add new items, remove items,
    and even add full lists. Lists are sequential, which makes them easy to navigate
    using iterators, a feature that will be explored in full in a later section in
    the chapter. There are also some methods for performing range-based operations
    on sublists.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different list implementations: `ArrayList` and `LinkedList`.
    Each of them is ideal depending on the circumstances. Here, we will work with
    `ArrayList` mainly. Let''s start by creating and populating an instance, then
    search for a certain value, and given its location within the list, we''ll print
    out the value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `indexOf` method informs you about the location of an object passed to the
    method as a parameter. It's sibling method, `lastIndexOf`, reports the location
    of the last occurrence of an object in the list.
  prefs: []
  type: TYPE_NORMAL
- en: You should look at a list as a series of nodes connected by links. If one of
    the nodes is eliminated, the link that used to point to it will be redirected
    to the following item in the list. When adding nodes, they will be attached by
    default at the end of the list (if they are not duplicated). As all the nodes
    in the collection are of the same type, it should be possible to exchange the
    locations of two nodes in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s experiment with removing an item from a list and ascertaining the locations
    for objects located immediately before and after the removed item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This program creates a list, prints it out, looks for a node in the list, and
    prints its location. Then, it removes an item in the list and repeats the previous
    process to show that the node has been removed from the list. This is a clear
    difference from the case with arrays, where it is not possible to remove items
    from them, and thus it is not possible to change their size. Observe the output
    of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to change the content of a node. In the previous example,
    instead of removing a node, change `list.remove(index-1);` to the following and
    check the outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The final array will have substituted `11` for `99`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead of deleting one node, you wanted to empty the whole list, the command
    to the issue would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `subList()`, an operator that generates lists from lists, it is possible
    to, for example, delete a range of cells within a list. See the following example,
    which deletes part of a string array, changing its meaning when printing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `list` object has been modified by running the example code so that it becomes
    shorter. The two index numbers used in the `subList()` method is the places in
    the list where the method starts and stops. The result of `subList()` can also
    be assigned to a different variable of the same `List` type, resulting in a reduced
    copy of the list in the code, after performing the `subList()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following modification in the latest code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will print out the list that was made of the nodes that were deleted in
    the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of interesting algorithms within the collections framework
    that offers relevant functionality for operating with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort`: Put the elements of a list in a certain order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shuffle`: Randomize the locations of all objects in a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse`: Invert the order of a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate`: Move objects to the end of a list, and when they reach the end, have
    them show up at the other end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap`: Swap two elements with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replaceAll`: Replace all occurrences of an element in a list using a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill`: Fill the content of a list with one value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy`: Make more instances of a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binarySearch`: Perform optimized searches within a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOfSubList`: Search for the occurrence of a piece (a set of consecutive
    nodes) of a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndexOfSubList`: Search for the last occurrence of a piece of a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lists generated from arrays using `Arrays.asList()` do not behave in the same
    way as the objects of the `List` class described in this section. The lists coming
    from arrays have a fixed length, which means that elements cannot be removed from
    the array. The reason for this is that `java.util.Arrays` implement its own `ArrayList`
    class inside the package, one that is different from the one in the collections
    framework. Confusing, isn't it?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 1: Creating the AnalyzeInput Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a new application that will respond to the
    CLI by storing whatever strings are provided to it, then run some statistical
    operations on the data, such as word counting (determining the most frequent word
    or the most frequent letter, and so on). The intent is to give you an idea of
    how to use the collections framework instead of other tools to do such operations.
    This time, we will do something special; instead of getting the data from the
    CLI as arguments to the script, we will use the `java.io.Console` API, which allows
    the reading of different types of strings from the terminal, such as usernames
    (plain strings) and passwords. The goal of this application is to read the input
    until a line with only the "`*`" symbol (asterisk) is captured. Once the termination
    symbol is entered, the text will be processed, and the statistics will be delivered
    to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IntelliJ and create a new Java program using the CLI template. Name the
    project `AnalyzeInput`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by creating a simple program that can read a line from the terminal and
    printing it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the program from the CLI by calling `java AnalyzeInput` from the right
    folder and interact with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You must import `java.io.Console`, which allows you to instantiate objects of
    the `Console` class. You can also see the call to `cons = System.console()`, which
    will make sure that the terminal is ready for you to read the data, and `line
    = cons.readLine()`, which will ensure that when hitting the *Enter* key on the
    keyboard, the resulting data is not empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is storing the data we are capturing in a collection. Since we
    don''t know the size this could be, we should be using `ArrayList <String>` to
    store the data. Also, to store data for as long as we want, we can modify the
    `if` statement and make it into a `while` loop. Finally, use the `add` method
    to add the lines into a list (note that the following code listing will never
    exit, so bear with us and do not execute it yet):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `while` loop to include the condition we established for finishing
    the data capture process – the arrival of a line with only an asterisk symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The outcome will happen only when you type the asterisk symbol alone in a line,
    as seen in this log while interacting with the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we used `ArrayList` to store the different strings, you could be typing
    until you exhaust the computer''s memory. Now it is possible to execute some commands
    to work with the strings. The first step will be turning the whole of the text
    into a list. This will require going through the different strings and splitting
    them into parts that will be added to a larger list. The easiest trick is to use
    the `split()` method using a whitespace character as a separator. Modify the `main`
    method to look like the following, and you will see that the result is now a list
    with all the words separated as single nodes in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having all the data stored in this way allows for the use of a lot of the methods
    available in the collections framework that will let you do operations with data.
    Let''s start by counting all the words in the text (including the closing symbol,
    "`*`"). Just add the following at the end of the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of this exercise is a program that is ready to be used for further
    analysis of the data. But in order to continue doing so, we need to make use of
    a tool that has not yet been introduced—the iterator. We will come back to this
    example later in the chapter and finish off the application by adding some extra
    functionality to it.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collections framework offers one more interface, `java.util.Map`, which
    can be used when dealing with data that is stored as key-value pairs. This type
    of data storage is becoming more and more relevant as data formats such as JSON
    are slowly taking over the internet. JSON is a data format that is based on having
    data stored in the form of nested arrays that always respond to the key-value
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having data organized in this way offers the possibility of having a very simple
    way to look for data – by means of the keys instead of using, for example, an
    index, as we would do in an array. Keys are the way we can identify the block
    of data we are looking for within a map. Let''s look at a simple example of a
    map before looking at alternatives to maps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to create a simple map and how to print some
    messages based on the information available within it. The first thing that you
    will notice in comparison to other interfaces in the collections framework is
    that we do not *add* elements to the map – we *put* elements in the map. Also,
    elements have two parts: the **key** (in our case, we are using strings) and the
    **value** (which can be heterogeneous in nature):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there is no key named "`bytes`" in the code, the `maps.containsKey()`
    method will answer accordingly, and the program will inform the user about it.
    The main methods available in this interface are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`put` (Object key, Object value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putAll` (Map map)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove` (Object key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get` (Object key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsKey` (Object key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keySet()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entrySet()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All but the last two are self-explanatory. Let''s focus on augmenting our previous
    example to see what those two methods do. Make the following addition to the code
    to see what `keySet()` and `entrySet()` have to offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of the modified code listing will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In other words, `entrySet()` will print the whole map using the key = value
    formula, while `keySet()` will respond with the set of keys within the map.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have realized this by now: keys must be unique – there cannot be
    two of the same keys in a map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not go deeper into maps at this point because they are, to an extent,
    a repetition of what we saw with sets. There are three different classes for maps:
    `HashMap`, `TreeMap`, and `LinkedHashMap`. The last two are put in order, while
    the first one is neither sorted nor arranged in order of arrival. You should use
    these classes according to your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, when working with *Exercise 01, Creating the AnalyzeInput
    Application* we stopped when we were about to make searches through the data.
    We made it to the point where we had to iterate through the data and look for
    characteristics such as word frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are used in Java to browse through collections. Let's look at a simple
    example that involves extracting the elements from a simple list one by one and
    printing them out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Iterators such as this one are the most generic ones in the collections framework
    and can be used with lists, sets, queues, and even maps. There are other less-broad
    implementations of the iterators that allow for different ways to browse through
    data, for example, in lists. As you saw in the latest code listing, the `iterator.hasNext()`
    method checks whether there is a node after the one we are at in the list. When
    starting the iterator, the object points to the first element in the list. Then,
    `hasNext()` responds with a Boolean stating whether there are more nodes hanging
    from it. The `iterator.next()` method will move the iterator to the following
    node in the collection. This kind of iterator does not have the possibility of
    going back in the collection; it can only move forward. There is one final method
    in the iterator, called `remove()`, which will eliminate the current element that
    the iterator is pointing to from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used `listIterator()` instead, we would have had a lot more options for
    navigating collections, such as adding new elements and changing elements. The
    following code listing demonstrates how to go through a list, add elements, and
    modify them. `listIterator` works only with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create a list of `Double`, iterate through the list, and
    round up each of the numbers. The outcome of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: By calling `listIterator.set()`, we modify each of the items in the list and
    the second `System.out.println()` command shows where the numbers have been rounded
    up or down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final iterator example we are going to see in this section is a trick to
    iterate through a map. This could come in handy in scenarios where you want to
    perform some operations on data within a map. By using the `entrySet()` method
    – which returns a list – it is possible to have an iterator over a map. See the
    following example to understand how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will iterate through a map and print the contents as they were
    stored in `HashMap`. Remember that these types of objects are not sorted in any
    specific way. You can expect an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we now have ways to iterate through collections, we can move on
    to an exercise that picks up where we left off: iterating through a list for data
    analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Bringing Analytics into the AnalyzeInput Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start from where we left off at the end of *Exercise 1*, *Creating
    the AnalyzeInput Application*. We managed to capture the text typed in the terminal
    and store it as a list of strings. This time, we are going to use a method from
    the collections framework called `frequency`, which will respond with the number
    of times a certain object can be found inside a list. As words could be repeated
    in a sentence, we first need to figure out a way to extract the unique elements
    in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are objects in the collections framework that keep only one copy of each
    element. We saw an example of this earlier in the chapter. We will create a `HashSet`
    instance and copy all the elements from the list into it. This will automatically
    eliminate duplicates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step, now that we have the set, is to create an iterator that will
    check how many copies of each element from the set can be found in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the same technique that we saw in previous examples for how to iterate
    through a set, we will find the next node in the set and check in the list for
    the frequency of the string stored in the node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final code can be referred at: [https://packt.live/2BrplvS](https://packt.live/2BrplvS).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The outcome will depend on the kind of text you type. For the sake of testing,
    try the following (we will stick to this data entry for the rest of the chapter
    – you can copy and paste it to the terminal each time you call the application):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full outcome of this input will be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the result is correct, it is not easy to read through. Ideally, results
    should be sorted. For example, by descending values of frequency, so that it is
    easy to see at a glance the most and least frequent words. This is the time to
    make yet another stop in the exercise as we need to introduce the idea of sorting
    before we move on with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sorting Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, there are some classes in the collections framework that force
    the items within them to be sorted. Examples of that are `TreeSet` and `TreeMap`.
    The aspect to explore in this section is how to use existing sorting mechanisms
    for lists, but also for cases that have datasets with more than one value per
    data point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exercise we are doing throughout this chapter is a good example of a case
    where there are data points with more than one value. For each data point, we
    need to store the word for which we are calculating the frequency and the frequency
    itself. You might think that a good technique to sort that out is by storing the
    information in the form of maps. The unique words could be the keys, while the
    frequencies could be the values. This could be achieved by modifying the final
    part of the previous program to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is an interesting and simple approach to sorting (copying the data
    into a structure that is sorted by nature), it presents the problem that data
    is sorted by key and not by value, as the following result of the previous code
    highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: So, if we want to sort these results by value, we need to figure out a different
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s step back for a second and analyze what tools are offered in the
    collections framework for sorting. There is a method called `sort()` that can
    be used to sort lists. An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Given a list, we could sort it this way just fine; it would even be possible
    to navigate through it backward using `listIterator` to sort a list in descending
    order. However, these methods do not solve the issue of sorting data points with
    multiple values. In such a case, we would need to create a class to store our
    own key-value pair. Let's see how to implement this by continuing with the exercise
    we have been dealing with throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Sort the Results from the AnalyzeInput Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have a program that, given some input text, identifies some basic characteristics
    of the text, such as the number of words in the text or the frequency of each
    of the words. Our goal is to be able to sort the results in descending order to
    make them easier to read. The solution will require the implementation of a class
    that will store our key-value pairs and make a list of objects from that class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class containing the two data points: the word and its frequency.
    Implement a constructor that will take values and pass them to class variables.
    This will simplify the code later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When calculating the frequency for each word, store the results in a newly
    created list of objects of the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sorting is going to require the creation of a new class using the `Comparator`
    interface, which we are just introducing now. This interface should implement
    a method that will be used to run comparisons within the objects in the array.
    This new class must implement `Comparator <DataPoint>` and include a single method
    called `compare()`. It should have two objects of the class being sorted as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The way we call the `Collections.sort()` algorithm using this new comparator
    is by adding an object of that class as a parameter to the `sort` method. We instantiate
    it directly in the call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will sort the frequencies list in ascending order. To print the results,
    it is no longer valid to make a direct call to `System.out.println(frequencies)`
    because it is now an array of objects and it will not print the contents of the
    data points to the terminal. Iterate through the list in the following way instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the program using the same input that we have been using for the
    last couple of examples, the outcome will be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our goal is to sort the results in descending order and, to do that, we will
    need to add one more thing to the call to the `sort` algorithm. When instantiating
    the `SortByValue()` class, we need to tell the compiler that we want the list
    to be sorted in reverse order. The collections framework already has a method
    for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the sake of clarity, the final code can be referred at: [https://packt.live/2W5qhzP](https://packt.live/2W5qhzP).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A full interaction path with this program, from the moment we call it to include
    the data entry, would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Properties in the collections framework are used to maintain lists of key-value
    pairs where both are of the `String` class. Properties are relevant when obtaining
    environmental values from the operating system, for example, and are the grounding
    class for many other classes. One of the main characteristics of the `Properties`
    class is that it allows the definition of a default response in the case of a
    search for a certain key not being satisfactory. The following example highlights
    the basics of this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Before diving into the results, you will notice that in properties, we put rather
    than add new elements/nodes. This is the same as we saw with maps. Also, you will
    have noticed that to iterate, we used the `keySet()` technique that we saw when
    iterating through maps earlier. Finally, the particularity of `Properties` is
    that you can set a default response in the case of the searched-for property not
    being found. This is what happens in the example when searching for `getProperty()`
    method will answer with its default message without crashing the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting method to be found in the `Properties` class is the `list()`;
    it comes with two different implementations that allow you to send the contents
    of a list to different data handlers. We can stream the whole properties list
    to a `PrintStreamer` object, such as `System.out`. This offers a simple way of
    displaying what is in a list without having to iterate through it. An example
    of this follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'That will result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `propertyNames()` method returns an `Enumeration` list, and by iterating
    through it, we will obtain the keys to the whole list. This is an alternative
    to creating a set and running the `keySet()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'That will result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The final method we will introduce you to from `Properties` at this point is
    `setProperty()`. It will modify the value of an existing key, or will eventually
    create a new key-value pair if the key is not found. The method will answer with
    the old value if the key exists, and answer with `null` otherwise. The next example
    shows how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are more methods in the `Properties` class that deals with storing and
    retrieving lists of properties to/from files. While this is a very powerful feature
    from the Java APIs, as we haven't yet introduced the use of files in this book,
    we will not discuss those methods here. For more information at this point, please
    refer to Java's official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Iterating through Large Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contemporary computing, we deal with large sets of data. The purpose of this
    activity is to create a random-sized list of random numbers to perform some basic
    operations on data, such as obtaining the average.
  prefs: []
  type: TYPE_NORMAL
- en: To start, you should create a random list of numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To compute the average, you could create an iterator that will go through the
    list of values and add the weighted value corresponding to each element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value coming from the `iterator.next()` method must be cast into a `Double`
    before it can be weighed against the total number of elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''ve implemented everything properly, the results of the averaging should
    similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 539.
  prefs: []
  type: TYPE_NORMAL
- en: If you managed to make this program work, you should think about how to take
    advantage of being able to simulate large sets of data like this one. This data
    could represent the amount of time between different arrivals of data in your
    application, temperature data from the nodes in an Internet of Things network
    being captured every second. The possibilities are endless. By using lists, you
    can make the size of the dataset as endless as their working possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the Java collections framework, which is a very
    powerful tool within the Java language that can be used to store, sort, and filter
    data. The framework is massive and offers tools in the form of interfaces, classes,
    and methods, some of which are beyond the scope of this chapter. We have focused
    on `Arrays`, `Lists`, `Sets`, `Maps`, and `Properties`. But there are others,
    such as queues and dequeues, that are worth exploring on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Sets, like their mathematical equivalents, store unique copies of items. Lists
    are like arrays that can be extended endlessly and support duplicates. Maps are
    used when dealing with key-value pairs, something very common in contemporary
    computing, and do not support the use of two of the same keys. Properties work
    very much like `HashMap` (a specific type of `Map`) but offer some extra features,
    such as the listing of all their contents to streams, which simplifies the printing
    out of the contents of a list.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the classes offered in the framework are sorted by design, such as `TreeHash`
    and `TreeMap`, while others are not. Depending on how you want to handle data,
    you will have to decide which is the best collection.
  prefs: []
  type: TYPE_NORMAL
- en: There are standard techniques for looking through data with iterators. These
    iterators, upon creation, will point to the first element in a list. Iterators
    offer some basic methods, such as `hasNext()` and `next()`, that state whether
    there is more data in the list and extract data from the list, respectively. While
    those two are common to all iterators, there are others, such as `listIterator`,
    that are much more powerful and allow, for example, the addition of new elements
    to a list while browsing through it.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at a chapter-long example that used many of these techniques,
    and we have introduced the use of the console to read data through the terminal.
    In the next chapter, we will cover exceptions and how to handle them.
  prefs: []
  type: TYPE_NORMAL
