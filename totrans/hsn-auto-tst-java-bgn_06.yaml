- en: Learn Everything about Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at one of the most important concept in
    Java code: arrays. We''ll see how different arrays look, and how to initialize
    and display them. We''ll also take a look at a few exercises to help us better
    understand how arrays work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and their usage in Java programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways of initializing arrays and assigning objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic programming on multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practice exercises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and their usage in Java programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We might have come across the term array in the past, so let's see what arrays
    are with an explanation and an example.
  prefs: []
  type: TYPE_NORMAL
- en: An array is a container that stores multiple values of the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will see what a container is, how to define that
    container, and how we can store values in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to work with arrays, we declare them by allocating some space for
    them using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new` keyword basically allocates memory for a value in this array. The
    square brackets mean that we are adding multiple values into the brackets, `[]` indicates
    the term for the array. To define an array, we have to create space for the multiple
    values that we will be storing in it. In this example, we have five integer values
    that we are planning to store in the array, which is why we have specified the
    array data type as an integer, and the number of variables to be added is given
    in the square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we observed in [Chapter 3](af539fda-b962-4b96-b326-1b5e3a18fe1c.xhtml), *Handling
    Strings and Their Functions in Java*, if the values were strings, we would specify
    the array data type as `String`.
  prefs: []
  type: TYPE_NORMAL
- en: We have declared an array and allocated memory for the values, now we need to
    pass those values. The first value will be placed in index `0`, the second in
    index `1`, and so on for all five values. Index naming starts from the `0` index,
    so the first value will be assigned to the `0` index. This means that we actually
    initialized values in the array. Now the `a` array holds all the values that we
    assign to it. For our example, we declare any random values for the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s retrieve the values from the array. To do so, we create a `for`
    loop by typing the following code in the `main` class after declaring the values
    of the array and leave a print statement after that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our starting point has been set at index `0` and the limit has been set to the
    length of the array. Take a look at the `i<a.length` code, `length` is a method
    that actually returns the size of the array.
  prefs: []
  type: TYPE_NORMAL
- en: On running the code we see that all the values assigned to the array are printed
    one after the other. In the next section, we will see a simpler way to declare
    and initialize all the array values.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to initialize arrays and assign objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to declare an array; the simplest way is
    in the form of an array literal. Let's explain this with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare another array by typing the following code line in the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What is the difference between the declaration in the previous example and the
    declaration that we are performing in this example?
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we are allocating memory and then assigning the values.
    In this example, rather than allocating the memory, we are directly passing the
    values to the array. Here, memory is dynamically allocated, if we add a value
    in the array declaration, automatically a memory will be allocated and the value
    will be passed into it. In most cases, coders use this method to declare array
    values, rather than declaring the allocation and then assigning the values.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the previous example, the first value is assigned to index `0`. If
    we write a print statement similar to the previous example and run the code, we
    will see the values of the `b` array displayed.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up single-dimensional arrays; let's talk about multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Passing objects in the *x* axis and *y* axis is nothing but a multidimensional
    array. The where the *x* axis is the row, and the *y* axis is the column of the
    matrix in which the array values are given. Multi in this case means we are viewing
    arrays from the multi-corner perspectives; this is called a **multidimensional**
    array. The following is a multidimensional array we have created to explain this
    concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a matrix and it has three rows and three columns. `2` is in the zero row
    and zero column, and the `4` beside it is in the zero row and first column, and
    the same iteration for the rest of the values. So each argument has an *x* axis
    and a *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example to explain this. We will create another class, name
    it `Multidimensional.java`, and declare a multidimensional array, `a`, in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first bracket represents the *x* axis or rows, and the second represents
    the *y* axis or columns. So, the *x* axis takes three values, which means three
    rows and the *y* axis takes three columns. We then assign the values for each
    element of the matrix that we created to explain multidimensional arrays. The
    following code shows how to assign values for the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This way we will feed all the values into a multidimensional array. If we want
    to display the value of the second row, first column, we write a print statement
    and give the location of the element whose value we wish to display. In this case,
    we want to display the second row, first column, so the print statement will be
    written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The print statement will display `3`, which is the value of the element in that
    location. In the next section, we will take an example that will help explain how
    we use all these concepts in solving coding.
  prefs: []
  type: TYPE_NORMAL
- en: How do we print all the values of the a array that we declared in this example?
    In the earlier example, we printed the array by simply creating a `for` loop,
    iterated it from `0` to the length of the array, and the array was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to declare a multidimensional array in the simplest format, like
    how array `b` was described in the previous example, we could write it in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The array will assume that the values in the first bracket are in the zero index,
    the second in the first index, and the third in the second index. This is the
    simplest way to declare multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Logic programming on multidimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will take a look at how we can print all the values of the entire multidimensional
    array used in the previous section, that is, the a array.
  prefs: []
  type: TYPE_NORMAL
- en: If we analyze the declaration of the array, we will see that two `for` loops
    will be required to print the entire array, one for rows and one for columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the controller to scan the complete first row, then the second row,
    and finally the third. So we add an outer `for` loop for the rows and set the
    length limit to the number of rows in the array, in this case two rows. The outer
    `for` loop for the rows will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This `for` loop will actually loop twice since we set the limit to `2` for
    rows. The first loop will scan the first row and the second loop will scan the
    second row. Now for each loop, we need to scan the three columns present in that
    specific row. To do this, we add an inner `for` loop that will scan every column
    and we set the limit to the number of columns in the array, which is `3` for this
    example. The inner `for` loop for the columns will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally to print the array, we add a print statement in the internal `for`
    loop to display all the values. The final code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to understand what we have written here. The control will start from
    the outer `for` loop; this outer `for` loop is executed twice because it has been
    set to less than `2`. After entering the outer `for` loop for the first time,
    it enters the inner `for` loop; this loop is executed three times because `j`
    has been set to less than `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s debug it and take a look at a few steps in the code to understand these
    loops better. The following are the steps that will be performed while debugging
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller executes the outer loop for the first time and the value of `i`
    has been initialized to `0`, this means that the value of the *x* axis is set
    at `0`. The controller will look at the first row since `0` indicates that the
    first row is being accessed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It moves to the inner `for` loop and executes it, the initial value of `j` has
    been been initialized to `0`; this means that the value of the *y* axis is set
    to `0`. The controller will look at the first row and first column, since it was
    already on the first row because of the outer loop. The inner loop sent the controller
    to look at the first column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` will take the value of the first row and first column as the values of
    `i` and `j` were initialized to `0`, `a[0][0]`. So the output for this execution
    will be the first row and first column, which is `2` in this example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller moves to the inner `for` loop again as the condition for the
    loop is still satisfied because `j` gets iterated to `1`, which is less than `3`;
    this means that the value of the *y* axis is set to `1` and it will access the
    second column. The controller will look at the first row and second column since
    it was already on the first row because of the outer loop and the inner loop sent
    the controller to look at the second column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` will take the value of the first row and second column as the values of
    `i` and `j` are set to `0` and `1`, `a[0][1]`. So the output for this execution
    will be the first row and second column, `4` in this example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller moves to the inner `for` loop again as the condition for the
    loop is still satisfied because `j` gets iterated to `2`, which is less than `3`.
    This means that the value of the *y* axis is set to `2` and it will access the
    third column. The controller will look at the first row and third column since
    it was already on the first row because of the outer loop and the inner loop sent
    the controller to look at the third column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` will take the value of the first row and third column as the values of
    `i` and `j` are set to `0` and `2`, `a[0][2]`. So the output for this execution
    will be the first row and third column, which is `5` in this example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the controller goes to the inner loop now, it won't be able to execute
    it because after `j` gets iterated again the value will be `3`, which is not less
    than the limit we had set for the loop. So the controller exits the inner `for`
    loop and goes back to the outer loop and iterates the value of `i` to `1`; this
    means that the value of the *x* axis is set to `1`. The controller will look at
    the second row since `1` indicates that the second row is being accessed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 2, 3, 4, 5, 6, and 7 are repeated again, but this time the value of `i`,
    which is the *x* axis, is set to `1`; that means the second row will be accessed.
    All the values in the second row are displayed according to the steps specified
    previously, until we reach the third column of the matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller will exit the inner loop after accessing the third column as
    `j` will be iterated to `3`, which is less than the limit that we had set for
    the loop. So the controller again exits the inner `for` loop and starts executing
    the outer loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the outer `for` loop, the value of `i` will be iterated to `2` and the loop
    will not be executed because it is not less than `2`, which is the limit we set
    for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how the values of a multidimensional array can be obtained using two
    `for` loops, in which the outer loop works with rows and the inner loop works
    with columns.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try a few exercises that will help us understand and work with arrays.
    These exercises will also explain concepts while giving an interview.
  prefs: []
  type: TYPE_NORMAL
- en: Print the smallest number in a 3 x 3 matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create another class for this exercise, name it `InterviewMinnumber`,
    and define the array in the main block. The definition code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code declares a 3 x 3 matrix named `abc`. Now we need to traverse each
    number in the matrix, and look for the smallest number in it. To traverse every
    number in the multidimensional array, we need to use the same concept that we
    have used in the *Logic programming on multidimensional arrays* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use two `for` loops here: an outer `for` loop to traverse the rows and an
    inner `for` loop to traverse the columns. The two `for` loops code will look at
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To find the smallest number, we declare a variable, `min`, and assign the first
    value of the `abc` array to it. We assume that the first value in the `abc` matrix
    is the lowest value in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add an `if` loop inside the inner `for` loop. Within this `if` loop, whatever
    we write will go and scan each element in the whole matrix that we declared. In
    the `if` loop, we add a condition where we check whether the value taken from
    the matrix at that instance is less than the `min` value. Inside the `if` loop,
    we swap the value of `min` and `abc`. The final code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the code and see how it finds the smallest number in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: When the loop is executed first, the value of the first element in the matrix
    is compared to the value of the `min` variable, but we set the value of the `min`
    variable equal to the first element, which is `2`. We check the condition in the
    `if` loop, which compares the value of the element in the matrix and the value
    of `min`. Here, `2` is not smaller than `2`, so it does not enter the loop and
    it goes to the start of the code again. In the next round of the loop, the value
    of the element changes because we move the next element in the matrix. Now the
    element being compared is `4`, we check the `if` condition again and it won't
    be true because `4` is not smaller that `2`, where `2` is the current value of
    `min`. Finally, when it reaches the element in the third row first column, `1`,
    then the `if` condition is true and the controller moves inside the loop and assigns
    `1` to the `min` value. This goes on until the final element in the array matrix,
    where each value of the `abc` matrix is compared to the value of the `min` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If we debug the code and observe it at every step, we will better understand
    the logic and working of this code.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the largest number from the column with the smallest number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we observed how to print the smallest number from
    the array matrix. In this example, we will look for the smallest number in the
    matrix and then the maximum number in the same column. The logic behind this is:
    we first find the minimum number, remember the row number it belongs to, and extract
    the maximum number in the same column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same matrix that we used in the previous example. The output
    for this exercise in the matrix that we are using will be `4`. The following steps
    will be implemented to perform this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the minimum value in the matrix that we declare
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the column of that minimum number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the maximum number in the identified column
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We already performed step 1 in the previous example, where we found the minimum
    number in the matrix, so we will be using the same code for this example and just
    change the variables a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move to step 2\. If we observe the code, we see that `i` stands for
    the row number and `j` stands for the column number. So `j` will take the value
    of the column where the smallest number is present and we will take this value
    of `j` and assign it to a variable that will call `mincolumn`. So we write code
    under the swapping command, which will assign the value of `j` to `mincolumn`.
    The code will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So the moment we find the smallest number in the matrix, we assign to it the
    value of `j`, which is the column number to `mincloumn`. In this case, the value
    of `mincolumn` will be `1`. This takes care of step 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 3, we look for the maximum number from the column in which the minimum
    number is present. We create a `while` loop outside the outer `for` loop that
    we had created to find the lowest number in the matrix. We initialize the condition
    variable, `k`, as `0` and iterate it every time the `while` look condition is
    met. The condition for the `while` loop is set to `k` less than `3`; this is because
    we have three rows to traverse to look for the maximum value in them. The code
    for the `while` loop will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a variable named `max` and give it an initial value of row `0` and
    column `mincolumn`. This gives the variable `max` an initial value of `4`, since
    `4` is the first element in the row which contains the minimum number in the matrix.
    The declaration code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Within the `while` loop, we add an `if` loop and set a condition that compares
    whether the variable in the column with the minimum number is greater than the
    variable `max` that we declared. If the condition is met, the value of that number
    is assigned to the `max` variable and the controller moves out of the `if` loop
    and back to the `while` look after iterating `k` by `1`. The iteration will take
    the controller to the next row as `k` is used to signify the row that is being
    traversed to look for the maximum number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `if` loop will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, for the first value of `k`, which is `0`, we go to the first row and second
    column and assign the value to `max`; in this example, the value is `4`. In the
    `if` condition, we compare the value of the first row, second column with the
    value of `max`. In this example, both the values are the same, so the `if` loop
    is not executed and we iterate `k` and enter the `while` loop again. Next, we compare
    the value of the second row, second column with the value of `max`; we move to
    the second row because the value of `k` is iterated by `1` and the current value
    of `k` is `1`. So, on comparing, we see that `o` is less that `4`, where `4` is
    the value of the `max` variable. The condition is not met again and the `if` loop
    is skipped again. This continues for the third row too and the final value of
    `max` is `4`, which is the largest number in the column. Finally, we leave a print
    statement to print the value of `max` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping variables with/without the temp variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this exercise, we will be swapping the location of the elements in a simple
    array and placing them in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we first need to understand the logic of how it will work. Let's
    take an example to explain this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initiate the `a` array and declare values in it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can use the bubble-sort mechanism to compare the variables to each other
    and then place them in the order we want. For the preceding example, the way the
    logic works will be as follows; we'll compare `2` with `6`, `2` with `1`, `2`
    with `4`, and `2` with `9`. The smallest number after this comparison is `1` and
    we swap its position with the first index, which is `2`. So after swapping, `1`
    will be the new first index. This means that `1` is the smallest number from the
    values given in the array. Now we move to the second index, we leave the first
    index untouched because we have already compared and declared `1` as the fixed
    first index as it is the smallest number in the array. Now we take the value `6`,
    which is the second index and compare it to other values present in the array.
    First we compare `6` and `2` and since `2` is smaller than `6` we swap their positions,
    so `2` is the new first index and `6` is the second index. We then compare `2`
    with `3`; basically we are comparing the first index with all the other values
    in the array. We then compare `2` to `3`, `2` to `4`, and `2` to `9`; here `2`
    is the smallest number. So `2` becomes our fixed second index in the array. Now
    we are left with four values that we need to sort. We again compare `6` with the
    other values. `6` is smaller than `3`, so we swap the positions of `6` and `3`.
    This makes `3` the third index in the array and we compare `3` with the other
    numbers, `3` is the smallest among all the value given in it. So `3` becomes our
    fixed third index in the array. Then we perform the same thing for the last three
    values and conclude that the final arrangement will be `1`, `2`, `3`, `4`, `6`,
    `9`. Now we need to apply this logic in a Java program and print it.
  prefs: []
  type: TYPE_NORMAL
- en: We will decide on an algorithm for our logic and, based on the algorithm, we
    will design our code step by step. We will write an outer `for` loop that moves
    one index and compares it with the rest.
  prefs: []
  type: TYPE_NORMAL
- en: We write an outer `for` loop and set the condition to not cross the length of
    the array; here the array size is `5`, so the condition is set to `i`, which is less
    than `5`. If `i` is `0`, the variable value will compare it to the first, second,
    third, and fourth variables. If `i` is `2`, the variable will compare it to the
    third and fourth variables. So whatever the `i` index is, it should start comparing
    the value of `i` with its next index. For this, we will create an inner `for`
    loop and we will initialize the `j` to be always one number more than `i`, `i`
    plus `1`, because we will compare it with the next index. So, if `i` equals `0`,
    `j` will be `1`. So the zero index will start comparing from the first index.
    And we compare it until the end of the array, so we set the limit for the inner
    `for` loop at `j`, as it's less than the length of the array, which is `5` in
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: We then add an `if` loop within the inner `for` loop. This loop will do the
    comparison between the indexes and swap the values when the condition is met.
    Once the first round of comparisons is done, the controller exits the inner `for`
    loop and goes back to the outer `for` loop, which is when the smallest number
    is picked after the comparison, pushed to the corner, and the index moves to the
    next value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we go back inside the `if` loop and write code to swap the values when
    the comparison condition is true. To swap variable values, we need to declare
    a `temp` variable and assign the `a[i]` number to `temp`. We add the following
    code to successfully swap the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And in the end, we add a print statement to display the final array after comparing
    and rearranging the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final output will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various concepts in arrays. We took a look at the
    different types of array, and how they can be initialized and displayed. We then
    performed different exercises to understand how we can use arrays in different
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss why the `Date` class and constructors are
    an important part of Java
  prefs: []
  type: TYPE_NORMAL
