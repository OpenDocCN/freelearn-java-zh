<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Fine-Grained Stack Tracing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java 9 comes with a new stack walker API that lets the program walk the calling stack. This is a very special functionality that is rarely needed by ordinary programs. The API can be useful for some very special cases--for functionality that is delivered by framework. So, if you want an efficient means of stack walking that gives you filterable access to stack trace information, you will enjoy this new stack walker API.</p>
<p class="mce-root">The API gives fast and optimized access to the call stack, implementing lazy access to the individual frames.</p>
<p class="mce-root">In this chapter, we cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Overview of the Java Stack</li>
<li class="calibre14">The importance of stack information</li>
<li class="calibre14">Using <kbd class="calibre16">StackWalker</kbd></li>
<li class="calibre14">The <kbd class="calibre16">StackFrame</kbd></li>
<li class="calibre14">Performance</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Overview of the Java Stack</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we dive into the stack walker, let's start by covering the Java Stack. This is basic stack information, not specific to the stack walker.</p>
<p class="mce-root">The Java runtime has a class named Stack, which can be used to store objects using the <strong class="calibre8">last-in-first-out</strong> (<strong class="calibre8">LIFO</strong>) policy.</p>
<p class="mce-root">When arithmetic expressions are calculated they are done using a stack. If we add <em class="calibre20">A</em> and <em class="calibre20">B</em> in our code first <em class="calibre20">A</em> is pushed on the <strong class="calibre8">Operand Stack</strong>, then <em class="calibre20">B</em> is pushed on the Operand Stack and finally the addition operation is executed, which fetches the two topmost elements of the Operand Stack and pushes the result, <em class="calibre20">A</em> + <em class="calibre20">B</em> there.</p>
<p class="mce-root">The JVM is written in C and executes calling C functions and returning from there. This call-return sequence is maintained using the Native Method Stack just like any other C program.</p>
<p class="mce-root">Finally, when the JVM creates a new thread it also allocates a call stack containing frames that in turn contain the local variables, reference to the previous frame, and reference to the class that contains the executing method. When a method is invoked a new frame is created. The frame is destroyed when a method finishes its execution, in other words, returns or throws an exception. This stack, the Java Virtual Machine Stack, is the one that the stack walker API manages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The importance of stack information</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Generally speaking we need the stack information when we want to develop caller dependent code. Having information about the caller allows our code to make decisions based on that information. In general practice, it is not a good idea to make functionality dependent on the caller. Information that affects the behavior of a method should be available via parameters. Caller dependent code development should be fairly limited.</p>
<p class="mce-root">The JDK accesses stack information with native methods that are not available to Java applications. The <kbd class="calibre16">SecurityManager</kbd> is a class that defines an application's security policy. This class checks that the caller of a reflection API is allowed to access the non-public members of another class. To do that it has to have access to the caller class and it does that through a protected native method.</p>
<p class="mce-root">This is an example of implementing some security measures without having to walk through a stack. We open our code for external developers to use it as a library. We also call methods of classes provided by the library user and they may call back to our code. There is some code that we want to allow library users to call but only if they were not called from our code. If we did not want to allow some of the code to be accessed directly by the library using code we could use Java 9's modular structure not exporting the package containing the classes not to be invoked. This is the reason we set the extra condition that the code is available for the callers from outside, except if they were called by our code:</p>
<div class="mce-root1"><img class="image-border4" src="Images/84dd9c87-8562-487d-acbc-5f7e5da41927.png"/></div>
<p class="mce-root">Another example is when we want to get access to a logger. Java applications use many different loggers and the logging system is usually very flexible so that the output of the different loggers can be switched on and off based on the actual need to introspect into the code. The most common practice is to use a different logger for each class and the name of the logger is usually the name of the class. The practice is so common that the logging framework even provides logger access methods that accept the reference to the class itself instead of the name. It essentially means that the call to get the handle of a logger looks something like the following:</p>
<pre class="calibre21">    private static final Logger LOG = Logger.getLogger(MyClass.class); </pre>
<p class="mce-root">A problem can arise when we create new classes from existing classes if we forget to alter the name of the class name in the call for getting a new logger. This is not a serious problem, but it is common. In that case our code will use the logger of the other class and it will actually work, but may create confusion when we analyze the log files. It would be much nicer if we had a method that returns the logger that is named as the class of the caller.</p>
<p class="mce-root">Let's continue our exploration of stack information in the next two sections with code snippet examples.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Example - Restricting callers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this section we develop a sample library with two methods. The <kbd class="calibre16">hello()</kbd> method prints <kbd class="calibre16">hello</kbd> to the standard output. The <kbd class="calibre16">callMe()</kbd> method accepts a <kbd class="calibre16">Runnable</kbd> as an argument and runs it. The first method however is restricted. It executes only if the caller is purely outside of the library. It throws an <kbd class="calibre16">IllegalCallerException</kbd> if the caller obtained the control in a way that the library was calling out, presumably via the second method invoking the passed <kbd class="calibre16">Runnable</kbd>. The implementation of the API is simple:</p>
<pre class="calibre21">    package packt.java9.deep.stackwalker.myrestrictivelibrary; 
    public class RestrictedAPI { 
      public void hello(){ 
        CheckEligibility.itIsNotCallBack(); 
        System.out.println("hello"); 
      } 
      public void callMe(Runnable cb){ 
        cb.run(); 
      } 
    } </pre>
<p class="mce-root">The code that performs the eligibility checking is implemented in a separate class to keep things simple. We will examine that code shortly, but before that we look at the main code we use to start the demonstration. The main program code we use to demonstrate the functionality is the following:</p>
<pre class="calibre21">    package packt.java9.deep.stackwalker.externalcode; 
 
    import<br class="calibre2"/>     packt.java9.deep.stackwalker.myrestrictivelibrary.RestrictedAPI; 
 
    public class DirectCall { 
 
      public static void main(String[] args) { 
        RestrictedAPI api = new RestrictedAPI(); 
        api.hello(); 
        api.callMe(() -&gt; { 
            api.hello(); 
        }); 
      } 
    } </pre>
<p class="mce-root">This code creates an instance of our API class and then directly invokes the <kbd class="calibre16">hello()</kbd> method. It should work and should print the characters <kbd class="calibre16">hello</kbd> on screen. The next code line asks the <kbd class="calibre16">callMe()</kbd> method to call back the <kbd class="calibre16">Runnable</kbd> provided in form of a lambda expression. In this case the call will fail, because the caller is outside but was called from inside the library.</p>
<p class="mce-root">Let's now look at how the eligibility check is implemented:</p>
<pre class="calibre21">    package packt.java9.deep.stackwalker.myrestrictivelibrary; 
 
    import static java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE; 
 
    public class CheckEligibility { 
      private static final String packageName 
        = CheckEligibility.class.getPackageName(); 
 
      private static boolean notInLibrary(StackWalker.StackFrame f) { 
        return !inLibrary(f); 
      } 
 
      private static boolean inLibrary(StackWalker.StackFrame f) { 
        return f.getDeclaringClass().getPackageName() 
         .equals(packageName); 
      } 
 
      public static void itIsNotCallBack() { 
        boolean eligible = StackWalker 
         .getInstance(RETAIN_CLASS_REFERENCE) 
         .walk(s -&gt; s.dropWhile(CheckEligibility::inLibrary) 
           .dropWhile(CheckEligibility::notInLibrary) 
           .count() == 0 
         ); 
         if (!eligible) { 
           throw new IllegalCallerException(); 
         } 
      } 
    } </pre>
<p class="mce-root">The <kbd class="calibre16">itIsNotCallBack()</kbd> method is the one called from the <kbd class="calibre16">hello()</kbd> method. This method creates a stack walker and invokes the <kbd class="calibre16">walk()</kbd> method. The argument of the <kbd class="calibre16">walk()</kbd> method is a <kbd class="calibre16">Function</kbd> that converts a <kbd class="calibre16">Stream</kbd> of <kbd class="calibre16">StackFrame</kbd> objects to some other value that the <kbd class="calibre16">walk()</kbd> method will return.</p>
<p class="mce-root">At first this argument setting might seem complex and difficult to understand. It would be more logical to return a <kbd class="calibre16">Stream</kbd> that provides the <kbd class="calibre16">StackFrame</kbd> objects instead of forcing the caller to define a <kbd class="calibre16">Function</kbd> that will get this as an argument.</p>
<p class="mce-root">The sample code uses a lambda expression to define the <kbd class="calibre16">Function</kbd> as an argument to the <kbd class="calibre16">walk()</kbd> method. The argument to the lambda expression <kbd class="calibre16">s</kbd> is the stream. Since the first element of this stream is the actual call we drop it. Because these calls should also be refused if the caller is not eligible even though the call to method <kbd class="calibre16">hello()</kbd> was through some other class and method that is already inside the library, we drop all elements from the frame that belong to classes inside the package of the class <kbd class="calibre16">CheckEligibility</kbd>. This package is <kbd class="calibre16">packt.java9.deep.stackwalker.myrestrictivelibrary</kbd> and in the code this string is stored in the field <kbd class="calibre16">packageName</kbd>. The resulting stream contains only the <kbd class="calibre16">StackFrame</kbd> objects that are from outside of the library. We drop these also until the stream exhausts or until we find a <kbd class="calibre16">StackFrame</kbd> that again belongs to the library. If all elements were dropped we are good. In this case the result of <kbd class="calibre16">count()</kbd> is zero. If we find some class in the <kbd class="calibre16">StackFrame</kbd> that belongs to the library it means that the outside code was called from the library and in this case we have to refuse working. In this case the variable eligible will be <kbd class="calibre16">false</kbd> and we throw an exception, as can be seen in the following screenshot:</p>
<div class="mce-root1"><img class="image-border5" src="Images/8360d154-c762-4f2e-82c1-06d9d7d1bb18.png"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Example - Getting logger for caller</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To get a logger, Java 9 has a new API. Using this API a module can provide an implementation for the service <kbd class="calibre16">LoggerFinder</kbd>, which in turn can return a <kbd class="calibre16">Logger</kbd> implementing the <kbd class="calibre16">getLogger()</kbd> method. This eliminates the dependency of libraries on specific loggers or logger facades, which is a huge advantage. The smaller but still annoying issue requiring us to write the name of the class again as the parameter to the method <kbd class="calibre16">getLogger()</kbd> is still there.</p>
<p class="mce-root">To avoid this cumbersome task, we create a helper class that looks up the caller class and retrieves the logger that is suitable for the caller class and module. Because in this case there is no need for all the classes referenced in the stack trace we will call the <kbd class="calibre16">getCallerClass()</kbd> method of the <kbd class="calibre16">StackWalker</kbd> class. We create a class named <kbd class="calibre16">Labrador</kbd> in the package <kbd class="calibre16">packt.java9.deep.stackwalker.logretriever</kbd>:</p>
<pre class="calibre21">    package packt.java9.deep.stackwalker.logretriever; 
 
    import java.lang.System.Logger; 
    import java.lang.System.LoggerFinder; 
 
    import static java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE; 
 
    public class Labrador { 
      public static Logger retrieve() { 
        final Class clazz = StackWalker 
          .getInstance(RETAIN_CLASS_REFERENCE) 
          .getCallerClass(); 
        return LoggerFinder.getLoggerFinder().getLogger( 
          clazz.getCanonicalName(), clazz.getModule()); 
      } 
    } </pre>
<p class="mce-root">Before Java 9 the solution for this issue was getting the <kbd class="calibre16">StackTrace</kbd> array from the <kbd class="calibre16">Thread</kbd> class and looking up the name of the caller class from there. Another approach was extending the <kbd class="calibre16">SecurityManager</kbd> that has a protected method <kbd class="calibre16">getClassContext()</kbd> that returns an array of all the classes on the stack. Both solutions walk through the stack and compose an array although we only need one element from the array. In case of logger retrieval it may not be a significant performance penalty since loggers are usually stored in <kbd class="calibre16">private static final</kbd> fields and thus are initialized once per class during class initialization. In other use cases the performance penalty may be significant.</p>
<p class="mce-root">After we have seen two examples we will look at the details of <kbd class="calibre16">StackWalker</kbd> inner working.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Working with StackWalker</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this section you will become more familiar with how to work with <kbd class="calibre16">StackWalker</kbd>. We will explore the following topics in this section:</p>
<ul class="calibre13">
<li class="calibre14">Getting an instance of <kbd class="calibre16">StackWalker</kbd></li>
<li class="calibre14">Stack walking options</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting an instance of StackWalker</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To perform the walking over the stack elements we need an instance of the stack walker. To do that, we invoke the <kbd class="calibre16">getInstance()</kbd> method. As shown here, there are four overloaded versions of this method:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">static StackWalker getInstance()</kbd></li>
<li class="calibre14"><kbd class="calibre16">static StackWalker getInstance(StackWalker.Option option)</kbd></li>
<li class="calibre14"><kbd class="calibre16">static StackWalker getInstance(Set&lt;StackWalker.Option&gt; options)</kbd></li>
<li class="calibre14"><kbd class="calibre16">static StackWalker getInstance(Set&lt;StackWalker.Option&gt; options, int estimateDepth)</kbd></li>
</ul>
<p class="mce-root">The first version does not take any arguments and returns a <kbd class="calibre16">StackWalker</kbd> instance that will let us walk through normal stack frames. This is usually what we would be interested in. The other versions of the method accept a <kbd class="calibre16">StackWalker.Option</kbd> value or values. The enum <kbd class="calibre16">StackWalker.Option,</kbd> as the name suggests, is inside the class <kbd class="calibre16">StackWalker</kbd> and has three values:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">RETAIN_CLASS_REFERENCE</kbd></li>
<li class="calibre14"><kbd class="calibre16">SHOW_REFLECT_FRAMES</kbd></li>
<li class="calibre14"><kbd class="calibre16">SHOW_HIDDEN_FRAMES</kbd></li>
</ul>
<p class="mce-root">These <kbd class="calibre16">enum</kbd> options have self-descriptive names and are explained in the next sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">RETAIN_CLASS_REFERENCE</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If we specify the first option <kbd class="calibre16">enum</kbd> constant, <kbd class="calibre16">RETAIN_CLASS_REFERENCE,</kbd> as an argument to the <kbd class="calibre16">getInstance()</kbd> method then the returned instance grants us access to the classes that the individual stack frames reference during the walking.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">SHOW_REFLECT_FRAMES</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">SHOW_REFLECT_FRAMES enum</kbd> constant will generate a walker that includes the frames that source from some reflective calling.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">SHOW_HIDDEN_FRAMES</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Finally the <kbd class="calibre16">enum</kbd> constant option, <kbd class="calibre16">SHOW_HIDDEN_FRAMES</kbd> will include all the hidden frames, which contain reflective calls as well as call frames that are generated for lambda function calls.</p>
<p class="mce-root">Here is a simple demonstration of reflective and hidden frames:</p>
<pre class="calibre21">    package packt; 
    import static java.lang.StackWalker.Option.SHOW_HIDDEN_FRAMES; 
    import static java.lang.StackWalker.Option.SHOW_REFLECT_FRAMES; 
    public class Main { </pre>
<p class="mce-root">The main method allowing us to execute this code directly calls the method <kbd class="calibre16">simpleCall()</kbd>:</p>
<pre class="calibre21">    public static void main(String[] args) { 
      simpleCall(); 
    } </pre>
<p class="mce-root">The method <kbd class="calibre16">simpleCall()</kbd> simply calls on as the name suggests:</p>
<pre class="calibre21">    static void simpleCall() { 
      reflectCall(); 
    } </pre>
<p class="mce-root">The next method in the chain is a bit more complex. Although this also only calls the next one, it does so using reflection:</p>
<pre class="calibre21">    static void reflectCall() { 
      try { 
        Main.class.getDeclaredMethod("lambdaCall", 
          new Class[0]) 
           .invoke(null, new Object[0]); 
      } catch (Exception e) { 
          throw new RuntimeException(); 
      } 
    } </pre>
<p class="mce-root">In this next example, we have a method that calls using a lambda:</p>
<pre class="calibre21">    static void lambdaCall() { 
      Runnable r = () -&gt; { 
        walk(); 
      }; 
      r.run(); 
    } </pre>
<p class="mce-root">The last method before the actual walking is called <kbd class="calibre16">walk()</kbd>:</p>
<pre class="calibre21">    static void walk() { 
      noOptions(); 
      System.out.println(); 
      reflect(); 
      System.out.println(); 
      hidden(); 
    } </pre>
<p class="mce-root">The preceding <kbd class="calibre16">walk()</kbd> method calls three methods, one after the other. These methods are very similar to each other and provided here:</p>
<pre class="calibre21">    static void noOptions() { 
      StackWalker 
        .getInstance() 
        .forEach(System.out::println); 
    } 
 
    static void reflect() { 
      StackWalker 
        .getInstance(SHOW_REFLECT_FRAMES) 
        .forEach(System.out::println); 
    } 
 
    static void hidden() { 
      StackWalker 
        // shows also reflect frames 
        .getInstance(SHOW_HIDDEN_FRAMES) 
        .forEach(System.out::println); 
    } </pre>
<p class="mce-root">The preceding three methods print out the frames to the standard output. They use the <kbd class="calibre16">forEach()</kbd> method of the stack walker. Here is the output of the stack walking program:</p>
<pre class="calibre21"><strong class="calibre3">stackwalker/packt.Main.noOptions(Main.java:45) 
stackwalker/packt.Main.walk(Main.java:34) 
stackwalker/packt.Main.lambda$lambdaCall$0(Main.java:28) 
stackwalker/packt.Main.lambdaCall(Main.java:30) 
stackwalker/packt.Main.reflectCall(Main.java:19) 
stackwalker/packt.Main.simpleCall(Main.java:12) 
stackwalker/packt.Main.main(Main.java:8)</strong> </pre>
<p class="mce-root">This output only contains the frames that belong to calls that are in our code. The <kbd class="calibre16">main()</kbd> method calls <kbd class="calibre16">simpleCall()</kbd>, which calls <kbd class="calibre16">reflectCall()</kbd>, that in turn calls <kbd class="calibre16">lambdaCall()</kbd>, which calls a lambda expression, that calls <kbd class="calibre16">walk()</kbd> and so on. The fact that we did not specify any option does not delete the lambda call from the stack. We performed that call, thus it must be there. What it deletes are the extra stack frames that are needed by the JVM to implement the lambda. We can see on the next output, when the option was <kbd class="calibre16">SHOW_REFLECT_FRAMES,</kbd> that the reflective frames are already there:</p>
<pre class="calibre21"><strong class="calibre3">stackwalker/packt.Main.reflect(Main.java:58) 
stackwalker/packt.Main.walk(Main.java:36) 
stackwalker/packt.Main.lambda$lambdaCall$0(Main.java:28) 
stackwalker/packt.Main.lambdaCall(Main.java:30) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 
java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
java.base/java.lang.reflect.Method.invoke(Method.java:547) 
stackwalker/packt.Main.reflectCall(Main.java:19) 
stackwalker/packt.Main.simpleCall(Main.java:12) 
stackwalker/packt.Main.main(Main.java:8)</strong> </pre>
<p class="mce-root">In this case the difference is that we can see that the call from the <kbd class="calibre16">reflectCall()</kbd> method to <kbd class="calibre16">lambdaCall()</kbd> method is not direct. The <kbd class="calibre16">reflectCall()</kbd> method calls the <kbd class="calibre16">invoke()</kbd> method that calls another method of the same name defined in a different class that in turn calls the <kbd class="calibre16">invoke0()</kbd> method, which is a native method provided by the JVM. After that we finally get to the <kbd class="calibre16">lambdaCall()</kbd> method.</p>
<p class="mce-root">In the output we can also see that these reflective calls belong to the module <kbd class="calibre16">java.base</kbd> and not our <kbd class="calibre16">stackwalker</kbd> module.</p>
<p class="mce-root">If we include the hidden frames in addition to the reflective frames, specifying the option <kbd class="calibre16">SHOW_HIDDEN_FRAMES</kbd>, then we will see the following output:</p>
<pre class="calibre21"><strong class="calibre3">stackwalker/packt.Main.hidden(Main.java:52) 
stackwalker/packt.Main.walk(Main.java:38) 
stackwalker/packt.Main.lambda$lambdaCall$0(Main.java:28) 
stackwalker/packt.Main$$Lambda$46/269468037.run(Unknown Source) 
stackwalker/packt.Main.lambdaCall(Main.java:30) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 
java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
java.base/java.lang.reflect.Method.invoke(Method.java:547) 
stackwalker/packt.Main.reflectCall(Main.java:19) 
stackwalker/packt.Main.simpleCall(Main.java:12) 
stackwalker/packt.Main.main(Main.java:8) </strong></pre>
<p class="mce-root">This includes an extra hidden frame that the JVM is using to execute the lambda call. In addition, the reflective frames are also included.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Final thoughts on enum constants</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We can also specify more than one option giving a set of the options. The simplest way of doing that is to use the static <kbd class="calibre16">of()</kbd> method of the <kbd class="calibre16">java.util.Set</kbd> interface. This way the <kbd class="calibre16">RETAIN_CLASS_REFERENCE</kbd> option can be combined with either the <kbd class="calibre16">SHOW_REFLECT_FRAMES</kbd> option or the <kbd class="calibre16">SHOW_HIDDEN_FRAMES</kbd> option.</p>
<p class="mce-root">Although it is technically possible to combine <kbd class="calibre16">SHOW_REFLECT_FRAMES</kbd> and <kbd class="calibre16">SHOW_HIDDEN_FRAMES</kbd> as an option set, there is really no advantage in doing that. The latter includes the first, so the combination of the two is exactly same as the second.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Accessing classes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When we want to access the class objects during a stack walk, we have to specify the <kbd class="calibre16">RETAIN_CLASS_REFERENCE</kbd> option. Although the <kbd class="calibre16">StackFrame</kbd> interface defines the <kbd class="calibre16">getClassName()</kbd> method, that could be used to access a class of the name using the <kbd class="calibre16">Class.forName()</kbd> method, doing so would not guarantee that the class the <kbd class="calibre16">StackFrame</kbd> object refers to was loaded by the same class loader as the code calling <kbd class="calibre16">Class.forName()</kbd>. In some special cases, we could end up with two different classes of the same name loaded by two different class loaders.</p>
<p class="mce-root">When the option is not used during the creation of the <kbd class="calibre16">StackWalker</kbd> instance then the methods that otherwise return a class object will throw an <kbd class="calibre16">UnsupportedOperationException</kbd> exception. That way <kbd class="calibre16">getDeclaringClass()</kbd> cannot be used on the <kbd class="calibre16">StackFrame</kbd> and <kbd class="calibre16">getCallerClass()</kbd> on the <kbd class="calibre16">StackWalker</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Walking methods</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">StackWalker</kbd> defines the <kbd class="calibre16">forEach()</kbd> method that expects a <kbd class="calibre16">Consumer</kbd> (preferably in the form of a lambda expression) that is invoked for each element of the stack trace walking up the stack. The argument to the <kbd class="calibre16">Consumer</kbd> method is a <kbd class="calibre16">StackFrame</kbd> object.</p>
<p class="mce-root">Although a method named <kbd class="calibre16">forEach</kbd> is also defined by the <kbd class="calibre16">Stream</kbd> interface and the method <kbd class="calibre16">walk()</kbd> passes a <kbd class="calibre16">Stream</kbd> object to the <kbd class="calibre16">Function</kbd> it gets as argument, we should not confuse the two. The <kbd class="calibre16">forEach()</kbd> method of <kbd class="calibre16">StackWalker</kbd> is a simpler, and most of the time less effective way to get through all the elements of the stack trace.</p>
<p class="mce-root">It is less effective, in most cases, because it forces the <kbd class="calibre16">StackWalker</kbd> instance to get all the elements of the stack trace so that the <kbd class="calibre16">forEach()</kbd> method can traverse through each element to the end. If we know that we will not traverse through the stack trace to the end we should use the <kbd class="calibre16">walk()</kbd> method that is accessing the stack the lazy way and thus leave more room for performance optimization.</p>
<p class="mce-root">The <kbd class="calibre16">StackWalker</kbd> class has the <kbd class="calibre16">walk()</kbd> method, which is the defining method that makes it a walker. The method accepts a <kbd class="calibre16">Function</kbd> that is called by the <kbd class="calibre16">StackWalker</kbd>. The return value of the <kbd class="calibre16">walk()</kbd> method will be the object returned by the <kbd class="calibre16">Function</kbd>. The argument to the <kbd class="calibre16">Function</kbd> is a <kbd class="calibre16">Stream&lt;StackFrame&gt;</kbd> that delivers the stack frames. The first frame is the one that contains the <kbd class="calibre16">walk()</kbd> method call, the next is the one that was calling method that contains the call to <kbd class="calibre16">walk()</kbd>, and so on.</p>
<p class="mce-root">The <kbd class="calibre16">Function</kbd> can be used to calculate some value based on the <kbd class="calibre16">StackFrame</kbd> objects that come from the stream and decide if a caller is eligible calling our code or not.</p>
<p class="mce-root">You might ponder, after reviewing the <kbd class="calibre16">walk()</kbd> method that needs a <kbd class="calibre16">Function</kbd> that in turn gets a <kbd class="calibre16">Stream&lt;StackFrame&gt;</kbd> as argument, why it is so complicated. We might wish we could get a <kbd class="calibre16">Stream&lt;StackFrame&gt;</kbd> from the <kbd class="calibre16">StackWalter</kbd> instance directly. The simplest approach would be to pass the stream back from the <kbd class="calibre16">Function</kbd>. Consider the following example:</p>
<pre class="calibre21">    // EXAMPLE OF WHAT NOT TO DO!!!! 
    public static void itIsNotCallBack() { 
      Stream&lt;StackWalker.StackFrame&gt; stream = 
        StackWalker 
          .getInstance(RETAIN_CLASS_REFERENCE) 
          .walk(s -&gt; s); 
      boolean eligible = // YOU GET EXCEPTION!!!! 
        stream.dropWhile(CheckEligibility::inLibrary) 
          .dropWhile(CheckEligibility::notInLibrary) 
          .count() == 0; 
      if (!eligible) { 
        throw new IllegalCallerException(); 
      } 
    } </pre>
<p class="mce-root">What we were doing is simply returning the stream directly from the walker call and walking through it afterwards doing the same calculation. Our results are an <kbd class="calibre16">IllegalStateException</kbd> exception instead of the eligibility check.</p>
<p class="mce-root">The reason for that is that the implementation of the <kbd class="calibre16">StackWalker</kbd> is highly optimized. It does not copy the whole stack to provide source information for the stream. It works from the actual, living stack. To do that it has to be sure that the stack is not modified while the stream is in use. This is something very similar to the <kbd class="calibre16">ConcurrentModificationException</kbd> that we might get if we alter a collection while we iterate over it. If we passed the stream up in the call stack and then wanted to get the <kbd class="calibre16">StackFrame</kbd> out of it, the stream would try to get the information from the stack frame that is long gone, since we returned from the method that it belonged to. That way the <kbd class="calibre16">StackWalker</kbd> does not make a snapshot of the whole stack but rather it works from the actual one and it must ensure that the part of the stack it needs does not change. We may call methods from the <kbd class="calibre16">Function</kbd> and that way we can dig deeper in the call chain but we cannot get higher while the stream is in use.</p>
<p class="mce-root">Also do not try to play other tricks, like extending the <kbd class="calibre16">StackWalker</kbd> class. You cannot. It is a <kbd class="calibre16">final</kbd> class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">StackFrame</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In previous sections, we iterated through the <kbd class="calibre16">StackFrame</kbd> elements, and provided sample code snippets, but did not take the time to examine it more closely. <kbd class="calibre16">StackFrame</kbd> is an interface defined inside the <kbd class="calibre16">StackWalker</kbd> class. It defines accessors, and a converter that can be used to convert the information to <kbd class="calibre16">StackTraceElement</kbd>.</p>
<p class="mce-root">The accessors the interface defines are the following:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">getClassName()</kbd> will return the binary name of the class of the method represented by the <kbd class="calibre16">StackFrame</kbd>.</li>
<li class="calibre14"><kbd class="calibre16">getMethodName()</kbd> will return the name of the method represented by the <kbd class="calibre16">StackFrame</kbd>.</li>
<li class="calibre14"><kbd class="calibre16">getDeclaringClass()</kbd> will return the class of the method represented by the <kbd class="calibre16">StackFrame</kbd>. If the <kbd class="calibre16">Option.RETAIN_CLASS_REFERENCE</kbd> was not used during the creation of the <kbd class="calibre16">StackWalker</kbd> instance then the method will throw <kbd class="calibre16">UnsupportedOperationException</kbd>.</li>
<li class="calibre14"><kbd class="calibre16">getByteCodeIndex()</kbd> gets the index to the code array containing the execution point of the method represented by the <kbd class="calibre16">StackFrame</kbd>. The use of this value can be helpful during bug hunting when looking at the disassembled Java code that the command line tool <kbd class="calibre16">javap</kbd> can give us. The programmatic use of this value can only be valuable for applications that have direct access to the byte code of the code, java agents or libraries that generate byte code during run-time. The method will return a negative number in case the method is native.</li>
<li class="calibre14"><kbd class="calibre16">getFileName()</kbd> returns the name of the source file the method represented by the <kbd class="calibre16">StackFrame</kbd> was defined.</li>
<li class="calibre14"><kbd class="calibre16">getLineNumber()</kbd> returns the line number of the source code.</li>
<li class="calibre14"><kbd class="calibre16">isNativeMethod()</kbd> returns <kbd class="calibre16">true</kbd> if the method represented by the <kbd class="calibre16">StackFrame</kbd> is native and <kbd class="calibre16">false</kbd> otherwise.</li>
</ul>
<p class="mce-root">The <kbd class="calibre16">StackFrame</kbd> does not provide any means to access the object that the method belongs to. You cannot access the arguments and the local variables of the method represented by the <kbd class="calibre16">StackFrame</kbd> and there is no other way you can accomplish that. This is important. Such access would be too invasive and is not possible.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Performance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Our coverage of <kbd class="calibre16">StackWalker</kbd> would not be complete without a look at performance considerations.</p>
<p class="mce-root"><kbd class="calibre16">StackWalker</kbd> is highly optimized and does not create huge memory structures that go unused. That is the reason why we have to use that <kbd class="calibre16">Function</kbd> passed to the method <kbd class="calibre16">walker()</kbd> as an argument. This is also the reason why a <kbd class="calibre16">StackTrace</kbd> is not automatically converted to a <kbd class="calibre16">StackTraceElement</kbd> when created. This only happens if we query the method name, the line number of the specific <kbd class="calibre16">StackTraceElement</kbd>. It is important to understand that this conversion takes a significant amount of time and if it was used for some debug purpose in the code it should not be left there.</p>
<p class="mce-root">To make the <kbd class="calibre16">StackWalker</kbd> even faster we can provide an estimate about the number of <kbd class="calibre16">StackFrame</kbd> elements that we will work with in the stream. If we do not provide such an estimate, the current implementation in the JDK will use eight <kbd class="calibre16">StackFrame</kbd> objects pre-allocated and when that is exhausted, the JDK will allocate more. The JDK will allocate the number of elements based on our estimate unless we estimate a value larger than 256. In that case, the JDK will use 256.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we learned how to use the <kbd class="calibre16">StackWalker</kbd> and provided example code. Our detailed review of the API included different usage scenarios, options, and information. We explained the API's complexity and shared how and how not to use the class. We closed with some related performance issues that the user has to be aware of.</p>
<p class="mce-root">In our next chapter, we will cover over a dozen Java Enhancement Proposals that were incorporated in the Java 9 platform. The featured changes will cover a wide range of tools and updates to APIs that are aimed at making developing with Java easier and the ability to create optimized Java applications. We will look at the new HTTP client, changes to the Javadoc and Doclet API, the new JavaScript parser, JAR and JRE changes, the new Java-level JVM compiler interface, support for TIFF images, platform logging, XML catalog support, collections, new platform-specific desktop features, and enhancements to method handling and the depreciation annotation.</p>


            </article>

            
        </section>
    </div>



  </body></html>