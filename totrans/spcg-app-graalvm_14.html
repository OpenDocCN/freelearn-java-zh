<html><head></head><body>
		<div id="_idContainer164">
			<h1 id="_idParaDest-180"><em class="italic"><a id="_idTextAnchor187"/>Chapter 10</em>: Microservices Architecture with GraalVM</h1>
			<p><a id="_idTextAnchor188"/>In previous chapters, we looked at how GraalVM builds on top of Java VM and provides a high-performance polyglot runtime. In this chapter, we will explore how GraalVM can be the core runtime for running microservices. A lot of microservices frameworks already run on GraalVM. We will explore some of the popular frameworks and build a sample application with them. We will also explore a serverless framework. We will take a case study and look at how we can architect the solution. </p>
			<p>By the end of this chapter, you will have acquired a good understanding of how to package applications as containers, running GraalVM, and how to build microservices applications using Micronaut, Quarkus, and Spring Boot. This chapter expects you to have a fair understanding of the Java programming language and some exposure to building Java microservices. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>An overview of GraalVM microservices architecture</li>
				<li>An understanding of how GraalVM helps to build microservices architecture </li>
				<li>Building microservices applications</li>
				<li>A case study to help understand how to go about solutioning a microservices application built on GraalVM</li>
				<li>Implementing a microservice with Spring Boot, Micronaut, Quarkus, and the Fn Project serverless framework</li>
			</ul>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor189"/>Technical requirements</h1>
			<p>This chapter provides a hands-on guide for building Java microservices. This requires some of the software to be installed and set up. The following is a list of prerequisites:</p>
			<ul>
				<li><strong class="bold">Source code</strong>: All the source code referred to in this chapter can be downloaded from the Git repository at <a href="https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10">https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10</a>.</li>
				<li><strong class="bold">GraalVM</strong>: GraalVM needs to be installed. For detailed instructions on installing and setting up GraalVM, refer to <a href="https://www.graalvm.org/docs/getting-started/#install-graalvm">https://www.graalvm.org/docs/getting-started/#install-graalvm</a>.</li>
				<li><strong class="bold">Spring Boot</strong>: Refer to <a href="https://spring.io/guides/gs/spring-boot/">https://spring.io/guides/gs/spring-boot/</a> for more details on how to set up and use Spring Boot. </li>
				<li><strong class="bold">Micronaut</strong>: We will be building code using the Micronaut framework. Please refer to <a href="https://micronaut.io/download/">https://micronaut.io/download/</a> for more details on how to download and set up Micronaut.</li>
				<li><strong class="bold">Quarkus</strong>: We will be building microservices using the Quarkus framework. Please refer to <a href="https://quarkus.io/">https://quarkus.io/</a> for more details on how to set up and use Quarkus.</li>
				<li><strong class="bold">fn project</strong>: We will be building a serverless application/function using fn project. Please refer to <a href="https://fnproject.io/">https://fnproject.io/</a> for more details on how to download, install, and set up fn project.</li>
				<li>The Code in Action video for this chapter can be found at <a href="https://bit.ly/3f7iT1T">https://bit.ly/3f7iT1T</a>.</li>
			</ul>
			<p>So, let's begin!</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor190"/>Overview of microservices architecture</h1>
			<p>Microservices <a id="_idIndexMarker763"/>are one of the most popular architectural patterns and have been proven to be the best architectural pattern for cloud-native application development. Microservices patterns help to decompose and structure applications into smaller, manageable, and self-contained components that expose functionality through a standard service interface. The following are some of the advantages of microservices architectural patterns:</p>
			<ul>
				<li><strong class="bold">Loose coupling</strong>: Since the application is decomposed into services that provide <a id="_idIndexMarker764"/>a standard interface, the application component can be independently managed, upgraded, and fixed without affecting the other dependent components. This helps in easily changing the application logic based on growing business needs and changes. </li>
				<li><strong class="bold">Manageability</strong>: Since the components are self-contained, it is very easy to manage <a id="_idIndexMarker765"/>these applications. The components can be owned by smaller squads for development and can be deployed independently without deploying the whole application. This assists with rapid development and deployments using DevOps. </li>
				<li><strong class="bold">Scalable</strong>: Scalability is one of the key requirements of cloud-native applications. Scalability in monoliths is an issue, as we have to scale the whole application, even though we just need to scale some part of the functionality. For <a id="_idIndexMarker766"/>example, during high demands, we might want to scale the ordering, shopping cart, and catalog services more than any other functionality of a retail portal. That is not possible in monoliths, but if these components are decomposed into independent microservices, it's easy to scale them individually and set autoscale parameters so that they scale based on demand. This helps in utilizing cloud resources more effectively, at a lower cost.</li>
			</ul>
			<p>Let's now <a id="_idIndexMarker767"/>explore how GraalVM helps to build high-performance microservices architectures.  </p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor191"/>Building microservices architecture with GraalVM </h1>
			<p>GraalVM is <a id="_idIndexMarker768"/>ideal for microservices <a id="_idIndexMarker769"/>architecture as it helps to build high-performance Java applications with a smaller footprint. One of the most important requirements for microservices architecture is a smaller footprint and faster startup. GraalVM is an ideal runtime for running polyglot workloads in the cloud. There <a id="_idIndexMarker770"/>are some cloud-native <a id="_idIndexMarker771"/>frameworks already available on the market that can build applications to run optimally on GraalVM, including Quarkus, Micronaut, Helidon, and Spring. </p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor192"/>Understanding GraalVM containers</h2>
			<p>Traditionally, applications are deployed on infrastructure that was pre-configured and set up for the applications to run. The infrastructure consisted of both hardware and a software <a id="_idIndexMarker772"/>platform that runs the applications. For example, if we have to run a web application, we will have to set up the operating system (such as Linux or Windows, for example) first. The web application server (Tomcat, WebSphere) and database (such as MySQL, Oracle, or DB2) are set up on a pre-defined hardware infrastructure, and then the applications are deployed on top of these web application servers. This takes a lot of time, and we may have to repeat this approach every time we have to set up the applications. </p>
			<p>To reduce the setup time and to make the configurations much easier to manage, we moved to virtualizing the infrastructure by pre-packaging the application, along with various platform <a id="_idIndexMarker773"/>components (application servers, databases, and suchlike) and the operating system, into self-contained <strong class="bold">Virtual Machines</strong> (<strong class="bold">VMs</strong>). (These VMs are not to be confused with <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>). JVM is <a id="_idIndexMarker774"/>more of a platform for running Java applications. VMs in this context are much more than just an application platform.) </p>
			<p>Virtualization helped to solve a lot of configuration and deployment issues. It also allowed us to optimize the usage of hardware resources by running multiple VMs on the same machine and utilizing resources better. VMs are bulky as they come with their own operating system and are tough to rapidly deploy, update, and manage. </p>
			<p>Containerization solved this issue by bringing in another layer of virtualization. Most modern architectures are built on containers. Containers are units of software that package code and all the dependencies and environment configurations. Containers are lightweight, standalone executable packages that be deployed on container runtimes. The following diagram shows the difference between VMs and containers:</p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/Figure_10.1_B16878.jpg" alt="Figure 10.1 – VMs versus containers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – VMs versus containers</p>
			<p>GraalVM is a perfect application platform (especially when it is compiled as native code) to be packaged along with the application in the same container. GraalVM provides the <a id="_idIndexMarker775"/>smallest footprint and faster startups and execution to rapidly deploy and scale up the application components. </p>
			<p>The preceding diagram shows how the application can be containerized with GraalVM. In the previous model, each of the containers has its own VM, which has logic for memory management, profiling, optimization (<strong class="bold">JIT</strong>), and so on. What GraalVM provides is a common runtime along with the container runtime, and just the application logic is containerized. Since GraalVM also supports multiple languages and interoperability between these languages, the containers can be running application code that is written in multiple languages. </p>
			<p>The following diagram shows the various scenarios of how containers can be deployed with GraalVM:</p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/Figure_10.2_B16878.jpg" alt="Figure 10.2 – GraalVM container patterns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – GraalVM container patterns</p>
			<p>In the preceding diagram, we can <a id="_idIndexMarker776"/>see various configurations/scenarios. Let's go through the details:</p>
			<ul>
				<li><strong class="bold">Container 1</strong>: In this container, we can see a native image running. This is by far the most optimal configuration with the smallest footprint and a faster load. </li>
				<li><strong class="bold">Container 2</strong>: In this container, we have a Java application and a JavaScript application running on Truffle with interoperability.</li>
				<li><strong class="bold">Container 3</strong>: Similar to container 2, we also can see a C/C++ application. </li>
			</ul>
			<p>Container 1 is the most optimal configuration for running cloud-native unless we have application code written in a different programming language that needs to interoperate. Another approach is to compile native images and split them into separate containers and use standard protocols such as REST to interact. </p>
			<p>These containers can be deployed in the cloud using various orchestrators, such as Docker Swarm, Kubernetes (including Azure Kubernetes Service, AWS Elastic Kubernetes Service, and Google Kubernetes Engine), AWS Fargate, and Red Hat OpenShift. </p>
			<p>Let's explore <a id="_idIndexMarker777"/>how GraalVM can be used as a common runtime in microservices architecture with the help of a case study.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor193"/>Case study – online book library</h1>
			<p>To understand how to implement microservices on GraalVM using various modern microservices frameworks, let's go through a very simple case study. Later in the chapter, we will <a id="_idIndexMarker778"/>pick one of the services from this architecture and build it using different frameworks.</p>
			<p>This case study involves building a simple website that shows a catalog of books. The catalog lists all the books. You can search and browse the books by specific keywords and should be able to select and obtain more details relating to the book. The user can then select and save it as a wishlist in a library of books. In the future, this can be extended to place an order for this book. But to keep it simple, let's assume that we're searching, browsing, and <a id="_idIndexMarker779"/>creating personal libraries in <strong class="bold">MVP</strong> (<strong class="bold">Minimum Viable Product</strong>) scope. Let's also have a section in the catalog where the user can see a book prediction based on what is in their library. This will help us to do a polyglot with some machine learning code, too.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor194"/>Functional architecture </h2>
			<p>Let's go through <a id="_idIndexMarker780"/>the thought process of building <a id="_idIndexMarker781"/>this application. We will first start by decomposing the functionality. For this, we will require the following services:</p>
			<ul>
				<li><strong class="bold">Catalogue UI Service</strong>: This web page is the home page where the user lands after <a id="_idIndexMarker782"/>successfully logging in (we will not be implementing the login, authentication, and authorization in MVP). This web page presents a way to search and view the books. This will <a id="_idIndexMarker783"/>be implemented as a micro-frontend (refer to <a href="https://micro-frontends.org/">https://micro-frontends.org/</a> for more details on micro-frontends). We will have three UI components as follows:<p>i. <strong class="bold">Book List UI component</strong>: This component shows a list of all the books.</p><p>ii. <strong class="bold">Book Details UI component</strong>: This <a id="_idIndexMarker784"/>component shows all the details pertaining to the selected book.</p><p>iii. <strong class="bold">Predicted Books UI component</strong>: This component shows the books that are predicted, based on the books in the library.</p></li>
				<li><strong class="bold">Library UI Service</strong>: This lists <a id="_idIndexMarker785"/>the books in your personal <a id="_idIndexMarker786"/>library and allows the user to add or delete books from this library.</li>
			</ul>
			<p>Now, to support these UI services, we will require microservices that store, fetch, and search the books. The following are the services that we will need:</p>
			<ul>
				<li><strong class="bold">Catalogue Service</strong>: These <a id="_idIndexMarker787"/>services provide <a id="_idIndexMarker788"/>the RESTful APIs to browse, search, and view the book details. </li>
				<li><strong class="bold">Prediction Service</strong>: To demonstrate the polyglot feature of GraalVM, let's assume <a id="_idIndexMarker789"/>that we already have machine learning code that we have developed using Python, and that can predict the book, based on the books that are available in the library. We will embed this Python code in this Java microservice to demonstrate how GraalVM can help us to build optimized embedding polyglot applications.</li>
				<li><strong class="bold">Library Service</strong>: This <a id="_idIndexMarker790"/>service will provide all the restful APIs for <a id="_idIndexMarker791"/>accessing books in the library, as well as for adding and deleting them from the library. </li>
				<li><strong class="bold">Book Info Service</strong>: Let's <a id="_idIndexMarker792"/>decide to use the Google Books API (<a href="https://developers.google.com/books">https://developers.google.com/books</a>) to get all the details about the books. We <a id="_idIndexMarker793"/>will need a service that proxies the Google Books API. This will help us to manage the data that is coming from the Google Books API. This also provides a proxy layer, so that we can always switch to a different Book API service without changing the whole application. </li>
			</ul>
			<p>Now we will need storage to store the information about the books that have been added to <a id="_idIndexMarker794"/>the personal libraries and to cache the <a id="_idIndexMarker795"/>data about the books, for faster fetching (instead of calling the Google Books API every time). To do so, we will require the following data services:</p>
			<ul>
				<li><strong class="bold">User Profile Data</strong>: This stores the user profiles.</li>
				<li><strong class="bold">User Library Data</strong>: This stores the books that the particular user has selected for their library.</li>
				<li><strong class="bold">Book Cache Data</strong>: We will need to cache the book information so that we don't have to call the Google Books API for information that we have already fetched. This will not only improve performance; it will also reduce costs as the Google Books API may charge you for the number of calls made. </li>
			</ul>
			<p>The following diagram illustrates how these components work together: </p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/Figure_10.3_B16878.jpg" alt="Figure 10.3 – Book library application – functional architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Book library application – functional architecture</p>
			<p>We have taken various architectural decisions while building the final architecture. Let's quickly review them:</p>
			<ul>
				<li><strong class="bold">Micro-frontends</strong>: We decided to make the UI components micro-frontends so that it's <a id="_idIndexMarker796"/>easier for us to manage and reuse the UI code. As we can see, both the catalog UI and library UI reuse the same components to render the list of books and show the book details. We are choosing ReactJS as this provides a very sound framework for micro-frontend implementation.</li>
				<li><strong class="bold">Embedding Python</strong>: We <a id="_idIndexMarker797"/>decided to reuse the Python code already built for prediction. We decided to embed that as part of our catalog service to provide an endpoint that will provide a list of predicted books. This will also help us to demonstrate the capabilities of polyglot. We will use the pure Java implementation of microservices, as most modern microservices frameworks do not support polyglot.</li>
				<li><strong class="bold">Serverless</strong>: We <a id="_idIndexMarker798"/>decided to render the book info service <em class="italic">serverless</em> as it does not need to keep the state; it just calls the Google Books API and passes the information. </li>
				<li><strong class="bold">Book information cache</strong>: We decided to use Redis to store the book information <a id="_idIndexMarker799"/>cache so that we don't have to go back to the Google Books API each time, thereby improving performance and reducing the cost of calling Google APIs.</li>
			</ul>
			<p>Let's now look at what the deployment architecture will look like on Kubernetes. Please refer to <a href="https://kubernetes.io/">https://kubernetes.io/</a> for more <a id="_idIndexMarker800"/>details on how Kubernetes orchestrates the containers and provides a scalable and highly available solution. The following section assumes that you have a good understanding of Kubernetes.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor195"/>Deployment architecture</h2>
			<p>The containers <a id="_idIndexMarker801"/>are deployed on the Kubernetes cluster. The <a id="_idIndexMarker802"/>following diagram shows the deployment architecture of these containers in Kubernetes. This can be similar in any cloud:</p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/Figure_10.4_B16878.jpg" alt="Figure 10.4 – Kubernetes deployment architecture for the book library application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Kubernetes deployment architecture for the book library application</p>
			<p>Let's understand <a id="_idIndexMarker803"/>the terms used in the <a id="_idIndexMarker804"/>preceding diagram in more detail:</p>
			<ul>
				<li><strong class="bold">Ingress Service deployment</strong>: Ingress Service will be the entry to the cluster. This will <a id="_idIndexMarker805"/>be a Kubernetes deployment that has the inbound port as <strong class="source-inline">8080</strong>, and the target port pointing to the cluster IP of the Catalogue UI page, which is the home page.</li>
				<li><strong class="bold">ClusterUIService deployment</strong>: This deployment has the <strong class="source-inline">reactjs</strong> implementation of the home page and the library page, which internally use the same <a id="_idIndexMarker806"/>set of <strong class="source-inline">reactjs</strong> components. This calls Library Service to get the information regarding the books stored in the personal library. This service also calls Catalog Service, which has all the REST endpoints to search and  browse the book's details. </li>
				<li><strong class="bold">LibraryService deployment</strong>: Library Service is implemented in Quarkus as a native image <a id="_idIndexMarker807"/>and provides the endpoints for accessing personal library information. This uses Library Data Service.</li>
				<li><strong class="bold">LibraryDataService deployment</strong>: Library Data Service is a PostgreSQL container that stores <a id="_idIndexMarker808"/>all the user profile and personal library information. It also uses a persistent volume so that when a node goes down, the information is stored. </li>
				<li><strong class="bold">CatalogueInfoService deployment</strong>: This deployment has the implementation of <strong class="source-inline">CatalogueInfoService</strong> in Quarkus native mode. This service provides <a id="_idIndexMarker809"/>the endpoints to search, browse, and get various details relating to the book. <strong class="source-inline">BookInfoService</strong> is used to get all the information pertaining to the book. <strong class="source-inline">CatalogueInfoService</strong> also uses the <strong class="source-inline">BookInfoCache</strong> service to fetch data that is already in cache.</li>
				<li><strong class="bold">BookInfoService deployment</strong>: This deployment has a serverless implementation <a id="_idIndexMarker810"/>service that fetches various book information from the Google Books API. This will be implemented using the fn project serverless framework running on GraalVM.</li>
				<li><strong class="bold">BookInfoCacheService deployment</strong>: This deployment is a Redis cache that caches <a id="_idIndexMarker811"/>all the book information, so as to avoid redundant calls to the Google Books API.</li>
			</ul>
			<p>The final finished source code can be found in the Git repository. We will not be discussing <a id="_idIndexMarker812"/>the source code, but simply to gain a good <a id="_idIndexMarker813"/>understanding of how to build these microservices, we will pick <strong class="source-inline">BookInfoService</strong> and implement it with various microservices frameworks in the next section.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor196"/>Exploring modern microservices frameworks</h1>
			<p>There are modern frameworks that are built around creating microservices rapidly. These frameworks <a id="_idIndexMarker814"/>are built on the basis of the <strong class="bold">Container-First</strong> and <strong class="bold">Cloud-First</strong> design principles. They are built from the ground up, with <a id="_idIndexMarker815"/>a fast boot time and a low memory <a id="_idIndexMarker816"/>footprint. Helidon, Micronaut, and Quarkus are three of the most widely used modern Java frameworks. All three frameworks run natively on GraalVM. Each of these frameworks promises faster startup and a low memory footprint, and they achieve this by means of different methods. Let's explore these frameworks in this section.</p>
			<p>To understand these frameworks, let's now get hands-on in building a simple book information service. It is a simple service that accepts a keyword, uses the Google Books API to retrieve the book information, and returns detailed information relating to all the books that <a id="_idIndexMarker817"/>match the keyword. The response is returned as <strong class="bold">JSON</strong> (<strong class="bold">JavaScript Object Notation</strong> – refer to <a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a> for more details).</p>
			<p>Let's first <a id="_idIndexMarker818"/>start with a traditional microservice that we build using Spring Boot without GraalVM</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor197"/>Building BookInfoService using Spring without GraalVM</h2>
			<p>Spring <a id="_idIndexMarker819"/>is one of the most widely used Java microservices frameworks. It comes with a lot of great features and is one of the popular frameworks used to build cloud-native <a id="_idIndexMarker820"/>applications. In this <a id="_idIndexMarker821"/>section, we will build in the traditional way without GraalVM, so as to understand the shortcomings of the traditional approach.</p>
			<h3>Creating Spring boilerplate code</h3>
			<p>To create the Spring boilerplate code, let's go to <a href="https://start.spring.io/">https://start.spring.io/</a> on a browser. This website <a id="_idIndexMarker822"/>helps us to specify some configurations and generate the boilerplate code. Let's generate the boilerplate code for our <strong class="source-inline">BookInfoService</strong>. The following screenshot shows the Spring initializer:</p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/Figure_10.5_B16878.jpg" alt="Figure 10.5 – Spring Initializr screenshot that generates boilerplate code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Spring Initializr screenshot that generates boilerplate code</p>
			<p>The preceding screenshot shows the configurations selected to generate the boilerplate. To keep it simple and focused, we are selecting <strong class="bold">Spring Web</strong>. We will use a simple <strong class="source-inline">HttpClient</strong> to call the Google APIs so as to keep it simple for ou, instead of the recommended way of using jsonb and so on. </p>
			<p>We need to extract the ZIP file that is generated and then implement the service. The following is <a id="_idIndexMarker823"/>the core logic code snippet. The full code is available in the Git repository at <a href="https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM">https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM</a>: </p>
			<p class="source-code">@RestController</p>
			<p class="source-code">public class BookInfoServiceController {</p>
			<p class="source-code">    @RequestMapping("/book-info")</p>
			<p class="source-code">    public String bookInfo(@RequestParam String query) {</p>
			<p>In the preceding code, we are setting the path as <strong class="source-inline">/book-info</strong> in order to call <strong class="source-inline">BookInfoService</strong>. In the following code, we will call the Google API to get the book information:</p>
			<p class="source-code">        String responseJson ="{}";</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            String url = "https://www.googleapis.com/                books/v1/volumes?q="+query+"&amp;key=&lt;your google                     api key&gt;";</p>
			<p class="source-code">            HttpClient client = HttpClient.newHttpClient();</p>
			<p class="source-code">            HttpRequest request = HttpRequest.newBuilder()                .uri(URI.create(url)).build();</p>
			<p class="source-code">            HttpResponse&lt;String&gt; response;</p>
			<p class="source-code">            response =                 client.send(request, BodyHandlers.ofString());</p>
			<p class="source-code">            responseJson = response.body();</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            responseJson = "{'error','"+e.getMessage()+"'}";</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        } </p>
			<p class="source-code">        return responseJson;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we are calling the Google Books API using our Google API key. You have to get your own key and include it in the URL. Refer to <a href="https://cloud.google.com/apis/docs/overview">https://cloud.google.com/apis/docs/overview</a> for more details on how to get your own Google API. We are calling the Google Books API using <strong class="source-inline">HttpClient</strong> and passing the response to the requester.</p>
			<p>Let's now <a id="_idIndexMarker824"/>build this code and run it. We will be using Maven to build it. The following command will build the code: </p>
			<p class="source-code">./mvnw package</p>
			<p>This will download all the dependencies, build the application, and generate a JAR file. You will find the JAR file under the target folder. We should be able to run the JAR file using the following command: </p>
			<p class="source-code">java -jar target/book-info-service-0.0.1-SNAPSHOT.jar</p>
			<p>This will start the Spring Boot application. The following screenshot shows the output of running the application:</p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/Figure_10.6_B16878.jpg" alt="Figure 10.6 – Output screenshot of the Spring BookInfoService application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – Output screenshot of the Spring BookInfoService application</p>
			<p>Now, let's access <a id="_idIndexMarker825"/>this application using a REST client. In this <a id="_idIndexMarker826"/>case, we are using <strong class="source-inline">CocoaRestClient</strong> (<a href="https://mmattozzi.github.io/cocoa-rest-client/">https://mmattozzi.github.io/cocoa-rest-client/</a>). You can use any REST client or even use the browser to invoke the service. Let's invoke http://localhost:8080/book-info?query=graalvm. The following screenshot shows the output: </p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/Figure_10.7_B16878.jpg" alt="Figure 10.7 – Output of invoking the BookInformationService Spring application &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – Output of invoking the BookInformationService Spring application </p>
			<p>Now that we know that the application is running, let's package this application into a Docker container <a id="_idIndexMarker827"/>and build the image. The following is the Dockerfile code for building the image:</p>
			<p class="source-code">FROM adoptopenjdk/openjdk11:ubi</p>
			<p class="source-code">ARG JAR_FILE=target/*.jar</p>
			<p class="source-code">COPY ${JAR_FILE} bookinfo.jar</p>
			<p class="source-code">ENTRYPOINT ["java","-jar","/bookinfo.jar"]</p>
			<p>This is a very simple Dockerfile. We are building the image using <strong class="source-inline">openjdk11</strong> as the base. We are then copying the jar file that we generated and specifying the entry point to run the jar file when we start the container. Let's now build the Docker image using the following command:</p>
			<p class="source-code">docker build -t abvijaykumar/bookinfo-traditional .</p>
			<p>Please feel free to use your name tag for the Docker image. These Docker images are also available on the author's Docker Hub at <a href="https://hub.docker.com/u/abvijaykumar">https://hub.docker.com/u/abvijaykumar</a>. This will build an image. We should be able to see whether the image has been created by using the following command:</p>
			<p class="source-code">docker images</p>
			<p>Let's run <a id="_idIndexMarker828"/>this image using the following command:</p>
			<p class="source-code">docker run -p 8080:8080 abvijaykumar/bookinfo-traditional</p>
			<p>The following screenshot shows the output of running the previous command:</p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/Figure_10.8_B16878.jpg" alt="Figure 10.8 – Console output of running the BookInformationService Spring application &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – Console output of running the BookInformationService Spring application </p>
			<p>We can see that it booted up in 2.107 seconds. We should be able to call the service. The following screenshot shows the output after calling <strong class="source-inline">http://localhost:8080/book-info?query=graalvm</strong>:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/Figure_10.9_B16878.jpg" alt="Figure 10.9 – Result of invoking the BookInformationService Spring application in a container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – Result of invoking the BookInformationService Spring application in a container</p>
			<p>Let's now <a id="_idIndexMarker829"/>use the modern frameworks to build the same service to understand and compare how these modern frameworks perform better with GraalVM.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor198"/>Building BookInfoService with Micronaut</h2>
			<p>Micronaut is a full-stack microservices framework introduced by the developers of the Grails <a id="_idIndexMarker830"/>framework. It has an integration with all the ecosystem and tools and relies on compile-time integration, rather than runtime integration. This makes the final applications <a id="_idIndexMarker831"/>run faster, as they are compiled <a id="_idIndexMarker832"/>with all the dependencies during build time. It achieves this with annotation and aspect-oriented programming concepts of <a id="_idIndexMarker833"/>code injection at build time. This was introduced in 2018. For more details on Micronaut, please refer to <a href="https://micronaut.io/">https://micronaut.io/</a>.</p>
			<p>Let's build <strong class="source-inline">BookInfoService</strong> with Micronaut. To get started, we need to install the Micronaut command line. Refer to <a href="https://micronaut.io/download/">https://micronaut.io/download/</a> for detailed instructions on installing the Micronaut CLI. Once installed, we should be able to call the <strong class="source-inline">mn</strong> command. Let's now create our <strong class="source-inline">BookInfoService</strong> Micronaut boilerplate code with <strong class="source-inline">mn</strong>. The following command creates the boilerplate code. We are passing the <strong class="source-inline">-b=maven</strong> flag to create the Maven build:</p>
			<p class="source-code">  mn create-app com.abvijay.f.mn.bookinfoservice -b=maven</p>
			<p class="source-code">| Application created at /Users/vijaykumarab/Google Drive/GraalVM-Book/Code/chapter9/mn/bookinfoservice</p>
			<p>We <a id="_idIndexMarker834"/>should see a directory created called <strong class="source-inline">bookinfoservice</strong> where all the generated boilerplate <a id="_idIndexMarker835"/>code is created. Let's now set the <a id="_idIndexMarker836"/>environment to point to GraalVM. To validate whether we are using the right version of GraalVM, we can check by running <strong class="source-inline">java-version</strong>. The following output shows the version of GraalVM:</p>
			<p class="source-code">java -version</p>
			<p class="source-code">java version "11.0.10" 2021-01-19 LTS</p>
			<p class="source-code">Java(TM) SE Runtime Environment GraalVM EE 21.0.0.2 (build 11.0.10+8-LTS-jvmci-21.0-b06)</p>
			<p class="source-code">Java HotSpot(TM) 64-Bit Server VM GraalVM EE 21.0.0.2 (build 11.0.10+8-LTS-jvmci-21.0-b06, mixed mode, sharing)</p>
			<p>Let's now update the Micronaut code to implement our logic. The following code snippet shows the code for <strong class="source-inline">Controller</strong>, which exposes the REST endpoint:</p>
			<p class="source-code">@Controller("/bookinfo")</p>
			<p class="source-code">public class BookInfoController {</p>
			<p class="source-code">    @Get("get-info") </p>
			<p class="source-code">    public String getBookInfo(String query) {</p>
			<p class="source-code">        BookInfoService svc = new BookInfoService();</p>
			<p class="source-code">        String ret = svc.fetch(query);</p>
			<p class="source-code">        return ret;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">BookInfoService</strong> class has the exact same code as what we implemented in Spring Boot in the preceding code. Let's now compile the Micronaut project by executing the following command:</p>
			<p class="source-code">./mvnw package</p>
			<p>We can <a id="_idIndexMarker837"/>then run the Micronaut application by executing the following command:</p>
			<p class="source-code">./mvnw mn:run</p>
			<p>The following <a id="_idIndexMarker838"/>screenshot shows the output <a id="_idIndexMarker839"/>when we run the Micronaut application: </p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/Figure_10.10_B16878.jpg" alt="Figure 10.10 – Console output of running the Micronaut BookInformationService Spring application &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – Console output of running the Micronaut BookInformationService Spring application </p>
			<p>We can see that it took just 500 milliseconds to load the Micronaut application, as compared to Spring Boot in the <em class="italic">Building BookInfoService using Spring without GraalVM</em> section, which took around 2 seconds. This is significantly fast, considering how simple and small our application is. Let's now build a Docker image of this application. Micronaut provides a direct way to build a Docker image with Maven by passing the <strong class="source-inline">-Dpackaging=docker</strong> argument. The following command will generate the Docker image directly:</p>
			<p class="source-code">mvn package -Dpackaging=docker</p>
			<p>Micronaut can also generate the Dockerfile so that we can customize and execute separately. The Dockerfiles are created under the target directory when we pass the <strong class="source-inline">-mn:dockerfile</strong> argument to the command. The following is the Dockerfile that is created: </p>
			<p class="source-code">FROM openjdk:15-alpine</p>
			<p class="source-code">WORKDIR /home/app</p>
			<p class="source-code">COPY classes /home/app/classes</p>
			<p class="source-code">COPY dependency/* /home/app/libs/</p>
			<p class="source-code">EXPOSE 8080</p>
			<p class="source-code">ENTRYPOINT ["java", "-cp", "/home/app/libs/*:/home/app/classes/", "com.abvijay.chapter9.mn.Application"]</p>
			<p>We can <a id="_idIndexMarker840"/>see that the Docker image is built on <strong class="source-inline">openjdk</strong>. We are still not using the GraalVM native image feature. Let's build this image by calling the following command:</p>
			<p class="source-code">docker build -t abvijaykumar/bookinfo-micronaut .</p>
			<p class="source-code">docker images</p>
			<p>Let's now run this Docker image by calling the following command:=</p>
			<p class="source-code">docker run -p 8080:8080 abvijaykumar/bookinfo-micronaut  </p>
			<p>The following shows the output of running the preceding command:</p>
			<p class="source-code"> __  __ _                                  _   </p>
			<p class="source-code">|  \/  (_) ___ _ __ ___  _ __   __ _ _   _| |_ </p>
			<p class="source-code">| |\/| | |/ __| '__/ _ \| '_ \ / _` | | | | __|</p>
			<p class="source-code">| |  | | | (__| | | (_) | | | | (_| | |_| | |_ </p>
			<p class="source-code">|_|  |_|_|\___|_|  \___/|_| |_|\__,_|\__,_|\__|</p>
			<p class="source-code">  Micronaut (v2.4.1)</p>
			<p class="source-code">01:24:35.391 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 1566ms. Server Running: http://7df31221ee43:8080</p>
			<p>We can see that the application started in 1.5 seconds, which is still faster than the Spring image. We are still not using the GraalVM native image feature. Let's now build the same <a id="_idIndexMarker841"/>application as a GraalVM native image. To build <a id="_idIndexMarker842"/>a native image, Micronaut <a id="_idIndexMarker843"/>supports a Maven profile, which can be invoked by passing the <strong class="source-inline">-Dpackaging=native-image</strong> argument to the command. The following command creates the native image: </p>
			<p class="source-code">./mvnw package -Dpackaging=native-image</p>
			<p class="source-code">docker images</p>
			<p>Let's now generate the Dockerfile to understand how this image is created. To generate the Dockerfile, we need to execute the following command:</p>
			<p class="source-code">mvn mn:dockerfile -Dpackaging=docker-native</p>
			<p>This will generate the Dockerfile under the target directory. The following code shows the Dockerfile: </p>
			<p class="source-code">FROM ghcr.io/graalvm/graalvm-ce:java11-21.0.0.2 AS builder</p>
			<p class="source-code">RUN gu install native-image</p>
			<p class="source-code">WORKDIR /home/app</p>
			<p class="source-code">COPY classes /home/app/classes</p>
			<p class="source-code">COPY dependency/* /home/app/libs/</p>
			<p class="source-code">RUN native-image -H:Class=com.abvijay.chapter9.mn.Application -H:Name=application --no-fallback -cp "/home/app/libs/*:/home/app/classes/"</p>
			<p class="source-code">FROM frolvlad/alpine-glibc:alpine-3.12</p>
			<p class="source-code">RUN apk update andand apk add libstdc++</p>
			<p class="source-code">COPY --from=builder /home/app/application /app/application</p>
			<p class="source-code">EXPOSE 8080</p>
			<p class="source-code">ENTRYPOINT ["/app/application"]</p>
			<p>We can <a id="_idIndexMarker844"/>see that this is a multi-phase Dockerfile. In the first phase, we are installing the native image, copying all the required application <a id="_idIndexMarker845"/>files into the image, and finally <a id="_idIndexMarker846"/>running the <strong class="source-inline">native-image</strong> command to create the native image. In the second phase, we are copying the native image and providing an entry point. </p>
			<p>Let's run this image and see how fast it loads. Let's execute the following command:</p>
			<p class="source-code"> docker run -p 8080:8080 bookinfoservice</p>
			<p>The following output shows that it took just 551 milliseconds for the image to load, which is almost half the time it took for the non-GraalVM Micronaut application:</p>
			<p class="source-code">/app/application: /usr/lib/libstdc++.so.6: no version information available (required by /app/application)</p>
			<p class="source-code"> __  __ _                                  _</p>
			<p class="source-code">|  \/  (_) ___ _ __ ___  _ __   __ _ _   _| |_</p>
			<p class="source-code">| |\/| | |/ __| '__/ _ \| '_ \ / _` | | | | __|</p>
			<p class="source-code">| |  | | | (__| | | (_) | | | | (_| | |_| | |_</p>
			<p class="source-code">|_|  |_|_|\___|_|  \___/|_| |_|\__,_|\__,_|\__|</p>
			<p class="source-code">  Micronaut (v2.4.1)</p>
			<p class="source-code">09:16:19.604 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 551ms. Server Running: http://da2bf01c90e4:8080</p>
			<p>We can see how easy it is to create a microservice with Micronaut, and how it seamlessly integrates with the GraalVM toolchain to generate Docker images with a very small footprint and fast loading. </p>
			<p>Quarkus is another very popular microservices framework. Let's now explore Quarkus and build the same service using Quarkus.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor199"/>Building BookInfoService with Quarkus</h2>
			<p>Quarkus was developed by Red Hat and provides the most sophisticated list of integration <a id="_idIndexMarker847"/>with the Java ecosystem of frameworks. It is <a id="_idIndexMarker848"/>built on top of the MicroProfile, Vert.x, Netty, and Hibernate standards. It is built as a fully Kubernetes-native <a id="_idIndexMarker849"/>framework. This was introduced in 2019.</p>
			<p>Let's now build <strong class="source-inline">BookInfoService</strong> using Quarkus. Quarkus provides a starter code generator at <a href="http://code.quarkus.io">http://code.quarkus.io</a>. Let's go to that website and generate our code. The following screenshot shows the configurations that are selected to generate our <strong class="source-inline">BookInfoService</strong> boilerplate code. We are also including RESTEasy JAX-RS to create our endpoint: </p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/Figure_10.11_B16878.jpg" alt="Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code</p>
			<p>This <a id="_idIndexMarker850"/>will generate code in a zip file (we can also provide a Git repository, where Quarkus will automatically push the code). Let's now download the zip file and then extract and compile <a id="_idIndexMarker851"/>it with the following command: </p>
			<p class="source-code">./mvnw compile quarkus:dev. </p>
			<p>The best <a id="_idIndexMarker852"/>part about Quarkus is that when we execute this command, it provides a way for us to edit the code and test it without restarting the server. This helps in building the application rapidly. Now, let's update the Quarkus code to our <strong class="source-inline">BookInfoService</strong> endpoint. </p>
			<p>The following code shows implementation of the endpoint:</p>
			<p class="source-code">@Path("/bookinfo")</p>
			<p class="source-code">public class BookInfoService {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Produces(MediaType.TEXT_PLAIN)</p>
			<p class="source-code">    @Path("/getBookInfo/{query}")</p>
			<p class="source-code">    public String getBookInfo(@PathParam String query) {</p>
			<p class="source-code">        String responseJson = "{}";</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            String url = "https://www.googleapis.com/books/                v1/volumes?q=" + query                     + "andkey=&lt;your google api key&gt;";</p>
			<p class="source-code">            HttpClient client = HttpClient.newHttpClient();</p>
			<p class="source-code">            HttpRequest request =                HttpRequest.newBuilder()                    .uri(URI.create(url)).build();</p>
			<p class="source-code">            HttpResponse&lt;String&gt; response;</p>
			<p class="source-code">            response = client.send(request,                BodyHandlers.ofString());</p>
			<p class="source-code">            responseJson = response.body();</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            responseJson =                 "{'error', '" + e.getMessage() + "'}";</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return responseJson;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>While we update the code and save it, Quarkus automatically updates the runtime. We don't have to restart the server. The following screenshot shows the output of calling our <strong class="source-inline">bookservice</strong> that is running with Quarkus:</p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/Figure_10.12_B16878.jpg" alt="Figure 10.12 – Result of invoking the Quarkus implementation of the &#13;&#10;BookInformationService application &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – Result of invoking the Quarkus implementation of the BookInformationService application </p>
			<p>Let's <a id="_idIndexMarker853"/>now build <a id="_idIndexMarker854"/>a GraalVM native image using Quarkus. To do <a id="_idIndexMarker855"/>that, we need to edit the <strong class="source-inline">pom.xml</strong> file and make sure we have the following profile:</p>
			<p class="source-code">&lt;profiles&gt;</p>
			<p class="source-code">    &lt;profile&gt;</p>
			<p class="source-code">        &lt;id&gt;native&lt;/id&gt;</p>
			<p class="source-code">        &lt;properties&gt;</p>
			<p class="source-code">            &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;</p>
			<p class="source-code">        &lt;/properties&gt;</p>
			<p class="source-code">    &lt;/profile&gt;</p>
			<p class="source-code">&lt;/profiles&gt;</p>
			<p>Quarkus uses Mandrel, which is a downstream distribution of GraalVM. You can read more about <a id="_idIndexMarker856"/>Mandrel at <a href="https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/">https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/</a>.</p>
			<p>Let's <a id="_idIndexMarker857"/>now build the native image. Quarkus provides a direct Maven profile to build native images. We <a id="_idIndexMarker858"/>can create a native image by executing <a id="_idIndexMarker859"/>the following command:</p>
			<p class="source-code">mvn package -Pnative</p>
			<p>This will create the native build under the target folder. Let's run the native build directly. The following shows the output after running the native image:</p>
			<p class="source-code">./bookinfoservice-1.0.0-SNAPSHOT-runner </p>
			<p class="source-code">__  ____  __  _____   ___  __ ____  ______ </p>
			<p class="source-code"> --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ </p>
			<p class="source-code"> -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \   </p>
			<p class="source-code">--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   </p>
			<p class="source-code">2021-03-31 11:26:31,564 INFO  [io.quarkus] (main) bookinfoservice 1.0.0-SNAPSHOT native (powered by Quarkus 1.13.0.Final) started in 0.015s. Listening on: http://0.0.0.0:8080</p>
			<p class="source-code">2021-03-31 11:26:31,843 INFO  [io.quarkus] (main) Profile prod activated. </p>
			<p class="source-code">2021-03-31 11:26:31,843 INFO  [io.quarkus] (main) Installed features: [cdi, rest-client, rest-client-jsonb, resteasy]</p>
			<p>We can see that it took just <strong class="source-inline">0.015s</strong> to start the application. This is significantly faster than the traditional implementations, which took around 2 seconds to start up. </p>
			<p>Quarkus <a id="_idIndexMarker860"/>also created various Dockerfile versions, and we can find these under the Docker folder. The <a id="_idIndexMarker861"/>following screenshot shows the <a id="_idIndexMarker862"/>list of Dockerfiles that Quarkus automatically creates: </p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/Figure_10.13_B16878.jpg" alt="Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus creates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus creates</p>
			<p>Let's quickly explore these various types of Dockerfiles:</p>
			<ul>
				<li><strong class="bold">Dockerfile.legacy-jar</strong> and <strong class="bold">Dockerfile.jvm</strong>: This Dockerfile has the commands <a id="_idIndexMarker863"/>to build a Docker image <a id="_idIndexMarker864"/>with a normal Quarkus application, JAR, and OpenJDK headless.</li>
				<li><strong class="bold">Dockerfile.native</strong>: This <a id="_idIndexMarker865"/>Dockerfile builds the native image. </li>
				<li><strong class="bold">Dockerfile.native-distroless</strong>: This Docker file also generates an image with a native image, but uses the new technique introduced by Google to build the image <a id="_idIndexMarker866"/>that contains just the application, language runtime, and no operating system distribution. This helps in creating a small image, and has fewer vulnerabilities. Refer to <a href="https://github.com/GoogleContainerTools/distroless">https://github.com/GoogleContainerTools/distroless</a><span class="hidden"> </span>for more details on distroless containers.</li>
			</ul>
			<p>We can create Docker images of these various Docker versions by executing the following commands:</p>
			<p class="source-code"><strong class="bold">docker build -f ./src/main/docker/Dockerfile.jvm -t abvijaykumar/bookinfo-quarkus-jvm .</strong></p>
			<p class="source-code"><strong class="bold">docker build -f ./src/main/docker/Dockerfile.jvm-legacy -t abvijaykumar/bookinfo-quarkus-jvm-legacy .</strong></p>
			<p class="source-code"><strong class="bold">docker build -f ./src/main/docker/Dockerfile.native -t abvijaykumar/bookinfo-quarkus-native .</strong></p>
			<p class="source-code"><strong class="bold">docker build -f ./src/main/docker/Dockerfile.native-distroless -t abvijaykumar/bookinfo-quarkus-native-distroless .</strong></p>
			<p>To <a id="_idIndexMarker867"/>compare <a id="_idIndexMarker868"/>the sizes of these images, lets run the <a id="_idIndexMarker869"/>following command:</p>
			<p class="source-code"> docker images</p>
			<p>The following chart compares the sizes of each of these images:</p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/Figure_10.14_B16878.jpg" alt="Figure 10.14 – Chart comparing the size of Docker images&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.14 – Chart comparing the size of Docker images</p>
			<p>At the <a id="_idIndexMarker870"/>time of writing this book, the smallest footprint and the fastest executing GraalVM microservice <a id="_idIndexMarker871"/>image is built using a Quarkus <a id="_idIndexMarker872"/>native distroless image. Spring has also <a id="_idIndexMarker873"/>launched Spring Native (<a href="https://spring.io/blog/2021/03/11/announcing-spring-native-beta">https://spring.io/blog/2021/03/11/announcing-spring-native-beta</a>) and Oracle has Helidon (<a href="https://helidon.io/#/">https://helidon.io/#/</a>), which <a id="_idIndexMarker874"/>provide similar frameworks to run on GraalVM. </p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor200"/>Building a serverless BookInfoService using fn project</h2>
			<p>Function-as-a-Service, or serverless, is another architectural pattern for running code on demand <a id="_idIndexMarker875"/>and utilizes cloud resources. The serverless approach runs the code when a request <a id="_idIndexMarker876"/>is received. The code boots <a id="_idIndexMarker877"/>up, executes, handles the requests, and then shuts down, thereby utilizing cloud resources to the optimum. This provides a highly available, scalable architecture at optimum cost. However, serverless architecture demands a faster boot, quicker execution, and shutdown.</p>
			<p>GraalVM native images (ahead of time) is the best option for serverless, as native images start up and run faster than traditional Java applications. GraalVM native images have a very small footprint, they are fast to boot, and they come with embedded VM (Substrate VM). </p>
			<p>fn project is also a great environment for building serverless applications. Fn supports the building of serverless applications in Go, Java, JavaScript, Python, Ruby, and C#. It is a very simple and rapid application development environment that comes with an fn daemon and a CLI that provides most of the scaffolding to build serverless applications. </p>
			<p>In this <a id="_idIndexMarker878"/>section, let's focus on building the <strong class="source-inline">BookInfoService</strong> function using fn project. Please <a id="_idIndexMarker879"/>refer to <a href="https://fnproject.io/">https://fnproject.io/</a> for detailed instructions <a id="_idIndexMarker880"/>on installing the <strong class="source-inline">fn</strong> command-line interface. We first have to start the fn daemon server using <strong class="source-inline">fn start</strong>. The fn <a id="_idIndexMarker881"/>server runs in Docker, and you can check that by running <strong class="source-inline">docker ps</strong>. The Fn daemon server runs at port <strong class="source-inline">8080</strong>.</p>
			<p>The <strong class="source-inline">fn</strong> command line also provides a way to generate boilerplate code. Let's now generate the project by executing the following command:</p>
			<p class="source-code">fn init --runtime java book-info-service-function</p>
			<p class="source-code">Creating function at: ./book-info-service-function</p>
			<p class="source-code">Function boilerplate generated.</p>
			<p class="source-code">func.yaml created.</p>
			<p>This creates a <strong class="source-inline">book-info-service-function</strong> directory with all the boilerplate code. Let's inspect what is inside that directory. We will find <strong class="source-inline">func.yaml</strong>, <strong class="source-inline">pom.xml</strong>, and <strong class="source-inline">src</strong> directories.</p>
			<p><strong class="source-inline">func.yml</strong> is the main manifest <strong class="source-inline">yaml</strong> file that has the key information about the class that implements the function and the entry point. Let's inspect the configuration file: </p>
			<p class="source-code"><strong class="bold">schema_version: 20180708</strong></p>
			<p class="source-code"><strong class="bold">name: book-info-service-function</strong></p>
			<p class="source-code"><strong class="bold">version: 0.0.1</strong></p>
			<p class="source-code"><strong class="bold">runtime: java</strong></p>
			<p class="source-code"><strong class="bold">build_image: fnproject/fn-java-fdk-build:jdk11-1.0.124</strong></p>
			<p class="source-code"><strong class="bold">run_image: fnproject/fn-java-fdk:jre11-1.0.124</strong></p>
			<p class="source-code"><strong class="bold">cmd: com.example.fn.HelloFunction::handleRequest</strong></p>
			<p>Let's <a id="_idIndexMarker882"/>now understand the preceding configuration file:</p>
			<ul>
				<li><strong class="source-inline">name</strong>: The name of the function. We can see the name of the function that we specified in our <strong class="source-inline">fn init</strong> command line.</li>
				<li><strong class="source-inline">version</strong>: The version of this function.</li>
				<li><strong class="source-inline">runtime</strong>: JVM as the runtime.</li>
				<li><strong class="source-inline">build_image</strong>: The Docker image that should be used to build the Java code; in this case, we see that it's JDK 11.</li>
				<li><strong class="source-inline">run_image</strong>: The Docker image that should be used as a runtime; in this case, it is JRE11.</li>
				<li><strong class="source-inline">cmd</strong>: This is the entry point, which is <strong class="source-inline">ClassName:MethodName</strong>. We will change <strong class="source-inline">cmd</strong> to point to our class and method: <strong class="source-inline">cmd: com.abvijay.chapter9.fn.BookInfoService::getBookInfo</strong>.</li>
			</ul>
			<p>In the <strong class="source-inline">src</strong> folder, we <a id="_idIndexMarker883"/>will create <strong class="source-inline">com.abvijay.chapter9.fn.BookInfoService</strong> with the <strong class="source-inline">getBookInfo()</strong> method. The <a id="_idIndexMarker884"/>implementation of <strong class="source-inline">getBookInfo()</strong> is the same as other implementations we performed previously in the section.</p>
			<p>The following code shows the implementation of the function that calls the Google API to get the books:</p>
			<p class="source-code">    public String getBookInfo(String query) {</p>
			<p class="source-code">        String responseJson = "{}";</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            String url = "https://www.googleapis.com/                books/v1/volumes?q=" + query                     + "&amp;key=&lt;your_google_api_key&gt;";</p>
			<p class="source-code">            HttpClient client = HttpClient.newHttpClient();</p>
			<p class="source-code">            HttpRequest request = HttpRequest.newBuilder()                .uri(URI.create(url)).build();</p>
			<p class="source-code">            HttpResponse&lt;String&gt; response;</p>
			<p class="source-code">            response = client.send(request,                BodyHandlers.ofString());</p>
			<p class="source-code">            responseJson = response.body();</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            responseJson =                 "{'error', '" + e.getMessage() + "'}";</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return responseJson;    </p>
			<p class="source-code">    }</p>
			<p>Let's now <a id="_idIndexMarker885"/>build and deploy this <a id="_idIndexMarker886"/>serverless container to the <a id="_idIndexMarker887"/>local Docker. Functions are grouped into applications. An application can have multiple functions. This helps in grouping and managing them. So we need to create a book info service app using the <strong class="source-inline">fn create app</strong> command. The following shows the output after executing the command:</p>
			<p class="source-code">fn create app book-info-service-app</p>
			<p class="source-code">Successfully created app:  book-info-service-app</p>
			<p>Once the app has been created, we can deploy it using the <strong class="source-inline">fn deploy</strong> command. This command has to be executed at the root folder of the function app that we created. The following shows the output after executing the command:</p>
			<p class="source-code">fn deploy --app book-info-service-app --local</p>
			<p class="source-code">Deploying book-info-service-function to app: book-info-service-app</p>
			<p class="source-code">Bumped to version 0.0.2</p>
			<p class="source-code">Building image book-info-service-function:0.0.2 .............................................................................................................</p>
			<p class="source-code">Updating function book-info-service-function using image book-info-service-function:0.0.2...</p>
			<p class="source-code">Successfully created function: book-info-service-function with book-info-service-function:0.0.2</p>
			<p>The <strong class="source-inline">fn deploy</strong> command will build the code using Maven, package it as a Docker image, and deploy <a id="_idIndexMarker888"/>it to the local Docker runtime. fn can also be used to deploy to the cloud or k8s cluster directly.</p>
			<p>Let's now <a id="_idIndexMarker889"/>use the <strong class="source-inline">docker images</strong> command to check whether our image has been built:</p>
			<p class="source-code"> docker images</p>
			<p>We can <a id="_idIndexMarker890"/>also use <strong class="source-inline">fn inspect</strong> to get all the details about the function. This helps in discovering the services. The following shows the output of executing the command: </p>
			<p class="source-code"> fn inspect function book-info-service-app book-info-service-function</p>
			<p class="source-code">{</p>
			<p class="source-code">    "annotations": {</p>
			<p class="source-code">        "fnproject.io/fn/invokeEndpoint":</p>
			<p class="source-code">        <a id="_idTextAnchor201"/>"http://localhost:8080/invoke/        01F29E8SXKNG8G00GZJ0000002"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "app_id": "01F29E183WNG8G00GZJ0000001",</p>
			<p class="source-code">    "created_at": "2021-04-02T14:02:25.587Z",</p>
			<p class="source-code">    "id": "01F29E8SXKNG8G00GZJ0000002",</p>
			<p class="source-code">    "idle_timeout": 30,</p>
			<p class="source-code">    "image": "book-info-service-function:0.0.2",</p>
			<p class="source-code">    "memory": 128,</p>
			<p class="source-code">    "name": "book-info-service-function",</p>
			<p class="source-code">    "timeout": 30,</p>
			<p class="source-code">    "updated_at": "2021-04-02T14:02:25.587Z"</p>
			<p class="source-code">}</p>
			<p>Now let's <a id="_idIndexMarker891"/>invoke the service. Since <a id="_idIndexMarker892"/>our function expects <a id="_idIndexMarker893"/>an input argument in the number, we can pass it using an echo command and pipe the output to <strong class="source-inline">fn invoke</strong> to invoke our function:</p>
			<p class="source-code">echo -n 'java' | fn invoke book-info-service-app book-info-service-function</p>
			<p class="source-code">{</p>
			<p class="source-code">  "kind": "books#volumes",</p>
			<p class="source-code">  "totalItems": 1941,</p>
			<p class="source-code">  "items": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">        "kind": "books#volume",</p>
			<p class="source-code">        "id": "Q3_QDwAAQBAJ",</p>
			<p class="source-code">        "etag": "0Hl3HzInpzY",</p>
			<p class="source-code">        "selfLink": "https://www.googleapis.com/            books/v1/volumes/Q3_QDwAAQBAJ",</p>
			<p class="source-code">                "volumeInfo": {</p>
			<p class="source-code">        "title": "Java Performance",</p>
			<p class="source-code">…</p>
			<p>We can see the function executing and the output of the Google API (the preceding output is partial, to save space). Now let's run the same logic on GraalVM. </p>
			<p>The base <a id="_idIndexMarker894"/>image for GraalVM is different. We use <strong class="source-inline">fnproject/fn-java-native-init</strong> as the base, and <a id="_idIndexMarker895"/>initialize our fn <a id="_idIndexMarker896"/>project with that. The following is the output of generating a Graal native image-based fn project:</p>
			<p class="source-code">fn init --init-image fnproject/fn-java-native-init book-info-service-function-graal</p>
			<p class="source-code">Creating function at: ./book-info-service-function-graal</p>
			<p class="source-code">Running init-image: fnproject/fn-java-native-init</p>
			<p class="source-code">Executing docker command: run --rm -e FN_FUNCTION_NAME=book-info-service-function-graal fnproject/fn-java-native-init</p>
			<p class="source-code">func.yaml created.</p>
			<p>This generates a Dockerfile. This is followed by the Dockerfile code, which you can find under the project directory (<strong class="source-inline">book-info-service-function-graal</strong>). This <strong class="source-inline">fn</strong> configuration works differently. It also generates a Dockerfile, with all the necessary Docker build commands. This is a multi-stage Docker build file. Let's inspect this Dockerfile:</p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/Figure_10.15_B16878.jpg" alt="Figure 10.15 – Dockerfile generated by fn&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15 – Dockerfile generated by fn</p>
			<p>Let's <a id="_idIndexMarker897"/>understand this Dockerfile:</p>
			<ul>
				<li><strong class="bold">Line 17</strong>: The <a id="_idIndexMarker898"/>image will be built using <strong class="source-inline">fnproject/fn-java-fdk-build</strong>.</li>
				<li><strong class="bold">Line 18</strong>: This <a id="_idIndexMarker899"/>sets the working directory to <strong class="source-inline">/function</strong>.</li>
				<li><strong class="bold">Lines 19–23</strong>: Then, the Maven environment is configured.</li>
				<li><strong class="bold">Lines 25–40</strong>: Using <strong class="source-inline">fnproject/fn-java-native</strong> as the base image, the GraalVM is configured and the fn runtime is compiled. This is a very important step as this is what makes our serverless runtime faster and with a smaller footprint.</li>
				<li><strong class="bold">Lines 43–47</strong>: The native images are copied using the <strong class="source-inline">busybox:glibc</strong> (which is the minimal version of Linux+glibc) base image. </li>
				<li><strong class="bold">Line 48</strong>: This is the function entry point. <strong class="source-inline">func.yml</strong>, in this way of building the serverless image, has no information. fn will use the Dockerfile to perform the build (along with Maven) and deploy the image to the repository. </li>
			</ul>
			<p>We need to change <strong class="source-inline">line</strong> <strong class="source-inline">48</strong> to point to our class. Let's replace that with the following:</p>
			<p class="source-code">CMD ["com.abvijay.chapter9.fn.BookInfoService::BookInfoService"]</p>
			<p>Another important configuration file that we need to change is <strong class="source-inline">reflection.json</strong>  under <strong class="source-inline">src/main/conf</strong>. This JSON file has the manifest information about the class name and the method. It is used by the native image builder to resolve the reflection we do by calling our function dynamically. Refer to the <em class="italic">Building native images</em> section in <a href="B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Graal Ahead-of-Time Compiler and Native Image</em>.</p>
			<p>Now, let's create an fn app and deploy this app using the <strong class="source-inline">fn create app</strong> command. The following is the output after executing the command:</p>
			<p class="source-code">fn create app book-info-service-app-graal</p>
			<p class="source-code">Successfully created app:  book-info-service-app-graal</p>
			<p>We can <a id="_idIndexMarker900"/>build the native image and deploy it using the <strong class="source-inline">fn deploy –app book-info-service-app-graal</strong> command and we can execute the method by calling <strong class="source-inline">echo -n 'java' | fn invoke book-info-service-app-graal book-info-service-function</strong>. Checking the Docker <a id="_idIndexMarker901"/>images, we will see <a id="_idIndexMarker902"/>that the size of the Java image is 238 MB, and that of the GraalVM image is just 41 MB. That is a 10-times-smaller footprint than traditional Java applications. We can time the function calls, and we can see that the native images are much faster (up to 30%). </p>
			<p class="source-code">docker images</p>
			<p>Serverless is the best solution, for quicker and stateless services, as it does not take any resources and we don't have to keep it running all the time.</p>
			<p>In this section, we have looked at various framework implementations and ways to optimize the image.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor202"/>Summary</h1>
			<p>Congratulations on reaching this point! In this chapter, we looked at how microservices architectures are built. To understand the architectural thought process, we picked a simple case study and explored how it can be deployed on Kubernetes as a collection of microservices. We then explored various microservices frameworks, and built a service on each of these frameworks, to appreciate the benefits that GraalVM brings to cloud-native architectures. </p>
			<p>After reading this chapter, you should have acquired a good understanding of how to go about building microservices-based, cloud-native applications using GraalVM as the runtime. This chapter gives a good head start for Java developers to quickly start building applications on one of the microservices frameworks (Quarkus, Spring, Micronaut). The source code that is provided along with this chapter (in Git) will also provide a good reference implementation of microservices on GraalVM.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor203"/>Questions</h1>
			<ol>
				<li>What is a microservice?</li>
				<li>What are the advantages of a microservices architecture?</li>
				<li>Why is GraalVM an ideal application runtime for microservices?</li>
			</ol>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor204"/>Further reading</h1>
			<ul>
				<li>Microservices architecture (<a href="https://microservices.io/">https://microservices.io/</a>)</li>
				<li>Micronaut (<a href="http://microprofile.io/">http://microprofile.io/</a>)</li>
				<li>Quarkus (<a href="https://quarkus.io/">https://quarkus.io/</a>)</li>
				<li>Spring Boot (<a href="https://spring.io/">https://spring.io/</a>)</li>
				<li>Spring Native (<a href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/">https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/</a>)</li>
			</ul>
		</div>
	</body></html>