- en: Chapter 9. Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the process of verifying that the user who is accessing an
    application is indeed who he/she claims to be and also, that he/she is allowed
    to access and use our application. In this chapter, we'll see how we can secure
    our web services with authentication mechanisms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic HTTP authenticator
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our web service now has the functionality that allows anyone to use an HTTP
    client and create and retrieve contacts. We need to somehow secure our web service
    and authenticate the users that call it. The most common way of authentication
    is basic HTTP authentication, which requires a basic set of credentials: a username
    and password.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we proceed with securing our web service, we need to add the `dropwizard-auth`
    dependency to our project, adding the following to the dependencies section of
    our `pom.xml` file:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see what it takes to build the authentication mechanism and secure our
    methods; perform the following steps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `com.dwbook.phonebook` package named `PhonebookAuthenticator`;
    here, we are going to build our service's security mechanism. The class needs
    to implement the `Authenticator<C, P>` interface and its `#authenticate()` method.
    The first parameter of the authenticator is the `Authentication` method, whereas
    the second one is the return type of the `#authenticate()` method.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Enable the authenticator you've just built by adding it to the Dropwizard environment
    along with `JerseyEnvironment#register()`, passing to it a `BasicAuthProvider`
    instance. The constructor of `BasicAuthProvider` takes an instance of the authenticator
    to be used as the input and the authentication realm. You will also need to import
    `io.dropwizard.auth.basic.BasicAuthProvider`.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may now secure web service endpoints, modifying the declarations of the
    `ContactResource` class' methods to expect a `Boolean` variable as the parameter,
    annotated with `@Auth` (import `io.dropwizard.auth.Auth`). The inclusion of this
    annotated parameter will trigger the authentication process.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Build and start the application and then try to access any of the endpoints
    of the `ContactResource` class, such as `http://localhost:8080/contact/1`, trying
    to display the contact with an ID equal to 1\. You will see a message stating
    that the server requires a username and a password.![How to do it…](img/9530OS_09_01.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dropwizard-auth` module includes everything we need in order to secure
    our services. We just need to implement an Authenticator and register it with
    the Dropwizard environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when we use the `@Auth` annotation for a method''s input parameter, we
    indicate that the user who is accessing our service must be authenticated. Each
    time an HTTP request is performed on a method that contains a variable annotated
    with `@Auth`, the authentication provider intercepts it requesting a username
    and password. These credentials are then passed on to our authenticator who is
    responsible for determining whether they''re valid or not. Whatever the authentication
    result is, that is, the return value of the `#authenticate()` method, it is injected
    in the variable that is annotated with `@Auth`. In case the authentication is
    unsuccessful or no credentials are provided, the request is blocked and the response
    is an **HTTP/1.1 401 Unauthorized** error. You can see the response received after
    performing an HTTP request with cURL without providing credentials in the following
    screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们为一个方法的输入参数使用`@Auth`注解时，我们表示访问我们服务的用户必须经过认证。每次对包含`@Auth`注解的变量的方法执行HTTP请求时，认证提供者都会拦截它，请求用户名和密码。然后，这些凭证被传递给我们的认证器，认证器负责确定它们是否有效。无论认证结果如何，即`#authenticate()`方法的返回值，它都会注入到被`@Auth`注解的变量中。如果认证失败或没有提供凭证，请求将被阻止，响应是一个**HTTP/1.1
    401 Unauthorized**错误。您可以在以下屏幕截图中看到执行HTTP请求后收到的响应，请求使用cURL执行，但没有提供凭证：
- en: '![How it works…](img/9530OS_09_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/9530OS_09_02.jpg)'
- en: Our authenticator class needs to be a class that implements the `Authenticator<C,
    P>` interface, where `C` is the set of credentials that we may use to authenticate
    the user and `P` is the type of the authentication's outcome. In our case, we
    used `BasicCredentials` as the credentials store, which is what `BasicAuthProvider`
    provides. In the `#authenticate()` method, we perform all the tasks required to
    authenticate the user. We implemented this to check that the user's name is `john_doe`
    as identified by the password, `secret`. This was an example; the next recipe
    illustrates how to authenticate users when their details (username and password)
    are stored in a database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的认证器类需要是一个实现了`Authenticator<C, P>`接口的类，其中`C`是我们可能用来认证用户的凭证集合，而`P`是认证结果类型。在我们的例子中，我们使用了`BasicCredentials`作为凭证存储，这是`BasicAuthProvider`提供的。在`#authenticate()`方法中，我们执行所有必要的任务以认证用户。我们实现了检查用户名是否为`john_doe`，这是通过密码`secret`识别的。这是一个例子；下一个菜谱将说明如何认证用户，当他们的详细信息（用户名和密码）存储在数据库中时。
- en: There's more…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As you may have noticed, our authenticator's `#authenticate()` method's return
    type is `Optional`. This is a Guava type that allows us to prevent null-pointer
    exceptions. There are cases where the `#authenticate()` method should return nothing,
    so instead of simply returning null (which could cause problems if not handled
    correctly), we return `Optional.absent()`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们的认证器的`#authenticate()`方法的返回类型是`Optional`。这是一个Guava类型，它允许我们防止空指针异常。在某些情况下，`#authenticate()`方法应该返回空值，因此我们返回`Optional.absent()`，而不是简单地返回null（如果处理不当可能会引起问题）。
- en: Such cases are when we need to provide an instance of the authenticated principal
    (that would probably contain username, name, e-mail, and so on) to the methods
    we secure, instead of just a `boolean` parameter, as we did in this example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的情况是我们需要向我们要保护的方法提供一个经过认证的主体的实例（可能包含用户名、姓名、电子邮件等），而不是像在这个例子中那样只是一个`boolean`参数。
- en: Setting client's credentials
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置客户端的凭证
- en: We have secured our web service, in particular the endpoints of the `ContactResource`
    class. Our client needs to be updated as well in order to be able to access these
    protected resources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经保护了我们的网络服务，特别是`ContactResource`类的端点。我们的客户端也需要更新，以便能够访问这些受保护的资源。
- en: To do so, we will need to modify the `App#run()` method. Use the `#addFilter()`
    method of the `client` object, right after its instantiation, adding `HTTPBasicAuthFilter`
    (import `com.sun.jersey.api.client.filter.HTTPBasicAuthFilter`) and providing
    the correct username and password.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要修改`App#run()`方法。在`client`对象实例化后，使用`#addFilter()`方法，添加`HTTPBasicAuthFilter`（导入`com.sun.jersey.api.client.filter.HTTPBasicAuthFilter`），并提供正确的用户名和密码。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `#addFilter()` method is used to add additional processing instructions
    to the `client` object. That is, every request that is performed by our Jersey
    client has to be processed by the filters we've added before it is eventually
    performed. In this case, we use the `#addFilter()` method in order to add the
    appropriate `BasicAuth` headers to every outgoing HTTP request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`#addFilter()` 方法用于向 `client` 对象添加额外的处理指令。也就是说，我们Jersey客户端执行的每一个请求都必须在我们添加的过滤器处理之后才能最终执行。在这种情况下，我们使用
    `#addFilter()` 方法来为每个发出的HTTP请求添加适当的 `BasicAuth` 头部。'
- en: Optional authentication
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选认证
- en: 'There are many cases where authentication should be optional. Think of a service
    that returns personalized information for a user and a default message when no
    user is logged in. In order to declare optional authentication, we should have
    provided the `required=false` parameter on the `@Auth` annotation, as shown in
    the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下认证应该是可选的。想想一个为用户提供个性化信息的服务，当没有用户登录时返回默认消息。为了声明可选认证，我们应该在 `@Auth` 注解中提供
    `required=false` 参数，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Authentication schemes
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证方案
- en: We used basic HTTP authentication in our application; however, it is not the
    only available authentication scheme. For example, some web services use API key
    authentication. In such cases, the authenticator should be checking the headers
    of the HTTP request, verifying the validity of the transmitted API key. However,
    doing so would require the usage of a custom authentication provider as well.
    In any case, the use of an authentication method depends on your application's
    needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中使用了基本的HTTP认证；然而，这并不是唯一可用的认证方案。例如，一些Web服务使用API密钥认证。在这种情况下，认证器应该检查HTTP请求的头部，验证传输的API密钥的有效性。然而，这样做将需要使用自定义认证提供者。无论如何，使用哪种认证方法取决于您的应用程序需求。
- en: Authenticating users with credentials stored in a database
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库中存储的凭据验证用户
- en: In the previous recipe, we used a hard-coded set of username and password to
    verify the users' identity. In most real-world cases though, you will need to
    identify users and verify their identity using credentials that are stored in
    a database, or more specifically, in a table that holds user information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们使用一组硬编码的用户名和密码来验证用户的身份。然而，在大多数现实世界的案例中，您需要使用存储在数据库中，或者更具体地说，在包含用户信息的表中存储的凭据来识别用户并验证他们的身份。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's first create a table in the database that will hold user data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在数据库中创建一个表，用于存储用户数据。
- en: 'Start the MySQL client, and after logging in, execute the following query in
    the phonebook database:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 启动MySQL客户端，登录后，在电话簿数据库中执行以下查询：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let''s add a user to the database by running the following query:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过运行以下查询将用户添加到数据库中：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We are going to modify our authentication provider in order to check the current
    user''s credentials in the database. Let''s see how:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的认证提供者，以便在数据库中检查当前用户的凭据。让我们看看如何：
- en: Since we are going to be interacting with the database for validating the user,
    we will need a DAO. So, create the `UserDAO` interface in the `com.dwbook.phonebook.dao`
    package.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将与数据库交互以验证用户，我们需要一个DAO。因此，在 `com.dwbook.phonebook.dao` 包中创建 `UserDAO` 接口。
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Modify `PhonebookAuthenticator`, adding a `UserDAO` instance as a member variable,
    creating a constructor to initialize the DAO instance using `jdbi`, and finally
    altering the authenticate method by utilizing the `UserDAO` instance for verifying
    user data by querying the database.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `PhonebookAuthenticator`，添加一个 `UserDAO` 实例作为成员变量，创建一个构造函数使用 `jdbi` 初始化DAO实例，并最终通过利用
    `UserDAO` 实例通过查询数据库来验证用户数据来修改认证方法。
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `App#run()` method, modify the registration of our authenticator in order
    to pass the existing `jdbi` instance to its constructor.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App#run()` 方法中，修改我们的认证器的注册，以便将其现有的 `jdbi` 实例传递给其构造函数。
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may now rebuild, run, and test the application again. This time, when requested,
    you will need to provide the username and password set stored in the database
    instead of the hard-coded ones.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以重新构建、运行并测试应用程序。这次，当请求时，您需要提供存储在数据库中的用户名和密码设置，而不是硬编码的。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Upon every request that is performed on a protected resource, our application
    checks the user's credentials against the database. To do so, we created a simple
    DAO with a single query that actually counts the rows that match the provided
    username and password. Of course, this could be either 0 (when the username/password
    set is incorrect) or 1 (when there is a correct set of credentials provided).
    This is what we check for in the authenticator's `#authenticate()` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在对受保护资源执行每个请求时，我们的应用程序都会将用户的凭据与数据库进行比对。为此，我们创建了一个简单的DAO，它只有一个查询，实际上会计算与提供的用户名和密码匹配的行数。当然，这可能是0（当用户名/密码集不正确时）或1（当提供了正确的凭据集时）。这就是我们在认证器的`#authenticate()`方法中检查的内容。
- en: There's more…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this recipe, we stored the password in a database as plain text. This is
    normally not the appropriate way to do so; passwords should always be encrypted
    or hashed, and never stored in clear text, to minimize the impact of a possible
    intrusion or unauthorized access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将密码以纯文本形式存储在数据库中。这通常不是正确的做法；密码应该始终加密或散列，而不是以明文形式存储，以最大限度地减少可能入侵或未经授权访问的影响。
- en: Caching
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: To improve our application's performance, we could cache the database credentials.
    Dropwizard provides the `CachingAuthenticator` class that we could use for this
    matter. The concept is simple; we build a wrapper around our authenticator with
    the `CachingAuthenticator#wrap()` method and register it with the environment.
    We will also be defining a set of caching directives, for example, how many entries
    to cache and for how long, using Guava's `CacheBuilderSpec`. For this example,
    we need to import `io.dropwizard.auth.CachingAuthenticator` and `com.google.common.cache.CacheBuilderSpec`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高我们应用程序的性能，我们可以缓存数据库凭据。Dropwizard提供了`CachingAuthenticator`类，我们可以用它来处理这个问题。这个概念很简单；我们使用`CachingAuthenticator#wrap()`方法围绕我们的认证器构建一个包装器，并将其注册到环境中。我们还将定义一组缓存指令，例如，要缓存多少条记录以及缓存多长时间，使用Guava的`CacheBuilderSpec`。对于这个例子，我们需要导入`io.dropwizard.auth.CachingAuthenticator`和`com.google.common.cache.CacheBuilderSpec`。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The key statement in the preceding snippet is `CacheBuilderSpec.parse("maximumSize=10000,
    expireAfterAccess=10m"));`. With this statement, we configure the wrapper to cache
    `10000` principals (the `maximumSize` property), that is, sets of usernames/passwords,
    and keep each of them cached for 10 minutes. The `CacheBuilderSpec#parse()` method
    is used to build a `CacheBuilderSpec` instance by parsing a string. This is for
    our convenience, allowing us to externalize the cache configuration, as instead
    of parsing a static string, we could parse a property defined in our configuration
    settings file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中的关键语句是`CacheBuilderSpec.parse("maximumSize=10000, expireAfterAccess=10m"));`。通过这个语句，我们配置包装器缓存`10000`个主体（`maximumSize`属性），即用户名/密码集合，并且每个都缓存10分钟。`CacheBuilderSpec#parse()`方法用于通过解析字符串来构建一个`CacheBuilderSpec`实例。这是为了我们的方便，允许我们将缓存配置外部化，而不是解析一个静态字符串，我们可以解析配置设置文件中定义的属性。
