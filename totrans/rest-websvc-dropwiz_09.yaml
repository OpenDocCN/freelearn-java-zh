- en: Chapter 9. Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the process of verifying that the user who is accessing an
    application is indeed who he/she claims to be and also, that he/she is allowed
    to access and use our application. In this chapter, we'll see how we can secure
    our web services with authentication mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic HTTP authenticator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our web service now has the functionality that allows anyone to use an HTTP
    client and create and retrieve contacts. We need to somehow secure our web service
    and authenticate the users that call it. The most common way of authentication
    is basic HTTP authentication, which requires a basic set of credentials: a username
    and password.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we proceed with securing our web service, we need to add the `dropwizard-auth`
    dependency to our project, adding the following to the dependencies section of
    our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see what it takes to build the authentication mechanism and secure our
    methods; perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `com.dwbook.phonebook` package named `PhonebookAuthenticator`;
    here, we are going to build our service's security mechanism. The class needs
    to implement the `Authenticator<C, P>` interface and its `#authenticate()` method.
    The first parameter of the authenticator is the `Authentication` method, whereas
    the second one is the return type of the `#authenticate()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enable the authenticator you've just built by adding it to the Dropwizard environment
    along with `JerseyEnvironment#register()`, passing to it a `BasicAuthProvider`
    instance. The constructor of `BasicAuthProvider` takes an instance of the authenticator
    to be used as the input and the authentication realm. You will also need to import
    `io.dropwizard.auth.basic.BasicAuthProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may now secure web service endpoints, modifying the declarations of the
    `ContactResource` class' methods to expect a `Boolean` variable as the parameter,
    annotated with `@Auth` (import `io.dropwizard.auth.Auth`). The inclusion of this
    annotated parameter will trigger the authentication process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and start the application and then try to access any of the endpoints
    of the `ContactResource` class, such as `http://localhost:8080/contact/1`, trying
    to display the contact with an ID equal to 1\. You will see a message stating
    that the server requires a username and a password.![How to do it…](img/9530OS_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dropwizard-auth` module includes everything we need in order to secure
    our services. We just need to implement an Authenticator and register it with
    the Dropwizard environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when we use the `@Auth` annotation for a method''s input parameter, we
    indicate that the user who is accessing our service must be authenticated. Each
    time an HTTP request is performed on a method that contains a variable annotated
    with `@Auth`, the authentication provider intercepts it requesting a username
    and password. These credentials are then passed on to our authenticator who is
    responsible for determining whether they''re valid or not. Whatever the authentication
    result is, that is, the return value of the `#authenticate()` method, it is injected
    in the variable that is annotated with `@Auth`. In case the authentication is
    unsuccessful or no credentials are provided, the request is blocked and the response
    is an **HTTP/1.1 401 Unauthorized** error. You can see the response received after
    performing an HTTP request with cURL without providing credentials in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/9530OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our authenticator class needs to be a class that implements the `Authenticator<C,
    P>` interface, where `C` is the set of credentials that we may use to authenticate
    the user and `P` is the type of the authentication's outcome. In our case, we
    used `BasicCredentials` as the credentials store, which is what `BasicAuthProvider`
    provides. In the `#authenticate()` method, we perform all the tasks required to
    authenticate the user. We implemented this to check that the user's name is `john_doe`
    as identified by the password, `secret`. This was an example; the next recipe
    illustrates how to authenticate users when their details (username and password)
    are stored in a database.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, our authenticator's `#authenticate()` method's return
    type is `Optional`. This is a Guava type that allows us to prevent null-pointer
    exceptions. There are cases where the `#authenticate()` method should return nothing,
    so instead of simply returning null (which could cause problems if not handled
    correctly), we return `Optional.absent()`.
  prefs: []
  type: TYPE_NORMAL
- en: Such cases are when we need to provide an instance of the authenticated principal
    (that would probably contain username, name, e-mail, and so on) to the methods
    we secure, instead of just a `boolean` parameter, as we did in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Setting client's credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have secured our web service, in particular the endpoints of the `ContactResource`
    class. Our client needs to be updated as well in order to be able to access these
    protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we will need to modify the `App#run()` method. Use the `#addFilter()`
    method of the `client` object, right after its instantiation, adding `HTTPBasicAuthFilter`
    (import `com.sun.jersey.api.client.filter.HTTPBasicAuthFilter`) and providing
    the correct username and password.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `#addFilter()` method is used to add additional processing instructions
    to the `client` object. That is, every request that is performed by our Jersey
    client has to be processed by the filters we've added before it is eventually
    performed. In this case, we use the `#addFilter()` method in order to add the
    appropriate `BasicAuth` headers to every outgoing HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Optional authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many cases where authentication should be optional. Think of a service
    that returns personalized information for a user and a default message when no
    user is logged in. In order to declare optional authentication, we should have
    provided the `required=false` parameter on the `@Auth` annotation, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Authentication schemes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used basic HTTP authentication in our application; however, it is not the
    only available authentication scheme. For example, some web services use API key
    authentication. In such cases, the authenticator should be checking the headers
    of the HTTP request, verifying the validity of the transmitted API key. However,
    doing so would require the usage of a custom authentication provider as well.
    In any case, the use of an authentication method depends on your application's
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users with credentials stored in a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used a hard-coded set of username and password to
    verify the users' identity. In most real-world cases though, you will need to
    identify users and verify their identity using credentials that are stored in
    a database, or more specifically, in a table that holds user information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first create a table in the database that will hold user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the MySQL client, and after logging in, execute the following query in
    the phonebook database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a user to the database by running the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to modify our authentication provider in order to check the current
    user''s credentials in the database. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are going to be interacting with the database for validating the user,
    we will need a DAO. So, create the `UserDAO` interface in the `com.dwbook.phonebook.dao`
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify `PhonebookAuthenticator`, adding a `UserDAO` instance as a member variable,
    creating a constructor to initialize the DAO instance using `jdbi`, and finally
    altering the authenticate method by utilizing the `UserDAO` instance for verifying
    user data by querying the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `App#run()` method, modify the registration of our authenticator in order
    to pass the existing `jdbi` instance to its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may now rebuild, run, and test the application again. This time, when requested,
    you will need to provide the username and password set stored in the database
    instead of the hard-coded ones.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upon every request that is performed on a protected resource, our application
    checks the user's credentials against the database. To do so, we created a simple
    DAO with a single query that actually counts the rows that match the provided
    username and password. Of course, this could be either 0 (when the username/password
    set is incorrect) or 1 (when there is a correct set of credentials provided).
    This is what we check for in the authenticator's `#authenticate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we stored the password in a database as plain text. This is
    normally not the appropriate way to do so; passwords should always be encrypted
    or hashed, and never stored in clear text, to minimize the impact of a possible
    intrusion or unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve our application's performance, we could cache the database credentials.
    Dropwizard provides the `CachingAuthenticator` class that we could use for this
    matter. The concept is simple; we build a wrapper around our authenticator with
    the `CachingAuthenticator#wrap()` method and register it with the environment.
    We will also be defining a set of caching directives, for example, how many entries
    to cache and for how long, using Guava's `CacheBuilderSpec`. For this example,
    we need to import `io.dropwizard.auth.CachingAuthenticator` and `com.google.common.cache.CacheBuilderSpec`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The key statement in the preceding snippet is `CacheBuilderSpec.parse("maximumSize=10000,
    expireAfterAccess=10m"));`. With this statement, we configure the wrapper to cache
    `10000` principals (the `maximumSize` property), that is, sets of usernames/passwords,
    and keep each of them cached for 10 minutes. The `CacheBuilderSpec#parse()` method
    is used to build a `CacheBuilderSpec` instance by parsing a string. This is for
    our convenience, allowing us to externalize the cache configuration, as instead
    of parsing a static string, we could parse a property defined in our configuration
    settings file.
  prefs: []
  type: TYPE_NORMAL
