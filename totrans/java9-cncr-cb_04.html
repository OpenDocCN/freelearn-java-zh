<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Thread Executors</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Creating a thread executor and controlling its rejected tasks</li>
<li class="calibre18">Executing tasks in an executor that returns a result</li>
<li class="calibre18">Running multiple tasks and processing the first result</li>
<li class="calibre18">Running multiple tasks and processing all the results</li>
<li class="calibre18">Running a task in an executor after a delay</li>
<li class="calibre18">Running a task in an executor periodically</li>
<li class="calibre18">Canceling a task in an executor</li>
<li class="calibre18">Controlling a task finishing in an executor</li>
<li class="calibre18">Separating the launching of tasks and the processing of their results in an executor</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">Usually, when you develop a simple, concurrent programming application in Java, first you create some <kbd class="calibre15">Runnable</kbd> objects and then the corresponding <kbd class="calibre15">Thread</kbd> objects to execute them. If you have to develop a program that runs a lot of concurrent tasks, this approach will present the following disadvantages:</p>
<ul class="calibre17">
<li class="calibre18">You will have to implement all of the code-related information to manage <kbd class="calibre15">Thread</kbd> objects (creating, ending, and obtaining results).</li>
<li class="calibre18">You will have to create a <kbd class="calibre15">Thread</kbd> object per task. Executing a huge number of tasks can affect the throughput of the application.</li>
<li class="calibre18">You will have to control and manage the resources of the computer efficiently. If you create too many threads, you could saturate the system.</li>
</ul>
<p class="calibre4">Since Java 5, the Java concurrency API provides a mechanism that aims to resolve these problems. This mechanism is called the <strong class="calibre1">Executor framework</strong> and is around the <kbd class="calibre15">Executor</kbd> interface, its subinterface <kbd class="calibre15">ExecutorService</kbd>, and the <kbd class="calibre15">ThreadPoolExecutor</kbd> class that implements both these interfaces.</p>
<p class="calibre4">This mechanism separates task creation and execution. With an executor, you only have to implement either <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> objects and send them to the executor. It is responsible for their execution, running them with the necessary threads. But it goes beyond this; it improves performance using a pool of threads. When you send a task to the executor, it tries to use a pooled thread for the execution of the task. It does so to avoid the continuous spawning of threads. Another important advantage of the <kbd class="calibre15">Executor</kbd> framework is the <kbd class="calibre15">Callable</kbd> interface. It's similar to the <kbd class="calibre15">Runnable</kbd> interface but offers two improvements, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">The main method of this interface, named <kbd class="calibre15">call()</kbd>, may return a result.</li>
<li class="calibre18">When you send a <kbd class="calibre15">Callable</kbd> object to an executor, you get an object that implements the <kbd class="calibre15">Future</kbd> interface. You can use this object to control the status and the result of the <kbd class="calibre15">Callable</kbd> object.</li>
</ul>
<p class="calibre4">This chapter presents nine recipes that show you how to work with the <kbd class="calibre15">Executor</kbd> framework using the classes mentioned earlier and other variants provided by the Java Concurrency API.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating a thread executor and controlling its rejected tasks</h1>
            

            <article>
                
<p class="calibre4">The first step toward working with the <kbd class="calibre15">Executor</kbd> framework is to create an object of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class. You can use the four constructors provided by this class or use a factory class named <kbd class="calibre15">Executors</kbd>, which creates <kbd class="calibre15">ThreadPoolExecutor</kbd>. Once you have an executor, you can send <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> objects to be executed.</p>
<p class="calibre4">When you want to finish the execution of an executor, use the <kbd class="calibre15">shutdown()</kbd> method. The executor waits for the completion of tasks that are either running or waiting for their execution. Then, it finishes the execution.</p>
<p class="calibre4">If you send a task to an executor between the <kbd class="calibre15">shutdown()</kbd> method and the end of its execution, the task will be rejected. This is because the executor no longer accepts new tasks. The <kbd class="calibre15">ThreadPoolExecutor</kbd> class provides a mechanism, which is called when a task is rejected.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">Executors</kbd> class to create a new <kbd class="calibre15">ThreadPoolExecutor</kbd> object, how to send tasks to the <kbd class="calibre15">Executor</kbd>, and how to control the rejected tasks of the <kbd class="calibre15">Executor</kbd> class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">You should read the <em class="calibre14">Creating, running, and setting the characteristics of a thread</em> recipe in <a href="part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre14">Thread Management</em>, to learn the basic mechanism of thread creation in Java. You can compare both the mechanisms and select one, depending on the problem.</p>
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, implement the tasks that will be executed by the server. Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a <kbd class="calibre15">Date</kbd> attribute named <kbd class="calibre15">initDate</kbd> to store the creation date of the task and a <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd> to store the name of the task:</li>
</ol>
<pre class="calibre23">
        private final Date initDate; <br class="title-page-name"/>        private final String name;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that initializes both the attributes:</li>
</ol>
<pre class="calibre23">
        public Task(String name){ <br class="title-page-name"/>          initDate=new Date(); <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">First, write the <kbd class="calibre15">initDate</kbd> attribute and the actual date, which is the starting date of the task:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Task %s: Created on: %s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),<br class="title-page-name"/>                          name,initDate); <br class="title-page-name"/>        System.out.printf("%s: Task %s: Started on: %s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),<br class="title-page-name"/>                          name,new Date());
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then, put the task to sleep for a random period of time:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          Long duration=(long)(Math.random()*10); <br class="title-page-name"/>          System.out.printf("%s: Task %s: Doing a task during %d<br class="title-page-name"/>                             seconds\n", Thread.currentThread().getName(),<br class="title-page-name"/>                            name,duration); <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Finally, write the completion date of the task in the console:</li>
</ol>
<pre class="calibre23">
         System.out.printf("%s: Task %s: Finished on: %s\n",<br class="title-page-name"/>                           Thread.currentThread().getName(),<br class="title-page-name"/>                           name,new Date());
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">RejectedTaskController</kbd> that implements the <kbd class="calibre15">RejectedExecutionHandler</kbd> interface. Implement the <kbd class="calibre15">rejectedExecution()</kbd> method of this interface. Then write the name of the task that has been rejected and the name and status of the executor:</li>
</ol>
<pre class="calibre23">
        public class RejectedTaskController implements<br class="title-page-name"/>                                              RejectedExecutionHandler { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void rejectedExecution(Runnable r,<br class="title-page-name"/>                                        ThreadPoolExecutor executor) { <br class="title-page-name"/>            System.out.printf("RejectedTaskController: The task %s has been<br class="title-page-name"/>                              rejected\n",r.toString()); <br class="title-page-name"/>            System.out.printf("RejectedTaskController: %s\n",<br class="title-page-name"/>                              executor.toString()); <br class="title-page-name"/>            System.out.printf("RejectedTaskController: Terminating: %s\n",<br class="title-page-name"/>                              executor.isTerminating()); <br class="title-page-name"/>            System.out.printf("RejectedTaksController: Terminated: %s\n",<br class="title-page-name"/>                              executor.isTerminated()); <br class="title-page-name"/>          }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Now implement the <kbd class="calibre15">Server</kbd> class that will execute every task it receives using an executor. Create a class named <kbd class="calibre15">Server</kbd>:</li>
</ol>
<pre class="calibre23">
        public class Server {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a <kbd class="calibre15">ThreadPoolExecutor</kbd> attribute named <kbd class="calibre15">executor</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ThreadPoolExecutor executor;
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the constructor of the class that initializes the <kbd class="calibre15">ThreadPoolExecutor</kbd> object using the <kbd class="calibre15">Executors</kbd> class, and establish a handler for rejected tasks:</li>
</ol>
<pre class="calibre23">
        public Server(){ <br class="title-page-name"/>          executor =( ThreadPoolExecutor ) Executors.newFixedThreadPool(<br class="title-page-name"/>                        Runtime.getRuntime().availableProcessors() ); <br class="title-page-name"/>          RejectedTaskController controller=new<br class="title-page-name"/>                                         RejectedTaskController(); <br class="title-page-name"/>          executor.setRejectedExecutionHandler(controller); <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the <kbd class="calibre15">executeTask()</kbd> method. It receives a <kbd class="calibre15">Task</kbd> object as a parameter and sends it to the executor. First, write a message to the console indicating that a new task has arrived:</li>
</ol>
<pre class="calibre23">
        public void executeTask(Task task){ <br class="title-page-name"/>          System.out.printf("Server: A new task has arrived\n");
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Then, call the <kbd class="calibre15">execute()</kbd> method of the executor and send it to the task:</li>
</ol>
<pre class="calibre23">
        executor.execute(task);
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Finally, write some executor data to the console to see its status:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Server: Pool Size: %d\n",<br class="title-page-name"/>                          executor.getPoolSize()); <br class="title-page-name"/>        System.out.printf("Server: Active Count: %d\n",<br class="title-page-name"/>                          executor.getActiveCount()); <br class="title-page-name"/>        System.out.printf("Server: Task Count: %d\n",<br class="title-page-name"/>                          executor.getTaskCount()); <br class="title-page-name"/>        System.out.printf("Server: Completed Tasks: %d\n",<br class="title-page-name"/>                          executor.getCompletedTaskCount());
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Next, implement the <kbd class="calibre15">endServer()</kbd> method. In this method, call the <kbd class="calibre15">shutdown()</kbd> method of the executor to finish its execution:</li>
</ol>
<pre class="calibre23">
        public void endServer() { <br class="title-page-name"/>          executor.shutdown(); <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it. First, create 100 tasks and send them to <kbd class="calibre15">Executor</kbd>:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            Server server=new Server(); <br class="title-page-name"/>               <br class="title-page-name"/>            System.out.printf("Main: Starting.\n"); <br class="title-page-name"/>              for (int i=0; i&lt;100; i++){ <br class="title-page-name"/>                Task task=new Task("Task "+i); <br class="title-page-name"/>                server.executeTask(task); <br class="title-page-name"/>              }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Then call the <kbd class="calibre15">endServer()</kbd> method of <kbd class="calibre15">Server</kbd> to shut down the executor:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Shuting down the Executor.\n"); <br class="title-page-name"/>        server.endServer();
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Finally, send a new task. This task will be rejected, so we will see how this mechanism works:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Sending another Task.\n"); <br class="title-page-name"/>        Task task=new Task("Rejected task"); <br class="title-page-name"/>        server.executeTask(task); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("Main: End.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key of this example is the <kbd class="calibre15">Server</kbd> class. This class creates and uses <kbd class="calibre15">ThreadPoolExecutor</kbd> to execute tasks.</p>
<p class="calibre4">The first important point is the creation of <kbd class="calibre15">ThreadPoolExecutor</kbd> in the constructor of the <kbd class="calibre15">Server</kbd> class. The <kbd class="calibre15">ThreadPoolExecutor</kbd> class has four different constructors, but due to their complexity, the Java concurrency API provides the <kbd class="calibre15">Executors</kbd> class to construct executors and other related objects. Although you can create <kbd class="calibre15">ThreadPoolExecutor</kbd> directly using one of its constructors, it's recommended that you use the <kbd class="calibre15">Executors</kbd> class.</p>
<p class="calibre4">In this case, you created a cached thread pool using the <kbd class="calibre15">newFixedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class in order to create the executor. This method creates an executor with the maximum number of threads. If the number of tasks you send is more than the number of threads, the remaining tasks will be blocked until there is a free thread available to process them. This method receives the maximum number of threads you want to have in your executor as parameters. In our case, we used the <kbd class="calibre15">availableProcessors()</kbd> method of the <kbd class="calibre15">Runtime</kbd> class that returns the number of processors available to JVM. Normally, this number matches the number of cores of the computer.</p>
<p class="calibre4">Reutilization of threads has the advantage that it reduces the time taken for thread creation. The cached thread pool, however, has the disadvantage of having constant lying threads for new tasks. Therefore, if you send too many tasks to this executor, you could overload the system.</p>
<p class="calibre4">Once you have created the executor, you can send tasks of the <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> type for execution using the <kbd class="calibre15">execute()</kbd> method. In this case, you sent objects of the <kbd class="calibre15">Task</kbd> class that implements the <kbd class="calibre15">Runnable</kbd> interface.</p>
<p class="calibre4">You also printed some log messages with information about the executor. Specifically, you used the following methods:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getPoolSize()</kbd>: This method returned the actual number of threads in the pool of the executor.</li>
<li class="calibre18"><kbd class="calibre15">getActiveCount()</kbd>: This method returned the number of threads that were executing tasks in the executor.</li>
<li class="calibre18"><kbd class="calibre15">getTaskCount()</kbd>: This method returned the number of tasks that were scheduled for execution. The returned value is only an approximation because it changes dynamically.</li>
<li class="calibre18"><kbd class="calibre15">getCompletedTaskCount()</kbd>: This method returned the number of tasks completed by the executor.</li>
</ul>
<p class="calibre4">One critical aspect of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class, and of executors in general, is that you have to end them explicitly. If you don't do this, the executor will continue its execution and the program won't end. If the executor doesn't have tasks to execute, it continues waiting for new tasks and doesn't end its execution. A Java application won't end until all its non-daemon threads finish their execution. So, if you don't terminate the executor, your application will never end.</p>
<p class="calibre4">To indicate to the executor that you want to finish it, use the <kbd class="calibre15">shutdown()</kbd> method of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class. When the executor finishes the execution of all the pending tasks, it finishes its execution as well. After you call the <kbd class="calibre15">shutdown()</kbd> method, if you try to send another task to the executor, it will be rejected and the executor will throw a <kbd class="calibre15">RejectedExecutionException</kbd> exception, unless you have implemented a manager for rejected tasks, as in our case. To manage the rejected tasks of an executor, you need to create a class that implements the <kbd class="calibre15">RejectedExecutionHandler</kbd> interface. This interface has a method called <kbd class="calibre15">rejectedExecution()</kbd> with two parameters:</p>
<ul class="calibre17">
<li class="calibre18">A <kbd class="calibre15">Runnable</kbd> object that stores the task that has been rejected</li>
<li class="calibre18">An <kbd class="calibre15">Executor</kbd> object that stores the executor that rejected the task</li>
</ul>
<p class="calibre4">This method is called for every task that is rejected by the executor. You need to establish the handler of the rejected tasks using the <kbd class="calibre15">setRejectedExecutionHandler()</kbd> method of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class.</p>
<p class="calibre4">The following screenshot shows part of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone16" src="../images/00027.gif"/></div>
<p class="calibre4">See that when the last task arrives at the executor, both the number of threads in the pool and the number of threads that are being executed are represented by 4. This refers to the number of cores of the PC on which the example was executed, and it is the number returned by the <kbd class="calibre15">availableProcessors()</kbd> method. Once this is done, we shut down the executor and the next task is rejected. <kbd class="calibre15">RejectedTaskController</kbd> writes information about the task and the executor in the console.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Executors</kbd> class provides other methods to create <kbd class="calibre15">ThreadPoolExecutor</kbd>:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">newCachedThreadPool()</kbd>: This method returns an <kbd class="calibre15">ExecutorService</kbd> object, so it's been cast to <kbd class="calibre15">ThreadPoolExecutor</kbd> to have access to all its methods. The cached thread pool you created creates new threads, if needed, to execute new tasks. Plus, it reuses the existing ones if they have finished the execution of the tasks they were running.</li>
<li class="calibre18"><kbd class="calibre15">newSingleThreadExecutor()</kbd>: This is an extreme case of a fixed-size thread executor. It creates an executor with only one thread so it can only execute one task at a time.</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">ThreadPoolExecutor</kbd> class provides a lot of methods to obtain information about its status. We used the <kbd class="calibre15">getPoolSize()</kbd>, <kbd class="calibre15">getActiveCount()</kbd>, and <kbd class="calibre15">getCompletedTaskCount()</kbd> methods in the example to obtain information about the size of the pool, the number of threads, and the number of completed tasks of the executor. You can also use the <kbd class="calibre15">getLargestPoolSize()</kbd> method; it returns the maximum number of threads that have been in the pool at a time.</p>
<p class="calibre4">The <kbd class="calibre15">ThreadPoolExecutor</kbd> class also provides other methods related to the finalization of the executor. These methods are:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">shutdownNow()</kbd>: This shuts down the executor immediately. It doesn't execute pending tasks. It returns a list with all the pending tasks. Tasks that are running when you call this method continue with their execution, but the method doesn't wait for their finalization.</li>
<li class="calibre18"><kbd class="calibre15">isTerminated()</kbd>: This method returns true if you call either the <kbd class="calibre15">shutdown()</kbd> or <kbd class="calibre15">shutdownNow()</kbd> method; the executor finishes the process of shutting it down accordingly.</li>
<li class="calibre18"><kbd class="calibre15">isShutdown()</kbd>: This method returns <kbd class="calibre15">true</kbd> if you call the <kbd class="calibre15">shutdown()</kbd> method of the executor.</li>
<li class="calibre18"><kbd class="calibre15">awaitTermination(long timeout, TimeUnit unit)</kbd>: This method blocks the calling thread until the tasks of the executor end or a timeout occurs. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>
<div class="packt_infobox">If you want to wait for the completion of tasks, regardless of their duration, use a big timeout, for example, <kbd class="calibre25">DAYS</kbd>.</div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Monitoring an Executor framework</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9">Chapter 9</a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Executing tasks in an executor that returns a result</h1>
            

            <article>
                
<p class="calibre4">One of the advantages of the <kbd class="calibre15">Executor</kbd> framework is that it allows you to run concurrent tasks that return a result. The Java Concurrency API achieves this with the following two interfaces:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">Callable</kbd>: This interface has the <kbd class="calibre15">call()</kbd> method. In this method, you have to implement the logic of the task. The <kbd class="calibre15">Callable</kbd> interface is a parameterized interface, meaning you have to indicate the type of data the <kbd class="calibre15">call()</kbd> method will return.</li>
<li class="calibre18"><kbd class="calibre15">Future</kbd>: This interface has some methods to obtain the result generated by a <kbd class="calibre15">Callable</kbd> object and manage its state.</li>
</ul>
<p class="calibre4">In this recipe, you will learn how to implement tasks that return a result and run them on an executor.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">FactorialCalculator</kbd>. Specify that it implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">Integer</kbd> type:</li>
</ol>
<pre class="calibre23">
        public class FactorialCalculator implements Callable&lt;Integer&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">Integer</kbd> attribute called <kbd class="calibre15">number</kbd> to store the number that this task will use for its calculations:</li>
</ol>
<pre class="calibre23">
        private final Integer number;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that initializes the attribute of the class:</li>
</ol>
<pre class="calibre23">
        public FactorialCalculator(Integer number){ <br class="title-page-name"/>          this.number=number; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">call()</kbd> method. This method returns the factorial of the number attribute of <kbd class="calibre15">FactorialCalculator</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public Integer call() throws Exception {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">First, create and initialize the internal variables used in the method:</li>
</ol>
<pre class="calibre23">
        int result = 1;
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">If the number is <kbd class="calibre15">0</kbd> or <kbd class="calibre15">1</kbd>, return <kbd class="calibre15">1</kbd>. Otherwise, calculate the factorial of the number. Between two multiplications, for educational purposes, put this task to sleep for 20 milliseconds:</li>
</ol>
<pre class="calibre23">
        if ((number==0)||(number==1)) { <br class="title-page-name"/>          result=1; <br class="title-page-name"/>        } else { <br class="title-page-name"/>          for (int i=2; i&lt;=number; i++) { <br class="title-page-name"/>            result*=i; <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(20); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Write a message to the console with the result of the operation:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: %d\n",Thread.currentThread().getName(),<br class="title-page-name"/>                          result);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Return the result of the operation:</li>
</ol>
<pre class="calibre23">
        return result;
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create <kbd class="calibre15">ThreadPoolExecutor</kbd> to run the tasks using the <kbd class="calibre15">newFixedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class. Pass <kbd class="calibre15">2</kbd> as the parameter, that is, as the number of threads in the executor:</li>
</ol>
<pre class="calibre23">
        ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors<br class="title-page-name"/>                                               .newFixedThreadPool(2);
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a list of <kbd class="calibre15">Future&lt;Integer&gt;</kbd> objects:</li>
</ol>
<pre class="calibre23">
        List&lt;Future&lt;Integer&gt;&gt; resultList=new ArrayList&lt;&gt;();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create a random number generator with the <kbd class="calibre15">Random</kbd> class:</li>
</ol>
<pre class="calibre23">
        Random random=new Random();
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Make a loop with ten steps. In every step, we generate a random number:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          Integer number= random.nextInt(10);
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Then, we create a <kbd class="calibre15">FactorialCalculator</kbd> object passing the generated random number as parameter:</li>
</ol>
<pre class="calibre23">
        FactorialCalculator calculator=new FactorialCalculator(number);
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Call the <kbd class="calibre15">submit()</kbd> method of the executor to send the <kbd class="calibre15">FactorialCalculator</kbd> task to the executor. This method returns a <kbd class="calibre15">Future&lt;Integer&gt;</kbd> object to manage the task and eventually get its result:</li>
</ol>
<pre class="calibre23">
        Future&lt;Integer&gt; result=executor.submit(calculator);
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Add the <kbd class="calibre15">Future</kbd> object to the list created before:</li>
</ol>
<pre class="calibre23">
          resultList.add(result); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a <kbd class="calibre15">do</kbd> loop to monitor the status of the executor:</li>
</ol>
<pre class="calibre23">
        do {
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">First, write a message to the console indicating the number of completed tasks, using the <kbd class="calibre15">getCompletedTaskNumber()</kbd> method of the executor:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Number of Completed Tasks: %d\n",<br class="title-page-name"/>                          executor.getCompletedTaskCount());
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Then, for the 10 <kbd class="calibre15">Future</kbd> objects in the list, write a message indicating whether the tasks that it manages have finished or not. Do this using the <kbd class="calibre15">isDone()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;resultList.size(); i++) { <br class="title-page-name"/>          Future&lt;Integer&gt; result=resultList.get(i); <br class="title-page-name"/>          System.out.printf("Main: Task %d: %s\n",i,result.isDone()); <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Put the thread to sleep for 50 milliseconds:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.MILLISECONDS.sleep(50); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Repeat this loop when the number of completed tasks of the executor is less than 10:</li>
</ol>
<pre class="calibre23">
        } while (executor.getCompletedTaskCount()&lt;resultList.size());
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">In the console, write the results obtained by each task. For each <kbd class="calibre15">Future</kbd> object, get the <kbd class="calibre15">Integer</kbd> object returned by its task, using the <kbd class="calibre15">get()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Results\n"); <br class="title-page-name"/>        for (int i=0; i&lt;resultList.size(); i++) { <br class="title-page-name"/>          Future&lt;Integer&gt; result=resultList.get(i); <br class="title-page-name"/>          Integer number=null; <br class="title-page-name"/>          try { <br class="title-page-name"/>            number=result.get(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } catch (ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          }
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Then, print the number to the console:</li>
</ol>
<pre class="calibre23">
          System.out.printf("Main: Task %d: %d\n",i,number); <br class="title-page-name"/>        }
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Finally, call the <kbd class="calibre15">shutdown()</kbd> method of the executor to finalize its execution:</li>
</ol>
<pre class="calibre23">
        executor.shutdown();
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you learned how to use the <kbd class="calibre15">Callable</kbd> interface to launch concurrent tasks that return a result. You implemented the <kbd class="calibre15">FactorialCalculator</kbd> class that implements the <kbd class="calibre15">Callable</kbd> interface with <kbd class="calibre15">Integer</kbd> as the type of the result. Hence, the <kbd class="calibre15">call()</kbd> method returns an <kbd class="calibre15">Integer</kbd> value.</p>
<p class="calibre4">The other critical point of this example is the <kbd class="calibre15">Main</kbd> class. You sent a <kbd class="calibre15">Callable</kbd> object to be executed in an executor using the <kbd class="calibre15">submit()</kbd> method. This method receives a <kbd class="calibre15">Callable</kbd> object as a parameter and returns a <kbd class="calibre15">Future</kbd> object that you can use with two main objectives:</p>
<ul class="calibre17">
<li class="calibre18">You can control the status of the task you can cancel the task and check whether it has finished or not. For this purpose, you used the <kbd class="calibre15">isDone()</kbd> method.</li>
<li class="calibre18">You can get the result returned by the <kbd class="calibre15">call()</kbd> method. For this purpose, you used the <kbd class="calibre15">get()</kbd> method. This method waits until the <kbd class="calibre15">Callable</kbd> object has finished the execution of the <kbd class="calibre15">call()</kbd> method and has returned its result. If the thread is interrupted while the <kbd class="calibre15">get()</kbd> method is waiting for the result, it throws an <kbd class="calibre15">InterruptedException</kbd> exception. If the <kbd class="calibre15">call()</kbd> method throws an exception, then the <kbd class="calibre15">get()</kbd> method throws an <kbd class="calibre15">ExecutionException</kbd> exception as well.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">When you call the <kbd class="calibre15">get()</kbd> method of a <kbd class="calibre15">Future</kbd> object and the task controlled by this object hasn't finished yet, the method is blocked until the task is finished. The <kbd class="calibre15">Future</kbd> interface provides another version of the <kbd class="calibre15">get()</kbd> method:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">get(long timeout, TimeUnit unit)</kbd>: This version of the <kbd class="calibre15">get</kbd> method, if the result of the task isn't available, waits for the specified time. If the specified period of time passes and the result is still not available, it throws a <kbd class="calibre15">TimeoutException</kbd> exception. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a thread executor and controlling its rejected tasks</em>, <em class="calibre14">Running multiple tasks and processing the first result</em>, and <em class="calibre14">Running multiple tasks and processing all the results recipes</em> in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running multiple tasks and processing the first result</h1>
            

            <article>
                
<p class="calibre4">A common problem in concurrent programming arises when you have various concurrent tasks available to solve a problem, but you are only interested in the first result. For example, you want to sort an array. You have various sort algorithms. You can launch all of them and get the result of the first one that sorts the array, that is, the fastest sorting algorithm for a given array.</p>
<p class="calibre4">In this recipe, you will learn how to implement this scenario using the <kbd class="calibre15">ThreadPoolExecutor</kbd> class. You are going to use two mechanisms to try and validate a user. The user will be validated if one of these mechanisms is able to validate it.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">UserValidator</kbd> that will implement the process of user validation:</li>
</ol>
<pre class="calibre23">
        public class UserValidator {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd> that will store the name of the user validation system:</li>
</ol>
<pre class="calibre23">
        private final String name;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that initializes its attributes:</li>
</ol>
<pre class="calibre23">
        public UserValidator(String name) { <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">validate()</kbd> method. It receives two <kbd class="calibre15">String</kbd> parameters with the name and password of the user you want to validate:</li>
</ol>
<pre class="calibre23">
        public boolean validate(String name, String password) {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a <kbd class="calibre15">Random</kbd> object named <kbd class="calibre15">random</kbd>:</li>
</ol>
<pre class="calibre23">
        Random random=new Random();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Wait for a random period of time to simulate the process of user validation:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          long duration=(long)(Math.random()*10); <br class="title-page-name"/>          System.out.printf("Validator %s: Validating a user during %d<br class="title-page-name"/>                             seconds\n", this.name,duration); <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          return false; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Return a random <kbd class="calibre15">Boolean</kbd> value. The <kbd class="calibre15">validate()</kbd> method returns <kbd class="calibre15">true</kbd> when the user is validated, and <kbd class="calibre15">false</kbd> otherwise:</li>
</ol>
<pre class="calibre23">
          return random.nextBoolean(); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement <kbd class="calibre15">getName()</kbd>. This method returns the value of the name attribute:</li>
</ol>
<pre class="calibre23">
        public String getName(){ <br class="title-page-name"/>          return name; <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Now, create a class named <kbd class="calibre15">ValidatorTask</kbd> that will execute a validation process with the <kbd class="calibre15">UserValidation</kbd> object as a concurrent task. Specify that it implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">String</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class ValidatorTask implements Callable&lt;String&gt; {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a private <kbd class="calibre15">UserValidator</kbd> attribute named <kbd class="calibre15">validator</kbd>:</li>
</ol>
<pre class="calibre23">
        private final UserValidator validator;
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Declare two private <kbd class="calibre15">String</kbd> attributes, named <kbd class="calibre15">user</kbd> and <kbd class="calibre15">password</kbd>:</li>
</ol>
<pre class="calibre23">
        private final String user; <br class="title-page-name"/>        private final String password;
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the constructor of the class that will initialize all the attributes:</li>
</ol>
<pre class="calibre23">
        public ValidatorTask(UserValidator validator, String user,<br class="title-page-name"/>                             String password){ <br class="title-page-name"/>          this.validator=validator; <br class="title-page-name"/>          this.user=user; <br class="title-page-name"/>          this.password=password; <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the <kbd class="calibre15">call()</kbd> method that will return a <kbd class="calibre15">String</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public String call() throws Exception {
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">If the user is not validated by the <kbd class="calibre15">UserValidator</kbd> object, write a message to the console indicating this and throw <kbd class="calibre15">Exception</kbd>:</li>
</ol>
<pre class="calibre23">
        if (!validator.validate(user, password)) { <br class="title-page-name"/>          System.out.printf("%s: The user has not been found\n",<br class="title-page-name"/>                            validator.getName()); <br class="title-page-name"/>          throw new Exception("Error validating user"); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Otherwise, write a message to the console indicating that the user has been validated and return the name of the <kbd class="calibre15">UserValidator</kbd> object:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: The user has been found\n",<br class="title-page-name"/>                          validator.getName()); <br class="title-page-name"/>        return validator.getName();
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Now implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create two <kbd class="calibre15">String</kbd> objects named <kbd class="calibre15">user</kbd> and <kbd class="calibre15">password</kbd> and initialize them with the test value:</li>
</ol>
<pre class="calibre23">
        String username="test"; <br class="title-page-name"/>        String password="test";
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create two <kbd class="calibre15">UserValidator</kbd> objects, named <kbd class="calibre15">ldapValidator</kbd> and <kbd class="calibre15">dbValidator</kbd>:</li>
</ol>
<pre class="calibre23">
        UserValidator ldapValidator=new UserValidator("LDAP"); <br class="title-page-name"/>        UserValidator dbValidator=new UserValidator("DataBase");
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create two <kbd class="calibre15">TaskValidator</kbd> objects, named <kbd class="calibre15">ldapTask</kbd> and <kbd class="calibre15">dbTask</kbd>. Initialize them with <kbd class="calibre15">ldapValidator</kbd> and <kbd class="calibre15">dbValidator</kbd>, respectively:</li>
</ol>
<pre class="calibre23">
        TaskValidator ldapTask=new TaskValidator(ldapValidator,<br class="title-page-name"/>                                                 username, password); <br class="title-page-name"/>        TaskValidator dbTask=new TaskValidator(dbValidator,<br class="title-page-name"/>                                               username,password);
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Create a list of <kbd class="calibre15">TaskValidator</kbd> objects and add to it the two objects that you have created:</li>
</ol>
<pre class="calibre23">
        List&lt;TaskValidator&gt; taskList=new ArrayList&lt;&gt;(); <br class="title-page-name"/>        taskList.add(ldapTask); <br class="title-page-name"/>        taskList.add(dbTask);
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Create a new <kbd class="calibre15">ThreadPoolExecutor</kbd> object using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class and a string variable named <kbd class="calibre15">result</kbd>:</li>
</ol>
<pre class="calibre23">
        ExecutorService executor=(ExecutorService)Executors<br class="title-page-name"/>                                             .newCachedThreadPool(); <br class="title-page-name"/>        String result;
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Call the <kbd class="calibre15">invokeAny()</kbd> method of the executor object. This method receives <kbd class="calibre15">taskList</kbd> as a parameter and returns <kbd class="calibre15">String</kbd>. Also, it writes the <kbd class="calibre15">String</kbd> object that is returned to the console:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          result = executor.invokeAny(taskList); <br class="title-page-name"/>          System.out.printf("Main: Result: %s\n",result); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } catch (ExecutionException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Terminate the executor using the <kbd class="calibre15">shutdown()</kbd> method and write a message to the console to indicate that the program has ended:</li>
</ol>
<pre class="calibre23">
        executor.shutdown(); <br class="title-page-name"/>        System.out.printf("Main: End of the Execution\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key of the example is in the <kbd class="calibre15">Main</kbd> class. The <kbd class="calibre15">invokeAny()</kbd> method of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class receives a list of tasks, then launches them, and returns the result of the first task that finishes without throwing an exception. This method returns the same data type that the <kbd class="calibre15">call()</kbd> method of the tasks returns. In this case, it returned a <kbd class="calibre15">String</kbd> value.</p>
<p class="calibre4">The following screenshot shows the output of an execution of the example when one of the tasks validates the user:</p>
<div class="cdpaligncenter"><img class="alignnone17" src="../images/00028.gif"/></div>
<p class="calibre4">The example has two <kbd class="calibre15">UserValidator</kbd> objects that return a random Boolean value. Each <kbd class="calibre15">UserValidator</kbd> object is used by a <kbd class="calibre15">Callable</kbd> object, implemented by the <kbd class="calibre15">TaskValidator</kbd> class. If the <kbd class="calibre15">validate()</kbd> method of the <kbd class="calibre15">UserValidator</kbd> class returns a false value, the <kbd class="calibre15">TaskValidator</kbd> class throws <kbd class="calibre15">Exception</kbd>. Otherwise, it returns the <kbd class="calibre15">true</kbd> value.</p>
<p class="calibre4">So, we have two tasks that can return the <kbd class="calibre15">true</kbd> value or throw <kbd class="calibre15">Exception</kbd>. You can have the following four possibilities:</p>
<ul class="calibre17">
<li class="calibre18">Both tasks return the <kbd class="calibre15">true</kbd> value. Here, the result of the <kbd class="calibre15">invokeAny()</kbd> method is the name of the task that finishes in the first place.</li>
<li class="calibre18">The first task returns the <kbd class="calibre15">true</kbd> value and the second one throws <kbd class="calibre15">Exception</kbd>. Here, the result of the <kbd class="calibre15">invokeAny()</kbd> method is the name of the first task.</li>
<li class="calibre18">The first task throws <kbd class="calibre15">Exception</kbd> and the second one returns the <kbd class="calibre15">true</kbd> value. Here, the result of the <kbd class="calibre15">invokeAny()</kbd> method is the name of the second task.</li>
<li class="calibre18">Both tasks throw <kbd class="calibre15">Exception</kbd>. In such a class, the <kbd class="calibre15">invokeAny()</kbd> method throws an <kbd class="calibre15">ExecutionException</kbd> exception.</li>
</ul>
<p class="calibre4">If you run the examples several times, you will get each of the four possible solutions.</p>
<p class="calibre4">The following screenshot shows the output of the application when both the tasks throw an exception:</p>
<div class="cdpaligncenter"><img class="alignnone18" src="../images/00029.gif"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ThreadPoolExecutor</kbd> class provides another version of the <kbd class="calibre15">invokeAny()</kbd> method:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</kbd>: This method executes all the tasks and returns the result of the first one that finishes without throwing an exception, if it does so before the given timeout is passed. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Running multiple tasks and processing all the results</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running multiple tasks and processing all the results</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Executor</kbd> framework allows you to execute concurrent tasks without worrying about thread creation and execution. It provides you with the <kbd class="calibre15">Future</kbd> class, which you can use to control the status and get the results of any task executed in an executor.</p>
<p class="calibre4">When you want to wait for the finalization of a task, you can use the following two methods:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">isDone()</kbd> method of the <kbd class="calibre15">Future</kbd> interface returns <kbd class="calibre15">true</kbd> if the task has finished its execution</li>
<li class="calibre18">The <kbd class="calibre15">awaitTermination()</kbd> method of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class puts the thread to sleep until all the tasks have finished their execution after a call to the <kbd class="calibre15">shutdown()</kbd> method</li>
</ul>
<p class="calibre4">These two methods have some drawbacks. With the first one, you can only control the completion of a task. With the second one, you have to shut down the executor to wait for a thread; otherwise, the method's call is returned immediately.</p>
<p class="calibre4">The <kbd class="calibre15">ThreadPoolExecutor</kbd> class provides a method that allows you to send a list of tasks to the executor and wait for the finalization of all the tasks in the list. In this recipe, you will learn how to use this feature by implementing an example with 10 tasks executed and their results printed out when they have finished.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Result</kbd> to store the results generated in the concurrent tasks of this example:</li>
</ol>
<pre class="calibre23">
        public class Result {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare two private attributes, namely a <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd> and an <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">value</kbd>:</li>
</ol>
<pre class="calibre23">
        private String name; <br class="title-page-name"/>        private int value;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the corresponding <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">set()</kbd> methods to set and return the value of the name and value attributes:</li>
</ol>
<pre class="calibre23">
        public String getName() { <br class="title-page-name"/>          return name; <br class="title-page-name"/>        } <br class="title-page-name"/>        public void setName(String name) { <br class="title-page-name"/>          this.name = name; <br class="title-page-name"/>        } <br class="title-page-name"/>        public int getValue() { <br class="title-page-name"/>          return value; <br class="title-page-name"/>        } <br class="title-page-name"/>        public void setValue(int value) { <br class="title-page-name"/>          this.value = value; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">Result</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Task implements Callable&lt;Result&gt; {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd>:</li>
</ol>
<pre class="calibre23">
        private final String name;
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the constructor of the class that initializes its attribute:</li>
</ol>
<pre class="calibre23">
        public Task(String name) { <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">call()</kbd> method of the class. In this case, the method will return a <kbd class="calibre15">Result</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public Result call() throws Exception {
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">First, write a message to the console to indicate that the task is getting started:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Staring\n",this.name);
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Then, wait for a random period of time:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          long duration=(long)(Math.random()*10); <br class="title-page-name"/>          System.out.printf("%s: Waiting %d seconds for results.\n",<br class="title-page-name"/>                            this.name,duration); <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">To generate an <kbd class="calibre15">int</kbd> value to be returned in the <kbd class="calibre15">Result</kbd> object, calculate the sum of five random numbers:</li>
</ol>
<pre class="calibre23">
        int value=0; <br class="title-page-name"/>        for (int i=0; i&lt;5; i++){ <br class="title-page-name"/>          value+=(int)(Math.random()*100); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a <kbd class="calibre15">Result</kbd> object and initialize it with the name of this <kbd class="calibre15">Task</kbd> object and the result of the operation done earlier:</li>
</ol>
<pre class="calibre23">
        Result result=new Result(); <br class="title-page-name"/>        result.setName(this.name); <br class="title-page-name"/>        result.setValue(value);
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Write a message to the console to indicate that the task has finished:</li>
</ol>
<pre class="calibre23">
        System.out.println(this.name+": Ends");
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Return the <kbd class="calibre15">Result</kbd> object:</li>
</ol>
<pre class="calibre23">
          return result; <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Finally, implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>         <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create a <kbd class="calibre15">ThreadPoolExecutor</kbd> object using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class:</li>
</ol>
<pre class="calibre23">
        ExecutorService executor=(ExecutorService)Executors<br class="title-page-name"/>                                               .newCachedThreadPool();
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create a list of <kbd class="calibre15">Task</kbd> objects. Create 10 <kbd class="calibre15">Task</kbd> objects and save them on this list:</li>
</ol>
<pre class="calibre23">
        List&lt;Task&gt; taskList=new ArrayList&lt;&gt;(); <br class="title-page-name"/>        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          Task task=new Task("Task-"+i); <br class="title-page-name"/>          taskList.add(task); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a list of <kbd class="calibre15">Future</kbd> objects. These objects are parameterized by the <kbd class="calibre15">Result</kbd> class:</li>
</ol>
<pre class="calibre23">
        List&lt;Future&lt;Result&gt;&gt;resultList=null;
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Call the <kbd class="calibre15">invokeAll()</kbd> method of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class. This class will return the list of the <kbd class="calibre15">Future</kbd> objects created earlier:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          resultList=executor.invokeAll(taskList); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Finalize the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.shutdown();
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Write the results of the tasks processing the list of <kbd class="calibre15">Future</kbd> objects:</li>
</ol>
<pre class="calibre23">
        System.out.println("Main: Printing the results"); <br class="title-page-name"/>        for (int i=0; i&lt;resultList.size(); i++){ <br class="title-page-name"/>          Future&lt;Result&gt; future=resultList.get(i); <br class="title-page-name"/>          try { <br class="title-page-name"/>            Result result=future.get(); <br class="title-page-name"/>            System.out.println(result.getName()+": "+result.getValue()); <br class="title-page-name"/>          } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you learned how to send a list of tasks to an executor and wait for the finalization of all of them using the <kbd class="calibre15">invokeAll()</kbd> method. This method receives a list of <kbd class="calibre15">Callable</kbd> objects and returns a list of <kbd class="calibre15">Future</kbd> objects. This list will have a <kbd class="calibre15">Future</kbd> object per task. The first object in the list of <kbd class="calibre15">Future</kbd> objects will be the object that controls the first task in the list of <kbd class="calibre15">Callable</kbd> objects, the second object the second task, and so on.</p>
<p class="calibre4">The first point to take into consideration is that the type of data used for the parameterization of the <kbd class="calibre15">Future</kbd> interface in the declaration of the list that stores the result objects must be compatible with the one used to parameterize <kbd class="calibre15">Callable</kbd> objects. In this case, you used the same type of data: the <kbd class="calibre15">Result</kbd> class.</p>
<p class="calibre4">Another important point about the <kbd class="calibre15">invokeAll()</kbd> method is that you will use <kbd class="calibre15">Future</kbd> objects only to get the results of the tasks. As the method finishes when all the tasks finish, if you call the <kbd class="calibre15">isDone()</kbd> method of <kbd class="calibre15">Future</kbd> objects that are returned, all the calls will return the true value.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ExecutorService</kbd> class provides another version of the <kbd class="calibre15">invokeAll()</kbd> method:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</kbd>: This method executes all the tasks and returns the result of their execution when all of them are finished, that is, if they finish before the given timeout has passed. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Executing tasks in an executor that returns a result</em> and <em class="calibre14">Running multiple tasks and processing the first result</em> recipes in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running a task in an executor after a delay</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Executor</kbd> framework provides the <kbd class="calibre15">ThreadPoolExecutor</kbd> class to execute <kbd class="calibre15">Callable</kbd> and <kbd class="calibre15">Runnable</kbd> tasks with a pool of threads, which helps you avoid all thread creation operations. When you send a task to the executor, it's executed as soon as possible, according to the configuration of the executor. There are use cases when you are not interested in executing a task as soon as possible. You may want to execute a task after a period of time or do it periodically. For these purposes, the Executor framework provides the <kbd class="calibre15">ScheduledExecutorService</kbd> interface along with its implementation, namely the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class.</p>
<p class="calibre4">In this recipe, you will learn how to create <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> and use it to schedule the execution of a task after a given period of time.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">String</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Task implements Callable&lt;String&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd> that will store the name of the task:</li>
</ol>
<pre class="calibre23">
        private final String name;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that initializes the name attribute:</li>
</ol>
<pre class="calibre23">
        public Task(String name) { <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">call()</kbd> method. Write a message to the console with the actual date and return some text, for example, <kbd class="calibre15">Hello, world</kbd>:</li>
</ol>
<pre class="calibre23">
        public String call() throws Exception { <br class="title-page-name"/>          System.out.printf("%s: Starting at : %s\n",name,new Date()); <br class="title-page-name"/>          return "Hello, world"; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create an executor of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class using the <kbd class="calibre15">newScheduledThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class, passing <kbd class="calibre15">1</kbd> as a parameter:</li>
</ol>
<pre class="calibre23">
        ScheduledExecutorService executor=Executors<br class="title-page-name"/>                                           .newScheduledThreadPool(1);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Initialize and start a few tasks (five in our case) with the <kbd class="calibre15">schedule()</kbd> method of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> instance:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Starting at: %s\n",new Date()); <br class="title-page-name"/>        for (int i=0; i&lt;5; i++) { <br class="title-page-name"/>          Task task=new Task("Task "+i); <br class="title-page-name"/>          executor.schedule(task,i+1 , TimeUnit.SECONDS); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Request the finalization of the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.shutdown();
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Wait for the finalization of all the tasks using the <kbd class="calibre15">awaitTermination()</kbd> method of the executor:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          executor.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Write a message to indicate the time when the program will finish:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Ends at: %s\n",new Date());
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key point of this example is the <kbd class="calibre15">Main</kbd> class and the management of <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd>. As with the <kbd class="calibre15">ThreadPoolExecutor</kbd> class, to create a scheduled executor, Java recommends that you utilize the <kbd class="calibre15">Executors</kbd> class. In this case, you used the <kbd class="calibre15">newScheduledThreadPool()</kbd> method. You passed the number <kbd class="calibre15">1</kbd> as a parameter to this method. This parameter refers to the number of threads you want to have in the pool.</p>
<p class="calibre4">To execute a task in this scheduled executor after a period of time, you have to use the <kbd class="calibre15">schedule()</kbd> method. This method receives the following three parameters:</p>
<ul class="calibre17">
<li class="calibre18">The task you want to execute</li>
<li class="calibre18">The period of time you want the task to wait before its execution</li>
<li class="calibre18">The unit of the period of time, specified as a constant of the <kbd class="calibre15">TimeUnit</kbd> class</li>
</ul>
<p class="calibre4">In this case, each task will wait for a number of seconds (<kbd class="calibre15">TimeUnit.SECONDS</kbd>) equal to its position in the array of tasks plus one.</p>
<div class="packt_infobox">If you want to execute a task at a given time, calculate the difference between that date and the current date and use the difference as the delay of the task.</div>
<p class="calibre4">The following screenshot shows the output of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone19" src="../images/00030.jpeg"/></div>
<p class="calibre4">You can see how the tasks start their execution, one per second. All the tasks are sent to the executor at the same time but with a delay of 1 second later than the previous task.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You can also use the <kbd class="calibre15">Runnable</kbd> interface to implement the tasks because the <kbd class="calibre15">schedule()</kbd> method of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class accepts both types of tasks.</p>
<p class="calibre4">Although the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class is a child class of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class (and therefore inherits all its features), Java recommends that you use <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> only for scheduled tasks.</p>
<p class="calibre4">Finally, you can configure the behavior of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class when you call the <kbd class="calibre15">shutdown()</kbd> method, and there are pending tasks waiting for the end of their delay time. The default behavior is that these tasks will be executed despite the finalization of the executor. You can change this behavior using the <kbd class="calibre15">setExecuteExistingDelayedTasksAfterShutdownPolicy()</kbd> method of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class. If you call the <kbd class="calibre15">setExecuteExistingDelayedTasksAfeterShutdownsPolicy()</kbd> passing the <kbd class="calibre15">false</kbd> value as parameter, pending tasks won't be executed after you call the <kbd class="calibre15">shutdown()</kbd> method.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Executing tasks in an executor that returns a result</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running a task in an executor periodically</h1>
            

            <article>
                
<p class="calibre4">The Executor framework provides the <kbd class="calibre15">ThreadPoolExecutor</kbd> class to execute concurrent tasks using a pool of threads that helps you avoid all thread creation operations. When you send a task to the executor, it executes the task as soon as possible according to its configuration. When it ends, the task is deleted from the executor, and if you want to execute it again, you have to send it to the executor again.</p>
<p class="calibre4">However, the Executor framework provides the possibility of executing periodic tasks through the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class. In this recipe, you will learn how to use this functionality of the class to schedule a periodic task.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd> that will store the name of the task:</li>
</ol>
<pre class="calibre23">
        private final String name;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that initializes the attribute:</li>
</ol>
<pre class="calibre23">
        public Task(String name) { <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Write a message to the console with the actual date to verify that the task is executed within the specified period:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("%s: Executed at: %s\n",name,new Date()); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create <kbd class="calibre15">ScheduledExecutorService</kbd> using the <kbd class="calibre15">newScheduledThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class. Pass <kbd class="calibre15">1</kbd> to this method as a parameter:</li>
</ol>
<pre class="calibre23">
        ScheduledExecutorService executor=Executors<br class="title-page-name"/>                                           .newScheduledThreadPool(1);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Write a message to the console with the actual date:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Starting at: %s\n",new Date());
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a new <kbd class="calibre15">Task</kbd> object:</li>
</ol>
<pre class="calibre23">
        Task task=new Task("Task");
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Send this object to the executor using the <kbd class="calibre15">scheduledAtFixRate()</kbd> method. Use the tasks created earlier as parameters: the number one, the number two, and the constant <kbd class="calibre15">TimeUnit.SECONDS</kbd>. This method returns a <kbd class="calibre15">ScheduledFuture</kbd> object that you can use to control the status of the task:</li>
</ol>
<pre class="calibre23">
        ScheduledFuture&lt;?&gt; result=executor.scheduleAtFixedRate(task, 1,<br class="title-page-name"/>                                                  2, TimeUnit.SECONDS);
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a loop with 10 steps to write the time remaining for the next execution of the task. In the loop, use the <kbd class="calibre15">getDelay()</kbd> method of the <kbd class="calibre15">ScheduledFuture</kbd> object to get the number of milliseconds until the next execution of the task:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          System.out.printf("Main: Delay: %d\n",result<br class="title-page-name"/>                                     .getDelay(TimeUnit.MILLISECONDS));
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Sleep the thread during 500 milliseconds.</li>
</ol>
<pre class="calibre23">
          try { <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(500); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Finish the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.shutdown();
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Put the thread to sleep for 5 seconds to verify that the periodic tasks have finished:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(5); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Write a message to indicate the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Finished at: %s\n",new Date());
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">When you want to execute a periodic task using the Executor framework, you need a <kbd class="calibre15">ScheduledExecutorService</kbd> object. To create it (as with every executor), Java recommends the use of the <kbd class="calibre15">Executors</kbd> class. This class works as a factory of executor objects. In this case, you used the <kbd class="calibre15">newScheduledThreadPool()</kbd> method to create a <kbd class="calibre15">ScheduledExecutorService</kbd> object. This method receives the number of threads of the pool as a parameter. Since you had only one task in this example, you passed <kbd class="calibre15">1</kbd> as a parameter.</p>
<p class="calibre4">Once you had the executor needed to execute a periodic task, you sent the task to the executor. You used the <kbd class="calibre15">scheduledAtFixedRate()</kbd> method. This method accepts four parameters: the task you want to execute periodically, the delay of time until the first execution of the task, the period between two executions, and the time unit of the second and third parameters. It's a constant of the <kbd class="calibre15">TimeUnit</kbd> class. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</p>
<p class="calibre4">An important point to consider is that the period between two executions is the period of time between the start of those two executions. If you have a periodic task that takes 5 seconds to execute and you put in a period of 3 seconds, you will have two instances of the task executing at a time.</p>
<p class="calibre4">The <kbd class="calibre15">scheduleAtFixedRate()</kbd> method returns a <kbd class="calibre15">ScheduledFuture</kbd> object, which extends the <kbd class="calibre15">Future</kbd> interface, with methods to work with scheduled tasks. <kbd class="calibre15">ScheduledFuture</kbd> is a parameterized interface. In this example, as your task was a <kbd class="calibre15">Runnable</kbd> object that was not parameterized, you had to parameterize them with the <kbd class="calibre15">?</kbd> symbol as a parameter.</p>
<p class="calibre4">You used one method of the <kbd class="calibre15">ScheduledFuture</kbd> interface. The <kbd class="calibre15">getDelay()</kbd> method returns the time until the next execution of the task. This method receives a <kbd class="calibre15">TimeUnit</kbd> constant with the time unit in which you want to receive the results.</p>
<p class="calibre4">The following screenshot shows the output of an execution of the example:</p>
<div class="cdpaligncenter"><img class="alignnone20" src="../images/00031.jpeg"/></div>
<p class="calibre4">You can see the task being executed every 2 seconds (denoted by Task: prefix) and the delay written in the console every 500 milliseconds. That's how long the main thread has been put to sleep. When you shut down the executor, the scheduled task ends its execution and you don't see any more messages in the console.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4"><kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> provides other methods to schedule periodic tasks. It is the <kbd class="calibre15">scheduleWithFixedRate()</kbd> method. It has the same parameters as the <kbd class="calibre15">scheduledAtFixedRate()</kbd> method, but there is a difference worth noticing. In the <kbd class="calibre15">scheduledAtFixedRate()</kbd> method, the third parameter determines the period of time between the starting of two executions. In the <kbd class="calibre15">scheduledWithFixedRate()</kbd> method, the parameter determines the period of time between the end of an execution of the task and its beginning.</p>
<p class="calibre4">You can also configure the behavior of an instance of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class with the <kbd class="calibre15">shutdown()</kbd> method. The default behavior is that the scheduled tasks finish when you call this method. You can change this behavior using the <kbd class="calibre15">setContinueExistingPeriodicTasksAfterShutdownPolicy()</kbd> method of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class with a true value. Periodic tasks won't finish upon calling the <kbd class="calibre15">shutdown()</kbd> method.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a thread executor and controlling its rejected tasks</em> and <em class="calibre14">Running a task in an executor after a delay </em>recipes in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Canceling a task in an executor</h1>
            

            <article>
                
<p class="calibre4">When you work with an executor, you don't have to manage threads. You only implement <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> tasks and send them to the executor. It's the executor that's responsible for creating threads, managing them in a thread pool, and finishing them if they are not needed. Sometimes, you may want to cancel a task that you send to the executor. In that case, you can use the <kbd class="calibre15">cancel()</kbd> method of <kbd class="calibre15">Future</kbd>, which allows you to make the cancelation operation. In this recipe, you will learn how to use this method to cancel tasks that you have sent to an executor.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">String</kbd> class. Implement the <kbd class="calibre15">call()</kbd> method. Write a message to the console and put it to sleep for <kbd class="calibre15">100</kbd> milliseconds inside an infinite loop:</li>
</ol>
<pre class="calibre23">
        public class Task implements Callable&lt;String&gt; { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public String call() throws Exception { <br class="title-page-name"/>            while (true){ <br class="title-page-name"/>              System.out.printf("Task: Test\n"); <br class="title-page-name"/>              Thread.sleep(100); <br class="title-page-name"/>            } <br class="title-page-name"/>          }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Create a <kbd class="calibre15">ThreadPoolExecutor</kbd> object using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class:</li>
</ol>
<pre class="calibre23">
        ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors<br class="title-page-name"/>                                               .newCachedThreadPool();
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create a new <kbd class="calibre15">Task</kbd> object:</li>
</ol>
<pre class="calibre23">
        Task task=new Task();
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Send the task to the executor using the <kbd class="calibre15">submit()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Executing the Task\n"); <br class="title-page-name"/>        Future&lt;String&gt; result=executor.submit(task);
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Put the main task to sleep for 2 seconds:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Cancel the execution of the task using the <kbd class="calibre15">cancel()</kbd> method of the <kbd class="calibre15">Future</kbd> object, named <kbd class="calibre15">result</kbd>, returned by the <kbd class="calibre15">submit()</kbd> method. Pass the true value as a parameter of the <kbd class="calibre15">cancel()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Canceling the Task\n"); <br class="title-page-name"/>        result.cancel(true);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Write the result of a call to the <kbd class="calibre15">isCancelled()</kbd> and <kbd class="calibre15">isDone()</kbd> methods to the console. This is to verify that the task has been canceled, and hence, already done:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Canceled: %s\n",result.isCancelled()); <br class="title-page-name"/>        System.out.printf("Main: Done: %s\n",result.isDone());
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Finish the executor with the <kbd class="calibre15">shutdown()</kbd> method and write a message indicating the finalization of the program:</li>
</ol>
<pre class="calibre23">
        executor.shutdown(); <br class="title-page-name"/>        System.out.printf("Main: The executor has finished\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">You use the <kbd class="calibre15">cancel()</kbd> method of the <kbd class="calibre15">Future</kbd> interface when you want to cancel a task that you have sent to an executor. Depending on the parameter of the <kbd class="calibre15">cancel()</kbd> method and the status of the task, the behavior of this method is different:</p>
<ul class="calibre17">
<li class="calibre18">If the task has finished or has been canceled earlier, or it can't be cancelled due to any other reason, the method will return the <kbd class="calibre15">false</kbd> value and the task won't be canceled.</li>
<li class="calibre18">If the task is waiting in the executor to get a <kbd class="calibre15">Thread</kbd> object that will execute it, the task is canceled and will never begin its execution. If the task is already running, it depends on the parameter of the method. The <kbd class="calibre15">cancel()</kbd> method receives a Boolean value as a parameter. If the value of this parameter is <kbd class="calibre15">true</kbd> and the task is running, it will be canceled. If the value of the parameter is false and the task is running, it won't be canceled.</li>
</ul>
<p class="calibre4">The following screenshot shows the output of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone21" src="../images/00032.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">If you use the <kbd class="calibre15">get()</kbd> method of a <kbd class="calibre15">Future</kbd> object that controls a task that has been canceled, the <kbd class="calibre15">get()</kbd> method will throw a <kbd class="calibre15">CancellationException</kbd> exception.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Executing tasks in an executor that returns a result</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Controlling a task finishing in an executor</h1>
            

            <article>
                
<p class="calibre4">The Java API provides the <kbd class="calibre15">FutureTask</kbd> class as a cancelable asynchronous computation. It implements the <kbd class="calibre15">Runnable</kbd> and <kbd class="calibre15">Future</kbd> interfaces and provides the basic implementation of the <kbd class="calibre15">Future</kbd> interface. We can create a <kbd class="calibre15">FutureTask</kbd> class using a <kbd class="calibre15">Callable</kbd> or <kbd class="calibre15">Runnable</kbd> object <kbd class="calibre15">(Runnable</kbd> objects doesn't return a result, so we have to pass as parameter too in this case the result that the <kbd class="calibre15">Future</kbd> object will return). It provides methods to cancel the execution and obtain the result of the computation. It also provides a method called <kbd class="calibre15">done()</kbd> that allows you to execute some code after the finalization of a task executed in an executor. It can be used to make some postprocess operations, such as generating a report, sending results by e-mail, or releasing some resources. This method is called internally by the <kbd class="calibre15">FutureTask</kbd> class when the execution of the task that this <kbd class="calibre15">FutureTask</kbd> object is controlling finishes. The method is called after the result of the task is set and its status is changed to <kbd class="calibre15">isDone</kbd>, regardless of whether the task has been canceled or finished normally.</p>
<p class="calibre4">By default, this method is empty. You can override the <kbd class="calibre15">FutureTask</kbd> class and implement this method to change the behavior. In this recipe, you will learn how to override this method to execute code after the finalization of the tasks.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">ExecutableTask</kbd> and specify that it implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">String</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class ExecutableTask implements Callable&lt;String&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd>. It will store the name of the task. Implement the <kbd class="calibre15">getName()</kbd> method to return the value of this attribute:</li>
</ol>
<pre class="calibre23">
        private final String name; <br class="title-page-name"/>        public String getName(){ <br class="title-page-name"/>          return name; <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize the name of the task:</li>
</ol>
<pre class="calibre23">
        public ExecutableTask(String name){ <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">call()</kbd> method. Put the task to sleep for a random period of time and return a message with the name of the task:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public String call() throws Exception { <br class="title-page-name"/>          try { <br class="title-page-name"/>            long duration=(long)(Math.random()*10); <br class="title-page-name"/>            System.out.printf("%s: Waiting %d seconds for results.\n",<br class="title-page-name"/>                              this.name,duration); <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>          } catch (InterruptedException e) {}     <br class="title-page-name"/>          return "Hello, world. I'm "+name; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement a class named <kbd class="calibre15">ResultTask</kbd> that extends the <kbd class="calibre15">FutureTask</kbd> class parameterized by the <kbd class="calibre15">String</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class ResultTask extends FutureTask&lt;String&gt; {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd>. It will store the name of the task:</li>
</ol>
<pre class="calibre23">
        private final String name;
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the constructor of the class. It has to receive a <kbd class="calibre15">Callable</kbd> object as a parameter. Call the constructor of the parent class and initialize the name attribute using the attribute of the task received:</li>
</ol>
<pre class="calibre23">
        public ResultTask(ExecutableTask callable) { <br class="title-page-name"/>          super(callable); <br class="title-page-name"/>          this.name= callable.getName(); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Override the <kbd class="calibre15">done()</kbd> method. Check the value of the <kbd class="calibre15">isCancelled()</kbd> method and write a different message to the console, depending on the returned value:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void done() { <br class="title-page-name"/>          if (isCancelled()) { <br class="title-page-name"/>            System.out.printf("%s: Has been canceled\n",name); <br class="title-page-name"/>          } else { <br class="title-page-name"/>            System.out.printf("%s: Has finished\n",name); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create <kbd class="calibre15">ExecutorService</kbd> using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class:</li>
</ol>
<pre class="calibre23">
        ExecutorService executor=Executors.newCachedThreadPool();
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create an array to store five <kbd class="calibre15">ResultTask</kbd> objects:</li>
</ol>
<pre class="calibre23">
        ResultTask resultTasks[]=new ResultTask[5];
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Initialize the <kbd class="calibre15">ResultTask</kbd> objects. For each position in the array, first you have to create <kbd class="calibre15">ExecutorTask</kbd> and then <kbd class="calibre15">ResultTask</kbd> using the object. Then, send <kbd class="calibre15">ResultTask</kbd> to the executor using the <kbd class="calibre15">submit()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;5; i++) { <br class="title-page-name"/>          ExecutableTask executableTask=new ExecutableTask("Task "+i); <br class="title-page-name"/>          resultTasks[i]=new ResultTask(executableTask); <br class="title-page-name"/>          executor.submit(resultTasks[i]); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Put the main thread to sleep for 5 seconds:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(5); <br class="title-page-name"/>        } catch (InterruptedException e1) { <br class="title-page-name"/>          e1.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Cancel all the tasks you have sent to the executor:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;resultTasks.length; i++) { <br class="title-page-name"/>          resultTasks[i].cancel(true); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Write the result of those tasks that haven't been canceled to the console, using the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">ResultTask</kbd> objects:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;resultTasks.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            if (!resultTasks[i].isCancelled()){ <br class="title-page-name"/>              System.out.printf("%s\n",resultTasks[i].get()); <br class="title-page-name"/>            } <br class="title-page-name"/>          } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          }     <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Finish the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
            executor.shutdown(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">done()</kbd> method is called by the <kbd class="calibre15">FutureTask</kbd> class when the task that is being controlled finishes its execution. In this example, you implemented a <kbd class="calibre15">Callable</kbd> object, the <kbd class="calibre15">ExecutableTask</kbd> class, and then a subclass of the <kbd class="calibre15">FutureTask</kbd> class that controls the execution of the <kbd class="calibre15">ExecutableTask</kbd> objects.</p>
<p class="calibre4">The <kbd class="calibre15">done()</kbd> method is called internally by the <kbd class="calibre15">FutureTask</kbd> class after establishing the return value and changing the status of the task to <kbd class="calibre15">isDone</kbd>. You can't change the result value of the task or change its status, but you can close resources used by the task, write log messages, or send notifications. The <kbd class="calibre15">FutureTask</kbd> class might be used to ensure that a specific task is run only once, as calling its <kbd class="calibre15">run()</kbd> method will execute its wrapped <kbd class="calibre15">Runnable</kbd>/<kbd class="calibre15">Callable</kbd> interface only once (and the result can be fetched with <kbd class="calibre15">get</kbd> when it's available).</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Executing tasks in an executor that returns a result</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Separating the launching of tasks and the processing of their results in an executor</h1>
            

            <article>
                
<p class="calibre4">Normally, when you execute concurrent tasks using an executor, you will send <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> tasks to the executor and get <kbd class="calibre15">Future</kbd> objects to control the method. You can find situations where you need to send the tasks to the executor in one object and process the results in another one. For such situations, the Java Concurrency API provides the <kbd class="calibre15">CompletionService</kbd> class.</p>
<p class="calibre4">The <kbd class="calibre15">CompletionService</kbd> class has a method to send tasks to an executor and a method to get the <kbd class="calibre15">Future</kbd> object for the next task that has finished its execution. Internally, it uses an <kbd class="calibre15">Executor</kbd> object to execute the tasks. This behavior has the advantage of sharing a <kbd class="calibre15">CompletionService</kbd> object and sending tasks to the executor so others can process the results. The limitation is that the second object can only get the <kbd class="calibre15">Future</kbd> objects for those tasks that have finished their execution, so these Future objects can only be used to get the results of the tasks.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">CompletionService</kbd> class to separate the process of launching tasks in an executor from the processing of their results.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">ReportGenerator</kbd> and specify that it implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">String</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class ReportGenerator implements Callable&lt;String&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare two private <kbd class="calibre15">String</kbd> attributes named <kbd class="calibre15">sender</kbd> and <kbd class="calibre15">title</kbd>. These attributes will represent the data of the report:</li>
</ol>
<pre class="calibre23">
        private final String sender; <br class="title-page-name"/>        private final String title;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that initializes the two attributes:</li>
</ol>
<pre class="calibre23">
        public ReportGenerator(String sender, String title){ <br class="title-page-name"/>          this.sender=sender; <br class="title-page-name"/>          this.title=title; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">call()</kbd> method. First, put the thread to sleep for a random period of time:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public String call() throws Exception { <br class="title-page-name"/>          try { <br class="title-page-name"/>            Long duration=(long)(Math.random()*10); <br class="title-page-name"/>            System.out.printf("%s_%s: ReportGenerator: Generating a<br class="title-page-name"/>                              report during %d seconds\n",this.sender,<br class="title-page-name"/>                              this.title,duration); <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, generate the report as a string with the <kbd class="calibre15">sender</kbd> and <kbd class="calibre15">title</kbd> attributes and return that string:</li>
</ol>
<pre class="calibre23">
          String ret=sender+": "+title; <br class="title-page-name"/>          return ret; <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create a class named <kbd class="calibre15">ReportRequest</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. Thiss class will simulate some report requests:</li>
</ol>
<pre class="calibre23">
        public class ReportRequest implements Runnable {
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd> to store the name of <kbd class="calibre15">ReportRequest</kbd>:</li>
</ol>
<pre class="calibre23">
        private final String name;
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a private <kbd class="calibre15">CompletionService</kbd> attribute named <kbd class="calibre15">service</kbd>. The <kbd class="calibre15">CompletionService</kbd> interface is a parameterized interface. Use the <kbd class="calibre15">String</kbd> class:</li>
</ol>
<pre class="calibre23">
        private final CompletionService&lt;String&gt; service;
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the constructor of the class that initializes the two attributes:</li>
</ol>
<pre class="calibre23">
        public ReportRequest(String name, CompletionService&lt;String&gt;<br class="title-page-name"/>                             service){ <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>          this.service=service; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Create three <kbd class="calibre15">ReportGenerator</kbd> objects and send them to the <kbd class="calibre15">CompletionService</kbd> object using the <kbd class="calibre15">submit()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          ReportGenerator reportGenerator=new ReportGenerator(name,<br class="title-page-name"/>                                                              "Report"); <br class="title-page-name"/>          service.submit(reportGenerator); <br class="title-page-name"/>     <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a class named <kbd class="calibre15">ReportProcessor</kbd>. This class will get the results of the <kbd class="calibre15">ReportGenerator</kbd> tasks. Specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class ReportProcessor implements Runnable {
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Declare a private <kbd class="calibre15">CompletionService</kbd> attribute named <kbd class="calibre15">service</kbd>. As the <kbd class="calibre15">CompletionService</kbd> interface is a parameterized interface, use the <kbd class="calibre15">String</kbd> class as a parameter of this <kbd class="calibre15">CompletionService</kbd> interface:</li>
</ol>
<pre class="calibre23">
        private final CompletionService&lt;String&gt; service;
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Declare a private <kbd class="calibre15">Boolean</kbd> attribute named <kbd class="calibre15">end</kbd>. Add the <kbd class="calibre15">volatile</kbd> keyword to ensure that all the threads have access to the actual value of the attribute:</li>
</ol>
<pre class="calibre23">
        private volatile boolean end;
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the constructor of the class to initialize the two attributes:</li>
</ol>
<pre class="calibre23">
        public ReportProcessor (CompletionService&lt;String&gt; service){ <br class="title-page-name"/>          this.service=service; <br class="title-page-name"/>          end=false; <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. While the <kbd class="calibre15">end</kbd> attribute is false, call the <kbd class="calibre15">poll()</kbd> method of the <kbd class="calibre15">CompletionService</kbd> interface to get the <kbd class="calibre15">Future</kbd> object of the next task executed by the completion service that has finished:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          while (!end){ <br class="title-page-name"/>            try { <br class="title-page-name"/>              Future&lt;String&gt; result=service.poll(20, TimeUnit.SECONDS);
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Then, get the results of the task using the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">Future</kbd> object and write the results to the console:</li>
</ol>
<pre class="calibre23">
              if (result!=null) { <br class="title-page-name"/>                String report=result.get(); <br class="title-page-name"/>                System.out.printf("ReportReceiver: Report Received: %s\n",<br class="title-page-name"/>                                  report); <br class="title-page-name"/>              }       <br class="title-page-name"/>            } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("ReportSender: End\n"); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Implement the <kbd class="calibre15">stopProcessing()</kbd> method that modifies the value of the <kbd class="calibre15">end</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public void stopProcessing() { <br class="title-page-name"/>          this.end = true; <br class="title-page-name"/>        }
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create <kbd class="calibre15">ThreadPoolExecutor</kbd> using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class:</li>
</ol>
<pre class="calibre23">
        ExecutorService executor=Executors.newCachedThreadPool();
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Create <kbd class="calibre15">CompletionService</kbd> using the executor created earlier as a parameter of the constructor:</li>
</ol>
<pre class="calibre23">
        CompletionService&lt;String&gt; service=new<br class="title-page-name"/>                                   ExecutorCompletionService&lt;&gt;(executor);
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Create two <kbd class="calibre15">ReportRequest</kbd> objects and the threads to execute them:</li>
</ol>
<pre class="calibre23">
        ReportRequest faceRequest=new ReportRequest("Face", service); <br class="title-page-name"/>        ReportRequest onlineRequest=new ReportRequest("Online", service);   <br class="title-page-name"/>        Thread faceThread=new Thread(faceRequest); <br class="title-page-name"/>        Thread onlineThread=new Thread(onlineRequest);
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Create a <kbd class="calibre15">ReportProcessor</kbd> object and the thread to execute it:</li>
</ol>
<pre class="calibre23">
        ReportProcessor processor=new ReportProcessor(service); <br class="title-page-name"/>        Thread senderThread=new Thread(processor);
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Start the three threads:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Starting the Threads\n"); <br class="title-page-name"/>        faceThread.start(); <br class="title-page-name"/>        onlineThread.start(); <br class="title-page-name"/>        senderThread.start();
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Wait for the finalization of the <kbd class="calibre15">ReportRequest</kbd> threads:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          System.out.printf("Main: Waiting for the report generators.\n"); <br class="title-page-name"/>          faceThread.join(); <br class="title-page-name"/>          onlineThread.join(); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Finish the executor using the <kbd class="calibre15">shutdown()</kbd> method and wait for the finalization of the tasks with the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Shutting down the executor.\n"); <br class="title-page-name"/>        executor.shutdown(); <br class="title-page-name"/>        try { <br class="title-page-name"/>          executor.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">Finish the execution of the <kbd class="calibre15">ReportSender</kbd> object setting the value of its <kbd class="calibre15">end</kbd> attribute to true:</li>
</ol>
<pre class="calibre23">
        processor.stopProcessing(); <br class="title-page-name"/>        System.out.println("Main: Ends");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the main class of the example, you created <kbd class="calibre15">ThreadPoolExecutor</kbd> using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class. Then, you used that <kbd class="calibre15">Executor</kbd> object to initialize a <kbd class="calibre15">CompletionService</kbd> object because the completion service uses an executor to execute its tasks. To execute a task using the completion service, use the <kbd class="calibre15">submit()</kbd> method, as in the <kbd class="calibre15">ReportRequest</kbd> class.</p>
<p class="calibre4">When one of these tasks is executed when the completion service finishes its execution, the service stores the <kbd class="calibre15">Future</kbd> object used to control its execution in a queue. The <kbd class="calibre15">poll()</kbd> method accesses this queue to check whether there is any task that has finished its execution; if yes, it returns the first element of the queue, which is a <kbd class="calibre15">Future</kbd> object of a task that has finished its execution. When the <kbd class="calibre15">poll()</kbd> method returns a <kbd class="calibre15">Future</kbd> object, it deletes it from the queue. In this case, you passed two attributes to the method to indicate the time you want to wait for the finalization of a task, in case the queue with the results of the finished tasks is empty.</p>
<p class="calibre4">Once the <kbd class="calibre15">CompletionService</kbd> object is created, you create two <kbd class="calibre15">ReportRequest</kbd> objects that execute a <kbd class="calibre15">ReportGenerator</kbd> task, execute a <kbd class="calibre15">ReportGenerator</kbd> task using the <kbd class="calibre15">CompletionService</kbd> object create before and passed as parameter to the constructor of the <kbd class="calibre15">ReportRequest</kbd> objects</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">CompletionService</kbd> class can execute <kbd class="calibre15">Callable</kbd> or <kbd class="calibre15">Runnable</kbd> tasks. In this example, you used <kbd class="calibre15">Callable</kbd>, but you could have also sent <kbd class="calibre15">Runnable</kbd> objects. Since <kbd class="calibre15">Runnable</kbd> objects don't produce a result, the philosophy of the <kbd class="calibre15">CompletionService</kbd> class doesn't apply in such cases.</p>
<p class="calibre4">This class also provides two other methods to obtain the <kbd class="calibre15">Future</kbd> objects of the finished tasks. These methods are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">poll()</kbd>: The version of the <kbd class="calibre15">poll()</kbd> method without arguments checks whether there are any <kbd class="calibre15">Future</kbd> objects in the queue. If the queue is empty, it returns null immediately. Otherwise, it returns its first element and removes it from the queue.</li>
<li class="calibre18"><kbd class="calibre15">take()</kbd>: This method, without arguments, checks whether there are any <kbd class="calibre15">Future</kbd> objects in the queue. If it is empty, it blocks the thread until the queue has an element. If the queue has elements, it returns and deletes its first element from the queue.</li>
</ul>
<p class="calibre4">In our case, we used the <kbd class="calibre15">poll()</kbd> method with a timeout to control when we would like to end the execution of the <kbd class="calibre15">ReportProcessor</kbd> task.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Executing tasks in an executor that returns a result</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>