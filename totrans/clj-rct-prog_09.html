<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;A Reactive API to Amazon Web Services"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. A Reactive API to Amazon Web Services</h1></div></div></div><p class="calibre7">Throughout this book, we have learned a number of tools and techniques to aid us in building reactive applications—futures with imminent, Observables with RxClojure/RxJava, channels with <code class="email">core.async</code>—and even in building reactive user interfaces using Om and React.</p><p class="calibre7">In the process, we also became acquainted with the concept of <span class="strong"><strong class="calibre2">Functional Reactive Programming</strong></span> and <span class="strong"><strong class="calibre2">Compositional Event Systems</strong></span>, as well as what makes them different.</p><p class="calibre7">In this last chapter, we will bring a few of these different tools and concepts together by developing an application based on a real-world use case from a client I worked with in Sydney, Australia. We will:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Describe the problem of infrastructure automation we were trying to solve</li><li class="listitem">Have a brief look at some of Amazon's AWS services</li><li class="listitem">Build an AWS dashboard using the concepts we have learned so far</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;A Reactive API to Amazon Web Services">
<div class="book" title="The problem"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec54" class="calibre1"/>The problem</h1></div></div></div><p class="calibre7">This client—which we will call BubbleCorp from now on—had a big problem that is all too common and well known to big enterprises: one massive monolithic application.</p><p class="calibre7">Besides<a id="id404" class="calibre1"/> making them move slow, as individual components can't be evolved independently, this application makes deployment incredibly hard due to its environment constraints: all infrastructure needs to be available in order for the application to work at all.</p><p class="calibre7">As a result, developing new features and bug fixes involves having only a handful of development environments shared across dozens of developers each. This requires a wasteful amount of coordination between teams just so that they won't step on each other's toes, contributing to slow the whole life-cycle further.</p><p class="calibre7">The long-term solution to this problem is to break down this big application into smaller components, which can be deployed and worked on independently, but as good as this sounds, it's<a id="id405" class="calibre1"/> a laborious and lengthy process.</p><p class="calibre7">As a first step, BubbleCorp decided the best thing they could improve in the short term is to give developers the ability to work in the application independently from each other, which implies being able to create a new environment as well.</p><p class="calibre7">Given the infrastructure constraints, running the application on a single developer machine is prohibitive.</p><p class="calibre7">Instead, they turned to infrastructure automation: they wanted a tool that, with the press of a button, would spin up a completely new environment.</p><p class="calibre7">This new environment would be already preconfigured with the proper application servers, database instances, DNS entries, and everything else needed to run the application.</p><p class="calibre7">This way, developers would only need to deploy their code and test their changes, without having to worry about the application setup.</p></div></div>
<div class="book" title="Infrastructure automation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec55" class="calibre1"/>Infrastructure automation</h1></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre2">Amazon Web Services</strong></span> (<span class="strong"><strong class="calibre2">AWS</strong></span>) is the most mature and comprehensive cloud computing platform <a id="id406" class="calibre1"/>available today, and as such it was a natural <a id="id407" class="calibre1"/>choice for BubbleCorp to host its infrastructure in.</p><p class="calibre7">If you haven't used AWS before, don't worry, we'll focus only on a few of its services:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Elastic Compute Cloud</strong></span> (<span class="strong"><strong class="calibre2">EC2</strong></span>): A <a id="id408" class="calibre1"/>service that provides users<a id="id409" class="calibre1"/> with the ability to rent virtual computers in which to run their applications.</li><li class="listitem"><span class="strong"><strong class="calibre2">Relational Database Service</strong></span> (<span class="strong"><strong class="calibre2">RDS</strong></span>): This <a id="id410" class="calibre1"/>can be thought of<a id="id411" class="calibre1"/> as a specialized version of EC2 that provides managed database services.</li><li class="listitem"><span class="strong"><strong class="calibre2">CloudFormation</strong></span>: With <a id="id412" class="calibre1"/>CloudFormation, users have the<a id="id413" class="calibre1"/> ability to specify infrastructure templates, called stacks, of several different AWS resources—such as EC2, AWS, and many others—as well as how they interact with each other. Once written, the infrastructure template can be sent to AWS to be executed.</li></ul></div><p class="calibre7">For <span class="strong"><strong class="calibre2">BubbleCorp</strong></span>, the idea was to write these infrastructure templates, which once submitted would result into a completely new, isolated environment containing all data and components required to run its app. At any given time, there would be dozens of these environments running with developers working on them.</p><p class="calibre7">As decent a<a id="id414" class="calibre1"/> plan as this sounds, big <a id="id415" class="calibre1"/>corporations usually have an added burden: cost centers. Unfortunately, BubbleCorp can't simply allow developers to log into the AWS Console—where we can manage AWS resources—and spin up environments at will. They needed a way to, among other things, add cost center metadata to the environment to handle their internal billing process.</p><p class="calibre7">This brings us to the application we will be focusing on for the remainder of this chapter.</p></div>
<div class="book" title="AWS resources dashboard"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec56" class="calibre1"/>AWS resources dashboard</h1></div></div></div><p class="calibre7">My team and I were tasked with building a web-based dashboard for AWS. This dashboard <a id="id416" class="calibre1"/>would allow developers to log in using their BubbleCorp's credentials and, once authenticated, create new CloudFormation environments as well as visualize the status of each individual resource within a CloudFormation stack.</p><p class="calibre7">The application itself is fairly involved, so we will focus on a subset of it: interfacing with the necessary AWS services in order to gather information about the status of each individual resource in a given CloudFormation stack.</p><p class="calibre7">Once finished, this is what our simplified dashboard will look like:</p><div class="mediaobject"><img src="../images/00027.jpeg" alt="AWS resources dashboard" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">It will display the ID, type, and current status of each resource. This might not seem like much for<a id="id417" class="calibre1"/> now, but given that all this information is coming from different, independent web services, it is far too easy to end up with unnecessarily complex code.</p><p class="calibre7">We will be using ClojureScript for this and therefore the JavaScript version of the AWS SDK, whose documentation can be found at <a class="calibre1" href="http://aws.amazon.com/sdk-for-node-js/">http://aws.amazon.com/sdk-for-node-js/</a>.</p><p class="calibre7">Before we get started, let's have a look at each of the AWS Services APIs we will be interacting with.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip33" class="calibre1"/>Tip</h3><p class="calibre7">In reality, we will not be interacting with the real AWS services but rather a stub server provided for download from the book's GitHub repository.</p><p class="calibre7">The reason for this is to make following this chapter easier, as you won't need to create an account as well as generate an API access key to interact with AWS.</p><p class="calibre7">Additionally, creating resources incurs cost, and the last thing I want is for you to be charged hundreds of dollars at the end of the month because someone accidentally left resources running for longer than they should—trust me it has happened before.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="CloudFormation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec57" class="calibre1"/>CloudFormation</h1></div></div></div><p class="calibre7">The first<a id="id418" class="calibre1"/> service we will look<a id="id419" class="calibre1"/> at is CloudFormation. This makes sense as the APIs found in here will give us a starting point for finding information about the resources in a given stack.</p></div>

<div class="book" title="CloudFormation">
<div class="book" title="The describeStacks endpoint"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec62" class="calibre1"/>The describeStacks endpoint</h2></div></div></div><p class="calibre7">This <a id="id420" class="calibre1"/>endpoint is responsible for listing all stacks<a id="id421" class="calibre1"/> associated with a particular AWS account. For a given stack, its response looks like the following:</p><div class="informalexample"><pre class="programlisting">{"Stacks"
   [{"StackId"
     "arn:aws:cloudformation:ap-southeast-2:337944750480:stack/DevStack-62031/1",
     "StackStatus" "CREATE_IN_PROGRESS",
     "StackName" "DevStack-62031",
     "Parameters" [{"ParameterKey" "DevDB", "ParameterValue" nil}]}]}</pre></div><p class="calibre7">Unfortunately, it <a id="id422" class="calibre1"/>doesn't say anything about which <a id="id423" class="calibre1"/>resources belong to this stack. It does, however, give us the stack name, which we can use to look up resources in the next service.</p></div></div>

<div class="book" title="CloudFormation">
<div class="book" title="The describeStackResources endpoint"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec63" class="calibre1"/>The describeStackResources endpoint</h2></div></div></div><p class="calibre7">This <a id="id424" class="calibre1"/>endpoint receives many arguments, but the one we're interested in is the stack name, which, once provided, returns the<a id="id425" class="calibre1"/> following:</p><div class="informalexample"><pre class="programlisting">{"StackResources"
   [{"PhysicalResourceId" "EC2123",
     "ResourceType" "AWS::EC2::Instance"},
    {"PhysicalResourceId" "EC2456",
     "ResourceType" "AWS::EC2::Instance"}
    {"PhysicalResourceId" "EC2789",
     "ResourceType" "AWS::EC2::Instance"}
    {"PhysicalResourceId" "RDS123",
     "ResourceType" "AWS::RDS::DBInstance"}
    {"PhysicalResourceId" "RDS456",
     "ResourceType" "AWS::RDS::DBInstance"}]}</pre></div><p class="calibre7">We seem to be getting somewhere now. This stack has several resources: three EC2 instances and two RDS instances—not too bad for only two API calls.</p><p class="calibre7">However, as we mentioned previously, our dashboard needs to show the status of each of the resources. With the list of resource IDs at hand, we need to look to other services that could give us detailed information about each resource.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="EC2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec58" class="calibre1"/>EC2</h1></div></div></div><p class="calibre7">The next <a id="id426" class="calibre1"/>service we will look at is specific<a id="id427" class="calibre1"/> to EC2. As we will see, the responses of the different services aren't as consistent as we would like them to be.</p></div>

<div class="book" title="EC2">
<div class="book" title="The describeInstances endpoint"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec64" class="calibre1"/>The describeInstances endpoint</h2></div></div></div><p class="calibre7">This <a id="id428" class="calibre1"/>endpoint sounds promising. Based on the documentation, it seems we can give it a list of instance IDs and it will give us back the following<a id="id429" class="calibre1"/> response:</p><div class="informalexample"><pre class="programlisting">{"Reservations"
   [{"Instances"
     [{"InstanceId" "EC2123",
       "Tags"
       [{"Key" "StackType", "Value" "Dev"}
        {"Key" "junkTag", "Value" "should not be included"}
        {"Key" "aws:cloudformation:logical-id", "Value" "theDude"}],
       "State" {"Name" "running"}}
      {"InstanceId" "EC2456",
       "Tags"
       [{"Key" "StackType", "Value" "Dev"}
        {"Key" "junkTag", "Value" "should not be included"}
        {"Key" "aws:cloudformation:logical-id", "Value" "theDude"}],
       "State" {"Name" "running"}}
      {"InstanceId" "EC2789",
       "Tags"
       [{"Key" "StackType", "Value" "Dev"}
        {"Key" "junkTag", "Value" "should not be included"}
        {"Key" "aws:cloudformation:logical-id", "Value" "theDude"}],
       "State" {"Name" "running"}}]}]}</pre></div><p class="calibre7">Buried in this response, we can see the <code class="email">State</code> key, which gives us the status of that particular EC2 instance. This is all we need as far as EC2 goes. This leaves us with RDS to handle.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="RDS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec59" class="calibre1"/>RDS</h1></div></div></div><p class="calibre7">One might <a id="id430" class="calibre1"/>be tempted to think that <a id="id431" class="calibre1"/>getting the statuses of RDS instances would be just as easy as with EC2. Let's see if that is the case.</p></div>

<div class="book" title="RDS">
<div class="book" title="The describeDBInstances endpoint"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec65" class="calibre1"/>The describeDBInstances endpoint</h2></div></div></div><p class="calibre7">This<a id="id432" class="calibre1"/> endpoint is equivalent in purpose to the analogous <a id="id433" class="calibre1"/>EC2 endpoint we just looked at. Its input, however, is slightly different: it accepts a single instance ID as input and, as of the time of this writing, doesn't support filters.</p><p class="calibre7">This means that if our stack has multiple RDS instances—say, in a primary/replica setup—we need to make multiple API calls to gather information about each one of them. Not a big deal, of course, but a limitation to be aware of.</p><p class="calibre7">Once given a specific database instance ID, this service responds with the following code:</p><div class="informalexample"><pre class="programlisting">{"DBInstances"
   [{"DBInstanceIdentifier" "RDS123", "DBInstanceStatus" "available"}]}</pre></div><p class="calibre7">The <a id="id434" class="calibre1"/>fact that a single instance comes inside a vector hints<a id="id435" class="calibre1"/> at the fact that filtering will be supported in the future. It just hasn't happened yet.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Designing the solution"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec60" class="calibre1"/>Designing the solution</h1></div></div></div><p class="calibre7">We now have all the information we need to start designing our application. We need to coordinate <a id="id436" class="calibre1"/>four different API calls per CloudFormation stack:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">describeStacks</code>: To list all available stacks</li><li class="listitem"><code class="email">describeStackResources</code>: To retrieve details of all resources contained in a stack</li><li class="listitem"><code class="email">describeInstances</code>: To retrieve details of all EC2 instances in a stack</li><li class="listitem"><code class="email">describeDBInstances</code>: To retrieve details of all DB2 instances in a stack</li></ul></div><p class="calibre7">Next, I would like you to step back for a moment and think about how you would design code like this. Go ahead, I'll wait.</p><p class="calibre7">Now that you're back, let's have a look at one possible approach.</p><p class="calibre7">If we recall the screenshot of what the dashboard would look like, we realize that, for the purposes of our application, the difference between EC2 and RDS resources can be completely ignored so long as each one has the attributes ID, type, and status.</p><p class="calibre7">This means whatever our solution may be, it has to somehow provide a uniform way of abstracting the different resource types.</p><p class="calibre7">Additionally, apart from <code class="email">describeStacks</code> and <code class="email">describeStackResources</code>, which need to be called sequentially, <code class="email">describeInstances</code> and <code class="email">describeDBInstances</code> can be executed concurrently, after which we will need a way to merge the results.</p><p class="calibre7">Since an image is worth a thousand words, the following image is what we would like the workflow to look like:</p><div class="mediaobject"><img src="../images/00028.jpeg" alt="Designing the solution" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The preceding <a id="id437" class="calibre1"/>image highlights a number of key aspects of our solution:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We start by retrieving stacks by calling <code class="email">describeStacks</code></li><li class="listitem">Next, for each stack, we call <code class="email">describeStackResources</code> to retrieve a list of resources for each one</li><li class="listitem">Then, we split the list by type, ending with a list of EC2 and one with RDS resources</li><li class="listitem">We proceed by concurrently calling <code class="email">describeInstances</code> and <code class="email">describeDBInstances</code>, yielding two lists of results, one per resource type</li><li class="listitem">As the response formats are different, we transform each resource into a uniform representation</li><li class="listitem">Lastly, we merge all results into a single list, ready for rendering</li></ul></div><p class="calibre7">This is quite a bit to take in, but as you will soon realize, our solution isn't too far off this high-level description.</p><p class="calibre7">We can <a id="id438" class="calibre1"/>quite easily think of this problem as having information about several different types of instances flowing through this graph of API calls—being transformed as needed in between—until we arrive at the information we're after, in the format we would like to work with.</p><p class="calibre7">As it turns out, a great way to model this problem is to use one of the Reactive abstractions we learned about earlier in this book: Observables.</p></div>

<div class="book" title="Designing the solution">
<div class="book" title="Running the AWS stub server"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec66" class="calibre1"/>Running the AWS stub server</h2></div></div></div><p class="calibre7">Before we jump into writing our dashboard, we should make sure our AWS stub server is properly <a id="id439" class="calibre1"/>set up. The stub server is a <a id="id440" class="calibre1"/>Clojure web application that simulates how the real AWS API behaves and is the backend our dashboard will talk to.</p><p class="calibre7">Let's start by going into our terminal, cloning the book repository using Git and then starting the stub server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ git clone https://github.com/leonardoborges/ClojureReactiveProgramming</strong></span>
<span class="strong"><strong class="calibre2">$ cd ClojureReactiveProgramming/code/chapter09/aws-api-stub</strong></span>
<span class="strong"><strong class="calibre2">$ lein ring server-headless 3001</strong></span>
<span class="strong"><strong class="calibre2">2014-11-23 17:33:37.766:INFO:oejs.Server:jetty-7.6.8.v20121106</strong></span>
<span class="strong"><strong class="calibre2">2014-11-23 17:33:37.812:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3001</strong></span>
<span class="strong"><strong class="calibre2">Started server on port 3001</strong></span>
</pre></div><p class="calibre7">This will have started the server on port 3001. To validate it is working as expected, point your browser to <code class="email">http://localhost:3001/cloudFormation/describeStacks</code>. You should see the following JSON response:</p><div class="informalexample"><pre class="programlisting">{
    "Stacks": [
        {
            "Parameters": [
                {
                    "ParameterKey": "DevDB",
                    "ParameterValue": null
                }
            ],
            "StackStatus": "CREATE_IN_PROGRESS",
            "StackId": "arn:aws:cloudformation:ap-southeast-2:337944750480:stack/DevStack-62031/1",
            "StackName": "DevStack-62031"
        }
    ]
}</pre></div></div></div>

<div class="book" title="Designing the solution">
<div class="book" title="Setting up the dashboard project"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec67" class="calibre1"/>Setting up the dashboard project</h2></div></div></div><p class="calibre7">As we <a id="id441" class="calibre1"/>previously mentioned, we will be developing the dashboard using ClojureScript with the UI rendered using Om. Additionally, as we have chosen Observables as our main Reactive abstraction, we will need RxJS, one of the many implementations of Microsoft's Reactive Extensions. We will be pulling these dependencies into our project shortly.</p><p class="calibre7">Let's create a new ClojureScript project called <code class="email">aws-dash</code> using the <code class="email">om-start</code> leiningen template:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ lein new om-start aws-dash</strong></span>
</pre></div><p class="calibre7">This gives us a starting point, but we should make sure our versions all match. Open up the <code class="email">project.clj</code> file found in the root directory of the new project and ensure the dependencies section looks like the following:</p><div class="informalexample"><pre class="programlisting">...
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/clojurescript "0.0-2371"]
                 [org.clojure/core.async "0.1.346.0-17112a-alpha"]
                 [om "0.5.0"]
                 [com.facebook/react "0.9.0"]
                 [cljs-http "0.1.20"]
                 [com.cognitect/transit-cljs "0.8.192"]]
   :plugins [[lein-cljsbuild "1.0.3"]]
...</pre></div><p class="calibre7">This is the first time we see the last two dependencies. <code class="email">cljs-http</code> is a simple HTTP library we will use to make AJAX requests to our AWS stub server. <code class="email">transit-cljs</code> allows us to, among other things, parse JSON responses into ClojureScript data structures.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip34" class="calibre1"/>Tip</h3><p class="calibre7">Transit<a id="id442" class="calibre1"/> itself is a format and a set of libraries through which applications developed in different technologies can speak to each other. In this case, we are using the Clojurescript library to parse JSON, but if you're interested in learning more, I recommend reading the official blog post announcement by<a id="id443" class="calibre1"/> Rich Hickey at <a class="calibre1" href="http://blog.cognitect.com/blog/2014/7/22/transit">http://blog.cognitect.com/blog/2014/7/22/transit</a>.</p></div><p class="calibre7">Next, we need RxJS, which, being a JavaScript dependency, isn't available via leiningen. That's OK. We will simply download it into the application output directory, <code class="email">aws-dash/dev-resources/public/js/</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ cd aws-dash/dev-resources/public/js/</strong></span>
<span class="strong"><strong class="calibre2">$ wget https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/dist/rx.all.js</strong></span>
<span class="strong"><strong class="calibre2">--2014-11-23 18:00:21--  https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/dist/rx.all.js</strong></span>
<span class="strong"><strong class="calibre2">Resolving raw.githubusercontent.com... 103.245.222.133</strong></span>
<span class="strong"><strong class="calibre2">Connecting to raw.githubusercontent.com|103.245.222.133|:443... connected.</strong></span>
<span class="strong"><strong class="calibre2">HTTP request sent, awaiting response... 200 OK</strong></span>
<span class="strong"><strong class="calibre2">Length: 355622 (347K) [text/plain]</strong></span>
<span class="strong"><strong class="calibre2">Saving to: 'rx.all.js'</strong></span>

<span class="strong"><strong class="calibre2">100%[========================&gt;] 355,622      966KB/s   in 0.4s</strong></span>

<span class="strong"><strong class="calibre2">2014-11-23 18:00:24 (966 KB/s) - 'rx.all.js' saved [355622/355622]</strong></span>
</pre></div><p class="calibre7">Moving <a id="id444" class="calibre1"/>on, we need to make our application aware of our new dependency on RxJS. Open the <code class="email">aws-dash/dev-resources/public/index.html</code> file and add a script tag to pull in RxJS:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script src="http://fb.me/react-0.9.0.js"&gt;&lt;/script&gt;
    &lt;script src="js/rx.all.js"&gt;&lt;/script&gt;
    &lt;script src="js/aws_dash.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">With all the dependencies in place, let's start the auto-compilation for our ClojureScript source files as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ cd aws-dash/</strong></span>
<span class="strong"><strong class="calibre2">$ lein cljsbuild auto</strong></span>
<span class="strong"><strong class="calibre2">Compiling ClojureScript.</strong></span>
<span class="strong"><strong class="calibre2">Compiling "dev-resources/public/js/aws_dash.js" from ("src/cljs" "dev-resources/tools/repl")...</strong></span>
<span class="strong"><strong class="calibre2">Successfully compiled "dev-resources/public/js/aws_dash.js" in 0.981 seconds.</strong></span>
</pre></div></div></div>

<div class="book" title="Designing the solution">
<div class="book" title="Creating AWS Observables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec68" class="calibre1"/>Creating AWS Observables</h2></div></div></div><p class="calibre7">We're <a id="id445" class="calibre1"/>now ready to start implementing<a id="id446" class="calibre1"/> our solution. If you recall from the Reactive Extensions chapter, <code class="email">RxJava/RxJS/RxClojure</code> ship with several useful Observables. However, when the built-in Observables aren't enough, it gives us the tools to build our own.</p><p class="calibre7">Since it is highly unlikely RxJS already provides Observables for Amazon's AWS API, we will <a id="id447" class="calibre1"/>start by implementing our own <a id="id448" class="calibre1"/>primitive Observables.</p><p class="calibre7">To keep things neat, we will do this in a new file, under <code class="email">aws-dash/src/cljs/aws_dash/observables.cljs</code>:</p><div class="informalexample"><pre class="programlisting">(ns aws-dash.observables
  (:require-macros [cljs.core.async.macros :refer [go]])
  (:require [cljs-http.client :as http]
            [cljs.core.async :refer [&lt;!]]
            [cognitect.transit :as t]))


(def r (t/reader :json))

(def  aws-endpoint "http://localhost:3001")
(defn aws-uri [path]
  (str aws-endpoint path))</pre></div><p class="calibre7">The namespace declaration requires the necessary dependencies we will need in this file. Note how there is no explicit dependency on RxJS. Since it is a JavaScript dependency that we manually pulled in, it is globally available for us to use via JavaScript interoperability.</p><p class="calibre7">The next line sets up a <code class="email">transit</code> reader for JSON, which we will use when parsing the stub server responses.</p><p class="calibre7">Then, we define the endpoint we will be talking to as well as a helper function to build the correct URIs. Make sure the variable <code class="email">aws-endpoint</code> matches the host and port of the stub server started in the previous section.</p><p class="calibre7">All Observables we are about to create follow a common structure: they make a request to the stub server, extract some information from the response, optionally transforming it, and then emit each item in the transformed sequence into the new Observable sequence.</p><p class="calibre7">To avoid repetition, this pattern is captured in the following function:</p><div class="informalexample"><pre class="programlisting">(defn observable-seq [uri transform]
  (.create js/Rx.Observable
           (fn [observer]
             (go (let [response      (&lt;! (http/get uri {:with-credentials? false}))
                       data          (t/read r (:body response))
                       transformed   (transform data)]
                   (doseq [x transformed]
                     (.onNext observer x))
                   (.onCompleted observer)))
             (fn [] (.log js/console "Disposed")))))</pre></div><p class="calibre7">Let's <a id="id449" class="calibre1"/>break this function down:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">observable-seq</code> receives two arguments: the backend URI to which we will issue a GET request, and a <code class="email">transform</code> function which is given the raw parsed JSON response and returns a sequence of transformed items.</li><li class="listitem">Then, it calls the <code class="email">create</code> function of the RxJS object <code class="email">Rx.Observable</code>. Note how we make use of JavaScript interoperability here: we access the create function by prepending it with a dot much like in Java interoperability. Since <code class="email">Rx.Observable</code> is a global object, we access it by prepending the global JavaScript namespace ClojureScript makes available to our program, <code class="email">js/Rx.Observable</code>.</li><li class="listitem">The Observable's create function receives two arguments. One is a function that gets called with an Observer to which we can push items to be published in the Observable sequence. The second function is a function that is called whenever this Observable is disposed of. This is the function where we could perform any cleanup needed. In our case, this function simply logs the fact that it is called to the console.</li></ul></div><p class="calibre7">The first<a id="id450" class="calibre1"/> function is the one that interests us though:</p><div class="informalexample"><pre class="programlisting">(fn [observer]
  (go (let [response      (&lt;! (http/get uri 
                                        {:with-credentials? 
                                         false}))
            data          (t/read r (:body response))
            transformed   (transform data)]
        (doseq [x transformed]
          (.onNext observer x))
        (.onCompleted observer))))</pre></div><p class="calibre7">As soon as it gets called, it performs a request to the provided URI using cljs-http's <code class="email">get</code> function, which returns a <code class="email">core.async</code> channel. That's why the whole logic is inside a <code class="email">go</code> block.</p><p class="calibre7">Next, we use the transit JSON reader we configured previously to parse the body of the response, feeding the result into the <code class="email">transform</code> function. Remember this function, as per our design, returns a sequence of things. Therefore, all that is left to do is push each item into the observer in turn.</p><p class="calibre7">Once we're done, we indicate that this Observable sequence won't emit any new item by invoking the <code class="email">.onCompleted</code> function of the <code class="email">observer</code> object.</p><p class="calibre7">Now, we<a id="id451" class="calibre1"/> can proceed creating our Observables using this helper function, starting with the one responsible for retrieving <a id="id452" class="calibre1"/>CloudFormation stacks:</p><div class="informalexample"><pre class="programlisting">(defn describe-stacks []
  (observable-seq (aws-uri "/cloudFormation/describeStacks")
                  (fn [data]
                    (map (fn [stack] {:stack-id   (stack "StackId")
                                     :stack-name (stack "StackName")})
                         (data "Stacks")))))</pre></div><p class="calibre7">This creates an observable that will emit one item per stack, in the following format:</p><div class="informalexample"><pre class="programlisting">({:stack-id "arn:aws:cloudformation:ap-southeast-2:337944750480:stack/DevStack-62031/1", :stack-name "DevStack-62031"})</pre></div><p class="calibre7">Now that we have stacks, we need an Observable to describe its resources:</p><div class="informalexample"><pre class="programlisting">(defn describe-stack-resources [stack-name]
  (observable-seq (aws-uri "/cloudFormation/describeStackResources")
                  (fn [data]
                    (map (fn [resource]
                           {:resource-id (resource "PhysicalResourceId")
                            :resource-type (resource "ResourceType")} )
                         (data "StackResources")))))</pre></div><p class="calibre7">It has a similar purpose and emits resource items in the following format:</p><div class="informalexample"><pre class="programlisting">({:resource-id "EC2123", :resource-type "AWS::EC2::Instance"}
 {:resource-id "EC2456", :resource-type "AWS::EC2::Instance"}
 {:resource-id "EC2789", :resource-type "AWS::EC2::Instance"}
 {:resource-id "RDS123", :resource-type "AWS::RDS::DBInstance"}
 {:resource-id "RDS456", :resource-type "AWS::RDS::DBInstance"})</pre></div><p class="calibre7">Since we're following our strategy almost to the letter, we need two more observables, one for each instance type:</p><div class="informalexample"><pre class="programlisting">(defn describe-instances [instance-ids]
  (observable-seq (aws-uri "/ec2/describeInstances")
                  (fn [data]
                    (let [instances (mapcat (fn [reservation]
                                              (reservation "Instances"))
                                            (data "Reservations"))]
                      (map (fn [instance]
                             {:instance-id  (instance "InstanceId")
                              :type        "EC2"
                              :status      (get-in instance ["State" "Name"])})
                           instances)))))

(defn describe-db-instances [instance-id]
  (observable-seq (aws-uri (str "/rds/describeDBInstances/" instance-id))
                  (fn [data]
                    (map (fn [instance]
                           {:instance-id (instance "DBInstanceIdentifier")
                            :type        "RDS"
                            :status      (instance "DBInstanceStatus")})
                         (data "DBInstances")))))</pre></div><p class="calibre7">Each <a id="id453" class="calibre1"/>of which will emit resource items<a id="id454" class="calibre1"/> in the following formats for EC2 and RDS, respectively:</p><div class="informalexample"><pre class="programlisting">({:instance-id "EC2123", :type "EC2", :status "running"} ...)
({:instance-id "RDS123", :type "RDS", :status "available"} ...)</pre></div></div></div>

<div class="book" title="Designing the solution">
<div class="book" title="Combining the AWS Observables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec69" class="calibre1"/>Combining the AWS Observables</h2></div></div></div><p class="calibre7">It seems <a id="id455" class="calibre1"/>we have all major pieces in <a id="id456" class="calibre1"/>place now. All that is left to do is to combine the more primitive, basic Observables we just created into more complex and useful ones by combining them to aggregate all the data we need in order to render our dashboard.</p><p class="calibre7">We will start by creating a function that combines both the <code class="email">describe-stacks</code> and <code class="email">describe-stack-resources</code> Observables:</p><div class="informalexample"><pre class="programlisting">(defn stack-resources []
  (-&gt; (describe-stacks)
      (.map #(:stack-name %))
      (.flatMap describe-stack-resources)))</pre></div><p class="calibre7">Starting in the previous example, we begin to see how defining our API calls in terms of Observable sequences pays off: it's almost simple combining these two Observables in a declarative manner.</p><p class="calibre7">Remember the role of <code class="email">flatMap</code>: as <code class="email">describe-stack-resources</code> itself returns an Observable, we use <code class="email">flatMap</code> to flatten both Observables, as we have done before in various different abstractions.</p><p class="calibre7">The <code class="email">stack-resources</code> Observable will emit resource items for all stacks. According to our<a id="id457" class="calibre1"/> plan, we would like to fork the <a id="id458" class="calibre1"/>processing here in order to concurrently retrieve EC2 and RDS instance data.</p><p class="calibre7">By following this train of thought, we arrive at two more functions that combine and transform the previous Observables:</p><div class="informalexample"><pre class="programlisting">(defn ec2-instance-status [resources]
  (-&gt; resources
      (.filter #(= (:resource-type %) "AWS::EC2::Instance"))
      (.map #(:resource-id %))
      (.reduce conj [])
      (.flatMap describe-instances)))

(defn rds-instance-status [resources]
  (-&gt; resources
      (.filter #(= (:resource-type %) "AWS::RDS::DBInstance"))
      (.map #(:resource-id %))
      (.flatMap describe-db-instances)))</pre></div><p class="calibre7">Both the functions receive an argument, resources, which is the result of calling the <code class="email">stack-resources</code> Observable. That way, we only need to call it once.</p><p class="calibre7">Once again, it is fairly simple to combine the Observables in a way that makes sense, following our high-level idea described previously.</p><p class="calibre7">Starting with <code class="email">resources</code>, we filter out the types we're not interested in, retrieve its IDs, and request its detailed information by flatmapping the <code class="email">describe-instances</code> and <code class="email">describe-db-instances</code> Observables.</p><p class="calibre7">Note, however, that due to a limitation in the RDS API described earlier, we have to call it multiple times to retrieve information about all RDS instances.</p><p class="calibre7">This seemingly fundamental difference in how we use the API becomes a minor transformation in our EC2 observable, which simply accumulates all IDs into a vector so that we can retrieve them all at once.</p><p class="calibre7">Our simple Reactive API to Amazon AWS is now complete, leaving us with the UI to create.</p></div></div>

<div class="book" title="Designing the solution">
<div class="book" title="Putting it all together"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec70" class="calibre1"/>Putting it all together</h2></div></div></div><p class="calibre7">Let's <a id="id459" class="calibre1"/>now turn to building our user interface. It's a simple one, so let's just jump into it. Open up <code class="email">aws-dash/src/cljs/aws_dash/core.cljs</code> and add the following:</p><div class="informalexample"><pre class="programlisting">(ns aws-dash.core
  (:require [aws-dash.observables :as obs]
            [om.core :as om :include-macros true]
            [om.dom :as dom :include-macros true]))

(enable-console-print!)

(def app-state (atom {:instances []}))

(defn instance-view [{:keys [instance-id type status]} owner]
  (reify
    om/IRender
    (render [this]
      (dom/tr nil
              (dom/td nil instance-id)
              (dom/td nil type)
              (dom/td nil status)))))

(defn instances-view [instances owner]
  (reify
    om/IRender
    (render [this]
      (apply dom/table #js {:style #js {:border "1px solid black;"}}
             (dom/tr nil
                     (dom/th nil "Id")
                     (dom/th nil "Type")
                     (dom/th nil "Status"))
             (om/build-all instance-view instances)))))

(om/root
 (fn [app owner]
   (dom/div nil
            (dom/h1 nil "Stack Resource Statuses")
            (om/build instances-view (:instances app))))
 app-state
 {:target (. js/document (getElementById "app"))})</pre></div><p class="calibre7">Our application state contains a single key, <code class="email">:instances</code>, which starts as an empty vector. As we can see from each Om component, instances will be rendered as rows in a HTML table.</p><p class="calibre7">After<a id="id460" class="calibre1"/> saving the file, make sure the web server is running by starting it from the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein repl</strong></span>
<span class="strong"><strong class="calibre2">Compiling ClojureScript.</strong></span>
<span class="strong"><strong class="calibre2">nREPL server started on port 58209 on host 127.0.0.1 - nrepl://127.0.0.1:58209</strong></span>
<span class="strong"><strong class="calibre2">REPL-y 0.3.5, nREPL 0.2.6</strong></span>
<span class="strong"><strong class="calibre2">Clojure 1.6.0</strong></span>
<span class="strong"><strong class="calibre2">Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17</strong></span>
<span class="strong"><strong class="calibre2">    Docs: (doc function-name-here)</strong></span>
<span class="strong"><strong class="calibre2">          (find-doc "part-of-name-here")</strong></span>
<span class="strong"><strong class="calibre2">  Source: (source function-name-here)</strong></span>
<span class="strong"><strong class="calibre2"> Javadoc: (javadoc java-object-or-class-here)</strong></span>
<span class="strong"><strong class="calibre2">    Exit: Control+D or (exit) or (quit)</strong></span>
<span class="strong"><strong class="calibre2"> Results: Stored in vars *1, *2, *3, an exception in *e</strong></span>


<span class="strong"><strong class="calibre2">user=&gt; (run)</strong></span>
<span class="strong"><strong class="calibre2">2015-02-08 21:02:34.503:INFO:oejs.Server:jetty-7.6.8.v20121106</strong></span>
<span class="strong"><strong class="calibre2">2015-02-08 21:02:34.545:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000</strong></span>
<span class="strong"><strong class="calibre2">#&lt;Server org.eclipse.jetty.server.Server@35bc3669&gt;</strong></span>
</pre></div><p class="calibre7">You should now be able point your browser to <code class="email">http://localhost:3000/</code>, but, as you might have guessed, you will see nothing but an empty table.</p><p class="calibre7">This is because we haven't yet used our Reactive AWS API.</p><p class="calibre7">Let's fix it and bring it all together at the bottom of <code class="email">core.cljs</code>:</p><div class="informalexample"><pre class="programlisting">(def resources (obs/stack-resources))

(.subscribe (-&gt; (.merge  (obs/rds-instance-status resources)
                         (obs/ec2-instance-status resources))
                (.reduce conj []))
            #(swap! app-state assoc :instances %))</pre></div><p class="calibre7">Yes, this is all we need! We create a <code class="email">stack-resources</code> Observable and pass it as an argument to both <code class="email">rds-instance-status</code> and <code class="email">ec2-instance-status</code>, which will concurrently retrieve status information about all instances.</p><p class="calibre7">Next, we create a new Observable by merging the previous two followed by a call to <code class="email">.reduce</code>, which will accumulate all information into a vector, convenient for rendering.</p><p class="calibre7">Finally, we simply subscribe to this Observable and, when it emits its results, we simply update <a id="id461" class="calibre1"/>our application state, leaving Om to do all the rendering for us.</p><p class="calibre7">Save the file and make sure ClojureScript has compiled successfully. Then, go back to your browser at <code class="email">http://localhost:3000/</code>, and you should see all instance statuses, as pictured at the beginning of this chapter.</p></div></div>
<div class="book" title="Exercises"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec61" class="calibre1"/>Exercises</h1></div></div></div><p class="calibre7">With our previous approach, the only way to see new information about the AWS resources is by refreshing the whole page. Modify our implementation in such a way that it queries the stub services every so often—say, every 500 milliseconds.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip35" class="calibre1"/>Tip</h3><p class="calibre7">The <code class="email">interval</code> function from RxJS can be helpful in solving this exercise. Think how you might use it together with our existing stream by reviewing how <code class="email">flatMap</code> works.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec62" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we looked at a real use case for Reactive applications: building a dashboard for AWS CloudFormation stacks.</p><p class="calibre7">We have seen how thinking of all the information needed as resources/items flowing through a graph fits nicely with how one creates Observables.</p><p class="calibre7">In addition, by creating primitive Observables that do one thing only gives us a nice declarative way to combine them into more complex Observables, giving us a degree of reuse not usually found with common techniques.</p><p class="calibre7">Finally, we packaged it together with a simple Om-based interface to demonstrate how using different abstractions in the same application does not add to complexity as long as the abstractions are chosen carefully for the problem at hand.</p><p class="calibre7">This brings us to the end of what hopefully was an enjoyable and informative journey through the different ways of Reactive Programming.</p><p class="calibre7">Far from being a complete reference, this book aims to provide you, the reader, with enough information, as well as concrete tools and examples that you can apply today.</p><p class="calibre7">It is also my hope that the references and exercises included in this book prove themselves useful, should you wish to expand your knowledge and seek out more details.</p><p class="calibre7">Lastly, I strongly encourage you to turn the page and read the <a class="calibre1" title="Appendix A. The Algebra of Library Design" href="part0070_split_000.html#page">Appendix </a>, <span class="strong"><em class="calibre8">The Algebra of Library Design</em></span>, as I truly believe it will, if nothing else, make you think hard about the importance of composition in programming.</p><p class="calibre7">I sincerely wish this book has been as entertaining and instructional to read as it was to write.</p><p class="calibre7">Thank you for reading. I look forward to seeing the great things you build.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Appendix&#xA0;A.&#xA0;The Algebra of Library Design"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="appA" class="calibre1"/>Appendix A. The Algebra of Library Design</h1></div></div></div><p class="calibre7">You might have noticed that all reactive abstractions we have encountered in this book have a few things in common. For one, they work as "container-like" abstractions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Futures encapsulate a computation that eventually yields a single value</li><li class="listitem">Observables encapsulate computations that can yield multiple values over time in the shape of a stream</li><li class="listitem">Channels encapsulate values pushed to them and can have them popped from it, working as a concurrent queue through which concurrent processes communicate</li></ul></div><p class="calibre7">Then, once we have this "container," we can operate on it in a number of ways, which are very similar across the different abstractions and frameworks: we can <code class="email">filter</code> the values contained in them, transform them using <code class="email">map</code>, combine abstractions of the same type using <code class="email">bind</code>/<code class="email">flatMap</code>/<code class="email">selectMany</code>, execute multiple computations in parallel, aggregate the results using <code class="email">sequence</code>, and much more.</p><p class="calibre7">As such, even though the abstractions and their underlying workings are fundamentally different, it still feels they belong to some type of higher-level abstractions.</p><p class="calibre7">In this appendix, we will explore what these higher-level abstractions are, the relationship between them, and how we can take advantage of them in our projects.</p></div>

<div class="book" title="Appendix&#xA0;A.&#xA0;The Algebra of Library Design">
<div class="book" title="The semantics of map"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec63" class="calibre1"/>The semantics of map</h1></div></div></div><p class="calibre7">We will get <a id="id462" class="calibre1"/>started by taking a look at one of the most used operations in these abstractions: <code class="email">map</code>.</p><p class="calibre7">We've been using <code class="email">map</code> for a long time in order to transform sequences. Thus, instead of creating a new function name for each new abstraction, library designers simply abstract the <code class="email">map</code> operation over its own container type.</p><p class="calibre7">Imagine the mess we would end up in if we had functions such as <code class="email">transform-observable</code>, <code class="email">transform-channel</code>, <code class="email">combine-futures</code>, and so on.</p><p class="calibre7">Thankfully, this is not the case. The semantics of <code class="email">map</code> are well understood to the point that even if a developer hasn't used a specific library before, he will almost always assume that <code class="email">map</code> will apply a function to the value(s) contained within whatever abstraction the library provides.</p><p class="calibre7">Let's look at three examples we encountered in this book. We will create a new leiningen project in which to experiment with the contents of this appendix:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ lein new library-design</strong></span>
</pre></div><p class="calibre7">Next, let's add a few dependencies to our <code class="email">project.clj</code> file:</p><div class="informalexample"><pre class="programlisting">...
:dependencies [[org.clojure/clojure "1.6.0"]
               [com.leonardoborges/imminent "0.1.0"]
               [com.netflix.rxjava/rxjava-clojure "0.20.7"]
               [org.clojure/core.async "0.1.346.0-17112a-alpha"]
               [uncomplicate/fluokitten "0.3.0"]]
...</pre></div><p class="calibre7">Don't worry about the last dependency—we'll get to it later on.</p><p class="calibre7">Now, start an REPL session so that we can follow along:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ lein repl</strong></span>
</pre></div><p class="calibre7">Then, enter the following into your REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">(require '[imminent.core :as i]</strong></span>
<span class="strong"><strong class="calibre2">         '[rx.lang.clojure.core :as rx]</strong></span>
<span class="strong"><strong class="calibre2">         '[clojure.core.async :as async])</strong></span>

<span class="strong"><strong class="calibre2">(def  repl-out *out*)</strong></span>
<span class="strong"><strong class="calibre2">(defn prn-to-repl [&amp; args]</strong></span>
<span class="strong"><strong class="calibre2">  (binding [*out* repl-out]</strong></span>
<span class="strong"><strong class="calibre2">    (apply prn args)))</strong></span>
<span class="strong"><strong class="calibre2">(-&gt; (i/const-future 31)</strong></span>
<span class="strong"><strong class="calibre2">    (i/map #(* % 2))</strong></span>
<span class="strong"><strong class="calibre2">    (i/on-success #(prn-to-repl (str "Value: " %))))</strong></span>


<span class="strong"><strong class="calibre2">(as-&gt; (rx/return 31) obs</strong></span>
<span class="strong"><strong class="calibre2">      (rx/map #(* % 2) obs)</strong></span>
<span class="strong"><strong class="calibre2">      (rx/subscribe obs #(prn-to-repl (str "Value: " %))))</strong></span>

<span class="strong"><strong class="calibre2">(def c        (chan))</strong></span>
<span class="strong"><strong class="calibre2">(def mapped-c (async/map&lt; #(* % 2) c))</strong></span>

<span class="strong"><strong class="calibre2">(async/go (async/&gt;! c 31))</strong></span>
<span class="strong"><strong class="calibre2">(async/go (prn-to-repl (str "Value: " (async/&lt;! mapped-c))))</strong></span>

<span class="strong"><strong class="calibre2">"Value: 62"</strong></span>
<span class="strong"><strong class="calibre2">"Value: 62"</strong></span>
<span class="strong"><strong class="calibre2">"Value: 62"</strong></span>
</pre></div><p class="calibre7">The three <a id="id463" class="calibre1"/>examples—using imminent, RxClojure, and core.async, respectively—look remarkably similar. They all follow a simple recipe:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Put the number 31 inside their respective abstraction.</li><li class="listitem" value="2">Double that number by mapping a function over the abstraction.</li><li class="listitem" value="3">Print its result to the REPL.</li></ol><div class="calibre13"/></div><p class="calibre7">As expected, this outputs the value <code class="email">62</code> three times to the screen.</p><p class="calibre7">It would seem <code class="email">map</code> performs the same abstract steps in all three cases: it applies the provided function, puts the resulting value in a fresh new container, and returns it. We could continue generalizing, but we would just be rediscovering an abstraction that already exists: Functors.</p></div></div>

<div class="book" title="Appendix&#xA0;A.&#xA0;The Algebra of Library Design">
<div class="book" title="The semantics of map">
<div class="book" title="Functors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec71" class="calibre1"/>Functors</h2></div></div></div><p class="calibre7">Functors <a id="id464" class="calibre1"/>are the first abstraction we will look at and they are rather simple: they<a id="id465" class="calibre1"/> define a single operation called <code class="email">fmap</code>. In Clojure, Functors can be represented using protocols and are used for containers that can be mapped over. Such containers include, but are not limited to, lists, Futures, Observables, and channels.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip36" class="calibre1"/>Tip</h3><p class="calibre7">The <span class="strong"><em class="calibre8">Algebra</em></span> in the title of this <span class="strong"><em class="calibre8">Appendix</em></span> refers to <span class="strong"><strong class="calibre2">Abstract Algebra</strong></span>, a branch of Mathematics that<a id="id466" class="calibre1"/> studies algebraic structures. An algebraic structure is, to put it simply, a set with one or more operations defined on it.</p><p class="calibre7">As an<a id="id467" class="calibre1"/> example, consider <span class="strong"><strong class="calibre2">Semigroups</strong></span>, which is one such algebraic structure. It is defined to be a set of elements together with an operation that combines any two elements of this set. Therefore, the set of positive integers together with the addition operation form a Semigroup.</p><p class="calibre7">Another tool used for studying algebraic structures is called Category Theory, of which Functors are part of.</p><p class="calibre7">We won't delve too much into the theory behind all this, as there are plenty of books [9][10] available on the subject. It was, however, a necessary detour to explain the title used in this appendix.</p></div><p class="calibre7">Does this mean<a id="id468" class="calibre1"/> all of these abstractions implement a Functor protocol? Unfortunately, this<a id="id469" class="calibre1"/> is not the case. As Clojure is a dynamic language and it didn't have protocols built in—they were added in version 1.2 of the language—these frameworks tend to implement their own version of the <code class="email">map</code> function, which doesn't belong to any protocol in particular.</p><p class="calibre7">The only exception is imminent, which implements the protocols included in <code class="email">fluokitten</code>, a Clojure library providing concepts from Category theory such as Functors.</p><p class="calibre7">This is a simplified version of the Functor protocol found in <code class="email">fluokitten</code>:</p><div class="informalexample"><pre class="programlisting">(defprotocol Functor
  (fmap [fv g]))</pre></div><p class="calibre7">As mentioned previously, Functors define a single operation. <code class="email">fmap</code> applies the function <code class="email">g</code> to whatever value is inside the container, Functor, <code class="email">fv</code>.</p><p class="calibre7">However, implementing this protocol does not guarantee that we have actually implemented a Functor. This is because, in addition to implementing the protocol, Functors are also required to obey a couple of laws, which we will examine briefly.</p><p class="calibre7">The identity law is as follows:</p><div class="informalexample"><pre class="programlisting">(= (fmap a-functor identity)
   (identity a-functor))</pre></div><p class="calibre7">The preceding code is all we need to verify this law. It simply says that mapping the <code class="email">identity</code> function over <code class="email">a-functor</code> is the same as simply applying the <code class="email">identity</code> function to the Functor itself.</p><p class="calibre7">The composition law is as follows:</p><div class="informalexample"><pre class="programlisting">(= (fmap a-functor (comp f g))
   (fmap (fmap a-functor g) f))</pre></div><p class="calibre7">The<a id="id470" class="calibre1"/> composition law, in turn, says that if we compose two arbitrary<a id="id471" class="calibre1"/> functions <code class="email">f</code> and <code class="email">g</code>, take the resulting function and apply that to <code class="email">a-functor</code>, that is the same as mapping <code class="email">g</code> over the Functor and then mapping <code class="email">f</code> over the resulting Functor.</p><p class="calibre7">No amount of text will be able to replace practical examples, so we will implement our own Functor, which we will call <code class="email">Option</code>. We will then revisit the laws to ensure we have respected them.</p></div></div></div>

<div class="book" title="Appendix&#xA0;A.&#xA0;The Algebra of Library Design">
<div class="book" title="The semantics of map">
<div class="book" title="The Option Functor"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec72" class="calibre1"/>The Option Functor</h2></div></div></div><p class="calibre7">As Tony Hoare once put it, null references are his one billion dollar mistake (<a class="calibre1" href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare</a>). Regardless of background, you no doubt will have encountered versions of the dreadful <code class="email">NullPointerException</code>. This usually happens when we try to call a method on an object reference that is <code class="email">null</code>.</p><p class="calibre7">Clojure <a id="id472" class="calibre1"/>embraces null values due to its interoperability with Java, its host<a id="id473" class="calibre1"/> language, but it provides improved support for dealing with them.</p><p class="calibre7">The core library is packed with functions that do the right thing if passed a nil value—Clojure's version of Java's <code class="email">null</code>. For instance, how many elements are there in a <code class="email">nil</code> sequence?</p><div class="informalexample"><pre class="programlisting">(count nil) ;; 0</pre></div><p class="calibre7">Thanks to conscious design decisions regarding <code class="email">nil</code>, we can, for the most part, afford not worry about it. For all other cases, the <code class="email">Option</code> Functor might be of some help.</p><p class="calibre7">The remaining of the examples in this appendix should be in a file called <code class="email">option.clj</code> under <code class="email">library-design/src/library_design/</code>. You're welcome to try this in the REPL as well.</p><p class="calibre7">Let's start our next example by adding the namespace declaration as well as the data we will be working with:</p><div class="informalexample"><pre class="programlisting">(ns library-design.option
  (:require [uncomplicate.fluokitten.protocols :as fkp]
            [uncomplicate.fluokitten.core :as fkc]
            [uncomplicate.fluokitten.jvm :as fkj]
            [imminent.core :as I]))

(def pirates [{:name "Jack Sparrow"    :born 1700 :died 1740 :ship "Black Pearl"}
              {:name "Blackbeard"      :born 1680 :died 1750 :ship "Queen Anne's Revenge"}
              {:name "Hector Barbossa" :born 1680 :died 1740 :ship nil}])

(defn pirate-by-name [name]
  (-&gt;&gt; pirates
       (filter #(= name (:name %)))
       first))

(defn age [{:keys [born died]}]
  (- died born))</pre></div><p class="calibre7">As a Pirates of the Caribbean fan, I thought it would be interesting to play with pirates for this example. Let's<a id="id474" class="calibre1"/> say we would like to calculate Jack Sparrow's age. Given<a id="id475" class="calibre1"/> the data and functions we just covered, this is a simple task:</p><div class="informalexample"><pre class="programlisting">  (-&gt; (pirate-by-name "Jack Sparrow")
      age) ;; 40</pre></div><p class="calibre7">However, what if we would like to know Davy Jones' age? We don't actually have any data for this pirate, so if we run our program again, this is what we'll get:</p><div class="informalexample"><pre class="programlisting">(-&gt; (pirate-by-name "Davy Jones")
      age) ;; NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)</pre></div><p class="calibre7">There it is. The dreadful <code class="email">NullPointerException</code>. This happens because in the implementation of the age function, we end up trying to subtract two <code class="email">nil</code> values, which is incorrect. As you might have guessed, we will attempt to fix this by using the <code class="email">Option</code> Functor.</p><p class="calibre7">Traditionally, <code class="email">Option</code> is implemented as an algebraic data type, more specifically a sum type with two variants: <code class="email">Some</code> and <code class="email">None</code>. These variants are used to identify whether a value is present or not without using <code class="email">nils</code>. You can think of both <code class="email">Some</code> and <code class="email">None</code> as subtypes of <code class="email">Option</code>.</p><p class="calibre7">In Clojure, we will represent them using records:</p><div class="informalexample"><pre class="programlisting">(defrecord Some [v])

(defrecord None [])

(defn option [v]
  (if v
    (Some. v)
    (None.)))</pre></div><p class="calibre7">As we can see, <code class="email">Some</code> can contain a single value whereas <code class="email">None</code> contains nothing. It's simply a<a id="id476" class="calibre1"/> marker indicating the absence of content. We have also created a <a id="id477" class="calibre1"/>helper function called <code class="email">option</code>, which creates the appropriate record depending on whether its argument is <code class="email">nil</code> or not.</p><p class="calibre7">The next step is to extend the <code class="email">Functor</code> protocol to both records:</p><div class="informalexample"><pre class="programlisting">(extend-protocol fkp/Functor
  Some
  (fmap [f g]
    (Some. (g (:v f))))
  None
  (fmap [_ _]
    (None.)))</pre></div><p class="calibre7">Here's where the semantic meaning of the <code class="email">Option</code> Functor becomes apparent: as <code class="email">Some</code> contains a value, its implementation of <code class="email">fmap</code> simply applies the function <code class="email">g</code> to the value inside the Functor <code class="email">f</code>, which is of type <code class="email">Some</code>. Finally, we put the result inside a new <code class="email">Some</code> record.</p><p class="calibre7">Now what does it mean to map a function over a <code class="email">None</code>? You probably guessed that it doesn't really make sense—the <code class="email">None</code> record holds no values. The only thing we can do is return another <code class="email">None</code>. As we will see shortly, this gives the <code class="email">Option</code> Functor a short-circuiting semantic.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip37" class="calibre1"/>Tip</h3><p class="calibre7">In the <code class="email">fmap</code> implementation of <code class="email">None</code>, we could have returned a reference to <code class="email">this</code> instead of a new record instance. I've not done so simply to make it clear that we need to return an instance of <code class="email">None</code>.</p></div><p class="calibre7">Now that we've implemented the Functor protocol, we can try it out:</p><div class="informalexample"><pre class="programlisting">(-&gt;&gt; (option (pirate-by-name "Jack Sparrow"))
     (fkc/fmap age)) ;; #library_design.option.Some{:v 40}

(-&gt;&gt; (option (pirate-by-name "Davy Jones"))
     (fkc/fmap age)) ;; #library_design.option.None{}</pre></div><p class="calibre7">The first example shouldn't hold any surprises. We convert the pirate map we get from calling <code class="email">pirate-by-name</code> into an option, and then <code class="email">fmap</code> the age function over it.</p><p class="calibre7">The second example is the interesting one. As stated previously, we have no data about Davy Jones. However, mapping <code class="email">age</code> over it does not throw an exception any longer, instead returning <code class="email">None</code>.</p><p class="calibre7">This might <a id="id478" class="calibre1"/>seem like a small benefit, but the bottom line is that the <code class="email">Option</code> Functor <a id="id479" class="calibre1"/>makes it safe to chain operations together:</p><div class="informalexample"><pre class="programlisting">(-&gt;&gt; (option (pirate-by-name "Jack Sparrow"))
     (fkc/fmap age)
     (fkc/fmap inc)
     (fkc/fmap #(* 2 %))) ;; #library_design.option.Some{:v 82}

(-&gt;&gt; (option (pirate-by-name "Davy Jones"))
     (fkc/fmap age)
     (fkc/fmap inc)
     (fkc/fmap #(* 2 %))) ;; #library_design.option.None{}</pre></div><p class="calibre7">At this point, some readers might be thinking about the <code class="email">some-&gt;</code> macro—introduced in Clojure 1.5—and how it effectively achieves the same result as the <code class="email">Option</code> Functor. This intuition is correct as demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">(some-&gt; (pirate-by-name "Davy Jones")
        age
        inc
        (* 2)) ;; nil</pre></div><p class="calibre7">The <code class="email">some-&gt;</code> macro threads the result of the first expression through the first form if it is not <code class="email">nil</code>. Then, if the result of that expression isn't <code class="email">nil</code>, it threads it through the next form and so on. As soon as any of the expressions evaluates to nil, <code class="email">some-&gt;</code> short-circuits and returns nil immediately.</p><p class="calibre7">That being said, Functor is a much more general concept, so as long as we are working with this concept, our code doesn't need to change as we are operating at a higher level of abstraction:</p><div class="informalexample"><pre class="programlisting">(-&gt;&gt; (i/future (pirate-by-name "Jack Sparrow"))
     (fkc/fmap age)
     (fkc/fmap inc)
     (fkc/fmap #(* 2 %))) ;; #&lt;Future@30518bfc: #&lt;Success@39bd662c: 82&gt;&gt;</pre></div><p class="calibre7">In the preceding example, even though we are working with a fundamentally different tool—futures—the code using the result did not have to change. This is only possible because both Options and futures are Functors and implement the same protocol provided by fluokitten. We have gained composability and simplicity as we can use the same API to work with various different abstractions.</p><p class="calibre7">Speaking of composability, this property is guaranteed by the second law of Functors. Let's see if our Option Functor respects this and the first—the identity—laws:</p><div class="informalexample"><pre class="programlisting">;; Identity
(= (fkc/fmap identity (option 1))
   (identity (option 1))) ;; true


;; Composition
(= (fkc/fmap (comp identity inc) (option 1))
   (fkc/fmap identity (fkc/fmap inc (option 1)))) ;; true</pre></div><p class="calibre7">And we're <a id="id480" class="calibre1"/>done, our <code class="email">Option</code> Functor is a lawful citizen. The remaining <a id="id481" class="calibre1"/>two abstractions also come paired with their own laws. We will not cover the laws in this section, but I encourage the reader to read about them (<a class="calibre1" href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/</a>).</p></div></div></div>
<div class="book" title="Finding the average of ages"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec64" class="calibre1"/>Finding the average of ages</h1></div></div></div><p class="calibre7">In this section, we will explore a different use case for the <code class="email">Option</code> Functor. We would like to, given a <a id="id482" class="calibre1"/>number of pirates, calculate the average of their ages. This is simple enough to do:</p><div class="informalexample"><pre class="programlisting">(defn avg [&amp; xs]
  (float (/ (apply + xs) (count xs))))

(let [a (some-&gt; (pirate-by-name "Jack Sparrow") age)
      b (some-&gt; (pirate-by-name "Blackbeard") age)
      c (some-&gt; (pirate-by-name "Hector Barbossa") age)]
  (avg a b c)) ;; 56.666668</pre></div><p class="calibre7">Note how we are using <code class="email">some-&gt;</code> here to protect us from <code class="email">nil</code> values. Now, what happens if there is a pirate for which we have no information?</p><div class="informalexample"><pre class="programlisting">(let [a (some-&gt; (pirate-by-name "Jack Sparrow") age)
      b (some-&gt; (pirate-by-name "Davy Jones") age)
      c (some-&gt; (pirate-by-name "Hector Barbossa") age)]
  (avg a b c)) ;; NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)</pre></div><p class="calibre7">It seems we're back at square one! It's worse now because using <code class="email">some-&gt;</code> doesn't help if we need to use all values at once, as opposed to threading them through a chain of function calls.</p><p class="calibre7">Of course, not all is lost. All we need to do is check if all values are present before calculating the average:</p><div class="informalexample"><pre class="programlisting">(let [a (some-&gt; (pirate-by-name "Jack Sparrow") age)
      b (some-&gt; (pirate-by-name "Davy Jones") age)
      c (some-&gt; (pirate-by-name "Hector Barbossa") age)]
  (when (and a b c)
    (avg a b c))) ;; nil</pre></div><p class="calibre7">While this works <a id="id483" class="calibre1"/>perfectly fine, our implementation suddenly had to become aware that any or all of the values <code class="email">a</code>, <code class="email">b</code>, and <code class="email">c</code> could be <code class="email">nil</code>. The next abstraction we will look at, Applicative Functors, fixes this.</p></div>
<div class="book" title="Applicative Functors"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec65" class="calibre1"/>Applicative Functors</h1></div></div></div><p class="calibre7">Like Functors, <span class="strong"><strong class="calibre2">Applicative Functors</strong></span> are <a id="id484" class="calibre1"/>a sort of container and<a id="id485" class="calibre1"/> defines two operations:</p><div class="informalexample"><pre class="programlisting">(defprotocol Applicative
  (pure [av v])
  (fapply [ag av]))</pre></div><p class="calibre7">The <code class="email">pure</code> function<a id="id486" class="calibre1"/> is a generic way to put a value inside an Applicative Functor. So far, we have been using the <code class="email">option</code> helper function for this purpose. We will be using it a little later.</p><p class="calibre7">The <code class="email">fapply</code> function<a id="id487" class="calibre1"/> will unwrap the function contained in the Applicative <code class="email">ag</code> and apply it to the value contained in the applicative <code class="email">av</code>.</p><p class="calibre7">The purpose of both the functions will become clear with an example, but first, we need to promote our <code class="email">Option</code> Functor into an Applicative Functor:</p><div class="informalexample"><pre class="programlisting">(extend-protocol fkp/Applicative
  Some
  (pure [_ v]
    (Some. v))

  (fapply [ag av]
    (if-let [v (:v av)]
      (Some. ((:v ag) v))
      (None.)))

  None
  (pure [_ v]
    (Some. v))

  (fapply [ag av]
    (None.)))</pre></div><p class="calibre7">The implementation of <code class="email">pure</code> is the simplest. All it does is wrap the value <code class="email">v</code> into an instance of <code class="email">Some</code>. Equally simple is the implementation of <code class="email">fapply</code> for <code class="email">None</code>. As there is no value, we simply return <code class="email">None</code> again.</p><p class="calibre7">The <code class="email">fapply</code> implementation of <code class="email">Some</code> ensures both arguments have a value for the <code class="email">:v</code> keyword—strictly <a id="id488" class="calibre1"/>speaking they both have to be instances of <code class="email">Some</code>. If <code class="email">:v</code> is non-nil, it applies the function contained in <code class="email">ag</code> to <code class="email">v</code>, finally wrapping the<a id="id489" class="calibre1"/> result. Otherwise, it returns <code class="email">None</code>.</p><p class="calibre7">This should be enough to try our first example using the Applicative Functor API:</p><div class="informalexample"><pre class="programlisting">(fkc/fapply (option inc) (option 2))
;; #library_design.option.Some{:v 3}

(fkc/fapply (option nil) (option 2))
;; #library_design.option.None{}</pre></div><p class="calibre7">We are now able to work with Functors that contain functions. Additionally, we have also preserved the semantics of what should happen when any of the Functors don't have a value.</p><p class="calibre7">We can now revisit the age average example from before:</p><div class="informalexample"><pre class="programlisting">(def age-option (comp (partial fkc/fmap age) option pirate-by-name))

(let [a (age-option "Jack Sparrow")
      b (age-option "Blackbeard")
      c (age-option "Hector Barbossa")]
  (fkc/&lt;*&gt; (option (fkj/curry avg 3))
           a b c))
;; #library_design.option.Some{:v 56.666668}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip38" class="calibre1"/>Tip</h3><p class="calibre7">The <a id="id490" class="calibre1"/>
<code class="email">vararg</code> function <code class="email">&lt;*&gt;</code> is defined by fluokitten and performs a left-associative <code class="email">fapply</code> on its arguments. Essentially, it is a convenience function that makes <code class="email">(&lt;*&gt; f g h)</code> equivalent to <code class="email">(fapply (fapply f g) h)</code>.</p></div><p class="calibre7">We start by defining a helper function to avoid repetition. The <code class="email">age-option</code> function retrieves the age of a pirate as an option for us.</p><p class="calibre7">Next, we curry the <code class="email">avg</code> function to <code class="email">3</code> arguments and put it into an option. Then, we use the <code class="email">&lt;*&gt;</code> function to apply it to the options a, b, and c. We get to the same result, but have the Applicative Functor take care of nil values for us.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip39" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre2">Function currying</strong></span>
</p><p class="calibre7">Currying is <a id="id491" class="calibre1"/>the technique of transforming a function of multiple arguments into a higher-order function of a single argument that returns more single-argument functions until all arguments have been supplied.</p><p class="calibre7">Roughly speaking, currying makes the following snippets equivalent:</p><div class="informalexample"><pre class="programlisting">(def curried-1 (fkj/curry + 2))
(def curried-2 (fn [a]
                 (fn [b]
                   (+ a b))))

((curried-1 10) 20) ;; 30
((curried-2 10) 20) ;; 30</pre></div></div><p class="calibre7">Using <a id="id492" class="calibre1"/>Applicative Functors this way is so common that the <a id="id493" class="calibre1"/>pattern has been captured as the function <code class="email">alift</code>, as shown in the following:</p><div class="informalexample"><pre class="programlisting"> (defn alift
  "Lifts a n-ary function `f` into a applicative context"
  [f]
  (fn [&amp; as]
    {:pre  [(seq as)]}
    (let [curried (fkj/curry f (count as))]
      (apply fkc/&lt;*&gt;
             (fkc/fmap curried (first as))
             (rest as)))))</pre></div><p class="calibre7">The <code class="email">alift</code> function is responsible for lifting a function in such a way that it can be used with Applicative Functors without much ceremony. Because of the assumptions we are able to make about Applicative Functors—for instance, that it is also a Functor—we can write generic code that can be re-used across any Applicatives.</p><p class="calibre7">With <code class="email">alift</code> in place, our age average example turns into the following:</p><div class="informalexample"><pre class="programlisting">(let [a (age-option "Jack Sparrow")
      b (age-option "Blackbeard")
      c (age-option "Hector Barbossa")]
  ((alift avg) a b c))
;; #library_design.option.Some{:v 56.666668}</pre></div><p class="calibre7">We lift <code class="email">avg</code> into an Applicative compatible version, making the code look remarkably like simple function application. And since we are not doing anything interesting with the let bindings, we can simplify it further as follows:</p><div class="informalexample"><pre class="programlisting">((alift avg) (age-option "Jack Sparrow")
             (age-option "Blackbeard")
             (age-option "Hector Barbossa"))
;; #library_design.option.Some{:v 56.666668}

((alift avg) (age-option "Jack Sparrow")
             (age-option "Davy Jones")
             (age-option "Hector Barbossa"))
;; #library_design.option.None{}</pre></div><p class="calibre7">As with <a id="id494" class="calibre1"/>Functors, we can take the code as it is, and simply <a id="id495" class="calibre1"/>replace the underlying abstraction, preventing repetition once again:</p><div class="informalexample"><pre class="programlisting">((alift avg) (i/future (some-&gt; (pirate-by-name "Jack Sparrow") age))
             (i/future (some-&gt; (pirate-by-name "Blackbeard") age))
             (i/future (some-&gt; (pirate-by-name "Hector Barbossa") age)))
;; #&lt;Future@17b1be96: #&lt;Success@16577601: 56.666668&gt;&gt;</pre></div></div>
<div class="book" title="Gathering stats about ages"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec66" class="calibre1"/>Gathering stats about ages</h1></div></div></div><p class="calibre7">Now that we can safely calculate the average age of a number of pirates, it might be interesting to take this further and calculate the median and standard deviation of the pirates' ages, in addition to their average age.</p><p class="calibre7">We <a id="id496" class="calibre1"/>already have a function to calculate the average, so let's just create the ones to calculate the median and the standard deviation of a list of numbers:</p><div class="informalexample"><pre class="programlisting">(defn median [&amp; ns]
  (let [ns (sort ns)
        cnt (count ns)
        mid (bit-shift-right cnt 1)]
    (if (odd? cnt)
      (nth ns mid)
      (/ (+ (nth ns mid) (nth ns (dec mid))) 2))))

(defn std-dev [&amp; samples]
  (let [n (count samples)
	mean (/ (reduce + samples) n)
	intermediate (map #(Math/pow (- %1 mean) 2) samples)]
    (Math/sqrt
     (/ (reduce + intermediate) n))))</pre></div><p class="calibre7">With these functions in place, we can write the code that will gather all the stats for us:</p><div class="informalexample"><pre class="programlisting">  (let  [a       (some-&gt; (pirate-by-name "Jack Sparrow")    age)
         b       (some-&gt; (pirate-by-name "Blackbeard")      age)
         c       (some-&gt; (pirate-by-name "Hector Barbossa") age)
         avg     (avg a b c)
         median  (median a b c)
         std-dev (std-dev a b c)]
    {:avg avg
     :median median
     :std-dev std-dev})

  ;; {:avg 56.666668,
  ;;  :median 60,
  ;;  :std-dev 12.472191289246473}</pre></div><p class="calibre7">This implementation is fairly straightforward. We first retrieve all ages we're interested in and bind <a id="id497" class="calibre1"/>them to the locals <code class="email">a</code>, <code class="email">b</code>, and <code class="email">c</code>. We then reuse the values when calculating the remaining stats. We finally gather all results in a map for easy access.</p><p class="calibre7">By now the reader will probably know where we're headed: what if any of those values is <code class="email">nil</code>?</p><div class="informalexample"><pre class="programlisting">  (let  [a       (some-&gt; (pirate-by-name "Jack Sparrow")    age)
         b       (some-&gt; (pirate-by-name "Davy Jones")      age)
         c       (some-&gt; (pirate-by-name "Hector Barbossa") age)
         avg     (avg a b c)
         median  (median a b c)
         std-dev (std-dev a b c)]
    {:avg avg
     :median median
     :std-dev std-dev})
  ;; NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)</pre></div><p class="calibre7">The second binding, <code class="email">b</code>, returns <code class="email">nil</code>, as we don't have any information about Davy Jones. As such, it causes the calculations to fail. Like before, we can change our implementation to protect us from such failures:</p><div class="informalexample"><pre class="programlisting">  (let  [a       (some-&gt; (pirate-by-name "Jack Sparrow")    age)
         b       (some-&gt; (pirate-by-name "Davy Jones")      age)
         c       (some-&gt; (pirate-by-name "Hector Barbossa") age)
         avg     (when (and a b c) (avg a b c))
         median  (when (and a b c) (median a b c))
         std-dev (when (and a b c) (std-dev a b c))]
    (when (and a b c)
      {:avg avg
       :median median
       :std-dev std-dev}))
  ;; nil</pre></div><p class="calibre7">This<a id="id498" class="calibre1"/> time it's even worse than when we only had to calculate the average; the code is checking for <code class="email">nil</code> values in four extra spots: before calling the three stats functions and just before gathering the stats into the result map.</p><p class="calibre7">Can we do better?</p></div>
<div class="book" title="Monads"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec67" class="calibre1"/>Monads</h1></div></div></div><p class="calibre7">Our last abstraction will solve the very problem we raised in the previous section: how to safely perform intermediate calculations by preserving the semantics of the abstractions we're working with—in this case, options.</p><p class="calibre7">It should be no surprise now that fluokitten also provides a protocol for Monads, simplified and shown as follows:</p><div class="informalexample"><pre class="programlisting">(defprotocol Monad
  (bind [mv g]))</pre></div><p class="calibre7">If you think in <a id="id499" class="calibre1"/>terms of a class hierarchy, Monads would be at the bottom of it, inheriting from Applicative Functors, which, in turn, inherit from Functors. That is, if you're working with a Monad, you can assume it is also an Applicative and a Functor.</p><p class="calibre7">The <code class="email">bind</code> function<a id="id500" class="calibre1"/> of monads takes a function <code class="email">g</code> as its second argument. This function receives as input the value contained in <code class="email">mv</code> and returns another Monad containing its result. This is a crucial part of the contract: <code class="email">g</code> has to return a Monad.</p><p class="calibre7">The reason why will become clearer after some examples. But first, let's promote our Option abstraction to a Monad—at this point, Option is already an Applicative Functor and a Functor:</p><div class="informalexample"><pre class="programlisting">(extend-protocol fkp/Monad
  Some
  (bind [mv g]
    (g (:v mv)))

  None
  (bind [_ _]
    (None.)))</pre></div><p class="calibre7">The implementation is fairly simple. In the <code class="email">None</code> version, we can't really do anything, so just like we have been doing so far, we return an instance of <code class="email">None</code>.</p><p class="calibre7">The <code class="email">Some</code> implementation extracts the value from the Monad <code class="email">mv</code> and applies the function <code class="email">g</code> to it. Note how this time we don't need to wrap the result as the function <code class="email">g</code> already returns a Monad instance.</p><p class="calibre7">Using the<a id="id501" class="calibre1"/> Monad API, we could sum the ages of our pirates as follows:</p><div class="informalexample"><pre class="programlisting">(def opt-ctx (None.))

(fkc/bind (age-option "Jack Sparrow")
          (fn [a]
            (fkc/bind (age-option "Blackbeard")
                      (fn [b]
                        (fkc/bind (age-option "Hector Barbossa")
                                  (fn [c]
                                    (fkc/pure opt-ctx 
                                              (+ a b c))))))))
;; #library_design.option.Some{:v 170.0}</pre></div><p class="calibre7">Firstly, we are making use of Applicative's <code class="email">pure</code> function in the inner-most function. Remember that role of <code class="email">pure</code> is to provide a generic way to put a value into an Applicative Functor. Since Monads are also Applicative, we make use of them here.</p><p class="calibre7">However, since Clojure is a dynamically typed language, we need to hint pure with the context—container—type we wish to use. This context is simply an instance of either <code class="email">Some</code> or <code class="email">None</code>. They both have the same pure implementation.</p><p class="calibre7">While we do get the right answer, the preceding example is far from what we would like to write due to its excessive nesting. It is also hard to read.</p><p class="calibre7">Thankfully, fluokitten provides a much better way to write monadic code, called the do-notation:</p><div class="informalexample"><pre class="programlisting">(fkc/mdo [a (age-option "Jack Sparrow")
          b (age-option "Blackbeard")
          c (age-option "Hector Barbossa")]
         (fkc/pure opt-ctx  (+ a b c)))
;; #library_design.option.Some{:v 170.0}</pre></div><p class="calibre7">Suddenly, the same code becomes a lot cleaner and easier to read, without losing any of the semantics of the Option Monad. This is because <code class="email">mdo</code> is a macro that expands to the code equivalent of the nested version, as we can verify by expanding the macro as follows:</p><div class="informalexample"><pre class="programlisting">(require '[clojure.walk :as w])

(w/macroexpand-all '(fkc/mdo [a (age-option "Jack Sparrow")
                              b (age-option "Blackbeard")
                              c (age-option "Hector Barbossa")]
                             (option  (+ a b c))))
;; (uncomplicate.fluokitten.core/bind
;;  (age-option "Jack Sparrow")
;;  (fn*
;;   ([a]
;;    (uncomplicate.fluokitten.core/bind
;;     (age-option "Blackbeard")
;;     (fn*
;;      ([b]
;;       (uncomplicate.fluokitten.core/bind
;;        (age-option "Hector Barbossa")
;;        (fn* ([c] (fkc/pure opt-ctx (+ a b c)))))))))))</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip40" class="calibre1"/>Tip</h3><p class="calibre7">It is important to stop for a moment here and appreciate the power of Clojure—and Lisp in general.</p><p class="calibre7">Languages such as <a id="id502" class="calibre1"/>Haskell and Scala, which make heavy use of abstractions <a id="id503" class="calibre1"/>such as Functors, Applicative, and Monads, also have their own versions of the do-notation. However, this support is baked into the compiler itself.</p><p class="calibre7">As an example, when Haskell added do-notation to the language, a new version of the compiler was released, and developers wishing to use the new feature had to upgrade.</p><p class="calibre7">In Clojure, on the other hand, this new feature can be shipped as a library due to the power and flexibility of macros. This is exactly what fluokitten has done.</p></div><p class="calibre7">Now, we are <a id="id504" class="calibre1"/>ready to go back to our original problem, gathering stats about the pirates' ages.</p><p class="calibre7">First, we will define a couple of helper functions that convert the result of our stats functions into the Option Monad:</p><div class="informalexample"><pre class="programlisting">(def avg-opt     (comp option avg))
(def median-opt  (comp option median))
(def std-dev-opt (comp option std-dev))</pre></div><p class="calibre7">Here, we take advantage of function composition to create monadic versions of existing functions.</p><p class="calibre7">Next, we will rewrite our solution using the monadic do-notation we learned earlier:</p><div class="informalexample"><pre class="programlisting">(fkc/mdo [a       (age-option "Jack Sparrow")
          b       (age-option "Blackbeard")
          c       (age-option "Hector Barbossa")
          avg     (avg-opt a b c)
          median  (median-opt a b c)
          std-dev (std-dev-opt a b c)]
         (option {:avg avg
                  :median median
                  :std-dev std-dev}))
;; #library_design.option.Some{:v {:avg 56.666668,
;;                                 :median 60,
;;                                 :std-dev 12.472191289246473}}</pre></div><p class="calibre7">This time we<a id="id505" class="calibre1"/> were able to write the function as we normally would, without having to worry about whether any values in the intermediate computations are empty or not. This semantic that is the very essence of the Option Monad is still preserved, as can be seen in the following:</p><div class="informalexample"><pre class="programlisting">(fkc/mdo [a       (age-option "Jack Sparrow")
          b       (age-option "Blackbeard")
          c       (age-option "Hector Barbossa")
          avg     (avg-opt a b c)
          median  (median-opt a b c)
          std-dev (std-dev-opt a b c)]
         (fkc/pure opt-ctx {:avg avg
                  :median median
                  :std-dev std-dev}))
;; #library_design.option.None{}</pre></div><p class="calibre7">For the sake of completeness, we will use futures to demonstrate how the do-notation works for any Monad:</p><div class="informalexample"><pre class="programlisting">(def avg-fut     (comp i/future-call avg))
(def median-fut  (comp i/future-call median))
(def std-dev-fut (comp i/future-call std-dev))

(fkc/mdo [a       (i/future (some-&gt; (pirate-by-name "Jack Sparrow") age))
          b       (i/future (some-&gt; (pirate-by-name "Blackbeard") age))
          c       (i/future (some-&gt; (pirate-by-name "Hector Barbossa") age))
          avg     (avg-fut a b c)
          median  (median-fut a b c)
          std-dev (std-dev-fut a b c)]
         (i/const-future {:avg avg
                          :median median
                          :std-dev std-dev}))
;; #&lt;Future@3fd0b0d0: #&lt;Success@1e08486b: {:avg 56.666668,
;;                                         :median 60,
;;                                         :std-dev 12.472191289246473}&gt;&gt;</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec68" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This appendix has taken us on a brief tour of the world of category theory. We learned three of its abstractions: Functors, Applicative Functors, and Monads. They were the guiding principle behind imminent's API.</p><p class="calibre7">To deepen our knowledge and understanding, we implemented our own Option Monad, a common abstraction used to safely handle the absence of values.</p><p class="calibre7">We have also seen that using these abstractions allow us to make some assumptions about our code, as seen in functions such as <code class="email">alift</code>. There are many other functions we would normally rewrite over and over again for different purposes, but that can be reused if we recognize our code fits into one of the abstractions learned.</p><p class="calibre7">Finally, I hope this encourages readers to explore category theory more, as it will undoubtedly change the way you think. And if I can be so bold, I hope this will also change the way you design libraries in the future.</p></div>
<div class="book" title="Appendix&#xA0;B.&#xA0;Bibliography"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="appB" class="calibre1"/>Appendix B. Bibliography</h1></div></div></div><p class="calibre7">[1] Rene Pardo and Remy Landau, <span class="strong"><em class="calibre8">The World's First Electronic Spreadsheet</em></span>: <a class="calibre1" href="http://www.renepardo.com/articles/spreadsheet.pdf">http://www.renepardo.com/articles/spreadsheet.pdf</a>
</p><p class="calibre7">[2] Conal Elliott and Paul Hudak, <span class="strong"><em class="calibre8">Functional Reactive Animation</em></span>: <a class="calibre1" href="http://conal.net/papers/icfp97/icfp97.pdf">http://conal.net/papers/icfp97/icfp97.pdf</a>
</p><p class="calibre7">[3] Evan Czaplicki, <span class="strong"><em class="calibre8">Elm: Concurrent FRP for Functional GUIs</em></span>: <a class="calibre1" href="http://elm-lang.org/papers/concurrent-frp.pdf">http://elm-lang.org/papers/concurrent-frp.pdf</a>
</p><p class="calibre7">[4] Erik Meijer, <span class="strong"><em class="calibre8">Subject/Observer is Dual to Iterator</em></span>: <a class="calibre1" href="http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf">http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf</a>
</p><p class="calibre7">[5] Henrik Nilsson, Antony Courtney and John Peterson, <span class="strong"><em class="calibre8">Functional Reactive Programming, Continued</em></span>: <a class="calibre1" href="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf</a>
</p><p class="calibre7">[6] John Hughes, <span class="strong"><em class="calibre8">Generalising Monads to Arrows</em></span>: <a class="calibre1" href="http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf">http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf</a>
</p><p class="calibre7">[7] Zhanyong Wan, Walid Taha and Paul Hudak, <span class="strong"><em class="calibre8">Real-Time FRP</em></span>: <a class="calibre1" href="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf</a>
</p><p class="calibre7">[8] Walid Taha, Zhanyong Wan, and Paul Hudak, <span class="strong"><em class="calibre8">Event-Driven FRP</em></span>: <a class="calibre1" href="http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf">http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf</a>
</p><p class="calibre7">[9] Benjamin C. Pierce, <span class="strong"><em class="calibre8">Basic Category Theory for Computer Scientists</em></span>: <a class="calibre1" href="http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&amp;qid=1423484917&amp;sr=8-7&amp;keywords=category+theory">http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&amp;qid=1423484917&amp;sr=8-7&amp;keywords=category+theory</a>
</p><p class="calibre7">[10] Steve Awodey, <span class="strong"><em class="calibre8">Category Theory (Oxford Logic Guides)</em></span>: <a class="calibre1" href="http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&amp;qid=1423484917&amp;sr=8-2&amp;keywords=category+theory">http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&amp;qid=1423484917&amp;sr=8-2&amp;keywords=category+theory</a>
</p><p class="calibre7">[11] Duncan Coutts, Roman Leshchinskiy, and Don Stewart, <span class="strong"><em class="calibre8">Stream Fusion</em></span>: <a class="calibre1" href="http://code.haskell.org/~dons/papers/icfp088-coutts.pdf">http://code.haskell.org/~dons/papers/icfp088-coutts.pdf</a>
</p><p class="calibre7">[12] Philip Wadler, <span class="strong"><em class="calibre8">Transforming programs to eliminate trees</em></span>: <a class="calibre1" href="http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps">http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps</a>
</p></div></body></html>