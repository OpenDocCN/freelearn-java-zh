- en: Making Our Game Professional - Do it as a Webapp
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will program a web application. We will build on what we
    have achieved already and create a web version of the Mastermind game. This time,
    it will not only run alone, guessing and answering the number of positions and
    matched colors, but also communicate with the user asking for the answers to the
    guesses. This will be a real game. Web programming is extremely important for
    Java programmers. Most of the programs are web applications. The universal client
    available on the Internet is the web browser. The thin-client, web browser-based
    architecture is widely accepted in enterprises as well. There are only some exceptions
    when the architecture has something else but the web client. If you want to become
    a professional Java developer, you must be familiar with web programming. And
    it is also fun!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of technical topics that we will visit during the development.
    First of all, we will discuss networking and web architecture. This is the concrete
    base of the whole building. It is not too sexy, just like when you construct the
    building. You spend a lot of money and effort digging trenches, and then you bury
    the concrete and end up at the end of the phase with what you seemingly had before:
    flat ground. Except that there is the base. Building without this base, the house
    would either collapse soon after or during the process of building. Networking
    is just as important for web programming. There are a lot of topics that seemingly
    have nothing to do with programming. Still, it is the base of the building and
    when you program web applications, you will also find the fun part in it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will also talk a bit about HTML, CSS, and JavaScript, but not too much. We
    cannot avoid them because they are also important for web programming, but they
    are topics that you can learn from somewhere else as well. In case you are not
    an expert in some of these areas, there are usually other experts in enterprise
    project teams who can extend your knowledge. (In the case of networking, there
    is no mercy.) In addition to that, JavaScript is a topic so complex and huge that
    it deserves a whole book to start with it. There are only very few experts who
    deeply understand both Java and JavaScript. I understand the general structure
    of the language and the environment it runs in, but I cannot keep up with the
    new frameworks that are released every week these days, having my focus on other
    areas.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to create Java applications that run in an application server,
    this time in Jetty, and we will see what a servlet is. We will create a web *hello
    world* application to start up fast, and then we will create the servlet version
    of Mastermind. Note that we hardly ever program servlets directly without the
    aid of some framework that implements the code to handle parameters, authentication,
    and many other things that are not application-specific. We will still stick to
    a naked servlet in this chapter because it is not possible to effectively use
    frameworks, such as Spring, without first understanding what a servlet is. Spring
    will come in the next chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We will mention **Java Server Pages** (**JSP**) only because you may meet some
    legacy application, which was developed using that technology, but modern web
    applications do not use JSP. Still, JSP is a part of the servlet standard and
    is available for use. There are other technologies that were developed in the
    recent past but do not seem to be future-proof these days. They are still usable
    but appear only in legacy applications, and choosing them for a new project is
    fairly questionable. We will talk about these technologies shortly in a separate
    section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how the basic web technology
    works and what the major architectural elements are, and you will be able to create
    simple web applications. This is not enough to be a professional Java web developer
    but will be a good grounding for the next chapter, where we will have a look at
    the professional frameworks used in today's enterprises for real application developments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Web and network
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs run on computers, and computers are connected to the Internet. This
    network was developed in the last 60 years, first to provide military data communication
    that is resilient to rocket attack, then it was extended to be an academic network,
    and later it became a commercial network used by anyone and available almost ubiquitously
    all over the Earth.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The design of the network, and the research, started as a response to the flight
    of Gagarin over the Earth in the fifties. Sending Gagarin to space and travelling
    over the Earth was a demonstration that Russia could send a rocket anywhere on
    the globe, possibly with atomic explosives. It meant that any data network that
    needed some central control was not resilient to such an attack. It was not feasible
    to have a network with a central location as a single point of failure. Therefore,
    research was started to create a network that goes on working even if any part
    of it is brought down.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: IP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network delivers data packets between any two computers connected to it.
    The protocol used on the network is IP, which is simply an abbreviation of Internet
    Protocol. Using IP, a computer can send a data packet to another. The package
    contains a header and the data content. The header contains the Internet addresses
    of the sender and the target machine, other flags, and information about the package.
    Since the machines are not connected to each other directly, routers forward the
    packets. It is like post offices sending mails to each other till it gets into
    the hands of the postman you know, who can directly deliver it to your mailbox.
    To do that, the routers use the information in the header. The algorithm and organization
    of how the routers interact are complex and something we need not know to be Java
    professionals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: If you ever need to program in order to send IP packets directly, you should
    look at `java.net.DatagramPacket`, and the rest is implemented in the JDK, the
    operating system, and on the firmware of the network card. You can create a data
    packet; sending it and changing the modulated voltage on the network card or emitting
    photons to the fiber is not your headache. However, you will all know whether
    you really need to program datagrams directly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: IP has two versions. The old version still in use is IPv4\. The new version
    that coexists with the old one is IPv6 or IPng (*ng* stands for *new generation*).
    The major difference that may concern a Java developer is that version 4 uses
    32-bit addresses and version 6 uses 128-bit addresses. When you see a version-4
    address, you will see something like `192.168.1.110`, whichÂ contains the four
    bytes in a decimal format separated by dots. IPv6 addresses are expressed as `2001:db8:0:0:0:0:2:1`,
    as eight 16-bit numbers expressed in hexadecimal separated by colons.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The Web is a bit more complex than sending data packets. If sending a data packet
    is like sending a one-page letter, then a web page download is like discussing
    a contract in paper mail. There should be an agreement in the initial paper mail
    as to what to send, what to answer, and so on, until the contract is signed. On
    the Internet, that protocol is called **Transmission Control Protocol** (**TCP**).
    While it is highly unlikely (but possible) that you will meet IP routing issues,
    being a Java developer, you certainly may meet TCP programming. Therefore, we
    will cover shortly how the TCP works. Be aware that this is very brief. Really.
    You will not become a TCP expert reading the next section, but you will get a
    glimpse of the most important issues that affect web programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP protocol is implemented in the operating system and provides a higher
    level of interface than IP. When you program TCP, you do not deal with datagrams.
    Instead, you have a channel of byte streams where you can put bytes to be delivered
    to the other computer, and you can read bytes from the channel that were sent
    by the other computer, exactly in the order as they were sent. This is a kind
    of connection between two computers and, what's more, between two programs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: There are other protocols that are implemented over IP and which are not connection-oriented.
    One of them is **User Datagram Protocol** (**UDP**), used for services when there
    is no need for connections, when the data may be lost and it is more important
    that the data gets to the destination in a timely manner than losing some of the
    packets (video streaming, telephony). When the data amount is small and in case
    it is not delivered, it can be requested again; the cost of losing it is cheap
    (DNS request, see the next section).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: When a packet is lost on the network, or when it is sent twice, or when it is
    delivered sooner than a later package, it is handled by the TCP software layer
    implemented by the operating system. This layer is also popularly called the **TCP
    stack**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the TCP is a connected protocol, there is a need for something that tells
    the TCP stack which stream a datagram belongs to when it arrives. The stream is
    identified by two ports. A port is a 16-bit integer. One identifies the program
    that initiates the connection, called the source port. The other one identifies
    the target program: the destination port. These are contained in each and every
    TCP packet delivered. When a machine runs a **Secure Shell** (**SSH**) server
    and a web server, they use different ports, usually port 22 and 80\. When a package
    comes that contains the destination portÂ number 22 in the TCP header, the TCP
    stack knows that the data in the packet belongs to the stream handled by the SSH
    server. Likewise, if the destination port is 80, then the data goes to the web
    server.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: When we program a server, we usually have to define the port number; otherwise,
    there is no way the clients will find the server program. Web servers are usually
    listen on port 80, and clients try to connect to that port. The client port is
    usually not important and not specified; it is allocated by the TCP stack automatically.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect from a client code to a server is easy: only a few lines of code.
    Sometimes, it is only one line of code. However, under the hood, there is a lot
    of work that the TCP stack does that we should care aboutâit takes time to build
    up a TCP connection.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: To have a connection, the TCP stack has to send a datagram to the destination
    to know that it exists. If there is no server listening on the port, sending the
    data over the network has no result, except for wasting the network bandwidth.
    For this reason, the client first sends an empty data packet called SYN. When
    the other side receives it, it sends back a similar package called SYN-ACK. Finally,
    the client sends a package called ACK. If the packets go through the Atlantic,
    this is approximately 45ms for each package, which is equivalent to 45 million
    seconds in bureaucrat time. This is almost one and a half years. We need three
    of those to set up the connection, and there is more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäºå»ºç«è¿æ¥ï¼TCPå æ å¿é¡»åç®çå°åéä¸ä¸ªæ°æ®æ¥ä»¥ç¡®è®¤å¶å­å¨ãå¦ææ²¡ææå¡å¨å¨ç«¯å£ä¸çå¬ï¼éè¿ç½ç»åéæ°æ®å°æ²¡æä»»ä½ç»æï¼é¤äºæµªè´¹ç½ç»å¸¦å®½ãå æ­¤ï¼å®¢æ·ç«¯é¦ååéä¸ä¸ªåä¸ºSYNçç©ºæ°æ®åãå½å¦ä¸ç«¯æ¶å°å®æ¶ï¼å®ä¼åéä¸ä¸ªç±»ä¼¼çåï¼ç§°ä¸ºSYN-ACKãæåï¼å®¢æ·ç«¯åéä¸ä¸ªåä¸ºACKçåãå¦ææ°æ®åç©¿è¶å¤§è¥¿æ´ï¼æ¯ä¸ªåå¤§çº¦éè¦45msï¼è¿å¨å®åæ¶é´ä¸­ç¸å½äº4500ä¸ç§ãè¿å ä¹æ¯1å¹´åçæ¶é´ãæä»¬éè¦ä¸ä¸ªè¿æ ·çæ°æ®åæ¥å»ºç«è¿æ¥ï¼èä¸è¿ææ´å¤ã
- en: 'When a TCP connection starts, the client does not start to send the data without
    control. It sends some data packets and then it waits for the server to acknowledge
    their receipt. It would not only be useless, but also network wasting, to send
    data that the server is not prepared to accept and has to throw away. The TCP
    is designed to optimize the network usage. Therefore, the client sends some data,
    and then it waits for the acknowledgement. The TCP stack automatically manages
    this. If the acknowledgement arrives, it sends more packets, and if a carefully
    designed optimization algorithm, implemented in the TCP stack, believes that it
    is good to send more, it will send a bit more data than in the first step. If
    there are negative acknowledgements telling the client that the server could not
    accept some of the data and had to throw it away, then the client will lower the
    number of packets it sends without acknowledgement. But first it starts slow and
    cautious. This is called TCP slow start and we have to be aware of it. Although
    it is a low level networking feature it has consequences that we have to consider
    in our Java code: we use database connection pools instead of creating a new connection
    to the database each time there is a need for some data; we try to manage to have
    as few connections to web servers as possible using techniques such as *keep-alive*,
    *SPDY* protocol, or *http/2.0* (also replacing SPDY).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å½ä¸ä¸ªTCPè¿æ¥å¼å§æ¶ï¼å®¢æ·ç«¯å¨æ²¡ææ§å¶çæåµä¸ä¸ä¼å¼å§åéæ°æ®ãå®ä¼åéä¸äºæ°æ®åï¼ç¶åç­å¾æå¡å¨ç¡®è®¤å®ä»¬çæ¥æ¶ãå¦æåéæå¡å¨å°æªåå¤æ¥åçæ°æ®ï¼é£ä¹åéè¿äºæ°æ®ä¸ä»æ¯«æ ç¨å¤ï¼èä¸è¿ä¼é æç½ç»èµæºçæµªè´¹ãTCPè¢«è®¾è®¡ç¨æ¥ä¼åç½ç»ä½¿ç¨ãå æ­¤ï¼å®¢æ·ç«¯åéä¸äºæ°æ®åï¼å®ä¼ç­å¾ç¡®è®¤ãTCPå æ ä¼èªå¨ç®¡çè¿ä¸ªè¿ç¨ãå¦ææ¶å°ç¡®è®¤ï¼å®ä¼åéæ´å¤çæ°æ®åãå¦æTCPå æ ä¸­å®ç°çä¸ä¸ªç²¾å¿è®¾è®¡çä¼åç®æ³è®¤ä¸ºåéæ´å¤æ°æ®æ¯åéçï¼å®å°åéæ¯ç¬¬ä¸æ­¥æ´å¤çæ°æ®ãå¦ææè´ç¡®è®¤åè¯å®¢æ·ç«¯æå¡å¨æ æ³æ¥åæäºæ°æ®å¹¶ä¸å¾ä¸ä¸¢å¼å®ä»¬ï¼é£ä¹å®¢æ·ç«¯å°åå°æªç¡®è®¤åéçæ°æ®åæ°éãä½é¦åå®ä¼å¼å§å¾æ¢èè°¨æãè¿è¢«ç§°ä¸ºTCPæ¢å¯å¨ï¼æä»¬å¿é¡»å¯¹æ­¤ææäºè§£ãå°½ç®¡è¿æ¯ä¸ä¸ªä½çº§ç½ç»ç¹æ§ï¼ä½å®å¯¹æä»¬çJavaä»£ç æå½±åï¼æä»¬å¿é¡»èèï¼æä»¬ä½¿ç¨æ°æ®åºè¿æ¥æ± èä¸æ¯æ¯æ¬¡éè¦æ°æ®æ¶é½åå»ºæ°çæ°æ®åºè¿æ¥ï¼æä»¬å°è¯éè¿ä½¿ç¨è¯¸å¦*keep-alive*ã*SPDY*åè®®æ*http/2.0*ï¼ä¹åä»£äºSPDYï¼ç­ææ¯æ¥å°½éåå°ä¸Webæå¡å¨çè¿æ¥æ°ã
- en: For a start, it is enough that TCP is connection-oriented where you build up
    a connection to a server, send and receive bytes, and finally close the connection.
    When you have a network performance problem, you have to look at the issues I
    listed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: é¦åï¼åªè¦TCPæ¯é¢åè¿æ¥çï¼ä½ å°±å¯ä»¥å»ºç«ä¸ä¸ªä¸æå¡å¨çè¿æ¥ï¼åéåæ¥æ¶å­èï¼æåå³é­è¿æ¥ãå½ä½ éå°ç½ç»æ§è½é®é¢æ¶ï¼ä½ å¿é¡»æ¥çæååºçé£äºé®é¢ã
- en: DNS
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS
- en: The TCP protocol creates a channel using the IP addresses of machines. When
    you type a URL in the browser, it usually does not contain IP numbers. It contains
    machine names. The name is converted to IP numbers using a distributed database
    called **Domain Name System** (**DNS**). This database is distributed, and when
    a program needs to convert a name to an address, it sends DNS request to one of
    the DNS servers it knows. These servers query each other or tell the client whom
    to ask, until the client knows the IP address assigned to the name. The servers
    and the client also cache the recently requested names, so answering is fast.
    On the other hand, when the IP address of a server changes this name, not all
    clients will immediately see the address assignment over the globe. The DNS lookup
    can be easily programmed, and there are classes and methods in JDK that support
    this, but usually we need not care about that; when we program, it is done automatically
    in web programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Hypertext Transport Protocol** (**HTTP**) is built on top of the TCP.
    When you type a URL in a browser, the browser opens a TCP channel to the server
    (after DNS lookup, of course) and sends a HTTP request to the web server. The
    server, after receiving the request, produces a response and sends it to the client.
    After that, the TCP channel may be closed or kept alive for further HTTP request-response
    pairs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Both the request and the response contain a header and an optional (possibly
    zero-length) body. The header is in the text format, and it is separated from
    the body by an empty line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: More precisely the header and the body are separated by four bytes:Â `0x0D`,
    `0x0A`, `0x0D`, andÂ `0x0A`, whichÂ are two `CR`, `LF` line separators. The HTTP
    protocol uses carriage return and line feed to terminate lines in the header,
    and thus, an empty line is two `CRLF` following each other.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The start of the header is a status line plus header fields. The following
    is a sample HTTP request:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the response:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The request does not contain a body. The status line is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It contains the so-called method of the request, the object that is requested,
    and the protocol version used by the request. The rest of the request of the header
    contains header fields that have the format, `label : value`. Some of the lines
    are wrapped in the printed version, but there is no line break in a header line.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The response specifies the protocol it uses (usually the same as the request),
    the status code, and the message format of the status:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After this, the response fields come with the same syntax as in the request.
    One important header is the content type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It specifies that the response body (truncated in the printout) is HTML text.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual request was sent to the URL, [https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230),
    which is the standard that defines the 1.1 version of HTTP. You can easily look
    into the communication yourself, starting up the browser and opening the developer
    tools. Such a tool is built into every browser these days. You can use it to debug
    the program behavior on the network application level looking at the actual HTTP
    requests and responses on the byte level. The following screenshot shows how the
    developer tool shows this communication:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: å®éè¯·æ±è¢«åéå°äºURLï¼[https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230)ï¼è¿æ¯å®ä¹HTTP
    1.1çæ¬çè§èãä½ å¯ä»¥è½»æ¾å°èªå·±æ¥çéä¿¡ï¼å¯å¨æµè§å¨å¹¶æå¼å¼åèå·¥å·ãå¦ä»ï¼è¿æ ·çå·¥å·å·²ç»åç½®å¨æ¯ä¸ä¸ªæµè§å¨ä¸­ãä½ å¯ä»¥ç¨å®æ¥å¨ç½ç»åºç¨ç¨åºçº§å«è°è¯ç¨åºè¡ä¸ºï¼æ¥çå®éçHTTPè¯·æ±åååºçå­èçº§ä¿¡æ¯ãä»¥ä¸æªå¾æ¾ç¤ºäºå¼åèå·¥å·å¦ä½æ¾ç¤ºè¿ç§éä¿¡ï¼
- en: '![](img/00045.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: HTTP methods
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPæ¹æ³
- en: The method that is the first word in the status line of the request tells the
    server what to do with the request. The standard defines different methods, such
    as `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, and some others.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ±ç¶æè¡ä¸­çç¬¬ä¸ä¸ªåè¯æè¡¨ç¤ºçæ¹æ³åè¯æå¡å¨å¦ä½å¤çè¯¥è¯·æ±ãæ åå®ä¹äºä¸åçæ¹æ³ï¼ä¾å¦`GET`ã`HEAD`ã`POST`ã`PUT`ã`DELETE`ä»¥åä¸äºå¶ä»æ¹æ³ã
- en: The client uses the `GET` method when it wants to get the content of a resource.
    In the case of a `GET` request, the body of the request is empty. This is the
    method used by the browser when we download a web page. It is also, many times,
    the method used when some program implemented in JavaScript and running in the
    browser asks for some information from a web application, but it does not want
    to send much information to the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å½å®¢æ·ç«¯æ³è¦è·åèµæºçå å®¹æ¶ï¼å®ä¼ä½¿ç¨`GET`æ¹æ³ãå¨`GET`è¯·æ±çæåµä¸ï¼è¯·æ±ä½æ¯ç©ºçãè¿æ¯æµè§å¨å¨æä»¬ä¸è½½ç½é¡µæ¶ä½¿ç¨çæ¹æ³ãå®ä¹æ¯ï¼å¾å¤æ¶åï¼å½å¨æµè§å¨ä¸­è¿è¡çJavaScriptç¨åºè¯·æ±ä¸äºä¿¡æ¯æ¶ä½¿ç¨çæ¹æ³ï¼ä½å®ä¸æ³åæå¡å¨åéå¤ªå¤ä¿¡æ¯ã
- en: When the client uses `POST`, the intention is usually to send some data to the
    server. The server does reply and, many times, there is also a body in the reply,
    but the main purpose of the request/reply communication is to send some information
    from the client to the server. This is the opposite of the `GET` method in some
    sense.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å½å®¢æ·ç«¯ä½¿ç¨`POST`æ¶ï¼éå¸¸çæå¾æ¯åæå¡å¨åéä¸äºæ°æ®ãæå¡å¨ç¡®å®ä¼åå¤ï¼å¾å¤æ¶åï¼åå¤ä¸­ä¹æä¸ä¸ªä½ï¼ä½è¯·æ±/åå¤éä¿¡çä¸»è¦ç®çæ¯ä»å®¢æ·ç«¯åæå¡å¨åéä¸äºä¿¡æ¯ãè¿å¨æç§ç¨åº¦ä¸ä¸`GET`æ¹æ³ç¸åã
- en: The `GET` and `POST` methods are the most frequently used methods. Although
    there is a general guideline to use `GET` to retrieve data and `POST` to send
    data to the server, it is only a recommendation, and there is no clean separation
    of the two cases. Many times, `GET` is used to send some data to the server. After
    all, it is an HTTP request with a status line and header fields, and although
    there is no body in the request, the object (part of the URL) that follows the
    method in the status line is still able to deliver parameters. Many times, it
    is also easy to test a service that responds to a `GET` request because you only
    need a browser and to type in the URL with the parameters, and look at the response
    in the browser developer tools. You should not be surprised if you see an application
    that uses `GET` requests to execute operations that modify the state on a web
    server. However, not being surprised does not mean approval. You should be aware
    that in most cases, these are not good practices. When we send sensitive information
    using the `GET` request, the parameters in the URL are available to the client
    in the address line of the browser. When we send using `POST`, the parameters
    are still reachable by the client (after all, the information the client sends
    is generated by the client and, as such, cannot be unavailable), but not that
    easy for a simple security-unaware user to copy-paste the information and send,
    perhaps, to a malevolent third party. The decision between using `GET` and `POST`
    should always consider practicalities and security issues.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The `HEAD` method is identical to a `GET` request, but the response will not
    contain a body. This is used when the client is not interested in the actual response.
    It may happen that the client already has the object and wants to see if it was
    changed. The `Last-Modified` header will contain the time when the resource was
    last changed, and the client can decide if it has a newer one or needs to ask
    for the resource in a new request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The `PUT` method is used when the client wants to store something on the server
    and `DELETE` when the client wants to erase some resource. These methods are used
    only by applications usually written in JavaScript and not directly by the browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: There are other methods defined in the standard, but these are the most important
    and frequently used ones.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Status codes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The response starts with the status code. These codes are also defined and there
    are a limited number of codes usable in a response. The most important is `200`,
    which says all is OK; the response contains what the request wanted. The codes
    are always in the range of `100` to `599`, contain three digits, and are grouped
    by the first digit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`1xx`: These codes are information codes. They are rarely used but can be very
    important in some cases. For example, `100` means continue. A server can send
    this code when it gets a `POST` request and the server wants to signal the client
    to send the body of the request because it can process it. Using this code, and
    the client waiting for this code, may save a lot of bandwidth if properly implemented
    on the server and also on the client.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2xx`: These codes mean success. The request is answered properly, or the requested
    service was done. There are codes, such as `200`, `201`, `202`, and so on, defined
    in the standard and there is a description about when to use one or the other.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3xx`: These codes mean redirection. One of these codes is sent when the server
    cannot directly service the request but knows the URL that can. The actual codes
    can distinguish between a permanent redirect (when it is known that all future
    requests should be sent to the new URL) and temporary redirect (when any later
    request should be sent here and possibly served or redirected), but the decision
    is kept on the server side.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4xx`: These are error codes. The most famous code is `404`, which means Not
    Found, that is, the server is not able to respond to the request because the resource
    is not found. `401` means that the resource to serve the request may be available
    but it requires authentication. `403` is a code that signals that the request
    was valid but is still refused to be served by the server.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5xx`: These codes are server error codes. When a response holds one of these
    error codes, the meaning is that there is some error on the server. This error
    can be temporary, for example, when the server is processing too many requests
    and cannot respond to a new request with a calculation-intensive response (this
    is usually signaled by error code `503`) or when the feature is not implemented
    (code `501`). The general error code `500` is interpreted as Internal Error, which
    means that no information, whatsoever, is available about what was going wrong
    on the server, but it was not going well and hence, no meaningful response.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2.0
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After almost 20 years since the last release of HTTP, the new version of HTTP
    was released in 2015\. This new version of the protocol has several enhancements
    over the previous versions. Some of these enhancements will also affect the way
    server applications will be developed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The first and most important enhancement is that the new protocol will make
    it possible to send several resources parallelly in a single TCP connection. The
    keep-alive flag is available to avoid the recreation of the TCP channel, but it
    does not help when a response is created slowly. In the new protocol, other resources
    can also be delivered in the same TCP channel even before one request is fully
    served. This requires complex package handling in the protocol, but this is hidden
    from the server application programmer as well as the browser programmer. The
    application server, servlet container, and browser implement this transparently.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2.0 will always be encrypted, therefore it will not be possible to use
    `http` as a protocol in the browser URL. It will always be `https`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The feature that will need changes in servlet programming to leverage the advantages
    of the new version of the protocol is server push. Version 4.0 of the servlet
    specification includes support for HTTP/2.0, and this version is still in draft.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Server push is an HTTP response to a request that will come in the future. How
    can a server answer a request that is not even issued? Well, the server anticipates.
    For example, the application sends an HTML page that has references to many small
    pictures and icons. The client downloads the HTML page, builds the DOM structure,
    analyzes it, and realizes that the pictures are needed, and sends the request
    for the pictures. The application programmer knows what pictures are there and
    may code the server to send the pictures even before the browser requests for
    it. Every such response includes a URL that this response is for. When the browser
    wants the resource, it realizes that it is already there and does not issue a
    new request. In `HttpServlet`, the program should access `PushBuilder` via the
    request's new `getPushBuilder` method and use that to push down resources to the
    client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are maintained by the browser and are sent in the HTTP request header
    using the `Cookie` header field. Each cookie has a name, value, domain, path,
    expiration time, and some other parameters. When a request is sent to a URL that
    matches the domain, the path of a non-expired cookie, the client sends the cookie
    to the server. Cookies are usually stored in small files on the client by the
    browser or in a local database. The actual implementation is the business of the
    browser, and we need not worry about it. It is just the text information that
    is not executed by the client. It is only sent back to the server when some rules
    (mainly domain and path) match. Cookies are created by servers and are sent to
    the client in HTTP responses using the `Set-Cookie` header field. Thus, essentially
    the server tells the client, Hey, here is this cookie, whenever you come to me
    next time, show me this piece of information, so I will know it is you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are usually to remember clients. Advertisers and online shops that need
    to remember who they are talking to heavily use it. But this is not the only use.
    These days, any application that maintains user sessions uses cookies to chain
    up the HTTP requests that come from the same user. When you log in to an application,
    the username and password you use to identify yourself are sent to the server
    only once, and in subsequent requests, only a special cookie is sent to the server
    used to identify the already logged in user. This use of cookies emphasizes why
    it is important to use cookie values that cannot be easily guessed. If the cookie
    used to identify a user is easily guessable, then an attacker could just create
    a cookie and send it to the server mimicking the other user. Cookie values, for
    the purpose, are usually long random strings.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are not always sent back to the server where they originate. When the
    cookie is set, the server specifies the domain of the URL where the cookie should
    be sent back. This is used when a different server from the one providing the
    services needing authentication does the user authentication.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Applications sometimes encode values into cookies. This is not necessarily bad,
    though in most actual cases, it is. When encoding something into a cookie, we
    should always consider the fact that the cookie travels through the network and
    can go huge as more and more data is encoded in it and can create unnecessary
    burden on the network. Usually, it is better to send only some unique, otherwise
    meaningless, random key, and store the values in some database, be it on disk
    or in the memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Client server and web architecture
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The applications we developed so far were running on a single JVM. We already
    have some experience with concurrent programming and this is something that will
    come handy now. When we program a web application, a part of the code will run
    on the server and a part of the application logic will execute in the browser.
    The server part will be written in Java, the browser part will be implemented
    in HTML, CSS, and JavaScript. Since this is a Java book we will focus mainly on
    the server part, but we should still be aware of the fact that many of the functionalities
    can be and should be implemented to run in the browser. The two programs communicate
    with each other over the IP network, that is, the Internet, or in the case of
    an enterprise internal application, the network of the company.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Today, a browser is capable of running very powerful applications, all implemented
    in JavaScript. A few years ago, such applications needed client application implemented
    in Delphi, C++, or Java, using the windowing capabilities of the client operating
    system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Originally, the client-server architecture meant that the functionality of the
    application was implemented on the client, and the program was using general services
    only from the server. The server provided database access and file storage but
    nothing more. Later, the three-tier architecture put the business functionality
    on the servers that used other servers for database and other general services,
    and the client application implemented the user interface and limited business
    functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: When the web technology started to penetrate enterprise computing, the web browser
    started to replace the client applications in many use cases. Previously, the
    browser could not run complex JavaScript applications. The application was executed
    on the web server and the client displayed the HTML that the server created as
    a part of the application logic. Every time something was changed on the user
    interface, the browser started a communication with the server, and in a HTTP
    request-response pair, the browser content was replaced. A web application was
    essentially a series of form filling and form data sending to the server, and
    the server responded with HTML-formatted pages, presumably containing new forms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interpreters were developed and became more and more effective and
    standardized. Today, modern web applications contain HTML (which is a part of
    the client code and is not generated by the server on the fly), CSS, and JavaScript.
    When the code is downloaded from the web server, the JavaScript starts to execute
    and communicate with the server. It is still HTTP requests and responses, but
    the responses do not contain HTML code. It contains pure data, usually in the
    JSON format. This data is used by the JavaScript code and some of the data, if
    needed, is displayed on the web browser display also controlled by JavaScript.
    This is functionally equivalent to a three-tier architecture with some slight
    but very important differences.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is that the code is not installed on the client. The client
    downloads the application from a web server, and the only thing that is installed
    is the modern browser. This removes a lot of enterprise maintenance burden and
    cost.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is that the client is not able, or is limited, to access
    the resources of the client machine. Thick client applications could save anything
    in a local file or access a local database. This is very limited, for security
    reasons, compared to a program running on the browser. At the same time this is
    a handy limitation because clients aren't and shouldn't be a trusted part of the
    architecture. The disk in the client computer is hard and expensive to back up.
    It can be stolen with a notebook, and encrypting it is costly. There are tools
    to protect client storage, but most of the time, storing the data on the server
    only is a more viable solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: It is also a common program design error to trust the client application. The
    client physically controls the client computer and although it can be made technically
    very difficult, the client can still overcome the security limitations of the
    client device and client code. If it is only the client application that checks
    the validity of some functionality or data, then the physical security provided
    by the physical control of the server is not used. Whenever data is sent from
    the client to the server, the data has to be checked in regards of validity, no
    matter what the client application is. Actually, since the client application
    can be changed, we just don't really know what the client application really is.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter and, as a matter of fact, in the entire book, we focus on Java
    technologies; therefore the sample application will not contain almost any client
    technology. I could not help but create some CSS. On the other hand, I definitely
    avoided JavaScript. Therefore, I have to emphasize again that the example is to
    demonstrate the programming of the server side and still providing something that
    really works. A modern application would use REST and JSON communications and
    would not play around creating HTML on the fly on the server side. Originally,
    I wanted to create a JavaScript client and REST server application, but the focus
    was moved so much from server-side Java programming that I dropped this idea.
    On the other hand, you can extend the application to be one like that.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Writing servlets
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servlets are Java classes that areÂ executed in a web server that implements
    the servlet container environment. The first web servers could only deliver static
    HTML files to the browsers. For each URL, there was an HTML page on the web server
    and the server delivered the content of this file, in response to a request sent
    by the browser. Very soon, there was a need to extend the web servers to be able
    to start some program that calculates the content of the response, on the fly,
    when the request is processed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The first standard to do that defined CGI. It started a new process to respond
    to a request. The new process got the request on its standard input, and the standard
    output was sent back to the client. This approach wastes a lot of resources. Starting
    a new process, as you learned in the previous chapter, is way too costly just
    to respond to an HTTP request. Even starting a new thread seems to be unnecessary,
    but with that, we ran a bit ahead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The next approach was FastCGI, executing the external process continually and
    reusing it, and then came different other approaches. The approaches after
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: FastCGIall use in-process extensions. In these cases, the code calculating the
    response runs inside the same process as the web server. Such standards or extension
    interfaces were ISAPI for the Microsoft IIS server, NSASPI for the Netscape server,
    and the Apache module interface. Each of these made it possible to create a **dynamically
    loaded library** (**DLL** on Windows or SO files on Unix systems) to be loaded
    by the web server during
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: startupand to map certain requests to be handled by the code implemented in
    these libraries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: When somebody programs PHP, for example, the Apache module extension is the
    PHP interpreter that reads the PHP code and acts upon it. When somebody programs
    ASP pages for the Microsoft IIS, the ISAPI extension implementing the ASP page
    interpreter is executed (well, this is a bit sloppy and oversimplified to say
    but works as an example).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: To Java, the interface definition is a servlet defined in JSR340 as of version
    3.1.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: JSR stands for Java Specification Request. These are requests for modification
    of the Java language, library interfaces, and other components. The requests go
    through an evaluation process, and when they are accepted, they become a standard.
    The process is defined by the Java Community Process (JCP). JCP is also documented
    and has versions. The current version is 2.10 and can be found at [https://jcp.org/en/procedures/overview](https://jcp.org/en/procedures/overview).
    The JSR340 standard can be found at [https://jcp.org/en/jsr/detail?id=340](https://jcp.org/en/jsr/detail?id=340).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: A servlet program implements the servlet interface. Usually this is done via
    extending `HttpServlet`, the abstract implementation of the `Servlet` interface.
    This abstract class implements methods, such as `doGet`, `doPost`, `doPut`, `doDelete`,
    `doHead`, `doOption`, and `doTrace`, free to be overridden by the actual class
    extending it. If a servlet class does not override one of the these methods, sending
    the corresponding HTTP method, `GET`, `POST`, and so on, will return the `405``Not
    Allowed` status code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Hello world servlet
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting into the technical details, let''s create an extremely simple
    *hello world* servlet. To do it, we setup a Gradle project with the build file,
    `build.gradle`, the servlet class in the file, `src/main/java/packt/java9/by/example/mastermind/servlet/HelloWorld.java`,
    and last but not least, we have to create the file `src/main/webapp/WEB-INF/web.xml`.
    The `gradle.build` file will look the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Gradle build file uses two plugins, `java` and `jetty`. We have already
    used the `java` plugin in the previous chapter. The `jetty` plugin adds tasks
    such as `jettyRun` that load the Jetty servlet container and start up the application.
    The `jetty` plugin is also an extension of the `war` plugin that compiles web
    applications into a **Web Archive** (**WAR**`)` packaging format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The WAR packaging format is practically the same as JAR; it is a zip file and
    it contains a `lib` directory that contains all the JAR files that the web application
    depends on. The classes of the application are in the directory, `WEB-INF/classes`,
    and there is a `WEB-INF/web.xml` file that describes servlet URL mapping, which
    we will explore in detail soon.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to develop an extremely simple servlet, we add the servlet API
    as a dependency to the project. This is, however, not a compile dependency. The
    API is available when the servlet runs in the container. Still, it has to be available
    when the compiler compiles our code; therefore, a *dummy* implementation is provided
    by the artifact specified as `providedCompile`. Because it is specified that way,
    the build process will not package the library into the generated WAR file. The
    generated file will contain nothing that is specific to Jetty or any other servlet
    container.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The servlet container will provide the actual implementation of the servlet
    library. When the application is deployed and started in a Jetty, the Jetty-specific
    implementation of the servlet library will be available on the classpath. When
    the application is deployed to a Tomcat, the Tomcat specific implementation will
    be available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a class in our project, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the servlet is started, the `init` method is invoked. When it is put out
    of service, the `destroy` method is called. These methods can be overridden and
    provide a more fine-grained control than the constructor and other finalization
    possibilities. A servlet object may be put into service more than once, and after
    calling `destroy`, the servlet container may invoke `init` again; thus, this cycle
    is not strictly tied to the life cycle of the object. Usually, there is not much
    that we do in these methods, but sometimes, you may need some code in them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that a single servlet object may be used to serve many requests,
    even at the same time; thus, the servlet classes and methods in it should be fairly
    thread-safe. The specification demands that a servlet container uses only one
    servlet instance in case the container runs in a non-distributed environment.
    In case the container runs on the same machine in several processes, each executing
    a JVM, or even on different machines, there can be many servlet instances that
    handle the requests. Generally, the servlet classes should be designed such that
    they do not assume that only one thread is executing them, but at the same time,
    they should also not assume that the instance is the same for different requests.
    We just cannot know.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean in practice? You should not use instance fields that are specific
    to a certain request. In the example, the field initialized to hold the message
    holds the same value for each and every request; essentially, the variable is
    almost a final constant. It is used only to demonstrate some functionality for
    the `init` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `doGet` method is invoked when the servlet container gets an HTTP request
    with the `GET` method. The method has two arguments. The first one represents
    the request, and the second one represents the response. The `request` can be
    used to collect all information that comes in the request. In the preceding example,
    there is nothing like that. We do not use any of the inputs. If a request comes
    to our servlet, then we answer the `Hello, World` string, no matter what. Later,
    we will see examples when we read the parameters from the request. The `response`
    gives methods that can be used to handle the output. In the example, we fetch
    `PrintWriter`, which is to be used to send characters to the body of the HTTP
    response. This is the content that appears in the browser. The mime type we send
    is `text/html`, and this is set by calling the `setContentType` method. This will
    get into the HTTP header field, `Content-Type`. The standard and the JavaDoc documentation
    of the classes define all the methods that can be used, and also how these should
    be used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a `web.xml` file that declares the servlets that are implemented
    in our code. This is, just as the name of the file indicates, an XML file. It
    declaratively defines all the servlets that are included in the archive and also
    other parameters. In the example, the parameters are not defined, only the servlet
    and the mapping to the URL. Since we have only one single servlet in this example,
    the WAR file, it is mapped to the root context. All and every `GET` request that
    arrives to the servlet container and to this archive will be served by this servlet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Java Server Pages
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I promised you that I would not bore you with Java Server Pages because that
    is a technology of the past. Even though it is the past, it is still not history
    as there are many programs running that still use JSP and contain JSP code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: JSP pages are web pages that contain HTML and Java code mixed. When an HTTP
    request is served by a JSP page, the servlet container reads the JSP page, executes
    the Java parts, takes the HTML parts as they are, and in this way, mixing the
    two together, creates an HTML page that is sent to the browser.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding page will create an HTML page that contains the text `hallo` five
    times, each in a new line separated by the tag `br`. Behind the scenes, the servlet
    container converts the JSP page to a Java servlet, then compiles the servlet using
    the Java compiler, and then runs the servlet. It does it every time there is some
    change in the source JSP file; therefore, it is very easy to incrementally craft
    some simple code using JSP. The code that is generated from the preceding JSP
    file is 138 lines long (on the Tomcat 8.5.5 version), which is simply long and
    boring to list here, but the part that may help to understand how the Java file
    generation works is only a few lines.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see all the lines of the generated servlet class, you can deploy
    the application into a Tomcat server and look at the directory `work/Catalina/localhost/hello/org/apache/jsp/`.
    It is a rarely known fact among developers that this code is actually saved to
    disk and is available. Sometimes it helps when you need to debug some JSP pages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the few interesting lines generated from the preceding code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The JSP compiler moves the inside of the JSP code out and the outside in. In
    the JSP code, Java is surrounded by HTML, and in the generated servlet Java source,
    the HTML is surrounded by Java. It is like when you want to mend clothes: the
    first thing is to turn the dress inside out.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not only the Java code that you can mix into HTML in the JSP pages but
    also the so-called tags. Tags are collected into tag libraries, implemented in
    Java, and packaged into JAR files, and they should be available on the classpath
    to be used. The JSP page using the tags from some library should declare the use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The tags look like HTML tags, but they are processed by the JSP compiler and
    executed by the code implemented in the `taglib` library. JSP may also refer to
    the value of the Java objects that are available in the scope of the JSP. To do
    this inside the HTML page, the JSP expression language could be used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'JSP was originally created to ease the development of a web application. The
    main advantage is the fast startup of development. There is no lengthy time for
    configuration, setup, and so on in the development, and when there is any change
    in the JSP page, there is no need to compile the whole application again: the
    servlet container generates the Java code, compiles it to class file, loads the
    code into memory, and executes. JSP was a competitor of Microsoft ASP pages, which
    mixed HTML with VisualBasic code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: When the application starts to grow big, using the JSP technology causes more
    problems than are good. The code that mixes the business logic and the view of
    the application, how it is rendered in the browser, becomes messy. Developing
    JSP requires frontend technology knowledge. A Java developer is expected to know
    some frontend technology but is rarely a design expert and CSS guru. Modern code
    also contains JavaScript, many times embedded in the HTML page. After all, the
    big advantage of JSP is that it contains code that runs on the server as well
    as on the client-side code. The developers follow the paradigm many times, so
    do not be surprised to see some legacy code that contains Java, HTML, CSS, and
    JavaScript all mixed in a JSP file. Since Java and JavaScript are syntactically
    similar sometimes, it is not obvious to see what is executed on the server and
    what is executed on the client. I have even seen code that created JavaScript
    code from Java code in a JSP file. That is a total mix of different responsibilities
    and a mess that is nearly impossible to maintain. This led to the total deprecation
    of JSP as of today.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The deprecation of JSP is not official. It is my expert opinion. You may meet
    some experienced developers who are still in love with JSP, and you may find yourself
    in projects where you are required to develop programs in JSP. It is not shameful
    doing that. Some people do worse for money.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: To mend the messy situation, there were technologies that advocated the separation
    of the server code and the client functionality more and more. These technologies
    include Wicket, Vaadin, JSF, and different Java templating engines, such as Freemarker,
    Apache Velocity, and Thymeleaf. These latter technologies can also be interesting
    when you generate textual output from Java even when the code is not web-related
    at all.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'These technologies, with discipline, helped control the development and maintenance
    costs of moderate and large web projects, but the basic problem of the architecture
    was still there: no clear separation of concerns.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, modern applications implement the code of a web application in separate
    projects: one for the client, using HTML, CSS and JavaScript, and a separate one
    to implement server functionality in Java (or in something else, but we focus
    here on Java). The communication between the two is the REST protocol, which we
    will cover in the subsequent chapters.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: HTML, CSS, and JavaScript
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML, CSS, and JavaScript are client-side technologies. These are extremely
    important for web applications, and a professional Java developer should have
    some knowledge about them. Nobody expects you to be an expert in Java and in web-client
    technologies at the same time, though this is not impossible. A certain understanding
    is desirable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML is the textual representation of a structured text. The text is given
    as characters, as in any text file. Tags represent the structure. A start tag
    starts with a `<` character, then the name of the tag, then, optionally, `name="value"`
    attributes, and finally a closing `>` character. An end tag starts with `</`,
    then the name of the tag, and then `>`. Tags are enclosed into hierarchies; thus,
    you should not close a tag sooner than the one that was opened later. First, the
    tag that was opened last has to be closed, then the next, and so on. This way,
    any actual tag in the HTML has a level, and all tags that are between the start
    and end tags are *below* this tag. Some tags that cannot enclose other tags or
    text do not have end tags and stand on their own. Consider the following sample:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The tag `head` is under `html`, and `title` is under `head`. This can be structured
    into a tree, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The browser stores the HTML text in a tree structure, and this tree is the object
    model of the web page document, thus the name, **Document Object Model** (**DOM**)
    tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The original HTML concept mixed formatting and structure, and even with the
    current version of HTML5, we still have tags such as `b`, `i`, `tt` that suggest
    the browser to display the text between the start and end tags in bold, italics,
    and teletype, respectively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As the name HTML, standing for Hypertext Markup Language, suggests, the text
    can contain references to other web pages in the form of hyperlinks. These links
    are assigned to texts using the `a` tag (standing for anchor) or to some form
    that may consist of different fields, and when the submit button of the form is
    pressed, the content of the fields is sent to the server in a `POST` request.
    When the form is sent, the content of the fields is encoded in the so-called `application/x-www-form-urlencoded`
    form.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The HTML structure always tried to promote the separation of structure and formatting.
    To do so, formatting was moved to styles. Styles defined in **Cascading Style
    Sheets** (**CSS**) provide much more flexibility for formatting than HTML; the
    format of a CSS is more effective for formatting. The aim to create CSS was that
    the design can be decoupled from the structure of the text. If I had to choose
    one of the three, I would opt for CSS as the one that is least important for Java
    server-side web developers and, at the same time, the most important for the users
    (things should look nice).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is the third pillar of client-side technologies. JavaScript is a
    fully functional, interpreted programming language executed by the browser. It
    can access the DOM tree, and read and modify it. When the DOM tree is modified,
    the browser automatically displays the modified page. JavaScript functions can
    be scheduledÂ and registered to be invoked when some event occurs. For example,
    you can register a function to be invoked when the document is fully loaded, when
    the user presses a button, clicks on a link, or just hovers the mouse over some
    section. Although JavaScript was first only used to create funny animations on
    the browser, today it is possible, and is a usual practice, to program fully functional
    clients using the capabilities of the browser. There are really powerful programs
    written in JavaScript, even such power-hungry applications as PC emulators.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we focus on Java and use the client-side technologies as much
    as is needed for demonstration technologies. However, being a Java web developer
    professional, you have to learn these technologies as well, to some extent at
    least, to understand what a client can do and to be able to cooperate with the
    professionals responsible for frontend technologies.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Mastermind servlet
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playing the Mastermind game via the Web is a bit different from what it used
    to be. Till now, we did not have any user interaction and our classes were designed
    accordingly. For example, we could add a new guess to the table, along with the
    partial and full matches calculated by the program. Now we have to separate the
    creation of a new guess, add it to the game, and set the full and partial matches.
    This time, we have to display the table first, and the user has to calculate and
    provide the number of matches.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to modify some of the classes to be able to do that. We need to add
    a new method to `Game.java`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Till now, we had only one method that was adding a new guess, and since the
    program knew the secret, it was immediately calculating the value of `full` and
    `partial`. The name of the method could be `addNewGuess`, overloading the original
    method, but this time, the method is used not only to add a new guess but also
    to add old guesses to rebuild the table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: When the program starts, there are no guesses. The program creates one, the
    first one. Later on, when the user tells the program the full and partial matches,
    the program needs the `Game` structure with `Table` and `Row` objects containing
    `Guess` objects and the `full` and `partial` match values. These were already
    available, but when the new HTTP hit comes in, we have to pull it from somewhere.
    Programming a servlet, we have to store the state of the game somewhere and restore
    it when a new HTTP request hits the server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Storing state
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storing the state can be done in two places. One place, which we will first
    do in our code, is the client. When the program creates a new guess, it adds it
    to the table and sends an HTML page that contains not only the new guess but also
    all the previous guesses and the `full` and `partial` match values that the user
    gave for each of the rows. To send the data to the server, the values are stored
    in the fields of a form. When the form is submitted, the browser gathers the information
    in the fields, creates an encoded string from the content of the fields, and puts
    the content into the body of a `POST` request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The other possibility for storing the actual state is in the server. The server
    can store the state of the game, and it can reconstruct the structure when it
    creates a new guess. The problem in this case is knowing which game to use. The
    server can and should store many games, one for each user, and users may use the
    application concurrently. It does not necessarily mean strong concurrency in the
    same meaning as we examined in the previous chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Even if the users are not served at the same time in multiple threads, there
    can be games that are active. Imagine `cnn.com` telling you that you cannot read
    the news at the moment because somebody else is reading it. There can be multiple
    users playing multiple games, and while serving an HTTP request, we should know
    which user we are serving.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Servlets maintain sessions that can be used for this purpose as we will see
    in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: HTTP session
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a client sends requests from the same browser to the same servlet, the
    series of requests belong to one session. To know that the requests belong to
    the same session, the servlet container automatically sends a cookie named `JSESSIONID`
    to the client, and this cookie has a long, random, hard-to-guess value (`tkojxpz9qk9xo7124pvanc1z`
    as I run the application in Jetty). The servlet maintains a session store that
    contains the `HttpSession` instances. The key string that travels in the value
    of the `JSESSIONID` cookie identifies the instances. When an HTTP request arrives
    at the servlet, the container attaches the session to the request object from
    the store. If there is no session for the key, then one is created, and the code
    can access the session object by calling the `request.getSession()` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: A `HttpSession` object can store attributes. The program can call the `setAttribute(String,Object)`,
    `getAttribute(String)`, and `removeAttribute(String)` methods to store, retrieve,
    or delete an attribute object. Each attribute is assigned to a `String` and can
    be any `Object`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Although the session attribute store essentially looks as simple as a `Map<String,?>`
    object, it is not. The values stored in the session can be moved from one node
    to another when the servlet container runs in a clustered or other distributed
    environment. To do that, the values are serialized; therefore, the values stored
    in the session should be `Serializable`. Failing to do so is a very common novice
    error. During development, executing the code in a simple development Tomcat or
    Jetty container practically never serializes the session to disk and never loads
    it from the serialized form. This means that the values set using `setAttribute`
    will be available by calling `getAttribute`. We run into trouble the first time
    the application gets installed in a clustered environment. As soon as a HTTP request
    arrives on different nodes `getAttribute` may return `null`. The method `setAttribute`
    is called on one node and during the processing of the next request `getAttribute`
    on a different node cannot deserialize the attribute value from the disk shared
    among the nodes. This is usually, and sadly, the production environment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: You, as a developer, should also be aware that serializing and de-serializing
    an object is a heavy operation that costs several CPU cycles. If the structure
    of the application uses only a part of the client state serving most of the HTTP
    requests, then this is a waste of CPU to create the whole state in memory from
    a serialized form and then serializing it again. In such cases, it is more advisable
    to store only a key in the session and use some database (SQL or NoSQL) or some
    other service to store the actual data referenced by the key. Enterprise applications
    almost exclusively use this structure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Storing state on the client
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will develop our code storing the state on the client. The form needed
    to send the user input and the number of new full and partial matches, also contains
    all the previous colors for all the guesses and answers given at that time by
    the user. To do so, we create a new helper class to format the HTML code. This
    is something that is done in a modern enterprise environment using templates,
    JSP files, or just totally avoided using pure REST and a one-page application
    in the enterprise environment. Nevertheless, here we will use the old technology
    in order to demonstrate the gears that rotate under the hood of modern engines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Except the `@Inject`Â annotation, the rest of the code is simple and straightforward.
    We will focus on `@Inject` later but very soon. What we have to focus on is the
    HTML structure the code generates. The generated page will look something like
    this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The form contains the colors in the form of DIV tags, and it also contains
    the "letter" of the color in hidden fields. These input fields are sent to the
    server when the form is submitted, just like any other field, but they do not
    appear on the screen and the user cannot edit them. The full and partial matches
    are displayed in the text input fields. Since it is not possible to display the
    `Color` objects in an HTML text, we use `LetteredColor` and `LetteredColorFactory`,
    which assign single letters to colors. The first 6 colors are simply numberedÂ as
    `0`, `1`, `2`, `3`, `4` and `5`. A CSS file can control how the colors will look
    on the browser window. You may remember that we covered how and where to implement
    the display of individual colors. First, we created a special printing class that
    was assigning letters to already existing colors, but that was usable only in
    a very limited environment (unit tests mainly). Now, we have the issue again.
    We have the lettered color, but now we need real colors as this time we have a
    client display that is capable of displaying colors. The real power of modern
    web technology shines here. The content and the format can be separated from each
    other. The pegs of different colors are listed in HTML as `div` tags. They have
    a formatting class but the actual look is defined in a CSS file that is responsible
    for nothing else but the look:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dependency injection with Guice
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The servlet class is very simple as shown in the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because many threads use servlets concurrently, and thus we cannot use instance
    fields holding data for a single hit, the servlet class does nothing else but
    create a new instance of a `MastermindHandler` class and invoke its `handle` method.
    Since there is a new instance of `MastermindHandler` for each request, it can
    store objects in fields specific to the request. To create a handler, we use the
    Guice library created by Google.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already talked about dependency injection. The handler needs a `Table`
    object to play, a `ColorManager` object to manage the colors, and a `Guesser`
    object to create a new guess, but creating these or fetching some prefabricated
    instances from somewhere is not the core functionality of the handler. The handler
    has to do one thing: handle the request; the instances needed to do this should
    be injected from outside. This is done by a `Guice` injector.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Guice, we have to list the library among the dependencies in `build.gradle`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we have to create an `injector` instance that will do the injection. The
    injector is created with the following line in the servlet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The instance of `MastermindModule` specifies what to inject where. This is
    essentially a configuration file in the Java format. Other dependency injector
    frameworks used, and use, XML and annotations to describe the injection binding
    and what to inject where, but Guice solely uses Java code. The following is the
    DI configuration code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The methods used in the `configure` method are created in a fluent API manner
    so that the methods can be chained one after the other and that the code can be
    read almost like English sentences. A good introduction to fluent API can be found
    atÂ [https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/).
    For example, the first configuration line could be read in English as
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*Bind to the class* `int` *wherever it is annotated with the* `@Name` *annotation
    having value* `"nrColor"` *to the instance* `6`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: (Note that the `int` value `6` is autoboxed to an `Integer` instance.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MastermindHandler` class contains fields annotated with `@Inject` annotation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This annotation is not Guice-specific. `@Inject` is a part of the `javax.inject`
    package and is a standard part of JDK. JDK does not provide the **dependency injector**
    (**DI**) framework but supports the different frameworks so that they can use
    standard JDK annotations, and in case the DI framework is replaced, the annotations
    may remain the same and not framework-specific.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: When the injector is called to create an instance of `MastermindHandler`, it
    looks at the class and sees that it has an `int` field annotated with `@Inject`
    and `@Named("nrColors")`, and finds in the configuration that such a field should
    have the value 6\. It injects the value to the field before returning the `MastermindHandler`
    object. Similarly, it also injects the values into the other fields, and if it
    should create any of the objects to be injected, it does. If there are fields
    in these objects, then they are also created by injecting other objects and so
    on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: This way the DI framework removes the burden from the programmers' shoulder
    to create the instances. This is something fairly boring and is not the core feature
    of the classes anyway. Instead, it creates all the objects needed to have a functional
    `MastermindHandler` and links them together via the Java object references. This
    way, the dependencies of the different objects (`MastermindHandler` needs `Guesser`,
    `ColorManager`, and `Table`;Â `ColorManager` needsÂ `ColorFactory`; andÂ `Table`
    also needs `ColorManager`, and so on) become a declaration, specified using annotations
    on the fields. These declarations are inside the code of the classes, and it is
    the right place for them. Where else could we specify what the class needs to
    properly function than in the class itself?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The configuration in our example specifies that wherever there is a need for
    `ColorFactory`, we will use `LetteredColorFactory`, and that wherever we need
    `Guesser`, we will use `UniqueGuesser`. This is separated from the code and it
    has to be like that. If we want to change the guessing strategy, we replace the
    configuration and the code should work without modifying the classes that use
    the guesser.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Guice is clever enough and you need not specify thatÂ whereverÂ there is a need
    for `Table`, we will use `Table`: there is no `bind(Table.class).to(Table.class)`.
    First I created a line like that in the configuration, but Guice rewarded me with
    an error message, and now, writing it again in plain English, I feel really stupid.
    If I need a table I need a table. Really?'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The MastermindHandler class
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already started the listing of the `MastermindHandler` class, and since
    this class is more than a hundred lines, I will not include it here as a whole.
    The most important method of this class is `handle`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: WeÂ perform three steps. Step 1 is creating the table and we do it from the request.
    If this is not the start of the game, there is already a table and the HTML form
    contains all previous guess colors and the answers to those. Then, as the second
    step, we create a new guess based on that. Step 3 is to send the new HTML page
    to the client.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is not a modern approach, creating HTML on the servlet code, but
    demonstrating pure servlet functionality with REST, JSON, and JavaScript with
    some framework would make this chapter alone a few hundred pages long, and it
    would definitely distract our focus from Java.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Printing HTML text to a `PrintWriter` is not something that should be new to
    you at this point in this book; therefore, we will not list that code here. You
    can download the working example on GitHub. The branch for this version of the
    code is `nosession`. Instead of printing, we will focus on the servlet parameter
    handling.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The request parameters are available via the `getParameter` method, which returns
    the string value of a parameter. This method assumes that any parameter, be it
    `GET` or `POST`, appears only once in the request. In case there are parameters
    that appear multiple times, the value should have been a string array. In such
    a case, we should use `getParameterMap`, which returns the whole map with the
    `String` keys and `String[]` values. Even though we do not have multiple values
    for any key this time, and we also know the values of the keys coming as `POST`
    parameters, we will still use the latter method. The reason for this is that we
    will later use the session to store these values, and we want to have a method
    that is reusable in that case.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the earlier commits in the Git repository, you will see that
    the first version used `getParameter` and I refactored it only later when I created
    the second version of the program, which stores the state in a session. Never
    believe if anyone tells you that programs are created perfectly upfront without
    any refactoring during development. Do not feel ashamed to create foolish code
    and refactor it later. It is only shameful if you do not refactor it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'To get to that we convert the request''s `Map<String,String[]>` to `Map<String,String>`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we use that map to re-create the game:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The conversion from `String` to `int` is done via the method `parseInt`. This
    method throws `NumberFormatException` when the input is not a number. Try to run
    the game, use the browser, and see how Jetty handles the case when the servlet
    throws an exception. How much valuable information do you see in the browser that
    can be used by a potential hacker? Fix the code so that it asks the user again
    if any of the numbers are not well formatted!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Storing state on the server
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application state shouldÂ usually not be saved on the client. There may be
    some special case in addition to the one where you write educational code and
    want to demonstrate how to do it. Generally, the state of the application related
    to the actual use is stored in the session object or on some database. This is
    especially important when the application requests the user to enter a lot of
    data and does not want the user to lose the work if there is some hiccup in the
    client computer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: You spend a lot of time selecting the appropriate items in an online shop, choosing
    the appropriate items that work together, creating a configuration of your new
    model airplane, and all of a sudden, there is a blackout in your home. If the
    state were stored on the client you'd have had to start from scratch. If the state
    is stored on the server, the state is saved to disk; the servers are duplicated,
    fed by battery-backed power supplies, and when you reboot your client machine
    when the power comes back in your home, you log in, and miraculously, the items
    are all there in your shopping basket. Well, it is not a miracle; it is web programming.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the second version will store the state of the game in the session.
    This will let the user have the game restore so long as the session is there.
    If the user quits and restarts the browser, the session gets lost and a new game
    can start.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there is no need to send the actual colors and matching in hidden fields
    this time, the HTML generation is modified a bit, and the generated HTML will
    also be simpler:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The number of full and partially matching colors is displayed as a simple number,
    so this version does not allow *cheating* or changing previous results. (These
    are the numbers `0` and `2` after the `div` tags that have the CSS class `spacer`.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The `handle` method in `MastermindHandler` also changes, as shown in the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This version of the class gets a `SessionSaver` object injected by the Guice
    injector. This is a class that we create. This class will convert the current
    Table into something that is stored in the session, and it also recreates the
    table from the data stored in the session. The `handle` method uses the `buildGameFromSessionAndRequest`
    method to restore the table and to add the full and partial match answers that
    the user just gave in the request. When the method creates a new guess and fills
    it in the table, and also sends it to the client in the response, it saves the
    state in the session by calling the `save` method via the `sessionSaver` object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The `buildGameFromSessionAndRequest` method replaces the other version, which
    we named `buildGameFromRequest`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that this version has the same illness of using the `parseInt` method from
    the `Integer` class in JDK, which throws an exception.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The GameSessionSaver class
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class has three public methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '`save`: This saves a table to the user session'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restore`: This gets a table from the user session'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset`: This deletes any table that may be in the session'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code of the class is the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we save the session and convert the table to a map, we use a `HashMap`.
    The implementation in this case is important. The `HashMap` class implements the
    `Serializable` interface; therefore, we can be safe putting it to the session.
    This alone does not guarantee that everything in `HashMap` is `Serializable`.
    The keys and the values in our case are Strings, and fortunately, the `String`
    class also implements the `Serializable` interface. This way, the converted `HashMap`
    object can be safely stored in the session.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, although serialization can be slow, storing `HashMap` in a session
    is so frequent that it implements its own serialization mechanism. This implementation
    is optimized and avoids serialization being dependent on the internal structure
    of the map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to think about why we have the `convertTableToMap` method in this
    class and `buildGameFromMap` in `MastermindHandler`. Converting the game and the
    table in it to a `Map` and the other way round should be implemented together.
    They are just two directions of the same conversion. On the other hand, the implementation
    of the `Table` to `Map` direction should use a `Map` version that is `Serializable`.
    This is very much related to session handling. Converting aÂ `Map` object, in general,
    to a `Table` object is one level higher, restoring the table from wherever it
    was stored: client, session, database, or in the moisture of the cloud. Session
    storage is only one possible implementation, and methods should be implemented
    in the class that meets the abstraction level.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The best solution could be to implement these in a separate class. You have
    homework!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reset` method is not used from the handler. This is invoked from the `Mastermind`
    class, that is, the servlet class to reset the game when we start it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Without this, playing the game against the machine once would just display the
    finished game every time we want to start it again, until we exit the browser
    and restart it or explicitly delete the `JSESSIONID` cookie somewhere in the advanced
    menu of the browser. Calling `reset` does not delete the session. The session
    remains the same, and thus the value of `JSESSIONID` too, but the game is deleted
    from the session object that the servlet container maintains.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Running the Jetty web servlet
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have included the Jetty plugin into our Gradle build, the targets
    of the plugin are available. To start Jetty is as easy as typing the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will compile the code, build the WAR file, and start the Jetty servlet
    container. To help us remember, it also prints the following on the command line:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can open this URL and see the opening screen of the game with the colors
    that the program created as a first guess:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: 'Now it is time to have some fun and play with our game, giving answers to the
    program. Do not make it easy for the code! Refer to the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'At the same time, if you look at the console where you have typed `gradle jettyRun`,
    you will see that the code is printing out log messages, as shown in the following
    screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.gif)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: These printouts come through the logger that we have in our code. In the previous
    chapters, we used the `System.out.println` method calls to send informational
    messages to the console. This is a practice that should not be followed in any
    program that is more complex than a *hello world*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several logging frameworks available for Java and each has advantages
    and disadvantages. There is one built into JDK in the `java.util.logging` package
    and accessing the logger is supported by the `System.getLogger` method: the `System.Logger`
    and `System.LoggerFinder` classes. Even though `java.util.logging` has been available
    in Java since JDK 1.4, a lot of programs use other logging solutions. In addition
    to the built-in logging, we have to mention `log4j`, `slf4j` and Apache Commons
    Logging. Before getting into the details of the different frameworks, let''s discuss
    why it is important to use logging instead of just printing to the standard output.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Configurability
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important reason is configurability and ease of use. We use logging
    to record information about the operation of code. This is not the core functionality
    of the application but is inevitable to have a program that can be operated. There
    are messages we print out to the log, which can be used by the operating personnel
    to identify environmental issues. For example, when an `IOException` is thrown
    and it gets logged, the operation may look at the logs and identify that the disk
    got full. They may delete files, or add a new disk and extend the partition. Without
    the logs, the only information would be that the program does not work.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The logs are also used many times to hunt down bugs. Some of the bugs do not
    manifest in the test environment and are very difficult to reproduce. In such
    a case, the logs that print out detailed information about the execution of the
    code are the only source of finding the root cause of some error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Since logging needs CPU, IO bandwidth, and other resources, it should be carefully
    examined what and when to log. This examination and the decisions could be done
    during programming, and as a matter of fact, that is the only possibility if we
    used `System.out.println` for logging. If we need to find a bug, we should log
    a lot. If we log a lot, the performance of the system will go down. The conclusion
    is that we have to log only if it is needed. If there is a bug in the system that
    cannot be reproduced, the developers ask the operation to switch on debug logging
    for a short period. Switching on and off different parts of logging is not possible
    when `System.out.println` is used. When the debug level log is switched on, the
    performance may go down for a while, but at the same time, the logs become available
    for analysis. At the same time, the analysis is simpler when we have to find the
    log lines that are relevant (and you do not know beforehand which are relevant)
    if there is a small (a few hundred megabytes log file) rather than a lot of 2-GB
    compressed log files to find the lines in.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Using a log framework, you can define loggers that identify the source of the
    log messages and log levels. A string usually identifies the logger, and it is
    a common practice to use the name of the class from which the log message is created.
    This is such a common practice that the different log frameworks provide factory
    classes that get the class itself, instead of its name, to get a logger.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible logging levels may be slightly different in different logging
    frameworks, but the most important levels are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`FATAL`: This is used when the log message is about some error that prevents
    the program from continuing its execution.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR`: This is used when there is some severe error, but the program can
    still go on functioning although, probably, in some limited manner.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING`: This is used when there is some condition that is not a direct problem
    but may later lead to an error if not attended. For example, the program recognizes
    that a disk is near full, some database connections answer within limits but close
    to the timeout value, and similar situations.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO`: This is used to create messages about normal operations that may be
    interesting to operate and are not an error or warning. These messages may help
    the operation to debug the operational environment settings.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG`: This is used to log information about the program that is detailed
    enough (hopefully) to find a bug in the code. The trick is that when we put the
    log statement into the code, we do not know what bug it could be. If we knew,
    we better fixed it.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`: This is even more detailed information about the execution of the
    code.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log frameworks are usually configured using some configuration file. The
    configuration may limit the logging, switching off certain levels. In a normal
    operational environment, the first three levels are usually switched on, and `INFO`,
    `DEBUG`, and `TRACE` are switched on when really needed. It is also possible to
    switch on and off certain levels only for certain loggers. If we know that the
    error is certainly in the `GameSessionSaver` class, then we can switch on theÂ `DEBUG`
    level only for that class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Log files may also contain other information that we did not directly code
    and would be very cumbersome to print to the standard output. Usually, each log
    message contains the precise time when the message was created, the name of the
    logger, and, many times, the identifier of the thread. Imagine if you were forced
    to put all this to each and every `println` argument; you would probably soon
    write some extra class to do that. Don''t! It has already been done professionally:
    it is the logger framework.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Loggers can also be configured to send the message to different locations. Logging
    to the console is only one possibility. Logging frameworks are prepared to send
    messages to files, database, Windows Event Recorder, syslog service, or to any
    other target. This flexibility, which message to print, what extra information
    to print, and where to print is reached by separating the different tasks that
    the logger framework does into several classes following the single responsibility
    principle.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The logger frameworks usually contain loggers that create the logs, formatters
    that format the message from the original log information, many times, adding
    information such as thread ID and time stamp, and appenders that append the formatted
    message to some destination. These classes implement interfaces defined in the
    logging framework and nothing but the size of the book stops us from creating
    our own formatters and appenders.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: When a log is configured, the appenders and formatters are configured, given
    the class that implements them. Therefore, when you want to send some logs to
    some special destination, you are not limited to the appenders that are provided
    by the authors of the framework. There are a lot of independent open-source projects
    for different logging frameworks providing appenders for different targets.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second reason to use a logging framework is performance. Although it is
    not good to optimize for performance before we profile the code (premature optimization),
    using some methodology known to be slow and inserting several lines into our performance-critical
    code, invoking slow methods is not really professional either. Using a well-established,
    highly optimized framework in a way that is industry best practice should not
    be questionable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `System.out.println` sends the message to a stream and returns only when
    the IO operation is done. Using real logging handles the information to the logger
    and lets the logger do the logging asynchronously, and it does not wait for completion.
    It is really a drawback that log information may be lost if there is some system
    failure, but this is usually not a serious issue considering how rarely that happens
    and what is on the other side of the wage: performance. What do we lose if there
    is a missing debug log line when the disk got full, anyway rendering the system
    unusable?'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one exception to this: audit loggingâwhen some log information about
    the transactions of the system has to be saved for legal reasons so that the operation
    and the actual transactions can be audited. In such a case, the log information
    is saved in a transactional manner, making the log part of the transaction. Because
    that is a totally different type of requirement, audit logging is not usually
    done with any of these frameworks.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Also, `System.out.println` is not synchronized and that way different threads
    may just garble the output. Log frameworks pay attention to this issue.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Log frameworks
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most widely used logging framework is **Apache****log4j**. It currently
    has a second version that is a total rewrite of the first version. It is very
    versatile and has many appenders and formatters. The configuration of log4j can
    be in XML or properties file format, and it can also be configured through API.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The author of log4j version 1 created a new logging framework: **slf4j**. This
    logging library is essentially a faÃ§ade that can be used together with any other
    logging framework. Thus, when you use slf4j in a library you develop, and your
    code is added to a program as a dependency that uses a different logging framework,
    it is easy to configure slf4j to send the logs to the loggers of the other framework.
    Thus, the logs will be handled together and not in separate file, which is desirable
    to decrease the cost of operation. When developing your library code or an application
    that uses slf4j, there is no need to select another log framework to slf4j. It
    has its own simple implementation called backlog.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Apache Commons Logging is also a faÃ§ade with its own logging implementation
    if nothing else fails. The major difference from slf4j is that it is more flexible
    in configurationÂ and what underlying logging to use, and it implements a run-time
    algorithm to discover which logging framework is available and is to be used.
    The industry best practice shows that this flexibility, which also comes with
    higher complexity and cost, is not needed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 logging
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 9 includes a facade implementation for logging. The use is very simple
    and we can expect that logging frameworks will very soon start to support this
    faÃ§ade. The fact that this faÃ§ade is built into the JDK has two major advantage:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The libraries that want to log do not need to have any dependency on any logging
    framework or logging faÃ§ade any more. The only dependency is the JDK log faÃ§ade
    that is there anyway.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JDK libraries that log themselves use this faÃ§ade and thus they will log
    into the same log file as the application.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we use the JDK-provided logging faÃ§ade the start of the `ColorManager` class
    will be changed to the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this version we do not import the slf4j classes. Instead we import the `java.lang.System.Logger`
    class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Note that we do not need to import the System class, because the classes from
    the `java.lang` package are automatically imported. This is not true for the classes
    that are nested classes in the `System` class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: To get access to the logger the `System.getLogger` static method is called.
    This method finds the actual logger that is available and returns one for the
    name that we pass as argument. There is no version of the method `getLogger` that
    accepts the class as the argument. If we want to stick to the convention then
    we have to write `ColorManager.class.getName()` to get the name of the class or
    we can write there the name of the class as a string. The second approach has
    the drawback that it does not follow the change of the name of the class. Intelligent
    IDEs like IntelliJ, Eclipse, or Netbeans rename the references to classes automatically
    but they have a hard time when the name of the class is used in a string.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface `System.Logger` does not declare the convenience methods `error`,
    `debug`, `warning`, and so on, that are familiar from other logging frameworks
    and faÃ§ade. There is only one method named `log` and the first argument of this
    method is the level of the actual log we issue. There are eight levels defined:
    `ALL`, `TRACE`, `DEBUG`, `INFO`, `WARNING`, `ERROR,` and `OFF`. When creating
    a log message we are supposed to use one of the middle six levels. `ALL` and `OFF`
    are meant to be passed to the `isLoggable` method. This method can be used to
    check if the actual logging level gets logged or not. For example, if the level
    is set to `INFO` then messages sent with `DEBUG` or `TRACE` will not be printed.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual implementation is located by the JDK using the service loader functionality.
    The log implementation has to be in a module that provides the interface `java.lang.System.LoggerFinder`
    via some implementation. In other words the module should have a class that implements
    the `LoggerFinder` interface and the `module-info.java` should declare which class
    it is using the code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `MyLoggerFinder` class has to extend the `LoggerFinder` abstract class with
    the method `getLogger`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Logging practice
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The practice of logging is very simple. If you do not want to spend too much
    time experimenting with different logging solutions and you do not have some special
    requirement, then simply go with slf4j, add the JAR to the dependency list as
    a compile dependency, and start using logging in the source code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Since logging is not instance-specific, and loggers implement thread safety,
    the log objects that we usually use are stored in a `static` field, and since
    they are used as long as the class is used, the program running the field is also
    `final`. For example using the slf4j faÃ§ade we can get a logger with the following
    command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To get the logger, the logger factory is used, which just creates the logger
    or returns the one that is already available.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The name of the variable is usually `log` or `logger,` but do not be surprised
    if you see `LOG` or `LOGGER`. The reason for uppercasing the name of the variable
    is that some static code analysis checkers treat `static final` variables as constants,
    as they really are, and the convention in the Java community is to use uppercase
    names for such variables. It is a matter of taste; many times `log` and `logger`Â are
    used in lowercase.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a log item the methods `trace`, `debug`, `info`, `warn`, and `error`
    create a message with the respective level as the name implies. For example, consider
    the following line:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It creates a debug message. Slf4j has support for formatting using the `{}`
    literal inside strings. This way, there is no need to append the string from small
    parts, and in case the actual log item is not sent to the log destination, the
    formatting will not perform. If we use `String` concatenation in any form to pass
    a string as an argument, then the formatting will happen even if debug logging
    is not desired as per the example.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'The logging methods also have a version that gets only two arguments: a `String`
    message and `Throwable`. In this case, the logging framework will take care of
    the output of the exception and the stack trace along with it. If you log something
    in exception handling code, log the exception and let the logger format it.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Other technologies
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the servlet technology, a bit of JavaScript, HTML, and CSS. When
    programming in a real professional environment, these technologies are generally
    used. The creation of the user interface of applications, however, was not always
    based on these technologies. Older operating system-native GUI applications as
    well as Swing, AWT, and SWT use a different approach to create UI. They build
    up the UI facing the user from program code, and the UI is built as a hierarchical
    structure of components. When web programming started, Java developers had experience
    with technologies like these and projects created frameworks that tried to hide
    the web technology layer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: One technology worthÂ mentioning isÂ Google Web Toolkit, which implements the
    server as well as the browser code in Java, but since there is no Java environment
    implemented in the browsers, it transpiles (converts) the client part of the code
    from Java to JavaScript. The last release of the toolkit was created two years
    ago in 2014 and since then Google has released other types of web programming
    toolkits that support native JavaScript, HTML, and CSS client development.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Vaadin** is also a toolkit that you may come across. It lets you write GUI
    code on the server in Java. It is built on top of GWT and is commercially supported.
    It may be a good choice in case there are developers available who have experience
    with GUI development in Java but not in web native technologies, and the application
    does not require special usability tuning on the client side. A typical intranet
    corporate application can select it as a technology.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Server Faces** (**JSF**) is a technology that tries to offload the client-side
    development of the application from the developers providing widgets ready to
    be used and the server side. It is a collection of several **Java Specification
    Requests** (**JSR**) and there are several implementations. The components and
    their relations are configured in XML files and the server creates the client
    native code. In this technology, there is no transpilation from Java to JavaScript.
    It is more like using a limited but huge set of widgets, limiting the use to those
    only, and giving up direct programming of the web browser. If one has the experience
    and knowledge, however, they can create new widgets in HTML, CSS, and JavaScript.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: There are many other technologies that were developed to support web applications
    in Java. The modern approach advocated by most of the big players is to develop
    the server side and the client side using separate toolsets and methodologies,Â and
    connect the two using REST communication.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learnt the structure of web programming. This was not possible
    without understanding the basics of TCP/IP networking, which is the protocol of
    the Internet. The application level protocol that is used over that is HTTP, currently
    in a very new version 2.0, which is still not supported by the servlet standard.
    We created a version of the Mastermind game that, this time, can really be played
    using the browser and we started it in a development environment using Jetty.
    We examined how to store the game state and implemented two versions. Finally,
    we learned the basics of logging and we looked at other technologies. At the same
    time, we also looked at the dependency injection implementation Guice from Google,
    and we studied how it works under the hood, and why and how to use it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you will be able to start the development of a web application
    in Java and will understand the architecture of such a program. You will understand
    what is under the hood when you start learning how to program web applications
    using the Spring framework, which hides many of the complexities of web programming.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
