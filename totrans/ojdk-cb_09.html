<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Testing OpenJDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Testing OpenJDK</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Running tests using the downloaded or the built version of jtreg</li><li class="listitem" style="list-style-type: disc">Building jtreg from the source</li><li class="listitem" style="list-style-type: disc">Running the standard set of OpenJDK tests</li><li class="listitem" style="list-style-type: disc">Writing your own test for jtreg</li><li class="listitem" style="list-style-type: disc">Using jtreg in GUI mode</li><li class="listitem" style="list-style-type: disc">Writing TestNG tests for jtreg</li><li class="listitem" style="list-style-type: disc">Compiling JT Harness from the source code</li><li class="listitem" style="list-style-type: disc">Building and running jcstress</li><li class="listitem" style="list-style-type: disc">Writing tests for jcstress</li><li class="listitem" style="list-style-type: disc">Creating a benchmark project using JMH</li><li class="listitem" style="list-style-type: disc">Downloading the source and compiling JMH</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Introduction</h1></div></div></div><p>Back in 1997, when JDK 1.1 was completed and JDK 1.2 had just started, there was an obvious problem—JDK had to be tested somehow and there had to be a tool for it. This is the moment when <span class="strong"><strong>jtreg</strong></span><a id="id405" class="indexterm"/> appeared as the regression test harness. At that time, there were not many testing frameworks for Java. In fact, there was not even much software written in Java. So choices were very limited and the only reasonable option was the framework that was being used at that time for the <a id="id406" class="indexterm"/>
<span class="strong"><strong>Java Compatibility Kit</strong></span> (<span class="strong"><strong>JCK</strong></span>). Its name was <a id="id407" class="indexterm"/>
<span class="strong"><strong>JavaTest</strong></span>. But, as JCK tests were very different from what a JDK regression test is supposed to do, the framework required some adaptation and that is when jtreg appeared. At the moment, even though many years have passed since 1997, jtreg still remains the primary tool for running unit and regression tests in OpenJDK. Since its introduction in OpenJDK, more than 10,000 tests have been created that run using the jtreg framework.</p><p>As a testing tool, jtreg might look a little unusual for modern developers who are used to tools such as jUnit and TestNG. The main reason jtreg looks different is because it has a long history. It appeared before jUnit in 1997, which appeared sometime around 2000. At that time, especially when technology was so young, three years was a long period. It seems possible that the other contributing factor was that jtreg for a long time remained a proprietary tool and, as it was doing its job, there was no need to change it. Also, it was not open to the wide open source community, who could have changed its shape over time. The other reason that contributes to its difference when compared to the current <span class="emphasis"><em>classical</em></span> tools is that it provides some special features that are not usually available in testing frameworks, but are required to do testing on JDK. These features include running a test in a separate instance (or for some tests, even several instances) of JVM with a specific set of parameters, testing Java applets (remember them?), running shell scripts as tests, running GUI tests which require user interaction, and so on. This is a pretty big set of additional features, which is enough to justify building a separate framework for it.</p><p>Having said all that, it would not be fair to say that jtreg is some old-fashioned tool that is stuck in the 1990s and does not attempt to change itself to be closer to the modern way of building frameworks for software testing. It has been integrated with testing frameworks such as <span class="strong"><strong>TestNG</strong></span><a id="id408" class="indexterm"/> and provides a way to create tests that are based on that framework. However, the majority of tests in JDK are still just classes with a main method that are executed by the framework. Though, to be fair, such an approach has its benefits since it allows one to run individual tests without any framework. There are also some tests that are just batch files and there is an ongoing effort to get rid of them.</p><p>As a tool that evolved from JavaTest, jtreg inherited compatibility with its framework. This compatibility has been now isolated into a separate project called <span class="strong"><strong>Java Test Harness</strong></span> (<span class="strong"><strong>JT Harness</strong></span>). This is a framework for running, building, and deploying tests suites. It also provides a GUI to manage and execute the test suites.</p><p>In this chapter, you will learn enough to be a confident jtreg user and know how to use JT Harness. You will find out how to build jtreg and JT Harness from the source code, how to run tests, and how to write your own tests. The chapter covers only plain Java and TestNG tests, as they are the most useful ones for OpenJDK developers. This chapter does not cover the usage of shell tests, as their usage is not considered a good practice and they were created to work around JVM limitations that existed a few years back. At the current moment, all OpenJDK contributors are encouraged to replace the shell tests with the Java version, wherever possible.</p></div></div>
<div class="section" title="Running tests using the downloaded or the built version of jtreg"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Running tests using the downloaded or the built version of jtreg</h1></div></div></div><p>The simplest <a id="id409" class="indexterm"/>way to get started with jtreg is to just download it, unpack it, and run some tests. In this recipe, we will do exactly that, without doing any<a id="id410" class="indexterm"/> additional things such as building it from the source code or trying to create our own tests.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec229"/>Getting ready</h2></div></div></div><p>For this recipe, nothing much is really required—just the Internet connection, a machine with an installed or built OpenJDK, and the OpenJDK source code. In a Windows environment, Cygwin has to be installed in your machine.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec230"/>How to do it...</h2></div></div></div><p>The following are a few simple steps to get a set of tests executed by jtreg:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If jtreg is not <a id="id411" class="indexterm"/>yet available on the machine, go to the official page of jtreg (<a class="ulink" href="https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/">https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/</a>) and download the latest available version of jtreg. The other option is to build it from the source code. To do this, follow the instructions in the <span class="emphasis"><em>Building Jtreg from the source</em></span> recipe that is covered later in this chapter. After you have either downloaded jtreg or built it using the source code, proceed to the next step.</li><li class="listitem">Unpack the downloaded archive to a folder.</li><li class="listitem">In the root folder of the OpenJDK source tree, create a shell script with the name, <code class="literal">run_test.sh</code>. This script will be used to run jtreg:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>export JT_JAVA=/etc/alternatives/java_sdk_1.7.0_openjdk/</strong></span>
<span class="strong"><strong>/home/user/openjdk/jtreg/bin/jtreg -jdk:$JT_JAVA -agentvm -automatic -verbose:summary -w build/jtreg/work -r build/jtreg/report hotspot/test/compiler/5091921</strong></span>
</pre></div><p>The only thing here that needs to be changed is the <code class="literal">JT_JAVA</code> environment variable that has to point to the version of OpenJDK that is higher or equal to 1.5.</p></li><li class="listitem">After running the script, you will see the output as shown:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jdk7u_clean]$ ./run_test.sh </strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test5091921.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6186134.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6196102.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6357214.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6559156.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6753639.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6850611.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6890943.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6897150.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6905845.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6931567.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6935022.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6959129.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6985295.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test6992759.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test7005594.java</strong></span>
<span class="strong"><strong>Passed: compiler/5091921/Test7020614.java</strong></span>
<span class="strong"><strong>Test results: passed: 17</strong></span>
</pre></div></li><li class="listitem">After the test, run the HTML report that is generated by jtreg. This is available in the folder specified by the <code class="literal">-r</code> parameter.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec231"/>How it works…</h2></div></div></div><p>As you can<a id="id412" class="indexterm"/> see, the shell script that is used to run jtreg is simple and there are <a id="id413" class="indexterm"/>only a few points that need to be clarified. These are the <code class="literal">JT_JAVA</code> environment variables and the command line arguments of jtreg.</p><p><code class="literal">JT_JAVA</code><a id="id414" class="indexterm"/> is one of the two environment variables used by the jtreg shell script. <code class="literal">JT_JAVA</code> specifies the version of Java that will be used to run the framework, but not the tests. In this recipe, for the sake of simplicity, we used the same version of Java to run jtreg and the tests.</p><p>The jtreg command line arguments<a id="id415" class="indexterm"/> are all described in detail on the jtreg webpage (<a class="ulink" href="http://openjdk.java.net/jtreg/command-help.html">http://openjdk.java.net/jtreg/command-help.html</a>), so we will cover just a few of them that are used in this recipe:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-jdk</code>: This<a id="id416" class="indexterm"/> argument will generate the JDK that will be used to run tests. Basically, it is the version of Java which is tested by the test run. In our example, we used the version that was installed on the machine. If you want to use the version that was built from the source, the variable should be changed appropriately to point to the output of the build.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-agentvm</code>: This <a id="id417" class="indexterm"/>is the mode when jtreg uses the pool of reusable JVMs to run the tests. When a test requires a separate JVM for the run, that JVM is not created, but it is borrowed from the pool of reusable instances. If any parameter is not specified, jtreg will recreate a JVM for each test and this will significantly slow down the test run.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-verbose:summary</code>: This<a id="id418" class="indexterm"/> argument specifies the output mode. The <code class="literal">summary</code> parameter means that it will print just the status and the test name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-automatic</code>: This<a id="id419" class="indexterm"/> argument means that only the automatic tests that do not require user intervention will be run.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-w</code>: This<a id="id420" class="indexterm"/> argument provides the location of the working directory. This will be used to store class files, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-r</code>: This <a id="id421" class="indexterm"/>argument provides the reporting directory in which reports are to be stored. To see the report, open the <code class="literal">&lt;reporting directory&gt;/html/report.html</code> file in any browser.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec232"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The complete list of command line options is available at <a class="ulink" href="http://openjdk.java.net/jtreg/command-help.html">http://openjdk.java.net/jtreg/command-help.html</a>.</li><li class="listitem" style="list-style-type: disc">Some might find <a id="id422" class="indexterm"/>it useful to run tests only for a specific bug and, for that, the <code class="literal">bug:&lt;bug_id&gt;</code> command-line option can be used. The tests' logfiles can be found in the working directory (specified by the <code class="literal">-w</code> parameter or in <code class="literal">JTwork</code> if that parameter is not defined). Logfiles are in text format with a <code class="literal">.jtr</code> extension. These files contain the test output along with the command line and an exception, if thrown, and are very useful for troubleshooting.</li></ul></div></div></div>
<div class="section" title="Building jtreg from the source"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec70"/>Building jtreg from the source</h1></div></div></div><p>Apart<a id="id423" class="indexterm"/> from downloading jtreg as a binary package, there is also an option to download the source code and build jtreg from the source. This can be beneficial for developers who might want to make changes in the source code or get the latest fix that has not yet been released as a binary package.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec233"/>Getting ready</h2></div></div></div><p>You will need an Internet connection, a machine capable of running make and batch files (Linux or Cygwin), and an installed Mercurial.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec234"/>How to do it...</h2></div></div></div><p>The following<a id="id424" class="indexterm"/> simple steps will show you how to get the jtreg source code and make the build:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the sources from <a class="ulink" href="http://hg.openjdk.java.net/code-tools/jtreg">http://hg.openjdk.java.net/code-tools/jtreg</a>. To do this, just execute the following command that will clone the jtreg source tree in the local folder, <code class="literal">jtreg</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost tmp]$ hg clone http://hg.openjdk.java.net/code-tools/jtreg</strong></span>
<span class="strong"><strong>destination directory: jtreg</strong></span>
<span class="strong"><strong>requesting all changes</strong></span>
<span class="strong"><strong>adding changesets</strong></span>
<span class="strong"><strong>adding manifests</strong></span>
<span class="strong"><strong>adding file changes</strong></span>
<span class="strong"><strong>added 85 changesets with 1239 changes to 602 files</strong></span>
<span class="strong"><strong>updating to branch default</strong></span>
<span class="strong"><strong>586 files updated, 0 files merged, 0 files removed, 0 files unresolved</strong></span>
</pre></div><p>After the execution of the command, the current directory can be found in the new <code class="literal">jtreg</code> folder with all the jtreg sources.</p></li><li class="listitem">If there is no <a id="id425" class="indexterm"/>Ant software installed on the machine, install it using <code class="literal">yum</code> (or any other packaging tool), or simply download it from <a class="ulink" href="http://ant.apache.org/">http://ant.apache.org/</a> and then unpack it. If you are using a Linux machine, you also have an option to install it by running <code class="literal">yum</code> or any other similar tool that can be found at <a class="ulink" href="http://ant.apache.org/">http://ant.apache.org/</a> and then unpack it.</li><li class="listitem">Download the latest available version of<a id="id426" class="indexterm"/> JT Harness, which is available at <a class="ulink" href="https://jtharness.java.net/">https://jtharness.java.net/</a>. Unpack it in the <code class="literal">jtreg/lib</code> folder.</li><li class="listitem">jtreg requires JUnit, but not the latest version. The version has to be earlier than 4.11. The simplest way to get it would be to download the version from Maven <a id="id427" class="indexterm"/>central at <a class="ulink" href="http://mvnrepository.com/artifact/junit/junit/4.5">http://mvnrepository.com/artifact/junit/junit/4.5</a>. A jtreg build requires just the JAR file. Put this file in the <code class="literal">jtreg/lib</code> folder.</li><li class="listitem">To make things slightly more exciting, a jtreg build also requires another testing framework—<span class="strong"><strong>TestNG v.6.8</strong></span>. This<a id="id428" class="indexterm"/> can be downloaded from <a class="ulink" href="http://testng.org/doc/download.html">http://testng.org/doc/download.html</a>.<p>Note that the required version is the version for Ant users. To make things simpler, just use the link, <a class="ulink" href="http://testng.org/testng-6.8.zip">http://testng.org/testng-6.8.zip</a>. Unpack the downloaded archive in the <code class="literal">jtreg/lib</code> folder.</p></li><li class="listitem">The next dependency <a id="id429" class="indexterm"/>is <code class="literal">JavaHelp</code>. This seems to be available only via a direct link at <a class="ulink" href="http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip">http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip</a>. Unpack it in the <code class="literal">jtreg/lib</code> folder.</li><li class="listitem">And then, finally, the last dependency, that is <a id="id430" class="indexterm"/><code class="literal">Xalan</code>, the XML transformation library. The required version is 2.7.1, which can be downloaded from one of the websites listed at <a class="ulink" href="http://www.apache.org/dyn/closer.cgi/xml/xalan-j">http://www.apache.org/dyn/closer.cgi/xml/xalan-j</a>. Follow the same procedure that you did with the other libraries and unpack it in the <code class="literal">jtreg/lib</code> folder.</li><li class="listitem">Now, it<a id="id431" class="indexterm"/> is time to write the script that will execute the build. Put the following script code into the <code class="literal">make.sh</code> file of the <code class="literal">jtreg</code> folder, created in the first step:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>export JDK15HOME= /etc/alternatives/java_sdk_1.7.0_openjdk/</strong></span>
<span class="strong"><strong>export JAVAHELP_HOME=/home/user/openjdk/jtreg/lib/jh2.0/javahelp</strong></span>
<span class="strong"><strong>export ANTHOME=/usr/share/ant</strong></span>
<span class="strong"><strong>export JTHARNESS_HOME=/home/user/openjdk/jtreg/lib/jharness4.4.1</strong></span>
<span class="strong"><strong>export JUNIT_JAR=/home/user/openjdk/jtreg/lib/junit4.5/junit-4.5.jar</strong></span>
<span class="strong"><strong>export TESTNG_HOME=/home/user/openjdk/jtreg/lib/testng-6.8</strong></span>
<span class="strong"><strong>export TESTNG_JAR=/home/user/openjdk/jtreg/lib/testng-6.8/testng-6.8.jar</strong></span>
<span class="strong"><strong>export XALANHOME=/home/user/openjdk/jtreg/lib/xalan-j_2_7_1</strong></span>
<span class="strong"><strong>make -C make</strong></span>
</pre></div><p>As you can see, the script is simple and it is only required to set the environment variables. Not much explanation is required, as all the variable names are pretty self-explanatory. So, just assign appropriate values that are relevant for your machine setup. All the variables are mandatory and have to be defined to run the framework.</p></li><li class="listitem">The final<a id="id432" class="indexterm"/> step is to just run that script:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jtreg]$ ./make.sh</strong></span>
</pre></div><p>After the build, which should take just a few seconds, the resulting JAR file can be found in the <code class="literal">build/images/jtreg/</code> folder. This folder will contain a fully workable and self-sufficient jtreg distribution:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jtreg]$ ls -l build/images/jtreg/</strong></span>
<span class="strong"><strong>total 60</strong></span>
<span class="strong"><strong>drwxrwxr-x. 2 user user 4096 May  3 21:27 bin</strong></span>
<span class="strong"><strong>-rw-rw-r--. 1 user user 994 May  3 21:23 COPYRIGHT</strong></span>
<span class="strong"><strong>drwxrwxr-x. 3 user user 4096 May  3 21:23 doc</strong></span>
<span class="strong"><strong>drwxrwxr-x. 4 user user 4096 May  3 21:27 legal</strong></span>
<span class="strong"><strong>drwxrwxr-x. 2 user user 4096 May  3 21:27 lib</strong></span>
<span class="strong"><strong>-rw-rw-r--. 1 user user 19241 May  3 21:27 LICENSE</strong></span>
<span class="strong"><strong>drwxrwxr-x. 3 user user 4096 May  3 21:23 linux</strong></span>
<span class="strong"><strong>-rw-rw-r--. 1 user user 3790 May  3 21:27 README</strong></span>
<span class="strong"><strong>-rw-rw-r--. 1 user user 72 May  3 21:27 release</strong></span>
<span class="strong"><strong>drwxrwxr-x. 3 user user 4096 May  3 21:23 solaris</strong></span>
<span class="strong"><strong>drwxrwxr-x. 3 user user 4096 May  3 21:23 win32</strong></span>
</pre></div></li></ol></div></div></div>
<div class="section" title="Running the standard set of OpenJDK tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec71"/>Running the standard set of OpenJDK tests</h1></div></div></div><p>This recipe is not much different from the one that describes a simple test execution. However, it will focus on how to run JDK tests. This knowledge might be required if someone is making changes to HotSpot or to any other part of OpenJDK.</p><p>Standard tests <a id="id433" class="indexterm"/>are available only in three root folders for JDK7 and in four folders for JDK8. These are <code class="literal">hotspot</code>, <code class="literal">jdk</code>, <code class="literal">langtools</code>, and <code class="literal">nashorn</code> (for jdk8 only). Although tests are not available for other areas such as CORBA, JDBC, JAXP, and so on, it doesn't mean that they are not tested at all. It just means that tests for them are not part of OpenJDK, that is, they are not provided by vendors.</p><p>The way tests are organized varies with the dependency of the area they are testing, for example, <code class="literal">hotspot</code> and <code class="literal">langtools</code> are mostly grouped by functional areas they are testing and, then, by bugs (by their numbers). The <code class="literal">jdk</code> folder is mostly organized by the package name, as this set of tests covers the Java APIs.</p><p>Keep in mind that some tests might fail, but it does not mean that something is particularly wrong with OpenJDK. It just means that there are some situations when it is rather hard to create a test that can pass in any environment. For example, there can be tests that need a special network configuration or some other sort of special environment, which might not be set up on the machine.</p><p>There is a set of tests that are known to fail and there is usually a good reason for that. The most obvious example is a test that covers some known problem, but whose fix is not going to happen soon. These tests are listed in <code class="literal">jdk/test/ProblemList.txt</code> or marked with a <code class="literal">@ignore</code> tag. These tests should usually be excluded from the standard test run.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec235"/>Getting ready</h2></div></div></div><p>As we will be <a id="id434" class="indexterm"/>running tests for OpenJDK, it is required to have relevant sources available on the machine. The machine should also be set up for the OpenJDK build, as we will be using OpenJDK make files to execute the test run.</p><p>jtreg should be downloaded and unpacked in a folder on the machine so that it is ready for the test run.</p><p>Some OpenJDK tests are shell scripts, so you will need to use either a Linux machine or, in the case of a Windows machine, Cygwin with support for the Bourne shell, even though Cygwin is not recommended, as there is a chance that some shell tests will not run properly on it.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec236"/>How to do it...</h2></div></div></div><p>One of the most convenient ways to run tests is to run them separately for each area, such as <code class="literal">hotspot</code>, <code class="literal">jdk</code>, and so on. As the aim of this recipe is to just explain the concept, we will be using the <code class="literal">jdk</code> tests, which are just a subset of all the tests available in OpenJDK, but the same pattern can be applied to all the other areas as well. Follow the given steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the OpenJDK source root folder, create a file with the name, <code class="literal">run_jdk_lang_tests.sh</code> and the following content:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>export JTREG_HOME=/home/user/openjdk/jtreg/build/images/jtreg/</strong></span>
<span class="strong"><strong>export JT_HOME=/home/user/openjdk/jtreg/build/images/jtreg/</strong></span>
<span class="strong"><strong>export PRODUCT_HOME=/home/stas/openjdk/jdk7u_clean/build/linux-amd64/j2sdk-image/</strong></span>
<span class="strong"><strong>cd jdk/test</strong></span>
<span class="strong"><strong>make TESTDIRS=java/lang</strong></span>
</pre></div><p>The <code class="literal">JTREG_HOME</code> and <code class="literal">JT_HOME</code> environment variables are both the same and should point to a folder with jtreg. Unfortunately, there are places in make files where both these variables are used.</p><p><code class="literal">PRODUCT_HOME</code> points to a JDK in the test. It is not strictly required to point it to a version of JDK that was just built from the source, but there is also no sense in executing tests on a version that one can't change.</p><p><code class="literal">TESTDIRS</code> points to a subset of tests to run. Obviously, the wider that subset, the more tests will be executed and the longer it will take to run. So usually it makes sense to limit this subset to something reasonable, unless there is a need to do a regression test after making big changes.</p></li><li class="listitem">Now let's run<a id="id435" class="indexterm"/> the script. It will execute tests in the <code class="literal">jdk</code> folder and output hundreds of lines like these:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>TEST: java/lang/StringBuilder/Insert.java</strong></span>
<span class="strong"><strong>  build: 1.112 seconds</strong></span>
<span class="strong"><strong>  compile: 1.112 seconds</strong></span>
<span class="strong"><strong>  main: 0.161 seconds</strong></span>
<span class="strong"><strong>TEST RESULT: Passed. Execution successful</strong></span>
<span class="strong"><strong>--------------------------------------------------</strong></span>
</pre></div></li><li class="listitem">When it's all finished, the make script will report something as shown:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Summary:</strong></span>
<span class="strong"><strong>TEST STATS: name=  run=383  pass=383  fail=0  excluded=4</strong></span>
<span class="strong"><strong>EXIT CODE: 0</strong></span>
<span class="strong"><strong>EXIT CODE: 0</strong></span>
<span class="strong"><strong>Testing completed successfully</strong></span>
</pre></div></li></ol></div><p>The preceding output tells us how many tests were executed, how many failed, how many passed, and so on. Now, when all the tests that we were interested in are run, the results can be found in the <code class="literal">jdk/build/linux-amd64/testoutput/JTreport</code> folder. There will be standard jtreg text and HTML report files that can be viewed using any web browser.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec237"/>There's more...</h2></div></div></div><p>If someone came<a id="id436" class="indexterm"/> to a point where there was a need to run an OpenJDK test, there is a good chance that there would be a situation when the tests had to be updated or extended. In that case, it is important to have a good understanding of what is going on inside these tests and what is the exact reason for each of them to exist. Mostly, that information is available in the <code class="literal">@bug</code> and <code class="literal">@summary</code> tags. It is highly recommended to pay attention to their content and put in some effort to see how they correlate with actual test code.</p><p>Most of the tests contain additional information in the <code class="literal">@bug</code> and <code class="literal">@summary</code> tags. It is important to refer to these tags to understand the reason for the test. For example, when you run tests, it is not uncommon to see an output like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>--------------------------------------------------</strong></span>
<span class="strong"><strong>TEST: java/lang/invoke/7157574/Test7157574.java</strong></span>
<span class="strong"><strong>  build: 1.194 seconds</strong></span>
<span class="strong"><strong>  compile: 1.193 seconds</strong></span>
<span class="strong"><strong>  main: 0.199 seconds</strong></span>
<span class="strong"><strong>TEST RESULT: Passed. Execution successful</strong></span>
</pre></div><p>It means that this is the test for the bug with ID <code class="literal">7157574</code>, which can actually be found in the JDK bug tracking system<a id="id437" class="indexterm"/> at <a class="ulink" href="https://bugs.openjdk.java.net/browse/JDK-7157574">https://bugs.openjdk.java.net/browse/JDK-7157574</a>. And, when one takes a look at the test, the following information will be in the header:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/* @test</strong></span>
<span class="strong"><strong> * @bug 7157574</strong></span>
<span class="strong"><strong> * @summary method handles returned by reflective lookup API sometimes have wrong receiver type</strong></span>
<span class="strong"><strong> *</strong></span>
<span class="strong"><strong> * @run main Test7157574</strong></span>
<span class="strong"><strong> */</strong></span>
</pre></div><p>This header has a reference to the bug that this test is testing and, in the summary section, it explains exactly what this test is doing. Also, when you look at the source of a test, it is quite common to see that it contains a very detailed explanation of the problem and the way that the problem is being tested.</p></div></div>
<div class="section" title="Writing your own test for jtreg"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Writing your own test for jtreg</h1></div></div></div><p>If you <a id="id438" class="indexterm"/>are going to add a new feature to OpenJDK or fix a bug, it is really a good idea to have a test case to cover the change in functionality and to ensure that<a id="id439" class="indexterm"/> the implementation change doesn't break anything. This recipe will help you to get some understanding of the process and create a simple test. You will find that writing your own test case for jtreg is not a complicated task, but it can be slightly unusual in some respects.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec238"/>Getting ready</h2></div></div></div><p>All that is required for this recipe is an installed jtreg and the OpenJDK sources. The latter is required only because this recipe assumes that the newly created test is for OpenJDK.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec239"/>How to do it...</h2></div></div></div><p>Writing tests for jtreg can be a little unusual, but when you get used to the pattern it is actually quite easy. To begin, just follow the steps. Keep in mind that all the paths are given relative to the OpenJDK source root:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the root folder of OpenJDK and create the <code class="literal">jdk/test/demo/SampleTest.java</code> file first:<div class="informalexample"><pre class="programlisting">/* @test
 * @summary Test to ensure that computer wasn't moved to the past
 * @compile SampleTimeProvider.java
 * @run main SampleTest
 * @run main/othervm SampleTest
 */
public class SampleTest {
    public static void main(String[] args) {
        long currentTime = new SampleTimeProvider().getCurrentTime();
        if ( currentTime &lt; 0 ) {
            throw new RuntimeException("It can't be 1969!");
        }
    }
}</pre></div></li><li class="listitem">Then, create the <code class="literal">jdk/test/demo/SampleTimeProvider.java</code> file as follows:<div class="informalexample"><pre class="programlisting">public class SampleTimeProvider {
    public long getCurrentTime() {
        return System.currentTimeMillis();
    }
}</pre></div></li><li class="listitem">Now, create a script file with the name, <code class="literal">run_jtreg.sh</code> in the source root folder of JDK and run it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>export JT_JAVA=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64</strong></span>
<span class="strong"><strong>/home/user/openjdk/jtreg/build/images/jtreg/bin/jtreg -jdk:$JT_JAVA -agentvm -automatic -verbose:summary -w build/jtreg/work -r build/jtreg/report -exclude:./jdk/test/ProblemList.txt jdk/test/demo/SampleTest.java</strong></span>
</pre></div></li><li class="listitem">The <a id="id440" class="indexterm"/>output <a id="id441" class="indexterm"/>should be as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jdk7u]$ ./run_jtreg.sh </strong></span>
<span class="strong"><strong>Directory "build/jtreg/work" not found: creating</strong></span>
<span class="strong"><strong>Directory "build/jtreg/report" not found: creating </strong></span>
<span class="strong"><strong>Passed: demo/SampleTest.java</strong></span>
<span class="strong"><strong>Test results: passed: 1</strong></span>
<span class="strong"><strong>Report written to /home/user/openjdk/jdk7u/build/jtreg/report/html/report.html</strong></span>
<span class="strong"><strong>Results written to /home/user/openjdk/jdk7u/build/jtreg/work</strong></span>
</pre></div><p>As you can see, only one test was run and the run was successful. So, writing a simple test case is a very simple task.</p></li><li class="listitem">Now, the final step. After all the tests have been run, let's look at the test result whose path was provided in the output of jtreg. Let's open <code class="literal">report/html/repost.html</code> in a web browser and take a look at what's there:<div class="mediaobject"><img src="graphics/8405OT_09_01.jpg" alt="How to do it..."/></div><p>Here, we<a id="id442" class="indexterm"/> can <a id="id443" class="indexterm"/>see that only one test, <span class="strong"><strong>demo/SampleTest.java</strong></span>, was executed and it was the one that passed.</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec240"/>How it works…</h2></div></div></div><p>Some explanation is required to find out what actually happened. The test itself is in the <code class="literal">SampleTest.java</code> file. jtreg knows that the file contains the test by the presence of the <code class="literal">@test</code> tag<a id="id444" class="indexterm"/> in the class header comments. Without that tag, jtreg will not consider it as a test.</p><p>The only purpose <a id="id445" class="indexterm"/>of the <code class="literal">@summary</code> tag is to give a summary description for the test. This description will also be used in logs and reports. It is very important to<a id="id446" class="indexterm"/> have a good, readable description for that tag. Also, if a test is for a bug, it is necessary to have the <code class="literal">@bug</code> tag<a id="id447" class="indexterm"/> populated with an appropriate bug number.</p><p>The next tag, <code class="literal">@compile</code>, has<a id="id448" class="indexterm"/> a reference to another file, which is required to be compiled to run the test. The only reason for the existence of <code class="literal">SampleTimeProvider.java</code> is to show how to use the <code class="literal">@compile</code> tag. It is very unusual for Java to do things like this. Usually, everything is compiled and then things are picked from the classpath, but this is the way Java works.</p><p>The <code class="literal">@run</code> tag<a id="id449" class="indexterm"/> tells the harness how to run the test. As can be seen from the test class, this parameter can be defined several times, which means that the test will also be executed several times and each time it will be run with a configuration defined by the associated run tag. In our example, there are two runs, one in the same VM and the other in a new instance of VM, which is specified by the <code class="literal">othervm</code> parameter. If this tag is not defined, then, by default, jtreg assumes that it is <code class="literal">@run main ClassName</code>.</p><p>Note that a test fails if it runs for longer than 2 minutes (120 seconds) and can be overwritten by <code class="literal">@run main/timeout=xxx</code>.</p><p>Usually, a test indicates its failure by throwing an exception. A test from this recipe will throw <code class="literal">RuntimeException</code> when its conditions are not met.</p><p>jtreg requires the <code class="literal">TEST.ROOT</code> file to be created in the tests' root folder. Without that file, it will not execute any test. Luckily for us, JDK already has the required file with the appropriate content, so there is no need for us to worry about it.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec241"/>See also</h2></div></div></div><p>jtreg test cases are defined by the Javadoc tags and it is useful to be familiar with all of them. The complete list of tags and information about each tag is available either in the help file that can be accessed by running the jtreg command, <code class="literal">–onlineHelp</code>, or online at <a class="ulink" href="http://openjdk.java.net/jtreg/tag-spec.html">http://openjdk.java.net/jtreg/tag-spec.html</a>.</p></div></div>
<div class="section" title="Using jtreg in GUI mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec73"/>Using jtreg in GUI mode</h1></div></div></div><p>jtreg is not <a id="id450" class="indexterm"/>only a command-line tool, but it also provides a relatively sophisticated graphical interface that allows you to run an individual set of tests, prepare test runs, see results of the run, and so on. This recipe will cover some basic features of UI that are enough for the user to start using the tool.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec242"/>Getting ready</h2></div></div></div><p>All that is required for this recipe is an installed jtreg and the OpenJDK sources.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec243"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the following script that will launch jtreg with a graphical UI:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>export JT_JAVA=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64</strong></span>
<span class="strong"><strong>/home/user/openjdk/jtreg/build/images/jtreg/bin/jtreg –g -jdk:$JT_JAVA -agentvm -automatic -verbose:summary -w build/jtreg/work -r build/jtreg/report -exclude:./jdk/test/ProblemList.txt jdk/test/</strong></span>
</pre></div><p>The parameter that tells jtreg to launch JT Harness UI is <code class="literal">-g</code>. After it is launched, jtreg displays a window similar to the following one:</p><div class="mediaobject"><img src="graphics/8405OT_09_02.jpg" alt="How to do it..."/></div></li><li class="listitem">On the<a id="id451" class="indexterm"/> right-hand side of the preceding screenshot, you can see the results of the latest test run. It knows where to pick them up from the <code class="literal">–r</code> parameter. In this screenshot, you can also see the number of successful and failed tests, the total number of executed tests, and some other stats.</li><li class="listitem">On the left-hand side of the preceding screenshot, there is a tree with all the available tests. This shows all the tests from the root of the test bundle, which is the folder with the <code class="literal">TEST.ROOT</code> configuration file. The green folder icon indicates the tests that ran successfully and the red one indicates the ones that failed.</li><li class="listitem">To run a specific test from a set of tests, right-click on the individual test folder and select the <span class="strong"><strong>Execute these test</strong></span> item from the pop-up menu. This will trigger the test run and a new report will be generated. For long running tests, there is a status window, which is available via the <span class="strong"><strong>Run Tests</strong></span> | <span class="strong"><strong>Monitor Progress</strong></span> menu item:<div class="mediaobject"><img src="graphics/8405OT_09_03.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec244"/>How it works…</h2></div></div></div><p>The UI that is<a id="id452" class="indexterm"/> used by jtreg does not actually belong to jtreg. It is provided by JT Harness and jtreg just integrates it using the provided plugin system.</p><p>JT Harness provides a rich interface not only to run tests, but it also has a set of wizards to create test configurations, various report conversion tools, an agent monitoring tool, and so on. To get more information about all these features, refer to JT Harness online help, which is available via the <span class="strong"><strong>Help/Online Help</strong></span> menu item.</p></div></div>
<div class="section" title="Writing TestNG tests for jtreg"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec74"/>Writing TestNG tests for jtreg</h1></div></div></div><p>jtreg also <a id="id453" class="indexterm"/>provides support to run TestNG test cases, which<a id="id454" class="indexterm"/> might be a more familiar technique for many developers. There are some steps that need to be performed to make it happen and this recipe will go through them.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec245"/>Getting ready</h2></div></div></div><p>This recipe will require the OpenJDK source code and an installed version of jtreg. On a Windows machine, it is also required to have Cygwin installed.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec246"/>How to do it...</h2></div></div></div><p>The following <a id="id455" class="indexterm"/>procedure should be more familiar to Java developers than writing a native jtreg test, as TestNG is what most developers have heard of and used. Now, let's get to the practical part and create a test. The paths are relative to the OpenJDK source root.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Relative to <a id="id456" class="indexterm"/>the OpenJDK root folder, create a folder with the name, <code class="literal">jdk/test/testng/org/demo</code>. This is the folder where we are going to create our tests.</li><li class="listitem">Create the file, <code class="literal">jdk/test/testng/TEST.properties</code>, relative to the OpenJDK source root. Add the following line there:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>TestNG.dirs=.</strong></span>
</pre></div><p>It is not strictly required to create the file, and it is also possible to define the property in <code class="literal">jdk/test/TEST.ROOT</code>, which will work in the same way as our previous property. However, in most cases, it is practical to have that file so that it can contain some additional configuration that is specific to the set of TestNG tests, for example, the <code class="literal">lib.dirs</code> property.</p></li><li class="listitem">In the <code class="literal">jdk/test/testng/org/mydemo</code> folder, create the following file with the name, <code class="literal">MyTestNGTest.java</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>package org.mydemo;</strong></span>

<span class="strong"><strong>import org.testng.Assert;</strong></span>
<span class="strong"><strong>import org.testng.annotations.Test;</strong></span>

<span class="strong"><strong>public class MyTestNGTest {</strong></span>
<span class="strong"><strong>    @Test</strong></span>
<span class="strong"><strong>    public void testMoreNanosThanMillis() {</strong></span>
<span class="strong"><strong>        final long nanos = System.nanoTime();</strong></span>
<span class="strong"><strong>        final long millis = System.currentTimeMillis();</strong></span>
<span class="strong"><strong>        Assert.assertTrue(nanos &gt; millis);</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li><li class="listitem">Now, in OpenJDK's source root folder, create the following bash script (fix the paths<a id="id457" class="indexterm"/> as required to match the machine environment):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>export JT_JAVA=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64</strong></span>
<span class="strong"><strong>/home/user/openjdk/jtreg/build/images/jtreg/bin/jtreg -jdk:$JT_JAVA -agentvm -automatic -verbose:summary -w build/jtreg/work -r build/jtreg/report -exclude:./jdk/test/ProblemList.txt jdk/test/testng</strong></span>
</pre></div></li><li class="listitem">Then, give<a id="id458" class="indexterm"/> it a name, <code class="literal">./run_jtreg.sh</code>, and make it executable (running <code class="literal">chmod +x ./run_jterg.sh</code> will do the job) and run it. The resulting output of the script should look similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jdk7u]$ ./run_jtreg.sh </strong></span>
<span class="strong"><strong>Passed: testng/org/mydemo/MyTestNGTest.java</strong></span>
<span class="strong"><strong>Test results: passed: 1</strong></span>
<span class="strong"><strong>Report written to /home/user/openjdk/jdk7u/build/jtreg/report/html/report.html</strong></span>
<span class="strong"><strong>Results written to /home/user/openjdk/jdk7u/build/jtreg/work</strong></span>
</pre></div></li></ol></div><p>And that's it. The test has been run and, as can be seen from the output, it has passed. The result of the run can be seen by opening <code class="literal">/home/user/openjdk/jdk7u/build/jtreg/report/html/report.html</code> in the browser application.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec247"/>How it works…</h2></div></div></div><p>The file named <code class="literal">TEST.properties</code> that is created in the folder with the tests root package, requires a bit of explanation. This is the file that contains sets of configurations specific to the TestNG tests in the folder where the file is located. For example, it can have a reference to folders with libraries via the <code class="literal">lib.dirs</code> property. That is the <code class="literal">path</code> type property, which is the same as <code class="literal">TestNG.dirs</code>, and such properties are space-separated lists of paths to some of the folders or files. If the path in the list starts with <code class="literal">/</code>, then it is evaluated relative to a folder with <code class="literal">TEST.ROOT</code>, otherwise it is evaluated from the directory containing <code class="literal">TEST.properties</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec248"/>See also</h2></div></div></div><p>As it is possible to use the TestNG annotations within the test classes, it is worth checking the TestNG website, which contains some documentation on this topic at <a class="ulink" href="http://testng.org/doc/documentation-main.html">http://testng.org/doc/documentation-main.html</a>.</p><p>It is also possible to use the jtreg style tags and the TestNG style test together. In that case, the test should be created as a normal jtreg test (see the <span class="emphasis"><em>Writing your own test for jtreg</em></span> recipe), using <code class="literal">testng</code> as the argument for <code class="literal">@run</code>, for example, <code class="literal">@run testng SampleTest</code>. In this scenario, there is no need for <code class="literal">TEST.properties</code> and things like <code class="literal">lib.dirs</code> are defined in the test source file via the jtreg tags, rather than in a separate configuration file.</p></div></div>
<div class="section" title="Compiling JT Harness from the source code"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Compiling JT Harness from the source code</h1></div></div></div><p>JT Harness <a id="id459" class="indexterm"/>is a framework that allows you to execute different sets of tests. It is not necessary to use it only with jtreg. Other testing frameworks can be integrated with it as well. This means that it could be useful to have its source code to be able to build it from the source. This is exactly what this recipe is going to explain.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec249"/>Getting ready</h2></div></div></div><p>You will need Internet access to download the source code and install the additional software that is required for the build.</p><p>Ensure that Ant version 1.6.1 or later is installed on the machine. If not, then install it. The <span class="emphasis"><em>How to do it...</em></span> section depends on the OS you are using. For example, on Fedora, that will be:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>yum install ant</strong></span>
</pre></div><p>On Windows, the simplest way would be to just download the distribution and add Ant's <code class="literal">bin</code> folder to the <code class="literal">PATH</code> environment variable. The Ant distribution can be found at <a class="ulink" href="http://ant.apache.org/">http://ant.apache.org/</a>. Keep in mind that, to make it work, the <code class="literal">JAVA_HOME</code> environment variable has to contain the correct path of the Java distribution.</p><p>Ensure that Subversion is installed on the machine. In contrast to other tools, JT Harness doesn't use the Mercurial repository for its source code. On Fedora, Subversion can be installed by running <code class="literal">yum</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>yum install svn</strong></span>
</pre></div><p>On any other OS, it really depends on the OS. Check <a class="ulink" href="http://subversion.apache.org/">http://subversion.apache.org/</a> to find out what is available.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec250"/>How to do it...</h2></div></div></div><p>Run the following command to check the source code:</p><div class="informalexample"><pre class="programlisting">svn checkout https://svn.java.net/svn/jtharness~svn/trunk jtharness</pre></div><p>This command <a id="id460" class="indexterm"/>will create a folder with the name, <code class="literal">jtharness</code>, and download the source code. In that folder, create another folder and name it, <code class="literal">lib</code>. Here we will put the libraries required to build JT Harness.</p><p>Now download the following software (all paths are given relative to the <code class="literal">jtharness</code> folder):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">JavaHelp seems to be available only via a direct link from <a class="ulink" href="http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip">http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip</a>. Unpack it into <code class="literal">lib/jh2.0</code>.</li><li class="listitem">Go to <a class="ulink" href="http://asm.ow2.org/">http://asm.ow2.org/</a> and download the ASM Java bytecode manipulation library binaries version 3.1. Unpack the archive into <code class="literal">lib/asm-3.1</code>. This is required only for compilation.</li><li class="listitem">Next, the required library is <code class="literal">Java Communications API</code>. Go to <a class="ulink" href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html">http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html</a> and download <code class="literal">Java Communications API 3.0u1</code> or any other higher version that is available. Unpack the archive into <code class="literal">lib/commapi</code>. This is required only for compilation.</li><li class="listitem">Java Servlet APIs are only required for compilation. Probably the simplest way to download them is to get the JAR from Maven Central. Go to <a class="ulink" href="http://search.maven.org/">http://search.maven.org/</a> and search for <code class="literal">javax.servlet servlet-api</code>. Download the JAR v.3.1.0 and put it directly into the <code class="literal">lib</code> folder.</li><li class="listitem">The last one is JUnit, which is also only required for compilation. The recommended version is 4.4. Go to <a class="ulink" href="http://junit.org/">http://junit.org/</a>and click on the <span class="strong"><strong>Download</strong></span> link to download the appropriate version of the JAR file. Place it directly into the <code class="literal">lib</code> folder.</li><li class="listitem">The next step is to get the sources. To do this, run the following command that will get the latest sources from the trunk:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>svn checkout https://svn.java.net/svn/jtharness~svn/trunk jtharness</strong></span>
</pre></div><p>This will create the folder, <code class="literal">jtharness</code>, with two subfolders: <code class="literal">www</code> and <code class="literal">code</code>. The <code class="literal">www</code> folder contains pages with links to the documentation and other useful information, but we are really interested in the folder with the name code. It is actually not strictly necessary to download <code class="literal">www</code> at all, but it doesn't do any harm either.</p></li><li class="listitem">Go to the<a id="id461" class="indexterm"/> folder, <code class="literal">jtharness/code/build</code>, locate the file <code class="literal">local.properties</code>, and edit it to set the following properties to point to the appropriate locations:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">jhalljar</code>: This<a id="id462" class="indexterm"/> provides the path to the JavaHelp <code class="literal">jhalljar.jar</code> file</li><li class="listitem" style="list-style-type: disc"><code class="literal">jhjar</code>: This <a id="id463" class="indexterm"/>property provides the path to the JavaHelp <code class="literal">jhjar.jar</code> file</li><li class="listitem" style="list-style-type: disc"><code class="literal">jcommjar</code>: This<a id="id464" class="indexterm"/> provides the path to <code class="literal">comm.jar</code> from the <code class="literal">Java Communications API</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">servletjar</code>: This<a id="id465" class="indexterm"/> provides the path to the <code class="literal">servlet-api.jar</code> file from <code class="literal">Java Servlet API</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">bytecodelib</code>: This<a id="id466" class="indexterm"/> provides a colon-separated path to the <code class="literal">asm-3.1.jar</code> and <code class="literal">asm-commons-3.1.jar</code> files</li><li class="listitem" style="list-style-type: disc"><code class="literal">junitlib</code>: This <a id="id467" class="indexterm"/>provides the path to <code class="literal">junit-4.4.jar</code> from jUnit</li></ul></div><p>After the editing, the file should look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#Please specify location of jhall.jar here - for compilation</strong></span>
<span class="strong"><strong>jhalljar = /home/user/openjdk/jtharness/lib/jh2.0/javahelp/lib/jhall.jar</strong></span>
<span class="strong"><strong># needed only at runtime</strong></span>
<span class="strong"><strong>jhjar = /home/user/openjdk/jtharness/lib/jh2.0/javahelp/lib/jh.jar</strong></span>
<span class="strong"><strong># location of jar with implementation of java serial communications API</strong></span>
<span class="strong"><strong>jcommjar = /home/user/openjdk/jtharness/lib/commapi/jar/comm.jar</strong></span>
<span class="strong"><strong># location of jar with servlet API implementation</strong></span>
<span class="strong"><strong>servletjar = /home/user/openjdk/jtharness/lib/javax.servlet-api-3.1.0.jar</strong></span>
<span class="strong"><strong># bytecode library (BCEL or ASM)</strong></span>
<span class="strong"><strong># these are not interchangable</strong></span>
<span class="strong"><strong>bytecodelib = /home/user/openjdk/jtharness/lib/asm-3.1/lib/asm-3.1.jar:/home/stas/openjdk/jtharness/lib/asm-3.1/lib/asm-commons-3.1.jar</strong></span>
<span class="strong"><strong># JUnit Library - Version 4 currently used to compile 3 and 4 support</strong></span>
<span class="strong"><strong>junitlib = /home/user/openjdk/jtharness/lib/junit-4.4.jar</strong></span>
<span class="strong"><strong># Please specify location where the build distribution (output) will be created</strong></span>
<span class="strong"><strong>BUILD_DIR = ../JTHarness-build</strong></span>
</pre></div><p>If it is required, the <code class="literal">BUILD_DIR</code> variable can be changed to a different folder but, usually it is not necessary.</p></li><li class="listitem">Now ensure <a id="id468" class="indexterm"/>that the current folder is <code class="literal">jtharness/code/build</code> and run Ant:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[stas@localhost build]$ ant</strong></span>
<span class="strong"><strong>Buildfile: /home/user/openjdk/jtharness/code/build/build.xml</strong></span>
<span class="strong"><strong> …skipped…</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong>Total time: 45 seconds</strong></span>
<span class="strong"><strong>When build is finished</strong></span>
</pre></div><p>When the build is finished, the folder, <code class="literal">jtharness/JTHarness-build/binaries</code>, contains the distribution of JT Harness.</p></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec251"/>See also</h2></div></div></div><p>There are other targets available in the JT Harness build file that you may find useful:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">run</code>: This<a id="id469" class="indexterm"/> builds and runs JT Harness. This is not the only way to launch the application. The other option is to run the following command from the source root folder after the build:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -jar JTHarness-build/binaries/lib/javatest.jar</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">clean</code>: This <a id="id470" class="indexterm"/>just builds the distribution directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">build</code>: This <a id="id471" class="indexterm"/>builds JT Harness and then runs all the tests.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test</code>: This <a id="id472" class="indexterm"/>just runs the test.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Javadoc</code>: This <a id="id473" class="indexterm"/>generates the Javadoc API documentation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">build-examples</code>: This<a id="id474" class="indexterm"/> builds the example test suites packaged with the source. This target also automatically builds the core harness first.</li></ul></div></div></div>
<div class="section" title="Building and running jcstress"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Building and running jcstress</h1></div></div></div><p>The <span class="strong"><strong>Java Concurrency Stress Test</strong></span> (<span class="strong"><strong>jcstress</strong></span>) is<a id="id475" class="indexterm"/> a set of tests for testing the correctness of the Java concurrency support. This is a new tool that is mostly targeted to Java 8, which means that not all the tests will run on previous versions of Java. As a new tool, jcstress is in its alpha phase and changes for fixes and improvements are common, which means that whoever is working with it is expected to update the source code and rebuild the tool relatively often.</p><p>Testing concurrency is not an easy task and it may or may not be easy to make such tests fail even with incorrect code. This happens due to the nature of concurrent code, which might work differently on different hardware configurations. Such variations arise from the number of CPUs or the CPU architecture. Overall, this means that many tests in jcstress are uncertain and they might require a long time before exposing potential problems.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec252"/>Getting ready</h2></div></div></div><p>You will need <a id="id476" class="indexterm"/>Internet access and the Mercurial repository to download the source code. As jcstress requires Java 8 for compilation and to run the full set of tests, it has to be installed on the machine and set as the current version. This means that the following commands should, as illustrated next, show Java 1.8 as the major version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost]$ java -version</strong></span>
<span class="strong"><strong>openjdk version "1.8.0_11"</strong></span>
<span class="strong"><strong>OpenJDK Runtime Environment (build 1.8.0_11-b12)</strong></span>
<span class="strong"><strong>OpenJDK 64-Bit Server VM (build 25.11-b02, mixed mode)</strong></span>
<span class="strong"><strong>[user@localhost jcstress]$ javac -version</strong></span>
<span class="strong"><strong>javac 1.8.0_11</strong></span>
</pre></div><p>The build will also require Maven (one of the Java build tools) to be installed on the machine. The installation of this tool depends on the OS. For example, on Fedora, this can be done by running the following command as root:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@localhost ~]# yum install maven</strong></span>
</pre></div><p>On other OSs, the simplest way might be to download the binary from <a class="ulink" href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a>, unpack the archive, point <code class="literal">M2_HOME</code> to the root of the unpacked folder and add <code class="literal">M2_HOME/bin</code> to the path.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec253"/>How to do it…</h2></div></div></div><p>Now it's time for action. The first few steps of this recipe will cover the build process and then it will switch to run the actual tests:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is to download the sources. Go to the folder where you want to store the source code and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost ~]$ hg clone http://hg.openjdk.java.net/code-tools/jcstress/ jcstress</strong></span>
</pre></div><p>When this<a id="id477" class="indexterm"/> command is run, Mercurial is downloaded along with the source code from the remote repository and it is stored in the folder, <code class="literal">jcstress</code>.</p></li><li class="listitem">Now, to build the tool, move to the folder <code class="literal">jcstress</code> and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jcstress]$ mvn clean install -pl tests-custom –am</strong></span>
</pre></div><p>If successful, it should display something like this as the end:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INFO] BUILD SUCCESS</strong></span>
<span class="strong"><strong>[INFO] ----------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Total time: 1:31.300s</strong></span>
<span class="strong"><strong>[INFO] Finished at: Tue Jul 29 22:23:19 BST 2014</strong></span>
<span class="strong"><strong>[INFO] Final Memory: 37M/410M</strong></span>
<span class="strong"><strong>[INFO] ----------------------------------------------------</strong></span>
</pre></div><p>This means that the build has done what it was supposed to do and the tests are ready to be run.</p></li><li class="listitem">To run all the<a id="id478" class="indexterm"/> tests, use the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -jar tests-custom/target/jcstress.jar</strong></span>
</pre></div><p>This will output thousands of lines like these:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(ETA:   00:39:58) (R: 1.36E+07) (T:  46/898) (F: 1/1) (I: 3/5)       [OK] o.o.j.t.atomicity.primitives.plain.VolatileCharAtomicityTest</strong></span>
<span class="strong"><strong>(ETA:   00:40:05) (R: 1.36E+07) (T:  46/898) (F: 1/1) (I: 3/5)       [OK] o.o.j.t.atomicity.primitives.plain.VolatileDoubleAtomicityTest</strong></span>
</pre></div><p><code class="literal">ETA</code> is the estimated completion time, <code class="literal">R</code> is the runtime in nanoseconds, <code class="literal">T</code> is the test number, <code class="literal">F</code> is the fork number, and <code class="literal">I</code> is the test iteration number. This is all followed by the result (<code class="literal">OK</code> in this example) and the full name of the test class.</p></li></ol></div><p>As you can see, the full standard set of tests run for approximately 40 minutes, and this might be too much, so there is an option to select which test to run using the <code class="literal">-t</code> parameter. This is a regular expression selected for the tests, for example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jcstress]$ java -jar tests-custom/target/jcstress.jar -t ".*ByteBufferAtomicityTests.*"</strong></span>
</pre></div><p>This will only run tests which have <code class="literal">ByteBufferAtomicityTests</code> anywhere in their name.</p><p>When the tests are <a id="id479" class="indexterm"/>completed, it is time to have a look at the reports that are generated and, by default, they are put into the <code class="literal">./results/</code> folder. There you can find the file, <code class="literal">index.html</code>, which can be opened with any browser. The result will list all the tests and, if you click on the tests, all the observer outputs. These outputs can be something that is expected, not expected, or expected but somehow surprising to the user. This can result in the following outcomes for a test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FAILED</code>: The test failed and the outcomes were not what was expected</li><li class="listitem" style="list-style-type: disc"><code class="literal">ERROR</code>: The test crashed</li><li class="listitem" style="list-style-type: disc"><code class="literal">ACCEPTABLE</code>: The test results matched the specifications</li><li class="listitem" style="list-style-type: disc"><code class="literal">ACCEPTABLE_INTERESTING</code>: This is the same as <code class="literal">ACCEPTABLE</code>, but it has something to highlight</li><li class="listitem" style="list-style-type: disc"><code class="literal">ACCEPTABLE_SPEC</code>: This is the same as <code class="literal">ACCEPTABLE</code>, but some interesting behavior is also observed that might not be otherwise expected</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec254"/>There's more...</h2></div></div></div><p>It is recommended that you have a look at the other command-line options that are available for jcstress. This information can be retrieved by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jcstress]$ java -jar tests-custom/target/jcstress.jar –h</strong></span>
</pre></div><p>jcstress has its own page at <a class="ulink" href="http://openjdk.java.net/">http://openjdk.java.net/</a>, which has some very useful information and links to the source and mailing list at <a class="ulink" href="http://openjdk.java.net/projects/code-tools/jcstress/">http://openjdk.java.net/projects/code-tools/jcstress/</a>.</p></div></div>
<div class="section" title="Writing tests for jcstress"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Writing tests for jcstress</h1></div></div></div><p>The<a id="id480" class="indexterm"/> <span class="strong"><strong>Java Concurrency Stress test</strong></span> is a wonderful tool that is used by JDK authors to ensure that their concurrent code works correctly with regards to concurrency. Concurrent code is hard to write and even harder to test. Most of their tests are probabilistic, require a lot of skill to write, and might take many days running time and the appropriate hardware to exhibit the fail behavior. Considering all this complexity, having a framework that can help with correct test execution is a big advantage. This recipe will go through the steps that are required to write your own tests for jcstress.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec255"/>Getting ready</h2></div></div></div><p>To follow this recipe, the only requirement is to have an environment that is capable of compiling and running jcstress (see the <span class="emphasis"><em>Building and running jcstress</em></span> recipe).</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec256"/>How to do it…</h2></div></div></div><p>The following steps will lead you through the process of creating a test and running it using jcstress:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start, we will need a code to test. Let's pick the problem which, arguably, is the most common cause of headaches in concurrency and is very easy to reproduce. Data race sounds like a good candidate. We will make a class called <code class="literal">CASValue</code> and implement it:<div class="informalexample"><pre class="programlisting">package org.openjdk.jcstress.tests;

public class CASValue {
    private int i = 0;
    public boolean cas(int expected, int newValue) {
        boolean res = false;
        if (i == expected) {
            i = newValue;
            res = true;
        }
        return res;
    }
}</pre></div><p>This class implements a single operation which is supposed to perform the compare-and-swap operation (see <a class="ulink" href="http://en.wikipedia.org/wiki/Compare-and-swap">http://en.wikipedia.org/wiki/Compare-and-swap</a>). Without synchronization, it will not work correctly in a multithreaded environment and should fail the test that we will create in the next steps of this recipe.</p></li><li class="listitem">In the source root folder of jcstress, create the file, <code class="literal">tests-custom/src/main/java/org/openjdk/jcstress/tests/CASValue.java</code>, and put the source code of the <code class="literal">CASValue</code> class in it.</li><li class="listitem">Now it's time<a id="id481" class="indexterm"/> to write a test to see whether our implementation is wrong. The test class will look like this:<div class="informalexample"><pre class="programlisting">package org.openjdk.jcstress.tests;

import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.LongResult2;

public class CASValueTests {
    @State
    public static class S extends CASValue { }

    @JCStressTest
    @Description("Tests correctness of CASValue CAS operations.")
    @Outcome(id = "[5,2]", expect = Expect.ACCEPTABLE, desc = "T1 -&gt; T2 execution.")
    @Outcome(id = "[1,10]", expect = Expect.ACCEPTABLE, desc = "T1 -&gt; T2 execution.")
    public static class ValCas_ValCas {
        @Actor public void actor1(S s, LongResult2 r) { 
            r.r1 = s.cas(0, 5) ? 5 : 1; 
        }
        @Actor public void actor2(S s, LongResult2 r) { 
            r.r2 = s.cas(0, 10) ? 10 : 2;
        }
    }
}</pre></div></li><li class="listitem">Save this file in the same folder as <code class="literal">CASValue.java</code>, that is, in <code class="literal">tests-custom/src/main/java/org/openjdk/jcstress/tests/</code>, and give it the name, <code class="literal">CASValueTests.java</code>.</li><li class="listitem">The <code class="literal">CASValueTests</code> class is the container class for other classes within the test. This is not strictly required, but it helps to keep the code clean. The <code class="literal">ValCas_ValCas</code> class, which is annotated with <code class="literal">@JCStressTest</code>, is the test case class that contains two actors—methods annotated with <code class="literal">@Actor</code>. These are the methods that will be run in parallel by the test framework.</li><li class="listitem">The subclass <code class="literal">S</code>, annotated with <code class="literal">@State</code>, is the state that was shared among the actors and, in this case, is the class under test. It extends our class, <code class="literal">CASValue</code>, and is created solely to avoid adding the <code class="literal">@State</code> annotation on <code class="literal">CASValue</code>.</li><li class="listitem">The <code class="literal">@Outcome</code> annotations specify the outcomes of the test. The outcomes can be <code class="literal">ACCEPTABLE</code>, <code class="literal">FORBIDDEN</code>, <code class="literal">ACCEPTABLE_INTERESTING</code>, and <code class="literal">ACCEPTABLE_SPEC</code>. These are defined by the <code class="literal">expect</code> attribute. The <code class="literal">id</code> attribute provides the list of outcomes, whereas <code class="literal">desc</code> is just a description of the outcome. This test case specifies that, for our test, the only valid outcomes for the values in <code class="literal">LongResul2</code> are <code class="literal">5</code> and <code class="literal">2</code> and <code class="literal">1</code> and <code class="literal">10</code>, which are the only expected ones if CAS works as expected. Any other outcomes are forbidden and will cause the test case to fail, which is exactly what we want.</li><li class="listitem">Now it's time<a id="id482" class="indexterm"/> to compile the test. To do this, run the following command from the source root directory of jcstress:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jcstress] mvn clean install -pl tests-custom –am</strong></span>
</pre></div><p>This will just run the build for the <code class="literal">tests-custom</code> project, which will compile the classes that we have just created.</p></li><li class="listitem">The next step is to run our test and see if it works:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost jcstress] java -jar tests-custom/target/jcstress.jar -t ".*CASValueTests.*"</strong></span>
</pre></div><p>The <code class="literal">-t</code> parameter in this command specifies that we only want to run the tests that satisfy the <code class="literal">.*CASValueTests.*</code> regular expression.</p><p>As expected, the tests should fail, as the provided implementation does implement the CAS operation correctly. The output should have several test outcomes similar to this one:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(ETA:        n/a) (R: 5.95E+08) (T:   1/1) (F: 1/1) (I: 1/5)   [FAILED] o.o.j.t.CASValueTests$ValCas_ValCas</strong></span>
<span class="strong"><strong>Observed state  Occurrences Expectation Interpretation</strong></span>
<span class="strong"><strong>[5, 2]  (3,230,666)        ACCEPTABLE T1 -&gt; T2 execution.</strong></span>
<span class="strong"><strong>[1, 10] (2,613,825)        ACCEPTABLE T2 -&gt; T1 execution.</strong></span>
<span class="strong"><strong>[5, 10] (7,609,449)        FORBIDDEN Other cases are not expected.</strong></span>
</pre></div><p>It shows how many outputs of each outcome were observed. So far, the incorrect outcome <code class="literal">[5, 10]</code> is the leader with <code class="literal">7,609,449</code> occurrences. This shows that the test worked correctly and helped us to identify that we need to fix our implementation on the CAS class.</p></li><li class="listitem">Now let's fix our class and run the test again. The easiest, though not the most efficient, way to fix the problem is to simply add the <code class="literal">synchronized</code> modifier to our CAS method:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>public class CASValue {</strong></span>
<span class="strong"><strong>    private int i = 0;</strong></span>
<span class="strong"><strong>    public synchronized boolean cas(int expected, int newValue) {</strong></span>
<span class="strong"><strong>        boolean res = false;</strong></span>
<span class="strong"><strong>        if (i == expected) {</strong></span>
<span class="strong"><strong>            i = newValue;</strong></span>
<span class="strong"><strong>            res = true;</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>        return res;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li><li class="listitem">After <a id="id483" class="indexterm"/>changing the implementation, run the build again:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install -pl tests-custom –am</strong></span>
</pre></div></li><li class="listitem">Then, rerun the test:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -jar tests-custom/target/jcstress.jar -t ".*CASValueTests.*"</strong></span>
</pre></div></li><li class="listitem">Now, the test should not show any failures and report that the test runs were successful:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(ETA: n/a) (R: 3.35E+08) (T:   1/1) (F: 1/1) (I: 1/5) [OK] o.o.j.t.CASValueTests$ValCas_ValCas</strong></span>
<span class="strong"><strong>(ETA: 00:00:02) (R: 1.69E+07) (T:   1/1) (F: 1/1) (I: 2/5) [OK] o.o.j.t.CASValueTests$ValCas_ValCas</strong></span>
<span class="strong"><strong>(ETA: 00:00:01) (R: 1.22E+07) (T:   1/1) (F: 1/1) (I: 3/5) [OK] o.o.j.t.CASValueTests$ValCas_ValCas</strong></span>
<span class="strong"><strong>(ETA: 00:00:00) (R: 1.07E+07) (T:   1/1) (F: 1/1) (I: 4/5) [OK] o.o.j.t.CASValueTests$ValCas_ValCas</strong></span>
<span class="strong"><strong>(ETA: now) (R: 1.00E+07) (T:   1/1) (F: 1/1) (I: 5/5) [OK] o.o.j.t.CASValueTests$ValCas_ValCas</strong></span>
</pre></div></li></ol></div><p>This shows that the change in the implementation worked and the implementation is correct according to the test case.</p><p>By following these steps, a developer can ensure that a concurrent code works as expected according to the specification, as long as the tests and test cases are implemented and defined correctly. However, keep in mind that concurrency is something that is hard to test, and an implementation that works on one hardware can easily fail on other hardware. It means <a id="id484" class="indexterm"/>that it is recommended to run these test on the widest possible range of configurations.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec257"/>See also</h2></div></div></div><p>This framework is built and maintained by Aleksey Shipilëv who has his own blog and also delivers lectures in various conferences. We recommend that you visit his home page (<a class="ulink" href="http://shipilev.net/">http://shipilev.net/</a>), watch his videos on YouTube (for example, <a class="ulink" href="https://www.youtube.com/watch?v=4p4vL6EhzOk">https://www.youtube.com/watch?v=4p4vL6EhzOk</a>), and read some of his papers. This will help you to get tons of information on correct concurrency testing, concurrency in general, support for concurrency in Java, and other related topics.</p></div></div>
<div class="section" title="Creating a benchmark project using JMH"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Creating a benchmark project using JMH</h1></div></div></div><p>Micro benchmarking<a id="id485" class="indexterm"/> itself is not an easy topic, and doing it correctly using languages like Java is a very difficult task. These difficulties <a id="id486" class="indexterm"/>arise from the way Java executes the code and the infrastructure required by JVM. Just as things like JIT and GC may affect the results of micro benchmarking heavily, to ensure that the result of each run is consistent and correct might not be an easy task to accomplish. To help with this problem, there are several frameworks that can help to ensure that the benchmark test runs properly. One of these frameworks is <a id="id487" class="indexterm"/>
<span class="strong"><strong>Java Microbenchmark Harness</strong></span> (<span class="strong"><strong>JMH</strong></span>), which is a part of OpenJDK. This recipe will explain how developers can use this framework to benchmark his/her own code.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec258"/>Getting ready</h2></div></div></div><p>This recipe requires a machine with an Internet connection, Maven, Java SDK, and your favorite IDE that has support for Maven projects.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec259"/>How to do it…</h2></div></div></div><p>The following steps will take you through the process of creating a benchmark project and writing the benchmark, which can be used to analyze the performance of the code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the command line, run the following Maven command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost ~] mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh-java-benchmark-archetype -DgroupId=org.benchmark -DartifactId=mybenchmark -Dversion=1.0</strong></span>
</pre></div></li><li class="listitem">After <a id="id488" class="indexterm"/>running this command, in the current directory, Maven will create a folder with the name, <code class="literal">mybenchmark</code>, which will have the skeleton of the project. If all goes well, the build should end with an output that is similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INFO] project created from Archetype in dir: /home/user/openjdk/mybenchmark</strong></span>
<span class="strong"><strong>[INFO] -------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] BUILD SUCCESS</strong></span>
<span class="strong"><strong>[INFO] -------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Total time: 9.188s</strong></span>
<span class="strong"><strong>[INFO] Finished at: Sat Aug 02 20:16:01 BST 2014</strong></span>
<span class="strong"><strong>[INFO] Final Memory: 11M/129M</strong></span>
<span class="strong"><strong>[INFO] -------------------------------------------------------</strong></span>
</pre></div></li><li class="listitem">Now, when<a id="id489" class="indexterm"/> the project is generated, we can start working with it and create our first microbenchmark test. Open the generated project file (<code class="literal">/home/user/openjdk/mybenchmark/pom.xml</code>) with your favorite IDE. Ensure that Maven is correctly configured and all dependencies are downloaded correctly. Notice that there is already a class created for the benchmark whose name is <code class="literal">org.benchmark.MyBenchmark</code>. At the beginning, all it has is a single method where we will later put the code we are going to test.</li><li class="listitem">As an example, let's test something that is relatively simple but has some room for improvement. A binary search is a good choice for this purpose. So, let's draft a simple implementation and put it into the <code class="literal">org.benchmark.BinarySearch1</code> class as shown next:<div class="informalexample"><pre class="programlisting">package org.benchmark;
public class BinarySearch1 {
    public static int search(long[] arr, long value) {
        return search(arr, value, 0, arr.length-1);
    }

    private static int search(long[] arr, long value, int start, int end) {
        if (end &lt; start) 
            return -1;

        int imid = start + ((end - start) / 2);
        if (arr[imid] &gt; value)
            return search(arr, value, start, imid-1);
        else if (arr[imid] &lt; value)
            return search(arr, value, imid+1, end);
        else
            return imid;
    }</pre></div><p>This is a very basic implementation, which will be fine for our experiment. If you are not familiar with binary search or where to get more information about this algorithm, visit the Wikipedia page at <a class="ulink" href="http://en.wikipedia.org/wiki/Binary_search_algorithm">http://en.wikipedia.org/wiki/Binary_search_algorithm</a>.</p></li><li class="listitem">Now, when <a id="id490" class="indexterm"/>the first draft of the<a id="id491" class="indexterm"/> implementation is ready, we will create a microbenchmark for it. Put the following code into the <code class="literal">org.benchmark.MyBenchmark</code> class:<div class="informalexample"><pre class="programlisting">package org.benchmark;

import org.openjdk.jmh.annotations.*;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

@State(value = Scope.Thread)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class MyBenchmark {
    private long[] data = new long[5000];

    @Setup
    public void setup() {
        for (int i = 0; i != data.length; ++i) {
            data[i]=(long)(Math.random()*Long.MAX_VALUE-1);
        }
        Arrays.sort(data);
    }

    @Benchmark
    public int testBinarySearch1 () {
        return BinarySearch1.search(data, Long.MAX_VALUE);
    }
}</pre></div><p>This code requires some clarification. The <code class="literal">@State</code> annotation is required to tell JMH that this class contains some data that is used by the tests, and that data in the <code class="literal">Scope.Thread</code> scope means that it will not be shared between several threads.</p><p>The <code class="literal">@BenchmarkMode(Mode.AverageTime)</code> annotation says that what we want to <a id="id492" class="indexterm"/>measure is the average time required to execute our test, which, by default, measures throughput. The <code class="literal">@OutputTimeUnit(TimeUnit.MICROSECONDS)</code> annotation sets <code class="literal">timeunit</code>. We need to define it, as the default is in seconds, which is a very big scale for the benchmark.</p><p>The <a id="id493" class="indexterm"/>setup method is annotated with the <code class="literal">@Setup</code> annotation, which means that it does some preparation for the tests and it will be called to initialize the data for the test. It is similar to the <code class="literal">@Before</code> annotation from JUnit. Keep in mind that this method is executed only once before running the test in the fork on JVM. It is not executed before each test method is called. This means that the same test method will work with the same data after each iteration.</p><p>The actual test is in the method annotated with <code class="literal">@Benchmark</code> that executes the code that we are testing.</p></li><li class="listitem">Now that everything is set up, run a test and find out how fast our code is. First, let's build the project with our code and test it. To do this, go to the folder with the project and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost mybenchmark] mvn clean install</strong></span>
</pre></div></li><li class="listitem">Then, run the benchmark:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost mybenchmark] java -jar target/benchmarks.jar --wi=10 --i=5 --f=1 --jvmArgs=-server</strong></span>
</pre></div><p>Here <code class="literal">wi</code> defines the number of <code class="literal">warmup</code> iterations, <code class="literal">i</code> the number of test run iterations, <code class="literal">f</code> says how many JVM forks to use, and <code class="literal">jvmArgs</code> are the parameters for forked JVM.</p><p>The <a id="id494" class="indexterm"/>output <a id="id495" class="indexterm"/>for each of our test methods should look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># VM invoker: C:\Usres\User\jdk1.7.0\jre\bin\java.exe</strong></span>
<span class="strong"><strong># VM options: -server</strong></span>
<span class="strong"><strong># Warmup: 10 iterations, 1 s each</strong></span>
<span class="strong"><strong># Measurement: 5 iterations, 1 s each</strong></span>
<span class="strong"><strong># Threads: 1 thread, will synchronize iterations</strong></span>
<span class="strong"><strong># Benchmark mode: Average time, time/op</strong></span>
<span class="strong"><strong># Benchmark: org.benchmark.MyBenchmark.testBinarySearch1</strong></span>

<span class="strong"><strong># Run progress: 0.00% complete, ETA 00:00:15</strong></span>
<span class="strong"><strong># Fork: 1 of 1</strong></span>
<span class="strong"><strong># Warmup Iteration   1: 74.562 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   2: 75.657 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   3: 79.575 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   4: 75.718 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   5: 76.432 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   6: 75.965 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   7: 73.987 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   8: 75.677 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration   9: 76.326 ns/op</strong></span>
<span class="strong"><strong># Warmup Iteration  10: 77.050 ns/op</strong></span>
<span class="strong"><strong>Iteration   1: 77.027 ns/op</strong></span>
<span class="strong"><strong>Iteration   2: 75.870 ns/op</strong></span>
<span class="strong"><strong>Iteration   3: 77.674 ns/op</strong></span>
<span class="strong"><strong>Iteration   4: 81.460 ns/op</strong></span>
<span class="strong"><strong>Iteration   5: 73.858 ns/op</strong></span>

<span class="strong"><strong>Result: 77.178 ±(99.9%) 10.778 ns/op [Average]</strong></span>
<span class="strong"><strong>  Statistics: (min, avg, max) = (73.858, 77.178, 81.460), stdev = 2.799</strong></span>
<span class="strong"><strong>  Confidence interval (99.9%): [66.400, 87.956]</strong></span>

<span class="strong"><strong># Run complete. Total time: 00:00:18</strong></span>
<span class="strong"><strong>Benchmark                            Mode  Samples   Score  Score error  Units</strong></span>
<span class="strong"><strong>o.b.MyBenchmark.testBinarySearch1    avgt        5  77.178       10.778  ns/op</strong></span>
</pre></div><p>The output shows the runs executed for each fork and the final result. Here we can see that, on average, our method takes <code class="literal">77.178</code> nanoseconds to run.</p></li><li class="listitem">Now that<a id="id496" class="indexterm"/> we have the results, what to do with them? Generally, these results make sense only when they are compared with<a id="id497" class="indexterm"/> something else. Let's try to make some changes to the code and see whether it helps our implementation of binary search to work faster. We can try to remove recursion and see how it's going to work. Create another class with the name, <code class="literal">org.benchmark.BinarySearch2</code>, and put the following implementation there:<div class="informalexample"><pre class="programlisting">package org.benchmark;
public class BinarySearch2 {
    public static int search(long[] arr, long value) {
        return search(arr, value, 0, arr.length-1);
    }
    private static int search(long[] arr, long value, int start, int end) {
        while (end &gt;= start) {
            int imid = start + ((end - start) / 2);
            if(arr[imid] == value)
                return imid;
            else if (arr[imid] &lt; value)
                start = imid + 1;
            else
                end = imid - 1;
        }
        return -1;
    }
}</pre></div><p>This is the iterative implementation, which doesn't use recursive calls.</p></li><li class="listitem">Now let's update the benchmark class so that we can compare recursive and iterative implementations:<div class="informalexample"><pre class="programlisting">package org.benchmark;

import org.openjdk.jmh.annotations.*;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

@State(value = Scope.Group)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class MyBenchmark {
    private long[] data = new long[500000];

    @Setup
    public void setup() {
        for (int i = 0; i != data.length; ++i) {
            data[i] = (long)(Math.random() * (Long.MAX_VALUE-1));
        }
        Arrays.sort(data);
    }

    @Benchmark
    @Group(value = "bsearch")
    public int testBinarySearch1() {
        return BinarySearch1.search(data, Long.MAX_VALUE);
    }

    @Benchmark
    @Group(value = "bsearch")
    public int testBinarySearch2() {
        return BinarySearch2.search(data, Long.MAX_VALUE);
    }
}</pre></div><p>The <a id="id498" class="indexterm"/>difference <a id="id499" class="indexterm"/>between this benchmark and the previous version is that this uses the benchmarking groups that give us a simple comparison of our implementations. The <code class="literal">@State</code> annotation now has to have the <code class="literal">Group</code> scope, otherwise the tests will be using different data instances, which is not what we would want, as we want algorithms to work in exactly the same conditions.</p></li><li class="listitem">Now, rebuild the project:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost mybenchmark] mvn clean install</strong></span>
</pre></div></li><li class="listitem">Then, run the test again:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost mybenchmark] java -jar target/benchmarks.jar --wi=10 --i=5 --f=1 --jvmArgs=-server</strong></span>
</pre></div><p>The output is going to be slightly different from the previous one, because of the use of groups. The main difference in which we are interested is going to be at the end of the report:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Run complete. Total time: 00:00:18</strong></span>
<span class="strong"><strong>Benchmark                                    Mode  Samples   Score  Score error  Units</strong></span>
<span class="strong"><strong>o.b.MyBenchmark.bsearch                      avgt        5  66.929        1.663  ns/op</strong></span>
<span class="strong"><strong>o.b.MyBenchmark.bsearch:testBinarySearch1    avgt        5  79.717        2.289  ns/op</strong></span>
<span class="strong"><strong>o.b.MyBenchmark.bsearch:testBinarySearch2    avgt        5  54.141        1.209  ns/op</strong></span>
</pre></div><p>What we can see here is that, for this particular configuration (which includes machine spec, version of JDK, OS, and so on), iterative implementation, which is implemented by the method, <code class="literal">testBinarySearch2()</code>, is on average faster than the recursive one, implemented by <code class="literal">testBinarySearch1()</code> (<code class="literal">54.141</code> &lt; <code class="literal">79.717</code>).</p></li></ol></div><p>After <a id="id500" class="indexterm"/>going<a id="id501" class="indexterm"/> through this recipe, you have learned how to run microbenchmark tests, how to interpret results, and how to compare the performance of different implementations. Ensure that you microbenchmark each hard task properly and remember that the results can vary significantly on different machines, JVM versions, and so on.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec260"/>There's more…</h2></div></div></div><p>JMH is a flexible framework that provides flexibility to the way it can be used. For example, if someone wants to run tests via the main method, without using <code class="literal">benchmarks.jar</code>, this can be easily achieved. To do this, just add the following main method to <code class="literal">MyBenchmark</code> and run it:</p><div class="informalexample"><pre class="programlisting">public static void main(String[] args) throws RunnerException {
    Options opt = new OptionsBuilder()
            .include(".*" + MyBenchmark.class.getSimpleName() + ".*")
            .warmupIterations(3)
            .measurementIterations(3)
            .forks(2)
            .build();
    new Runner(opt).run();
}</pre></div><p>This example will give the same result as running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@localhost mybenchmark] java -jar target/benchmarks.jar --wi=3 --i=3 --f=2</strong></span>
</pre></div><p>We also <a id="id502" class="indexterm"/>recommend that<a id="id503" class="indexterm"/> you download the source code (see the <span class="emphasis"><em>Downloading source and compiling JHM</em></span> recipe). Have a look at the recipe and JavaDocs, as the JavaDocs are well written and explain a lot about the framework.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec261"/>See also</h2></div></div></div><p>Similar to jcstress, this framework is also built and maintained by Aleksey Shipilëv who has his own blog and also delivers lectures in various conferences. We recommend you visit his home page (<a class="ulink" href="http://shipilev.net/">http://shipilev.net/</a>), watch his videos on YouTube (for example, <a class="ulink" href="https://www.youtube.com/watch?v=4p4vL6EhzOk">https://www.youtube.com/watch?v=4p4vL6EhzOk</a>), and read some of his papers.</p></div></div>
<div class="section" title="Downloading the source and compiling JHM"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Downloading the source and compiling JHM</h1></div></div></div><p>Similar to all other <a id="id504" class="indexterm"/>OpenJDK tools and projects, there is an option to download the source of the JHM and build it yourself. This might be required if a framework requires customization and an extension fix. Luckily the process is very easy and straightforward.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec262"/>Getting ready</h2></div></div></div><p>This recipe requires a machine with an Internet connection that is capable of running Mercurial and Maven. Basically, the requirements are the same as that for compiling and running <code class="literal">jcstress</code> (see the <span class="emphasis"><em>Building and running jcstress</em></span> recipe).</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec263"/>How to do it…</h2></div></div></div><p>The following steps will lead you through the process of downloading the source code and building JHM:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start, let's run the following command to download the source files:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>hg clone http://hg.openjdk.java.net/code-tools/jmh/ jmh</strong></span>
</pre></div><p>This command will download the source files and put them into the <code class="literal">jmh</code> folder.</p></li><li class="listitem">The next step is to <a id="id505" class="indexterm"/>build the source code. The build requires Maven to be installed on the machine. Change the current folder to <code class="literal">jmh</code> and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install –DskipTests</strong></span>
</pre></div><p>This command should generate an output similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INFO] -------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] BUILD SUCCESS</strong></span>
<span class="strong"><strong>[INFO] -------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Total time: 3:14.052s</strong></span>
<span class="strong"><strong>[INFO] Finished at: Sat Aug 02 19:43:39 BST 2014</strong></span>
<span class="strong"><strong>[INFO] Final Memory: 38M/176M</strong></span>
<span class="strong"><strong>[INFO] -------------------------------------------------------</strong></span>
</pre></div><p>This means that the build was successful.</p></li><li class="listitem">Now, the final <a id="id506" class="indexterm"/>step is to change your benchmark project to use the version of JHM that was just built. Assuming the project references of the JHM version are by properties, just change the version of the JHM dependency in your project to <code class="literal">1.0-SNAPHOT</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;properties&gt;</strong></span>
<span class="strong"><strong>    ...</strong></span>
<span class="strong"><strong>    &lt;jmh.version&gt;0.9.3&lt;/jmh.version&gt;</strong></span>
<span class="strong"><strong>&lt;/properties&gt;</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec264"/>How it works…</h2></div></div></div><p>When you run Maven with the <code class="literal">install</code> target, it will put the newly built version of the artefact in the local repository. In this case, the version is <code class="literal">1.0-SNAPSHOT</code>. When another project has dependency on that version, Maven will pick the version from the local repository and use it.</p></div></div></body></html>