["```java\ncase class User(name: String)\ndef getUser(id: Int): User =\n if (Set(1, 2, 3).contains(id)) User(s\"User-$id\")   \n else null\n```", "```java\nprintln(getUser(1 ).name)  // User-1\nprintln(getUser(10).name)  // NullPointerException\n```", "```java\nclass GameState(notifications: ActorRef) extends Actor {\n  val onlineUsers = collection.mutable.ListBuffer[User]()\n  def receive = {\n    case Connect   (u) => onlineUsers += u\n    case Disconnect(u) => onlineUsers -= u\n    case Round         => notifications ! RewardWinners(onlineUsers)\n  }\n}\n```", "```java\ncase Round => notifications ! RewardWinners(onlineUsers)\n```", "```java\nclass NotificationsActor extends Actor {\n  def receive = {\n    case RewardWinners(users) =>\n     Thread.sleep(1000)\n    val winners = users.filter(_.score >= 100)\n    if (winners.nonEmpty) winners.foreach { u =>\n      println(s\"User $u is rewarded!\") }\n    else println(\"No one to reward!\")\n  }\n}\n```", "```java\nsealed trait Protocol\ncase class   Connect (user : User      ) extends Protocol\ncase class   Disconnect (user : User      ) extends Protocol\ncase class   RewardWinners(users: Seq[User]) extends Protocol\ncase object  Round                    extends Protocol\n```", "```java\nval system = ActorSystem(\"GameActors\")\nval notifications = system.actorOf(Props[NotificationsActor], name = \"notifications\")\nval gameState     = system.actorOf(Props(classOf[GameState], notifications), name = \"gameState\")\nval u1 = User(\"User1\", 10)\nval u2 = User(\"User2\", 100)\n```", "```java\ngameState ! Connect(u1)\ngameState ! Connect(u2)\ngameState ! Round\ngameState ! Disconnect(u2)\n```", "```java\nvar cans = 0\ndef insertCoin(): SodaCan =\n  if (cans > 0) { cans -= 1; new SodaCan }\n  else throw new RuntimeException(\"Out of soda cans!\")\nprintln(insertCoin())\n```", "```java\ndef insertCoin(): Try[SodaCan] = Try {\n  if (cans > 0) { cans -= 1; new SodaCan }\n  else throw new RuntimeException(\"Out of soda cans!\")\n}\n```", "```java\nclass GameState(notifications: ActorRef) extends Actor {\n  var onlineUsers = List[User]()\n  def receive = {\n    case Connect   (u) => onlineUsers :+= u\n    case Disconnect(u) => onlineUsers = onlineUsers.filter(_ != u)\n    case Round         => notifications ! RewardWinners(onlineUsers)\n  }\n}\n```", "```java\nval listMutable  : Seq[Int] = collection.mutable.ListBuffer[Int](1, 2, 3)\ndef blackBox(x: Seq[Int]): Unit = ???\nblackBox(listMutable)  // Anything could happen to listMutable here, because it is mutable\n```", "```java\nval listImmutable: Seq[Int] = List(1, 2, 3)\ndef blackBox(x: Seq[Int]): Unit = ???\nblackBox(listImmutable) // No matter what happens, listImmutable remains the same, because it is immutable\n```", "```java\ndef getUserName(id: Int): String = {\n  val name = s\"User-$id\"\n  println(s\"LOG: Requested user: $name\")\n  name\n}\nval u = getUserName(10)\n```", "```java\nval u = \"User-10\"\n```", "```java\ndef getUserNamePure(id: Int): (List[String], String) = {\n  val name = s\"User-$id\"\n  val log  = List(s\"LOG: Requested user: $name\")\n  (log, name)\n}\nval u = getUserNamePure(10)\n```", "```java\nval u = (List(\"LOG: Requested user: User-10\"), \"User-10\")\n```", "```java\ndef division(n1: Double, n2: Double): Double =\n  if (n2 == 0) throw new RuntimeException(\"Division by zero!\")\n  else n1 / n2\n```", "```java\ndivision(1, 0)\nprintln(\"This line will never be executed\")\n```", "```java\ndef getUser(id: Int): User =\n  if (Set(1, 2, 3).contains(id)) User(s\"User-$id\")\n  else null\n```"]