- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, web applications have been developed using the request/response
    model followed by HTTP. In this traditional request/response model, the request
    is always initiated by the client, then the server sends a response back to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: There has never been any way for the server to send data to the client independently,
    that is, without having to wait for a request, until now. The WebSocket protocol
    allows full-duplex, two-way communication between the client (browser) and the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The Jakarta API for WebSocket allows us to develop WebSocket endpoints in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing WebSocket server endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing WebSocket clients in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing WebSocket clients in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src).
  prefs: []
  type: TYPE_NORMAL
- en: Developing WebSocket server endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways we can implement a WebSocket server endpoint via the Jakarta
    API for WebSocket: we can either develop an endpoint programmatically, in which
    case we need to extend the `jakarta.websocket.Endpoint` class, or we can annotate
    **Plain Old Java Objects** (**POJOs**) with WebSocket-specific annotations. These
    two approaches are very similar, therefore we will be discussing in detail only
    the annotation approach, and will briefly explain how to develop WebSocket server
    endpoints programmatically later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop a simple web-based chat application that takes
    full advantage of the Jakarta API for WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an annotated WebSocket server endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following Java class illustrates how we can develop a WebSocket server
    endpoint by annotating a Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The class-level `@ServerEndpoint` annotation indicates that the class is a WebSocket
    server endpoint. The `"/websocketchat"`, in this example). WebSocket clients will
    use this URI to communicate with our endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The `@OnOpen` annotation is used to indicate a method that needs to be executed
    whenever a WebSocket connection is opened from any of the clients. In our example,
    we are simply sending some output to the server log, but of course, any valid
    server-side Java code can be placed here.
  prefs: []
  type: TYPE_NORMAL
- en: Any method annotated with the `@OnMessage` annotation will be invoked whenever
    our server endpoint receives a message from any of the clients. Since we are developing
    a chat application, our code simply broadcasts the message it receives to all
    connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `processMessage()` method is annotated with `@OnMessage`,
    and it takes two parameters, an instance of a class implementing the `jakarta.websocket.Session`
    interface, and a `String` containing the message that was received. Since we are
    developing a chat application, our WebSocket server endpoint simply broadcasts
    the received message to all connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: The `getOpenSessions()` method of the `Session` interface returns a `Set` of
    `Session` objects representing all open sessions, we iterate through this set
    to broadcast the received message back to all connected clients by invoking the
    `getBasicRemote()` method on each `Session` instance, then invoking the `sendText()`
    method on the resulting `RemoteEndpoint.Basic` implementation returned by this
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The `getOpenSessions()` method on the `Session` interface returns all the open
    sessions at the time the method was invoked. It is possible for one or more of
    the sessions to have closed after the method was invoked, so it is recommended
    to invoke the `isOpen()` method on a `Session` implementation before attempting
    to send data back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to annotate a method with the `@OnClose` annotation to handle
    the event when a client disconnects from the server endpoint. In our example,
    we simply log a message to the server log.
  prefs: []
  type: TYPE_NORMAL
- en: There is one additional annotation we didn’t use in our example. The `@OnError`
    annotation is used to indicate a method that needs to be invoked in case of an
    error when sending or receiving data to or from the client.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, developing an annotated WebSocket server endpoint is straightforward.
    We simply need to add a few annotations and the application server will invoke
    our annotated methods as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to develop a WebSocket server endpoint programmatically, we need
    to write a Java class that extends `jakarta.websocket.Endpoint`. This class has
    `onOpen()`, `onClose()`, and `onError()` methods that are called at the appropriate
    times during the endpoint’s lifecycle. There is no method equivalent to the `@OnMessage`
    annotation – to handle incoming messages from the clients, the `addMessageHandler()`
    method needs to be invoked in the session, passing an instance of a class implementing
    the `jakarta.websocket.MessageHandler` interface (or one of its subinterfaces)
    as its sole parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is more straightforward to develop annotated WebSocket endpoints
    as opposed to their programmatic counterparts. Therefore, we recommend the annotated
    approach whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to develop WebSocket endpoints, we will focus our
    attention on developing WebSocket clients.
  prefs: []
  type: TYPE_NORMAL
- en: Developing WebSocket clientsin JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most WebSocket clients are implemented as web pages taking advantage of the
    JavaScript WebSocket API. We will cover how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Jakarta API for WebSocket provides a client API that allows us to develop
    WebSocket clients as standalone Java applications. We will be covering this capability
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing JavaScript client-side WebSocket code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover how to develop client-side JavaScript code to
    interact with the WebSocket endpoint we developed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The client page for our WebSocket example is implemented as a JSF page using
    HTML5-friendly markup (as explained in [*Chapter 7*](B21231_07.xhtml#_idTextAnchor100)).
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in *Figure 9**.1*, our client page consists of a text area where
    we can see what the users of our application are saying (it is, after all, a chat
    application), and a text-input box that we can use to send messages to other users.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Javascript WebSocket client](img/B21231_9_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Javascript WebSocket client
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript code for our client page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The last line of our JavaScript code (`window.addEventListener("load", init);`)
    sets our JavaScript `init()` function to get executed as soon as the page loads.
  prefs: []
  type: TYPE_NORMAL
- en: In the `init()` function, we initialize a new JavaScript WebSocket object, passing
    the URI of our server endpoint as a parameter. This lets our JavaScript code know
    the location of our server endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript WebSocket object has a number of function types used to handle
    different events such as opening the connection, receiving a message, and handling
    errors. We need to set these types to our own JavaScript functions so that we
    can handle these events, which is what we do in our `init()` method right after
    invoking the constructor for the JavaScript WebSocket object. In our example,
    the functions we assigned to the WebSocket object simply delegate their functionality
    to stand-alone JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: Our `websocketOpen()` function is called whenever the WebSocket connection is
    opened. In our example, we simply send a message to the browser’s JavaScript console.
  prefs: []
  type: TYPE_NORMAL
- en: Our `webSocketMessage()` function is invoked whenever the browser receives a
    WebSocket message from our WebSocket endpoint. In our example, we update the contents
    of the text area that has the ID of the chat window with the contents of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Our `websocketError()` function is called whenever there is a WebSocket-related
    error. In our example, we simply send a message to the browser’s JavaScript console.
  prefs: []
  type: TYPE_NORMAL
- en: Our JavaScript `sendMessage()` function sends a message to the WebSocket server
    endpoint containing both the username and the contents of the text input with
    the ID of `chatinput`. This function is called when the user clicks on the button
    with the ID of `sendBtn`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `closeConnection()` JavaScript function closes the connection to our WebSocket
    server endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this example, writing client-side JavaScript code to interact
    with WebSocket endpoints is fairly straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Developing WebSocket clients in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although developing web-based WebSocket clients is currently the most common
    way of developing WebSocket clients, the Jakarta API for WebSocket provides a
    client API we can use to develop WebSocket clients in Java.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be developing a simple graphical WebSocket client using
    the client API of the Jakarta API for WebSocket. *Figure 9**.2* illustrates the
    GUI of our Java WebSocket client.
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.2 – WebSocket client developed in Java](img/B21231_9_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – WebSocket client developed in Java
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We won’t be covering the GUI code, since it is not relevant to the discussion.
    The complete code for the example, including the GUI code, can be downloaded from
    the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with WebSocket server endpoints, Java WebSocket clients can be developed
    either programmatically or by using annotations. Once again, we will cover only
    the annotation approach. Developing a programmatic client is very similar to the
    way programmatic server endpoints are developed, which is to say, programmatic
    clients must extend `jakarta.websocket.Endpoint` and override the appropriate
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, here is the code for our Java WebSocket client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The class-level `@ClientEndPoint` annotation denotes our class as a WebSocket
    client. All Java WebSocket clients must be annotated with this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The code to establish a connection to the WebSocket server endpoint is in our
    class constructor. First, we need to invoke `ContainerProvider.getWebSocketContainer()`
    to obtain an instance of `jakarta.websocket.WebSocketContainer`. We then establish
    the connection by invoking the `connectToServer()` method on our `WebSocketContainer`
    instance, passing a class annotated with `@ClientEndpoint` as the first parameter
    (in our example, we use `this`, since the connection code is inside our WebSocket
    Java client code), and an `URI` object containing the WebSocket server endpoint
    URI as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: After the connection is established, we are ready to respond to WebSocket events.
    Alert readers may have noticed that we are using the exact same annotations we
    used to develop our server endpoint again in our client code.
  prefs: []
  type: TYPE_NORMAL
- en: Any method annotated with the `@OnOpen` annotation will be invoked automatically
    when the connection to the WebSocket server endpoint is established, the method
    must return void and can have an optional parameter of type `jakarta.websocket.Session`.
    In our example, we initialize a class variable with the `Session` instance we
    received as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Methods annotated with the `@OnClose` annotation are invoked whenever the WebSocket
    session is closed. The annotated method can have optional parameters of type `jakarta.websocket.Session`
    and type `CloseReason`. In our example, we chose to use only the `CloseReason`
    optional parameter, since this class has a handy `getReasonPhrase()` method that
    provides a short explanation of why the session was closed.
  prefs: []
  type: TYPE_NORMAL
- en: The `@OnError` annotation is used to indicate that a method will be called when
    an error occurs. Methods annotated with `@OnError` must have a parameter of type
    `java.lang.Throwable` (the parent class of `java.lang.Exception`), and can have
    an optional parameter of type `Session`. In our example, we simply send the stack
    trace of the `Throwable` parameter to `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods annotated with `@OnMessage` are invoked whenever an incoming WebSocket
    message is received. `@OnMessage` methods can have different parameters depending
    on the type of message received and how we wish to handle it. In our example,
    we used the most common case, receiving a text message. In this particular case,
    we need a `String` parameter that will hold the contents of the message, and an
    optional `Session` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the JavaDoc documentation for `@OnMessage` at [https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage](https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage)
    for information on how to handle other types of messages.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we simply update the chat window text area, appending the received
    message to its contents.
  prefs: []
  type: TYPE_NORMAL
- en: To send a WebSocket message, we invoke the `getBasicRemote()` method on our
    Session instance, then invoke the `sendText()` method on the resulting `RemoteEndpoint.Basic`
    implementation returned by this call (if this looks familiar, it is because we
    did exactly the same thing in the WebSocket server endpoint code). In our example,
    we do this in the `sendMessage()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information about the Jakarta API for WebSocket
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the bulk of the functionality provided by the Jakarta
    API for WebSocket. For additional information, refer to the user guide for Tyrus,
    a popular open source Jakarta API for WebSocket implementation, at [https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/](https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the Jakarta API for WebSocket, a Jakarta EE API
    for developing WebSocket server endpoints and clients:'
  prefs: []
  type: TYPE_NORMAL
- en: We first saw how to develop WebSocket server endpoints by taking advantage of
    the Jakarta API for WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we covered how to develop web-based WebSocket clients using JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we explained how to develop WebSocket client applications in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSockets allow us to implement real-time, two-way communication between a
    web browser and a web server. As we saw in this chapter, the Jakarta EE WebSocket
    API takes care of the low-level details allowing us to develop WebSocket endpoints
    via a few simple annotations.
  prefs: []
  type: TYPE_NORMAL
