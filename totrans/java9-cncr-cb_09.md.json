["```java\n        public class MyLock extends ReentrantLock {\n\n```", "```java\n        public String getOwnerName() {\n          if (this.getOwner()==null) {\n            return \"None\";\n          }\n          return this.getOwner().getName();\n        }\n\n```", "```java\n        public Collection<Thread> getThreads() { \n          return this.getQueuedThreads(); \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final Lock lock;\n\n```", "```java\n        public Task (Lock lock) { \n          this.lock=lock; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<5; i++) {\n\n```", "```java\n        lock.lock(); \n        System.out.printf(\"%s: Get the Lock.\\n\",\n                          Thread.currentThread().getName());\n\n```", "```java\n              try { \n                TimeUnit.MILLISECONDS.sleep(500); \n                System.out.printf(\"%s: Free the Lock.\\n\",\n                                  Thread.currentThread().getName()); \n              } catch (InterruptedException e) { \n                e.printStackTrace(); \n              } finally { \n                lock.unlock(); \n              } \n            } \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        MyLock lock=new MyLock();\n\n```", "```java\n        Thread threads[]=new Thread[5];\n\n```", "```java\n        for (int i=0; i<5; i++) { \n          Task task=new Task(lock); \n          threads[i]=new Thread(task); \n          threads[i].start(); \n        }\n\n```", "```java\n        for (int i=0; i<15; i++) {\n\n```", "```java\n        System.out.printf(\"Main: Logging the Lock\\n\"); \n        System.out.printf(\"************************\\n\"); \n        System.out.printf(\"Lock: Owner : %s\\n\",lock.getOwnerName());\n\n```", "```java\n        System.out.printf(\"Lock: Queued Threads: %s\\n\",\n                          lock.hasQueuedThreads()); \n        if (lock.hasQueuedThreads()){ \n          System.out.printf(\"Lock: Queue Length: %d\\n\",\n                            lock.getQueueLength()); \n          System.out.printf(\"Lock: Queued Threads: \"); \n          Collection<Thread> lockedThreads=lock.getThreads(); \n          for (Thread lockedThread : lockedThreads) { \n            System.out.printf(\"%s \",lockedThread.getName()); \n          } \n          System.out.printf(\"\\n\"); \n        }\n\n```", "```java\n        System.out.printf(\"Lock: Fairness: %s\\n\",lock.isFair()); \n        System.out.printf(\"Lock: Locked: %s\\n\",lock.isLocked()); \n        System.out.printf(\"************************\\n\");\n\n```", "```java\n              TimeUnit.SECONDS.sleep(1); \n            } \n          } \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final int time;\n\n```", "```java\n        private final Phaser phaser;\n\n```", "```java\n        public Task(int time, Phaser phaser) { \n          this.time=time; \n          this.phaser=phaser; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n\n          phaser.arrive();\n\n```", "```java\n        System.out.printf(\"%s: Entering phase 1.\\n\",\n                          Thread.currentThread().getName()); \n        try { \n          TimeUnit.SECONDS.sleep(time); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n        System.out.printf(\"%s: Finishing phase 1.\\n\",\n                          Thread.currentThread().getName()); \n        phaser.arriveAndAwaitAdvance();\n\n```", "```java\n        System.out.printf(\"%s: Entering phase 2.\\n\",\n                          Thread.currentThread().getName()); \n        try { \n          TimeUnit.SECONDS.sleep(time); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n        System.out.printf(\"%s: Finishing phase 2.\\n\",\n                          Thread.currentThread().getName()); \n        phaser.arriveAndAwaitAdvance(); \n\n        System.out.printf(\"%s: Entering phase 3.\\n\",\n                          Thread.currentThread().getName()); \n        try { \n          TimeUnit.SECONDS.sleep(time); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n        System.out.printf(\"%s: Finishing phase 3.\\n\",\n                          Thread.currentThread().getName()); \n\n        phaser.arriveAndDeregister();\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        Phaser phaser=new Phaser(3);\n\n```", "```java\n        for (int i=0; i<3; i++) { \n          Task task=new Task(i+1, phaser); \n          Thread thread=new Thread(task); \n          thread.start(); \n        }\n\n```", "```java\n        for (int i=0; i<10; i++) {\n\n```", "```java\n        System.out.printf(\"********************\\n\"); \n        System.out.printf(\"Main: Phaser Log\\n\"); \n        System.out.printf(\"Main: Phaser: Phase: %d\\n\",\n                          phaser.getPhase()); \n        System.out.printf(\"Main: Phaser: Registered Parties: %d\\n\",\n                          phaser.getRegisteredParties()); \n        System.out.printf(\"Main: Phaser: Arrived Parties: %d\\n\",\n                          phaser.getArrivedParties()); \n        System.out.printf(\"Main: Phaser: Unarrived Parties: %d\\n\",\n                          phaser.getUnarrivedParties()); \n        System.out.printf(\"********************\\n\");\n\n```", "```java\n              TimeUnit.SECONDS.sleep(1); \n            } \n          } \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final long milliseconds;\n\n```", "```java\n        public Task (long milliseconds) { \n          this.milliseconds=milliseconds; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n\n          System.out.printf(\"%s: Begin\\n\",\n                            Thread.currentThread().getName()); \n          try { \n            TimeUnit.MILLISECONDS.sleep(milliseconds); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n          System.out.printf(\"%s: End\\n\",\n                            Thread.currentThread().getName()); \n\n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        ThreadPoolExecutor executor = (ThreadPoolExecutor)\n                                Executors.newCachedThreadPool();\n\n```", "```java\n        Random random=new Random(); \n        for (int i=0; i<10; i++) { \n          Task task=new Task(random.nextInt(10000)); \n          executor.submit(task); \n        }\n\n```", "```java\n        for (int i=0; i<5; i++){ \n          showLog(executor); \n          TimeUnit.SECONDS.sleep(1); \n        }\n\n```", "```java\n        executor.shutdown();\n\n```", "```java\n        for (int i=0; i<5; i++){ \n          showLog(executor); \n          TimeUnit.SECONDS.sleep(1); \n        }\n\n```", "```java\n        executor.awaitTermination(1, TimeUnit.DAYS);\n\n```", "```java\n          System.out.printf(\"Main: End of the program.\\n\"); \n        }\n\n```", "```java\n        private static void showLog(ThreadPoolExecutor executor) { \n          System.out.printf(\"*********************\"); \n          System.out.printf(\"Main: Executor Log\"); \n          System.out.printf(\"Main: Executor: Core Pool Size: %d\\n\",\n                            executor.getCorePoolSize()); \n          System.out.printf(\"Main: Executor: Pool Size: %d\\n\",\n                            executor.getPoolSize()); \n          System.out.printf(\"Main: Executor: Active Count: %d\\n\",\n                            executor.getActiveCount()); \n          System.out.printf(\"Main: Executor: Task Count: %d\\n\",\n                            executor.getTaskCount()); \n\n```", "```java\n          System.out.printf(\"Main: Executor: Completed Task Count: %d\\n\",\n                            executor.getCompletedTaskCount()); \n          System.out.printf(\"Main: Executor: Shutdown: %s\\n\",\n                            executor.isShutdown()); \n          System.out.printf(\"Main: Executor: Terminating: %s\\n\",\n                            executor.isTerminating()); \n          System.out.printf(\"Main: Executor: Terminated: %s\\n\",\n                            executor.isTerminated()); \n          System.out.printf(\"*********************\\n\"); \n        }\n\n```", "```java\n        public class Task extends RecursiveAction{\n\n```", "```java\n        private final int array[];\n\n```", "```java\n        private final int start; \n        private final int end;\n\n```", "```java\n        public Task (int array[], int start, int end) { \n          this.array=array; \n          this.start=start; \n          this.end=end; \n        }\n\n```", "```java\n        protected void compute() { \n          if (end-start>100) { \n            int mid=(start+end)/2; \n            Task task1=new Task(array,start,mid); \n            Task task2=new Task(array,mid,end); \n\n            task1.fork(); \n            task2.fork(); \n\n            task1.join(); \n            task2.join();\n\n```", "```java\n          } else { \n              for (int i=start; i<end; i++) { \n                array[i]++; \n\n                try { \n                  Thread.sleep(5); \n                } catch (InterruptedException e) { \n                  e.printStackTrace(); \n                } \n              } \n            } \n          } \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        ForkJoinPool pool=new ForkJoinPool();\n\n```", "```java\n        int array[]=new int[10000];\n\n```", "```java\n        Task task1=new Task(array,0,array.length);\n\n```", "```java\n        pool.execute(task1);\n\n```", "```java\n        while (!task1.isDone()) { \n          showLog(pool); \n          TimeUnit.SECONDS.sleep(1); \n        }\n\n```", "```java\n        pool.shutdown();\n\n```", "```java\n        pool.awaitTermination(1, TimeUnit.DAYS);\n\n```", "```java\n        showLog(pool); \n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        private static void showLog(ForkJoinPool pool) { \n          System.out.printf(\"**********************\\n\"); \n          System.out.printf(\"Main: Fork/Join Pool log\\n\"); \n          System.out.printf(\"Main: Fork/Join Pool: Parallelism: %d\\n\",\n                            pool.getParallelism()); \n          System.out.printf(\"Main: Fork/Join Pool: Pool Size: %d\\n\",\n                            pool.getPoolSize()); \n          System.out.printf(\"Main: Fork/Join Pool: Active Thread Count:\n                             %d\\n\", pool.getActiveThreadCount()); \n          System.out.printf(\"Main: Fork/Join Pool: Running Thread Count:\n                             %d\\n\", pool.getRunningThreadCount()); \n          System.out.printf(\"Main: Fork/Join Pool: Queued Submission:\n                             %d\\n\", pool.getQueuedSubmissionCount()); \n          System.out.printf(\"Main: Fork/Join Pool: Queued Tasks: %d\\n\",\n                            pool.getQueuedTaskCount()); \n          System.out.printf(\"Main: Fork/Join Pool: Queued Submissions:\n                             %s\\n\", pool.hasQueuedSubmissions()); \n          System.out.printf(\"Main: Fork/Join Pool: Steal Count: %d\\n\",\n                            pool.getStealCount()); \n          System.out.printf(\"Main: Fork/Join Pool: Terminated : %s\\n\",\n                            pool.isTerminated()); \n          System.out.printf(\"**********************\\n\"); \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n\n            AtomicLong counter = new AtomicLong(0); \n            Random random=new Random();\n\n```", "```java\n        long streamCounter = random.doubles(1000).parallel()\n                             .peek( number -> { \n          long actual=counter.incrementAndGet(); \n          System.out.printf(\"%d - %f\\n\", actual, number); \n        }).count(); \n\n        System.out.printf(\"Counter: %d\\n\", counter.get()); \n        System.out.printf(\"Stream Counter: %d\\n\", streamCounter);\n\n```", "```java\n            counter.set(0); \n            random.doubles(1000).parallel().peek(number -> { \n              long actual=counter.incrementAndGet(); \n              System.out.printf(\"Peek: %d - %f\\n\", actual,number); \n            }).forEach( number -> { \n              System.out.printf(\"For Each: %f\\n\", number); \n            }); \n\n            System.out.printf(\"Counter: %d\\n\", counter.get()); \n          } \n        }\n\n```", "```java\n        public class MyFormatter extends Formatter { \n          @Override \n          public String format(LogRecord record) { \n\n            StringBuilder sb=new StringBuilder(); \n            sb.append(\"[\"+record.getLevel()+\"] - \"); \n            sb.append(new Date(record.getMillis())+\" : \"); \n            sb.append(record.getSourceClassName()+ \".\"\n                      +record.getSourceMethodName()+\" : \"); \n            sb.append(record.getMessage()+\"\\n\");. \n            return sb.toString(); \n          }\n\n```", "```java\n        public class MyLoggerFactory {\n\n```", "```java\n        private static Handler handler;\n\n```", "```java\n        public synchronized static Logger getLogger(String name){\n\n```", "```java\n        Logger logger=Logger.getLogger(name);\n\n```", "```java\n        logger.setLevel(Level.ALL);\n\n```", "```java\n        try { \n          if (handler==null) { \n            handler=new FileHandler(\"recipe6.log\"); \n            Formatter format=new MyFormatter(); \n            handler.setFormatter(format); \n          }\n\n```", "```java\n            if (logger.getHandlers().length==0) { \n              logger.addHandler(handler); \n            } \n          } catch (SecurityException e | IOException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n          return logger; \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        @Override \n        public void run() {\n\n```", "```java\n        Logger logger= MyLogger.getLogger(this.getClass().getName());\n\n```", "```java\n        logger.entering(Thread.currentThread().getName(), \"run()\");\n\n```", "```java\n        try { \n          TimeUnit.SECONDS.sleep(2); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n          logger.exiting(Thread.currentThread().getName(), \"run()\",\n                         Thread.currentThread()); \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        Logger logger=MyLogger.getLogger(Main.class.getName());\n\n```", "```java\n        logger.entering(Main.class.getName(), \"main()\",args);\n\n```", "```java\n        Thread threads[]=new Thread[5];\n\n```", "```java\n        for (int i=0; i<threads.length; i++) { \n          logger.log(Level.INFO,\"Launching thread: \"+i); \n          Task task=new Task(); \n          threads[i]=new Thread(task); \n          logger.log(Level.INFO,\"Thread created: \"+\n                     threads[i].getName()); \n          threads[i].start(); \n        }\n\n```", "```java\n        logger.log(Level.INFO,\"Ten Threads created.\"+\n                   \"Waiting for its finalization\");\n\n```", "```java\n        for (int i=0; i<threads.length; i++) { \n          try { \n            threads[i].join(); \n            logger.log(Level.INFO,\"Thread has finished its execution\",\n                       threads[i]); \n          } catch (InterruptedException e) { \n            logger.log(Level.SEVERE, \"Exception\", e); \n          } \n        }\n\n```", "```java\n          logger.exiting(Main.class.getName(), \"main()\"); \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private ReentrantLock lock;\n\n```", "```java\n        public Task(ReentrantLock lock) { \n          this.lock=lock; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          lock.lock(); \n          try { \n            TimeUnit.SECONDS.sleep(1); \n            lock.unlock(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        ReentrantLock lock=new ReentrantLock();\n\n```", "```java\n          for (int i=0; i<10; i++) { \n            Task task=new Task(lock); \n            Thread thread=new Thread(task); \n            thread.run(); \n          } \n        }\n\n```", "```java\n        public class Task1 implements Runnable {\n\n```", "```java\n        private Lock lock1, lock2;\n\n```", "```java\n        public Task1 (Lock lock1, Lock lock2) { \n          this.lock1=lock1; \n          this.lock2=lock2; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          lock1.lock(); \n          System.out.printf(\"Task 1: Lock 1 locked\\n\");\n\n```", "```java\n        lock2.lock(); \n        System.out.printf(\"Task 1: Lock 2 locked\\n\");\n\n```", "```java\n          lock2.unlock(); \n          lock1.unlock(); \n        }\n\n```", "```java\n        public class Task2 implements Runnable{\n\n```", "```java\n        private Lock lock1, lock2;\n\n```", "```java\n        public Task2(Lock lock1, Lock lock2) { \n          this.lock1=lock1; \n          this.lock2=lock2; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          lock2.lock(); \n          System.out.printf(\"Task 2: Lock 2 locked\\n\");\n\n```", "```java\n        lock1.lock(); \n        System.out.printf(\"Task 2: Lock 1 locked\\n\");\n\n```", "```java\n          lock1.unlock(); \n          lock2.unlock(); \n        }\n\n```", "```java\n        public class Main {\n\n```", "```java\n        Lock lock1, lock2; \n        lock1=new ReentrantLock(); \n        lock2=new ReentrantLock();\n\n```", "```java\n        Task1 task1=new Task1(lock1, lock2);\n\n```", "```java\n        Task2 task2=new Task2(lock1, lock2);\n\n```", "```java\n        Thread thread1=new Thread(task1); \n        Thread thread2=new Thread(task2); \n\n        thread1.start(); \n        thread2.start();\n\n```", "```java\n        while ((thread1.isAlive()) &&(thread2.isAlive())) { \n          System.out.println(\"Main: The example is\"+ \"running\"); \n          try { \n            TimeUnit.MILLISECONDS.sleep(500); \n          } catch (InterruptedException ex) { \n            ex.printStackTrace(); \n          } \n        }\n\n```", "```java\n    @Override \n    public void run() { \n      synchronized(lock1) { \n        System.out.printf(\"Task 1: Lock 1 locked\\n\"); \n        synchronized(lock2) { \n          System.out.printf(\"Task 1: Lock 2 locked\\n\"); \n        } \n      } \n    }\n\n```", "```java\n        public class ProducerConsumerTest extends MultithreadedTestCase {\n\n```", "```java\n        private LinkedTransferQueue<String> queue;\n\n```", "```java\n        @Override \n        public void initialize() { \n          super.initialize(); \n          queue=new LinkedTransferQueue<String>(); \n          System.out.printf(\"Test: The test has been initialized\\n\"); \n        }\n\n```", "```java\n        public void thread1() throws InterruptedException { \n          String ret=queue.take(); \n          System.out.printf(\"Thread 1: %s\\n\",ret); \n        }\n\n```", "```java\n        public void thread2() throws InterruptedException { \n          waitForTick(1); \n          String ret=queue.take(); \n          System.out.printf(\"Thread 2: %s\\n\",ret); \n        }\n\n```", "```java\n         public void thread3() { \n          waitForTick(1); \n          waitForTick(2); \n          queue.put(\"Event 1\"); \n          queue.put(\"Event 2\"); \n          System.out.printf(\"Thread 3: Inserted two elements\\n\"); \n        }\n\n```", "```java\n        public void finish() { \n          super.finish(); \n          System.out.printf(\"Test: End\\n\"); \n          assertEquals(true, queue.size()==0); \n          System.out.printf(\"Test: Result: The queue is empty\\n\"); \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) throws Throwable {\n\n```", "```java\n        ProducerConsumerTest test=new ProducerConsumerTest();\n\n```", "```java\n        System.out.printf(\"Main: Starting the test\\n\"); \n        TestFramework.runOnce(test); \n        System.out.printf(\"Main: The test has finished\\n\");\n\n```", "```java\n        public class Task implements Runnable { \n\n          @Override \n          public void run() { \n\n            Date start, end; \n            start = new Date(); \n            do { \n              System.out.printf(\"%s: tick\\n\",\n                                Thread.currentThread().getName()); \n              end = new Date(); \n            } while (end.getTime() - start.getTime() < 100000); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n\n            Thread[] threads = new Thread[10]; \n\n            for (int i=0; i<10; i++) { \n              Task task=new Task(); \n              threads[i]=new Thread(task); \n              threads[i].start(); \n            } \n\n            for (int i=0; i<10; i++) { \n              try { \n                threads[i].join(); \n              } catch (InterruptedException e) { \n                e.printStackTrace(); \n              } \n            } \n          } \n        }\n\n```"]