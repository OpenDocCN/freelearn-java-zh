- en: Advanced Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级特性
- en: In this chapter, we are going to explore the more advanced features of Scala.
    As with any programming language, some advanced constructs might be seldom used
    in practice or can obfuscate code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Scala的更高级特性。与任何编程语言一样，一些高级构造在实际应用中可能很少使用，或者可能会使代码变得难以理解。
- en: We will aim to only explain features that we have encountered in real projects
    that have been deployed to production. Some features are used more in libraries
    or in the SDK than in a typical project, but it is important to understand them
    in order to be able to use a library effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将致力于解释我们在实际项目中遇到并部署到生产环境中的特性。有些特性在库或SDK中使用得更多，但在典型项目中使用得较少，但理解它们对于有效地使用库来说很重要。
- en: As these features are varied and cover a large spectrum, we found it easier
    to explain them using ad hoc code examples rather than a complete project. You
    can, therefore, jump directly to any section of this chapter if you are already
    familiar with some of these concepts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些特性种类繁多，覆盖范围广泛，我们发现使用专门的代码示例来解释它们比使用完整的项目更容易。因此，如果你已经熟悉这些概念中的某些，可以直接跳转到本章的任何部分。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Strictness and laziness, and their impact on performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格性和懒性，以及它们对性能的影响
- en: Covariance and contravariance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协变性和逆变
- en: Currying and partially applied functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化和部分应用函数
- en: Implicit usage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式使用
- en: Project setup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'All the examples of this chapter have been committed to the following Git repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有示例都已提交到以下Git仓库：
- en: '[https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects)'
- en: If you want to run the code examples in this chapter, you need to clone this
    repository and import the project into IntelliJ. Each section has a corresponding
    Scala worksheet file—for instance, the next section's examples are in the `lazyness.sc` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要运行本章中的代码示例，你需要克隆这个仓库并将项目导入IntelliJ。每个部分都有一个相应的Scala工作表文件——例如，下一节的示例在`lazyness.sc`文件中。
- en: The solutions to the exercises are given in these worksheets, and so it would
    be more profitable to you if you do not read them completely until you have tried
    to do the exercises.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 练习的答案已经包含在这些工作表中，因此在你尝试做练习之前完全阅读它们对你来说可能更有利。
- en: Strictness and laziness
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格性和懒性
- en: Scala's default evaluation strategy is strict. This means that if you don't
    do anything special, any variable declaration or arguments of a function call
    are immediately evaluated. The opposite of a strict evaluation strategy is a lazy
    evaluation strategy, which means that evaluation is performed only when needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的默认评估策略是严格的。这意味着如果你不做任何特殊处理，任何变量声明或函数调用中的参数都会立即被评估。严格评估策略的反面是懒评估策略，这意味着只有在需要时才会进行评估。
- en: Strict val
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Strict val
- en: 'The following is a strict variable declaration:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个严格的变量声明：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that `println` is called immediately. This means that the block at
    the right side of the assignment is evaluated as soon as the `StrictDemo` class
    is instantiated. If we want to delay the block's evaluation, we have to use the
    `lazy `prefix.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`println`被立即调用。这意味着赋值右侧的代码块在`StrictDemo`类被实例化时立即被评估。如果我们想延迟代码块的评估，我们必须使用`lazy`前缀。
- en: lazy val
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lazy val
- en: 'When we use the `lazy` prefix in front of `val` or `var` (as shown in the following
    code), it is evaluated only when needed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`val`或`var`前使用`lazy`前缀（如下面的代码所示）时，它只会在需要时进行评估：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we instantiate the class, the block at the right side of the assignment
    is not evaluated. It will only get evaluated when we use the variable, as shown
    in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化类时，赋值右侧的代码块不会被评估。它只在我们使用变量时才会被评估，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This mechanism allows you to defer the evaluation of computationally expensive
    operations. For instance, you could use it to start an application quickly and
    run the initialization code only when the first user needs it. Scala guarantees
    that the evaluation will be performed only once, even if there are multiple threads
    trying to use the variable at the same time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制允许你延迟计算密集型操作的评估。例如，你可以用它来快速启动应用程序，并且只有在第一个用户需要时才运行初始化代码。Scala保证即使有多个线程同时尝试使用该变量，评估也只会执行一次。
- en: 'You can have chains of `lazy` values, which will get evaluated only when the
    last element of the chain is required, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有`lazy`值的链，这些值只有在链的最后一个元素需要时才会被评估，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we require `val3`, the three values get evaluated, as shown in the following
    code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求`val3`时，三个值将被评估，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By-name parameters
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名参数
- en: We can go a bit further and delay the evaluation of function arguments. A by-name
    parameter is like a function that does not take any argument. This way, it only gets evaluated
    when the function's body requires it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，延迟函数参数的评估。命名参数就像一个不接受任何参数的函数。这样，它只有在函数体需要它时才会被评估。
- en: 'Say that you have an application that loads its configuration from a file or
    a database. You want the application to start as fast as possible, and so you
    decide to use `lazy val` to load a greeting message on demand, as shown in the
    following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个应用程序，它从文件或数据库中加载其配置。你希望应用程序尽可能快地启动，因此你决定使用`lazy val`按需加载问候消息，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that for the sake of brevity we haven't actually loaded anything here—just
    imagine that we did.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了简洁起见，我们在这里实际上没有加载任何内容——只是想象我们已经做了。
- en: 'If we then want to use the greeting variable in a function but keep delaying
    its evaluation, we can use a by-name parameter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在函数中使用问候变量但保持延迟其评估，我们可以使用命名参数：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `AppConfig.greeting` phrase is not evaluated the first time we call `greet`
    with `"Bob"`, because the body of the function did not require it. It is only
    evaluated when we call `greet` with `"Mikael"`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次用`"Bob"`调用`greet`时，`AppConfig.greeting`短语不会被评估，因为函数体不需要它。它只在我们用`"Mikael"`调用`greet`时才会被评估。
- en: In some cases, using by-name parameters can enhance the performance of a program,
    because the evaluation of an expensive operation can be skipped if it is not required.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用命名参数可以增强程序的性能，因为如果不需要，可以跳过昂贵操作的评估。
- en: Lazy data structures
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒数据结构
- en: 'Here is a function definition that calls the strict methods of `Vector`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个调用`Vector`严格方法的函数定义：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It prints the following on the console:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它在控制台上打印以下内容：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see that `Vector` is iterated twice: once for `filter`, and once for
    `map`. But our `evenPlusOne` function would be faster if it could iterate only
    once. One way to do this would be to change the implementation and use `collect`.
    Another way would be to use the non-strict `withFilter` method, as shown in the
    following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Vector`被迭代了两次：一次用于`filter`，一次用于`map`。但是，如果`evenPlusOne`函数只迭代一次，它将更快。做到这一点的一种方法是将实现方式改变并使用`collect`。另一种方法是使用非严格的`withFilter`方法，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `withFilter` method prints the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`withFilter`方法打印以下内容：'
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, `Vector` is iterated only once. Each element is filtered and then
    mapped one by one. This is because `withFilter` is a lazy operation—it does not
    immediately create a new filtered `Vector`, but instead creates a new `withFilter` object that
    will store the filter's predicate. This SDK collection `withFilter `type has a
    special implementation of `map` that will call the filter's predicate before calling
    the function passed to `map`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Vector`只迭代了一次。每个元素都被过滤，然后逐个映射。这是因为`withFilter`是一个懒操作——它不会立即创建一个新的过滤`Vector`，而是创建一个新的`withFilter`对象，该对象将存储过滤器的谓词。这个SDK集合`withFilter`类型有一个特殊的`map`实现，它会在调用传递给`map`的函数之前调用过滤器的谓词。
- en: 'This works pretty well as long as you only have one `map` or `flatMap` operation,
    or if you further refine your `filter` with another call to `withFilter`. However,
    if you call another `map` operation, the collection will be iterated twice, as
    shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只要只有一个`map`或`flatMap`操作，或者如果你通过另一个`withFilter`调用进一步细化`filter`，这种方法就会非常好。然而，如果你调用另一个`map`操作，集合将被迭代两次，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code prints the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码打印以下内容：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that the calls to `map2` are made at the end, which means that we
    iterated a second time over `Vector(1, 3)`. We need a lazier data structure that
    will not iterate until we actually need each element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对`map2`的调用是在最后进行的，这意味着我们对`Vector(1, 3)`进行了第二次迭代。我们需要一个更懒的数据结构，它不会在我们实际需要每个元素之前进行迭代。
- en: 'In the Scala SDK, this collection type is `Stream`. If we replace `Vector`
    with `Stream` in our `lazyEvenPlusTwo` function, then we get the desired behavior,
    as shown in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala SDK中，这种集合类型是`Stream`。如果我们将`Vector`替换为`Stream`在我们的`lazyEvenPlusTwo`函数中，那么我们就会得到期望的行为，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the call to our function, we convert the resulting `Stream` to `Vector`.
    It is this call to `toVector` that materializes the elements of the stream and
    calls the anonymous functions passed to `filter` and `map`. The following code
    is what gets printed on the console:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用我们的函数后，我们将结果 `Stream` 转换为 `Vector`。正是这个 `toVector` 调用将流中的元素具体化，并调用传递给 `filter`
    和 `map` 的匿名函数。以下是在控制台上打印的代码：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that `Stream` is iterated only once. For each element, we call `filter`,
    then `map` and `map2`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `Stream` 只被迭代一次。对于每个元素，我们调用 `filter`，然后 `map` 和 `map2`。
- en: 'But there is more to it. Since `Stream` is lazy, it can be used to represent
    infinite collections. The following code shows how we can get a `Stream` of all
    the positive even integers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有更多。由于 `Stream` 是惰性的，它可以用来表示无限集合。以下代码显示了如何获取所有正偶数的 `Stream`：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We use the `Stream` operator `#::`, which builds `Stream` with a head element
    and a tail. It works the same way as the `List` operator `::`, but in a lazy way.
    The following steps show how it works:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Stream` 操作符 `#::`，它使用头部元素和尾部构建 `Stream`。它的工作方式与 `List` 操作符 `::` 相同，但以惰性的方式进行。以下步骤显示了它是如何工作的：
- en: 'We build `Stream 0 #:: 2`, which has `0` as its head and a tail with one element, `2`.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们构建 `Stream 0 #:: 2`，其头部为 `0`，尾部有一个元素，`2`。'
- en: 'The third element will be `(0 #:: 2).tail.map(_ + 2)`. At this stage, the tail
    is only `Stream(2)`, and so the third element will be `4`.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第三个元素将是 `(0 #:: 2).tail.map(_ + 2)`。在这个阶段，尾部只有 `Stream(2)`，因此第三个元素将是 `4`。'
- en: 'The fourth element will be `(0 #:: 2 #:: 4).tail.map(_ + 2)`. The same process
    repeats for all subsequent elements.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第四个元素将是 `(0 #:: 2 #:: 4).tail.map(_ + 2)`。相同的过程会重复应用于所有后续元素。'
- en: Since our `Stream` is infinite, we cannot convert all of it to `Vector`, as
    this would go on forever. We just take the first 10 elements with `take(10)` and
    then convert them to `Vector`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `Stream` 是无限的，我们不能将其全部转换为 `Vector`，因为这会无限进行。我们只需用 `take(10)` 取前 10 个元素，然后将它们转换为
    `Vector`。
- en: Covariance and contravariance
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协变性和反对称性
- en: 'When an `F` type accepts a type parameter of `A`, we can add a `+` or `-` sign
    in front of the parameter declaration to indicate the **variance** of `F` on `A`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `F` 类型接受 `A` 类型的类型参数时，我们可以在参数声明前添加一个 `+` 或 `-` 符号来指示 `F` 在 `A` 上的 **变异性**：
- en: '`F[+A]` makes `F` **covariant** on `A`. This means that if `B <:< A` (where `B`
    extends `A`), then `F[B] <:< F[A]`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F[+A]` 使 `F` 在 `A` 上 **协变**。这意味着如果 `B <:< A`（其中 `B` 扩展 `A`），那么 `F[B] <:< F[A]`。'
- en: '`F[-A]` makes `F` **contravariant** on `A`. If `B <:< A`, then `F[A]  <:< F[B]`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F[-A]` 使 `F` 在 `A` 上 **反对称**。如果 `B <:< A`，那么 `F[A] <:< F[B]`。'
- en: '`F[A]` makes `F` **invariant** on `A`. If `B <:< A`, then there is no relationship
    between `F[A]` and `F[B]`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F[A]` 使 `F` 在 `A` 上 **不变**。如果 `B <:< A`，则 `F[A]` 和 `F[B]` 之间没有关系。'
- en: InvariantDecoder
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InvariantDecoder
- en: 'We are now going to explore this variance concept with an example. Let''s start
    with a simple class hierarchy, as shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过一个示例来探索这个变异性概念。让我们从一个简单的类层次结构开始，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this hierarchy, I can declare a variable of an `Animal` type and assign
    it to an instance of a `Cat` or `Dog` type. The following code will compile:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个层次结构，我可以声明一个 `Animal` 类型的变量，并将其分配给 `Cat` 或 `Dog` 类型的实例。以下代码可以编译：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'More generally, the assignment `val a: A = b: B` compiles if `B <:< A`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '更一般地，如果 `B <:< A`，则赋值 `val a: A = b: B` 可以编译。'
- en: You can check that type `B` extends type `A` with the expression `implicitly[B
    <:< A]`; if it compiles, then `B` is a subtype of `A`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用表达式 `implicitly[B <:< A]` 检查类型 `B` 是否扩展类型 `A`；如果它可以编译，那么 `B` 是 `A` 的子类型。
- en: 'Then, we define an `InvariantDecoder` trait that has a single `decode` method.
    There is no `+` or `-` sign, and so `InvariantDecoder` is invariant on `A`, as
    shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个只有一个 `decode` 方法的 `InvariantDecoder` 特质。没有 `+` 或 `-` 符号，因此 `InvariantDecoder`
    在 `A` 上是 **不变的**，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After this, we implement `InvariantDecoder` for `Cat`, as shown in the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为 `Cat` 实现 `InvariantDecoder`，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we call `decode` with a string that matches the `CatRegex` regular expression,
    we obtain a `Cat` instance wrapped in an `Option` instance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用匹配 `CatRegex` 正则表达式的字符串调用 `decode` 时，我们获得一个 `Cat` 实例包裹在 `Option` 实例中。
- en: 'But what if we declare a variable of the `InvariantDecoder[Animal] `type? Can
    we assign our `InvariantCatDecoder` to it? Let''s try it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们声明一个 `InvariantDecoder[Animal]` 类型的变量呢？我们可以将我们的 `InvariantCatDecoder` 分配给它吗？让我们试试：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code does not compile, but the compiler is very helpful in this
    case. The following code is the error you will get:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码无法编译，但编译器在这种情况下非常有帮助。以下是你将得到的错误：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It tells us that if we want to make this line compile, we have to make `InvariantDecoder`
    covariant in type `A`. To do so, we have to add a `+` sign in front of the `A` parameter in
    `InvariantDecoder`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们，如果我们想让这一行编译，我们必须使 `InvariantDecoder` 在类型 `A` 上协变。为此，我们必须在 `InvariantDecoder`
    中的 `A` 参数前添加一个 `+` 符号。
- en: CovariantDecoder
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协变解码器
- en: 'Let''s follow the compiler''s advice and create a new `CovariantDecoder[+A]`,
    along with a `CovariantCatDecoder` instance that extends it, as shown in the following
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循编译器的建议，创建一个新的 `CovariantDecoder[+A]`，以及一个扩展它的 `CovariantCatDecoder` 实例，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We do not show the implementation of `decode` in `CovariantCatDecoder`; it
    is the same as in `InvariantCatDecoder`. With this covariant parameter, the following
    relationship is verified:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有展示 `CovariantCatDecoder` 中 `decode` 的实现；它与 `InvariantCatDecoder` 中的相同。有了这个协变参数，以下关系得到验证：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, we can assign the `CovariantCatDecoder` to an instance of `CovariantDecoder[Animal]`,
    as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以将 `CovariantCatDecoder` 赋值给 `CovariantDecoder[Animal]` 的一个实例，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we call `decode` on it, we get back an `Option[Animal]`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `decode` 时，我们得到一个 `Option[Animal]`。
- en: At first, glance, having `CovariantDecoder` seems natural—if my decoder can
    produce `Cat`, and `Cat` is an `Animal`, my decoder should also be a decoder of
    `Animal`. On the other hand, if I have an instance of `Decoder[Animal]`, I would
    expect it to be able to decode any `Animal`—not only `Cat`, but also `Dog` instances—and
    this is not the case for our earlier `covariantAnimalDecoder`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，拥有 `CovariantDecoder` 似乎是自然的——如果我的解码器可以产生 `Cat`，而 `Cat` 是 `Animal`，那么我的解码器也应该是一个
    `Animal` 的解码器。另一方面，如果我有一个 `Decoder[Animal]` 的实例，我会期望它能够解码任何 `Animal`——不仅 `Cat`，还包括
    `Dog` 实例——但这并不是我们之前 `covariantAnimalDecoder` 的情况。
- en: There is no right or wrong design here; this is just a matter of taste. In general,
    I would advise you to use invariant type parameters first, and if you then experience
    some limitations with it, you can decide to make them covariant or contravariant.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有对或错的设计；这只是口味的问题。一般来说，我建议你首先使用不变类型参数，如果你在使用它时遇到一些限制，你可以决定使它们协变或逆变。
- en: 'The full covariant implementation for getting `Cat` and `Dog` would be the
    following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `Cat` 和 `Dog` 的完整协变实现如下：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Contravariant encoder
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆变编码器
- en: 'Now, we would like to model the opposite of decoding a string to an object—encoding
    an object to a string! We make our `Encoder` contravariant by adding a `-` sign
    in front of the `A` type parameter, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要模拟将字符串解码为对象的相反操作——将对象编码为字符串！我们通过在 `A` 类型参数前添加一个 `-` 符号使我们的 `Encoder`
    逆变，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code is an instance of this `Encoder`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是这个 `Encoder` 的一个实例：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have the `Cat <:< Animal `relationship, and `Encoder` is contravariant on
    its argument. This implies that `Encoder[Animal] <:< Encoder[Cat]`, and I can,
    therefore, assign `Encoder[Animal]` to a variable of type `Encoder[Cat]`, as shown
    in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `Cat <:< Animal` 的关系，并且 `Encoder` 在其参数上是逆变的。这意味着 `Encoder[Animal] <:< Encoder[Cat]`，因此我可以将
    `Encoder[Animal]` 赋值给类型为 `Encoder[Cat]` 的变量，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Similar to the covariant decoder, the contravariance of the encoder seems natural—if
    I can encode any `Animal`, I can also encode `Cat`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与协变解码器类似，编码器的逆变看起来很自然——如果我可以编码任何 `Animal`，我也可以编码 `Cat`。
- en: However, if we wanted to create a single `Codec` trait that can encode and decode,
    we would be in trouble. The type parameter cannot be covariant and contravariant
    at the same time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要创建一个可以编码和解码的单个 `Codec` 特性，我们就会遇到麻烦。类型参数不能同时是协变和逆变。
- en: 'The only way to make it work would be to make the type parameter invariant,
    as in the following implementation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作的唯一方法是将类型参数设置为不变，如下面的实现所示：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But let''s see what happens if we attempt to use a covariance. The compiler
    would return the following error:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看如果我们尝试使用协变会发生什么。编译器会返回以下错误：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The compiler complains about the `A` type being in a contravariant position.
    This is because in functions, the parameters are always in a contravariant position,
    and the result is always in a covariant position. For instance, if you open `scala.Function3`,
    you will see the following declaration:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器对 `A` 类型处于逆变位置表示不满。这是因为函数中，参数总是处于逆变位置，而结果总是处于协变位置。例如，如果你打开 `scala.Function3`，你会看到以下声明：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This implies the following two things:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下两点：
- en: If you declare a type parameter as covariant with `+A`, then the `A `type can
    only appear in the **result** of a method
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将类型参数声明为使用 `+A` 进行协变，那么 `A` 类型只能出现在方法的 **结果** 中
- en: If you declare a type parameter as contravariant with `-A`, then the `A` type can
    only appear in the **parameters** of a method
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将类型参数声明为使用 `-A` 进行逆变，那么 `A` 类型只能出现在方法的 **参数** 中
- en: In our `decode` method, `A` appears in the result and hence is in a covariant
    position. This is why we could make the decoder covariant on A by using `+A` in
    `CovariantDecoder`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `decode` 方法中，`A` 出现在结果中，因此它处于协变位置。这就是为什么我们可以通过在 `CovariantDecoder` 中使用
    `+A` 来使解码器在 `A` 上协变。
- en: Conversely, in our `encode` method, `A` appears in the parameters, and hence
    it is in a contravariant position. This is why we could make the encoder contravariant
    on `A` by using `-A` in `Encoder`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在我们的 `encode` 方法中，`A` 出现在参数中，因此它处于逆变位置。这就是为什么我们可以通过在 `Encoder` 中使用 `-A` 来使编码器在
    `A` 上逆变。
- en: Another way to implement our `Codec` would be to use a type class. This is explained
    in [Chapter 5](d2e776f6-4446-4cb8-ba6d-f474cde4ff6f.xhtml), *Type Classes*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的 `Codec` 的另一种方式是使用类型类。这在上文[第5章](d2e776f6-4446-4cb8-ba6d-f474cde4ff6f.xhtml)，*类型类*中有所解释。
- en: Covariance in collections
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合中的协变
- en: 'Most collection types in the SDK are covariant. For instance, if you open the
    `Vector` class, you will see the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 中的大多数集合类型都是协变的。例如，如果你打开 `Vector` 类，你会看到以下内容：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This allows us to assign `Vector[B]` to a variable of `Vector[A] if B <:<A `type,
    as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将 `Vector[B]` 赋值给 `Vector[A]` 类型的变量，前提是 `B <:< A` 类型，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now here is a bit of magic:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一点魔法：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Scala not only allows us to add `Dog` to `Vector[Cat]`, but it also automatically
    infers the new collection to be of a `Vector[Product with Serializable with Animal] `type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 不仅允许我们将 `Dog` 添加到 `Vector[Cat]` 中，而且它还会自动推断新的集合类型为 `Vector[Product with
    Serializable with Animal]`。
- en: 'We saw earlier that the parameters of a function are in contravariant position.
    Therefore, it should not even be possible to have a `:+(a: A)`method that can
    add elements to the `Vector` class, because `Vector` is covariant on `A`! But
    there is a trick. If you look in the Vector source code at the definition of `:+`,
    the following code is what you will see:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '我们之前看到，函数的参数处于逆变位置。因此，甚至不可能有一个 `:+(a: A)` 方法可以向 `Vector` 类添加元素，因为 `Vector`
    在 `A` 上是协变的！但是有一个技巧。如果你查看 `Vector` 源代码中 `:+` 的定义，你会看到以下代码：'
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The method takes a `B `type parameter with the constraint that `B` must be a
    supertype of `A`. In our previous example, the `A `type was `Cat` and our `elem` argument was
    of the `Dog `type. The Scala compiler automatically inferred the `B` type to be
    the closest common supertype of `Dog` and `Cat`, which is `Product with Serializable
    with Animal`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个受约束的 `B` 类型参数，要求 `B` 必须是 `A` 的超类型。在我们之前的例子中，`A` 类型是 `Cat`，我们的 `elem`
    参数是 `Dog` 类型。Scala 编译器自动推断 `B` 类型为 `Dog` 和 `Cat` 的最接近的共同超类型，即 `Product with Serializable
    with Animal`。
- en: 'If we add `String` to this `Vector`, the resulting type will be the next common
    supertype between `Animal` and `String`, which is `Serializable`, as shown in
    the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `String` 添加到这个 `Vector` 中，结果类型将是 `Animal` 和 `String` 之间的下一个公共超类型，即 `Serializable`，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then, when we add an `Int` to the `Vector` class, the next common supertype
    between `Serializable` and `Int` is `Any`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们向 `Vector` 类添加一个 `Int` 时，`Serializable` 和 `Int` 之间的下一个公共超类型是 `Any`。
- en: 'If you have a class that has a covariant `MyClass[+A]` type parameter, and
    you need to implement a method with a parameter of an `A` type, then you can define
    it with a `B >: A `type parameter, written as `def myMethod[B >: A](b: B) = ...`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你有一个具有协变 `MyClass[+A]` 类型参数的类，并且你需要实现一个具有 `A` 类型参数的方法，那么你可以使用 `B >: A` 类型参数来定义它，写作
    `def myMethod[B >: A](b: B) = ...`。'
- en: Currying and partially applied functions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化和部分应用函数
- en: The name *currying* is a reference to the mathematician and logician Haskell
    Curry. The process of currying consists of transforming a function that takes
    multiple arguments into a sequence of functions, each with a single argument.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “柯里化”这个名字是对数学家和逻辑学家 Haskell Curry 的致敬。柯里化的过程包括将接受多个参数的函数转换为一系列函数，每个函数只有一个参数。
- en: Function value
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数值
- en: Before we start currying functions, we need to understand the difference between
    a function and a function value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始柯里化函数之前，我们需要理解函数和函数值的区别。
- en: 'You are already familiar with functions—they begin with the keyword `def`,
    take one or several parameter lists between `()` symbols, optionally declare a
    return type after a `:` sign, and have a defined body after the `=` sign, as shown
    in the following example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉函数——它们以关键字 `def` 开头，在括号 `()` 符号之间有一个或多个参数列表，可选地在冒号 `:` 后声明返回类型，并在等号 `=`
    后有一个定义的函数体，如下面的示例所示：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A function value (also called a **function literal**) is similar to any other
    value, such as `"hello": String`, `3: Int`, or `true: Boolean`. As with other
    values, you can pass a function value as an argument to a function, or assign
    it to a variable using the `val` keyword.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '函数值（也称为函数字面量）类似于任何其他值，例如 `"hello": String`、`3: Int` 或 `true: Boolean`。与其他值一样，您可以将函数值作为参数传递给函数，或使用
    `val` 关键字将其分配给变量。'
- en: 'You can declare function values directly, as shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接声明函数值，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or you can transform a function into a function value by adding a `_` character
    at the end of the function''s name, as shown in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过在函数名称末尾添加一个 `_` 字符将函数转换为函数值，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When it comes to applying arguments to a function, the syntax is the same whether
    we call a function or a function value, as shown in the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到向函数应用参数时，无论是调用函数还是函数值，语法都是相同的，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Currying
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'A curried function is a function that takes one parameter and returns another
    function that takes one parameter. You can convert a function value into a curried
    function value by calling the `.curried `method, as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数是一个接受一个参数并返回另一个接受一个参数的函数的函数。您可以通过调用 `.curried` 方法将函数值转换为柯里化函数值，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The call to `.curried` transforms the function value''s type from `(Int, Int)
    => Int` to `Int => (Int => Int)`. The `multiplyVal` takes two integers as parameters
    and returns an integer. The `multiplyCurried` takes one `Int` and returns a function
    that takes `Int` and returns `Int`. The two function values have exactly the same
    functionality—the difference lies in the way we call them, as shown in the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`.curried` 的调用将函数值的类型从 `(Int, Int) => Int` 转换为 `Int => (Int => Int)`。`multiplyVal`
    接受两个整数作为参数并返回一个整数。`multiplyCurried` 接受一个 `Int` 并返回一个接受 `Int` 并返回 `Int` 的函数。这两个函数值具有完全相同的功能——区别在于我们如何调用它们，如下面的代码所示：'
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we call `multiplyCurried(2)`, we apply only the first argument, and this
    returns a `Int => Int` function. At this stage, the function is not completely
    applied—it is a **partially applied** function. If we want to obtain the final
    result, we have to apply the second argument by calling `multiplyCurried(2)(3)`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `multiplyCurried(2)` 时，我们只应用了第一个参数，这返回了一个 `Int => Int` 函数。在这个阶段，函数还没有完全应用——它是一个**部分应用**函数。如果我们想要获得最终结果，我们必须通过调用
    `multiplyCurried(2)(3)` 来应用第二个参数。
- en: Partially applied functions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用函数
- en: 'In practice, there is no need to call `.curried` to define curried functions.
    You can declare curried functions directly with multiple parameter lists. Here
    is a curried function that calculates a discount to an `Item` class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，没有必要调用 `.curried` 来定义柯里化函数。您可以直接使用多个参数列表声明柯里化函数。以下是一个计算 `Item` 类折扣的柯里化函数示例：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can **fully apply** the function if we provide two argument lists, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供两个参数列表，我们可以**完全应用**函数，如下所示：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But we can also partially apply the function if we just provide the first argument
    list and add a `_` character to indicate that we want a function value, as shown
    in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们只提供第一个参数列表并添加一个 `_` 字符来表示我们想要一个函数值，我们也可以部分应用函数，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `discount10` function value is a partially applied function that takes `Item`
    and returns `Item`. We can then call it with an `Item` instance to fully apply
    it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`discount10` 函数值是一个部分应用函数，它接受 `Item` 并返回 `Item`。然后我们可以通过传递一个 `Item` 实例来调用它以完全应用它。'
- en: 'A partially applied function is especially useful when we need to pass anonymous
    functions to higher order functions (functions that accept functions as arguments),
    such as `map` or `filter`, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用函数在需要将匿名函数传递给高阶函数（接受函数作为参数的函数）时特别有用，例如 `map` 或 `filter`，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, the `map` function expects an argument of a `Item => B` type.
    We pass the `discount(10)`argument, which is a partially applied function of a
    `Item => Item` type. Thanks to partially applied functions, we managed to apply
    a discount to a collection of items without having to define a new function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`map` 函数期望一个 `Item => B` 类型的参数。我们传递了 `discount(10)` 参数，这是一个 `Item =>
    Item` 类型的部分应用函数。多亏了部分应用函数，我们才能够在不定义新函数的情况下对一系列商品应用折扣。
- en: Implicits
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式
- en: As its name indicates, the Scala keyword `implicit` can be used to implicitly add some
    extra code to the compiler. For instance, an implicit parameter in a function
    definition allows you to omit this parameter when you call the function. As a
    result, you do not have to pass this parameter explicitly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，Scala 关键字 `implicit` 可以用来隐式地向编译器添加一些额外的代码。例如，函数定义中的隐式参数允许你在调用函数时省略此参数。因此，你不必显式地传递此参数。
- en: 'There are different kinds of implicit in Scala that we will cover in this section:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Scala 中不同类型的隐式：
- en: An implicit parameter is declared in a function definition
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式参数在函数定义中被声明
- en: An implicit value is passed as an argument to a function that has an implicit
    parameter
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个隐式值被作为参数传递给一个具有隐式参数的函数
- en: An implicit conversion converts one type to another type
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式转换将一种类型转换为另一种类型
- en: 'This is an extremely powerful feature that can feel a bit like magic sometimes.
    In this section, we will see how it can help writing more concise code and also
    how to use it to validate some constraints at compile time. In the next chapter,
    we will use them to define another powerful concept: type classes.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的功能，有时会感觉有点像魔法。在本节中，我们将看到它如何帮助编写更简洁的代码，以及如何使用它来在编译时验证一些约束。在下一章中，我们将使用它们来定义另一个强大的概念：类型类。
- en: Implicit parameters
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式参数
- en: In a function definition, the last parameter list can be marked as `implicit`.
    Such a function can then be invoked without passing the corresponding arguments.
    When you omit the implicit arguments, the Scala compiler will try to find implicit
    values of the same type in the current scope and will use them as arguments to
    the function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，最后一个参数列表可以被标记为 `implicit`。这样的函数可以不传递相应的参数就调用。当你省略隐式参数时，Scala 编译器将尝试在当前作用域中查找相同类型的隐式值，并将它们用作函数的参数。
- en: 'Here is an illustration of this mechanism that you can type into a Scala worksheet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个你可以将其输入到 Scala 工作表中的这个机制的说明：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We first declare a new `AppContext` class and assign a new instance of this
    class to an `implicit val`. The `val myAppCtx` can be used like a normal `val`,
    but in addition, the `implicit` keyword indicates to the compiler that this `val`
    is a candidate for **implicit resolution**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个新的 `AppContext` 类，并将这个类的新实例分配给一个 `implicit val`。`val myAppCtx` 可以像正常的
    `val` 一样使用，但 `implicit` 关键字还向编译器指示这个 `val` 是隐式解析的候选者。
- en: The definition of the `greeting` function has an `implicit` marker on its last
    parameter list. When we call it without passing the `appCtx` argument, the compiler
    tries to resolve this implicit parameter. This implicit resolution tries to find
    an implicit value of an `AppContext` type in the current scope. The only implicit
    value with this type is `myAppCtx`, and hence this is the argument that is used
    for `appCtx`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting` 函数的定义在其最后一个参数列表上有 `implicit` 标记。当我们不传递 `appCtx` 参数调用它时，编译器会尝试解析这个隐式参数。这个隐式解析尝试在当前作用域中查找
    `AppContext` 类型的隐式值。唯一具有这种类型的隐式值是 `myAppCtx`，因此这就是用于 `appCtx` 的参数。'
- en: Note that the implicit resolution is performed at compile time. If the compiler
    cannot resolve the implicit parameter, it will raise an error. Also, if there
    are several implicit values of the same type in the current scope, the compiler
    will be unable to decide which one to pick, and will raise an error because of
    ambiguous implicit values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，隐式解析是在编译时进行的。如果编译器无法解析隐式参数，它将引发错误。此外，如果当前作用域中有多个相同类型的隐式值，编译器将无法决定选择哪一个，并会因为模糊的隐式值而引发错误。
- en: 'In a large code base, it can sometimes be difficult to know what implicit value
    is chosen on a given function call. Fortunately, IntelliJ can show this to you.
    Position your cursor on the `greeting("hello ")` line and go to View | Implicit
    parameters, or press *Ctrl *+ *Shift *+ *P* (Linux/Windows) or *Meta *+ *Shift
    +* *P* (macOS). You should see the following tooltip, as shown in the following
    screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型代码库中，有时很难知道在给定的函数调用中选择了哪个隐式值。幸运的是，IntelliJ 可以显示给你。将光标置于 `greeting("hello
    ")` 行，然后转到视图 | 隐式参数，或者按住 *Ctrl* + *Shift* + *P*（Linux/Windows）或 *Meta* + *Shift
    +* *P*（macOS）。你应该会看到以下提示，如下面的截图所示：
- en: '![](img/6c1fc20e-91f7-4df6-8faf-559c84bce872.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c1fc20e-91f7-4df6-8faf-559c84bce872.png)'
- en: You can then click on the parameter shown in the tooltip. IntelliJ will jump
    to the declaration of the implicit value.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击提示中显示的参数。IntelliJ 将跳转到隐式值的声明。
- en: 'The arguments for the implicit parameter list can also be passed explicitly.
    The following call is equivalent to the previous one:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数列表的参数也可以显式传递。以下调用与上一个调用等价：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When you pass the implicit arguments explicitly, the implicit resolution mechanism
    does not kick in.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显式传递隐式参数时，隐式解析机制不会启动。
- en: An implicit parameter should have a type that has very few instances. It would
    not make sense to have an implicit parameter of a type string; there would be
    too many candidates for resolving it. This would make the code difficult to understand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数应该有一个实例非常少的类型。拥有一个类型为字符串的隐式参数是没有意义的；会有太多的候选者来解析它。这将使代码难以理解。
- en: Implicit parameter usage
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式参数使用
- en: Implicit parameters are useful when you have to repeatedly pass the same argument
    to many functions. This happens frequently for configuration parameters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要反复将相同的参数传递给许多函数时，隐式参数非常有用。这种情况在配置参数中经常发生。
- en: Passing a timeout
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递超时
- en: 'Imagine that you implemented a `PriceService` trait that calls an external
    website to get the price of a product. You defined its interface as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你实现了一个名为 `PriceService` 的特质，它通过调用外部网站来获取产品的价格。你定义了它的接口如下：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The external website might not be responsive, and so our service has to wait
    a certain amount of time before giving up, indicated by the parameter `timeout`.
    As we have seen in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling
    Errors*, the service would return `Invalid[NonEmptyList[String]]` if there were
    any problem getting the price, or `Valid[Double]` if we can obtain the price.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 外部网站可能不会响应，因此我们的服务必须等待一段时间后才会放弃，这由参数 `timeout` 表示。正如我们在[第3章](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml)中看到的，*处理错误*，如果获取价格时出现任何问题，服务将返回
    `Invalid[NonEmptyList[String]]`，如果我们能够获取价格，则返回 `Valid[Double]`。
- en: In a large application, you could have many more services defined like this.
    Using an implicit parameter allows you to call these functions without having
    to pass the `timeout` argument each time. Furthermore, if you need to add other
    configuration parameters, you could add more implicit parameters without having
    to change all your function calls.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型应用程序中，你可以定义更多这样的服务。使用隐式参数允许你调用这些函数而无需每次都传递 `timeout` 参数。此外，如果你需要添加其他配置参数，你可以添加更多的隐式参数，而无需更改所有的函数调用。
- en: 'When you want to call the service, you would need to have `implicit val timeout:
    Timeout` in your scope. This gives you a good amount of flexibility, as you have
    total control over where you define this `timeout` and how you bring it to the
    current scope. The following list shows some options for this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '当你想调用该服务时，你需要在你的作用域中拥有 `implicit val timeout: Timeout`。这为你提供了很大的灵活性，因为你完全控制在哪里定义这个
    `timeout` 以及如何将其带到当前作用域。以下列出了一些选项：'
- en: 'You could define it only once in a `object AppConfig { implicit val defaultTimeout:
    Timeout = ??? }` singleton for the whole application. In this object, you could
    hard code its value or read it from a configuration file. When you need to call
    a service, all you have to do is `import AppConfig.defaultTimeout` to bring it
    to the current scope.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '你可以在 `object AppConfig { implicit val defaultTimeout: Timeout = ??? }` 单例中只定义一次，用于整个应用程序。在这个对象中，你可以将其值硬编码或从配置文件中读取。当你需要调用服务时，你只需要
    `import AppConfig.defaultTimeout` 就可以将它带到当前作用域。'
- en: You could use one value for production code and a different one for test code.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为生产代码使用一个值，为测试代码使用另一个值。
- en: You could have one part of your application using one value, say for fast services,
    and another part using a different value for slow services.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序的某一部分可以使用一个值，比如用于快速服务，而另一部分可以使用不同的值用于慢速服务。
- en: Passing an application context
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递应用程序上下文
- en: If you have many other configuration parameters to pass to your functions, it
    can be more convenient to put them in an `ApplicationContext` class and declare
    an implicit parameter of this class in your functions. The added benefit is that
    this context can not only store configuration parameters, but it can also hold
    references to commonly used service classes. This mechanism can effectively replace
    dependency injection frameworks, such as Spring or Guice, that you might have
    used with Java.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多其他配置参数需要传递给你的函数，将其放在一个`ApplicationContext`类中并在你的函数中声明这个类的隐式参数会更方便。额外的优势是，这个上下文不仅可以存储配置参数，还可以持有常用服务类的引用。这种机制可以有效地替代你可能使用过的Java依赖注入框架，如Spring或Guice。
- en: 'For instance, say that we have an application that implements a `DataService`
    trait. It has two methods that can load and save `Product` objects from a database,
    as shown in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个实现`DataService`特质的程序。它有两个方法可以从数据库加载和保存`Product`对象，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We would typically have two implementations of this trait:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会为这个特质实现两个版本：
- en: One in the production code that will interact with a real database.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个在生产代码中，它将交互一个真实的数据库。
- en: One in the test code that will save a `Product` in memory for the duration of
    the test. This will allow us to run tests more quickly and to keep the tests independent
    from any external system.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在测试代码中，它将在测试期间将`Product`保存在内存中。这将使我们能够更快地运行测试，并使测试独立于任何外部系统。
- en: 'We can then define an `AppContext` class, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个`AppContext`类，如下所示：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This context would have different implementations for the production and the
    test code. This will let you implement complex functions without having to connect
    to the database or to an external service when running your tests. For instance,
    we can implement an `updatePrice` function using an `implicit appContext` parameter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个上下文将针对生产代码和测试代码有不同的实现。这将让你在运行测试时无需连接到数据库或外部服务就能实现复杂的函数。例如，我们可以使用`implicit
    appContext`参数实现一个`updatePrice`函数：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function loads a product from the database, obtains its new price by calling
    the `priceService`, and saves the product with the updated price. It will return
    a `Valid[Double]` containing the new price, or `Invalid[NonEmptyList[String]]`
    containing the errors if any of the services go wrong. When writing the unit test
    for this function, we would pass `AppContext`, which holds fake implementations
    of `PriceService` and `DataService`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从数据库中加载一个产品，通过调用`priceService`获取其新价格，并使用更新后的价格保存产品。它将返回一个包含新价格的`Valid[Double]`，或者在服务出现错误时返回包含错误信息的`Invalid[NonEmptyList[String]]`。在为这个函数编写单元测试时，我们会传递`AppContext`，它包含`PriceService`和`DataService`的模拟实现。
- en: Examples in the SDK
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDK中的示例
- en: The **Scala Development Kit** (**SDK**) makes use of implicit parameters in
    various places. We will explore some common uses that you will encounter as a
    more experienced Scala developer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scala开发工具包**（**SDK**）在多个地方使用了隐式参数。我们将探讨一些作为更有经验的Scala开发者你可能会遇到的常见用法。'
- en: breakOut
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: breakOut
- en: The definition of several methods on the Scala collection API, such as `map`,
    has an implicit parameter of a `CanBuildFrom `type. This type is used to build
    a collection of the same type as the input type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Scala集合API上几个方法的定义，如`map`，有一个`CanBuildFrom`类型的隐式参数。这个类型用于构建与输入类型相同类型的集合。
- en: 'For instance, when you call `map` on a `Vector`, the return type will still
    be a `Vector`, as shown in the following code run in the REPL:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你对一个`Vector`调用`map`时，返回类型仍然是一个`Vector`，如下面的REPL中运行的代码所示：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you position your cursor in IntelliJ at the `map` method and press cmd
    + left-click, you will see that `map` is declared in `TraversableLike`, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在IntelliJ中将光标定位在`map`方法上并按下cmd + left-click时，你会看到`map`是在`TraversableLike`中声明的，如下所示：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `TraversableLike` trait is a super trait of many Scala collections, such
    as `Vector`, `List`, `HashSet`, and many more. It implements many methods that
    are common to all these collections. In many of these methods, the `bf: CanBuildFrom`
    parameter is used to build a collection of the same type as the original collection.
    If you jump to the definition of `CanBuildFrom`, you will see that it has three
    type parameters, as shown in the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first parameter, `From`, is the type of the original collection (`Vector`,
    `List`, and many more). The second parameter, `Elem`, is the type of the elements
    contained in the collection. The third parameter, `To`, is the type of the target
    collection.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our example, this means that when we called `.map` on our `Vector`,
    an implicit parameter of the `CanBuildFrom` type was passed. We can see where
    it is declared by once more positioning our cursor at the `map` method, and going
    to View | Implicit parameters, or pressing cmd + s*hift* + *P*. If we then click
    on the tooltip text, we will jump to this definition in `Vector.scala`, as shown
    in the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can see that the `To` target parameter in `CanBuildFrom` is of the `Vector[A]` type.
    This explains why the `vec` variable in our example is of the `Vector[(String,
    Int)]` type.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is quite complicated, but you do not have to understand it in
    detail unless you want to implement your own collection types. The SDK does a
    good job of hiding these details when you are just a user of the library.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one thing that is useful to remember is that you can pass a different
    `CanBuildFrom` parameter to avoid unnecessary transformations. For instance, imagine
    that we want to build `Map[String, Int]`, where the key is a string and the value
    is the length of that string. Going back to our example, the most immediate way
    would be to call `.toMap`, as shown in the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The problem with this approach is that it will iterate twice through the elements
    of the `Vector` class: once for mapping the elements, and once for building `Map`.
    On a small collection, this is not an issue, but on large collections, the performance
    can be affected.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can build our `Map` in one iteration. If we pass the special
    `breakOut `object when calling `map`, the target type of `CanBuildFrom` will be
    the type of the receiving variable, as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This simple trick can improve the performance of your application, and does
    not degrade the readability.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Collection transformation operations, such as `.toMap`, `toVector`, and many
    more, can often be removed. Try to pass `breakOut` in the previous transformation;
    it will save one iteration.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: executionContext
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Future` class in the Scala SDK allows you to run computations asynchronously.
    We will explore this in more detail in [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml),
    *Online Shopping – Persistence*, but in this section, we will explore how it makes
    use of implicit parameters to provide an execution context.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Scala SDK中的`Future`类允许你异步运行计算。我们将在第6章中更详细地探讨这一点，*在线购物——持久化*，但在这个部分，我们将探讨它是如何使用隐式参数来提供执行上下文的。
- en: 'Open a Scala console and enter the following code. It should create a `Future`
    computation that will print the name of the current thread when it gets executed:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个Scala控制台并输入以下代码。它应该创建一个`Future`计算，当它执行时将打印当前线程的名称：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since we are missing an implicit in our scope, you should see the following
    error:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在作用域内缺少隐式转换，你应该看到以下错误：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The compiler tells us that we must have an `implicit ExecutionContext` in scope.
    An `ExecutionContext` is a class that can execute some computations asynchronously,
    typically using a thread pool. As suggested by the compiler, we can use the default
    execution context by importing `scala.concurrent.ExecutionContext.Implicits.global`,
    as shown in the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器告诉我们，我们必须在作用域内有一个`implicit ExecutionContext`。`ExecutionContext`是一个可以异步执行一些计算的类，通常使用线程池。如编译器所建议，我们可以通过导入`scala.concurrent.ExecutionContext.Implicits.global`来使用默认的执行上下文，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the previous snippet, the value of `res1` could be as:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`res1`的值可以是：
- en: '`res1: scala.concurrent.Future[Unit] = Future(<not completed>)`As this is `Future`,
    we don''t know when it''s going to finish; it will depend on your machine.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`res1: scala.concurrent.Future[Unit] = Future(<未完成>)`由于这是一个`Future`，我们不知道它何时完成；这取决于你的机器。'
- en: 'We can see that the name of the thread used to execute our `println` statement
    was `scala-execution-context-global-11`. If we want to run our computation using
    a different thread pool, we can declare a new `ExecutionContext`. Restart the
    Scala console and enter the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，用于执行我们的`println`语句的线程名称是`scala-execution-context-global-11`。如果我们想使用不同的线程池来运行我们的计算，我们可以声明一个新的`ExecutionContext`。重新启动Scala控制台并输入以下代码：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We can observe that the thread used to run our code is now coming from a different
    thread pool. Many methods on `Future` have an implicit `ExecutionContext` parameter.
    By changing the implicit in scope, you can control how the asynchronous computations
    get executed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，运行我们的代码所使用的线程现在来自不同的线程池。`Future`上的许多方法都有一个隐式的`ExecutionContext`参数。通过更改作用域内的隐式转换，你可以控制异步计算如何执行。
- en: This is especially useful when using some database drivers—you would typically
    use a separate thread pool to query the database, with one thread per database
    connection. On the other hand, CPU-bound computations can use the default thread
    pool, which will be initialized with the number of CPU cores available on your
    machine.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这在使用某些数据库驱动程序时特别有用——你通常会使用单独的线程池来查询数据库，每个数据库连接一个线程。另一方面，CPU密集型计算可以使用默认的线程池，该线程池将初始化为你的机器上可用的CPU核心数。
- en: Implicit conversion
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: 'An implicit conversion converts a source type to a target type. This allows
    you to do the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换将源类型转换为目标类型。这允许你做以下操作：
- en: Use methods of the target type as if they were declared on the source type
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目标类型的方法用作在源类型上声明的方法
- en: Pass the source type as an argument in functions that accept the target type
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接受目标类型的函数中将源类型作为参数传递
- en: 'For instance, we could treat the `String` type as if it were `LocalDate` using
    the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下代码将`String`类型视为`LocalDate`：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that IntelliJ highlights a yellow warning `Advanced language feature:
    implicit conversion` on the `implicit` keyword.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IntelliJ在`implicit`关键字上突出显示了一个黄色的警告`高级语言功能：隐式转换`。
- en: If you want to get rid of this warning, you can position the cursor on the `implicit`
    keyword, then press *Alt* + *Enter*, and choose to Enable implicit conversion.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想消除这个警告，可以将光标放在`implicit`关键字上，然后按*Alt* + *Enter*，并选择启用隐式转换。
- en: 'After this declaration, if we have a `String` object that can be parsed into
    a `LocalDate`, we can call any of the methods normally available on `LocalDate`,
    as shown in the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在此声明之后，如果我们有一个可以解析为`LocalDate`的`String`对象，我们可以调用`LocalDate`上正常可用的任何方法，如下面的代码所示：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can also call functions that accept `LocalDate` using normal strings as
    arguments, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用普通字符串作为参数调用接受`LocalDate`的函数，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This looks a bit like magic, and it is indeed not easy to spot that there is
    an implicit conversion happening when reading the code. Fortunately, IntelliJ
    can help us.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点像魔术，确实在阅读代码时不容易发现正在发生隐式转换。幸运的是，IntelliJ 可以帮助我们。
- en: First, you might notice that the `getDayOfWeek` and `getYear` methods are underlined.
    This is to show that the method is defined on an implicitly converted type.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能会注意到 `getDayOfWeek` 和 `getYear` 方法被下划线标注。这是为了表明该方法是在隐式转换的类型上定义的。
- en: 'IntelliJ can also help us find where the implicit conversion is defined. Position
    your cursor on one of the strings and press c*trl* *+* *Q* on macOS (or click
    on Navigate | Implicit conversion). You should see the following popup:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 还可以帮助我们找到隐式转换的定义位置。将光标放在其中一个字符串上，然后在 macOS 上按 `ctrl` + `+` + `Q`（或点击“导航”|“隐式转换”）。你应该会看到一个以下弹出窗口：
- en: '![](img/726d9aad-a975-4cad-8734-32fa52500e5d.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/726d9aad-a975-4cad-8734-32fa52500e5d.png)'
- en: The popup highlights the implicit conversion function that is applied. You can
    then click on it to jump to its declaration. Note that IntelliJ also shows some
    other possible implicit conversions coming from the SDK.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出窗口突出显示了应用的隐式转换函数。然后你可以点击它跳转到其声明。请注意，IntelliJ 还显示了来自 SDK 的其他一些可能的隐式转换。
- en: 'This conversion to `LocalDate` may appear to be quite nice; however, if we
    use a string that cannot be parsed, the code will throw exceptions at runtime,
    as shown in the following code. As we have seen in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml),
    *Handling Errors*, this is best avoided:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换为 `LocalDate` 可能看起来相当不错；然而，如果我们使用一个无法解析的字符串，代码将在运行时抛出异常，如下面的代码所示。正如我们在[第
    3 章](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml)“处理错误”中看到的，这最好避免：
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This example of implicit conversion was for illustrative purposes only.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐式转换的例子只是为了说明。
- en: Since our conversion can throw exceptions, it would make the code unsafe if
    we were to use it in production code. It can, however, be useful for writing more
    concise unit tests.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的转换可能会抛出异常，如果我们将其用于生产代码中，这将使代码变得不安全。然而，它对于编写更简洁的单元测试却很有用。
- en: Implicit conversions are very powerful, and with great power comes great responsibility!
    It is not recommended that you define implicit conversions from common types of
    the SDK (`String`, `Int`, and many more) to other SDK types. It can quickly make
    your code difficult to read.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换非常强大，而大权在握也伴随着巨大的责任！不建议你从 SDK 的常见类型（如 `String`、`Int` 等）定义隐式转换到其他 SDK 类型。这可能会迅速使你的代码难以阅读。
- en: Implicit class
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式类
- en: 'Implicit conversions are often used to add additional methods to an existing
    type. This is called the **pimp my library** pattern. For instance, if we want
    to add a `square `method on the `Int` type, we can proceed as follows. Type the
    following code in a Scala console:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换通常用于向现有类型添加额外的方法。这被称为“pimp my library”模式。例如，如果我们想在 `Int` 类型上添加一个 `square`
    方法，我们可以按照以下步骤进行。在 Scala 控制台中输入以下代码：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `5` gets implicitly converted to `IntOps`, which provides the `square` method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`5` 被隐式转换为 `IntOps`，它提供了 `square` 方法。'
- en: Note that `IntOps` extends `AnyVal`. This extension makes it a **value class**.
    The benefit of a value class is that the compiler will avoid allocating a new
    object when we call the `square` method. The produced bytecode will be as efficient
    as if `square` was defined directly inside the `Int` class. The compile-time type
    is `IntOps`, but the runtime type will be `Int`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `IntOps` 扩展了 `AnyVal`。这种扩展使其成为一个**值类**。值类的优点是编译器将避免在我们调用 `square` 方法时分配新对象。生成的字节码将和直接在
    `Int` 类中定义 `square` 一样高效。编译时的类型是 `IntOps`，但运行时的类型将是 `Int`。
- en: One of the limitations of value classes is that they must be defined in the
    top level of a file or inside an object. If you try to run the preceding code
    in a Scala worksheet, you will get a `Value class may not be a member of another
    class` compilation error<q>. </q>This is a consequence of the way Scala worksheets
    are evaluated—the code inside a worksheet belongs to a non-static object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 值类的一个限制是它们必须在文件的顶层或对象内部定义。如果你尝试在一个 Scala 工作表中运行前面的代码，你将得到一个编译错误：“值类不能是另一个类的成员”。<q>这是
    Scala 工作表评估方式的结果——工作表内的代码属于一个非静态对象。
- en: 'This pimp my library pattern is very useful whenever you want to add new capabilities
    to classes you cannot change, such as the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想向无法更改的类添加新功能时，这种“pimp my library”模式非常有用，例如以下情况：
- en: Classes that are part of the SDK or that come from a third-party library.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For your own classes, you can make some methods accessible from a server module,
    but not from a client module.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scala offers some syntactic sugar to make this pattern more concise. We can
    rewrite the preceding code with an implicit class definition as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The compiler transforms an implicit class declaration into a class and implicit
    conversion. The two forms are equivalent.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is commonly used in the SDK, especially for "pimping" classes coming
    from the Java Development Kit.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `java.lang.String` can be pimped by `scala.collection.immutable.StringOps`,
    as shown in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the first line, we call the `reverse` method, which is a pimped method coming
    from `StringOps`. By underlining the `reverse `method, IntelliJ shows you that
    it is not a method defined on `java.lang.String`. If you move your cursor to the
    first string, `"abcd"`, and press *Ctrl* + *Shift* + *Q*, you should see a pop-up
    window showing you that `"abcd"` is implicitly converted to `StringOps` using
    `Predef.augmentString`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In lines 2 and 3, we are showing you how we could explicitly convert our string
    to `StringOps` and call the same method. This is for illustrative purposes; in
    a real project, you would only rely on the implicit conversion.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: How are implicits resolved?
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have declared implicit values and implicit conversions in the same
    scope as where they were used. But we can define them in other files too.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scala compiler has a set of rules to find implicit parameters or implicit
    conversions. The compiler goes through the following steps and adheres to the
    following rules:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the current scope as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicits defined in the current scope:** These should be in the same function
    or class or object. This is how we defined it in the previous section.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit import:** You can define an implicit value `implValue` in an object
    `myObj`, and bring it to the current scope with the statement `import myObj.implValue`.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wildcard import:** `import myObj._`.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look at the associated types:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Companion object of the source type:** For instance, in the companion object
    of `Option`, there is an implicit conversion to `Iterable`. This allows you to
    call any method of `Iterable` on an `Option` instance. Also, if a function expects
    an `Iterable` parameter, you can pass an `Option` instance.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Companion object of a parameter''s type:** For instance, if you call `List(1,
    2, 3).sorted`, the `sorted `method actually takes an implicit parameter of the
    `Ordering[Int]`type. This implicit value can be found in the companion object
    of `Ordering`.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Companion object of a parameter''s type parameter:** When a function''s parameter
    has an `A `type parameter, for instance, `Ordering[A]`, the companion object of
    `A` is searched for implicits. Here is an example:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this example, the `sorted` method expects an implicit parameter of an `Ordering[Person]` type,
    which can be found in the companion object of the `Person `type parameter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`sorted` 方法期望一个隐式参数为 `Ordering[Person]` 类型，这个类型可以在 `Person` 类型参数的伴随对象中找到。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered quite a lot of material in this chapter. You learned how to
    improve performance using the `lazy` variable, and learned about covariance and
    contravariance. You also learned how to partially apply functions using currying
    techniques, and finally, we went through all the different ways of using implicit
    in Scala. Some concepts, such as currying, are also used in other functional programming
    languages, such as Haskell.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。你学习了如何使用 `lazy` 变量来提高性能，并了解了协变和逆变。你还学习了如何使用柯里化技术部分应用函数，最后，我们探讨了在
    Scala 中使用隐式的所有不同方式。一些概念，如柯里化，也用于其他函数式编程语言，如 Haskell。
- en: In the next chapter, we are going to go deeper into type theory by introducing
    the type classes. Type classes is the concept of grouping the same types sharing
    a common behavior.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过引入类型类来深入探讨类型理论。类型类是分组具有共同行为的相同类型的概念。
