- en: Advanced Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the more advanced features of Scala.
    As with any programming language, some advanced constructs might be seldom used
    in practice or can obfuscate code.
  prefs: []
  type: TYPE_NORMAL
- en: We will aim to only explain features that we have encountered in real projects
    that have been deployed to production. Some features are used more in libraries
    or in the SDK than in a typical project, but it is important to understand them
    in order to be able to use a library effectively.
  prefs: []
  type: TYPE_NORMAL
- en: As these features are varied and cover a large spectrum, we found it easier
    to explain them using ad hoc code examples rather than a complete project. You
    can, therefore, jump directly to any section of this chapter if you are already
    familiar with some of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Strictness and laziness, and their impact on performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariance and contravariance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying and partially applied functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the examples of this chapter have been committed to the following Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to run the code examples in this chapter, you need to clone this
    repository and import the project into IntelliJ. Each section has a corresponding
    Scala worksheet file—for instance, the next section's examples are in the `lazyness.sc` file.
  prefs: []
  type: TYPE_NORMAL
- en: The solutions to the exercises are given in these worksheets, and so it would
    be more profitable to you if you do not read them completely until you have tried
    to do the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Strictness and laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala's default evaluation strategy is strict. This means that if you don't
    do anything special, any variable declaration or arguments of a function call
    are immediately evaluated. The opposite of a strict evaluation strategy is a lazy
    evaluation strategy, which means that evaluation is performed only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Strict val
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a strict variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `println` is called immediately. This means that the block at
    the right side of the assignment is evaluated as soon as the `StrictDemo` class
    is instantiated. If we want to delay the block's evaluation, we have to use the
    `lazy `prefix.
  prefs: []
  type: TYPE_NORMAL
- en: lazy val
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we use the `lazy` prefix in front of `val` or `var` (as shown in the following
    code), it is evaluated only when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we instantiate the class, the block at the right side of the assignment
    is not evaluated. It will only get evaluated when we use the variable, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This mechanism allows you to defer the evaluation of computationally expensive
    operations. For instance, you could use it to start an application quickly and
    run the initialization code only when the first user needs it. Scala guarantees
    that the evaluation will be performed only once, even if there are multiple threads
    trying to use the variable at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have chains of `lazy` values, which will get evaluated only when the
    last element of the chain is required, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we require `val3`, the three values get evaluated, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By-name parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can go a bit further and delay the evaluation of function arguments. A by-name
    parameter is like a function that does not take any argument. This way, it only gets evaluated
    when the function's body requires it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say that you have an application that loads its configuration from a file or
    a database. You want the application to start as fast as possible, and so you
    decide to use `lazy val` to load a greeting message on demand, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that for the sake of brevity we haven't actually loaded anything here—just
    imagine that we did.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we then want to use the greeting variable in a function but keep delaying
    its evaluation, we can use a by-name parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `AppConfig.greeting` phrase is not evaluated the first time we call `greet`
    with `"Bob"`, because the body of the function did not require it. It is only
    evaluated when we call `greet` with `"Mikael"`.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, using by-name parameters can enhance the performance of a program,
    because the evaluation of an expensive operation can be skipped if it is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a function definition that calls the strict methods of `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `Vector` is iterated twice: once for `filter`, and once for
    `map`. But our `evenPlusOne` function would be faster if it could iterate only
    once. One way to do this would be to change the implementation and use `collect`.
    Another way would be to use the non-strict `withFilter` method, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `withFilter` method prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This time, `Vector` is iterated only once. Each element is filtered and then
    mapped one by one. This is because `withFilter` is a lazy operation—it does not
    immediately create a new filtered `Vector`, but instead creates a new `withFilter` object that
    will store the filter's predicate. This SDK collection `withFilter `type has a
    special implementation of `map` that will call the filter's predicate before calling
    the function passed to `map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works pretty well as long as you only have one `map` or `flatMap` operation,
    or if you further refine your `filter` with another call to `withFilter`. However,
    if you call another `map` operation, the collection will be iterated twice, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the calls to `map2` are made at the end, which means that we
    iterated a second time over `Vector(1, 3)`. We need a lazier data structure that
    will not iterate until we actually need each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Scala SDK, this collection type is `Stream`. If we replace `Vector`
    with `Stream` in our `lazyEvenPlusTwo` function, then we get the desired behavior,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the call to our function, we convert the resulting `Stream` to `Vector`.
    It is this call to `toVector` that materializes the elements of the stream and
    calls the anonymous functions passed to `filter` and `map`. The following code
    is what gets printed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `Stream` is iterated only once. For each element, we call `filter`,
    then `map` and `map2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is more to it. Since `Stream` is lazy, it can be used to represent
    infinite collections. The following code shows how we can get a `Stream` of all
    the positive even integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Stream` operator `#::`, which builds `Stream` with a head element
    and a tail. It works the same way as the `List` operator `::`, but in a lazy way.
    The following steps show how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We build `Stream 0 #:: 2`, which has `0` as its head and a tail with one element, `2`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third element will be `(0 #:: 2).tail.map(_ + 2)`. At this stage, the tail
    is only `Stream(2)`, and so the third element will be `4`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fourth element will be `(0 #:: 2 #:: 4).tail.map(_ + 2)`. The same process
    repeats for all subsequent elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since our `Stream` is infinite, we cannot convert all of it to `Vector`, as
    this would go on forever. We just take the first 10 elements with `take(10)` and
    then convert them to `Vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance and contravariance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an `F` type accepts a type parameter of `A`, we can add a `+` or `-` sign
    in front of the parameter declaration to indicate the **variance** of `F` on `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F[+A]` makes `F` **covariant** on `A`. This means that if `B <:< A` (where `B`
    extends `A`), then `F[B] <:< F[A]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F[-A]` makes `F` **contravariant** on `A`. If `B <:< A`, then `F[A]  <:< F[B]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F[A]` makes `F` **invariant** on `A`. If `B <:< A`, then there is no relationship
    between `F[A]` and `F[B]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InvariantDecoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to explore this variance concept with an example. Let''s start
    with a simple class hierarchy, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this hierarchy, I can declare a variable of an `Animal` type and assign
    it to an instance of a `Cat` or `Dog` type. The following code will compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, the assignment `val a: A = b: B` compiles if `B <:< A`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can check that type `B` extends type `A` with the expression `implicitly[B
    <:< A]`; if it compiles, then `B` is a subtype of `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we define an `InvariantDecoder` trait that has a single `decode` method.
    There is no `+` or `-` sign, and so `InvariantDecoder` is invariant on `A`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we implement `InvariantDecoder` for `Cat`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When we call `decode` with a string that matches the `CatRegex` regular expression,
    we obtain a `Cat` instance wrapped in an `Option` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we declare a variable of the `InvariantDecoder[Animal] `type? Can
    we assign our `InvariantCatDecoder` to it? Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does not compile, but the compiler is very helpful in this
    case. The following code is the error you will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It tells us that if we want to make this line compile, we have to make `InvariantDecoder`
    covariant in type `A`. To do so, we have to add a `+` sign in front of the `A` parameter in
    `InvariantDecoder`.
  prefs: []
  type: TYPE_NORMAL
- en: CovariantDecoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the compiler''s advice and create a new `CovariantDecoder[+A]`,
    along with a `CovariantCatDecoder` instance that extends it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not show the implementation of `decode` in `CovariantCatDecoder`; it
    is the same as in `InvariantCatDecoder`. With this covariant parameter, the following
    relationship is verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we can assign the `CovariantCatDecoder` to an instance of `CovariantDecoder[Animal]`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When we call `decode` on it, we get back an `Option[Animal]`.
  prefs: []
  type: TYPE_NORMAL
- en: At first, glance, having `CovariantDecoder` seems natural—if my decoder can
    produce `Cat`, and `Cat` is an `Animal`, my decoder should also be a decoder of
    `Animal`. On the other hand, if I have an instance of `Decoder[Animal]`, I would
    expect it to be able to decode any `Animal`—not only `Cat`, but also `Dog` instances—and
    this is not the case for our earlier `covariantAnimalDecoder`.
  prefs: []
  type: TYPE_NORMAL
- en: There is no right or wrong design here; this is just a matter of taste. In general,
    I would advise you to use invariant type parameters first, and if you then experience
    some limitations with it, you can decide to make them covariant or contravariant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full covariant implementation for getting `Cat` and `Dog` would be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Contravariant encoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we would like to model the opposite of decoding a string to an object—encoding
    an object to a string! We make our `Encoder` contravariant by adding a `-` sign
    in front of the `A` type parameter, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is an instance of this `Encoder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the `Cat <:< Animal `relationship, and `Encoder` is contravariant on
    its argument. This implies that `Encoder[Animal] <:< Encoder[Cat]`, and I can,
    therefore, assign `Encoder[Animal]` to a variable of type `Encoder[Cat]`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the covariant decoder, the contravariance of the encoder seems natural—if
    I can encode any `Animal`, I can also encode `Cat`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we wanted to create a single `Codec` trait that can encode and decode,
    we would be in trouble. The type parameter cannot be covariant and contravariant
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to make it work would be to make the type parameter invariant,
    as in the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But let''s see what happens if we attempt to use a covariance. The compiler
    would return the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler complains about the `A` type being in a contravariant position.
    This is because in functions, the parameters are always in a contravariant position,
    and the result is always in a covariant position. For instance, if you open `scala.Function3`,
    you will see the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This implies the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: If you declare a type parameter as covariant with `+A`, then the `A `type can
    only appear in the **result** of a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you declare a type parameter as contravariant with `-A`, then the `A` type can
    only appear in the **parameters** of a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our `decode` method, `A` appears in the result and hence is in a covariant
    position. This is why we could make the decoder covariant on A by using `+A` in
    `CovariantDecoder`.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, in our `encode` method, `A` appears in the parameters, and hence
    it is in a contravariant position. This is why we could make the encoder contravariant
    on `A` by using `-A` in `Encoder`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to implement our `Codec` would be to use a type class. This is explained
    in [Chapter 5](d2e776f6-4446-4cb8-ba6d-f474cde4ff6f.xhtml), *Type Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance in collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most collection types in the SDK are covariant. For instance, if you open the
    `Vector` class, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to assign `Vector[B]` to a variable of `Vector[A] if B <:<A `type,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here is a bit of magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Scala not only allows us to add `Dog` to `Vector[Cat]`, but it also automatically
    infers the new collection to be of a `Vector[Product with Serializable with Animal] `type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw earlier that the parameters of a function are in contravariant position.
    Therefore, it should not even be possible to have a `:+(a: A)`method that can
    add elements to the `Vector` class, because `Vector` is covariant on `A`! But
    there is a trick. If you look in the Vector source code at the definition of `:+`,
    the following code is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The method takes a `B `type parameter with the constraint that `B` must be a
    supertype of `A`. In our previous example, the `A `type was `Cat` and our `elem` argument was
    of the `Dog `type. The Scala compiler automatically inferred the `B` type to be
    the closest common supertype of `Dog` and `Cat`, which is `Product with Serializable
    with Animal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add `String` to this `Vector`, the resulting type will be the next common
    supertype between `Animal` and `String`, which is `Serializable`, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Then, when we add an `Int` to the `Vector` class, the next common supertype
    between `Serializable` and `Int` is `Any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a class that has a covariant `MyClass[+A]` type parameter, and
    you need to implement a method with a parameter of an `A` type, then you can define
    it with a `B >: A `type parameter, written as `def myMethod[B >: A](b: B) = ...`.'
  prefs: []
  type: TYPE_NORMAL
- en: Currying and partially applied functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name *currying* is a reference to the mathematician and logician Haskell
    Curry. The process of currying consists of transforming a function that takes
    multiple arguments into a sequence of functions, each with a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: Function value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start currying functions, we need to understand the difference between
    a function and a function value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are already familiar with functions—they begin with the keyword `def`,
    take one or several parameter lists between `()` symbols, optionally declare a
    return type after a `:` sign, and have a defined body after the `=` sign, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A function value (also called a **function literal**) is similar to any other
    value, such as `"hello": String`, `3: Int`, or `true: Boolean`. As with other
    values, you can pass a function value as an argument to a function, or assign
    it to a variable using the `val` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare function values directly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can transform a function into a function value by adding a `_` character
    at the end of the function''s name, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to applying arguments to a function, the syntax is the same whether
    we call a function or a function value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A curried function is a function that takes one parameter and returns another
    function that takes one parameter. You can convert a function value into a curried
    function value by calling the `.curried `method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `.curried` transforms the function value''s type from `(Int, Int)
    => Int` to `Int => (Int => Int)`. The `multiplyVal` takes two integers as parameters
    and returns an integer. The `multiplyCurried` takes one `Int` and returns a function
    that takes `Int` and returns `Int`. The two function values have exactly the same
    functionality—the difference lies in the way we call them, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When we call `multiplyCurried(2)`, we apply only the first argument, and this
    returns a `Int => Int` function. At this stage, the function is not completely
    applied—it is a **partially applied** function. If we want to obtain the final
    result, we have to apply the second argument by calling `multiplyCurried(2)(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Partially applied functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In practice, there is no need to call `.curried` to define curried functions.
    You can declare curried functions directly with multiple parameter lists. Here
    is a curried function that calculates a discount to an `Item` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can **fully apply** the function if we provide two argument lists, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also partially apply the function if we just provide the first argument
    list and add a `_` character to indicate that we want a function value, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `discount10` function value is a partially applied function that takes `Item`
    and returns `Item`. We can then call it with an `Item` instance to fully apply
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A partially applied function is especially useful when we need to pass anonymous
    functions to higher order functions (functions that accept functions as arguments),
    such as `map` or `filter`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `map` function expects an argument of a `Item => B` type.
    We pass the `discount(10)`argument, which is a partially applied function of a
    `Item => Item` type. Thanks to partially applied functions, we managed to apply
    a discount to a collection of items without having to define a new function.
  prefs: []
  type: TYPE_NORMAL
- en: Implicits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name indicates, the Scala keyword `implicit` can be used to implicitly add some
    extra code to the compiler. For instance, an implicit parameter in a function
    definition allows you to omit this parameter when you call the function. As a
    result, you do not have to pass this parameter explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different kinds of implicit in Scala that we will cover in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: An implicit parameter is declared in a function definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implicit value is passed as an argument to a function that has an implicit
    parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implicit conversion converts one type to another type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an extremely powerful feature that can feel a bit like magic sometimes.
    In this section, we will see how it can help writing more concise code and also
    how to use it to validate some constraints at compile time. In the next chapter,
    we will use them to define another powerful concept: type classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a function definition, the last parameter list can be marked as `implicit`.
    Such a function can then be invoked without passing the corresponding arguments.
    When you omit the implicit arguments, the Scala compiler will try to find implicit
    values of the same type in the current scope and will use them as arguments to
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustration of this mechanism that you can type into a Scala worksheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We first declare a new `AppContext` class and assign a new instance of this
    class to an `implicit val`. The `val myAppCtx` can be used like a normal `val`,
    but in addition, the `implicit` keyword indicates to the compiler that this `val`
    is a candidate for **implicit resolution**.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `greeting` function has an `implicit` marker on its last
    parameter list. When we call it without passing the `appCtx` argument, the compiler
    tries to resolve this implicit parameter. This implicit resolution tries to find
    an implicit value of an `AppContext` type in the current scope. The only implicit
    value with this type is `myAppCtx`, and hence this is the argument that is used
    for `appCtx`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the implicit resolution is performed at compile time. If the compiler
    cannot resolve the implicit parameter, it will raise an error. Also, if there
    are several implicit values of the same type in the current scope, the compiler
    will be unable to decide which one to pick, and will raise an error because of
    ambiguous implicit values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a large code base, it can sometimes be difficult to know what implicit value
    is chosen on a given function call. Fortunately, IntelliJ can show this to you.
    Position your cursor on the `greeting("hello ")` line and go to View | Implicit
    parameters, or press *Ctrl *+ *Shift *+ *P* (Linux/Windows) or *Meta *+ *Shift
    +* *P* (macOS). You should see the following tooltip, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c1fc20e-91f7-4df6-8faf-559c84bce872.png)'
  prefs: []
  type: TYPE_IMG
- en: You can then click on the parameter shown in the tooltip. IntelliJ will jump
    to the declaration of the implicit value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments for the implicit parameter list can also be passed explicitly.
    The following call is equivalent to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When you pass the implicit arguments explicitly, the implicit resolution mechanism
    does not kick in.
  prefs: []
  type: TYPE_NORMAL
- en: An implicit parameter should have a type that has very few instances. It would
    not make sense to have an implicit parameter of a type string; there would be
    too many candidates for resolving it. This would make the code difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit parameter usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicit parameters are useful when you have to repeatedly pass the same argument
    to many functions. This happens frequently for configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you implemented a `PriceService` trait that calls an external
    website to get the price of a product. You defined its interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The external website might not be responsive, and so our service has to wait
    a certain amount of time before giving up, indicated by the parameter `timeout`.
    As we have seen in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling
    Errors*, the service would return `Invalid[NonEmptyList[String]]` if there were
    any problem getting the price, or `Valid[Double]` if we can obtain the price.
  prefs: []
  type: TYPE_NORMAL
- en: In a large application, you could have many more services defined like this.
    Using an implicit parameter allows you to call these functions without having
    to pass the `timeout` argument each time. Furthermore, if you need to add other
    configuration parameters, you could add more implicit parameters without having
    to change all your function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to call the service, you would need to have `implicit val timeout:
    Timeout` in your scope. This gives you a good amount of flexibility, as you have
    total control over where you define this `timeout` and how you bring it to the
    current scope. The following list shows some options for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could define it only once in a `object AppConfig { implicit val defaultTimeout:
    Timeout = ??? }` singleton for the whole application. In this object, you could
    hard code its value or read it from a configuration file. When you need to call
    a service, all you have to do is `import AppConfig.defaultTimeout` to bring it
    to the current scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could use one value for production code and a different one for test code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could have one part of your application using one value, say for fast services,
    and another part using a different value for slow services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing an application context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have many other configuration parameters to pass to your functions, it
    can be more convenient to put them in an `ApplicationContext` class and declare
    an implicit parameter of this class in your functions. The added benefit is that
    this context can not only store configuration parameters, but it can also hold
    references to commonly used service classes. This mechanism can effectively replace
    dependency injection frameworks, such as Spring or Guice, that you might have
    used with Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say that we have an application that implements a `DataService`
    trait. It has two methods that can load and save `Product` objects from a database,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We would typically have two implementations of this trait:'
  prefs: []
  type: TYPE_NORMAL
- en: One in the production code that will interact with a real database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One in the test code that will save a `Product` in memory for the duration of
    the test. This will allow us to run tests more quickly and to keep the tests independent
    from any external system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then define an `AppContext` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This context would have different implementations for the production and the
    test code. This will let you implement complex functions without having to connect
    to the database or to an external service when running your tests. For instance,
    we can implement an `updatePrice` function using an `implicit appContext` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This function loads a product from the database, obtains its new price by calling
    the `priceService`, and saves the product with the updated price. It will return
    a `Valid[Double]` containing the new price, or `Invalid[NonEmptyList[String]]`
    containing the errors if any of the services go wrong. When writing the unit test
    for this function, we would pass `AppContext`, which holds fake implementations
    of `PriceService` and `DataService`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples in the SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Scala Development Kit** (**SDK**) makes use of implicit parameters in
    various places. We will explore some common uses that you will encounter as a
    more experienced Scala developer.
  prefs: []
  type: TYPE_NORMAL
- en: breakOut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of several methods on the Scala collection API, such as `map`,
    has an implicit parameter of a `CanBuildFrom `type. This type is used to build
    a collection of the same type as the input type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, when you call `map` on a `Vector`, the return type will still
    be a `Vector`, as shown in the following code run in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When you position your cursor in IntelliJ at the `map` method and press cmd
    + left-click, you will see that `map` is declared in `TraversableLike`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TraversableLike` trait is a super trait of many Scala collections, such
    as `Vector`, `List`, `HashSet`, and many more. It implements many methods that
    are common to all these collections. In many of these methods, the `bf: CanBuildFrom`
    parameter is used to build a collection of the same type as the original collection.
    If you jump to the definition of `CanBuildFrom`, you will see that it has three
    type parameters, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `From`, is the type of the original collection (`Vector`,
    `List`, and many more). The second parameter, `Elem`, is the type of the elements
    contained in the collection. The third parameter, `To`, is the type of the target
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our example, this means that when we called `.map` on our `Vector`,
    an implicit parameter of the `CanBuildFrom` type was passed. We can see where
    it is declared by once more positioning our cursor at the `map` method, and going
    to View | Implicit parameters, or pressing cmd + s*hift* + *P*. If we then click
    on the tooltip text, we will jump to this definition in `Vector.scala`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `To` target parameter in `CanBuildFrom` is of the `Vector[A]` type.
    This explains why the `vec` variable in our example is of the `Vector[(String,
    Int)]` type.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is quite complicated, but you do not have to understand it in
    detail unless you want to implement your own collection types. The SDK does a
    good job of hiding these details when you are just a user of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one thing that is useful to remember is that you can pass a different
    `CanBuildFrom` parameter to avoid unnecessary transformations. For instance, imagine
    that we want to build `Map[String, Int]`, where the key is a string and the value
    is the length of that string. Going back to our example, the most immediate way
    would be to call `.toMap`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this approach is that it will iterate twice through the elements
    of the `Vector` class: once for mapping the elements, and once for building `Map`.
    On a small collection, this is not an issue, but on large collections, the performance
    can be affected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can build our `Map` in one iteration. If we pass the special
    `breakOut `object when calling `map`, the target type of `CanBuildFrom` will be
    the type of the receiving variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This simple trick can improve the performance of your application, and does
    not degrade the readability.
  prefs: []
  type: TYPE_NORMAL
- en: Collection transformation operations, such as `.toMap`, `toVector`, and many
    more, can often be removed. Try to pass `breakOut` in the previous transformation;
    it will save one iteration.
  prefs: []
  type: TYPE_NORMAL
- en: executionContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Future` class in the Scala SDK allows you to run computations asynchronously.
    We will explore this in more detail in [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml),
    *Online Shopping – Persistence*, but in this section, we will explore how it makes
    use of implicit parameters to provide an execution context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Scala console and enter the following code. It should create a `Future`
    computation that will print the name of the current thread when it gets executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are missing an implicit in our scope, you should see the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler tells us that we must have an `implicit ExecutionContext` in scope.
    An `ExecutionContext` is a class that can execute some computations asynchronously,
    typically using a thread pool. As suggested by the compiler, we can use the default
    execution context by importing `scala.concurrent.ExecutionContext.Implicits.global`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, the value of `res1` could be as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`res1: scala.concurrent.Future[Unit] = Future(<not completed>)`As this is `Future`,
    we don''t know when it''s going to finish; it will depend on your machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the name of the thread used to execute our `println` statement
    was `scala-execution-context-global-11`. If we want to run our computation using
    a different thread pool, we can declare a new `ExecutionContext`. Restart the
    Scala console and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We can observe that the thread used to run our code is now coming from a different
    thread pool. Many methods on `Future` have an implicit `ExecutionContext` parameter.
    By changing the implicit in scope, you can control how the asynchronous computations
    get executed.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful when using some database drivers—you would typically
    use a separate thread pool to query the database, with one thread per database
    connection. On the other hand, CPU-bound computations can use the default thread
    pool, which will be initialized with the number of CPU cores available on your
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An implicit conversion converts a source type to a target type. This allows
    you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use methods of the target type as if they were declared on the source type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the source type as an argument in functions that accept the target type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, we could treat the `String` type as if it were `LocalDate` using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that IntelliJ highlights a yellow warning `Advanced language feature:
    implicit conversion` on the `implicit` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get rid of this warning, you can position the cursor on the `implicit`
    keyword, then press *Alt* + *Enter*, and choose to Enable implicit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this declaration, if we have a `String` object that can be parsed into
    a `LocalDate`, we can call any of the methods normally available on `LocalDate`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also call functions that accept `LocalDate` using normal strings as
    arguments, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This looks a bit like magic, and it is indeed not easy to spot that there is
    an implicit conversion happening when reading the code. Fortunately, IntelliJ
    can help us.
  prefs: []
  type: TYPE_NORMAL
- en: First, you might notice that the `getDayOfWeek` and `getYear` methods are underlined.
    This is to show that the method is defined on an implicitly converted type.
  prefs: []
  type: TYPE_NORMAL
- en: 'IntelliJ can also help us find where the implicit conversion is defined. Position
    your cursor on one of the strings and press c*trl* *+* *Q* on macOS (or click
    on Navigate | Implicit conversion). You should see the following popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/726d9aad-a975-4cad-8734-32fa52500e5d.png)'
  prefs: []
  type: TYPE_IMG
- en: The popup highlights the implicit conversion function that is applied. You can
    then click on it to jump to its declaration. Note that IntelliJ also shows some
    other possible implicit conversions coming from the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'This conversion to `LocalDate` may appear to be quite nice; however, if we
    use a string that cannot be parsed, the code will throw exceptions at runtime,
    as shown in the following code. As we have seen in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml),
    *Handling Errors*, this is best avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This example of implicit conversion was for illustrative purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: Since our conversion can throw exceptions, it would make the code unsafe if
    we were to use it in production code. It can, however, be useful for writing more
    concise unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions are very powerful, and with great power comes great responsibility!
    It is not recommended that you define implicit conversions from common types of
    the SDK (`String`, `Int`, and many more) to other SDK types. It can quickly make
    your code difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implicit conversions are often used to add additional methods to an existing
    type. This is called the **pimp my library** pattern. For instance, if we want
    to add a `square `method on the `Int` type, we can proceed as follows. Type the
    following code in a Scala console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `5` gets implicitly converted to `IntOps`, which provides the `square` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `IntOps` extends `AnyVal`. This extension makes it a **value class**.
    The benefit of a value class is that the compiler will avoid allocating a new
    object when we call the `square` method. The produced bytecode will be as efficient
    as if `square` was defined directly inside the `Int` class. The compile-time type
    is `IntOps`, but the runtime type will be `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the limitations of value classes is that they must be defined in the
    top level of a file or inside an object. If you try to run the preceding code
    in a Scala worksheet, you will get a `Value class may not be a member of another
    class` compilation error<q>. </q>This is a consequence of the way Scala worksheets
    are evaluated—the code inside a worksheet belongs to a non-static object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pimp my library pattern is very useful whenever you want to add new capabilities
    to classes you cannot change, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes that are part of the SDK or that come from a third-party library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For your own classes, you can make some methods accessible from a server module,
    but not from a client module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scala offers some syntactic sugar to make this pattern more concise. We can
    rewrite the preceding code with an implicit class definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The compiler transforms an implicit class declaration into a class and implicit
    conversion. The two forms are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is commonly used in the SDK, especially for "pimping" classes coming
    from the Java Development Kit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `java.lang.String` can be pimped by `scala.collection.immutable.StringOps`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we call the `reverse` method, which is a pimped method coming
    from `StringOps`. By underlining the `reverse `method, IntelliJ shows you that
    it is not a method defined on `java.lang.String`. If you move your cursor to the
    first string, `"abcd"`, and press *Ctrl* + *Shift* + *Q*, you should see a pop-up
    window showing you that `"abcd"` is implicitly converted to `StringOps` using
    `Predef.augmentString`.
  prefs: []
  type: TYPE_NORMAL
- en: In lines 2 and 3, we are showing you how we could explicitly convert our string
    to `StringOps` and call the same method. This is for illustrative purposes; in
    a real project, you would only rely on the implicit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: How are implicits resolved?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have declared implicit values and implicit conversions in the same
    scope as where they were used. But we can define them in other files too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scala compiler has a set of rules to find implicit parameters or implicit
    conversions. The compiler goes through the following steps and adheres to the
    following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the current scope as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicits defined in the current scope:** These should be in the same function
    or class or object. This is how we defined it in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit import:** You can define an implicit value `implValue` in an object
    `myObj`, and bring it to the current scope with the statement `import myObj.implValue`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wildcard import:** `import myObj._`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look at the associated types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Companion object of the source type:** For instance, in the companion object
    of `Option`, there is an implicit conversion to `Iterable`. This allows you to
    call any method of `Iterable` on an `Option` instance. Also, if a function expects
    an `Iterable` parameter, you can pass an `Option` instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Companion object of a parameter''s type:** For instance, if you call `List(1,
    2, 3).sorted`, the `sorted `method actually takes an implicit parameter of the
    `Ordering[Int]`type. This implicit value can be found in the companion object
    of `Ordering`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Companion object of a parameter''s type parameter:** When a function''s parameter
    has an `A `type parameter, for instance, `Ordering[A]`, the companion object of
    `A` is searched for implicits. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `sorted` method expects an implicit parameter of an `Ordering[Person]` type,
    which can be found in the companion object of the `Person `type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered quite a lot of material in this chapter. You learned how to
    improve performance using the `lazy` variable, and learned about covariance and
    contravariance. You also learned how to partially apply functions using currying
    techniques, and finally, we went through all the different ways of using implicit
    in Scala. Some concepts, such as currying, are also used in other functional programming
    languages, such as Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to go deeper into type theory by introducing
    the type classes. Type classes is the concept of grouping the same types sharing
    a common behavior.
  prefs: []
  type: TYPE_NORMAL
