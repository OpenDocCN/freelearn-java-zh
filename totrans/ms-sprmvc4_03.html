<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Handling Forms and Complex URL Mapping"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Handling Forms and Complex URL Mapping</h1></div></div></div><p>Our application, as beautiful as it looks, would benefit from more informations about our users.</p><p>We could as them to provide the topics they are interested in.</p><p>In this chapter, we will build a profile page. It will feature server- and client-side validation and file upload for a profile picture. We will save that information in the user session and also ensure that our audience is as large as possible by translating the application into several languages. Finally, we will display a summary of Twitter activity matching users' tastes.</p><p>Sounds good? Let's get started, we have some work to do.</p><div class="section" title="The profile page – a form"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>The profile page – a form</h1></div></div></div><p>Forms are the<a id="id164" class="indexterm"/> cornerstones of every web application. They have been the main way to get user input since the very beginning of the Internet!</p><p>Our first task here is to create a profile page like this one:</p><div class="mediaobject"><img src="graphics/2117_03_01.jpg" alt="The profile page – a form"/></div><p>It will let the user<a id="id165" class="indexterm"/> enter some personal information as well as a list of tastes. These tastes will then be fed to our search engine.</p><p>Let's create a new page in <code class="literal">templates/profile/profilePage.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      layout:decorator="layout/default"&gt;
&lt;head lang="en"&gt;
    &lt;title&gt;Your profile&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="row" layout:fragment="content"&gt;

    &lt;h2 class="indigo-text center"&gt;Personal info&lt;/h2&gt;

    &lt;form th:action="@{/profile}" method="post" class="col m8 s12 offset-m2"&gt;

        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input id="twitterHandle" type="text"/&gt;
                &lt;label for="twitterHandle"&gt;Last Name&lt;/label&gt;
            &lt;/div&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input id="email" type="text"/&gt;
                &lt;label for="email"&gt;Email&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input id="birthDate" type="text"/&gt;
                &lt;label for="birthDate"&gt;Birth Date&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row s12"&gt;
            &lt;button class="btn waves-effect waves-light" type="submit" name="save"&gt;Submit
                &lt;i class="mdi-content-send right"&gt;&lt;/i&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Note the <code class="literal">@{}</code> syntax that will construct the full path to a resource by prepending the server context <a id="id166" class="indexterm"/>path (in our case, <code class="literal">localhost:8080</code>) to its argument.</p><p>We will also create the associated controller named <code class="literal">ProfileController</code> in the <code class="literal">profile</code> package:</p><div class="informalexample"><pre class="programlisting">package masterspringmvc4.profile;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ProfileController {

    @RequestMapping("/profile")
    public String displayProfile() {
        return "profile/profilePage";
    }
}</pre></div><p>Now, you can go to <code class="literal">http://localhost:8080</code> and behold a beautiful form that does nothing. That's because we didn't map any action to the post URL.</p><p>Let's create a <span class="strong"><strong>Data Transfer Object</strong></span> (<span class="strong"><strong>DTO</strong></span>) in the same package as our controller. We will name <a id="id167" class="indexterm"/>it <code class="literal">ProfileForm</code>. Its role will be to map the fields of our web form and describe validation rules:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.profile;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

public class ProfileForm {
    private String twitterHandle;
    private String email;
    private LocalDate birthDate;
    private List&lt;String&gt; tastes = new ArrayList&lt;&gt;();

    // getters and setters
}</pre></div><p>This is a regular <span class="strong"><strong>Plain Old Java Object</strong></span> (<span class="strong"><strong>POJO</strong></span>). Don't forget to generate the getters and setters, without <a id="id168" class="indexterm"/>which our data binding will not work properly. Note that we have a list of tastes that we will not populate right now but a bit later.</p><p>Since we are <a id="id169" class="indexterm"/>using Java 8, the birth date of our user will be using the new Java date-time API (JSR 310). This API is much better than the old <code class="literal">java.util.Date</code> API because it makes strong distinctions between all the nuances of human dates and uses a fluent API and immutable data structures.</p><p>In our example, a <code class="literal">LocalDate</code> class is a simple day without time associated to it. It can be differentiated from the <code class="literal">LocalTime</code> class, which represents a time within a day, the <code class="literal">LocalDateTime</code> class, which represents both, or the <code class="literal">ZonedDateTime</code> class, which uses a time zone.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>If you wish to <a id="id170" class="indexterm"/>learn more about the Java 8 date time API, refer to the Oracle tutorial available at <a class="ulink" href="https://docs.oracle.com/javase/tutorial/datetime/TOC.html">https://docs.oracle.com/javase/tutorial/datetime/TOC.html</a>.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>Good advice is to always generate the <code class="literal">toString</code> method of our data objects like this form. It is extremely useful for debugging.</p></div></div><p>To instruct Spring to bind our field to this DTO, we will have to add some metadata in the <code class="literal">profilePage</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      layout:decorator="layout/default"&gt;
&lt;head lang="en"&gt;
    &lt;title&gt;Your profile&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="row" layout:fragment="content"&gt;

    &lt;h2 class="indigo-text center"&gt;Personal info&lt;/h2&gt;

    &lt;form th:action="@{/profile}" <span class="strong"><strong>th:object="${profileForm}" </strong></span>method="post" class="col m8 s12 offset-m2"&gt;

        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input <span class="strong"><strong>th:field="${profileForm.twitterHandle}" </strong></span>id="twitterHandle" type="text"/&gt;
                &lt;label for="twitterHandle"&gt;Last Name&lt;/label&gt;
            &lt;/div&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input <span class="strong"><strong>th:field="${profileForm.email}"</strong></span> id="email" type="text"/&gt;
                &lt;label for="email"&gt;Email&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input <span class="strong"><strong>th:field="${profileForm.birthDate}"</strong></span> id="birthDate" type="text"/&gt;
                &lt;label for="birthDate"&gt;Birth Date&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row s12"&gt;
            &lt;button class="btn waves-effect waves-light" type="submit" name="save"&gt;Submit
                &lt;i class="mdi-content-send right"&gt;&lt;/i&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>You will <a id="id171" class="indexterm"/>notice two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">th:object</code> attribute in the form</li><li class="listitem" style="list-style-type: disc">The <code class="literal">th:field</code> attributes in all the fields</li></ul></div><p>The first one will bind an object by its type to the controller. The second ones will bind the actual fields<a id="id172" class="indexterm"/> to our form bean attributes.</p><p>For the <code class="literal">th:object</code> field to work, we need to add an argument of the type <code class="literal">ProfileForm</code> to our request mapping methods:</p><div class="informalexample"><pre class="programlisting">@Controller
public class ProfileController {

    @RequestMapping("/profile")
    public String displayProfile(ProfileForm profileForm) {
        return "profile/profilePage";
    }

    @RequestMapping(value = "/profile", method = RequestMethod.POST)
    public String saveProfile(ProfileForm profileForm) {
        System.out.println("save ok" + profileForm);
        return "redirect:/profile";
    }
}</pre></div><p>We also added a mapping for the <code class="literal">POST</code> method that will be called when the form is submitted. At this point, if you try to submit the form with a date (for instance 10/10/1980), it won't work at all and give you an error 400 and no useful logging information.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>
<span class="strong"><strong>Logging in Spring Boot</strong></span>
</p><p>With<a id="id173" class="indexterm"/> Spring Boot, logging configuration is extremely simple. Just add <code class="literal">logging.level.{package} = DEBUG</code> to the <code class="literal">application.properties</code> file, where <code class="literal">{package}</code> is the fully qualified name of one of the classes or a package in your application. You can, of course, replace<a id="id174" class="indexterm"/> debug by any logging level you want. You can also add a classic logging configuration. Refer to <a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html">http://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html</a> for more information.</p></div></div><p>We will need to debug our application a little bit to understand what happened. Add this line to your file <code class="literal">application.properties</code>:</p><div class="informalexample"><pre class="programlisting">logging.level.org.springframework.web=DEBUG</pre></div><p>The <code class="literal">org.springframework.web</code> package is the base package of Spring MVC. This will allow us to see debug information generated by Spring web. If you submit the form again, you will see the following error in the log:</p><div class="informalexample"><pre class="programlisting">Field error in object 'profileForm' on field 'birthDate': rejected value [10/10/1980]; codes [typeMismatch.profileForm.birthDate,typeMismatch.birthDate,typeMismatch.java.time.LocalDate,typeMismatch]; … nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type java.lang.String to type java.time.LocalDate for value '10/10/1980'; nested exception is java.time.format.DateTimeParseException: Text '10/10/1980' could not be parsed, unparsed text found at index 8]</pre></div><p>To understand what's going on, we need to have a look at the <code class="literal">DateTimeFormatterRegistrar</code> class of Spring.</p><p>In this class, you will see half a dozen parsers and printers for the JSR 310. They will all fall back on the short style date format, which is either <code class="literal">MM/dd/yy</code> if you live in the US or <code class="literal">dd/MM/yy</code> otherwise.</p><p>This will instruct Spring Boot to create a <code class="literal">DateFormatter</code> class when our application starts.</p><p>We need to do the<a id="id175" class="indexterm"/> same thing in our case and create our own formatter since writing a year with two digits is a bit akward.</p><p>A <code class="literal">Formatter</code> in Spring is a class that can both <code class="literal">print</code> and <code class="literal">parse</code> an object. It will be used to decode and print a value from and to a String.</p><p>We will create a very simple formatter in the <code class="literal">date</code> package called <code class="literal">USLocalDateFormatter</code>:</p><div class="informalexample"><pre class="programlisting">public class USLocalDateFormatter implements Formatter&lt;LocalDate&gt; {
    public static final String US_PATTERN = "MM/dd/yyyy";
    public static final String NORMAL_PATTERN = "dd/MM/yyyy";

    @Override public LocalDate parse(String text, Locale locale) throws ParseException {
        return LocalDate.parse(text, DateTimeFormatter.ofPattern(getPattern(locale)));
    }

    @Override public String print(LocalDate object, Locale locale) {
        return DateTimeFormatter.ofPattern(getPattern(locale)).format(object);
    }

    public static String getPattern(Locale locale) {
        return isUnitedStates(locale) ? US_PATTERN : NORMAL_PATTERN;
    }

    private static boolean isUnitedStates(Locale locale) {
        return Locale.US.getCountry().equals(locale.getCountry());
    }
}</pre></div><p>This little class <a id="id176" class="indexterm"/>will allow us to parse the date in a more common format (with years in four digits) according to the user's locale.</p><p>Let's create a new class in the <code class="literal">config</code> package called <code class="literal">WebConfiguration</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import masterSpringMvc.dates.USLocalDateFormatter;
import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import java.time.LocalDate;

@Configuration
public class WebConfiguration extends WebMvcConfigurerAdapter {

    @Override public void addFormatters(FormatterRegistry registry) {
        registry.addFormatterForFieldType(LocalDate.class, new USLocalDateFormatter());
    }
}</pre></div><p>This class extends the <code class="literal">WebMvcConfigurerAdapter</code>, which is a very handy class to customize the Spring MVC configuration. It provides a lot of common extension points that you can access by overriding methods such as the <code class="literal">addFormatters()</code> method.</p><p>This time, submitting our form won't result in any error except if you don't type the date with the correct date format.</p><p>For the moment, it is impossible for the users to see the format in which they are supposed to enter their birth date, so let's add this information to the form.</p><p>In the <code class="literal">ProfileController</code>, let's add a <code class="literal">dateFormat</code> attribute:</p><div class="informalexample"><pre class="programlisting">@ModelAttribute("dateFormat")
public String localeFormat(Locale locale) {
    return USLocalDateFormatter.getPattern(locale);
}</pre></div><p>The <code class="literal">@ModelAttribute</code> annotation will allow us to expose a property to the web page, exactly like the <code class="literal">model.addAttribute()</code> method that we saw in the previous chapter.</p><p>Now, we can <a id="id177" class="indexterm"/>use this information in our page by adding a placeholder to our date field:</p><div class="informalexample"><pre class="programlisting">&lt;div class="row"&gt;
    &lt;div class="input-field col s6"&gt;
        &lt;input th:field="${profileForm.birthDate}" id="birthDate" type="text" <span class="strong"><strong>th:placeholder="${dateFormat}"</strong></span>/&gt;
        &lt;label for="birthDate"&gt;Birth Date&lt;/label&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre></div><p>This information will now be displayed to the user:</p><div class="mediaobject"><img src="graphics/2117_03_02.jpg" alt="The profile page – a form"/></div></div></div>
<div class="section" title="Validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Validation</h1></div></div></div><p>We wouldn't want <a id="id178" class="indexterm"/>our user to enter invalid or empty information<a id="id179" class="indexterm"/> and that's why we will need to add some validation logic to our <code class="literal">ProfileForm</code>.</p><div class="informalexample"><pre class="programlisting">package masterspringmvc4.profile;

import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.NotEmpty;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Past;
import javax.validation.constraints.Size;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class ProfileForm {
    @Size(min = 2)
    private String twitterHandle;

    @Email
    @NotEmpty
    private String email;

   @NotNull
    private Date birthDate;

    @NotEmpty
    private List&lt;String&gt; tastes = new ArrayList&lt;&gt;();
}</pre></div><p>As you can <a id="id180" class="indexterm"/>see, we added a few validation constraints. These <a id="id181" class="indexterm"/>annotations come from the JSR-303 specification, which specifies bean validation. The most popular implementation of this specification is <code class="literal">hibernate-validator</code>, which is included in Spring Boot.</p><p>You can see that we use annotations coming from the <code class="literal">javax.validation.constraints</code> package (defined in the API) and some coming from the <code class="literal">org.hibernate.validator.constraints</code> package (additional constraints). Both work, I encourage you to take a look at what is available in those packages in the jars <code class="literal">validation-api</code> and <code class="literal">hibernate-validator</code>.</p><p>You can also<a id="id182" class="indexterm"/> take a look at the constraints available in the hibernate validator in the documentation at <a class="ulink" href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints">http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints</a>.</p><p>We will need to add a few more things for validation to work. First, the controller needs to say that it wants a valid model on form submission. Adding the <code class="literal">javax.validation.Valid</code> annotation to the parameter representing the form does just that:</p><div class="informalexample"><pre class="programlisting">@RequestMapping(value = "/profile", method = RequestMethod.POST)
public String saveProfile(@Valid ProfileForm profileForm, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        return "profile/profilePage";
    }

    System.out.println("save ok" + profileForm);
    return "redirect:/profile";
}</pre></div><p>Note that we do not redirect the user if the form contains any errors. This will allow us to display them on the same web page.</p><p>Speaking of <a id="id183" class="indexterm"/>which, we need to add a place on the web page where<a id="id184" class="indexterm"/> those errors will be displayed.</p><p>Add these lines just at the beginning of the form tag in <code class="literal">profilePage.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;ul th:if="${#fields.hasErrors('*')}" class="errorlist"&gt;
    &lt;li th:each="err : ${#fields.errors('*')}" th:text="${err}"&gt;Input is incorrect&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>This will iterate through every error found in the form and display them in a list. If you try to submit an empty form, you will see a bunch of errors:</p><div class="mediaobject"><img src="graphics/2117_03_03.jpg" alt="Validation"/></div><p>Note that the <code class="literal">@NotEmpty</code> check on the tastes will prevent the form from being submitted. Indeed, we do not yet have a way to provide them.</p><div class="section" title="Customize validation messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Customize validation messages</h2></div></div></div><p>These<a id="id185" class="indexterm"/> error messages are not very useful for our user yet. The first thing we need to do is to associate them properly to their respective fields. Let's modify <code class="literal">profilePage.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      layout:decorator="layout/default"&gt;
&lt;head lang="en"&gt;
    &lt;title&gt;Your Profile&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="row" layout:fragment="content"&gt;

    &lt;h2 class="indigo-text center"&gt;Personal info&lt;/h2&gt;

    &lt;form th:action="@{/profile}" th:object="${profileForm}" method="post" class="col m8 s12 offset-m2"&gt;

        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input th:field="${profileForm.twitterHandle}" id="twitterHandle" type="text" <span class="strong"><strong>th:errorclass="invalid</strong></span>"/&gt;
                &lt;label for="twitterHandle"&gt;Twitter handle&lt;/label&gt;

                <span class="strong"><strong>&lt;div th:errors="*{twitterHandle}" class="red-text"&gt;Error&lt;/div&gt;</strong></span>
            &lt;/div&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input th:field="${profileForm.email}" id="email" type="text" <span class="strong"><strong>th:errorclass="invalid</strong></span>"/&gt;
                &lt;label for="email"&gt;Email&lt;/label&gt;

                <span class="strong"><strong>&lt;div th:errors="*{email}" class="red-text"&gt;Error&lt;/div&gt;</strong></span>
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input th:field="${profileForm.birthDate}" id="birthDate" type="text" <span class="strong"><strong>th:errorclass="invalid</strong></span>" th:placeholder="${dateFormat}"/&gt;
                &lt;label for="birthDate"&gt;Birth Date&lt;/label&gt;

                &lt;div th:errors="*{birthDate}" class="red-text"&gt;Error&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row s12"&gt;
            &lt;button class="btn indigo waves-effect waves-light" type="submit" name="save"&gt;Submit
                &lt;i class="mdi-content-send right"&gt;&lt;/i&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>You will notice that we added a <code class="literal">th:errors</code> tag below each field in the form. We also added a <code class="literal">th:errorclass</code> tag to each field. If the field contains an error, the associated css class will be added to the DOM.</p><p>The<a id="id186" class="indexterm"/> validation looks much better already:</p><div class="mediaobject"><img src="graphics/2117_03_04.jpg" alt="Customize validation messages"/></div><p>The next thing we need to do is to customize the error messages to reflect the business rules of our application in a better way.</p><p>Remember that Spring Boot takes care of creating a message source bean for us? The default location for this message source is in <code class="literal">src/main/resources/messages.properties</code>.</p><p>Let's create such a bundle, and add the following text:</p><div class="informalexample"><pre class="programlisting">Size.profileForm.twitterHandle=Please type in your twitter user name
Email.profileForm.email=Please specify a valid email address
NotEmpty.profileForm.email=Please specify your email address
PastLocalDate.profileForm.birthDate=Please specify a real birth date
NotNull.profileForm.birthDate=Please specify your birth date

typeMismatch.birthDate = Invalid birth date format.</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>It can be very handy in development to configure the message source to always reload our bundles. Add the following property to <code class="literal">application.properties</code>:</p><p>
<code class="literal">spring.messages.cache-seconds=0</code>
</p><p>0 means always reload, whereas -1 means never reload.</p></div></div><p>The class<a id="id187" class="indexterm"/> responsible for resolving the error messages in Spring is <code class="literal">DefaultMessageCodesResolver</code>. In the case of field validation, this class tries to resolve the following messages in the given order:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">code + "." + object name + "." + field</li><li class="listitem" style="list-style-type: disc">code + "." + field</li><li class="listitem" style="list-style-type: disc">code + "." + field type</li><li class="listitem" style="list-style-type: disc">code</li></ul></div><p>In the preceding rules, the code part can be two things: an annotation type such as <code class="literal">Size</code> or <code class="literal">Email</code>, or an exception code such as <code class="literal">typeMismatch</code>. Remember when we got an exception caused by an incorrect date format? The associated error code was indeed <code class="literal">typeMismatch</code>.</p><p>With the preceding messages, we chose to be very specific. A good practice is to define default messages as follows:</p><div class="informalexample"><pre class="programlisting">Size=the {0} field must be between {2} and {1} characters long
typeMismatch.java.util.Date = Invalid date format.</pre></div><p>Note the placeholders; each validation error has a number of arguments associated with it.</p><p>The last way to declare error messages would involve defining the error message directly in the validation annotations as follows:</p><div class="informalexample"><pre class="programlisting">@Size(min = 2, message = "Please specify a valid twitter handle")
private String twitterHandle;</pre></div><p>However, the downside of this method is that it is not compatible with internationalization.</p></div><div class="section" title="Custom annotation for validation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Custom annotation for validation</h2></div></div></div><p>For Java dates, there <a id="id188" class="indexterm"/>is an annotation called <code class="literal">@Past</code>, which ensures that a date is from the past.</p><p>We don't want our user to pretend they are coming from the future, so we need to validate the birth date. To do<a id="id189" class="indexterm"/> this, we will define our own annotation in the <code class="literal">date</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.date;

import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.Payload;
import java.lang.annotation.*;
import java.time.LocalDate;

@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PastLocalDate.PastValidator.class)
@Documented
public @interface PastLocalDate {
    String message() default "{javax.validation.constraints.Past.message}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    class PastValidator implements ConstraintValidator&lt;PastLocalDate, LocalDate&gt; {
        public void initialize(PastLocalDate past) {
        }

        public boolean isValid(LocalDate localDate, ConstraintValidatorContext context) {
            return localDate == null || localDate.isBefore(LocalDate.now());
        }
    }
}</pre></div><p>Simple isn't it? This code will verify that our date is really from the past.</p><p>We can now add it to the <code class="literal">birthDate</code> field in the profile form:</p><div class="informalexample"><pre class="programlisting">@NotNull
@PastLocalDate
private LocalDate birthDate;</pre></div></div></div>
<div class="section" title="Internationalization"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Internationalization</h1></div></div></div><p>Internationalization, frequently abbreviated i18n, is the process of designing an application<a id="id190" class="indexterm"/> that can be translated into various languages.</p><p>This generally involves placing translations in properties bundles with their names suffixed with the target locale, for instance, the <code class="literal">messages_en.properties</code>, <code class="literal">messages_en_US.properties</code>, and <code class="literal">messages_fr.properties</code> files.</p><p>The correct property bundle is resolved by trying the most specific locale first and then falling back to the less specific ones.</p><p>For U.S English, if you try to get a translation from a bundle named <code class="literal">x</code>, the application would first look in the <code class="literal">x_en_US.properties</code> file, then the <code class="literal">x_en.properties</code> file, and finally, the <code class="literal">x.properties</code> file.</p><p>The first thing we will do is translate our error messages into French. To do this, we will rename our existing <code class="literal">messages.properties</code> file to <code class="literal">messages_en.properties</code>.</p><p>We will also create a second bundle named <code class="literal">messages_fr.properties</code>:</p><div class="informalexample"><pre class="programlisting">Size.profileForm.twitterHandle=Veuillez entrer votre identifiant Twitter
Email.profileForm.email=Veuillez spécifier une adresse mail valide
NotEmpty.profileForm.email=Veuillez spécifier votre adresse mail
PastLocalDate.profileForm.birthDate=Veuillez donner votre vraie date de naissance
NotNull.profileForm.birthDate=Veuillez spécifier votre date de naissance

typeMismatch.birthDate = Date de naissance invalide.</pre></div><p>We saw in <a class="link" href="ch01.html" title="Chapter 1. Setting Up a Spring Web Application in No Time">Chapter 1</a>, <span class="emphasis"><em>Setting Up a Spring Web Application in No Time</em></span> that by default, Spring Boot uses a fixed <code class="literal">LocaleResolver</code> interface. The <code class="literal">LocaleResolver</code> is a simple interface with two methods:</p><div class="informalexample"><pre class="programlisting">public interface LocaleResolver {

    Locale resolveLocale(HttpServletRequest request);

    void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale);
}</pre></div><p>Spring provides a bunch of implementations of this interface, such as <code class="literal">FixedLocaleResolver</code>. This local resolver is very simple; we can configure the application locale via a property and cannot change it once it is defined. To configure the locale of our application, let's add the following property to our <code class="literal">application.properties</code> file:</p><div class="informalexample"><pre class="programlisting">spring.mvc.locale=fr</pre></div><p>This will add our validation messages in French.</p><p>If we take a<a id="id191" class="indexterm"/> look at the different <code class="literal">LocaleResolver</code> interfaces that are bundled in Spring MVC, we will see the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FixedLocaleResolver</code>: This fixes the locale defined in configuration. It cannot be changed once fixed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CookieLocaleResolver</code>: This allows the locale to be retrieved and saved in a cookie.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AcceptHeaderLocaleResolver</code>: This uses the HTTP header sent by the user's browser to find the locale.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SessionLocaleResolver</code>: This finds and stores the locale in an HTTP session.</li></ul></div><p>These implementations cover a number of use cases, but in a more complex application one might implement <code class="literal">LocaleResolver</code> directly to allow more complex logic such as fetching the locale from the database and falling back to browser locale, for instance.</p><div class="section" title="Changing the locale"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Changing the locale</h2></div></div></div><p>In our application, the locale is linked to the user. We will save their profile in session.</p><p>We will allow the user to change the language of the site using a small menu. That's why we will use the <code class="literal">SessionLocaleResolver</code>. Let's edit <code class="literal">WebConfiguration</code> once more:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import masterSpringMvc.date.USLocalDateFormatter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
import org.springframework.web.servlet.i18n.SessionLocaleResolver;

import java.time.LocalDate;

@Configuration
public class WebConfiguration extends WebMvcConfigurerAdapter {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addFormatterForFieldType(LocalDate.class, new USLocalDateFormatter());
    }

    @Bean
    public LocaleResolver localeResolver() {
        return new SessionLocaleResolver();
    }

    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor();
        localeChangeInterceptor.setParamName("lang");
        return localeChangeInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }
}</pre></div><p>We declared a <code class="literal">LocaleChangeInterceptor</code> bean as a Spring MVC interceptor. It will intercept any<a id="id192" class="indexterm"/> request made to <code class="literal">Controller</code> and check for the <code class="literal">lang</code> query parameter. For instance, navigating to <code class="literal">http://localhost:8080/profile?lang=fr</code> would cause the locale to change.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>
<span class="strong"><strong>Spring MVC Interceptors</strong></span> can be compared to Servlet filters in a web application. Interceptors allow custom preprocessing, skipping the execution of a handler, and <a id="id193" class="indexterm"/>custom post-processing. Filters are more powerful, for example, they allow for exchanging the request and response objects that are handed down the chain. Filters are configured in a <code class="literal">web.xml</code> file, while interceptors are declared as beans in the application context.</p></div></div><p>Now, we can change the locale by entering the correct URL ourselves, but it would be better to add a navigation bar allowing the user to change the language. We will modify the default layout (<code class="literal">templates/layout/default.html</code>) to add a drop-down menu:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      &gt;
&lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"/&gt;
    &lt;title&gt;Default title&lt;/title&gt;

    &lt;link href="/webjars/materializecss/0.96.0/css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;ul id="lang-dropdown" class="dropdown-content"&gt;
    &lt;li&gt;&lt;a href="?lang=en_US"&gt;English&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="?lang=fr"&gt;French&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;nav&gt;
    &lt;div class="nav-wrapper indigo"&gt;
        &lt;ul class="right"&gt;
            &lt;li&gt;&lt;a class="dropdown-button" href="#!" data-activates="lang-dropdown"&gt;&lt;i class="mdi-action-language right"&gt;&lt;/i&gt; Lang&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/nav&gt;

&lt;section layout:fragment="content"&gt;
    &lt;p&gt;Page content goes here&lt;/p&gt;
&lt;/section&gt;

&lt;script src="/webjars/jquery/2.1.4/jquery.js"&gt;&lt;/script&gt;
&lt;script src="/webjars/materializecss/0.96.0/js/materialize.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    $(".dropdown-button").dropdown();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>This will allow<a id="id194" class="indexterm"/> the user to choose between the two supported languages.</p><div class="mediaobject"><img src="graphics/2117_03_05.jpg" alt="Changing the locale"/></div></div><div class="section" title="Translating the application text"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Translating the application text</h2></div></div></div><p>The last thing<a id="id195" class="indexterm"/> we need to do in order to have a fully bilingual application is to translate the titles and labels of our application. To do this, we will edit our web pages and use the <code class="literal">th:text</code> attribute, for instance, in <code class="literal">profilePage.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      layout:decorator="layout/default"&gt;
&lt;head lang="en"&gt;
    &lt;title&gt;Your profile&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="row" layout:fragment="content"&gt;

    &lt;h2 class="indigo-text center" <span class="strong"><strong>th:text="#{profile.title}"</strong></span>&gt;Personal info&lt;/h2&gt;

    &lt;form th:action="@{/profile}" th:object="${profileForm}" method="post" class="col m8 s12 offset-m2"&gt;

        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input th:field="${profileForm.twitterHandle}" id="twitterHandle" type="text" th:errorclass="invalid"/&gt;
                &lt;label for="twitterHandle" <span class="strong"><strong>th:text="#{twitter.handle}"</strong></span>&gt;Twitter handle&lt;/label&gt;

                &lt;div th:errors="*{twitterHandle}" class="red-text"&gt;Error&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input th:field="${profileForm.email}" id="email" type="text" th:errorclass="invalid"/&gt;
                &lt;label for="email" <span class="strong"><strong>th:text="#{email}"</strong></span>&gt;Email&lt;/label&gt;

                &lt;div th:errors="*{email}" class="red-text"&gt;Error&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div class="input-field col s6"&gt;
                &lt;input th:field="${profileForm.birthDate}" id="birthDate" type="text" th:errorclass="invalid"/&gt;
                &lt;label for="birthDate" <span class="strong"><strong>th:text="#{birthdate}" th:placeholder="${dateFormat}"</strong></span>&gt;Birth Date&lt;/label&gt;

                &lt;div th:errors="*{birthDate}" class="red-text"&gt;Error&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row s12 center"&gt;
            &lt;button class="btn indigo waves-effect waves-light" type="submit" name="save" th:text="#{submit}"&gt;Submit
                &lt;i class="mdi-content-send right"&gt;&lt;/i&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The <code class="literal">th:text</code> attribute <a id="id196" class="indexterm"/>will replace the contents of a HTML element with an expression. Here, we use the <code class="literal">#{}</code> syntax, which indicates we want to display a message coming from a property source like <code class="literal">messages.properties</code>.</p><p>Let's add the corresponding translations to our English bundle:</p><div class="informalexample"><pre class="programlisting">NotEmpty.profileForm.tastes=Please enter at least one thing
profile.title=Your profile
twitter.handle=Twitter handle
email=Email
birthdate=Birth Date
tastes.legend=What do you like?
remove=Remove
taste.placeholder=Enter a keyword
add.taste=Add taste
submit=Submit</pre></div><p>Now to the French ones:</p><div class="informalexample"><pre class="programlisting">NotEmpty.profileForm.tastes=Veuillez saisir au moins une chose
profile.title=Votre profil
twitter.handle=Pseudo twitter
email=Email
birthdate=Date de naissance
tastes.legend=Quels sont vos goûts ?
remove=Supprimer
taste.placeholder=Entrez un mot-clé
add.taste=Ajouter un centre d'intérêt
submit=Envoyer</pre></div><p>Some<a id="id197" class="indexterm"/> of the translations are not used yet, but will be used in just a moment. Et voilà! The French market is ready for the Twitter search flood.</p></div><div class="section" title="A list in a form"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>A list in a form</h2></div></div></div><p>We now want the user to enter a list of "tastes", which are, in fact, a list of keywords we will use<a id="id198" class="indexterm"/> to search tweets.</p><p>A button will be displayed, allowing our user to enter a new keyword and add it to a list. Each item of this list will be an editable input text and will be removable thanks to a remove button:</p><div class="mediaobject"><img src="graphics/2117_03_06.jpg" alt="A list in a form"/></div><p>Handling list data in a form can be a chore with some frameworks. However, with Spring MVC and Thymeleaf it is relatively straightforward, when you understand the principle.</p><p>Add the<a id="id199" class="indexterm"/> following lines in the <code class="literal">profilePage.html</code> file right below the row containing the birth date, and just over the submit button:</p><div class="informalexample"><pre class="programlisting">&lt;fieldset class="row"&gt;
    &lt;legend th:text="#{tastes.legend}"&gt;What do you like?&lt;/legend&gt;
    &lt;button class="btn teal" type="submit" name="addTaste" th:text="#{add.taste}"&gt;Add taste
        &lt;i class="mdi-content-add left"&gt;&lt;/i&gt;
    &lt;/button&gt;

    &lt;div th:errors="*{tastes}" class="red-text"&gt;Error&lt;/div&gt;

    &lt;div class="row" th:each="row,rowStat : *{tastes}"&gt;
        &lt;div class="col s6"&gt;
            &lt;input type="text" th:field="*{tastes[__${rowStat.index}__]}" th:placeholder="#{taste.placeholder}"/&gt;
        &lt;/div&gt;

        &lt;div class="col s6"&gt;
            &lt;button class="btn red" type="submit" name="removeTaste" th:value="${rowStat.index}" th:text="#{remove}"&gt;Remove
                &lt;i class="mdi-action-delete right waves-effect"&gt;&lt;/i&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/fieldset&gt;</pre></div><p>The purpose of this snippet is to iterate over the <code class="literal">tastes</code> variable of our <code class="literal">LoginForm</code>. This can be achieved with the <code class="literal">th:each</code> attribute, which looks a lot like a <code class="literal">for…in</code> loop in java.</p><p>Compared to the search result loop we saw earlier, the iteration is stored in two variables instead of one. The first one will actually contain each row of the data. The <code class="literal">rowStat</code> variable will contain additional information on the current state of the iteration.</p><p>The strangest thing in the new piece of code is:</p><div class="informalexample"><pre class="programlisting">th:field="*{tastes[__${rowStat.index}__]}"</pre></div><p>This is quite a complicated syntax. You could come up with something simpler on your own, such as:</p><div class="informalexample"><pre class="programlisting">th:field="*{tastes[rowStat.index]}"</pre></div><p>Well, that wouldn't work. The <code class="literal">${rowStat.index}</code> variable, which represents the current index of the iteration loop, needs to be evaluated before the rest of the expression. To achieve this, we need to use preprocessing.</p><p>The <a id="id200" class="indexterm"/>expression surrounded by double underscores will be preprocessed, which means that it will be processed before the normal processing phase, allowing it to be evaluated twice.</p><p>There are two new submit buttons on our form now. They all have a name. The global submit button we had earlier is called <code class="literal">save</code>. The two new buttons are called <code class="literal">addTaste</code> and <code class="literal">removeTaste</code>.</p><p>On the controller side, this will allow us to easily discriminate the different actions coming from our form. Let's add two new actions to our <code class="literal">ProfileController</code>:</p><div class="informalexample"><pre class="programlisting">@Controller
public class ProfileController {

    @ModelAttribute("dateFormat")
    public String localeFormat(Locale locale) {
        return USLocalDateFormatter.getPattern(locale);
    }

    @RequestMapping("/profile")
    public String displayProfile(ProfileForm profileForm) {
        return "profile/profilePage";
    }

    @RequestMapping(value = "/profile", params = {"save"}, method = RequestMethod.POST)
    public String saveProfile(@Valid ProfileForm profileForm, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            return "profile/profilePage";
        }
        System.out.println("save ok" + profileForm);
        return "redirect:/profile";
    }

    @RequestMapping(value = "/profile", params = {"addTaste"})
    public String addRow(ProfileForm profileForm) {
        profileForm.getTastes().add(null);
        return "profile/profilePage";
    }

    @RequestMapping(value = "/profile", params = {"removeTaste"})
    public String removeRow(ProfileForm profileForm, HttpServletRequest req) {
        Integer rowId = Integer.valueOf(req.getParameter("removeTaste"));
        profileForm.getTastes().remove(rowId.intValue());
        return "profile/profilePage";
    }
}</pre></div><p>We added a <code class="literal">param</code> parameter to each of our post actions to differentiate them. The one we had previously is now bound to the <code class="literal">save</code> parameter.</p><p>When <a id="id201" class="indexterm"/>we click on a button, its name will automatically be added to the form data sent by the browser. Note that we specified a particular value with the remove button: <code class="literal">th:value="${rowStat.index}"</code>. This attribute will indicate which value the associated parameter should specifically take. A blank value will be sent if this attribute is not present. This means that when we click on the remove button, a <code class="literal">removeTaste</code> parameter will be added to the <code class="literal">POST</code> request, containing the index of the row we would like to remove. We can then get it back into the <code class="literal">Controller</code> with the following code:</p><div class="informalexample"><pre class="programlisting">Integer rowId = Integer.valueOf(req.getParameter("removeTaste"));</pre></div><p>The only downside with this method is that the whole form data will be sent every time we click on the button, even if it is not strictly required. Our form is small enough, so a tradeoff is acceptable.</p><p>That's it! The form is now complete, with the possibility of adding one or more tastes.</p></div></div>
<div class="section" title="Client validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Client validation</h1></div></div></div><p>As a little bonus, client-side validation has become very easy nowadays with the HTML5 form validation <a id="id202" class="indexterm"/>specification. If your target browsers <a id="id203" class="indexterm"/>are Internet Explorer 10 and above, adding client-side validation is as easy as specifying the correct input type instead of just using text.</p><p>By adding the client-side validation, we can prevalidate the form and avoid overloading the server with requests that we know are incorrect. More information on the client-side validation <a id="id204" class="indexterm"/>specification is available at <a class="ulink" href="http://caniuse.com/#search=validation">http://caniuse.com/#search=validation</a>.</p><p>We can modify our inputs to enable simple client-side validation. The previous inputs, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;input th:field="${profileForm.twitterHandle}" id="twitterHandle" type="text" th:errorclass="invalid"/&gt;
&lt;input th:field="${profileForm.email}" id="email" type="text" th:errorclass="invalid"/&gt;
&lt;input th:field="${profileForm.birthDate}" id="birthDate" type="text" th:errorclass="invalid"/&gt;
&lt;input type="text" th:field="*{tastes[__${rowStat.index}__]}" th:placeholder="#{taste.placeholder}"/&gt;</pre></div><p>This becomes:</p><div class="informalexample"><pre class="programlisting">&lt;input th:field="${profileForm.twitterHandle}" id="twitterHandle" type="text" <span class="strong"><strong>required="required"</strong></span> th:errorclass="invalid"/&gt;
&lt;input th:field="${profileForm.email}" id="email" <span class="strong"><strong>type="email" required="required"</strong></span> th:errorclass="invalid"/&gt;
&lt;input th:field="${profileForm.birthDate}" id="birthDate" type="text" <span class="strong"><strong>required="required"</strong></span> th:errorclass="invalid"/&gt;
&lt;input type="text" <span class="strong"><strong>required="required"</strong></span> th:field="*{tastes[__${rowStat.index}__]}" th:placeholder="#{taste.placeholder}"/&gt;</pre></div><p>With this<a id="id205" class="indexterm"/> method, your browser will detect when the<a id="id206" class="indexterm"/> form is submitted and validate each attribute according to its type. The <code class="literal">required</code> attribute forces the user to enter a nonblank value. The <code class="literal">email</code> type enforces basic e-mail validation rules on the corresponding field.</p><div class="mediaobject"><img src="graphics/2117_03_07.jpg" alt="Client validation"/></div><p>Other types <a id="id207" class="indexterm"/>of validators also exist. Take a look at <a class="ulink" href="http://www.the-art-of-web.com/html/html5-form-validation">http://www.the-art-of-web.com/html/html5-form-validation</a>.</p><p>The downside of this method is that our add taste and remove taste buttons will now trigger validation. To fix this, we need to include a script at the bottom of the default layout, right after the jQuery declaration.</p><p>However, it would be best to include it only on the profile page. To do this, we can add a new fragment section in the <code class="literal">layout/default.html</code> page, just before the end of the body tag:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" layout:fragment="script"&gt;
&lt;/script&gt;</pre></div><p>This will allow us to include an additional script on each page if needed.</p><p>Now, we can add the following script to our profile page, just before closing the body tag:</p><div class="informalexample"><pre class="programlisting">&lt;script layout:fragment="script"&gt;
    $('button').bind('click', function(e) {
        if (e.currentTarget.name === 'save') {
            $(e.currentTarget.form).removeAttr('novalidate');
        } else {
            $(e.currentTarget.form).attr('novalidate', 'novalidate');
        }
    });
&lt;/script&gt;</pre></div><p>Form <a id="id208" class="indexterm"/>validation won't be triggered when a <code class="literal">novalidate</code> attribute<a id="id209" class="indexterm"/> is present on the form. This little script will dynamically remove the <code class="literal">novalidate</code> attribute if the action of the form is named <code class="literal">save</code> if the name of the input is different, the <code class="literal">novalidate</code> attribute will always be added. Validation will thus be triggered only by the save button.</p></div>
<div class="section" title="The check point"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>The check point</h1></div></div></div><p>Before moving <a id="id210" class="indexterm"/>on to the next chapter, let's check whether everything is in the right place.</p><p>In the Java sources, you should have the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A new controller, the <code class="literal">ProfileController</code></li><li class="listitem" style="list-style-type: disc">Two new classes related to date: a date formatter and an annotation to validate <code class="literal">LocalDate</code>s</li><li class="listitem" style="list-style-type: disc">A new <code class="literal">WebConfiguration</code> folder to customize Spring MVC's configuration</li></ul></div><div class="mediaobject"><img src="graphics/2117_03_08.jpg" alt="The check point"/></div><p>In the resources, you <a id="id211" class="indexterm"/>should have a new template inside the profile directory and two new bundles:</p><div class="mediaobject"><img src="graphics/2117_03_09.jpg" alt="The check point"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, you learned how to make a complete form. We created a model using Java 8 dates, and you learned how to format information coming from the user and display it accordingly.</p><p>We ensured that the form was filled with valid information, with validator annotations, including our own. Also, we prevented obviously incorrect information from even hitting the server by including some client-side validation very easily.</p><p>Finally, we even translated the whole application into English and French, date formats included!</p><p>In the next chapter, we will build a space where the users will be able to upload their pictures and learn more about error handling in Spring MVC applications.</p></div></body></html>