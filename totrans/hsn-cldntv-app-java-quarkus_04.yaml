- en: Creating a Container Image of Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的应用程序的容器镜像
- en: In the previous chapter, we had a glimpse of the power of Quarkus applications
    by running a traditional JVM application and then turning it into a native build.
    There is much more to Quarkus than lean executables and low resource usage, though,
    so, in this chapter, we will keep learning how to create container images of our
    application that can then be deployed into a Kubernetes-native environment. For
    this purpose, our to-do list includes installing the Docker tool and the Community
    version of OpenShift, which is called **Origin Community Distribution of Kubernetes**,
    or simply **OKD**. Then, we will learn how to scale our application so that we
    can improve its response time even further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过运行传统的JVM应用程序并将其转换为原生构建，一瞥了Quarkus应用程序的力量。然而，Quarkus不仅仅有精简的可执行文件和低资源使用，因此，在本章中，我们将继续学习如何创建我们的应用程序的容器镜像，然后可以部署到Kubernetes原生环境中。为此，我们的待办事项列表包括安装Docker工具和OpenShift的社区版，这被称为**Origin
    Community Distribution of Kubernetes**，或简称**OKD**。然后，我们将学习如何扩展我们的应用程序，以便我们可以进一步提高其响应时间。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up Docker in your environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的环境中设置Docker
- en: Starting a Quarkus application in a container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中启动Quarkus应用程序
- en: Running a native executable in a container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行原生可执行文件
- en: Deploying your container image on OpenShift
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenShift上部署您的容器镜像
- en: Scaling our application to improve its throughput
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展我们的应用程序以提高其吞吐量
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter03).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章节的项目源代码，链接为[https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter03)。
- en: Setting up Docker
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker
- en: 'Docker is a tool that lets us simplify the creation and execution of containers
    in our environment. Each container, in turn, wraps up an application and its dependencies
    into a single standardized unit that includes everything it needs to run, that
    is, the system tools, code, and other required libraries. This guarantees that
    your application will always execute in the same way by sharing a simple container
    image. Docker is available in two versions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个工具，它让我们能够简化在我们环境中创建和执行容器。每个容器反过来又把一个应用程序及其依赖项封装成一个单一的标准化单元，该单元包括它运行所需的一切，即系统工具、代码和其他所需的库。这保证了您的应用程序将始终以相同的方式执行，通过共享一个简单的容器镜像。Docker有两种版本：
- en: '**Community Edition** (**CE**): The Docker CE, which we will be using in this
    book, is ideal for developers and small teams looking for a quick start with Docker
    and container-based applications.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区版**（**CE**）：我们将在这本书中使用Docker CE，它非常适合寻求快速开始使用Docker和基于容器的应用程序的开发人员和小型团队。'
- en: '**Enterprise Edition** (**EE**): The EE features additional capabilities such
    as a certified infrastructure, image management, and image security scanning.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业版**（**EE**）：EE具有额外的功能，例如认证的基础设施、镜像管理和镜像安全扫描。'
- en: Although we will be using the Community version of Docker, this isn't going
    to reduce your application's full potential as we will be able to leverage advanced
    container capabilities through a native Kubernetes platform, which is an ideal
    solution for running business-critical applications in production at scale.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将使用Docker的社区版，但这并不会降低您应用程序的完整潜力，因为我们将通过原生Kubernetes平台利用高级容器功能，这对于在生产环境中大规模运行业务关键应用程序是一个理想的解决方案。
- en: 'The installation of Docker is fully documented at [https://docs.docker.com/install/](https://docs.docker.com/install/).
    In a nutshell, you can follow several installation tactics, depending on your
    needs:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的安装过程在[https://docs.docker.com/install/](https://docs.docker.com/install/)上进行了全面文档化。简而言之，您可以根据自己的需求遵循几种安装策略：
- en: From a midterm perspective, you may want to ease the upgrade of Docker. Most
    users choose to set up Docker's repositories and install and upgrade from there
    ([https://docs.docker.com/install/linux/docker-ce/fedora/#install-using-the-repository](https://docs.docker.com/install/linux/docker-ce/fedora/#install-using-the-repository)).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从中期角度来看，你可能希望简化 Docker 的升级。大多数用户选择设置 Docker 的仓库，并从那里安装和升级（[https://docs.docker.com/install/linux/docker-ce/fedora/#install-using-the-repository](https://docs.docker.com/install/linux/docker-ce/fedora/#install-using-the-repository)）。
- en: Another option, which turns out to be pretty useful if you are installing Docker
    on a machine that is offline, requires manually installing the RPM package and
    manually handling upgrades as well ([https://docs.docker.com/install/linux/docker-ce/fedora/#install-from-a-package](https://docs.docker.com/install/linux/docker-ce/fedora/#install-from-a-package)).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选项，如果你在离线机器上安装 Docker，证明非常实用，需要手动安装 RPM 软件包，并手动处理升级（[https://docs.docker.com/install/linux/docker-ce/fedora/#install-from-a-package](https://docs.docker.com/install/linux/docker-ce/fedora/#install-from-a-package)）。
- en: Finally, for quick and easy installation, you can use the automated script,
    which will detect your operating system and install Docker accordingly. For the
    sake of simplicity, we will choose this option.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，为了快速方便地安装，你可以使用自动化脚本，该脚本将检测你的操作系统并相应地安装 Docker。为了简化，我们将选择此选项。
- en: 'Let''s proceed with installing Docker by following these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤继续安装 Docker：
- en: 'The automated script can be downloaded from [https://get.docker.com/](https://get.docker.com/),
    as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化脚本可以从 [https://get.docker.com/](https://get.docker.com/) 下载，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, execute it with the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令执行它：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important! Just like any other shell script, verify its content before executing
    it! Its content needs to match with the `install.sh` script located at [https://github.com/docker/docker-install](https://github.com/docker/docker-install).
    If the content doesn't match, verify whether the automated script is still being
    maintained by going to the Docker install page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要！就像任何其他 shell 脚本一样，在执行之前验证其内容！其内容需要与位于 [https://github.com/docker/docker-install](https://github.com/docker/docker-install)
    的 `install.sh` 脚本相匹配。如果不匹配，请通过访问 Docker 安装页面来验证自动化脚本是否仍在维护。
- en: 'If you would like to run Docker as a non-privileged user, you should consider
    adding your user to the `docker` group by executing the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望以非特权用户身份运行 Docker，你应该考虑通过执行以下命令将你的用户添加到 `docker` 组：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For this to take effect, you will need to log out and log in again. We can
    check that our user is now in the Docker group by checking the output of the following
    command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其生效，你需要注销并重新登录。我们可以通过检查以下命令的输出来确认我们的用户现在是否在 Docker 组中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output should include `docker` in the list of groups. Now, you can verify
    that you can run Docker commands without a root user (or `sudo`):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应包括 `docker` 在组列表中。现在，你可以验证是否可以在非 root 用户（或 `sudo`）的情况下运行 Docker 命令：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command will pull the `hello-world` test image from the Docker
    repository, and run it in a container. When the test image starts, it prints an
    informative message and exits:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令将从 Docker 仓库拉取 `hello-world` 测试镜像，并在容器中运行它。当测试镜像启动时，它会打印一条信息性消息然后退出：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This message shows that your installation appears to be working correctly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息表明你的安装似乎工作正常。
- en: Running Quarkus applications in a container
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行 Quarkus 应用程序
- en: Once you have installed Docker, you are just ready to build a Docker image out
    of your Java or native executable application. For this purpose, we will quickly
    build another simple application that inspects some environment variables to determine
    the container ID where the application is running.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Docker，你就可以准备从你的 Java 或本地可执行应用程序构建 Docker 镜像了。为此，我们将快速构建另一个简单的应用程序，该应用程序检查一些环境变量以确定应用程序运行的容器
    ID。
- en: The source code for this chapter is located in the `Chapter03/hello-okd` folder
    of this book's GitHub repository. We recommend importing the project into your
    IDE before you continue.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于本书 GitHub 仓库的 `Chapter03/hello-okd` 文件夹中。我们建议在继续之前将项目导入到你的 IDE 中。
- en: 'Let''s dive into the code by starting with the REST endpoint class (`HelloOKD`),
    which returns some information from a **Contexts and Dependency Injection** (**CDI**)
    service:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 REST 端点类 (`HelloOKD`) 开始，该类从 **Contexts and Dependency Injection** (**CDI**)
    服务返回一些信息：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following code is for the `ContainerService` class, which is injected into
    the REST endpoint:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `ContainerService` 类的代码，该类被注入到 REST 端点：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example shows the use of the CDI `@ApplicationScoped` annotation for injected
    objects. An object that is defined as `@ApplicationScoped` is created once for
    the duration of the lifetime of an application. In our case, it returns the `HOSTNAME`
    environment variable, which defaults to the Docker container ID.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了 CDI `@ApplicationScoped` 注解在注入对象中的应用。定义为 `@ApplicationScoped` 的对象将在应用程序的生命周期内创建一次。在我们的例子中，它返回
    `HOSTNAME` 环境变量，默认为 Docker 容器 ID。
- en: 'In order to test our simple REST service, the following `HelloOKDTest` has
    been included in the project under the `src/test/java` path. Through its `testHelloEndpoint`
    method, we verify that the status code of the REST call was a success:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的简单 REST 服务，以下 `HelloOKDTest` 已包含在 `src/test/java` 路径下的项目中。通过其 `testHelloEndpoint`
    方法，我们验证 REST 调用的状态码是否成功：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before we set off on our journey into Docker, let''s check that the preceding
    test passes. The test phase will automatically kick in as we run the `install`
    goal of our project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始 Docker 之旅之前，让我们检查前面的测试是否通过。测试阶段将在我们运行项目的 `install` 目标时自动启动：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A successful test should produce the following log:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的测试应该产生以下日志：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s move on to looking at Docker. If you take a look at the `src/main/docker`
    folder, you will notice that some of the files have been automatically added to
    your project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看 Docker。如果你查看 `src/main/docker` 文件夹，你会注意到一些文件已经被自动添加到你的项目中：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first file in the list, `Dockerfile.jvm`, is a Dockerfile that''s been
    specifically written for a JVM environment. Its content is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一个文件 `Dockerfile.jvm` 是为 JVM 环境专门编写的 Dockerfile。其内容如下：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A Dockerfile is a plain text file that contains a set of commands that we can
    use to assemble an image so that it can be executed by Docker. A Dockerfile needs
    to match with a specific format and set of instructions that have been documented
    in the Dockerfile reference ([https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个包含一系列命令的纯文本文件，我们可以使用这些命令来组装一个镜像，以便它可以由 Docker 执行。Dockerfile 需要与特定格式和一组已在
    Dockerfile 参考中记录的指令相匹配 ([https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/))。
- en: 'In our example, the Dockerfile contains instructions for building a Java environment
    using Fabric8 Java Base Image and enables the JMX exporter ([https://github.com/prometheus/jmx_exporter](https://github.com/prometheus/jmx_exporter))
    to expose process metrics. Now, we will build the image for our container, as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，Dockerfile 包含了使用 Fabric8 Java Base Image 构建Java环境的指令，并使 JMX 导出器 ([https://github.com/prometheus/jmx_exporter](https://github.com/prometheus/jmx_exporter))
    能够暴露进程指标。现在，我们将构建我们的容器镜像，如下所示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In your console, you can verify that the Docker pull process will be triggered
    and that all the commands in the Dockerfile contribute to building the intermediate
    layers of your `quarkus/hello-okd` container image:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的控制台中，你可以验证 Docker 拉取过程将被触发，并且 Dockerfile 中的所有命令都贡献于构建 `quarkus/hello-okd`
    容器镜像的中间层：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s check that the image is available in your local Docker repository
    by executing the `docker images` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行 `docker images` 命令来检查镜像是否在你的本地 Docker 仓库中可用：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, the locally cached image is now available in your local Docker
    repository. You can run it using the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，本地缓存的镜像现在可用在你的本地 Docker 仓库中。你可以使用以下命令运行它：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `run` command, we have included some additional flags, such as `--rm`,
    which removes the container automatically after it exits. The `-i` flag will connect
    the container to the Terminal. Finally, the `-p` flag exposes port `8080` externally,
    thus mapping to port `8080` on the host machine.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `run` 命令中，我们包含了一些额外的标志，例如 `--rm`，它会在容器退出后自动删除容器。`-i` 标志将容器连接到终端。最后，`-p` 标志将端口
    `8080` 外部暴露，从而映射到主机机器上的端口 `8080`。
- en: 'Since we will be exporting the service on the host port, that is, `8080`, check
    that no other service is engaging that port! You should be able to collect this
    output on the console, which is a log of the agent startup and, at the bottom,
    a log of our `hello-okd` service:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将导出主机上的服务到端口，即 `8080`，请检查没有其他服务正在占用该端口！你应该能够在控制台收集此输出，这是一个代理启动的日志，底部是我们的
    `hello-okd` 服务的日志：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Docker process is now running, which can be confirmed by the following
    command. This command will display the `Image` name for running containers:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docker进程现在正在运行，可以通过以下命令进行确认。此命令将显示运行容器的`Image`名称：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the output of running the preceding command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行前面命令的输出：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can test that the application is running in the container with the following
    command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令测试应用程序是否在容器中运行：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should be able to see the same container ID that was printed by the `docker
    ps` command in the output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在输出中看到与`docker ps`命令打印的相同容器ID：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's rebuild our container image so that we can use the native executable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新构建我们的容器镜像，以便我们可以使用原生可执行文件。
- en: Running the native executable process in a container
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行原生可执行进程
- en: 'As we have seen, the Quarkus Maven plugin has also produced `src/main/docker/Dockerfile.native`,
    which can be used as a template so that we can run our native executable in a
    container. Here''s the content of this file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Quarkus Maven插件还生成了`src/main/docker/Dockerfile.native`，可以用作模板，这样我们就可以在容器中运行我们的原生可执行文件。以下是该文件的内容：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since there's no need to use a JDK layer to start our application, the base
    layer for our container will be a stripped-down RHEL image known as `ubi-minimal`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要使用JDK层来启动我们的应用程序，我们的容器的基础层将是一个精简的RHEL镜像，称为`ubi-minimal`。
- en: Red Hat **Universal Base Images** (**UBI**) are OCI-compliant container OS images
    that include complimentary runtime languages and other packages that are freely
    redistributable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 红帽**通用基础镜像**（**UBI**）是符合OCI规范的容器操作系统镜像，包括免费重新分发的附加运行时语言和其他包。
- en: 'Before building the Docker image, package your application by including the
    `-Dnative-image.docker-build` option:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Docker镜像之前，通过包含`-Dnative-image.docker-build`选项来打包您的应用程序：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check that the build was successful and then build the image with the following
    command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 检查构建是否成功，然后使用以下命令构建镜像：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From the console, you will see that the container will be created in much the
    same way that the Java application was, but using a different initial image (`ubi-minimal`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，您将看到容器将以与Java应用程序相同的方式创建，但使用不同的初始镜像（`ubi-minimal`）：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s check that the image is available in the Docker repository:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查该镜像是否在Docker仓库中可用：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `quarkus/hello-okd-native` image is now available. Now, run the container
    image using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus/hello-okd-native`镜像现在可用。现在，使用以下命令运行容器镜像：'
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'No additional JVM layers will be displayed on the console. Here, we can see
    that our service was started up in just a few milliseconds:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台不会显示额外的JVM层。在这里，我们可以看到我们的服务仅用了几毫秒就启动了：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Verify that the application returns the container ID when requesting the `getContainerId`
    URI:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 验证当请求`getContainerId` URI时，应用程序返回容器ID：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In our case, the output is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，输出如下：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Great! We just managed to run a native application as a Docker image. Our next
    task will be deploying our image into a Kubernetes-native environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚成功地将一个原生应用程序作为Docker镜像运行。我们的下一个任务将是将我们的镜像部署到Kubernetes原生环境中。
- en: Deploying Quarkus applications on a Kubernetes-native platform
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes原生平台上部署Quarkus应用程序
- en: 'Now that we have verified how simple it is to run Quarkus applications in a
    container, we will deploy our application into a Kubernetes-native environment.
    Even if Kubernetes itself is sufficient to orchestrate your services, you can
    greatly extend its capabilities by installing OpenShift. Besides leveraging Kubernetes
    features, OpenShift also provides the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了在容器中运行Quarkus应用程序是多么简单，我们将部署我们的应用程序到Kubernetes原生环境中。即使Kubernetes本身足以编排您的服务，您也可以通过安装OpenShift来极大地扩展其功能。除了利用Kubernetes功能外，OpenShift还提供以下功能：
- en: Better management of container images through the use of **image streams**,
    which decouple the actual image from your application
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用**镜像流**更好地管理容器镜像，它将实际镜像与应用程序解耦
- en: Advanced CI/CD capabilities to make the whole CI/CD workflow a lot easier, also
    including a Jenkins certified image
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级CI/CD功能，使整个CI/CD工作流程变得更加容易，还包括一个Jenkins认证的镜像
- en: A simpler build process as it's easier to build a docker image inside OpenShift
    through the `BuildConfig` component, which can perform automated image builds
    and push them to its internal registry
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单的构建过程，因为通过`BuildConfig`组件在OpenShift内部构建Docker镜像更容易，该组件可以执行自动镜像构建并将它们推送到其内部仓库
- en: A wealth of certified plugins, such as storage/networking/monitoring plugins
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的经过认证的插件，例如存储/网络/监控插件
- en: Support for multitenancy through the **Resource Scheduler** component, which
    will determine where to run Pods
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 **资源调度器**组件支持多租户，该组件将确定 Pod 的运行位置
- en: A large set of certified databases and middleware products
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列经过认证的数据库和中间件产品
- en: A simpler UI web application from where you can easily manage your cluster of
    services and create new applications
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更简单的 UI 网络应用程序，您可以从其中轻松管理您的服务集群并创建新应用程序
- en: 'OpenShift is available in several flavors:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 有几种版本：
- en: '**Red Hat OpenShift Container Platform** (requires a subscription): The supported
    Kubernetes platform that lets you build, deploy, and manage your container-based
    applications consistently across cloud and on-premises infrastructures.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Red Hat OpenShift 容器平台**（需要订阅）：这是一个受支持的 Kubernetes 平台，让您可以一致地在云和本地基础设施上构建、部署和管理基于容器的应用程序。'
- en: '**Red Hat OpenShift Dedicated** (requires a subscription): This provides a
    supported, private, high-availability Red Hat OpenShift cluster hosted on Amazon
    Web Services or Google Cloud Platform.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Red Hat OpenShift 专用**（需要订阅）：这提供了一种受支持的、私有的、高可用性的 Red Hat OpenShift 集群，托管在亚马逊网络服务或谷歌云平台上。'
- en: '**Red Hat OpenShift Online** (several plans are available): It provides on-demand
    access to Red Hat OpenShift so that you can manage containerized applications.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Red Hat OpenShift 在线**（提供多种计划）：它提供按需访问 Red Hat OpenShift，以便您可以管理容器化应用程序。'
- en: '**Origin Community Distribution of Kubernetes** (**OKD**): This is the Community
    version of the Red Hat OpenShift Container Platform that you can freely use in
    any environment.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 的原始社区发行版**（**OKD**）：这是您可以在任何环境中自由使用的 Red Hat OpenShift 容器平台的社区版本。'
- en: For the purpose of this book, we will be installing **Minishift**, a simplified
    version of **OKD**, to launch a single-node cluster inside a virtual machine.
    This is the simplest approach to get started and try OpenShift on your local machine.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们将安装 **Minishift**，这是 **OKD** 的简化版本，以便在虚拟机内部启动单个节点集群。这是开始并尝试在本地机器上使用
    OpenShift 的最简单方法。
- en: The current version of Minishift is based on the release 3.x of Openshift. It
    is highly recommended to move to an Openshift 4.x platform for most advanced examples,
    such as developing Cloud based reactive applications, which is discussed in the
    last chapter of this book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Minishift 的当前版本基于 Openshift 的 3.x 版本发布。强烈建议迁移到 Openshift 4.x 平台，以便使用大多数高级示例，例如在本书最后一章讨论的基于云的响应式应用程序开发。
- en: 'The installation of Minishift is quite simple: all you''ll need to do is download
    and unzip the latest distribution of it. Some prerequisites, however, do exist
    as you need to prepare your system by installing a hypervisor, which is required
    to start the virtual environment that OKD is provisioned on.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Minishift 的安装相当简单：您需要做的只是下载并解压缩其最新发行版。然而，确实存在一些先决条件，因为您需要通过安装虚拟机管理程序来准备您的系统，这是启动
    OKD 提供的虚拟环境所必需的。
- en: Installing Minishift
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Minishift
- en: In this section, we will learn how to install Minishift on a machine running
    Fedora. If you don't run Fedora on your machine, you can check out the prerequisites
    for your OS at [https://docs.okd.io/latest/minishift/getting-started/preparing-to-install.html](https://docs.okd.io/latest/minishift/getting-started/preparing-to-install.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在运行 Fedora 的机器上安装 Minishift。如果您在机器上不运行 Fedora，您可以查看您操作系统的先决条件，请参阅[https://docs.okd.io/latest/minishift/getting-started/preparing-to-install.html](https://docs.okd.io/latest/minishift/getting-started/preparing-to-install.html)。
- en: 'First, you will need to install two kernel modules (`libvirt` and `qemu**-**kvm`),
    which are needed to manage the various virtualization platforms. These are compliant
    with the **Kernel-based Virtual Machine** (**KVM**) technology. Follow these steps
    to do so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装两个内核模块（`libvirt` 和 `qemu**-**kvm`），这些模块是管理各种虚拟化平台所需的。它们符合 **基于内核的虚拟机**（**KVM**）技术。按照以下步骤进行操作：
- en: 'From the shell, execute the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 shell 中，执行以下命令：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, to run the virtualization platform with your user, add it to the `libvirt`
    group:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了使用您的用户运行虚拟化平台，将其添加到 `libvirt` 组中：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, configure the group membership with the user you are currently logged
    in as:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用当前登录的用户配置组成员资格：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, you will need to download and make the KVM driver for your Docker
    machine executable. As the root user, execute the following commands:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要下载并使 Docker 机器的 KVM 驱动程序可执行。作为 root 用户，执行以下命令：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once your user has been set up, download and unpack the latest Minishift release
    package from the official GitHub repository: [https://github.com/minishift/minishift/releases](https://github.com/minishift/minishift/releases).
    At the time of writing, this is the latest version of Minishift that can be downloaded:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的用户设置完成，从官方GitHub仓库下载并解压最新的Minishift发布包：[https://github.com/minishift/minishift/releases](https://github.com/minishift/minishift/releases)。在撰写本文时，这是可以下载的Minishift的最新版本：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the download has completed, unpack the `.tar` file into a destination
    folder. For example, to unpack it into your home (`~`) directory, execute the
    following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，将`.tar`文件解压到目标文件夹中。例如，要将它解压到您的家目录（`~`），请执行以下命令：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Within this package, you will find the `minishift` executable, which can be
    used to start your Minishift environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此包中，您将找到`minishift`可执行文件，可用于启动您的Minishift环境。
- en: 'Next, we will run the `minishift` command to start the installation process:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行`minishift`命令以启动安装过程：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once complete, you should see a message similar to the following in your Terminal:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您应该在终端中看到类似以下的消息：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And that's it! Minishift has been installed in your environment!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！Minishift已安装到您的环境中！
- en: 'It''s recommended that you include the following folders in the `$PATH` environment
    variable:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您将以下文件夹包含在`$PATH`环境变量中：
- en: The folder where you have unpacked the `minishift` tool.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您解压`minishift`工具的文件夹。
- en: The folder where the `oc` client tool is located. This tool is a command-line
    utility that you can use to manage your Minishift cluster. Once you start up the
    cluster, this tool is copied to `~/.minishift/cache/oc/<oc-version>/linux`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存放`oc`客户端工具的文件夹。此工具是一个命令行实用程序，您可以使用它来管理您的Minishift集群。一旦启动集群，此工具将被复制到`~/.minishift/cache/oc/<oc-version>/linux`。
- en: 'So, for example, if you unpacked Minishift in your home directory, replace
    `oc-version` with your tool version and execute the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果您在家目录中解压了Minishift，请将`oc-version`替换为您的工具版本，并执行以下命令：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can verify this by opening the OpenShift web console in your default browser
    (in our case, `https://192.168.42.190:8443`) or by passing the `console` argument
    to the `minishift` tool:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在默认浏览器中打开OpenShift网络控制台（在我们的案例中，`https://192.168.42.190:8443`）或通过将`console`参数传递给`minishift`工具来验证这一点：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since the console runs on a secured connection, you will be warned that no
    signed certificates have been found in your browser. Add a security exception
    to your browser so that you land on the login page:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于控制台在安全连接上运行，您将收到警告，表示在您的浏览器中未找到已签名的证书。向您的浏览器添加安全异常，以便您登录到登录页面：
- en: '![](img/bd93639c-7c77-45e3-9837-1486b67607e1.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd93639c-7c77-45e3-9837-1486b67607e1.png)'
- en: 'Log in with `developer/developer` to enter the dashboard:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`developer/developer`登录以进入仪表板：
- en: '![](img/3cdc899c-2da8-45da-9f2b-1268cc2d91e2.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cdc899c-2da8-45da-9f2b-1268cc2d91e2.png)'
- en: Congratulations! You have installed Minishift and verified it. The next step
    will be deploying our sample application on it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已安装Minishift并验证了它。下一步将是将其部署到我们的示例应用程序上。
- en: Building and deploying a Quarkus application on OKD
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OKD上构建和部署Quarkus应用程序
- en: Minishift's dashboard contains a set of templates that can be used to build
    our applications quickly. At the time of writing, there's no Quarkus template;
    however, we can easily build and deploy our image as a **binary build** that conveys
    the Dockerfile that we have already tested.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Minishift的仪表板包含一组模板，可以快速构建我们的应用程序。在撰写本文时，还没有Quarkus模板；然而，我们可以轻松构建和部署我们的镜像，作为一个**二进制构建**，它传达了我们已经测试过的Dockerfile。
- en: A **binary build** is a feature that allows developers to upload artifacts from
    a binary source instead of pulling the source from a Git repository URL.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制构建**是一种功能，允许开发者从二进制源上传工件，而不是从Git仓库URL拉取源代码。'
- en: For this purpose, we will be using the `oc` client tool, which is the Swiss
    Army knife that's used to configure OpenShift and its objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用`oc`客户端工具，这是用于配置OpenShift及其对象的瑞士军刀。
- en: The following set of commands is contained in the `deploy-openshift.sh` file,
    which is located in the `Chapter03` directory of this book's GitHub repository.
    If you are impatient to see your application in the cloud, simply execute the
    script and check that the output matches what we've written in this paragraph.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令集包含在本书GitHub仓库的`Chapter03`目录中的`deploy-openshift.sh`文件中。如果您迫不及待想看到您的应用程序在云中运行，只需执行脚本并检查输出是否与本文中所述相符。
- en: 'The first thing we will need to do is create a namespace for our project, which
    will be created in our current OpenShift namespace. You can create the `quarkus-hello-okd`
    namespace with the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是为我们的项目创建一个命名空间，该命名空间将在我们的当前OpenShift命名空间中创建。你可以使用以下命令创建`quarkus-hello-okd`命名空间：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first thing we will need to do is define a binary build object using the
    `oc new-build` command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是使用`oc new-build`命令定义一个二进制构建对象：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The previous command will produce an image binary build that will be pushed
    into Minishift''s internal registry. The following output describes the resources
    that were created for this purpose:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将生成一个图像二进制构建，并将其推送到Minishift的内部注册表。以下输出描述了为此目的创建的资源：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that the build configuration has been created, we can check its availability
    by querying the `bc` alias (which stands for build config):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建配置已经创建，我们可以通过查询`bc`别名（代表构建配置）来检查其可用性：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should see the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As it is, the binary build doesn''t contain any reference to our Dockerfile.
    We can add this information using the `oc patch` command, which is a useful shortcut
    that we can use to edit resources. In our case, we need to set the `dockerfilePath`
    attribute that refers to the `dockerStrategy` element to the location where our
    Dockerfile is. From the root of your Quarkus project, execute the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，二进制构建不包含对Dockerfile的任何引用。我们可以使用`oc patch`命令添加此信息，这是一个有用的快捷方式，我们可以用它来编辑资源。在我们的例子中，我们需要设置`dockerfilePath`属性，使其指向Dockerfile的位置。从你的Quarkus项目根目录开始，执行以下命令：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following output will be returned:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回以下输出：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you check the binary build description, you will see that the Dockerfile
    path has been included:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查二进制构建描述，你会看到Dockerfile路径已被包含：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is a bit verbose; however, it should contain the following information:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出有些冗长；然而，它应该包含以下信息：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we are ready to start the build process, which will take the project''s
    root folder (`.`) as input and will result in uploading `ImageStream` onto your
    Minishift environment. Execute the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始构建过程，该过程将以项目根文件夹（`.`）作为输入，并将结果上传到你的Minishift环境。执行以下命令：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will notify you that the image has been built and pushed to the
    Minishift registry:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将通知你图像已被构建并推送到Minishift注册表：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As a proof of concept, let''s check the list of image streams that are available
    in the default project using its alias, `is`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念验证，让我们检查默认项目中可用的图像流列表，使用其别名`is`：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Your `ImageStream` is now available. All we have to do is create an application
    that uses `ImageStream quarkus-hello-okd` as input. This can be done using the
    following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`ImageStream`现在可用。我们只需创建一个使用`ImageStream quarkus-hello-okd`作为输入的应用程序。这可以通过以下命令完成：
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, the resources will be created. This will be confirmed by the resulting
    output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将创建资源。这将通过以下输出得到确认：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, our application is ready to be consumed. To allow external clients to
    access it, we need to expose it through a route object, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已准备好被使用。为了允许外部客户端访问它，我们需要通过路由对象将其公开，如下所示：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The route will be exposed and the following log will be displayed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 路由将被公开，并显示以下日志：
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can verify the route address with the following command, which uses a JSON
    template to display the virtual host address of our `quarkus-hello-okd` route:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令验证路由地址，该命令使用JSON模板显示`quarkus-hello-okd`路由的虚拟主机地址：
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In our case, the route is accessible at the following address:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，路由可通过以下地址访问：
- en: '[PRE61]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Please note that the actual IP address of the route is determined by the hypervisor
    according to your network configuration, so don't be surprised if it differs from
    the address that was exposed in this example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际的路由IP地址是由虚拟机管理程序根据你的网络配置确定的，所以如果它与示例中暴露的地址不同，请不要感到惊讶。
- en: 'You should be able to acknowledge this information from the web console, which
    shows that the application is up and running and that a single Pod has been started:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够从Web控制台确认此信息，这表明应用程序正在运行，并且已启动一个Pod：
- en: '![](img/62302b35-e85a-458c-8f32-efe6d45a5781.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62302b35-e85a-458c-8f32-efe6d45a5781.png)'
- en: 'If you go to the route host/port you have been assigned (in our case, `http://quarkus-hello-okd-myproject.192.168.42.5.nip.io`),
    you will see the following welcome screen:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问分配给你的路由主机/端口（在我们的例子中，`http://quarkus-hello-okd-myproject.192.168.42.5.nip.io`），你会看到以下欢迎屏幕：
- en: '![](img/fe8baf16-18e9-4e8a-b0f4-7eafd361f0a5.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe8baf16-18e9-4e8a-b0f4-7eafd361f0a5.png)'
- en: 'This is a simple static page that has been included in `src/main/resources/META-INF/resources/index.html`
    to show you that your application is available and contains some useful information
    about where you can place static assets and configuration. Your REST service,
    on the other hand, is still available through the REST URI:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的静态页面，它已经被包含在 `src/main/resources/META-INF/resources/index.html` 中，以显示你的应用程序是可用的，并包含一些有关你可以放置静态资源和配置的有用信息。另一方面，你的
    REST 服务仍然可以通过 REST URI 访问：
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Since the application is running on the `quarkus-hello-okd-1-84xwq` Pod, the
    expected output is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序正在运行在 `quarkus-hello-okd-1-84xwq` Pod 上，预期的输出如下：
- en: '[PRE63]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, let's learn how to scale our Quarkus service by adding some replicas of
    our application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何通过添加一些应用程序的副本来扩展我们的 Quarkus 服务。
- en: Scaling our Quarkus service
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展我们的 Quarkus 服务
- en: So far, you've learned how to deploy a Quarkus application on Minishift. The
    application is running in a Pod, which is allocated in its own internal IP address
    and is the equivalent of a machine running a container. In our case, the application
    is running on one Pod in an OpenShift node. This is sufficient to guarantee the
    availability of our applications since some liveness and readiness probes are
    periodically executed. If your Pods stop responding, the OpenShift platform will
    automatically restart them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何在 Minishift 上部署 Quarkus 应用程序。该应用程序在一个 Pod 中运行，它分配了自己的内部 IP 地址，相当于运行容器的机器。在我们的例子中，应用程序在一个
    OpenShift 节点的一个 Pod 上运行。这足以保证我们应用程序的可用性，因为一些存活性和就绪性探针会定期执行。如果你的 Pods 停止响应，OpenShift
    平台将自动重启它们。
- en: On the other hand, your application probably needs to satisfy a minimum throughput.
    This requirement usually can't be met with just one Pod unless the number of requests
    is pretty low. In this case, the simplest strategy is horizontal Pod scaling,
    which will improve the number of available resources that will be automatically
    balanced when a request for your application arrives on the router.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你的应用程序可能需要满足一个最低吞吐量。除非请求量相当低，否则通常无法仅通过一个 Pod 来满足这一要求。在这种情况下，最简单的策略是水平 Pod
    扩缩，这将提高在请求到达路由器时自动平衡的可用资源数量。
- en: Before scaling up our application, we will need to define an upper memory limit
    for it, in order to reduce the impact it will have on the cluster in terms of
    system resources. Since our Quarkus application doesn't require a large amount
    of memory, we will set a limit of 50 MB as the upper limit, which is quite reasonable,
    and definitely thinner than an average Java application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展我们的应用程序之前，我们需要为它定义一个上限内存限制，以减少它对集群在系统资源方面的冲击。由于我们的 Quarkus 应用程序不需要大量的内存，我们将设置
    50 MB 作为上限，这相当合理，并且肯定比一个平均的 Java 应用程序要薄。
- en: 'Execute the following command to set the memory limit to 50 MB. This will update
    the **deployment configuration** of your application:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令将内存限制设置为 50 MB。这将更新你应用程序的 **部署配置**：
- en: '[PRE64]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A deployment configuration (whose alias in the command line is simply `dc`)
    describes the state of a particular component of the application as a Pod template.
    When you update the deployment configuration, a deployment process occurs to scale
    down the application and scale it up with a new deployment configuration and a
    new replication controller for the application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 部署配置（在命令行中的别名简单为 `dc`）描述了应用程序特定组件的状态，作为一个 Pod 模板。当你更新部署配置时，会发生部署过程，以缩小应用程序的规模，并使用新的部署配置和新的应用程序复制控制器来扩大规模。
- en: 'The following output should be returned:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 应该返回以下输出：
- en: '[PRE65]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As a proof of concept, you can verify the deployment configuration through
    the `describe` command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念验证，你可以通过 `describe` 命令验证部署配置：
- en: '[PRE66]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output of the `describe` command is a bit verbose; however, you should
    be able to see the following setting in the `Limits` section:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 命令的输出有点冗长；然而，你应该能够在 `Limits` 部分看到以下设置：'
- en: '[PRE67]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s scale our application to 10 instances. This will be pretty fast
    since we have set a memory limit on the resources that are consumed by each Pod:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is the expected output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Moving to the web console, in the Overview panel, we will see that our application
    has scaled to 10 Pods:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37d3f292-5448-4e98-b08c-793a23f269f9.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a large number of available Pods, let''s try to run a load
    test against our application:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, you should be able to see the response that was produced by the REST application
    in your console. This displays the ID of the Pod that executed the request (the
    output has been truncated for brevity):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Although measuring the performance of our applications is beyond the scope of
    this book, you can go ahead and measure the time that's needed to run the equivalent
    Java application in the same cluster. You will notice a different response in
    terms of time and memory consumption!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'That was our last task for this chapter. When you are done with this example,
    and you want to clean up the resources we created in our project, simply execute
    the following command, which will perform a bulk cleanup of resources:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output may vary, depending on the number of Pods available. However, it
    should look similar to the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding log confirms that all the deleted resources have been successfully
    evicted.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we ran a simple REST application in a Docker container and
    then ran it in a Kubernetes-native environment, that is, Minishift. We saw how
    simple it is to make our applications highly available with a sound throughput
    by leveraging the features of a bundled distribution of OKD.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to add some more features to our application. In the next chapter,
    we will learn how to configure the Undertow extension, which can be added to provide
    web server capabilities to our application. It also includes some UI assets, which
    we will look at in brief.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
