- en: '*Chapter 10*: Managing Data in a Database'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：数据库中的数据管理'
- en: This chapter explains and demonstrates how to manage – that is, insert, read,
    update, and delete – data in a database using a Java application. It also provides
    a short introduction to **Structured Query Language** (**SQL**) and basic database
    operations, including how to connect to a database, how to create a database structure,
    how to write a database expression using SQL, and how to execute these expressions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释并演示了如何使用 Java 应用程序管理数据库中的数据——也就是说，插入、读取、更新和删除数据。它还简要介绍了 **结构化查询语言**（**SQL**）和基本数据库操作，包括如何连接到数据库、如何创建数据库结构、如何使用
    SQL 编写数据库表达式以及如何执行这些表达式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库
- en: Creating a database structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库结构
- en: Connecting to a database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Releasing the connection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放连接
- en: '**Create, read, update, and delete** (**CRUD**) operations on data'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建、读取、更新和删除**（**CRUD**）数据操作'
- en: Using a shared library JAR file to access a database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享库 JAR 文件访问数据库
- en: By the end of the chapter, you will be able to create and use a database for
    storing, updating, and retrieving data as well as create and use a shared library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建和使用数据库来存储、更新和检索数据，以及创建和使用共享库。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，你需要以下内容：
- en: A computer with either a Microsoft Windows, Apple macOS, or Linux operating
    system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有 Microsoft Windows、Apple macOS 或 Linux 操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高
- en: An IDE or code editor you prefer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你偏好的 IDE 或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015)*,* *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on GitHub
    ([https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git))
    in the `examples/src/main/java/com/packt/learnjava/ch10_database` folder, and
    in the `database` folder, as a separate project of the shared library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何设置 Java SE 和 IntelliJ IDEA 编辑器的说明在 [*第 1 章*](B18388_01_ePub.xhtml#_idTextAnchor015)*，*
    *Java 17 入门* 中提供。本章的代码示例文件可在 GitHub 上找到（[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)），位于
    `examples/src/main/java/com/packt/learnjava/ch10_database` 文件夹中，以及 `database`
    文件夹中，作为共享库的独立项目。
- en: Creating a database
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: '`java.sql`, `javax.sql`, and `java.transaction.xa` packages) and the database-specific
    class that implements an interface for database access (called a **database driver**),
    which is provided by each database vendor.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.sql`, `javax.sql`, 和 `java.transaction.xa` 包以及实现数据库访问接口（称为 **数据库驱动程序**）的特定数据库类，这些由每个数据库供应商提供。'
- en: Using JDBC means writing Java code that manages data in a database using the
    interfaces and classes of the JDBC API and a database-specific driver, which knows
    how to establish a connection with the particular database. Using this connection,
    an application can then issue requests written in SQL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JDBC 意味着编写 Java 代码，使用 JDBC API 的接口和类以及特定数据库的驱动程序来管理数据库中的数据，该驱动程序知道如何与特定数据库建立连接。使用此连接，应用程序可以随后发出用
    SQL 编写的请求。
- en: Naturally, we are only referring to the databases that understand SQL here.
    They are called relational or tabular **database management systems** (**DBMSs**)
    and make up the vast majority of the currently used DBMSs – although some alternatives
    (for example, a navigational database and NoSQL) are used too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们这里只指的是理解 SQL 的数据库。它们被称为关系型或表格 **数据库管理系统**（**DBMS**），构成了目前使用的 DBMS 中的绝大多数——尽管也使用了一些替代方案（例如，导航数据库和
    NoSQL）。
- en: The `java.sql` and `javax.sql` packages are included in the `javax.sql` package
    contains the `DataSource` interface that supports the statement’s pooling, distributed
    transactions, and rowsets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.sql` 和 `javax.sql` 包包含在 `javax.sql` 包中，它包含支持语句池、分布式事务和行集的 `DataSource`
    接口。'
- en: 'Creating a database involves the following eight steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据库涉及以下八个步骤：
- en: Install the database by following the vendor instructions.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照供应商的说明安装数据库。
- en: Open the PL/SQL terminal and create a database user, a database, a schema, tables,
    views, stored procedures, and anything else that is necessary to support the data
    model of the application.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PL/SQL终端并创建数据库用户、数据库、模式、表、视图、存储过程以及支持应用程序数据模型所需的一切。
- en: Add to this application the dependency on a `.jar` file with the database-specific
    driver.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此应用程序添加对具有数据库特定驱动程序的`.jar`文件的依赖。
- en: Connect to the database from the application.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序连接到数据库。
- en: Construct the SQL statement.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建SQL语句。
- en: Execute the SQL statement.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行SQL语句。
- en: Use the result of the execution as your application requires.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的应用程序需求使用执行结果。
- en: Release (that is, close) the database connection and any other resources that
    were opened in the process.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放（即关闭）数据库连接以及在此过程中打开的任何其他资源。
- en: '*Steps 1* to *3* are performed only once during the database setup and before
    the application is run. *Steps 4* to *8* are performed by the application repeatedly
    as needed. In fact, *Steps 5* to *7* can be repeated multiple times with the same
    database connection.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*到*3*在数据库设置期间以及应用程序运行之前只执行一次。*步骤4*到*8*根据需要由应用程序重复执行。实际上，*步骤5*到*7*可以使用相同的数据库连接重复多次。'
- en: 'For our example, we are going to use the PostgreSQL database. You will first
    need to perform *Steps 1* to *3* by yourself using the database-specific instructions.
    To create the database for our demonstration, we use the following PL/SQL commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用PostgreSQL数据库。您首先需要根据数据库特定的说明自行执行*步骤1*到*3*。为了创建我们的演示数据库，我们使用以下PL/SQL命令：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These commands create a `student` user that can manage all aspects of the `SUPERUSER`
    database, and make the `student` user an owner of the `learnjava` database. We
    will use the `student` user to access and manage data from the Java code. In practice,
    for security considerations, an application is not allowed to create or change
    database tables and other aspects of the database structure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令创建了一个可以管理`SUPERUSER`数据库所有方面的`student`用户，并将`student`用户设置为`learnjava`数据库的所有者。我们将使用`student`用户从Java代码访问和管理数据。在实际应用中，出于安全考虑，应用程序不允许创建或更改数据库表和其他数据库结构方面。
- en: Additionally, it is a good practice to create another logical layer, called
    a **schema**, which can have its own set of users and permissions. This way, several
    schemas in the same database can be isolated, and each user (one of them is your
    application) can only access certain schemas. On an enterprise level, the common
    practice is to create synonyms for the database schema so that no application
    can access the original structure directly. However, we do not do this in this
    book for the sake of simplicity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建另一个逻辑层，称为**模式**，它可以有自己的用户和权限集是一个好习惯。这样，同一数据库中的多个模式可以隔离，每个用户（其中之一是您的应用程序）只能访问某些模式。在企业层面，常见的做法是为数据库模式创建同义词，这样没有任何应用程序可以直接访问原始结构。然而，为了简化，我们在这本书中不这样做。
- en: Creating a database structure
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库结构
- en: 'After the database is created, the following three SQL statements will allow
    you to create and change the database structure. This is done through database
    entities, such as a table, function, or constraint:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库创建后，以下三个SQL语句将允许您创建和更改数据库结构。这是通过数据库实体（如表、函数或约束）完成的：
- en: The `CREATE` statement creates the database entity.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE`语句创建数据库实体。'
- en: The `ALTER` statement changes the database entity.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALTER`语句更改数据库实体。'
- en: The `DROP` statement deletes the database entity.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DROP`语句删除数据库实体。'
- en: There are also various SQL statements that allow you to inquire about each database
    entity. Such statements are database-specific and, typically, they are only used
    in a database console. For example, in the PostgreSQL console, `\d <table>` can
    be used to describe a table, while `\dt` lists all the tables. Refer to your database
    documentation for more details.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样存在各种SQL语句，允许您查询每个数据库实体。这些语句是数据库特定的，通常仅在数据库控制台中使用。例如，在PostgreSQL控制台中，可以使用`\d
    <table>`来描述一个表，而`\dt`列出所有表。有关更多详细信息，请参阅您的数据库文档。
- en: 'To create a table, you can execute the following SQL statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个表，您可以执行以下SQL语句：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The limitations for a table name, column names, and types of values that can
    be used depend on the particular database. Here is an example of a command that
    creates the `person` table in PostgreSQL:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表名、列名和可以使用的值类型的限制取决于特定的数据库。以下是一个在PostgreSQL中创建`person`表的命令示例：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `SERIAL` keyword indicates that this field is a sequential integer number
    that is generated by the database every time a new record is created. Additional
    options for generating sequential integers are `SMALLSERIAL` and `BIGSERIAL`;
    they differ by size and the range of possible values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`SERIAL` 关键字表示该字段是一个由数据库在创建新记录时生成的顺序整数。生成顺序整数的其他选项有 `SMALLSERIAL` 和 `BIGSERIAL`；它们在大小和可能值的范围内有所不同：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `PRIMARY_KEY` keyword indicates that this is going to be the unique identifier
    of the record and will most probably be used in a search. The database creates
    an index for each primary key to make the search process faster. An index is a
    data structure that helps to accelerate data search in the table without having
    to check every table record. An index can include one or more columns of a table.
    If you request the description of the table, you will see all the existing indices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIMARY_KEY` 关键字表示这将是要记录的唯一标识符，并且很可能会用于搜索。数据库为每个主键创建一个索引，以加快搜索过程。索引是一种数据结构，有助于加速表中的数据搜索，而无需检查每个表记录。索引可以包括一个或多个表的列。如果您请求表的描述，您将看到所有现有的索引。'
- en: 'Alternatively, we can make a composite `PRIMARY KEY` keyword using a combination
    of `first_name`, `last_name`, and `dob`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `first_name`、`last_name` 和 `dob` 的组合来创建一个复合 `PRIMARY KEY` 关键字：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, there is a chance that there are two people who will have the same
    name and were born on the same day, so such a composite prim is not a good idea.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在两个人可能同名且在同一天出生的可能性，因此这样的组合主键不是一个好主意。
- en: 'The `NOT NULL` keyword imposes a constraint on the field: it cannot be empty.
    The database will raise an error for every attempt to create a new record with
    an empty field or delete the value from the existing record. We did not set the
    size of the columns of type `VARCHAR`, thus allowing these columns to store string
    values of any length.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOT NULL` 关键字对字段施加约束：它不能为空。数据库将为尝试创建一个空字段的记录或从现有记录中删除值的每个尝试引发错误。我们没有设置 `VARCHAR`
    类型的列的大小，因此允许这些列存储任何长度的字符串值。'
- en: 'The Java object that matches such a record may be represented by the following
    `Person` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与此类记录匹配的 Java 对象可能由以下 `Person` 类表示：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may have noticed, there are two constructors in the `Person` class:
    with and without `id`. We will use the constructor that accepts `id` to construct
    an object based on the existing record, while the other constructor will be used
    to create an object before inserting a new record.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，`Person` 类中有两个构造函数：带有 `id` 和不带 `id` 的。我们将使用接受 `id` 的构造函数来根据现有记录构建一个对象，而另一个构造函数将用于在插入新记录之前创建一个对象。
- en: 'Once created, the table can be deleted using the `DROP` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，可以使用 `DROP` 命令来删除表格：
- en: '[PRE39]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The existing table can also be changed using the `ALTER` SQL command; for example,
    we can add a column address:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ALTER` SQL 命令更改现有表格；例如，我们可以添加一个地址列：
- en: '[PRE40]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you are not sure whether such a column exists already, you can add `IF EXISTS`
    or `IF NOT EXISTS`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否已经存在此类列，您可以添加 `IF EXISTS` 或 `IF NOT EXISTS`：
- en: '[PRE41]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this possibility exists only with PostgreSQL 9.6 and later versions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种可能性仅存在于 PostgreSQL 9.6 及更高版本中。
- en: 'Another important consideration to take note of during database table creation
    is whether another index (in addition to `PRIMARY KEY`) has to be added. For example,
    we can allow a case-insensitive search of first and last names by adding the following
    index:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据库表时，另一个重要考虑因素是是否需要添加另一个索引（除了 `PRIMARY KEY` 之外）。例如，我们可以通过添加以下索引来允许对首字母和姓氏进行不区分大小写的搜索：
- en: '[PRE42]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the search speed improves, we leave the index in place; if not, it can be
    removed, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索速度提高，我们保留索引；如果没有，可以按照以下方式删除：
- en: '[PRE43]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We remove it because an index has an overhead of additional writes and storage
    space.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其删除，因为索引有额外的写入和存储空间开销。
- en: 'We also can remove a column from a table if we need to, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们也可以从表中删除列，如下所示：
- en: '[PRE44]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In our examples, we follow the naming convention of PostgreSQL. If you use a
    different database, we suggest that you look up its naming convention and follow
    it, so that the names you create align with those that are created automatically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们遵循 PostgreSQL 的命名约定。如果您使用不同的数据库，我们建议您查找其命名约定并遵循它，以便您创建的名称与自动创建的名称相匹配。
- en: Connecting to a database
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: So far, we have used a console to execute SQL statements. The same statements
    can be executed from Java code using the JDBC API too. But, tables are created
    only once, so there is not much sense in writing a program for a one-time execution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用控制台来执行SQL语句。同样，也可以使用JDBC API从Java代码中执行这些语句。但是，表只创建一次，因此为单次执行编写程序没有太多意义。
- en: 'Data management, however, is another matter. So, from now on, we will use Java
    code to manipulate data in a database. In order to do this, we first need to add
    the following dependency to the `pom.xml` file in the `database` project:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据管理是另一回事。所以，从现在开始，我们将使用Java代码来操作数据库中的数据。为了做到这一点，我们首先需要将以下依赖项添加到`database`项目的`pom.xml`文件中：
- en: '[PRE45]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `example` project also gets access to this dependency because, in the `pom.xml`
    file of the `example` project, we have the following dependency on the database
    `.jar` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`example`项目也获得了对这个依赖的访问权限，因为在`example`项目的`pom.xml`文件中，我们有以下对数据库`.jar`文件的依赖项：'
- en: '[PRE50]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Make sure to install the `database` project by executing the `"mvn clean install"`
    command in the `database` folder before running any of the examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何示例之前，请确保通过在`database`文件夹中执行`"mvn clean install"`命令来安装`database`项目。
- en: 'Now, we can create a database connection from the Java code, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从Java代码中创建数据库连接，如下所示：
- en: '[PRE55]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding code is just an example of how to create a connection using the
    `java.sql.DriverManger` class. The `prop.put( "password", "secretPass123" )` statement
    demonstrates how to provide a password for the connection using the `java.util.Properties`
    class. However, we did not set a password when we created the `student` user,
    so we do not need it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是使用`java.sql.DriverManger`类创建连接的一个示例。`prop.put( "password", "secretPass123"
    )`语句演示了如何使用`java.util.Properties`类为连接提供密码。然而，我们在创建`student`用户时没有设置密码，所以不需要它。
- en: Many other values can be passed to `DriverManager` that configure the connection
    behavior. The name of the keys for the passed-in properties are the same for all
    major databases, but some of them are database-specific. So, read your database
    vendor documentation for more details.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向`DriverManager`传递许多其他值来配置连接行为。传入属性的键名对所有主要数据库都是相同的，但其中一些是数据库特定的。所以，阅读你的数据库供应商文档以获取更多详细信息。
- en: Alternatively, for passing `user` and `password` only, we could use an overloaded
    `DriverManager.getConnection(String url, String user, String password)` version.
    It is a good practice to keep the password encrypted. We are not going to demonstrate
    how to do it, but there are plenty of guides available on the internet that you
    can refer to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们只想传递`user`和`password`，可以使用重载的`DriverManager.getConnection(String url,
    String user, String password)`版本。保持密码加密是一个好习惯。我们不会演示如何做，但互联网上有许多可参考的指南。
- en: 'Another way of connecting to a database is to use the `javax.sql.DataSource`
    interface. Its implementation is included in the same `.jar` file as the database
    driver. In the case of `PostgreSQL`, there are two classes that implement the
    `DataSource` interface:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库的另一种方式是使用`javax.sql.DataSource`接口。它的实现包含在数据库驱动程序的同一`.jar`文件中。在`PostgreSQL`的情况下，有两个类实现了`DataSource`接口：
- en: '`org.postgresql.ds.PGSimpleDataSource`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.postgresql.ds.PGSimpleDataSource`'
- en: '`org.postgresql.ds.PGConnectionPoolDataSource`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.postgresql.ds.PGConnectionPoolDataSource`'
- en: 'We can use these classes instead of `DriverManager`. The following code is
    an example of creating a database connection using the `PGSimpleDataSource` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些类来代替`DriverManager`。以下代码是使用`PGSimpleDataSource`类创建数据库连接的一个示例：
- en: '[PRE64]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Using the `PGConnectionPoolDataSource` class allows you to create a pool of
    `Connection` objects in memory, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PGConnectionPoolDataSource`类允许你在内存中创建一个`Connection`对象池，如下所示：
- en: '[PRE75]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is a preferred method because creating a `Connection` object takes time.
    Pooling allows you to do it upfront and then reuse the created objects when they
    are needed. After the connection is no longer required, it can be returned to
    the pool and reused. The pool size and other parameters can be set in a configuration
    file (such as `postgresql.conf` for PostgreSQL).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个首选方法，因为创建`Connection`对象需要时间。池化允许你提前创建，并在需要时重用创建的对象。当连接不再需要时，它可以返回到池中并重用。池大小和其他参数可以在配置文件（如PostgreSQL的`postgresql.conf`）中设置。
- en: However, you do not need to manage the connection pool yourself. There are several
    mature frameworks that can do it for you, such as HikariCP ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)),
    Vibur ([http://www.vibur.org](http://www.vibur.org)), and Commons DBCP ([https://commons.apache.org/proper/commons-dbcp](https://commons.apache.org/proper/commons-dbcp))
    – these are reliable and easy to use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不需要自己管理连接池。有几个成熟的框架可以为你完成这项工作，例如 HikariCP ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP))、Vibur
    ([http://www.vibur.org](http://www.vibur.org)) 和 Commons DBCP ([https://commons.apache.org/proper/commons-dbcp](https://commons.apache.org/proper/commons-dbcp))
    - 这些框架可靠且易于使用。
- en: Whatever method of creating a database connection we choose, we are going to
    hide it inside the `getConnection()` method and use it in all our code examples
    in the same way. With the object of the `Connection` class acquired, we can now
    access the database to add, read, delete, or modify the stored data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择哪种创建数据库连接的方法，我们都会将其隐藏在 `getConnection()` 方法中，并在所有代码示例中以相同的方式使用它。一旦获取了
    `Connection` 类的对象，我们就可以访问数据库，以添加、读取、删除或修改存储的数据。
- en: Releasing the connection
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放连接
- en: Keeping the database connection alive requires a significant number of resources,
    such as memory and CPU, so it is a good idea to close the connection and release
    the allocated resources as soon as you no longer need them. In the case of pooling,
    the `Connection` object, when closed, is returned to the pool and consumes fewer
    resources.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 保持数据库连接活跃需要大量的资源，例如内存和 CPU，因此，当你不再需要它们时，关闭连接并释放分配的资源是一个好主意。在连接池的情况下，当 `Connection`
    对象关闭时，它会被返回到池中，并消耗更少的资源。
- en: 'Before Java 7, a connection was closed by invoking the `close()` method in
    a `finally` block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 7 之前，通过在 `finally` 块中调用 `close()` 方法来关闭连接：
- en: '[PRE90]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The code inside the `finally` block is always executed, whether the exception
    inside the `try` block is thrown or not. However, since Java 7, the `try-with-resources`
    construct also does the job on any object that implements the `java.lang.AutoCloseable`
    or `java.io.Closeable` interface. Since the `java.sql.Connection` object does
    implement the `AutoCloseable` interface, we can rewrite the previous code snippet,
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块中的代码总是会被执行，无论 `try` 块中的异常是否被抛出。然而，自从 Java 7 以来，`try-with-resources`
    构造也可以在实现 `java.lang.AutoCloseable` 或 `java.io.Closeable` 接口的对象上完成这项工作。由于 `java.sql.Connection`
    对象实现了 `AutoCloseable` 接口，我们可以重写之前的代码片段，如下所示：'
- en: '[PRE102]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `catch` clause is necessary because the `AutoCloseable` resource throws
    `java.sql.SQLException`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 子句是必要的，因为 `AutoCloseable` 资源会抛出 `java.sql.SQLException`。'
- en: CRUD data
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD 数据
- en: 'There are four kinds of SQL statements that read or manipulate data in a database:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的 SQL 语句可以读取或操作数据库中的数据：
- en: The `INSERT` statement adds data to a database.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT` 语句用于向数据库中添加数据。'
- en: The `SELECT` statement reads data from a database.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT` 语句用于从数据库中读取数据。'
- en: The `UPDATE` statement changes data in a database.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE` 语句用于更改数据库中的数据。'
- en: The `DELETE` statement deletes data from a database.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 语句用于从数据库中删除数据。'
- en: Either one or several different clauses can be added to the preceding statements
    to identify the data that is requested (such as the `WHERE` clause) and the order
    in which the results have to be returned (such as the `ORDER` clause).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向前面的语句添加一个或多个不同的子句来标识请求的数据（例如 `WHERE` 子句）以及结果必须返回的顺序（例如 `ORDER` 子句）。
- en: 'The JDBC connection is represented by `java.sql.Connection`. This, among others,
    has the methods required to create three types of objects that allow you to execute
    SQL statements that provide different functionality to the database side:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 连接由 `java.sql.Connection` 表示。这，以及其他一些方法，允许你创建三种类型的对象，这些对象可以执行提供不同功能的 SQL
    语句：
- en: '`java.sql.Statement`: This simply sends the statement to the database server
    for execution.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.sql.Statement`：这仅仅是将语句发送到数据库服务器以执行。'
- en: '`java.sql.PreparedStatement`: This caches the statement with a certain execution
    path on the database server by allowing it to be executed multiple times with
    different parameters in an efficient manner.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.sql.PreparedStatement`：通过允许以高效的方式多次使用不同的参数执行，它可以在数据库服务器上缓存语句并指定一定的执行路径。'
- en: '`java.sql.CallableStatement`: This executes the stored procedure in the database.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.sql.CallableStatement`：这可以在数据库中执行存储过程。'
- en: In this section, we are going to review how to do it in Java code. The best
    practice is to test the SQL statement in the database console before using it
    programmatically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾如何在 Java 代码中实现它。最佳实践是在程序化使用之前在数据库控制台中测试 SQL 语句。
- en: The INSERT statement
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`INSERT` 语句'
- en: 'The `INSERT` statement creates (populates) data in the database and has the
    following format:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT` 语句在数据库中创建（填充）数据，并具有以下格式：'
- en: '[PRE107]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Alternatively, when several records need to be added, you can use the following
    format:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当需要添加多个记录时，可以使用以下格式：
- en: '[PRE109]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The SELECT statement
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SELECT` 语句'
- en: 'The `SELECT` statement has the following format:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 语句具有以下格式：'
- en: '[PRE113]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Alternatively, when all the columns need to be selected, you can use the following
    format:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当需要选择所有列时，可以使用以下格式：
- en: '[PRE115]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'A more general definition of the `WHERE` clause is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句的更一般定义如下：'
- en: '[PRE116]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The construct’s `column_name` operator value can be combined using the `AND`
    and `OR` logical operators, and grouped by brackets, `( )`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 构造的 `column_name` 操作符值可以使用 `AND` 和 `OR` 逻辑运算符组合，并通过括号分组，`( )`。
- en: 'For example, the following method brings all the first name values (separated
    by a whitespace character) from the `person` table:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下方法从 `person` 表中提取所有名字值（由空白字符分隔）：
- en: '[PRE126]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `getString(int position)` method of the `ResultSet` interface extracts
    the `String` value from position `1` (the first in the list of columns in the
    `SELECT` statement). There are similar getters for all primitive types: `getInt(int
    position)`, `getByte(int position)`, and more.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 接口的 `getString(int position)` 方法从位置 `1`（`SELECT` 语句中列列表中的第一个）提取
    `String` 值。对于所有原始类型都有类似的获取器：`getInt(int position)`、`getByte(int position)` 等。'
- en: 'It is also possible to extract the value from the `ResultSet` object using
    the column name. In our case, it will be `getString("first_name")`. This method
    of getting values is especially useful when the `SELECT` statement is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从 `ResultSet` 对象中按列名提取值。在我们的例子中，它将是 `getString("first_name")`。当 `SELECT`
    语句如下时，这种方法获取值特别有用：
- en: '[PRE140]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: However, bear in mind that extracting values from the `ResultSet` object using
    the column name is less efficient. The difference in performance, though, is very
    small and only becomes important when the operation takes place many times. Only
    the actual measuring and testing processes can tell whether the difference is
    significant to your application or not. Extracting values by column name is especially
    attractive because it provides better code readability, which pays off in the
    long run during application maintenance.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，使用列名从 `ResultSet` 对象中提取值效率较低。然而，性能差异非常小，只有在操作多次时才会变得重要。只有实际的测量和测试过程才能告诉你这种差异是否对你的应用程序具有重要意义。通过列名提取值特别吸引人，因为它提供了更好的代码可读性，这在长期的应用程序维护中会带来回报。
- en: There are many other useful methods in the `ResultSet` interface. If your application
    reads data from a database, we highly recommend that you read the official documentation
    ([www.postgresql.org/docs](http://www.postgresql.org/docs)) of the `SELECT` statement
    and the `ResultSet` interface for the database version you are using.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 接口中还有许多其他有用的方法。如果你的应用程序从数据库中读取数据，我们强烈建议你阅读你使用的数据库版本的 `SELECT` 语句和
    `ResultSet` 接口的官方文档 ([www.postgresql.org/docs](http://www.postgresql.org/docs))。'
- en: The UPDATE statement
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`UPDATE` 语句'
- en: 'The data can be changed by the `UPDATE` statement, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以通过 `UPDATE` 语句进行更改，如下所示：
- en: '[PRE141]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can use this statement to change the first name in one of the records from
    the original value, `John`, to a new value, `Jim`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此语句将记录中的一个名字从原始值 `John` 更改为新值 `Jim`：
- en: '[PRE142]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Without the `WHERE` clause, all the records of the table will be affected.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `WHERE` 子句，表中的所有记录都将受到影响。
- en: The DELETE statement
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DELETE` 语句'
- en: 'To remove records from a table, use the `DELETE` statement, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表中删除记录，请使用 `DELETE` 语句，如下所示：
- en: '[PRE143]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Without the `WHERE` clause, all the records of the table are deleted. In the
    case of the `person` table, we can delete all the records using the following
    SQL statement:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `WHERE` 子句，将删除表中的所有记录。在 `person` 表的情况下，我们可以使用以下 SQL 语句来删除所有记录：
- en: '[PRE144]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Additionally, this statement only deletes the records that have a first name
    of `Jim`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此语句仅删除具有 `Jim` 为名字的首个记录：
- en: '[PRE145]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Using statements
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用语句
- en: 'The `java.sql.Statement` interface offers the following methods for executing
    SQL statements:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.sql.Statement` 接口提供了以下方法来执行 SQL 语句：'
- en: '`boolean execute(String sql)`: This returns `true` if the executed statement
    returns data (inside the `java.sql.ResultSet` object) that can be retrieved using
    the `ResultSet getResultSet()` method of the `java.sql.Statement` interface. Alternatively,
    it returns `false` if the executed statement does not return data (for the `INSERT`
    statement or the `UPDATE` statement) and the subsequent call to the `int getUpdateCount()`
    method of the `java.sql.Statement` interface returns the number of affected rows.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean execute(String sql)`：如果执行语句返回数据（在 `java.sql.ResultSet` 对象中），并且可以使用
    `java.sql.Statement` 接口的 `ResultSet getResultSet()` 方法检索，则返回 `true`。否则，如果执行语句不返回数据（对于
    `INSERT` 语句或 `UPDATE` 语句），并且对 `java.sql.Statement` 接口的 `int getUpdateCount()`
    方法的后续调用返回受影响的行数，则返回 `false`。'
- en: '`ResultSet executeQuery(String sql)`: This returns data as a `java.sql.ResultSet`
    object (the SQL statement used with this method is usually a `SELECT` statement).
    The `ResultSet getResultSet()` method of the `java.sql.Statement` interface does
    not return data, while the `int getUpdateCount()` method of the `java.sql.Statement`
    interface returns `-1`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultSet executeQuery(String sql)`：返回数据作为 `java.sql.ResultSet` 对象（与此方法一起使用的
    SQL 语句通常是 `SELECT` 语句）。`java.sql.Statement` 接口的 `ResultSet getResultSet()` 方法不返回数据，而
    `java.sql.Statement` 接口的 `int getUpdateCount()` 方法返回 `-1`。'
- en: '`int executeUpdate(String sql)`: This returns the number of affected rows (the
    executed SQL statement is expected to be the `UPDATE` statement or the `DELETE`
    statement). The same number is returned by the `int getUpdateCount()` method of
    the `java.sql.Statement` interface; the subsequent call to the `ResultSet getResultSet()`
    method of the `java.sql.Statement` interface returns `null`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int executeUpdate(String sql)`：返回受影响的行数（预期的 SQL 语句是 `UPDATE` 语句或 `DELETE`
    语句）。`java.sql.Statement` 接口的 `int getUpdateCount()` 方法返回相同的数字；对 `java.sql.Statement`
    接口的 `ResultSet getResultSet()` 方法的后续调用返回 `null`。'
- en: 'We will demonstrate how these three methods work on each of the statements:
    `INSERT`, `SELECT`, `UPDATE`, and `DELETE`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示这三个方法如何在每个语句上工作：`INSERT`、`SELECT`、`UPDATE` 和 `DELETE`。
- en: The execute(String sql) method
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`execute(String sql)` 方法'
- en: 'Let’s try executing each of the statements; we’ll start with the `INSERT` statement:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试执行每个语句；我们首先从 `INSERT` 语句开始：
- en: '[PRE146]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The preceding code adds a new record to the `person` table. The returned `false`
    value indicates that there is no data returned by the executed statement; this
    is why the `getResultSet()` method returns `null`. But, the `getUpdateCount()`
    method returns `1` because one record was affected (added). The `selectAllFirstNames()`
    method proves that the expected record was inserted.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码向 `person` 表添加了一条新记录。返回的 `false` 值表示执行语句没有返回数据；这就是为什么 `getResultSet()` 方法返回
    `null` 的原因。但是，`getUpdateCount()` 方法返回 `1`，因为影响了一条记录（添加）。`selectAllFirstNames()`
    方法证明了预期的记录已被插入。
- en: 'Now, let’s execute the `SELECT` statement, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行 `SELECT` 语句，如下所示：
- en: '[PRE159]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The preceding code selects all the first names from the `person` table. The
    returned `true` value indicates that there is data returned by the executed statement.
    That is why the `getResultSet()` method does not return `null` but a `ResultSet`
    object instead. The `getUpdateCount()` method returns `-1` because no record was
    affected (changed). Since there was only one record in the `person` table, the
    `ResultSet` object contains only one result, and `rs.getString(1)` returns `Bill`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从 `person` 表中选择所有姓名。返回的 `true` 值表示执行语句返回了数据。这就是为什么 `getResultSet()` 方法不返回
    `null`，而是返回一个 `ResultSet` 对象。`getUpdateCount()` 方法返回 `-1`，因为没有记录受到影响（更改）。由于 `person`
    表中只有一个记录，`ResultSet` 对象只包含一个结果，`rs.getString(1)` 返回 `Bill`。
- en: 'The following code uses the `UPDATE` statement to change the first name in
    all the records of the `person` table to `Adam`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `UPDATE` 语句将 `person` 表中所有记录的姓名更改为 `Adam`：
- en: '[PRE173]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: In the preceding code, the returned `false` value indicates that there is no
    data returned by the executed statement. This is why the `getResultSet()` method
    returns `null`. But, the `getUpdateCount()` method returns `1` because one record
    was affected (changed) since there was only one record in the `person` table.
    The `selectAllFirstNames()` method proves that the expected change was made to
    the record.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，返回的 `false` 值表示执行语句没有返回数据。这就是为什么 `getResultSet()` 方法返回 `null` 的原因。但是，`getUpdateCount()`
    方法返回 `1`，因为影响了一条记录（更改），由于 `person` 表中只有一个记录。`selectAllFirstNames()` 方法证明了预期的更改已应用于记录。
- en: 'The following `DELETE` statement execution deletes all records from the `person`
    table:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `DELETE` 语句执行删除了 `person` 表中的所有记录：
- en: '[PRE184]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: In the preceding code, the returned `false` value indicates that there is no
    data returned by the executed statement. That is why the `getResultSet()` method
    returns `null`. But, the `getUpdateCount()` method returns `1` because one record
    was affected (deleted) since there was only one record in the `person` table.
    The `selectAllFirstNames()` method proves that there are no records in the `person`
    table.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，返回的 `false` 值表明执行语句没有返回数据。这就是为什么 `getResultSet()` 方法返回 `null` 的原因。但是，`getUpdateCount()`
    方法返回 `1`，因为只有一个记录受到影响（被删除），因为 `person` 表中只有一个记录。`selectAllFirstNames()` 方法证明了
    `person` 表中没有记录。
- en: The executeQuery(String sql) method
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`executeQuery(String sql)` 方法'
- en: 'In this section, we will try to execute the same statements (as a query) that
    we used when demonstrating the `execute()` method in the *The execute(String sql)
    method* section. We’ll start with the `INSERT` statement, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试执行与在 *The execute(String sql) method* 部分中演示 `execute()` 方法时使用的相同语句（作为一个查询）。我们将从以下
    `INSERT` 语句开始：
- en: '[PRE195]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The preceding code generates an exception with the `No results were returned
    by the query` message because the `executeQuery()` method expects to execute the
    `SELECT` statement. Nevertheless, the `selectAllFirstNames()` method proves that
    the expected record was inserted.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码由于查询没有返回结果而抛出异常，因为 `executeQuery()` 方法期望执行 `SELECT` 语句。尽管如此，`selectAllFirstNames()`
    方法证明了预期的记录已被插入。
- en: 'Now, let’s execute the `SELECT` statement, as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行以下 `SELECT` 语句：
- en: '[PRE205]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: The preceding code selects all the first names from the `person` table. The
    returned `false` value indicates that `executeQuery()` always returns the `ResultSet`
    object, even when no record exists in the `person` table. As you can see, there
    appear to be two ways of getting a result from the executed statement. However,
    the `rs2` object has no data, so, while using the `executeQuery()` method, make
    sure that you get the data from the `ResultSet` object.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从 `person` 表中选择所有名字。返回的 `false` 值表明 `executeQuery()` 总是返回 `ResultSet` 对象，即使
    `person` 表中没有记录。如您所见，似乎有两种从执行语句获取结果的方法。然而，`rs2` 对象没有数据，所以在使用 `executeQuery()`
    方法时，请确保您从 `ResultSet` 对象中获取数据。
- en: 'Now, let’s try to execute an `UPDATE` statement, as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试执行以下 `UPDATE` 语句：
- en: '[PRE222]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The preceding code generates an exception with the `No results were returned
    by the query` message because the `executeQuery()` method expects to execute the
    `SELECT` statement. Nevertheless, the `selectAllFirstNames()` method proves that
    the expected change was made to the record.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码由于查询没有返回结果而抛出异常，因为 `executeQuery()` 方法期望执行 `SELECT` 语句。尽管如此，`selectAllFirstNames()`
    方法证明了预期的更改已应用于记录。
- en: 'We are going to get the same exception while executing the `DELETE` statement:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `DELETE` 语句时，我们将遇到相同的异常：
- en: '[PRE230]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Nevertheless, the `selectAllFirstNames()` method proves that all the records
    of the `person` table were deleted.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`selectAllFirstNames()` 方法证明了 `person` 表中的所有记录都被删除了。
- en: Our demonstration shows that `executeQuery()` should be used for `SELECT` statements
    only. The advantage of the `executeQuery()` method is that, when used for `SELECT`
    statements, it returns a not-null `ResultSet` object even when there is no data
    selected, which simplifies the code since there is no need to check the returned
    value for `null`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示表明，`executeQuery()` 应仅用于 `SELECT` 语句。`executeQuery()` 方法的优点是，当用于 `SELECT`
    语句时，即使没有选择数据，它也会返回一个非空的 `ResultSet` 对象，这简化了代码，因为不需要检查返回值是否为 `null`。
- en: The executeUpdate(String sql) method
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`executeUpdate(String sql)` 方法'
- en: 'We’ll start demonstrating the `executeUpdate()` method with the `INSERT` statement:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 `INSERT` 语句来演示 `executeUpdate()` 方法：
- en: '[PRE238]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: As you can see, the `executeUpdate()` method returns the number of affected
    (inserted, in this case) rows. The same number returns the `int getUpdateCount()`
    method, while the `ResultSet getResultSet()` method returns `null`. The `selectAllFirstNames()`
    method proves that the expected record was inserted.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`executeUpdate()` 方法返回受影响的（在本例中为插入的）行数。相同的数字由 `int getUpdateCount()` 方法返回，而
    `ResultSet getResultSet()` 方法返回 `null`。`selectAllFirstNames()` 方法证明了预期的记录已被插入。
- en: 'The `executeUpdate()` method can’t be used for executing the `SELECT` statement:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeUpdate()` 方法不能用于执行 `SELECT` 语句：'
- en: '[PRE250]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: The message of the exception is `A result was returned when none was expected`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 异常信息为 `A result was returned when none was expected`。
- en: 'The `UPDATE` statement, on the other hand, is executed by the `executeUpdate()`
    method just fine:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`UPDATE` 语句可以通过 `executeUpdate()` 方法正常执行：
- en: '[PRE257]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: The `executeUpdate()` method returns the number of affected (updated, in this
    case) rows. The same number returns the `int getUpdateCount()` method, while the
    `ResultSet getResultSet()` method returns `null`. The `selectAllFirstNames()`
    method proves that the expected record was updated.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeUpdate()` 方法返回受影响的（在这种情况下是更新）行数。相同的数字由 `int getUpdateCount()` 方法返回，而
    `ResultSet getResultSet()` 方法返回 `null`。`selectAllFirstNames()` 方法证明了预期的记录已被更新。'
- en: 'The `DELETE` statement produces similar results:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 语句产生类似的结果：'
- en: '[PRE267]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: By now, you have probably realized that the `executeUpdate()` method is better
    suited for `INSERT`, `UPDATE`, and `DELETE` statements.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经意识到 `executeUpdate()` 方法更适合 `INSERT`、`UPDATE` 和 `DELETE` 语句。
- en: Using PreparedStatement
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PreparedStatement
- en: '`PreparedStatement` is a subinterface of the `Statement` interface. This means
    that it can be used anywhere that the `Statement` interface is used. The advantage
    of `PreparedStatement` is that it is cached in the database instead of being compiled
    every time it is invoked. This way, it is efficiently executed multiple times
    for different input values. It can be created by the `prepareStatement()` method
    using the same `Connection` object.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement` 是 `Statement` 接口的一个子接口。这意味着它可以在任何使用 `Statement` 接口的地方使用。`PreparedStatement`
    的优点是它在数据库中缓存，而不是每次调用时都编译。这样，它可以针对不同的输入值高效地执行多次。可以通过使用相同的 `Connection` 对象的 `prepareStatement()`
    方法来创建它。'
- en: 'Since the same SQL statement can be used for creating `Statement` and `PreparedStatement`,
    it is a good idea to use `PreparedStatement` for any SQL statement that is called
    multiple times because it performs better than the `Statement` interface on the
    database side. To do this, all we need to change are these two lines from the
    preceding code example:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 由于相同的 SQL 语句可以用于创建 `Statement` 和 `PreparedStatement`，因此对于任何多次调用的 SQL 语句使用 `PreparedStatement`
    是一个好主意，因为它在数据库端的表现优于 `Statement` 接口。为此，我们只需要更改前面代码示例中的这两行：
- en: '[PRE277]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Instead, we can use the `PreparedStatement` class, as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用 `PreparedStatement` 类，如下所示：
- en: '[PRE279]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'To create the `PreparedStatement` object with parameters, you can substitute
    the input values with the question mark symbol (`?`); for example, we can create
    the following method (see the `Person` class in the `database` project):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用参数创建 `PreparedStatement` 对象，可以将输入值替换为问号符号（`?`）；例如，我们可以创建以下方法（参见 `database`
    项目中的 `Person` 类）：
- en: '[PRE281]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: When it is used the first time, the database compiles the `PreparedStatement`
    object as a template and stores it. Then, when it is later used by the application
    again, the parameter value is passed to the template, and the statement is executed
    immediately without the overhead of compilation since it has been done already.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当它第一次使用时，数据库将 `PreparedStatement` 对象编译为模板并存储它。然后，当它稍后被应用程序再次使用时，参数值被传递到模板，并且由于已经编译过，因此无需编译开销即可立即执行语句。
- en: Another advantage of a prepared statement is that it is better protected from
    a SQL injection attack because values are passed in using a different protocol
    and the template is not based on the external input.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句的另一个优点是它更好地保护免受 SQL 注入攻击，因为值是通过不同的协议传递的，并且模板不是基于外部输入的。
- en: If a prepared statement is used only once, it may be slower than a regular statement,
    but the difference may be negligible. If in doubt, test the performance and see
    whether it is acceptable for your application – the increased security could be
    worth it.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预处理语句只使用一次，它可能比常规语句慢，但差异可能微不足道。如果有疑问，测试性能并查看它是否适合你的应用程序——提高的安全性可能是值得的。
- en: Using CallableStatement
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CallableStatement
- en: 'The `CallableStatement` interface (which extends the `PreparedStatement` interface)
    can be used to execute a stored procedure, although some databases allow you to
    call a stored procedure using either a `Statement` or `PreparedStatement` interface.
    A `CallableStatement` object is created by the `prepareCall()` method and can
    have parameters of three types:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallableStatement` 接口（它扩展了 `PreparedStatement` 接口）可以用来执行存储过程，尽管一些数据库允许你使用
    `Statement` 或 `PreparedStatement` 接口来调用存储过程。`CallableStatement` 对象是通过 `prepareCall()`
    方法创建的，并且可以有三个类型的参数：'
- en: '`IN` for an input value'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN` 用于输入值'
- en: '`OUT` for the result'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OUT` 用于结果'
- en: '`IN OUT` for either an input or an output value'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN OUT`用于输入或输出值'
- en: The `IN` parameter can be set the same way as the parameters of `PreparedStatement`,
    while the `OUT` parameter must be registered by the `registerOutParameter()` method
    of `CallableStatement`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`IN`参数可以像`PreparedStatement`的参数一样设置，而`OUT`参数必须通过`CallableStatement`的`registerOutParameter()`方法进行注册。'
- en: It is worth noting that executing a stored procedure from Java programmatically
    is one of the least standardized areas. PostgreSQL, for example, does not support
    stored procedures directly, but they can be invoked as functions that have been
    modified for this purpose by interpreting the `OUT` parameters as return values.
    Oracle, on the other hand, allows the `OUT` parameters as functions too.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，从Java程序中执行存储过程是标准化程度最低的领域之一。例如，PostgreSQL不支持存储过程，但它们可以作为已经为此目的修改过的函数来调用，将`OUT`参数解释为返回值。另一方面，Oracle允许将`OUT`参数作为函数使用。
- en: 'This is why the following differences between database functions and stored
    procedures can serve only as general guidelines and not as formal definitions:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么数据库函数和存储过程之间的以下差异只能作为一般性指南，而不能作为正式定义：
- en: A function has a return value, but it does not allow `OUT` parameters (except
    for some databases) and can be used in a SQL statement.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数有一个返回值，但它不允许`OUT`参数（除了某些数据库）并且可以在SQL语句中使用。
- en: A stored procedure does not have a return value (except for some databases);
    it allows `OUT` parameters (for most databases) and can be executed using the
    JDBC `CallableStatement` interface.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储过程没有返回值（除了某些数据库）；它允许`OUT`参数（对于大多数数据库）并且可以使用JDBC的`CallableStatement`接口执行。
- en: You can refer to the database documentation to learn how to execute a stored
    procedure.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考数据库文档来了解如何执行存储过程。
- en: 'Since stored procedures are compiled and stored on the database server, the
    `execute()` method of `CallableStatement` performs better for the same SQL statement
    than the corresponding method of the `Statement` or `PreparedStatement` interface.
    This is one of the reasons why a lot of Java code is sometimes replaced by one
    or several stored procedures that even include business logic. However, there
    is no one right answer for every case and problem, so we will refrain from making
    specific recommendations, except to repeat the familiar mantra about the value
    of testing and the clarity of the code you are writing:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储过程是在数据库服务器上编译和存储的，因此`CallableStatement`的`execute()`方法对于相同的SQL语句比`Statement`或`PreparedStatement`接口的相应方法性能更好。这就是为什么很多Java代码有时被一个或多个包含业务逻辑的存储过程所取代的原因之一。然而，对于每一个案例和问题都没有一个正确的答案，所以我们不会提出具体的建议，除了重复熟悉的咒语关于测试的价值和您所编写的代码的清晰性：
- en: '[PRE301]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'Now, we can call this method, as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式调用此方法：
- en: '[PRE317]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: A stored procedure can be without any parameters at all, with `IN` parameters
    only, with `OUT` parameters only, or with both. The result may be one or multiple
    values, or a `ResultSet` object. You can find the syntax of the SQL for function
    creation in your database documentation.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程可以没有任何参数，只有`IN`参数，只有`OUT`参数，或者两者都有。结果可能是一个或多个值，或者一个`ResultSet`对象。您可以在数据库文档中找到创建函数的SQL语法的语法。
- en: Using a shared library JAR file to access a database
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用共享库JAR文件访问数据库
- en: In fact, we have already started using the `database` project JAR file to access
    the database driver, set as a dependency in the `pom.xml` file of the `database`
    project. Now, we are going to demonstrate how to use a JAR file of the `database`
    project JAR file to manipulate data in the database. An example of such usage
    is presented in the `UseDatabaseJar` class.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们已经开始使用`database`项目的JAR文件来访问数据库驱动程序，将其设置为`database`项目的`pom.xml`文件中的依赖项。现在，我们将演示如何使用`database`项目JAR文件来操作数据库中的数据。这种使用的示例在`UseDatabaseJar`类中给出。
- en: 'To support CRUD operations, a database table often represents a class of objects.
    Each row of such a table contains properties of one object of a class. In the
    *Creating a database structure* section, we demonstrated an example of such mapping
    between the `Person` class and the `person` table. To illustrate how to use a
    JAR file for data manipulation, we have created a separate `database` project
    that has only one `Person` class. In addition to the properties shown in the *Creating
    a database structure* section, it has static methods for all CRUD operations.
    The following is the `insert()` method:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持CRUD操作，数据库表通常代表一个对象类。此类表中的每一行都包含一个对象的一个类的属性。在*创建数据库结构*部分，我们展示了`Person`类和`person`表之间此类映射的示例。为了说明如何使用JAR文件进行数据操作，我们创建了一个单独的`database`项目，该项目只有一个`Person`类。除了*创建数据库结构*部分中显示的属性外，它还包含所有CRUD操作的静态方法。以下是对`insert()`方法的实现：
- en: '[PRE320]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'The following is the `selectByFirstName()` method:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`selectByFirstName()`方法的实现：
- en: '[PRE333]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'The following is the `updateFirstNameById()` method:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`updateFirstNameById()`方法的实现：
- en: '[PRE352]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'The following is the `deleteById()` method:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`deleteById()`方法的实现：
- en: '[PRE364]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: As you can see, all the preceding methods accept the `Connection` object as
    a parameter, instead of creating and destroying it inside each method. We decided
    to do it like so because it allows several operations to associate with each `Connection`
    object in case we would like them to be committed to the database together or
    to be rolled back if one of them fails (read about transaction management in the
    documentation of the database of your choice). Besides, the JAR file (generated
    by the `database` project) can be used by different applications, so database
    connection parameters are going to be application-specific, and that is why the
    `Connection` object has to be created in the application that uses the JAR file.
    The following code demonstrates such a usage (see the `UseDatabaseJar` class).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有前面的方法都接受`Connection`对象作为参数，而不是在每个方法内部创建和销毁它。我们决定这样做是因为它允许多个操作与每个`Connection`对象相关联，以防我们希望它们一起提交到数据库或如果其中一个失败则回滚（请参阅您选择的数据库文档中的事务管理部分）。此外，由`database`项目生成的JAR文件可以被不同的应用程序使用，因此数据库连接参数将是特定于应用程序的，这就是为什么`Connection`对象必须创建在使用JAR文件的应用程序中。以下代码演示了这种用法（请参阅`UseDatabaseJar`类）。
- en: 'Make sure you have executed the `mvn clean install` command in the `database`
    folder before running the following examples:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行以下示例之前，请确保您已在`database`文件夹中执行了`mvn clean install`命令。
- en: '[PRE374]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: Let’s walk through the preceding code snippet. Lines `1` and `26` to `28` compose
    the `try–catch` block that disposes of the `Connection` object and catches all
    the exceptions that may happen inside this block during its execution.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析前面的代码片段。第`1`行和第`26`至`28`行构成了处理`Connection`对象并捕获在此块执行过程中可能发生的所有异常的`try–catch`块。
- en: 'Line `2` was included just to clean up the data from the `person` table before
    running the demo code. The following is the implementation of the `cleanTablePerson()`
    method:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 第`2`行只是为了在运行演示代码之前清理`person`表中的数据。以下是对`cleanTablePerson()`方法的实现：
- en: '[PRE412]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: In lines `3`, `4`, and `5`, we create three objects of the `Person` class, then
    in lines `6`, `7`, and `8`, we use them to insert records in the `person` table.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`3`、`4`和`5`行，我们创建了三个`Person`类的对象，然后在第`6`、`7`和`8`行，我们使用它们在`person`表中插入记录。
- en: In line `9`, we query the database for a record that has the first name taken
    from the `jill` object, and in line `10`, we print out the result count, which
    is `0` (because we did not insert such a record).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`9`行，我们查询数据库以获取一个来自`jill`对象的首个名字的记录，在第`10`行，我们打印出结果计数，该计数为`0`（因为我们没有插入这样的记录）。
- en: In line `11`, we query the database for a record that has the first name set
    to `Jane`, and in line `12`, we print out the result count, which is `2` (because
    we did insert two records with such a value).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`11`行，我们查询数据库以获取一个首个名字设置为`Jane`的记录，在第`12`行，我们打印出结果计数，该计数为`2`（因为我们确实插入了两个具有此值的记录）。
- en: In line `13`, we extract the first of the two objects returned by the previous
    query, and in line `14`, we update the corresponding record with a different value
    for the first name (taken from the `jill` object).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`13`行，我们提取前一个查询返回的两个对象中的第一个，在第`14`行，我们使用来自`jill`对象的不同值更新相应的记录的首个名字。
- en: In line `15`, we repeat the query for a record with the first name set to `Jane`,
    and in line `16`, we print out the result count, which is `1` this time (as expected,
    because we have changed the first name to `Jill` on one of the two records).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`15`行，我们重复查询名字设置为`Jane`的记录，在第`16`行，我们打印出结果计数，这次是`1`（正如预期的那样，因为我们已经将其中一个记录的名字从`Jane`改为了`Jill`）。
- en: In line `17`, we select all the records with the first name set to `Jill`, and
    in line `18`, we print out the result count, which is `1` this time (as expected,
    because we have changed the first name to `Jill` on one of the two records that
    used to have the first name value `Jane`).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`17`行，我们选择所有名字设置为`Jill`的记录，在第`18`行，我们打印出结果计数，这次是`1`（正如预期的那样，因为我们已经将其中一个原本名字为`Jane`的记录的名字改为了`Jill`）。
- en: In line `19`, we select all the records with the name set to `Mike`, and in
    line `20`, we print out the result count, which is `1` (as expected, because we
    have created only one such record).
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`19`行，我们选择所有名字设置为`Mike`的记录，在第`20`行，我们打印出结果计数，这次是`1`（正如预期的那样，因为我们只创建了一个这样的记录）。
- en: In lines `21` to `23`, we delete all the retrieved records in a loop.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`21`到`23`行，我们在循环中删除所有检索到的记录。
- en: That is why when we select all the records with the first name `Mike` in line
    `24` again, we get a result count equal to `0` in line `25` (as expected, because
    there is no such record anymore).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们再次在第`24`行选择名字为`Mike`的所有记录时，在第`25`行我们得到的结果计数为`0`（正如预期的那样，因为已经没有这样的记录了）。
- en: At this point, when this code snippet is executed and the `main()` method of
    the `UseDatabseJar` class is completed, all the changes in the database are saved
    automatically.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，当这段代码片段执行完毕，并且`UseDatabseJar`类的`main()`方法完成后，数据库中的所有更改都会自动保存。
- en: That is how a JAR file (which allows modifying data in a database) can be used
    by any application that has this file as a dependency.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JAR文件（允许修改数据库中的数据）可以被任何将其作为依赖项的应用程序使用的原理。
- en: Summary
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed and demonstrated how the data in a database can
    be populated, read, updated, and deleted from a Java application. A short introduction
    to the SQL language described how to create a database and its structure, how
    to modify it, and how to execute SQL statements, using `Statement`, `PreparedStatement`,
    and `CallableStatement`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论并演示了如何在Java应用程序中填充、读取、更新和删除数据库中的数据。对SQL语言的简要介绍说明了如何创建数据库及其结构，如何修改它，以及如何使用`Statement`、`PreparedStatement`和`CallableStatement`执行SQL语句。
- en: Now, you can create and use a database for storing, updating, and retrieving
    data, and create and use a shared library.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建和使用数据库来存储、更新和检索数据，以及创建和使用共享库。
- en: In the next chapter, we will describe and discuss the most popular network protocols,
    demonstrate how to use them, and how to implement client-server communication
    using the latest Java HTTP Client API. The protocols reviewed include the Java
    implementation of a communication protocol based on TCP, UDP, and URLs.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述和讨论最流行的网络协议，演示如何使用它们，以及如何使用最新的Java HTTP客户端API实现客户端-服务器通信。所审查的协议包括基于TCP、UDP和URL的通信协议的Java实现。
- en: Quiz
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: 'Select all the correct statements:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的语句：
- en: JDBC stands for Java Database Communication.
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JDBC代表Java数据库通信。
- en: The JDBC API includes the `java.db` package.
  id: totrans-616
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JDBC API包括`java.db`包。
- en: The JDBC API comes with Java installation.
  id: totrans-617
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JDBC API与Java安装一起提供。
- en: The JDBC API includes the drivers for all major DBMSs.
  id: totrans-618
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JDBC API包括了所有主要数据库管理系统（DBMS）的驱动程序。
- en: 'Select all the correct statements:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的语句：
- en: A database table can be created using the `CREATE` statement.
  id: totrans-620
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`CREATE`语句创建数据库表。
- en: A database table can be changed using the `UPDATE` statement.
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`UPDATE`语句更改数据库表。
- en: A database table can be removed using the `DELETE` statement.
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`DELETE`语句删除数据库表。
- en: Each database column can have an index.
  id: totrans-623
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个数据库列都可以有一个索引。
- en: 'Select all the correct statements:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的语句：
- en: To connect to a database, you can use the `Connect` class.
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接到数据库，你可以使用`Connect`类。
- en: Every database connection must be closed.
  id: totrans-626
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个数据库连接都必须关闭。
- en: The same database connection may be used for many operations.
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一个数据库连接可以用于许多操作。
- en: Database connections can be pooled.
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库连接可以被池化。
- en: 'Select all the correct statements:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的语句：
- en: A database connection can be closed automatically using the `try-with-resources`
    construct.
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`try-with-resources`构造自动关闭数据库连接。
- en: A database connection can be closed using the `finally` block construct.
  id: totrans-631
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `finally` 块结构关闭数据库连接。
- en: A database connection can be closed using the `catch` block.
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `catch` 块关闭数据库连接。
- en: A database connection can be closed without a `try` block.
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在不使用 `try` 块的情况下关闭数据库连接。
- en: 'Select all the correct statements:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的说法：
- en: The `INSERT` statement includes a table name.
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`INSERT` 语句包含一个表名。'
- en: The `INSERT` statement includes column names.
  id: totrans-636
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`INSERT` 语句包含列名。'
- en: The `INSERT` statement includes values.
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`INSERT` 语句包含值。'
- en: The `INSERT` statement includes constraints.
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`INSERT` 语句包含约束。'
- en: 'Select all the correct statements:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的说法：
- en: The `SELECT` statement must include a table name.
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SELECT` 语句必须包含一个表名。'
- en: The `SELECT` statement must include a column name.
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SELECT` 语句必须包含一个列名。'
- en: The `SELECT` statement must include the `WHERE` clause.
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SELECT` 语句必须包含 `WHERE` 子句。'
- en: The `SELECT` statement may include the `ORDER` clause.
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SELECT` 语句可能包含 `ORDER` 子句。'
- en: 'Select all the correct statements:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的说法：
- en: The `UPDATE` statement must include a table name.
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UPDATE` 语句必须包含一个表名。'
- en: The `UPDATE` statement must include a column name.
  id: totrans-646
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UPDATE` 语句必须包含一个列名。'
- en: The `UPDATE` statement may include the `WHERE` clause.
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UPDATE` 语句可能包含 `WHERE` 子句。'
- en: The `UPDATE` statement may include the `ORDER` clause.
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UPDATE` 语句可能包含 `ORDER` 子句。'
- en: 'Select all the correct statements:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的说法：
- en: The `DELETE` statement must include a table name.
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DELETE` 语句必须包含一个表名。'
- en: The `DELETE` statement must include a column name.
  id: totrans-651
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DELETE` 语句必须包含一个列名。'
- en: The `DELETE` statement may include the `WHERE` clause.
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DELETE` 语句可能包含 `WHERE` 子句。'
- en: The `DELETE` statement may include the `ORDER` clause.
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DELETE` 语句可能包含 `ORDER` 子句。'
- en: 'Select all the correct statements about the `execute()` method of the `Statement`
    interface:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择关于 `Statement` 接口的 `execute()` 方法的正确说法：
- en: It receives a SQL statement.
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接收一个 SQL 语句。
- en: It returns a `ResultSet` object.
  id: totrans-656
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回一个 `ResultSet` 对象。
- en: The `Statement` object may return data after `execute()` is called.
  id: totrans-657
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `execute()` 后，`Statement` 对象可能返回数据。
- en: The `Statement` object may return the number of affected records after `execute()`
    is called.
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `execute()` 后，`Statement` 对象可能返回受影响记录的数量。
- en: 'Select all the correct statements about the `executeQuery()` method of the
    `Statement` interface:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择关于 `Statement` 接口的 `executeQuery()` 方法的正确说法：
- en: It receives a SQL statement.
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接收一个 SQL 语句。
- en: It returns a `ResultSet` object.
  id: totrans-661
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回一个 `ResultSet` 对象。
- en: The `Statement` object may return data after `executeQuery()` is called.
  id: totrans-662
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `executeQuery()` 后，`Statement` 对象可能返回数据。
- en: The `Statement` object may return the number of affected records after `executeQuery()`
    is called.
  id: totrans-663
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `executeQuery()` 后，`Statement` 对象可能返回受影响记录的数量。
- en: 'Select all the correct statements about the `executeUpdate()` method of the
    `Statement` interface:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择关于 `Statement` 接口的 `executeUpdate()` 方法的正确说法：
- en: It receives a SQL statement.
  id: totrans-665
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接收一个 SQL 语句。
- en: It returns a `ResultSet` object.
  id: totrans-666
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回一个 `ResultSet` 对象。
- en: The `Statement` object may return data after `executeUpdate()` is called.
  id: totrans-667
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `executeUpdate()` 后，`Statement` 对象可能返回数据。
- en: The `Statement` object returns the number of affected records after `executeUpdate()`
    is called.
  id: totrans-668
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `executeUpdate()` 后，`Statement` 对象返回受影响记录的数量。
- en: 'Select all the correct statements about the `PreparedStatement` interface:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择关于 `PreparedStatement` 接口的正确说法：
- en: It extends `Statement`.
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它扩展了 `Statement`。
- en: An object of type `PreparedStatement` is created by the `prepareStatement()`
    method.
  id: totrans-671
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `prepareStatement()` 方法创建 `PreparedStatement` 类型的对象。
- en: It is always more efficient than `Statement`.
  id: totrans-672
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它总是比 `Statement` 更高效。
- en: It results in a template in the database being created only once.
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它导致数据库中只创建一次模板。
- en: 'Select all the correct statements about the `CallableStatement` interface:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择关于 `CallableStatement` 接口的正确说法：
- en: It extends `PreparedStatement`.
  id: totrans-675
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它扩展了 `PreparedStatement`。
- en: An object of type `CallableStatement` is created by the `prepareCall()` method.
  id: totrans-676
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `prepareCall()` 方法创建 `CallableStatement` 类型的对象。
- en: It is always more efficient than `PreparedStatement`.
  id: totrans-677
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它总是比 `PreparedStatement` 更高效。
- en: It results in a template in the database being created only once.
  id: totrans-678
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它导致数据库中只创建一次模板。
