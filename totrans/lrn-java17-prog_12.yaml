- en: '*Chapter 10*: Managing Data in a Database'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains and demonstrates how to manage – that is, insert, read,
    update, and delete – data in a database using a Java application. It also provides
    a short introduction to **Structured Query Language** (**SQL**) and basic database
    operations, including how to connect to a database, how to create a database structure,
    how to write a database expression using SQL, and how to execute these expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a database structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create, read, update, and delete** (**CRUD**) operations on data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a shared library JAR file to access a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to create and use a database for
    storing, updating, and retrieving data as well as create and use a shared library.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with either a Microsoft Windows, Apple macOS, or Linux operating
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor you prefer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015)*,* *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on GitHub
    ([https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git))
    in the `examples/src/main/java/com/packt/learnjava/ch10_database` folder, and
    in the `database` folder, as a separate project of the shared library.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`java.sql`, `javax.sql`, and `java.transaction.xa` packages) and the database-specific
    class that implements an interface for database access (called a **database driver**),
    which is provided by each database vendor.'
  prefs: []
  type: TYPE_NORMAL
- en: Using JDBC means writing Java code that manages data in a database using the
    interfaces and classes of the JDBC API and a database-specific driver, which knows
    how to establish a connection with the particular database. Using this connection,
    an application can then issue requests written in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, we are only referring to the databases that understand SQL here.
    They are called relational or tabular **database management systems** (**DBMSs**)
    and make up the vast majority of the currently used DBMSs – although some alternatives
    (for example, a navigational database and NoSQL) are used too.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.sql` and `javax.sql` packages are included in the `javax.sql` package
    contains the `DataSource` interface that supports the statement’s pooling, distributed
    transactions, and rowsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a database involves the following eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the database by following the vendor instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the PL/SQL terminal and create a database user, a database, a schema, tables,
    views, stored procedures, and anything else that is necessary to support the data
    model of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to this application the dependency on a `.jar` file with the database-specific
    driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the database from the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the SQL statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the SQL statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the result of the execution as your application requires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release (that is, close) the database connection and any other resources that
    were opened in the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Steps 1* to *3* are performed only once during the database setup and before
    the application is run. *Steps 4* to *8* are performed by the application repeatedly
    as needed. In fact, *Steps 5* to *7* can be repeated multiple times with the same
    database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we are going to use the PostgreSQL database. You will first
    need to perform *Steps 1* to *3* by yourself using the database-specific instructions.
    To create the database for our demonstration, we use the following PL/SQL commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These commands create a `student` user that can manage all aspects of the `SUPERUSER`
    database, and make the `student` user an owner of the `learnjava` database. We
    will use the `student` user to access and manage data from the Java code. In practice,
    for security considerations, an application is not allowed to create or change
    database tables and other aspects of the database structure.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is a good practice to create another logical layer, called
    a **schema**, which can have its own set of users and permissions. This way, several
    schemas in the same database can be isolated, and each user (one of them is your
    application) can only access certain schemas. On an enterprise level, the common
    practice is to create synonyms for the database schema so that no application
    can access the original structure directly. However, we do not do this in this
    book for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the database is created, the following three SQL statements will allow
    you to create and change the database structure. This is done through database
    entities, such as a table, function, or constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CREATE` statement creates the database entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ALTER` statement changes the database entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DROP` statement deletes the database entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also various SQL statements that allow you to inquire about each database
    entity. Such statements are database-specific and, typically, they are only used
    in a database console. For example, in the PostgreSQL console, `\d <table>` can
    be used to describe a table, while `\dt` lists all the tables. Refer to your database
    documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a table, you can execute the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The limitations for a table name, column names, and types of values that can
    be used depend on the particular database. Here is an example of a command that
    creates the `person` table in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SERIAL` keyword indicates that this field is a sequential integer number
    that is generated by the database every time a new record is created. Additional
    options for generating sequential integers are `SMALLSERIAL` and `BIGSERIAL`;
    they differ by size and the range of possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `PRIMARY_KEY` keyword indicates that this is going to be the unique identifier
    of the record and will most probably be used in a search. The database creates
    an index for each primary key to make the search process faster. An index is a
    data structure that helps to accelerate data search in the table without having
    to check every table record. An index can include one or more columns of a table.
    If you request the description of the table, you will see all the existing indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can make a composite `PRIMARY KEY` keyword using a combination
    of `first_name`, `last_name`, and `dob`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, there is a chance that there are two people who will have the same
    name and were born on the same day, so such a composite prim is not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NOT NULL` keyword imposes a constraint on the field: it cannot be empty.
    The database will raise an error for every attempt to create a new record with
    an empty field or delete the value from the existing record. We did not set the
    size of the columns of type `VARCHAR`, thus allowing these columns to store string
    values of any length.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java object that matches such a record may be represented by the following
    `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed, there are two constructors in the `Person` class:
    with and without `id`. We will use the constructor that accepts `id` to construct
    an object based on the existing record, while the other constructor will be used
    to create an object before inserting a new record.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, the table can be deleted using the `DROP` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The existing table can also be changed using the `ALTER` SQL command; for example,
    we can add a column address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not sure whether such a column exists already, you can add `IF EXISTS`
    or `IF NOT EXISTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, this possibility exists only with PostgreSQL 9.6 and later versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important consideration to take note of during database table creation
    is whether another index (in addition to `PRIMARY KEY`) has to be added. For example,
    we can allow a case-insensitive search of first and last names by adding the following
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the search speed improves, we leave the index in place; if not, it can be
    removed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We remove it because an index has an overhead of additional writes and storage
    space.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also can remove a column from a table if we need to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In our examples, we follow the naming convention of PostgreSQL. If you use a
    different database, we suggest that you look up its naming convention and follow
    it, so that the names you create align with those that are created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used a console to execute SQL statements. The same statements
    can be executed from Java code using the JDBC API too. But, tables are created
    only once, so there is not much sense in writing a program for a one-time execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data management, however, is another matter. So, from now on, we will use Java
    code to manipulate data in a database. In order to do this, we first need to add
    the following dependency to the `pom.xml` file in the `database` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `example` project also gets access to this dependency because, in the `pom.xml`
    file of the `example` project, we have the following dependency on the database
    `.jar` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to install the `database` project by executing the `"mvn clean install"`
    command in the `database` folder before running any of the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a database connection from the Java code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is just an example of how to create a connection using the
    `java.sql.DriverManger` class. The `prop.put( "password", "secretPass123" )` statement
    demonstrates how to provide a password for the connection using the `java.util.Properties`
    class. However, we did not set a password when we created the `student` user,
    so we do not need it.
  prefs: []
  type: TYPE_NORMAL
- en: Many other values can be passed to `DriverManager` that configure the connection
    behavior. The name of the keys for the passed-in properties are the same for all
    major databases, but some of them are database-specific. So, read your database
    vendor documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, for passing `user` and `password` only, we could use an overloaded
    `DriverManager.getConnection(String url, String user, String password)` version.
    It is a good practice to keep the password encrypted. We are not going to demonstrate
    how to do it, but there are plenty of guides available on the internet that you
    can refer to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of connecting to a database is to use the `javax.sql.DataSource`
    interface. Its implementation is included in the same `.jar` file as the database
    driver. In the case of `PostgreSQL`, there are two classes that implement the
    `DataSource` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.postgresql.ds.PGSimpleDataSource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.postgresql.ds.PGConnectionPoolDataSource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use these classes instead of `DriverManager`. The following code is
    an example of creating a database connection using the `PGSimpleDataSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `PGConnectionPoolDataSource` class allows you to create a pool of
    `Connection` objects in memory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This is a preferred method because creating a `Connection` object takes time.
    Pooling allows you to do it upfront and then reuse the created objects when they
    are needed. After the connection is no longer required, it can be returned to
    the pool and reused. The pool size and other parameters can be set in a configuration
    file (such as `postgresql.conf` for PostgreSQL).
  prefs: []
  type: TYPE_NORMAL
- en: However, you do not need to manage the connection pool yourself. There are several
    mature frameworks that can do it for you, such as HikariCP ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)),
    Vibur ([http://www.vibur.org](http://www.vibur.org)), and Commons DBCP ([https://commons.apache.org/proper/commons-dbcp](https://commons.apache.org/proper/commons-dbcp))
    – these are reliable and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever method of creating a database connection we choose, we are going to
    hide it inside the `getConnection()` method and use it in all our code examples
    in the same way. With the object of the `Connection` class acquired, we can now
    access the database to add, read, delete, or modify the stored data.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing the connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the database connection alive requires a significant number of resources,
    such as memory and CPU, so it is a good idea to close the connection and release
    the allocated resources as soon as you no longer need them. In the case of pooling,
    the `Connection` object, when closed, is returned to the pool and consumes fewer
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Java 7, a connection was closed by invoking the `close()` method in
    a `finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The code inside the `finally` block is always executed, whether the exception
    inside the `try` block is thrown or not. However, since Java 7, the `try-with-resources`
    construct also does the job on any object that implements the `java.lang.AutoCloseable`
    or `java.io.Closeable` interface. Since the `java.sql.Connection` object does
    implement the `AutoCloseable` interface, we can rewrite the previous code snippet,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The `catch` clause is necessary because the `AutoCloseable` resource throws
    `java.sql.SQLException`.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four kinds of SQL statements that read or manipulate data in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: The `INSERT` statement adds data to a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SELECT` statement reads data from a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UPDATE` statement changes data in a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DELETE` statement deletes data from a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either one or several different clauses can be added to the preceding statements
    to identify the data that is requested (such as the `WHERE` clause) and the order
    in which the results have to be returned (such as the `ORDER` clause).
  prefs: []
  type: TYPE_NORMAL
- en: 'The JDBC connection is represented by `java.sql.Connection`. This, among others,
    has the methods required to create three types of objects that allow you to execute
    SQL statements that provide different functionality to the database side:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.sql.Statement`: This simply sends the statement to the database server
    for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.sql.PreparedStatement`: This caches the statement with a certain execution
    path on the database server by allowing it to be executed multiple times with
    different parameters in an efficient manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.sql.CallableStatement`: This executes the stored procedure in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we are going to review how to do it in Java code. The best
    practice is to test the SQL statement in the database console before using it
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: The INSERT statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `INSERT` statement creates (populates) data in the database and has the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, when several records need to be added, you can use the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The SELECT statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SELECT` statement has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, when all the columns need to be selected, you can use the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'A more general definition of the `WHERE` clause is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The construct’s `column_name` operator value can be combined using the `AND`
    and `OR` logical operators, and grouped by brackets, `( )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following method brings all the first name values (separated
    by a whitespace character) from the `person` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getString(int position)` method of the `ResultSet` interface extracts
    the `String` value from position `1` (the first in the list of columns in the
    `SELECT` statement). There are similar getters for all primitive types: `getInt(int
    position)`, `getByte(int position)`, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to extract the value from the `ResultSet` object using
    the column name. In our case, it will be `getString("first_name")`. This method
    of getting values is especially useful when the `SELECT` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: However, bear in mind that extracting values from the `ResultSet` object using
    the column name is less efficient. The difference in performance, though, is very
    small and only becomes important when the operation takes place many times. Only
    the actual measuring and testing processes can tell whether the difference is
    significant to your application or not. Extracting values by column name is especially
    attractive because it provides better code readability, which pays off in the
    long run during application maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other useful methods in the `ResultSet` interface. If your application
    reads data from a database, we highly recommend that you read the official documentation
    ([www.postgresql.org/docs](http://www.postgresql.org/docs)) of the `SELECT` statement
    and the `ResultSet` interface for the database version you are using.
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data can be changed by the `UPDATE` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this statement to change the first name in one of the records from
    the original value, `John`, to a new value, `Jim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Without the `WHERE` clause, all the records of the table will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: The DELETE statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove records from a table, use the `DELETE` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the `WHERE` clause, all the records of the table are deleted. In the
    case of the `person` table, we can delete all the records using the following
    SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, this statement only deletes the records that have a first name
    of `Jim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Using statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.sql.Statement` interface offers the following methods for executing
    SQL statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean execute(String sql)`: This returns `true` if the executed statement
    returns data (inside the `java.sql.ResultSet` object) that can be retrieved using
    the `ResultSet getResultSet()` method of the `java.sql.Statement` interface. Alternatively,
    it returns `false` if the executed statement does not return data (for the `INSERT`
    statement or the `UPDATE` statement) and the subsequent call to the `int getUpdateCount()`
    method of the `java.sql.Statement` interface returns the number of affected rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResultSet executeQuery(String sql)`: This returns data as a `java.sql.ResultSet`
    object (the SQL statement used with this method is usually a `SELECT` statement).
    The `ResultSet getResultSet()` method of the `java.sql.Statement` interface does
    not return data, while the `int getUpdateCount()` method of the `java.sql.Statement`
    interface returns `-1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int executeUpdate(String sql)`: This returns the number of affected rows (the
    executed SQL statement is expected to be the `UPDATE` statement or the `DELETE`
    statement). The same number is returned by the `int getUpdateCount()` method of
    the `java.sql.Statement` interface; the subsequent call to the `ResultSet getResultSet()`
    method of the `java.sql.Statement` interface returns `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will demonstrate how these three methods work on each of the statements:
    `INSERT`, `SELECT`, `UPDATE`, and `DELETE`.'
  prefs: []
  type: TYPE_NORMAL
- en: The execute(String sql) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s try executing each of the statements; we’ll start with the `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds a new record to the `person` table. The returned `false`
    value indicates that there is no data returned by the executed statement; this
    is why the `getResultSet()` method returns `null`. But, the `getUpdateCount()`
    method returns `1` because one record was affected (added). The `selectAllFirstNames()`
    method proves that the expected record was inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s execute the `SELECT` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code selects all the first names from the `person` table. The
    returned `true` value indicates that there is data returned by the executed statement.
    That is why the `getResultSet()` method does not return `null` but a `ResultSet`
    object instead. The `getUpdateCount()` method returns `-1` because no record was
    affected (changed). Since there was only one record in the `person` table, the
    `ResultSet` object contains only one result, and `rs.getString(1)` returns `Bill`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the `UPDATE` statement to change the first name in
    all the records of the `person` table to `Adam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the returned `false` value indicates that there is no
    data returned by the executed statement. This is why the `getResultSet()` method
    returns `null`. But, the `getUpdateCount()` method returns `1` because one record
    was affected (changed) since there was only one record in the `person` table.
    The `selectAllFirstNames()` method proves that the expected change was made to
    the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `DELETE` statement execution deletes all records from the `person`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the returned `false` value indicates that there is no
    data returned by the executed statement. That is why the `getResultSet()` method
    returns `null`. But, the `getUpdateCount()` method returns `1` because one record
    was affected (deleted) since there was only one record in the `person` table.
    The `selectAllFirstNames()` method proves that there are no records in the `person`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The executeQuery(String sql) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will try to execute the same statements (as a query) that
    we used when demonstrating the `execute()` method in the *The execute(String sql)
    method* section. We’ll start with the `INSERT` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code generates an exception with the `No results were returned
    by the query` message because the `executeQuery()` method expects to execute the
    `SELECT` statement. Nevertheless, the `selectAllFirstNames()` method proves that
    the expected record was inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s execute the `SELECT` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code selects all the first names from the `person` table. The
    returned `false` value indicates that `executeQuery()` always returns the `ResultSet`
    object, even when no record exists in the `person` table. As you can see, there
    appear to be two ways of getting a result from the executed statement. However,
    the `rs2` object has no data, so, while using the `executeQuery()` method, make
    sure that you get the data from the `ResultSet` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to execute an `UPDATE` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code generates an exception with the `No results were returned
    by the query` message because the `executeQuery()` method expects to execute the
    `SELECT` statement. Nevertheless, the `selectAllFirstNames()` method proves that
    the expected change was made to the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to get the same exception while executing the `DELETE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Nevertheless, the `selectAllFirstNames()` method proves that all the records
    of the `person` table were deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Our demonstration shows that `executeQuery()` should be used for `SELECT` statements
    only. The advantage of the `executeQuery()` method is that, when used for `SELECT`
    statements, it returns a not-null `ResultSet` object even when there is no data
    selected, which simplifies the code since there is no need to check the returned
    value for `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The executeUpdate(String sql) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start demonstrating the `executeUpdate()` method with the `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `executeUpdate()` method returns the number of affected
    (inserted, in this case) rows. The same number returns the `int getUpdateCount()`
    method, while the `ResultSet getResultSet()` method returns `null`. The `selectAllFirstNames()`
    method proves that the expected record was inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `executeUpdate()` method can’t be used for executing the `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: The message of the exception is `A result was returned when none was expected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UPDATE` statement, on the other hand, is executed by the `executeUpdate()`
    method just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: The `executeUpdate()` method returns the number of affected (updated, in this
    case) rows. The same number returns the `int getUpdateCount()` method, while the
    `ResultSet getResultSet()` method returns `null`. The `selectAllFirstNames()`
    method proves that the expected record was updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DELETE` statement produces similar results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: By now, you have probably realized that the `executeUpdate()` method is better
    suited for `INSERT`, `UPDATE`, and `DELETE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Using PreparedStatement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`PreparedStatement` is a subinterface of the `Statement` interface. This means
    that it can be used anywhere that the `Statement` interface is used. The advantage
    of `PreparedStatement` is that it is cached in the database instead of being compiled
    every time it is invoked. This way, it is efficiently executed multiple times
    for different input values. It can be created by the `prepareStatement()` method
    using the same `Connection` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the same SQL statement can be used for creating `Statement` and `PreparedStatement`,
    it is a good idea to use `PreparedStatement` for any SQL statement that is called
    multiple times because it performs better than the `Statement` interface on the
    database side. To do this, all we need to change are these two lines from the
    preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can use the `PreparedStatement` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the `PreparedStatement` object with parameters, you can substitute
    the input values with the question mark symbol (`?`); for example, we can create
    the following method (see the `Person` class in the `database` project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: When it is used the first time, the database compiles the `PreparedStatement`
    object as a template and stores it. Then, when it is later used by the application
    again, the parameter value is passed to the template, and the statement is executed
    immediately without the overhead of compilation since it has been done already.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of a prepared statement is that it is better protected from
    a SQL injection attack because values are passed in using a different protocol
    and the template is not based on the external input.
  prefs: []
  type: TYPE_NORMAL
- en: If a prepared statement is used only once, it may be slower than a regular statement,
    but the difference may be negligible. If in doubt, test the performance and see
    whether it is acceptable for your application – the increased security could be
    worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Using CallableStatement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CallableStatement` interface (which extends the `PreparedStatement` interface)
    can be used to execute a stored procedure, although some databases allow you to
    call a stored procedure using either a `Statement` or `PreparedStatement` interface.
    A `CallableStatement` object is created by the `prepareCall()` method and can
    have parameters of three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IN` for an input value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OUT` for the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IN OUT` for either an input or an output value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IN` parameter can be set the same way as the parameters of `PreparedStatement`,
    while the `OUT` parameter must be registered by the `registerOutParameter()` method
    of `CallableStatement`.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that executing a stored procedure from Java programmatically
    is one of the least standardized areas. PostgreSQL, for example, does not support
    stored procedures directly, but they can be invoked as functions that have been
    modified for this purpose by interpreting the `OUT` parameters as return values.
    Oracle, on the other hand, allows the `OUT` parameters as functions too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why the following differences between database functions and stored
    procedures can serve only as general guidelines and not as formal definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: A function has a return value, but it does not allow `OUT` parameters (except
    for some databases) and can be used in a SQL statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stored procedure does not have a return value (except for some databases);
    it allows `OUT` parameters (for most databases) and can be executed using the
    JDBC `CallableStatement` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can refer to the database documentation to learn how to execute a stored
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since stored procedures are compiled and stored on the database server, the
    `execute()` method of `CallableStatement` performs better for the same SQL statement
    than the corresponding method of the `Statement` or `PreparedStatement` interface.
    This is one of the reasons why a lot of Java code is sometimes replaced by one
    or several stored procedures that even include business logic. However, there
    is no one right answer for every case and problem, so we will refrain from making
    specific recommendations, except to repeat the familiar mantra about the value
    of testing and the clarity of the code you are writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: A stored procedure can be without any parameters at all, with `IN` parameters
    only, with `OUT` parameters only, or with both. The result may be one or multiple
    values, or a `ResultSet` object. You can find the syntax of the SQL for function
    creation in your database documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Using a shared library JAR file to access a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In fact, we have already started using the `database` project JAR file to access
    the database driver, set as a dependency in the `pom.xml` file of the `database`
    project. Now, we are going to demonstrate how to use a JAR file of the `database`
    project JAR file to manipulate data in the database. An example of such usage
    is presented in the `UseDatabaseJar` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support CRUD operations, a database table often represents a class of objects.
    Each row of such a table contains properties of one object of a class. In the
    *Creating a database structure* section, we demonstrated an example of such mapping
    between the `Person` class and the `person` table. To illustrate how to use a
    JAR file for data manipulation, we have created a separate `database` project
    that has only one `Person` class. In addition to the properties shown in the *Creating
    a database structure* section, it has static methods for all CRUD operations.
    The following is the `insert()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `selectByFirstName()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `updateFirstNameById()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `deleteById()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the preceding methods accept the `Connection` object as
    a parameter, instead of creating and destroying it inside each method. We decided
    to do it like so because it allows several operations to associate with each `Connection`
    object in case we would like them to be committed to the database together or
    to be rolled back if one of them fails (read about transaction management in the
    documentation of the database of your choice). Besides, the JAR file (generated
    by the `database` project) can be used by different applications, so database
    connection parameters are going to be application-specific, and that is why the
    `Connection` object has to be created in the application that uses the JAR file.
    The following code demonstrates such a usage (see the `UseDatabaseJar` class).
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have executed the `mvn clean install` command in the `database`
    folder before running the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the preceding code snippet. Lines `1` and `26` to `28` compose
    the `try–catch` block that disposes of the `Connection` object and catches all
    the exceptions that may happen inside this block during its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line `2` was included just to clean up the data from the `person` table before
    running the demo code. The following is the implementation of the `cleanTablePerson()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: In lines `3`, `4`, and `5`, we create three objects of the `Person` class, then
    in lines `6`, `7`, and `8`, we use them to insert records in the `person` table.
  prefs: []
  type: TYPE_NORMAL
- en: In line `9`, we query the database for a record that has the first name taken
    from the `jill` object, and in line `10`, we print out the result count, which
    is `0` (because we did not insert such a record).
  prefs: []
  type: TYPE_NORMAL
- en: In line `11`, we query the database for a record that has the first name set
    to `Jane`, and in line `12`, we print out the result count, which is `2` (because
    we did insert two records with such a value).
  prefs: []
  type: TYPE_NORMAL
- en: In line `13`, we extract the first of the two objects returned by the previous
    query, and in line `14`, we update the corresponding record with a different value
    for the first name (taken from the `jill` object).
  prefs: []
  type: TYPE_NORMAL
- en: In line `15`, we repeat the query for a record with the first name set to `Jane`,
    and in line `16`, we print out the result count, which is `1` this time (as expected,
    because we have changed the first name to `Jill` on one of the two records).
  prefs: []
  type: TYPE_NORMAL
- en: In line `17`, we select all the records with the first name set to `Jill`, and
    in line `18`, we print out the result count, which is `1` this time (as expected,
    because we have changed the first name to `Jill` on one of the two records that
    used to have the first name value `Jane`).
  prefs: []
  type: TYPE_NORMAL
- en: In line `19`, we select all the records with the name set to `Mike`, and in
    line `20`, we print out the result count, which is `1` (as expected, because we
    have created only one such record).
  prefs: []
  type: TYPE_NORMAL
- en: In lines `21` to `23`, we delete all the retrieved records in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: That is why when we select all the records with the first name `Mike` in line
    `24` again, we get a result count equal to `0` in line `25` (as expected, because
    there is no such record anymore).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, when this code snippet is executed and the `main()` method of
    the `UseDatabseJar` class is completed, all the changes in the database are saved
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: That is how a JAR file (which allows modifying data in a database) can be used
    by any application that has this file as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed and demonstrated how the data in a database can
    be populated, read, updated, and deleted from a Java application. A short introduction
    to the SQL language described how to create a database and its structure, how
    to modify it, and how to execute SQL statements, using `Statement`, `PreparedStatement`,
    and `CallableStatement`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can create and use a database for storing, updating, and retrieving
    data, and create and use a shared library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will describe and discuss the most popular network protocols,
    demonstrate how to use them, and how to implement client-server communication
    using the latest Java HTTP Client API. The protocols reviewed include the Java
    implementation of a communication protocol based on TCP, UDP, and URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JDBC stands for Java Database Communication.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The JDBC API includes the `java.db` package.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The JDBC API comes with Java installation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The JDBC API includes the drivers for all major DBMSs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A database table can be created using the `CREATE` statement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A database table can be changed using the `UPDATE` statement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A database table can be removed using the `DELETE` statement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Each database column can have an index.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To connect to a database, you can use the `Connect` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Every database connection must be closed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The same database connection may be used for many operations.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Database connections can be pooled.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A database connection can be closed automatically using the `try-with-resources`
    construct.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A database connection can be closed using the `finally` block construct.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A database connection can be closed using the `catch` block.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A database connection can be closed without a `try` block.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `INSERT` statement includes a table name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `INSERT` statement includes column names.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `INSERT` statement includes values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `INSERT` statement includes constraints.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SELECT` statement must include a table name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SELECT` statement must include a column name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SELECT` statement must include the `WHERE` clause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SELECT` statement may include the `ORDER` clause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UPDATE` statement must include a table name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UPDATE` statement must include a column name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UPDATE` statement may include the `WHERE` clause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UPDATE` statement may include the `ORDER` clause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DELETE` statement must include a table name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DELETE` statement must include a column name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DELETE` statement may include the `WHERE` clause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DELETE` statement may include the `ORDER` clause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements about the `execute()` method of the `Statement`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It receives a SQL statement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns a `ResultSet` object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Statement` object may return data after `execute()` is called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Statement` object may return the number of affected records after `execute()`
    is called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements about the `executeQuery()` method of the
    `Statement` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It receives a SQL statement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns a `ResultSet` object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Statement` object may return data after `executeQuery()` is called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Statement` object may return the number of affected records after `executeQuery()`
    is called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements about the `executeUpdate()` method of the
    `Statement` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It receives a SQL statement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns a `ResultSet` object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Statement` object may return data after `executeUpdate()` is called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Statement` object returns the number of affected records after `executeUpdate()`
    is called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements about the `PreparedStatement` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It extends `Statement`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An object of type `PreparedStatement` is created by the `prepareStatement()`
    method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is always more efficient than `Statement`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It results in a template in the database being created only once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements about the `CallableStatement` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It extends `PreparedStatement`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An object of type `CallableStatement` is created by the `prepareCall()` method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is always more efficient than `PreparedStatement`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It results in a template in the database being created only once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
