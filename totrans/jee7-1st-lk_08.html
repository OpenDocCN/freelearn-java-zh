<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Validators and Interceptors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Validators and Interceptors</h1></div></div></div><p>In this chapter, we will see data validation with constraints. This will give us the opportunity to put a small part of <a id="id498" class="indexterm"/>
<span class="strong"><strong>AOP</strong></span> (<span class="strong"><strong>Aspect Oriented Programming</strong></span>) in action and discover the novelties in the validation and interception APIs. The specifications concerned are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Bean Validation 1.1</li><li class="listitem" style="list-style-type: disc">Interceptors 1.2</li></ul></div><div class="section" title="Bean Validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec35"/>Bean Validation</h1></div></div></div><p>The Bean Validation 1.1 Specification <a id="id499" class="indexterm"/>was developed under JSR 349. This section just gives you an overview of improvements in the API. The complete document specification (for more information) can be downloaded from  <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html</a>.</p><p>We are almost at the end of the realization of our online preregistration application. In the previous chapters, we developed the different layers of our application and now we need to validate the data that will be handled by this application.</p><div class="section" title="Validating your data"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Validating your data</h2></div></div></div><p>The Java language provides for Java SE <a id="id500" class="indexterm"/>and Java EE developers the Bean Validation Specification, which allows us to express constraints on objects. By default, it offers a small number of constraints (compared to the needs that you may have) called built-in constraints (see the following table). But, it gives you the opportunity to combine these constraints in order to make much more complex constraints (custom constraints) that suit your needs. This is what makes its power. This specification can be used in conjunction with many other specifications such as CDI, JSF, JPA, and JAX-RS.</p><p>The list of the built-in constraints in Bean Validation 1.1 is shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Constraint</p>
</th><th style="text-align: left" valign="bottom">
<p>Supported type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Null</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Object</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id501" class="indexterm"/>ensures that the value of the object is null</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@NotNull</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Object</code></p>
</td><td style="text-align: left" valign="top">
<p>This ensures <a id="id502" class="indexterm"/>that the value of the object is not null</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@AssertTrue</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">boolean</code>, Boolean</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id503" class="indexterm"/>ensures that the value of the object is true</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@AssertFalse</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">boolean</code>, Boolean</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id504" class="indexterm"/>ensures that the value of the object is false</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Min</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">BigDecimal</code>, <code class="literal">BigInteger</code> <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and the respective wrappers (such as <code class="literal">Byte</code> and <code class="literal">Short</code>)</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id505" class="indexterm"/>ensures that the value of the object is greater than or equal to the value specified in the annotation</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Max</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">BigDecimal</code>, <code class="literal">BigInteger</code> <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and the respective wrappers (such as <code class="literal">Byte</code> and <code class="literal">Short</code>)</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id506" class="indexterm"/>ensures that the value of the object is less than or equal to the value specified in the annotation</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@DecimalMin</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">BigDecimal</code>, <code class="literal">BigInteger</code>, <code class="literal">CharSequence</code></p>
<p><code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and the respective wrappers (such as <code class="literal">Byte</code> and <code class="literal">Short</code>)</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id507" class="indexterm"/>ensures that the value of the object is greater than or equal to the value specified in the annotation</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@DecimalMax</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">BigDecimal</code>, <code class="literal">BigInteger</code>, <code class="literal">CharSequence</code></p>
<p><code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and the respective wrappers (such as <code class="literal">Byte</code> and <code class="literal">Short</code>)</p>
</td><td style="text-align: left" valign="top">
<p>This ensures <a id="id508" class="indexterm"/>that the value of the object is less than or equal to the value specified in the annotation</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Size</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">CharSequence</code>, <code class="literal">Collection</code>, <code class="literal">Array</code>, and <code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id509" class="indexterm"/>ensures that the size of the object is in the defined range</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Digits</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">BigDecimal</code>, <code class="literal">BigInteger</code>, <code class="literal">CharSequence</code></p>
<p><code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and the respective wrappers (such <code class="literal">asByte</code> and <code class="literal">Short</code>)</p>
</td><td style="text-align: left" valign="top">
<p>This ensures <a id="id510" class="indexterm"/>that the value of the object is in the defined range</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Past</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">java.util.Date</code> and <code class="literal">java.util.Calendar</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id511" class="indexterm"/>ensures that the date contained in the object is prior to the date of treatment</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Future</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">java.util.Date</code> and <code class="literal">java.util.Calendar</code></p>
</td><td style="text-align: left" valign="top">
<p>This ensures <a id="id512" class="indexterm"/>that the date contained in the object is later than the date of treatment</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@Pattern</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">CharSequence</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id513" class="indexterm"/>ensures that value of the item meets the regular expression defined in the annotation</p>
</td></tr></tbody></table></div><p>One advantage of this specification is the ability to define the different constraints it offers via annotations, which facilitates its use. According to the characteristics of the annotation (explained in detail in <a class="link" href="ch07.html" title="Chapter 7. Annotations and CDI">Chapter 7</a>, <span class="emphasis"><em>Annotations and CDI</em></span>), you can express constraints for a class, field, or property. The <a id="id514" class="indexterm"/>following example shows a <code class="literal">Student</code> entity whose fields are decorated with the built-in constraints. You can see the constraints to avoid the null value or to define the size and format of attributes in the following code:</p><div class="informalexample"><pre class="programlisting">@Entity
public class Student implements Serializable {
  @Id
  @NotNull
  @Size(min = 1, max = 15)
  private String id;
  @Size(max = 30)
  private String firstname;
  @Pattern(regexp="^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$", message="Invalid phone/fax format,should be as xxx-xxx-xxxx")
  //if the field contains phone or fax number consider using this//annotation to enforce field validation
  @Size(max = 10)
  private String phone;
  @Pattern(regexp="[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?",message="Invalid email")
  //if the field contains email address consider using this//annotation to enforce field validation
  @Size(max = 60)
  @Email
  private String email;

  //...
}</pre></div><p>Once the constraints are defined, the Bean Validation Specification allows you to validate the data under constraints manually or automatically through other specifications. We begin by presenting manual validation. The following example demonstrates how to validate the constraints of a class manually. We must say that the <code class="literal">Validator</code> API also provides methods to validate a single attribute or a specific value as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public static void main(String[] args) {
  Student student = new Student();
  student.setEmail("qsdfqsdfqsdfsqdfqsdfqsdf");
  student.setPhone("dfqsdfqsdfqsdfqsdfqsdfqsd");
  
  ValidatorFactory factory =Validation.buildDefaultValidatorFactory();
  Validator validator = factory.getValidator();
  
  Set&lt;ConstraintViolation&lt;Student&gt;&gt; violations =validator.validate(student);
  System.out.println("Number of violations : "+violations.size());
  for(ConstraintViolation&lt;Student&gt; cons : violations){
    System.out.println("Calss :"+cons.getRootBeanClass()+",Instance : "+cons.getLeafBean()+", "
     + " attribute : "+cons.getPropertyPath()+",message :"+cons.getMessage());
  }
}    </pre></div><p>As we mentioned, the Bean Validation Specification can be combined with other specifications. In the example that follows, we present the coupling between Bean Validation and JSF. We take this opportunity to highlight automatic validation. The example that follows demonstrates how to <a id="id515" class="indexterm"/>validate the input of a student in our online preregistration website:</p><div class="informalexample"><pre class="programlisting">@ManagedBean
public class InscriptionBean {
  @Size(min=4, message="The full name must have "+ " at least four characters!")
  private String name;
  @Past
  private Date birthday;
  @NotNull
  @Size(min=1, max=1,message="Enter only one character")
  private String gender;
  @Pattern(regexp="^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$", 
  message="Invalid phone format, should be as xxx-xxx-xxxx")
  @Size(max = 10)
  private String phone;
  @Pattern(regexp="[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)"
  + "*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?", 
  message="Invalid email")
  private String email;

  //...getter and setter
}</pre></div><p>The following code shows an example of the content of the web page allowing candidates to enter their personal identification. As you can see, we used the pass through attribute explained in <a class="link" href="ch03.html" title="Chapter 3. The Presentation Layer">Chapter 3</a>, <span class="emphasis"><em>The Presentation Layer</em></span>, to use the calendar of HTML5 and we put the tag <code class="literal">&lt;h:message/&gt;</code> next to each field with the ID of the concerned field in order to display error messages in case of violation of the <a id="id516" class="indexterm"/>constraint. This allows us to have the screen capture shown in the following screenshot.</p><p>The following code is an example of the contents of the <code class="literal">identificationInformationPage.xml</code> JSF page:</p><div class="informalexample"><pre class="programlisting">&lt;html 
  
  
  &gt;
  &lt;h:head&gt;
    &lt;title&gt;Inscription information&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;f:view&gt;
      &lt;h:form&gt;
        &lt;table border="0"&gt;                    
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;th&gt;Name :&lt;/th&gt;
              &lt;th&gt;&lt;h:inputText value="#{inscriptionBean.name}"id="name"/&gt;&lt;/th&gt;
              &lt;th&gt;&lt;h:message for="name" style="color:red"/&gt;&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Birthday :&lt;/td&gt;
              &lt;td&gt;&lt;h:inputText pta:type="date"value="#{inscriptionBean.birthday}"  id="birth"&gt;
              &lt;f:convertDateTime pattern="yyyy-MM-dd" /&gt;
              &lt;/h:inputText&gt;&lt;/td&gt;
              &lt;th&gt;&lt;h:message for="birth" style="color:red"/&gt;&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Gender :&lt;/td&gt;
              &lt;td&gt;&lt;h:inputText value="#{inscriptionBean.gender}"id="gender"/&gt;&lt;/td&gt;
              &lt;th&gt;&lt;h:message for="gender" style="color:red"/&gt;&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Phone :&lt;/td&gt;
              &lt;td&gt;&lt;h:inputText value="#{inscriptionBean.phone}"id="phone"/&gt;&lt;/td&gt;
              &lt;th&gt;&lt;h:message for="phone" style="color:red"/&gt;&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Email :&lt;/td&gt;
              &lt;td&gt;&lt;h:inputText value="#{inscriptionBean.email}"id="email"/&gt;&lt;/td&gt;
              &lt;th&gt;&lt;h:message for="email" style="color:red"/&gt;&lt;/th&gt;
            &lt;/tr&gt;                        
          &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;p&gt;
          &lt;h:commandButton value="Submit" /&gt;
        &lt;/p&gt;
      &lt;/h:form&gt;
    &lt;/f:view&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>As shown in the following screenshot, when submitting the entry, the contents of the form will automatically be validated and error messages will be returned to the form. Thus, this association (JSF and Bean validation) allows you to define the constraints on a single bean and use it for multiple forms.</p><p>The result of the validation is shown in the <a id="id517" class="indexterm"/>following screenshot:</p><div class="mediaobject"><img src="graphics/923-5_08_01.jpg" alt="Validating your data"/></div></div><div class="section" title="Building a custom constraint"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Building a custom constraint</h2></div></div></div><p>In the previous example, we wanted to <a id="id518" class="indexterm"/>have a constraint that allows us to ensure that the value of the <code class="literal">Gender</code> field was entered in uppercase, but this constraint does <a id="id519" class="indexterm"/>not exist explicitly. To do this, we must have some knowledge of regular expressions and use the <code class="literal">@Pattern</code> annotation. This requires some background. Fortunately, we have the ability to create custom constraints. We will set up a constraint that allows us to perform this task.</p><p>The creation of a new constraint substantially follows the same rules as the creation of a simple annotation (as explained <a class="link" href="ch07.html" title="Chapter 7. Annotations and CDI">Chapter 7</a>, <span class="emphasis"><em>Annotations and CDI</em></span>). The fundamental difference lies in the fact that instead of implementing a processor, we will implement a validator in the case of constraints. That said, the creation of a custom constraint includes the following steps: creating a constraint annotation and implementing a validator.</p></div><div class="section" title="Creating a constraint annotation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Creating a constraint annotation</h2></div></div></div><p>Although the goal is to create a constraint <a id="id520" class="indexterm"/>that ensures that a string character is capitalized, we will create a generic annotation. This annotation will take as <a id="id521" class="indexterm"/>parameter the <a id="id522" class="indexterm"/>type of the expected case. Thus, it may, in the future, allow us to test if the characters are uppercase or lowercase .</p><p>We will create the enumeration <code class="literal">CaseType</code>, which contains different types of case, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public enum CaseType {
    NONE,
    UPPER,
    LOWER
}</pre></div><p>Once we have defined the possible types of cases, we will create our annotation and define its characteristics directly. Already, it <a id="id523" class="indexterm"/>should be noted that in addition to the basic features we've seen in the creation of annotations, you'll have to add the <code class="literal">@Constraint</code> annotation that defines the validator of this <a id="id524" class="indexterm"/>constraint. For other features, please refer to <a class="link" href="ch07.html" title="Chapter 7. Annotations and CDI">Chapter 7</a>, <span class="emphasis"><em>Annotations and CDI</em></span>. The following <a id="id525" class="indexterm"/>code is the code of our annotation:</p><div class="informalexample"><pre class="programlisting">@Target({ElementType.FIELD, ElementType.METHOD,ElementType.PARAMETER,ElementType.LOCAL_VARIABLE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CaseValidator.class)
public @interface Case {
  String message() default "This value must be uppercase";    
  CaseType type() default CaseType.UPPER;
  Class&lt;? extends Payload&gt;[] payload() default {};
  Class&lt;?&gt;[] groups() default {}; 
}</pre></div></div><div class="section" title="Implementing a validator"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Implementing a validator</h2></div></div></div><p>Instead of a processor that is required for <a id="id526" class="indexterm"/>simple annotations, constraints need to implement the <code class="literal">javax.validation.ConstraintValidator &lt;A extends Annotation, T extends Object&gt;</code> interface, which provides two methods that are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">void initialize(A constraintAnnotation)</code>: This method is always called before processing a <a id="id527" class="indexterm"/>constraint. It allows you to initialize the parameters that will be useful during the execution of the <code class="literal">isValid()</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">boolean isValid(T value, ConstraintValidatorContext context)</code>: This method <a id="id528" class="indexterm"/>contains the validation logic.</li></ul></div><p>The following code shows the validator of our constraint:</p><div class="informalexample"><pre class="programlisting">public class CaseValidator implements ConstraintValidator&lt;Case, String&gt;{
  private CaseType type;
  
  public void initialize(Case annotation) {
    type = annotation.type();
  }

  public boolean isValid(String value,ConstraintValidatorContext context) {
  if(value == null)
    return true;        
    
    if (type == CaseType.UPPER) {
      return value.equals(value.toUpperCase());
    } else {
      return value.equals(value.toLowerCase());
    }
  }    
}</pre></div><p>After you create your validator, you must register the service (see <a class="link" href="ch07.html" title="Chapter 7. Annotations and CDI">Chapter 7</a>, <span class="emphasis"><em>Annotations and CDI</em></span>). Then, import the package <a id="id529" class="indexterm"/>containing your annotation. The following screenshot shows the structure of the project in which we have defined our annotation:</p><div class="mediaobject"><img src="graphics/923-5_08_02.jpg" alt="Implementing a validator"/></div><p>Now, we just need to add <code class="literal">@Case (type = CaseType.UPPER)</code> on an attribute of type <code class="literal">String</code> to ensure that the value will always be in capital letters. The following code shows the change in the <code class="literal">InscriptionBean</code> Bean code that was presented earlier:</p><div class="informalexample"><pre class="programlisting">@Case(type= CaseType.UPPER, message="This value must be uppercase")
private String gender;</pre></div><p>And the result is simply beautiful, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/923-5_08_03.jpg" alt="Implementing a validator"/></div></div><div class="section" title="Latest improvements in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec58"/>Latest improvements in action</h2></div></div></div><p>Chapter 2 of the <span class="emphasis"><em>Bean </em></span><a id="id530" class="indexterm"/>
<span class="emphasis"><em>Validation 1.1 Specification Document</em></span> presents the major changes of this version. These are: openness, support for dependency injection, better integration with CDI, support for method and constructor validation, support for group conversion, and finally support for message interpolation using expression language.</p><div class="section" title="Openness"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec54"/>Openness</h3></div></div></div><p>The implementation of the Bean Validation 1.1 Specification has been managed as an open source project. Thus, the source code, reference implementation and test compatibility kit of the API are accessible to the community. For more information, please access the site <a class="ulink" href="http://beanvalidation.org">http://beanvalidation.org</a>.</p></div><div class="section" title="Support for dependency injection and CDI integration"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec55"/>Support for dependency injection and CDI integration</h3></div></div></div><p>The Bean Validation 1.1 <a id="id531" class="indexterm"/>Specification has standardized the management of objects used to implement validators inside a container and reviewed all the services that were offered to these objects. That helped support dependency injection in Bean Validation components and improve integration with CDI. Henceforth, we can use the <code class="literal">@Resource</code> and <code class="literal">@Inject</code> annotations to inject objects of type <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code>. The following example demonstrates the use <a id="id532" class="indexterm"/>of the <code class="literal">@Inject</code> annotation to validate an object using Bean Validation components:</p><div class="informalexample"><pre class="programlisting">@Singleton
@Startup
public class InjectValidators {    
  private Logger logger =Logger.getLogger(InjectValidators.class.getName());

  @Inject
  private Validator validator;

  @PostConstruct
  public void init() {
    Student student = new Student();
    Set&lt;ConstraintViolation&lt;Student&gt;&gt; violations =validator.validate(student);
    logger.info("InjectValidators-Number of violations : " +violations.size());        
  }
}</pre></div></div><div class="section" title="Support for method and constructor validation"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec56"/>Support for method and constructor validation</h3></div></div></div><p>The Bean Validation Specification 1.1 <a id="id533" class="indexterm"/>has added the ability to define constraints on the parameters of a method or constructor. It also allows the definition of the constraints on the return value of a method. The following code demonstrates how to declare and validate constraints on the parameters of a method and its return value:</p><div class="informalexample"><pre class="programlisting">@Singleton
@Startup
public class ParameterConstraints {
  private Logger logger =Logger.getLogger(InjectValidators.class.getName());
  @Inject
  ExecutableValidator validator;
  
  @PostConstruct
  public void init() {                
    try {
      ParameterConstraints pc = new ParameterConstraints();
      Method method = ParameterConstraints.class.getMethod("createStudent", Student.class);
      Object[] params = {null};
      Set&lt;ConstraintViolation&lt;ParameterConstraints&gt;&gt;violations = validator.validateParameters(pc, method, params);
      
      logger.info("ParameterConstraints-Number of violations : " + violations.size());
    } catch (Exception ex) {
      Logger.getLogger(ParameterConstraints.class.getName()).log(Level.SEVERE, null, ex);
    } 
  }

  @Size(max = 2)
  public String createStudent(@NotNull Student std) {
    return "123456";
  }
}</pre></div></div><div class="section" title="Support for group conversion"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec57"/>Support for group conversion </h3></div></div></div><p>While cascading a data validation, it <a id="id534" class="indexterm"/>may happen that the data to validate belongs to groups that are different from the requested group. For a concrete example, consider the following two classes <code class="literal">Student</code> and <code class="literal">Address</code>:</p><div class="informalexample"><pre class="programlisting">public class Student {
  @NotNull
  @Size(min = 1, max = 15)
  private String id;
  @Size(max = 30)
  private String firstname;
  @Size(max = 30)
  private String lastname;
  
  @Valid//To propagate the validation of a student object
  private Address address;

  //getter and setter
}

public class Address {
  @NotNull(groups=AddressCheck.class)    
  @Size(max = 10,groups=AddressCheck.class)
  private String phone;
  
  @NotNull(groups=AddressCheck.class)   
  @Email(groups=AddressCheck.class)
  private String email;    
  //getter and setter
}
public interface AddressCheck { }</pre></div><p>To enable the validation of an object step-by-step, the Bean Validation Specification proposes the notion of groups. This gives you the ability to define a subset of constraints that can be validated separately. By default, validation constraints belongs to the <code class="literal">Default</code> group. And if a validation group is not specified when validating data, only the constraints of the <code class="literal">Default</code> group will be checked. This justifies the fact that the code of the <code class="literal">testDefaultGroup()</code> method will run entirely without errors. Although the phone and the e-mail attributes of the <code class="literal">Address</code> class are not conformed to the constraints, they will not be validated for the simple reason that the <a id="id535" class="indexterm"/>constraints that decorate them are not a part of the <code class="literal">Default</code> group. This can be seen in the following code:</p><div class="informalexample"><pre class="programlisting">public  void testDefaultGroup(){
  ValidatorFactory factory =Validation.buildDefaultValidatorFactory();
  Validator validator = factory.getValidator();
  
  Student student = new Student(); 
  student.setId("ST23576");
  student.setFirstname("Stelba");
  student.setLastname("estelle");
  student.setAddress(new Address());
  
  //Only the default group will be test. 
  Set&lt;ConstraintViolation&lt;Student&gt;&gt; constraintViolations =validator.validate(student);       
  assertEquals(0, constraintViolations.size());                
} </pre></div><p>So, to validate the attributes of the <code class="literal">Address</code> object at the same time as the validation of the <code class="literal">Student</code> object, you have two options. The first is to list all the groups in the <code class="literal">validate()</code> method as is the case in the following code:</p><div class="informalexample"><pre class="programlisting">Student student = new Student(); 
student.setId("ST23576");
student.setFirstname("Stelba");
student.setLastname("estelle");
student.setAddress(new Address());

Set&lt;ConstraintViolation&lt;Student&gt;&gt; constraintViolations =validator.validate(student, Default.class, AddressCheck.class); 
assertEquals(2, constraintViolations.size());  </pre></div><p>The second method is to use the concept of group conversion via the <code class="literal">@ConvertGroup</code> or <code class="literal">@ConvertGroup.List</code> for several conversions. As its name implies, this feature gives you the ability to perform conversions from one group to another to validate attributes whose constraints belong to a group different from the requested group. The following code shows the changes that should be added on the <code class="literal">Address</code> attribute of the <code class="literal">Student</code> class in order to take advantage of the group conversion feature:</p><div class="informalexample"><pre class="programlisting">@Valid//To propagate the validation of a student object
@ConvertGroup(from=Default.class, to=AddressCheck.class)
private Address address;</pre></div><p>The following code shows the joint validation attributes of the <code class="literal">Student</code> object and attributes of the <code class="literal">Address</code> object after using the <code class="literal">@ConvertGroup</code> annotation. As you can see in the following code, we did not have to list <a id="id536" class="indexterm"/>all the groups of constraints.</p><div class="informalexample"><pre class="programlisting">Student student = new Student(); 
student.setId("ST23576");
student.setFirstname("Stelba");
student.setLastname("estelle");
student.setAddress(new Address());
Set&lt;ConstraintViolation&lt;Student&gt;&gt; constraintViolations =validator.validate(student);       
assertEquals(2, constraintViolations.size());</pre></div><p>The following code shows how to use the <code class="literal">@ConvertGroup.List</code> annotation:</p><div class="informalexample"><pre class="programlisting">//annotation
@ConvertGroup.List({
  @ConvertGroup(from = Default.class, to = Citizen.class),
  @ConvertGroup(from = Salaried.class, to = Foreign.class)
})
List&lt;Student&gt; studentList;</pre></div></div><div class="section" title="Support message interpolation using expression language"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec58"/>Support message interpolation using expression language</h3></div></div></div><p>With this version of the specification, it is <a id="id537" class="indexterm"/>possible to use expression language when defining the error message. It helps in better formatting of the message and the use of conditions in the description of the message. The following code shows a possible use of expression language in the definition of an error message:</p><div class="informalexample"><pre class="programlisting">public class Department implements Serializable {
  
  @Size(max = 30, message="A department must have at most {max}level${max &gt; 1 ? 's' : ''}")
  private Integer nbrlevel;
  
  //...
}</pre></div></div></div></div></div>
<div class="section" title="Interceptors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec36"/>Interceptors</h1></div></div></div><p>The Interceptors 1.2 Specification was <a id="id538" class="indexterm"/>developed under JSR 318. This section just gives you an overview of improvements in the  API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html</a>.</p><div class="section" title="Intercepting some processes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>Intercepting some processes</h2></div></div></div><p>Interceptors are a Java mechanism that allows us to implement some concepts of AOP, in the sense that they give us the ability to separate the code from the crosscutting concerns such as logging, auditing, and security. Thus, due to this specification, we can intercept invocations of methods, lifecycle callback events, and timeout events.</p><p>Interceptors allow you to intercept method calls as well as the outbreak of some events. During the interception, you can access the method name, method parameters, and a lot of other information. That said, the interceptors can be used to manage cross cutting concerns such as logging, auditing, security (to ensure that a user has the right to execute a method), and modification of the method parameters. You can define them in a dedicated class or within the target class directly.</p><p>The signature of an interceptor is as follows: <code class="literal">Object &lt;method_name&gt;(InvocationContext ctx) throws Exception { ... }"</code> and to <code class="literal">void &lt;method_name&gt;(InvocationContext ctx) { ... }</code>. It can throw an exception of type <code class="literal">Exception</code> and should be decorated with an annotation that defines the type of elements it must intercept. For example, <code class="literal">@AroundInvoke</code> to intercept methods and <code class="literal">@AroundTimeout</code> to intercept services' timers. Failing to use these annotations, you can always make use of XML configuration.</p><div class="section" title="Defining interceptors in the target class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec59"/>Defining interceptors in the target class</h3></div></div></div><p>The following code shows a session bean <a id="id539" class="indexterm"/>with method and timer service interceptors. The service timer interceptor (<code class="literal">targetClassTimerInterceptor</code>) only does the logging, while the method interceptor (<code class="literal">targetClassMethodInterceptor</code>), in addition to a little logging, demonstrates how to access and modify the parameters of an intercepted method. In this case, we check that the names of candidates start with <code class="literal">Sir</code>, if this is not the case, it is added.</p><p>The following code is an example of a session bean containing interceptors:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class StudentSessionBean {    
  
  private Logger logger = Logger.getLogger(
    "studentSessionBean.targetClassInterceptor");
  
  public Student createEntity(Student std){
    logger.info("createEntity-Name of the student :"+std.getFirstname());        
    return std;
  }
  
  @AroundInvoke
  public Object targetClassMethodInterceptor(InvocationContext ctx) throws Exception{
    logger.info("targetClassMethodInterceptor - method :"+ctx.getMethod().getName()+", "
    + "parameters : "+Arrays.toString(ctx.getParameters())+", date: "+new Date());
    if(ctx.getMethod().getName().equals("createEntity")){
      Student std = (Student) ctx.getParameters()[0];
      logger.info("targetClassMethodInterceptor -Name of student before : "+std.getFirstname());
      if(!std.getFirstname().startsWith("Sir")){
        std.setFirstname("Sir "+std.getFirstname());
      }
    }  
    return  ctx.proceed();
  }
  
  @Schedule(minute="*/2", hour="*")
  public void executeEvery2Second(){
    logger.info("executeEvery2Second - executeEvery5Second - date: "+new Date());
  }
  
  @AroundTimeout
  public Object targetClassTimerInterceptor(InvocationContext ctx) throws Exception{
    logger.info("targetClassTimerInterceptor - method :"+ctx.getMethod().getName()+", timer : "+ctx.getTimer());
    return  ctx.proceed();
  }
}</pre></div></div><div class="section" title="Defining interceptors in an interceptor class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec60"/>Defining interceptors in an interceptor class</h3></div></div></div><p>The following code shows a class that <a id="id540" class="indexterm"/>can be used as an interceptor. To complete this <a id="id541" class="indexterm"/>class, we extract the interceptor methods contained in the <code class="literal">StudentSessionBean</code> class. As you can see, this class has no special annotation. But to be explicit, you can decorate it with <code class="literal">javax.interceptor.Interceptor</code> annotation (in our case, we have not done it to show you that this is optional).</p><div class="informalexample"><pre class="programlisting">public class MyInterceptor {
  private Logger logger = Logger.getLogger(
    "studentSessionBean.targetClassInterceptor");
  
  @AroundInvoke
  public Object targetClassMethodInterceptor(InvocationContext ctx) throws Exception{
    logger.info("targetClassMethodInterceptor - method :"+ctx.getMethod().getName()+", "
    + "parameters : "+Arrays.toString(ctx.getParameters())+", date:     "+new Date());
    if(ctx.getMethod().getName().equals("createEntity")){
      Student std = (Student) ctx.getParameters()[0];
      logger.info("targetClassMethodInterceptor - Name of studentbefore : "+std.getFirstname());
      if(!std.getFirstname().startsWith("Sir")){
        std.setFirstname("Sir "+std.getFirstname());
      }
    }  
    return ctx.proceed();
  }
  
  @AroundTimeout
  public Object targetClassTimerInterceptor(InvocationContext ctx)throws Exception{
    logger.info("targetClassTimerInterceptor - method :+ctx.getMethod().getName()+", timer : "+ctx.getTimer());
    return  ctx.proceed();
  }
}</pre></div><p>The following code shows how to declare an interceptor class in order to intercept some processes of a given class. The result is the same as what you get in the case of the <code class="literal">StudentSessionBean</code> class presented in <a id="id542" class="indexterm"/>the preceding code.</p><div class="informalexample"><pre class="programlisting">@Interceptors(MyInterceptor.class)
@Stateless
public class StudentSessionBeanWithoutInterceptor {
    private Logger logger = Logger.getLogger(
            "studentSessionBean.targetClassInterceptor");
    
     @Schedule(minute="*/2", hour="*")
    public void executeEvery2Second(){
        logger.info("executeEvery2Second - executeEvery5Second - date : "+new Date());
    }
     
     public Student createEntity(Student std){
        logger.info("createEntity-Name of the student : "+std.getFirstname());        
        return std;
    } 
}</pre></div></div></div><div class="section" title="Latest improvements in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Latest improvements in action</h2></div></div></div><p>For all the new features added to the <a id="id543" class="indexterm"/>Interceptors 1.2 Specification, the most important are certainly: adding of a lifecycle callback interceptor for constructors, adding of standard annotation for managing the execution order of interceptors, and finally, the transfer of interceptor binding from the CDI Specification to Interceptors Specification 1.2.</p><div class="section" title="Intercept constructor invocation"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec61"/>Intercept constructor invocation </h3></div></div></div><p>Due to the <a id="id544" class="indexterm"/>
<code class="literal">@AroundConstruct</code> annotation, you can define an interceptor that will run just before the creation of the target instance to intercept the execution of the target instance constructor. Interceptor methods decorated with this annotation should not be defined in the target class.</p><p>The following code demonstrates how to use the <code class="literal">@AroundConstruct</code>. The example is to record the time at which the different methods have been called to be sure that the method <code class="literal">@AroundConstruct</code> is indeed run before the constructor. It also shows you how to access the name of the constructor and its parameters.</p><div class="informalexample"><pre class="programlisting">public class AroundConstructInterceptor {
  private Logger logger = Logger.getLogger("AroundConstructInterceptor.interceptorClass");    
    
  @AroundConstruct
  public Object initialize(InvocationContext ctx) throws Exception{
    logger.info("initialize - constructor :"+ctx.getConstructor()+", "
    + "parameters : "+Arrays.toString(ctx.getParameters())+","
    + " execution time : "+new Date());
    return ctx.proceed();
  }    
}

@Stateless
@Interceptors(AroundConstructInterceptor.class)
public class AroundConstructBean  {
  
  private Logger logger = Logger.getLogger("AroundConstructManagedBean.interceptorClass");
  
  public AroundConstructBean(){     
    logger.info("AroundConstructManagedBean - Execution time :"+new Date());
  }    
}</pre></div></div><div class="section" title="Associating an interceptor with a class using interceptor binding"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec62"/>Associating an interceptor with a class using interceptor binding</h3></div></div></div><p><span class="emphasis"><em>Associating Interceptors using Interceptor Bindings</em></span>, Chapter 3 of the <span class="emphasis"><em>Interceptors 1.2 Specification Document</em></span>, was extracted from <a id="id545" class="indexterm"/>Chapter 9 of the <a id="id546" class="indexterm"/>
<span class="emphasis"><em>CDI Specification Document</em></span>. It discusses the possibility of using annotations to associate interceptors with another component that is not an interceptor. To make this possible you must: create an interceptor binding type, declare the interceptor bindings, and bind this interceptor to the desired component.</p><div class="section" title="Creation of interceptor binding types"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec27"/>Creation of interceptor binding types</h4></div></div></div><p>The interceptor binding type is created exactly <a id="id547" class="indexterm"/>like a simple annotation, <a id="id548" class="indexterm"/>except that it adds at least the <code class="literal">@InterceptorBinding</code> among the annotations used to define the characteristic of the interceptor binding. The following code shows the declaration of an interceptor <a id="id549" class="indexterm"/>binding type to log some information:</p><div class="informalexample"><pre class="programlisting">@InterceptorBinding
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {    
}</pre></div></div><div class="section" title="Declaring interceptor binding"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec28"/>Declaring interceptor binding</h4></div></div></div><p>We can declare interceptor binding by <a id="id550" class="indexterm"/>annotating an interceptor with the interceptor binding type and the <code class="literal">@javax.interceptor.Interceptor</code> annotation. <a id="id551" class="indexterm"/>The following code demonstrates how to declare an interceptor binding:</p><div class="informalexample"><pre class="programlisting">@Log
@Interceptor
public class LoggerInterceptor {
  // Interceptors methods
}</pre></div></div><div class="section" title="Binding an interceptor by using interceptor binding type"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec29"/>Binding an interceptor by using interceptor binding type</h4></div></div></div><p>After all these operations, it is up to <a id="id552" class="indexterm"/>you to decorate a non interceptor component with the interceptor binding types to bind the interceptor to a component. The <a id="id553" class="indexterm"/>following code demonstrates how to bind the <code class="literal">LoggerInterceptor</code> interceptor to our EJB:</p><div class="informalexample"><pre class="programlisting">@Stateless
@Log
public class StudentSessionBeanWithoutInterceptor {
    //Method to intercept
}</pre></div><p>By default, the interceptor is not enabled. To do this, you must declare the interceptor in the <code class="literal">bean.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;interceptors&gt;
    &lt;class&gt;com.packt.ch08.bean.LoggerInterceptor&lt;/class&gt;
&lt;/interceptors&gt;</pre></div></div></div><div class="section" title="Defining the execution order of interceptors"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec63"/>Defining the execution order of interceptors</h3></div></div></div><p>When we talked about the CDI <a id="id554" class="indexterm"/>Specification in the <a class="link" href="ch07.html" title="Chapter 7. Annotations and CDI">Chapter 7</a>, <span class="emphasis"><em>Annotations and CDI</em></span>, we discussed adding the <code class="literal">@Priority</code> annotation. This annotation was adopted by the Interceptors 1.2 Specification and permits us to define an execution order for interceptors that were declared with interceptor bindings. When using this annotation, the interceptor with the smallest priority is called first. The following code demonstrates how to use this annotation. In our case, the <code class="literal">LoggerInterceptor</code> interceptor will be <a id="id555" class="indexterm"/>called before the <code class="literal">LoggerInterceptor1</code> interceptor.</p><div class="informalexample"><pre class="programlisting">@Log
@Interceptor
@Priority(2000)
public class LoggerInterceptor {
    // interceptor method
}

@Log1
@Interceptor
@Priority(2050)
public class LoggerInterceptor1 {
  //Interceptor method
}

@Stateless
@Log1
@Log
public class StudentSessionBeanWithoutInterceptor {
    //Methods to intercept
}</pre></div><p>In parallel to this the annotation permits us to enable the interceptors. In other words, it saves you from using the <code class="literal">&lt;interceptors&gt;</code> element in the <code class="literal">bean.xml</code> file as we did in the preceding case.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec37"/>Summary</h1></div></div></div><p>At the end of this chapter, we are now able to validate inputs on JSF forms and the data that will be manipulated by an application through the Bean Validation Specification. We also learned how to intercept different types of processes such as the creation of an object, invocation of a method, or service timer execution in order to audit or modify a method's parameters. In the next chapter, we will end our journey into the Java EE 7 world by addressing the security aspect of our online preregistration application.</p></div></body></html>