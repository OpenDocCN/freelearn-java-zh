<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Providing a Persistence Layer with Apache Aries and OpenJPA"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Providing a Persistence Layer with Apache Aries and OpenJPA</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing OpenJPA modules in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Installing Apache Aries JTA modules in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Building a project with a persistence layer for deployment in Karaf</li><li class="listitem" style="list-style-type: disc">Building a project with a persistence layer and transaction support for deployment in Karaf</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Introduction</h1></div></div></div><p>Your applications will commonly need to safely persist data and make use of transactional<a id="id523" class="indexterm"/> behaviors. A preferred way to accomplish this for Java developers is to use the <span class="strong"><strong>Java Persistence API</strong></span> (<span class="strong"><strong>JPA</strong></span>) and <span class="strong"><strong>Java Transaction API</strong></span> (<span class="strong"><strong>JTA</strong></span>). In <a id="id524" class="indexterm"/>the context of Apache Karaf, developers will use an OSGi-ready JPA implementation, such as <span class="strong"><strong>Apache OpenJPA</strong></span>, <span class="strong"><strong>EclipseLink</strong></span>, or <span class="strong"><strong>Hibernate</strong></span> and the <span class="strong"><strong>Apache Aries JTA</strong></span>.</p><p>This book will use OpenJPA as an implementation of the JPA specification for the transparent persistence of Java objects. In relation to OSGi containers, it provides container-managed persistence for the Blueprint container.</p><p>The Apache Aries JTA provides a transaction management service to the container. Using this service, developers can build applications requiring the following transactional flow:</p><div class="informalexample"><pre class="programlisting">getTransaction()
begin()  // demark beginning of transaction
doWork() // your business logic
if (rollback) then rollback() else commit()</pre></div><p>The previous pseudo code outlines the general form of a transaction; the developer obtains from the container a transaction session, demarks the beginning of the transaction, performs their business logic and, then must decide if they can commit the transaction or rollback resources.</p><p>The recipes in this chapter will aid you in deploying JPA and JTA resources into Karaf, and guide you by example to use these APIs in your bundles.</p></div></div>
<div class="section" title="Installing OpenJPA modules in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Installing OpenJPA modules in Apache Karaf</h1></div></div></div><p>Before <a id="id525" class="indexterm"/>we can begin to explore how to<a id="id526" class="indexterm"/> build OpenJPA-backed applications, we must first install all the required JPA modules into the Karaf container.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec193"/>Getting ready</h2></div></div></div><p>The ingredients of this recipe include the Apache Karaf distribution kit, access to JDK, and Internet connectivity.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec194"/>How to do it…</h2></div></div></div><p>Thanks to Apache Karaf's feature system, installing OpenJPA is a very simple two-step process: install the JPA and OpenJPA feature in Karaf. The steps are as follows:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Why do we not have to add the feature URL? This is because Apache Karaf's standard distribution includes the JPA and OpenJPA feature URLs by default.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We can install a feature by executing the <code class="literal">feature:install</code> command with the feature's name as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt;  feature:install jpa</strong></span>
</pre></div><p>We can verify the installation by executing the <code class="literal">list –t 0 | grep -i JPA</code> command, which will list all installed OpenJPA components and dependencies in Karaf (Geronimo-jta_1.1_spec, Geronimo-jpa_2.0_spec, Aries JPA API, Aries JPA Blueprint, Aries JPA Container, and Aries JPA Container Context).</p></li><li class="listitem">Similar to the installation of the JPA, we use the feature's name to install the OpenJPA engine, as follows.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt;  feature:install openjpa/2.2.2</strong></span>
</pre></div><p>We can verify the installation by executing the <code class="literal">list –t 0 | grep -i OpenJPA</code> command, which will list all installed OpenJPA components and<a id="id527" class="indexterm"/> dependencies in Karaf (core among them is the OpenJPA Aggregate JAR).</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec195"/>How it works…</h2></div></div></div><p>The <a id="id528" class="indexterm"/>Apache Karaf community maintains<a id="id529" class="indexterm"/> an Apache Karaf feature descriptor for JPA and OpenJPA. These feature descriptor files contain all of the essential bundles and dependencies required to install these APIs and providers, which are shown in the following diagram:</p><div class="mediaobject"><img src="graphics/5081OS_07_01.jpg" alt="How it works…"/></div><p>When the JPA or OpenJPA feature is installed (using the <code class="literal">feature:install</code> command), Karaf will use the appropriate URL handlers to obtain the required resources and install them into the container. Next, it attempts to bring them to a started state. If you execute the <code class="literal">list –t 0</code> command on the Karaf console, you will see the JPA and all other artifacts deployed into the container. We can depict the integration of OpenJPA components into Karaf more simply by illustrating the key artifacts being deployed atop a standard Karaf installation.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec196"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Deploying applications as a feature</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Apache Karaf for System Builders">Chapter 1</a>, <span class="emphasis"><em>Apache Karaf for System Builders</em></span>.</li></ul></div></div></div>
<div class="section" title="Installing Apache Aries JTA modules in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Installing Apache Aries JTA modules in Apache Karaf</h1></div></div></div><p>Applications <a id="id530" class="indexterm"/>often require transaction <a id="id531" class="indexterm"/>management alongside the JPA. This is accomplished by including the JTA into the Karaf container.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec197"/>Getting ready</h2></div></div></div><p>The ingredients of this recipe include the Apache Karaf distribution kit, access to JDK, and Internet connectivity. Generally, you'll also need to perform the steps outlined in the <span class="emphasis"><em>Installing OpenJPA modules in Apache Karaf</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec198"/>How to do it…</h2></div></div></div><p>Thanks to Apache Karaf's feature system, installing JTA is a very simple one-step process.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Why do we not have to add the feature URL? This is because Apache Karaf's standard distribution includes the JTA feature URL by default.</p></div></div><div class="section" title="Installing the JTA feature into Karaf"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec10"/>Installing the JTA feature into Karaf</h3></div></div></div><p>We <a id="id532" class="indexterm"/>install a feature by executing the <code class="literal">feature:install</code> command with the feature's name as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt;  feature:install transaction</strong></span>
</pre></div><p>We can<a id="id533" class="indexterm"/> verify the installation by executing the <code class="literal">list –t 0 | grep -i transaction</code> command, which will list all installed transaction components and dependencies in Karaf (such as Apache Aries Transaction Blueprint and Apache Aries Transaction Manager). In addition, we can verify that <code class="literal">geronimo_jta_1.1_spec</code> has been installed by grepping on <code class="literal">jta</code>.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec199"/>How it works…</h2></div></div></div><p>The Apache Karaf community maintains an Apache Karaf features descriptor for JTA. The features descriptor file contains all of the essential bundles and dependencies required to install the transaction manager, which are shown in the following diagram:</p><div class="mediaobject"><img src="graphics/5081OS_07_02.jpg" alt="How it works…"/></div><p>When<a id="id534" class="indexterm"/> the JTA feature is installed (using the <code class="literal">feature:install</code> command), Karaf will use the appropriate URL handlers<a id="id535" class="indexterm"/> to obtain the required <a id="id536" class="indexterm"/>resources and install them in the container. Next, it attempts to bring them to a started state. If you execute the <code class="literal">list –t 0</code> command on the Karaf console, you will see the JTA and all other artifacts deployed into the<a id="id537" class="indexterm"/> container. We can depict the integration of JTA components into Karaf more simply by illustrating the key artifacts being deployed atop a standard Karaf installation. In this deployment, we see the Transaction Manager (JTA) deployed among the various JPA modules from the <span class="emphasis"><em>Installing OpenJPA modules in Apache Karaf</em></span> recipe.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec200"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Deploying applications as a feature</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Apache Karaf for System Builders">Chapter 1</a>, <span class="emphasis"><em>Apache Karaf for System Builders</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing OpenJPA modules in Apache Karaf</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Building a project with a persistence layer for deployment in Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Building a project with a persistence layer for deployment in Karaf</h1></div></div></div><p>Application<a id="id538" class="indexterm"/> developers often need to make <a id="id539" class="indexterm"/>use of a persistence layer in their projects; one of the preferred methodologies to perform this in Karaf is to make use of the Java Persistence API and OpenJPA.</p><p>In the <span class="emphasis"><em>Installing OpenJPA modules in Apache Karaf</em></span> recipe, we learned how to install OpenJPA in Karaf; in this recipe, we'll make use of the JPA and OpenJPA to build a simple application that persists recipes to a database using a <code class="literal">RecipeBookService</code> class, which will hide the complexities of data storage and retrieval from its users.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec201"/>Getting ready</h2></div></div></div><p>The<a id="id540" class="indexterm"/> ingredients of this recipe include <a id="id541" class="indexterm"/>the Apache Karaf distribution kit, access to JDK, and Internet connectivity. Sample code for this recipe is available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3</a>. Generally, you'll also need to perform the steps outlined in the <span class="emphasis"><em>Installing OpenJPA modules in Apache Karaf</em></span> recipe.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip30"/>Tip</h3><p>Please uninstall contents of the <span class="emphasis"><em>Building a project with a persistence layer and transaction support for deployment in Karaf</em></span> recipe before attempting this recipe as conflicts may occur. This recipe comes later in the chapter.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec202"/>How to do it…</h2></div></div></div><p>Building a project with a JPA persistence layer will require the following nine steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is generating a Maven-based bundle project. Create an empty Maven-based project. A <code class="literal">pom.xml</code> file containing the essential Maven coordinate information and a bundle packaging directive will suffice.</li><li class="listitem">The next step is adding dependencies to the POM file as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.servicemix.bundles&lt;/groupId&gt;
    &lt;artifactId&gt;
      org.apache.servicemix.bundles.commons-dbcp
    &lt;/artifactId&gt;
    &lt;version&gt;1.4_3&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.osgi&lt;/groupId&gt;
    &lt;artifactId&gt;org.osgi.core&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.osgi&lt;/groupId&gt;
    &lt;artifactId&gt;org.osgi.compendium&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.osgi&lt;/groupId&gt;
    &lt;artifactId&gt;org.osgi.enterprise&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
    &lt;artifactId&gt;geronimo-jpa_2.0_spec&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.openjpa&lt;/groupId&gt;
    &lt;artifactId&gt;openjpa&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.derby&lt;/groupId&gt;
    &lt;artifactId&gt;derby&lt;/artifactId&gt;
    &lt;version&gt;10.8.1.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;!-- custom felix gogo command --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.karaf.shell&lt;/groupId&gt;
    &lt;artifactId&gt;
      org.apache.karaf.shell.console
    &lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><p>For Karaf 3.0.0, we use OpenJPA 2.2.2 and OSGi version 5.0.0.</p></li><li class="listitem">The <a id="id542" class="indexterm"/>next step is adding build <a id="id543" class="indexterm"/>plugins. Our recipe requires two build plugins to be configured: OpenJPA and bundle.<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we configure the <code class="literal">openjpa-maven-plugin</code>. The <code class="literal">openjpa-maven-plugin</code> provides <a id="id544" class="indexterm"/>tasks for building and maintaining an OpenJPA-based project. We add to our POM file the following plugin configuration:<div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;openjpa-maven-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;addDefaultConstructor&gt;
      true
    &lt;/addDefaultConstructor&gt;
    &lt;enforcePropertyRestriction&gt;
      true
    &lt;/enforcePropertyRestriction&gt;
  &lt;/configuration&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;enhancer&lt;/id&gt;
      &lt;phase&gt;process-classes&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;enhance&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.openjpa&lt;/groupId&gt;
      &lt;artifactId&gt;openjpa&lt;/artifactId&gt;
      &lt;version&gt;2.2.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</pre></div><p>In <code class="literal">openjpa-maven-plugin</code>, given in the previous block of code, we instruct<a id="id545" class="indexterm"/> the plugin<a id="id546" class="indexterm"/> to perform an enhance process upon our entity classes to provide the persistence functionality. As stated by the OpenJPA project: "Build time enhancement is the recommended method to use with OpenJPA, as it is the fastest and most reliable method".</p></li><li class="listitem">Next, we configure <a id="id547" class="indexterm"/>the <code class="literal">maven-bundle-plugin</code>. We<a id="id548" class="indexterm"/> configure the <code class="literal">maven-bundle-plugin</code> to assemble our project code into an OSGi bundle. We add the following plugin configuration to our POM file:<div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;
  &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.4.0&lt;/version&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;instructions&gt;
      &lt;Bundle-SymbolicName&gt;
        ${project.artifactId}
      &lt;/Bundle-SymbolicName&gt;
      &lt;Meta-Persistence&gt;
        META-INF/persistence.xml
      &lt;/Meta-Persistence&gt;
      &lt;Bundle-Activator&gt;
        com.packt.jpa.demo.Activator
      &lt;/Bundle-Activator&gt;
      &lt;Export-Package&gt;
        com.packt.jpa.demo.api.*
      &lt;/Export-Package&gt;
      &lt;Import-Package&gt;
        org.osgi.service.blueprint;resolution:=optional,
        javax.persistence;version="[1.1,2)",
        javax.persistence.criteria;version="[1.1,2)",
        javax.sql,
        org.apache.commons.dbcp;version="[1.4,2)",
        org.apache.derby.jdbc,
        org.apache.felix.service.command,
        org.apache.felix.gogo.commands,
        org.apache.karaf.shell.console,
        *
      &lt;/Import-Package&gt;
    &lt;/instructions&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div><p>As highlighted in the previous code snippet, the <code class="literal">Meta-Persistence</code> tag will add an entry to our bundle's manifest file pointing to our <code class="literal">persistence.xml</code> file location (we'll create this resource in our next step). The import statements for the <code class="literal">javax.persistence</code>, <code class="literal">dbcp</code>, and <code class="literal">derby</code> packages are of greatest importance for our example project. The Felix and Karaf imports are required by the optional Karaf commands.</p></li></ol></div></li><li class="listitem">The next step is creating the persistence descriptor file. Create a directory tree <a id="id549" class="indexterm"/>as <code class="literal">src/main/resources/META-INF</code> in your project. We'll then create a file named <code class="literal">persistence.xml</code> in this folder. This file is shown in the following code <a id="id550" class="indexterm"/>snippet:<div class="informalexample"><pre class="programlisting">&lt;persistence 
             
             version="1.0"&gt;

  &lt;persistence-unit name="recipe" transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;
      org.apache.openjpa.persistence.PersistenceProviderImpl
    &lt;/provider&gt;

    &lt;non-jta-data-source&gt;
      osgi:service/javax.sql.DataSource/ (osgi.jndi.service.name=jdbc/demo)
    &lt;/non-jta-data-source&gt;

    &lt;class&gt;com.packt.jpa.demo.entity.Recipe&lt;/class&gt;
    &lt;exclude-unlisted-classes&gt;
      true
    &lt;/exclude-unlisted-classes&gt;

    &lt;properties&gt;

      &lt;!-- OpenJPA Properties --&gt;
      &lt;property name="openjpa.ConnectionDriverName" value="org.apache.derby.jdbc.ClientDriver.class"/&gt;
      &lt;property name="openjpa.ConnectionURL" value="jdbc:derby://localhost:1527/demo;create=true"/&gt;
      &lt;property name="openjpa.Multithreaded" value="true"/&gt;
      &lt;property name="openjpa.TransactionMode" value="managed"/&gt;
      &lt;property name="openjpa.ConnectionFactoryMode" value="managed"/&gt;
      &lt;property name="openjpa.LockManager" value="pessimistic(VersionCheckOnReadLock=true,VersionUpdateOnWriteLock=true)"/&gt;
      &lt;property name="openjpa.LockTimeout" value="30000"/&gt;
      &lt;property name="openjpa.jdbc.MappingDefaults" value="ForeignKeyDeleteAction=restrict, JoinForeignKeyDeleteAction=restrict"/&gt;
      &lt;property name="openjpa.LockManager" value="pessimistic(VersionCheckOnReadLock=true,VersionUpdateOnWriteLock=true)"/&gt;
      &lt;property name="openjpa.Log" value="DefaultLevel=INFO, Runtime=INFO, Tool=INFO, SQL=INFO"/&gt;
      &lt;property name="openjpa.jdbc.SynchronizeMappings" value="buildSchema"/&gt;
      &lt;property name="openjpa.jdbc.DBDictionary" value="derby"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre></div><p>The <a id="id551" class="indexterm"/>persistence descriptor<a id="id552" class="indexterm"/> file contains a multitude of configuration entries required by our application. The most important among them being the definition of the <code class="literal">persistence-unit</code> and <code class="literal">non-jta-data-source</code> objects; the former sets the data persistence to <code class="literal">RESOURCE_LOCAL</code>, and the latter sets the use of a JDBC service for non-transactional data storage. The various OpenJPA properties are beyond the scope of this book, but they are included here to provide a sample configuration. The more interesting part of the previous example is the reference of the datasource. Since the <code class="literal">persistence.xml</code> file only knows of JNDI lookup syntax for resources, the OSGi service of the datasource needs to be referenced in a JNDI way. This results in <code class="literal">osgi:service</code> being the JNDI lookup for an OSGi service that provides a <code class="literal">javax.sql.DataSource</code> interface where the filter matches the <code class="literal">osgi.jndi.service.name</code> value as equivalent to <code class="literal">jdbc/demo</code>.</p></li><li class="listitem">The next step is creating the Blueprint descriptor file. In your project, create the <code class="literal">src/main/resources/OSGI-INF</code> directory tree. We'll then create a file named <code class="literal">blueprint.xml</code> in this folder as follows:<div class="informalexample"><pre class="programlisting">&lt;blueprint default-activation="eager"
      
      
      
      &gt;

  &lt;!-- Define RecipeBookService Services, and expose them. --&gt;
  &lt;bean id="recipeBookService" class="com.packt.jpa.demo.dao.RecipeBookServiceDAOImpl"&gt;
    &lt;jpa:unit property="entityManagerFactory" unitname="recipe" /&gt;
  &lt;/bean&gt;

  &lt;service ref="recipeBookService" interface="com.packt.jpa.demo.api.RecipeBookService" /&gt;

  &lt;bean id="dataSource" class="org.apache.derby.jdbc.ClientDataSource" &gt;
    &lt;property name="databaseName" value="demo"/&gt;
    &lt;property name="createDatabase" value="create"/&gt;
  &lt;/bean&gt;

  &lt;service id="demoDataSource" ref="dataSource" interface="javax.sql.DataSource"&gt;
    &lt;service-properties&gt;
      &lt;entry key="osgi.jndi.service.name" value="jdbc/demo"/&gt;
      &lt;entry key="transactional" value="false"/&gt;
    &lt;/service-properties&gt;
  &lt;/service&gt;
&lt;/blueprint&gt;</pre></div><p>You should note the inclusion of the <code class="literal">DataSource</code> service as an OSGi service in this <code class="literal">blueprint.xml</code> file. It contains the service property <code class="literal">osgi.jndi.service.name</code> with the value <code class="literal">jdbc/demo</code>. This is the <code class="literal">DataSource</code> service that is referenced by the <code class="literal">persistence.xml</code> file.</p></li><li class="listitem">The <a id="id553" class="indexterm"/>next step is developing <a id="id554" class="indexterm"/>the OSGi service with the JPA backend. We've created the basic project structure and plumbed in configurations for the persistence and Blueprint descriptors; now we'll focus on the underlying Java code of our JPA-backed application. We break down this process into the following three steps:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is defining a service interface. The service interface will define the user API for our project. In our sample code, we implement a <code class="literal">RecipeBookService</code> class, which provides the methods required to interact with a collection of recipes. This is shown<a id="id555" class="indexterm"/> in the following <a id="id556" class="indexterm"/>code:<div class="informalexample"><pre class="programlisting">package com.packt.jpa.demo.api;

import java.util.Collection;
import com.packt.jpa.demo.entity.Recipe;

public interface RecipeBookService {

  public Collection&lt;Recipe&gt; getRecipes();

  public void addRecipe(String title, String ingredients);

  public void deleteRecipe(String title);

}</pre></div><p>The interface's implementation follows the standard Java conventions, requiring no special OSGi packages.</p></li><li class="listitem">The next step is implementing a service DAO. Now that we have defined our service interface, we'll provide an implementation as a DAO. Consider the following code:<div class="informalexample"><pre class="programlisting">public class RecipeBookServiceDAOImpl implements RecipeBookService {

  @PersistenceUnit(unitName="recipe")
  private EntityManagerFactory factory;

  public void setEntityManagerFactory(EntityManagerFactory factory) {
    this.factory = factory;
  }

  @Override
  public List&lt;Recipe&gt; getRecipes() {
    List&lt;Recipe&gt; result = new ArrayList&lt;Recipe&gt;();
    EntityManager entityManager = factory.createEntityManager();
    EntityTransaction entityTransaction = entityManager.getTransaction();
    entityTransaction.begin();
    result = entityManager.createQuery("select r from RECIPE r", Recipe.class).getResultList();
    entityTransaction.commit();
    return result;
  }

  @Override
  public void addRecipe(String title, String ingredients) {
    EntityManager entityManager = factory.createEntityManager();
    EntityTransaction entityTransaction = entityManager.getTransaction();
    entityTransaction.begin();
    entityManager.persist(new Recipe(title, ingredients));
    entityTransaction.commit();
}

  @Override
  public void deleteRecipe(String title) {
    EntityManager entityManager = factory.createEntityManager();
    EntityTransaction entityTransaction = entityManager.getTransaction();
    entityTransaction.begin();
    entityManager.remove(entityManager.getReference(Recipe.class, title));
    entityTransaction.commit();
  }
}</pre></div><p>The <code class="literal">EntityManagerFactory</code> function will be wired into our DAO using Blueprint. Each service method implemented in our DAO service implementation will require management of the JPA-style transaction elements.</p></li><li class="listitem">The <a id="id557" class="indexterm"/>next step<a id="id558" class="indexterm"/> is implementing entities. Finally, we implement our entities as shown in the following code:<div class="informalexample"><pre class="programlisting">package com.packt.jpa.demo.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity( name = "RECIPE" )
@Table( name = "RECIPES" )
public class Recipe {

  @Id
  @Column(nullable = false)
  private String title;

  @Column(length=10000)
  private String ingredients;

  public Recipe() {
  }

  public Recipe(String title, String ingredients) {
    super();
    this.title = title;
    this.ingredients = ingredients;
  }

  public String getTitle() {
    return title;
  }
  public void setTitle(String title) {
    this.title = title;
  }
  public String getIngredients() {
    return ingredients;
  }
  public void setIngredients(String ingredients) {
    this.ingredients = ingredients;
  }

  public String toString() {
    return "" + this.title + " " + this.ingredients;
  }
}</pre></div><p>Our <code class="literal">Entity</code> class is where our objects meet their persistent storage definition requirement. To store an object into a database, we must describe their storage in terms of tables, columns, and so on, and override the <code class="literal">equals</code> and <code class="literal">hashCode</code> methods.</p></li></ol></div></li><li class="listitem">The <a id="id559" class="indexterm"/>next step is the optional <a id="id560" class="indexterm"/>creation of Karaf commands to directly test the persistence service. To simplify manual testing of our <code class="literal">RecipeBookService</code> class, we can create a set of custom Karaf commands, which will exercise our JPA-backed data storage and retrieval operations. Sample implementations of these commands are available from the book's website. Of particular interest is how they obtain a reference to the <code class="literal">RecipeBookService</code> class and make calls to the service. Now, we must wire the command implementation into Karaf via Blueprint as follows:<div class="informalexample"><pre class="programlisting">&lt;!-- Apache Karaf Commands --&gt;
&lt;command-bundle &gt;
  &lt;command&gt;
    &lt;action class="com.packt.jpa.demo.commands.AddRecipe"&gt;
      &lt;property name="recipeBookService" ref="recipeBookService"/&gt;
    &lt;/action&gt;
  &lt;/command&gt;
  &lt;command&gt;
    &lt;action class="com.packt.jpa.demo.commands.RemoveRecipe"&gt;
      &lt;property name="recipeBookService" ref="recipeBookService"/&gt;
    &lt;/action&gt;
  &lt;/command&gt;
  &lt;command&gt;
    &lt;action class="com.packt.jpa.demo.commands.ListRecipes"&gt;
      &lt;property name="recipeBookService" ref="recipeBookService"/&gt;
    &lt;/action&gt;
  &lt;/command&gt;
&lt;/command-bundle&gt;</pre></div><p>Each of our custom command's implementation classes are wired to our <code class="literal">recipeBookService</code> instance.</p></li><li class="listitem">The next step is deploying the project into Karaf. Deploying our application in Karaf will require the following three steps: installing a JDBC driver for a backing database, installing JNDI, and adding our project bundle to the container. For our example project, we'll use Apache Derby as our JDBC provider.<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We can install the JDBC driver using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; install -s mvn:org.apache.derby/derbyclient/10.8.1.2</strong></span>
</pre></div><p>Once installed, you can check whether the client driver is available by executing the classes command and grepping upon the <code class="literal">ClientDataSource</code> implementation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip31"/>Tip</h3><p>This demo <a id="id561" class="indexterm"/>will require a running instance of the Derby database. See <a class="ulink" href="http://db.apache.org/derby/papers/DerbyTut/install_software.html">http://db.apache.org/derby/papers/DerbyTut/install_software.html</a> for a short tutorial on installing Apache Derby.</p></div></div></li><li class="listitem">We <a id="id562" class="indexterm"/>need to install <a id="id563" class="indexterm"/>the <code class="literal">jndi</code> feature using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:install jndi</strong></span>
</pre></div><p>Once <a id="id564" class="indexterm"/>the <code class="literal">jndi</code> feature is installed in Karaf, we'll be able to use the <code class="literal">jndi:names</code> command to view the configured datasources in the container.</p></li><li class="listitem">We install our project bundle by executing the <code class="literal">install</code> command on its Maven coordinates as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; install –s mvn:com.packt/jpa-only/1.0.0-SNAPSHOT</strong></span>
</pre></div><p>We can verify the installation by executing the <code class="literal">list –t 0 | grep -i JPA-only</code> command, which will list the bundle state of our project.</p></li></ol></div></li><li class="listitem">The last step is testing the project. We've now deployed a large collection of bundles into the Karaf container; we can test our integration using the supplied Karaf test commands as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; test:addrecipe "Simple Chocolate Chip Cookies" "2/3 cup butter, 1 cup brown sugar, 2 eggs, 2 tbsp milk, 2 cups flour, 1 tsp baking powder, 1/4 tsp baking soda, 1/2 tsp vanilla, 1 cup chocolate chips. Whip the butter and sugar together, then add in the eggs and beat well. In a second bowl combine the dry ingredients. Make sure to thoroughly mix together the flour, baking soda and powder. Add the dry ingredients, milk, and vanilla into the butter , sugar, and egg mixture. Beat until dough is consistent. You may now preheat your oven to 375F. Drop teaspoon full amounts of dough onto greased or lined cookie sheets. Bake for 10 to 12 minutes. This recipe should yield between three to four dozen cookies."</strong></span>
<span class="strong"><strong>Executing command addrecipe</strong></span>
<span class="strong"><strong>Recipe added!</strong></span>
<span class="strong"><strong>karaf@root()&gt;</strong></span>
</pre></div><p>Using the supplied custom Karaf commands, we can add recipe entries to our database. In the previous example, we added a recipe for chocolate chip cookies. Consider the following command line snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; test:listrecipes</strong></span>
<span class="strong"><strong>Executing command list recipes</strong></span>
<span class="strong"><strong> Simple Chocolate Chip Cookies 2/3 cup butter, 1 cup brown sugar, 2 eggs, 2 tbsp milk, 2 cups flour, 1 tsp baking powder, 1/4 tsp baking soda, 1/2 tsp vanilla, 1 cup chocolate chips. Whip the butter and sugar together, then add in the eggs and beat well. In a second bowl combine the dry ingredients. Make sure to thoroughly mix together the flour, baking soda and powder. Add the dry ingredients, milk, and vanilla into the butter , sugar, and egg mixture. Beat until dough is consistent. You may now preheat your oven to 375F. Drop teaspoon full amounts of dough onto greased or lined cookie sheets. Bake for 10 to 12 minutes. This recipe should yield between three to four dozen cookies.</strong></span>
<span class="strong"><strong>karaf@root()&gt;</strong></span>
</pre></div><p>The <code class="literal">listrecipes</code> custom command performs a select all function upon <a id="id565" class="indexterm"/>our recipe data<a id="id566" class="indexterm"/> store, displaying <a id="id567" class="indexterm"/>all entries on the console. Alternatively, you could use any JDBC tool of your choice to verify that your recipe entries are persisted to disk.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>
<span class="strong"><strong>Simplifying datasource administration with the JDBC feature</strong></span>
</p><p>Apache Karaf 3.0 contains a JDBC feature that provides many useful commands for interacting with datasources. Try installing the <code class="literal">jdbc</code> feature and then executing the following commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">karaf@root()&gt; feature:install jdbc</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">karaf@root()&gt; jdbc:datasources</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">karaf@root()&gt; jdbc:tables jdbc/demo</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">karaf@root()&gt; jdbc:query jdbc/demo "select * from RECIPES"</code><p>Output from these commands are not formatted to small consoles, so you may need to expand your terminal to comfortably display results.</p></li></ul></div></div></div></li></ol></div><p>Finally, even after restarting Karaf, all of your recipe entries will be available.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec203"/>How it works…</h2></div></div></div><p>Observing <a id="id568" class="indexterm"/>from a high-level point of view, our persistence layer works by integrating several Apache Aries libraries and OpenJPA together in the Karaf container. The following diagram shows this high-level view:</p><div class="mediaobject"><img src="graphics/5081OS_07_03.jpg" alt="How it works…"/></div><p>The<a id="id569" class="indexterm"/> key interactions in this design are the discovery and wiring of the persistence unit and Blueprint descriptor and wiring the entity and data access objects. This results in having our persistence bundle interacting with the JPA service implementation (OpenJPA), which in turn interacts with the EntityManagerFactory interface (from the persistence unit) wired into our DAO service implementation in the Blueprint descriptor file. These key deployment artifacts are illustrated in the following diagram:</p><div class="mediaobject"><img src="graphics/5081OS_07_04.jpg" alt="How it works…"/></div><p>From <a id="id570" class="indexterm"/>the point of view of the architecture <a id="id571" class="indexterm"/>of our persistence-enabled bundle, its operation depends upon the interaction of the bundle manifest, persistent configuration, and Blueprint wiring.</p><p>The <code class="literal">Meta-Persistence</code> manifest header triggers the processing of the bundles' persistence configuration, which in turn configures JNDI data source declaration, entity discovery, and JDBC integration.</p><p>The Blueprint descriptor wires together our DAO service interface and implementation, as well <a id="id572" class="indexterm"/>as further defining datasources. A key feature of this service wiring is linking the persistence unit to the DAO service implementation. The DAO service<a id="id573" class="indexterm"/> uses the persistence unit's <code class="literal">EntityManagerFactory</code> function to enable entity access, manipulation, and transactions.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec204"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building a project with a persistence layer and transaction support for deployment in Karaf</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Building a project with a persistence layer and transaction support for deployment in Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Building a project with a persistence layer and transaction support for deployment in Karaf</h1></div></div></div><p>Transaction support for your JPA-persisted data can be simply added by introducing Apache <a id="id574" class="indexterm"/>Aries JTA modules to your project. The <a id="id575" class="indexterm"/>JTA components provide a transaction manager that coordinates data storage and retrieval.</p><p>In the <span class="emphasis"><em>Building a project with a persistence layer for deployment in Karaf</em></span> recipe, we learned how to use JPA and OpenJPA to build a simple application that persists recipes to a database using a <code class="literal">RecipeBookService</code> class. In this recipe, we'll add container-based transaction management via JTA.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec205"/>Getting ready</h2></div></div></div><p>The ingredients of this recipe include the Apache Karaf distribution kit, access to JDK, and Internet connectivity. Sample code for this recipe is available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4</a>. Generally, you'll also need to perform the steps outlined in the <span class="emphasis"><em>Building a project with a persistence layer for deployment in Karaf</em></span> recipe and the <span class="emphasis"><em>Installing Apache Aries JTA modules in Apache Karaf</em></span> recipe.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note134"/>Note</h3><p>Please uninstall contents of the <span class="emphasis"><em>Building a project with a persistence layer for deployment in Karaf</em></span> recipe before attempting this recipe as conflicts may occur.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec206"/>How to do it…</h2></div></div></div><p>Given a <a id="id576" class="indexterm"/>JPA-based project as outlined in the <span class="emphasis"><em>Building a project with a persistence layer for deployment in Karaf</em></span> recipe, we can add Java transaction support using the following five steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is updating the persistence to JTA. First, we switch the transaction type from <code class="literal">RESOURCE_LOCAL</code> to <code class="literal">JTA</code>; this switches the project from self-managed persistence to container-managed. This is shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;persistence-unit name="recipe" transaction-type="JTA"&gt;

  &lt;provider&gt;org.apache.openjpa.persistence.PersistenceProviderImpl&lt;/provider&gt;

  &lt;jta-data-source&gt;
    osgi:service/javax.sql.XADataSource/(osgi.jndi.service.name=jdbc/demoxa)
  &lt;/jta-data-source&gt;
  &lt;non-jta-data-source&gt;
    osgi:service/javax.sql.DataSource/(transactional=false)
  &lt;/non-jta-data-source&gt;

  &lt;class&gt;com.packt.jpa.demo.entity.Recipe&lt;/class&gt;
  &lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes&gt;</pre></div><p>After switching the transaction type, we need to add a <code class="literal">jta-data-source</code>. The previous example registers <code class="literal">jdbc/demoxa</code> as a service with JNDI. The <code class="literal">non-jta-data-source</code> used in the previous recipe is retained to help show the progression from the basic design to container-managed transactions; it may be removed during development.</p></li><li class="listitem">The<a id="id577" class="indexterm"/> next step is updating the Blueprint<a id="id578" class="indexterm"/> descriptor. Switching <a id="id579" class="indexterm"/>our transaction type from <code class="literal">RESOURCE_LOCAL</code> to <code class="literal">JTA</code> changes how we will wire our <code class="literal">RecipeBookService</code> class. This is shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;!-- Define RecipeBookService Service, and expose them. --&gt;
&lt;bean id="recipeBookService" class="com.packt.jpa.demo.dao.RecipeBookServiceDAOImpl"&gt;
  &lt;tx:transaction method="*" value="Required" /&gt;
  &lt;jpa:context property="entityManager" unitname="recipe" /&gt;
&lt;/bean&gt;</pre></div><p>We change the <code class="literal">jpa</code> property to reference the context instead of the unit and now add in a reference to the container-provided <code class="literal">entityManager</code> interface. The presence of JTA-style transactions also means that we can now include definitions for XA-capable data sources. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="xaDataSource" class="org.apache.derby.jdbc.ClientXADataSource"&gt;
  &lt;property name="databaseName" value="demo"/&gt;
  &lt;property name="createDatabase" value="create" /&gt;
&lt;/bean&gt;</pre></div><p>We wire together data-source-specific XA drivers with <code class="literal">XADataSource</code> service instantiations as follows:</p><div class="informalexample"><pre class="programlisting">&lt;service ref="xaDataSource" 
         interface="javax.sql.XADataSource"&gt;
  &lt;service-properties&gt;
    &lt;entry key="osgi.jndi.service.name" value="jdbc/demoxa"/&gt;
    &lt;entry key="transactional" value="true"/&gt;
  &lt;/service-properties&gt;
&lt;/service&gt;

&lt;!-- JTA Transaction Manager setup. --&gt;
&lt;reference id="txManager" 
           interface="javax.transaction.TransactionManager" 
           availability="mandatory"/&gt;</pre></div><p>Finally, we add a service reference for the container-provided <code class="literal">TransactionManager</code> interface, and set its presence to <code class="literal">mandatory</code>.</p></li><li class="listitem">The next <a id="id580" class="indexterm"/>step is updating the service DAO. The <a id="id581" class="indexterm"/>changes to our persistence<a id="id582" class="indexterm"/> and Blueprint configuration to JTA-style transactions necessitates changes to our DAO service implementation. Our service does not need to create and manage its own transactions, as entities are now accessed through the container-provided <code class="literal">EntityManager</code> function. Consider the following code:<div class="informalexample"><pre class="programlisting">public class RecipeBookServiceDAOImpl implements RecipeBookService {

  private EntityManager em;

  public void setEntityManager(EntityManager em) {
    this.em = em;
  }

  @Override
  public List&lt;Recipe&gt; getRecipes() {
    List&lt;Recipe&gt; result = new ArrayList&lt;Recipe&gt;();
    result = em.createQuery("select r from RECIPE r", Recipe.class).getResultList();
    return result;
  }

  @Override
  public void addRecipe(String title, String ingredients) {
    em.persist(new Recipe(title, ingredients));
  }

  @Override
  public void deleteRecipe(String title) {
    em.remove(em.getReference(Recipe.class, title));
  }
}</pre></div><p>A result of this subtle change is that our service methods are simplified.</p></li><li class="listitem">The next step is deploying the project into Karaf. Deploying our application into Karaf will require two steps (in addition to those outlined in the <span class="emphasis"><em>Building a project with a persistence layer for deployment in Karaf</em></span> recipe): installing transaction support and adding our project bundle to the container. JTA will require <a id="id583" class="indexterm"/>a container-based transaction <a id="id584" class="indexterm"/>manager; we can install<a id="id585" class="indexterm"/> one using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:install transaction</strong></span>
</pre></div><p>Once installed, we can now deploy our project bundles using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt;  install –s mvn:com.packt/jpa-jta/1.0.0-SNAPSHOT</strong></span>
</pre></div><p>We can verify the installation by executing the <code class="literal">list –t 0 | grep -i JPA-JTA</code> command, which will list the bundle state of our project.</p></li><li class="listitem">The<a id="id586" class="indexterm"/> final step is testing the project. We've now deployed a large collection of bundles into the Karaf container; we can test our integration using the supplied Karaf test commands as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; test:addrecipe "Recipe-Title" "Ingredients."</strong></span>
<span class="strong"><strong>Executing command addrecipe</strong></span>
<span class="strong"><strong>Recipe added!</strong></span>
<span class="strong"><strong>karaf@root()&gt;</strong></span>
</pre></div><p>In the previous code, we have added a simple placeholder entry into our recipe's data store. Now, consider the following command line snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; test:listrecipes</strong></span>
<span class="strong"><strong>Executing command list recipes</strong></span>
<span class="strong"><strong>Recipe-Title Ingredients.</strong></span>
<span class="strong"><strong>karaf@root()&gt;</strong></span>
</pre></div><p>Issuing the <code class="literal">listrecipes</code> command, we retrieve our previous entry.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip35"/>Tip</h3><p>See the JDBC feature note in the <span class="emphasis"><em>Building a project with a persistence layer for deployment in Karaf</em></span> recipe for Karaf console commands to verify data source information.</p></div></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec207"/>How it works…</h2></div></div></div><p>The <a id="id587" class="indexterm"/>operation of this persistence-enabled bundle is very <a id="id588" class="indexterm"/>similar to that of our previous recipe. The <a id="id589" class="indexterm"/>vital changes being the introduction of the JTA transaction manager, updating the persistence unit to JTA, adding the XA datasource, then wiring an <code class="literal">EntityManager</code> function into the DAO service implementation and requiring the transaction manager's availability.</p><p>Operationally, transactions are coordinated by the container's transaction manager—this allows for more complex transactions with more varied enlisted resources than standard JPA-style transactions.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec208"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For an alternative persistence layer approach, see <a class="link" href="ch08.html" title="Chapter 8. Providing a Big Data Integration Layer with Apache Cassandra">Chapter 8</a>, <span class="emphasis"><em>Providing a Big Data Integration Layer with Apache Cassandra</em></span>.</li></ul></div></div></div></body></html>