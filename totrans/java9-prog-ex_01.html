<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting Started with Java 9</h1>
            

            <article>
                
<p class="calibre2">You want to learn Java and you have a good reason for it. Java is a modern and well-established application programming language, which is widely used in many industries, be it telecommunication, finance, or something else. Java developer positions are the most numerous and, probably, the best paid. This, among other things, makes the language lucrative for young professionals to learn. On the other hand, this is not without reason. Java language, the tools, and the whole infrastructure around it is complex and compound. Becoming a Java professional does not happen in a day or week; it is a work of many years. To be a Java expert, you need to know not only about the programming language but also about object-oriented programming principles, open source libraries, application servers, network, databases, and many other things that you can become an expert in. Nevertheless, learning the language is an absolute must that all other practices should build on. Through this book, you will be able to learn Java version 9 and a bit more.</p>
<p class="calibre2">In this chapter, you will be introduced to the Java environment and given step-by-step instructions on how to install it, edit sample code, compile, and run Java. You will get acquainted with the basic tools that help development, be they are a part of Java or are provided by other vendors. We will cover the following topics in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">Introduction to Java</li>
<li class="calibre15">Installing Windows, Linux, and Mac OS X</li>
<li class="calibre15">Executing <kbd class="calibre11">jshell</kbd></li>
<li class="calibre15">Using other Java tools</li>
<li class="calibre15">Using integrated development environment</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting started with Java</h1>
            

            <article>
                
<p class="calibre2">It is like going through a path in a forest. You can focus on the gravel of the road but it is pointless. Instead, you can enjoy the view, the trees, the birds, and the environment around you, which is more enjoyable. This book is similar as I won't be focusing only on the language. From time to time, I will cover topics that are close to the road and will give you some overview and directions on where you can go further after you finish this book. I will not only teach you the language but also talk a bit about algorithms, object-oriented programming principles, tools that surround Java development, and how professionals work. This will be mixed with the coding examples that we will follow. Lastly, the final chapter will be fully devoted to the topic, what to learn next and how to go further to become a professional Java developer.</p>
<p class="calibre2">By the time this book gets into print, Java will have completed 22 years. <a href="http://www.oracle.com/technetwork/java/javase/overview/javahistory-index-198355.html" class="calibre6"><span>http://www.oracle.com/technetwork/java/javase/overview/javahistory-index-198355.html</span></a>. The language has changed a lot during this period and got better. The real question to ask is not how long has it been here, but rather how long will it stay? Is it still worth learning this language? There are numerous new languages that have been developed since Java was born (<span><a href="http://blog.takipi.com/java-vs-net-vs-python-vs-ruby-vs-node-js-who-reigns-the-job-market/" class="calibre6">http://blog.takipi.com/java-vs-net-vs-python-vs-ruby-vs-node-js-who-reigns-the-job-market/</a></span>). These languages are more modern and have functional programming features, which, by the way, Java has also had since version 8. Many say that Java is the past—the future is Scala, Swift, Go, Kotlin, JavaScript, and so on. You can add many other languages to this list, and for each, you can find a blog article that celebrates the burial of Java. There are two answers to this concern-one is a pragmatic business approach, the other is more engineering:</p>
<ul class="calibre14">
<li class="calibre15">Considering that COBOL is still actively used in the finance industry and COBOL developers are perhaps better paid than Java developers, it is not too risky to say that as a Java developer, you will find positions in the next 40 years. Personally, I would bet more than a 100 years, but considering my age, it will not be fair predicting more than 20 to 40 years ahead.</li>
<li class="calibre15">Java is not only a language; it is also a technology that you will learn a bit about from this book. The technology includes the <strong class="calibre1">Java Virtual Machine</strong> (<strong class="calibre1">JVM</strong>), which is usually referred to as JVM, and gives the runtime environment for many languages. Kotlin and Scala, for example, cannot run without JVM. Even if Java will be adumbrated, JVM will still be a number one player in the enterprise scene.</li>
</ul>
<p class="calibre2">To understand and learn the basic operation of JVM is almost as important as the language itself. Java is a compiled and interpreted language. It is a special beast that forges the best of both worlds. Before Java, there were interpreted and compiled languages.</p>
<p class="calibre2">Interpreted languages are read from the source code by the interpreter and then the interpreter executes the code. In each of these languages, there is some preliminary lexical and syntax analysis step; however, after that, the interpreter, which, as a program itself, is executed by the processor and the interpreter continuously, interprets the program code to know what to do. Compiled languages are different. In such a case, the source code is compiled to binary (<kbd class="calibre11">.exe</kbd> file on Windows platforms), which the operating system loads and the processor directly executes. Compiled programs usually run faster, but there is usually a slower compilation phase that may make the development slower, and the execution environment is not so flexible. Java combined the two approaches.</p>
<p class="calibre2">To execute a Java program, the Java source code has to be compiled to the JVM byte code (<kbd class="calibre11">.class</kbd> file), which is loaded by JVM and is interpreted or compiled. Hmm... is it interpreted or compiled? The thing that came with Java is the <strong class="calibre1">Just in Time (JIT)</strong> compiler. This makes the phase of the compilation that is calculation-intensive and the compilation for compiled languages relatively slow. JVM first starts to interpret the Java byte code and, while doing that, it keeps track of execution statistics. When it gathers enough statistics about code executions, it compiles to native code (for example, x86 code on an Intel/AMD platform) for direct execution of the parts of code that are executed frequently and keeps interpreting the code fragments that are rarely used. After all, why waste expensive CPU time to compile some code that is hardly ever used? (For example, code that reads configuration during startup and does not execute again unless the application server is restarted.) Compilation to the byte code is fast and code generation is done only for the segments that pay off.</p>
<p class="calibre2">It is also interesting that JIT uses the statistics of the code execution to optimize the code. If, for example, it sees that some conditional branch is executed in 99% of the cases and the other branch is executed only in 1%, then it will generate native code that runs fast, thus favoring the frequent branch. If the behavior of that part of the program changes by time and the statistic shows that the ratios changed, the JIT automatically recompiles the byte code from time to time. This is all automatic and behind the scenes.</p>
<p class="calibre2">In addition to the automatic compilation, there is also an extremely important feature of JVM-it manages the memory for the Java program. The execution environment of modern languages do that and Java was the first mainstream language that had an automatic garbage collection (GC). Before Java, I was programming in C for 20 years and it was a great pain to keep track of all memory allocation and not to forget to release the memory when the program no longer needed it. Forgetting memory allocation at a single point in the code and the long running program was eating up all memory slowly. Such problems practically ceased to exist in Java. There is a price that we have to pay for it—GC needs processor capacity and some extra memory, but that is something we are not short of in most of the enterprise applications. Some special programs, like real-time embedded systems that control the brakes of a heavy-duty lorry may not have that luxury. Those are still programmed in assembly or C. For the rest of us, we have Java, and though it may seem strange for many professionals, even <em class="calibre12">almost-real-time</em> programs, such as high-frequency trading applications, are written in Java.</p>
<p class="calibre2">These applications connect through the network to the stock exchange and they sell and buy stocks responding to market change in milliseconds. Java is capable of doing that. The runtime environment of Java that you will need to execute a compiled Java code, which also includes the JVM itself, contains code that lets Java programs access the network, files on disks, and other resources. To do this, the runtime contains high-level classes that the code can instantiate, execute, and which do the low-level jobs. You will also do this. It means that the actual Java code does not need to handle IP packets, TCP connections, or even HTTP handling when it wants to use or provide a REST service in some microservices architecture. It is already implemented in the runtime libraries, and all the application programmer has to do is to include the classes in the code and use the APIs they provide on an abstraction level that matches the program. When you program in Java, you can focus on the actual problem you want to solve, which is the <em class="calibre12">business</em> code and not the low-level system code. If it is not in the standard library, you will find it in some product in some external library, and it is also very probable that you will find an open source solution for the problem.</p>
<p class="calibre2">This is also a strong point of Java. There is a vast number of open source libraries available for all the different purposes. If you cannot find a library fitting your problem if you start to code some low-level code, then probably you are doing something wrong. There are topics in this book that are important, such as class loaders or reflection, not because you have to use them every day but rather because they are used by frameworks, and knowing them helps understand how these frameworks work. If you cannot solve your problem without using reflection or writing your own class loader or program multithread directly, then you probably chose the wrong framework. There is almost certainly a good one: Apache project, Google, and many other important players in the software industry publish their Java libraries as open source.</p>
<p class="calibre2">This is also true for multithread programming. Java is a multithread programming environment from the very beginning. The JVM and the runtime supports programs that execute the code. The execution runs parallel on multiple threads. There are runtime language constructs that support parallel executing programs starting at the very low level to high abstraction. Multithread code utilizes the multicore processors, which are more effective. These processors are more and more common. 20 years ago, only high-end servers had multiple processors and only Digital Alpha processors had 64-bit architecture and CPU clock above 100 MHz. 10 years ago, multiprocessor structure was common on the server side, and about 5 years ago, multicore processors were on some desktops and on notebooks. Today, even mobile phones have them. When Java was started in 1995, the geniuses who created it had seen this future.</p>
<p class="calibre2">They envisioned Java to be a <em class="calibre12">write once, run anywhere</em> language. At that time, the first target for the language was applet running in the browser. Today, many think (and I also share this opinion) that applets were a wrong target, or at least things were not done in the right way. As for now, you will meet applets on the Internet less frequently than Flash applications or dinosaurs.</p>
<p class="calibre2">However, at the same time, the Java interpreter was also executing server and client applications without any browser; furthermore, as the language and the executing environment developed, these application areas became more and more relevant. Today, the main use of Java is enterprise computing and mobile applications mainly for the Android platform; for the future, the use of the environment is growing in embedded systems as the <strong class="calibre1">Internet of things</strong> (<strong class="calibre1">IoT</strong>) comes more and more into picture.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Installing Java</h1>
            

            <article>
                
<p class="calibre2">To develop, compile, and execute Java programs, you will need the Java execution environment. As the operating systems that we usually use for software development do not contain the language preinstalled, you will have to download it. Although, there is multiple implementation of the language, I recommend that you download the official version of the software from Oracle. The official site for java is <a href="http://java.com" class="calibre6"><span>http://java.com</span></a> and this is the site from where the latest release of the language can be downloaded. At the time of writing this book, the 9th version of Java is not yet released. An early pre-release version is accessible via <span><a href="http://jdk9.java.net/" class="calibre6">http://jdk9.java.net/</a>download</span>. Later the release versions will also be available from here.</p>
<div class="packtfigure"><img class="image-border" src="../images/00005.jpeg"/></div>
<p class="calibre2">What you can download from here is a so called early access version of the code that is available only to experiment with it, and no professionals should use it for real professional purposes</p>
<p class="calibre2">On the page, you have to click on the radio button to accept the license. After that, you can click on the link that directly starts the download of the installation kit. The license is a special early access license version that you, as a professional, should carefully read, understand, and accept only if you are agreeable with the terms.</p>
<p class="calibre2">There is a separate installation kit for Windows 32 and 64 bit systems, Mac OS X, Linux 32 and 64 bit versions, Linux for ARM processor, Solaris for SPARC processor systems, and Solaris x86 versions. As it is not likely that you will use Solaris, I will detail the installation procedure only for Windows, Linux, and Mac OS X. In later chapters, the samples will always be Mac OS X, but since Java is a <em class="calibre12">write once, run anywhere</em> language, there is no difference after the installation. The directory separator may be slanted differently, the classpath separator character is a semicolon on Windows instead of a colon, and the look and feel of the Terminal or command application is also different. However, where it is important, I will try not to forget to mention it.</p>
<p class="calibre2">To confuse you, the Java download for each of these operating system versions lists a link for the JRE and one for the JDK. <strong class="calibre1">JRE</strong> stands for <strong class="calibre1">Java Runtime Environment</strong> and it contains all the tools and executables that are needed to run Java programs. <strong class="calibre1">JDK</strong> is the <strong class="calibre1">Java Development Kit</strong> that contains all the tools and executables that are needed to develop Java programs including the execution of the Java program. In other words, JDK contains its own JRE. For now, all you need to do is download the JDK.</p>
<p class="calibre2">There is one important point of the installation that is the same on each of the three operating systems that you have to be prepared for before the installation: to install Java, you should have administrative privileges.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Installation on Windows</h1>
            

            <article>
                
<p class="calibre2">The installation process on Windows starts by double clicking on the downloaded file. It will start the installer that will present you a welcome screen.</p>
<div class="packtfigure"><img class="image-border1" src="../images/00006.jpeg"/></div>
<p class="calibre2">Pressing the <span>Next</span> button we get a window where you can select the parts you want to install. Let's leave here the default selection, which means that we install all the downloaded parts of Java and press the button <span>Next</span>. The following window is where we can select the destination folder for the installation.</p>
<div class="packtfigure"><img class="image-border2" src="../images/00007.jpeg"/></div>
<p class="calibre2">As for now we do not change the directory selected by the installer. Press <span>Next</span>. Later, when you become a professional Java developer, you may decide to install Java to a different location but then you will already have to know what you are doing.</p>
<p class="calibre2">You may need to click the <span>Next</span> button a few times and then the installer finishes. Provide the administrative password when asked and voila! Java is installed. This is really the very usual Windows installation process.</p>
<p class="calibre2">The last step is to set the environment variable <kbd class="calibre11">JAVA_HOME</kbd>. To do that in Windows we have to open the control center and select the <span>Edit environment variables for your account</span> menu.</p>
<div class="packtfigure"><img class="image-border3" src="../images/00008.jpeg"/></div>
<p class="calibre2">This will open a new window that we should use to create a new environment variable for the current user.</p>
<div class="packtfigure"><img class="image-border4" src="../images/00009.jpeg"/></div>
<p class="calibre2">The name of the new variable has to be <kbd class="calibre11">JAVA_HOME</kbd> and the value should point to the installation directory of the JDK.</p>
<div class="packtfigure"><img class="image-border5" src="../images/00010.jpeg"/></div>
<p class="calibre2">This value on most of the systems is C:Program FilesJavajdk-9. This is used by many Java programs and tools to locate the Java runtime.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Installation on MAC OS X</h1>
            

            <article>
                
<p class="calibre2">In this section, we will take look at how to install Java step-by-step on an OS X platform. I will describe the installation process for the released version available at the time of writing this book. As for now, the Java 9 early access version is a bit tricky to install. It is probable that version Java 9 will have similar or the same install steps as Java 8 update 92 has.</p>
<p class="calibre2">The OS X version of Java comes in the form of a <kbd class="calibre11">.dmg</kbd> file. This is a packaging format of OS X. To open it, simply double click on the file in the <kbd class="calibre11">Download</kbd> folder where the browser saves it and the operating system will mount the file as a read-only disk image.</p>
<div class="packtfigure"><img class="image-border6" src="../images/00011.jpeg"/></div>
<p class="calibre2">There is only one file on this disk: the installation image. Double click on the file name or icon in the Finder application and the installation process will start.</p>
<div class="packtfigure"><img class="image-border7" src="../images/00012.jpeg"/></div>
<p class="calibre2">The first screen opening is a welcome screen. Click <span>Continue</span> and you will see the <span>Summary</span> page that displays what will be installed.</p>
<p class="calibre2">It is not a surprise that you will see a standard Java installation. This time, the button is called <span>Install</span>. Click on it and you will see the following:</p>
<div class="packtfigure"><img class="image-border8" src="../images/00013.jpeg"/></div>
<p class="calibre2">This is the time when you have to provide the login parameters for the administrative user—a username and password. When provided, installation starts and, in a few seconds, you will see a <a class="calibre6"><span>Summary</span> page</a>.</p>
<div class="packtfigure"><img class="image-border9" src="../images/00014.jpeg"/></div>
<p class="calibre2">Click <span>Close</span> and you are ready. You have Java installed on your Mac. Optionally, you can dismount the installation disk and, sometime later, you can also delete the <kbd class="calibre11">.dmg</kbd> file. You will not need that, and in case you do, you can download it any time from Oracle.</p>
<p class="calibre2">The last thing is to check whether the installation was okay. Proof of the pudding is eating it. Start a Terminal window and type <kbd class="calibre11">java -version</kbd> at the prompt and Java will tell you the version installed.</p>
<p class="calibre2">On the next screenshot you can see the output on my workstation and also the Mac OS commands that are handy to switch between the different versions of Java:</p>
<div class="packtfigure"><img class="image-border10" src="../images/00015.jpeg"/></div>
<p class="calibre2">On the screenshot, you can see that I have installed the Java JDK 1.8u92 version and, at the same time, I also have a Java 9 early release installation, which I will use to test the new features of Java for this book.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Installation on Linux</h1>
            

            <article>
                
<p class="calibre2">There are several ways to install Java on Linux, depending on its flavor. Here, I will describe an installation method that works more or less the same way on all flavors. The one I used is Debian.</p>
<p class="calibre2">First step is the same as in any other operating system: download the installation kit. In the case of Linux, you should select a package that has a <kbd class="calibre11">tar.gz</kbd> ending. This is a compressed archive format. You should also carefully select the package that matches the processor in your machine and the 32/64 bit version of the operating system. After the package is downloaded, you have to switch to root mode, issuing the <kbd class="calibre11">su</kbd> command. This the first command you can see on the screenshot that shows the installation commands.</p>
<div class="packtfigure"><img class="image-border11" src="../images/00016.jpeg"/></div>
<p class="calibre2">The <kbd class="calibre11">tar</kbd> command uncompressed the archive into a subfolder. In Debian, this subfolder has to be moved to <kbd class="calibre11">/opt/jdk</kbd> and the <kbd class="calibre11">mv</kbd> command is used for this purpose. The two <kbd class="calibre11">update-alternatives</kbd> command is Debian-specific. These tell the operating system to use this newly installed Java in case there is already an older Java installed. The Debian I was using to test and demonstrate the installation process on a virtual machine came with a 7 year old version of Java.</p>
<p class="calibre2">The final step of the installation is the same as any other operating system: checking that the installation was successful in issuing the <kbd class="calibre11">java -version</kbd> command. In the case of Linux, this is even more important because the installation process does not check that the downloaded version matches the operating system and the processor architecture.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Setting JAVA_HOME</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">JAVA_HOME</kbd> environment variable plays a special role for Java. Even though the JVM executable, <kbd class="calibre11">java.exe</kbd> or <kbd class="calibre11">java</kbd>, is on the <kbd class="calibre11">PATH</kbd> (thus you can execute it by typing the name <kbd class="calibre11">java</kbd> without specifying directory on the Command Prompt) (Terminal), it is recommended that you use the correct Java installation to set this environment variable. The value of the variable should point to the installed JDK. There are many Java-related programs, for example, Tomcat or Maven, that use this variable to locate the installed and currently used Java version. In Mac OS X, setting this variable is unavoidable.</p>
<p class="calibre2">In OS X, the program that starts to execute when you type <kbd class="calibre11">java</kbd> is a wrapper that first looks at <kbd class="calibre11">JAVA_HOME</kbd> to decide which Java version to start. If this variable is not set, then OS X will decide on its own, selecting from the available installed JDK versions. To see the available versions, you can issue the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">~$ /usr/libexec/java_home -V</strong><br class="title-page-name"/><strong class="calibre1">Matching Java Virtual Machines (10):</strong><br class="title-page-name"/><strong class="calibre1">    9, x86_64:    "Java SE 9-ea"    /Library/Java/JavaVirtualMachines/jdk-9.jdk/Contents/Home</strong><br class="title-page-name"/><strong class="calibre1">    1.8.0_92, x86_64:    "Java SE 8"    /Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home</strong><br class="title-page-name"/><strong class="calibre1">    1.7.0_60, x86_64:    "Java SE 7"    /Library/Java/JavaVirtualMachines/jdk1.7.0_60.jdk/Contents/Home</strong><br class="title-page-name"/><strong class="calibre1">/Library/Java/JavaVirtualMachines/jdk-9.jdk/Contents/Home</strong>
</pre>
<p class="calibre2">You will then get the list of installed JDKs. Note that the command is lowercase, but the option is capital. If you do not provide any options and argument to the program, it will simply return the JDK it thinks is the newest and most appropriate for the purpose. As I copied the output of the command from my Terminal window, you can see that I have quite a few versions of Java installed on my machine.</p>
<p class="calibre2">The last line of the program response is the home directory of JDK, which is the default. You can use this to set your <kbd class="calibre11">JAVA_HOME</kbd> variable using some bash programming:</p>
<pre class="calibre20">
    <strong class="calibre1">export JAVA_HOME=$(/usr/libexec/java_home)</strong>
</pre>
<p class="calibre2">You can place this file in your <kbd class="calibre11">.bashrc</kbd> file, which is executed each time you start Terminal application and thus <kbd class="calibre11">JAVA_HOME</kbd> will always be set. If you want to use a different version, you can use <kbd class="calibre11">-v</kbd>, with the lower case option this time, to the same utility, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)</strong>
</pre>
<p class="calibre2">The argument is the version of Java you want to use. Note that this versioning becomes:</p>
<pre class="calibre20">
    <strong class="calibre1">export JAVA_HOME=$(/usr/libexec/java_home -v 9)</strong>
</pre>
<p class="calibre2">If you want to use Java JDK Early Access version and not 1.9, there is no explanation for the same—fact of life.</p>
<p class="calibre2">Note that there is another environment variable that is important for Java-<kbd class="calibre11">CLASSPATH</kbd>. We will talk about it later.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Executing jshell</h1>
            

            <article>
                
<p class="calibre2">Now that we have spent a lot of time installing Java, it is time to get the fingers burnt a bit. As we are using Java 9, there is a new tool that helps developers to play around with the language. This is a <strong class="calibre1">Read-Eval-Print-Loop</strong> (<strong class="calibre1">REPL</strong>) tool that many language toolsets contain and there were also implementations from Java, but version 9 is the first that contains this feature off the shelf.</p>
<p class="calibre2">REPL is a tool that has interactive prompt and language commands that can be directly entered without editing some standalone file. The entered commands are executed directly and then the loop starts again, waiting for the user to type in the next command. This is a very effective tool to try out some language constructs without the delay of editing, compiling, and loading. The steps are automatically and transparently done by the REPL tool.</p>
<p class="calibre2">The REPL tool in Java 9 is called jshell. To start it, just type its name. If it is not on the <kbd class="calibre11">PATH</kbd>, then type the full path to jshell that comes installed with Java 9, as shown in the following example:</p>
<pre class="calibre20">
    <strong class="calibre1">$ jshell</strong><br class="title-page-name"/><strong class="calibre1">|  Welcome to JShell -- Version 9-ea</strong><br class="title-page-name"/><strong class="calibre1">|  For an introduction type: /help intro</strong><br class="title-page-name"/><strong class="calibre1">jshell&gt; </strong>
</pre>
<p class="calibre2">The jshell starts up in an interactive way and the prompt it displays is <kbd class="calibre11">jshell&gt;</kbd> to help you recognize that jshell is running and what you type is read by the program and not the operating system shell. As this is the first time you will start jshell, it tells you to type <kbd class="calibre11">/help intro</kbd>. Let's do it. It will print out a short text about what jshell is, as shown in the following code:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /help intro</strong><br class="title-page-name"/><strong class="calibre1">|  </strong><br class="title-page-name"/><strong class="calibre1">|  intro</strong><br class="title-page-name"/><strong class="calibre1">|  </strong><br class="title-page-name"/><strong class="calibre1">|  The jshell tool allows you to execute Java code, getting immediate results.</strong><br class="title-page-name"/><strong class="calibre1">|  You can enter a Java definition (variable, method, class, etc), like:  int x = 8</strong><br class="title-page-name"/><strong class="calibre1">|  or a Java expression, like:  x + x</strong><br class="title-page-name"/><strong class="calibre1">|  or a Java statement or import.</strong><br class="title-page-name"/><strong class="calibre1">|  These little chunks of Java code are called 'snippets'.</strong><br class="title-page-name"/><strong class="calibre1">|  </strong><br class="title-page-name"/><strong class="calibre1">|  There are also jshell commands that allow you to understand and</strong><br class="title-page-name"/><strong class="calibre1">|  control what you are doing, like:  /list</strong><br class="title-page-name"/><strong class="calibre1">|  </strong><br class="title-page-name"/><strong class="calibre1">|  For a list of commands: /help</strong>
</pre>
<p class="calibre2">Okay, so we can type Java snippets and <kbd class="calibre11">/list</kbd>, but that is only one example of the available commands. We can hope for more information by typing <kbd class="calibre11">/help</kbd>, as shown in the following code:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /help</strong><br class="title-page-name"/><strong class="calibre1">|  Type a Java language expression, statement, or declaration.</strong><br class="title-page-name"/><strong class="calibre1">|  Or type one of the following commands:</strong><br class="title-page-name"/><strong class="calibre1">|     /list [&lt;name or id&gt;|-all|-start]                             -- list the source you have typed</strong><br class="title-page-name"/><strong class="calibre1">|     /edit &lt;name or id&gt;                                           -- edit a source entry referenced by name or id</strong><br class="title-page-name"/><strong class="calibre1">|     /drop &lt;name or id&gt;                                           -- delete a source entry referenced by name or id</strong><br class="title-page-name"/><strong class="calibre1">|     /save [-all|-history|-start] &lt;file&gt;                          -- Save snippet source to a file.</strong><br class="title-page-name"/><strong class="calibre1">...</strong>
</pre>
<p class="calibre2">What you get is a long list of commands. Most of it is not presented here to save paper and your attention. We will use many of these commands on our journey through the next few pages. Let's start with a small Java snippet that is the ageless <em class="calibre12">Hello World</em> example:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">Hello World!</strong>
</pre>
<p class="calibre2">This is the shortest ever Hello World program in Java. Till Java 9, if you wanted to do nothing more than print out <kbd class="calibre11">Hello World!</kbd>, you had to create a program file. It had to contain the source code of a class including the <kbd class="calibre11">public static main</kbd> method, which contained the one line we had to type in with Java 9 jshell. It was cumbersome just for a simple printout of sample code. Now it is much easier and jshell is also lenient, forgiving us the missing semicolon at the end of the line.</p>
<p class="calibre2">The next thing we should try is declaring a variable, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; int a = 13</strong><br class="title-page-name"/><strong class="calibre1">a ==&gt; 13</strong><br class="title-page-name"/><strong class="calibre1">jshell&gt; </strong>
</pre>
<p class="calibre2">We declared a variable, named <kbd class="calibre11">a</kbd>, and assigned the value to it-<kbd class="calibre11">13</kbd>. The type of the variable is <kbd class="calibre11">int</kbd>, which is an abbreviation for integer types in Java. Now we have this variable already in our snippet, so we can print it out if we want to as shown:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; System.out.println(a)</strong><br class="title-page-name"/><strong class="calibre1">13</strong>
</pre>
<p class="calibre2">It is time to write something more complex into jshell than a one liner.</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; void main(String[] args){</strong><br class="title-page-name"/><strong class="calibre1">   ...&gt;  System.out.println("Hello World")</strong><br class="title-page-name"/><strong class="calibre1">   ...&gt; }</strong><br class="title-page-name"/><strong class="calibre1">|  Error:</strong><br class="title-page-name"/><strong class="calibre1">|  ';' expected</strong><br class="title-page-name"/><strong class="calibre1">|   System.out.println("Hello World")</strong><br class="title-page-name"/><strong class="calibre1">|                             </strong>
</pre>
<p class="calibre2">The jshell recognizes that this is not a one-liner and that it cannot process what we typed so far, when we press <em class="calibre12">Enter</em> at the end of the first line, and it signals that it expects more characters from us, so it displays <kbd class="calibre11">...&gt;</kbd> as a continuation prompt. We type in the commands that make up the whole hello world <kbd class="calibre11">main</kbd> method, but this time jshell does not let us miss the semicolon. That is allowed only in the case of one-line snippets. As jshell is interactive, it is easy to correct the mistake; press the up arrow key a few times to get back the previous lines and, this time, add the semicolon at the end of the second line:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; void main(String[] args){</strong><br class="title-page-name"/><strong class="calibre1">   ...&gt;  System.out.println("Hello World");</strong><br class="title-page-name"/><strong class="calibre1">   ...&gt; }</strong><br class="title-page-name"/><strong class="calibre1">|  created method main(String[])</strong>
</pre>
<p class="calibre2">This method was created for us as a snippet and now we can call it:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; main(null)</strong><br class="title-page-name"/><strong class="calibre1">Hello World</strong>
</pre>
<p class="calibre2">And it works. You can list all the snippets that were created, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /list</strong><br class="title-page-name"/><strong class="calibre1">   1 : System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">   2 : int a = 13;</strong><br class="title-page-name"/><strong class="calibre1">   3 : System.out.println(a)</strong><br class="title-page-name"/><strong class="calibre1">   4 : void main(String[] args){</strong><br class="title-page-name"/><strong class="calibre1">               System.out.println("Hello World");</strong><br class="title-page-name"/><strong class="calibre1">              }</strong>
</pre>
<p class="calibre2">And, as we want to go on writing a full Java version of <em class="calibre12">hello world</em>, we can save our work from jshell to a file, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /save HelloWorld.java</strong>
</pre>
<p class="calibre2">Finally, we exited from jshell by typing <kbd class="calibre11">/exit</kbd>. As you get back to the system prompt, type <kbd class="calibre11">cat HelloWorld.java</kbd> (or <kbd class="calibre11">type HelloWorld.java</kbd> on Windows) to see the content of the file. It is as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">$ cat HelloWorld.java</strong><br class="title-page-name"/><strong class="calibre1">System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">int a = 13;</strong><br class="title-page-name"/><strong class="calibre1">System.out.println(a)</strong><br class="title-page-name"/><strong class="calibre1">void main(String[] args){</strong><br class="title-page-name"/><strong class="calibre1">        System.out.println("Hello World");</strong><br class="title-page-name"/><strong class="calibre1">       }</strong>
</pre>
<p class="calibre2">The file contains all the snippets that we typed in one after the other. If you think that you have messed up the shell with lots of variables and code snippets that you do not need anymore, you can issue the <kbd class="calibre11">/reset</kbd> command:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /reset</strong><br class="title-page-name"/><strong class="calibre1">|  Resetting state.</strong>
</pre>
<p class="calibre2">After this command, the jshell is as clean as when it was started earlier</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /list</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">jshell&gt;</strong>
</pre>
<p class="calibre2">Listing just does not produce anything as we deleted it all. Fortunately, we saved the state of jshell to a file and we can also load the content of the file issuing the <kbd class="calibre11">/open</kbd> command:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /open HelloWorld.java</strong><br class="title-page-name"/><strong class="calibre1">Hello World!</strong><br class="title-page-name"/><strong class="calibre1">13</strong>
</pre>
<p class="calibre2">It loads the line from the file and executes it just as the characters were typed into the Command Prompt.</p>
<p class="calibre2">You may recall that the <kbd class="calibre11">/list</kbd> command printed a number in front of each snippet. We can use it to edit the snippets individually. To do so, issue the <kbd class="calibre11">/edit</kbd> command followed by the number of the snippet:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /edit 1</strong>
</pre>
<p class="calibre2">You may recall that the first command we entered was the <kbd class="calibre11">System.out.println</kbd> system call that prints out the argument to the console. When you press <em class="calibre12">Enter</em> after the <kbd class="calibre11">/edit 1</kbd> command, you do not get the prompt back. Instead, jshell opens a separate graphical editor that contains the snippet to edit as shown in the following image:</p>
<div class="packtfigure"><img class="image-border12" src="../images/00017.jpeg"/></div>
<p class="calibre2">Edit the text in the box so that it will look like this:</p>
<pre class="calibre20">
    <strong class="calibre1">printf("Hello World!")</strong>
</pre>
<p class="calibre2">Click on <span>Accept</span> and then <span>Exit</span>. When you click on <span>Accept</span>, the Terminal will execute the snippet and display the following result:</p>
<pre class="calibre20">
    <strong class="calibre1">Hello World!</strong>
</pre>
<p class="calibre2">The method that we used, <kbd class="calibre11">printf</kbd>, stands for formatted printing. This may be well known from many other languages. It was first introduced by the C language and though cryptic, the name survived. This is also part of the standard Java class, <kbd class="calibre11">PrintStream</kbd>, just like <kbd class="calibre11">println</kbd>. In case of <kbd class="calibre11">println</kbd>, we had to write <kbd class="calibre11">System.out</kbd> in front of the method name. In case of <kbd class="calibre11">printf</kbd>, we did not. Why?</p>
<p class="calibre2">The reason is that jshell defines a few snippets that are automatically loaded when jshell starts or resets. You can see these if you issue the <kbd class="calibre11">/list</kbd> command with the <kbd class="calibre11">-start</kbd> option, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /list -start</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  s1 : import java.util.*;</strong><br class="title-page-name"/><strong class="calibre1">  s2 : import java.io.*;</strong><br class="title-page-name"/><strong class="calibre1">  s3 : import java.math.*;</strong><br class="title-page-name"/><strong class="calibre1">  s4 : import java.net.*;</strong><br class="title-page-name"/><strong class="calibre1">  s5 : import java.util.concurrent.*;</strong><br class="title-page-name"/><strong class="calibre1">  s6 : import java.util.prefs.*;</strong><br class="title-page-name"/><strong class="calibre1">  s7 : import java.util.regex.*;</strong><br class="title-page-name"/><strong class="calibre1">  s8 : void printf(String format, Object... args) { System.out.printf(format, args); }</strong>
</pre>
<p class="calibre2">These predefined snippets help the use of jshell. Most of the users will import these classes, and to ease the print to screen, it defines a method snippet that happens to have the name, <kbd class="calibre11">printf</kbd>, which is also the name of a method in the <kbd class="calibre11">PrintStream</kbd> class.</p>
<p class="calibre2">If you want to list all the snippets you entered as well as the predefined snippets and also those that contained some error and thus were not executed, you can use the <kbd class="calibre11">-all</kbd> option to the <kbd class="calibre11">/list</kbd> command, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /list -all</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">  s7 : import java.util.regex.*;</strong><br class="title-page-name"/><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">   1 : System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">  e1 : System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">       int a = 14;</strong><br class="title-page-name"/><strong class="calibre1">   5 : System.out.println("Hello World!");</strong><br class="title-page-name"/><strong class="calibre1">...</strong>
</pre>
<p class="calibre2">Some of the lines were deleted from the actual output for brevity. The lines that are preloaded are numbered with the <kbd class="calibre11">s</kbd> prefix. The snippets that contain an error have a number prefixed with <kbd class="calibre11">e</kbd>.</p>
<p class="calibre2">If you want to execute some of the snippets again, you only have to type <kbd class="calibre11">/n</kbd> where <kbd class="calibre11">n</kbd> is the number of the snippet, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /1</strong><br class="title-page-name"/><strong class="calibre1">System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">Hello World!</strong>
</pre>
<p class="calibre2">You cannot re-execute the preloaded snippets or snippets that contained errors. There is no need for any of those anyway. Preloaded snippets declare some imports and define a snippet method; erroneous snippets do not execute because they are, well...erroneous.</p>
<p class="calibre2">You need not rely on the number of jshell when you want to re-execute a snippet. When you already have a lot of snippets in your jshell session, listing them all would be too cumbersome; there is a shortcut to re-execute the last n-th snippet. You have to write <kbd class="calibre11">/-n</kbd>. Here, n is the number of the snippet counting from the last one. So, if you want to execute the very last snippet, then you have to write <kbd class="calibre11">/-1</kbd>. If you want to execute the one before the last one, you have to write <kbd class="calibre11">/-2</kbd>. Note that if you already typed <kbd class="calibre11">/-1</kbd>, then the last one is the re-execution of the last snippet and snippet number -2 will become number <kbd class="calibre11">-3</kbd>.</p>
<p class="calibre2">Listing all the snippets can also be avoided in other ways. When you are interested only in certain types of snippets, you can have special commands.</p>
<p class="calibre2">If we want to see only the variables that we defined in the snippets, then we can issue the <kbd class="calibre11">/vars</kbd> command, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /vars</strong><br class="title-page-name"/><strong class="calibre1">|    int a = 13</strong>
</pre>
<p class="calibre2">If we want to see only the classes, the command/types will do that:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; class s {}</strong><br class="title-page-name"/><strong class="calibre1">|  created class s</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">jshell&gt; /types</strong><br class="title-page-name"/><strong class="calibre1">|    class s</strong>
</pre>
<p class="calibre2">Here, we just created an empty class and then we listed it.</p>
<p class="calibre2">To list the methods that were defined in the snippets, the <kbd class="calibre11">/methods</kbd> command can be issued:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /methods</strong><br class="title-page-name"/><strong class="calibre1">|    printf (String,Object...)void</strong><br class="title-page-name"/><strong class="calibre1">|    main (String[])void</strong>
</pre>
<p class="calibre2">You can see in the output that there are only two methods, which are as follows:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">printf</kbd>: This is defined in a preloaded snippet</li>
<li class="calibre15"><kbd class="calibre11">main</kbd>: This, we defined</li>
</ul>
<p class="calibre2">If you want to see everything you typed, you have to issue the <kbd class="calibre11">/history</kbd> command for all the snippets and commands that you typed. (I will not copy the output here; I do not want to shame myself. You should try yourself and see your own history.)</p>
<p class="calibre2">Recall that we can delete all the snippets issuing the <kbd class="calibre11">/reset</kbd> command. You can also delete snippets individually. To do so, you should issue the <kbd class="calibre11">/drop n</kbd> command, where <kbd class="calibre11">n</kbd> is the snipped number:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /drop 1</strong><br class="title-page-name"/><strong class="calibre1">|  This command does not accept the snippet '1' : System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">|  See /types, /methods, /vars, or /list</strong>
</pre>
<p class="calibre2">Oops! Something went wrong. There is nothing defined when snippet number <kbd class="calibre11">1</kbd> was executed and the <kbd class="calibre11">/drop</kbd> command actually drops the defined variable, type, or method. There is nothing to be dropped in the first snippet. But, if we reissue the <kbd class="calibre11">/list</kbd> command, we will get the following results:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /list</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">   1 : System.out.println("Hello World!")</strong><br class="title-page-name"/><strong class="calibre1">   2 : int a = 13;</strong><br class="title-page-name"/><strong class="calibre1">   3 : System.out.println(a)</strong><br class="title-page-name"/><strong class="calibre1">   4 : void main(String[] args){</strong><br class="title-page-name"/><strong class="calibre1">               System.out.println("Hello World");</strong><br class="title-page-name"/><strong class="calibre1">              }</strong>
</pre>
<p class="calibre2">We can see that we can drop the second or the fourth snippet, too:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /drop 2</strong><br class="title-page-name"/><strong class="calibre1">|  dropped variable a</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">jshell&gt; /drop 4</strong><br class="title-page-name"/><strong class="calibre1">|  dropped method main(String[])</strong>
</pre>
<div class="packtinfobox">The jshell error message says to see the output of the <kbd class="calibre22">/types</kbd>, <kbd class="calibre22">/methods</kbd>, <kbd class="calibre22">/vars</kbd>, or <kbd class="calibre22">/list</kbd> commands. The problem with this is that <kbd class="calibre22">/types</kbd>, <kbd class="calibre22">/methods</kbd>, and <kbd class="calibre22">/vars</kbd> do not display the number of the snippet. This is most probably a small bug in the jshell prerelease version and may be fixed by the time the JDK is released.</div>
<p class="calibre2">When we were editing the snippets, jshell opened a separate graphical editor. It may happen that you are running jshell using ssh on a remote server and where it is not possible to open a separate window. You can set the editor using the <kbd class="calibre11">/set</kbd> command. This command can set quite a few configuration options of the jshell. To set the editor to use the ubiquitous vi, issue the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /set editor "vi"</strong><br class="title-page-name"/><strong class="calibre1">|  Editor set to: vi</strong>
</pre>
<p class="calibre2">After this, jshell will open the snipped-in vi in the same Terminal window where you issue the <kbd class="calibre11">/edit</kbd> command.</p>
<p class="calibre2">It is not only the editor that you can set. You can set the startup file, and the way jshell prints the feedback to the console after a command was executed.</p>
<p class="calibre2">If you set the startup file, then the commands listed in the startup file will be executed instead of the built-in commands of jshell after the <kbd class="calibre11">/reset</kbd> command. This also means that you will not be able to use the classes directly that are imported by default and you will not have the <kbd class="calibre11">printf</kbd> method snippet, unless your own startup file contains the imports and the definition of the snippet.</p>
<p class="calibre2">Create the <kbd class="calibre11">sample.startup</kbd> file with the following content:</p>
<pre class="calibre20">
void println(String message) { System.out.println(message); }
</pre>
<p class="calibre2">Starting up a new jshell and executing it is done as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /set start sample.startup</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">jshell&gt; /reset</strong><br class="title-page-name"/><strong class="calibre1">|  Resetting state.</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">jshell&gt; println("wuff")</strong><br class="title-page-name"/><strong class="calibre1">wuff</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">jshell&gt; printf("This won't work...")</strong><br class="title-page-name"/><strong class="calibre1">|  Error:</strong><br class="title-page-name"/><strong class="calibre1">|  cannot find symbol</strong><br class="title-page-name"/><strong class="calibre1">|    symbol:   method printf(java.lang.String)</strong><br class="title-page-name"/><strong class="calibre1">|  printf("This won't work...")</strong><br class="title-page-name"/><strong class="calibre1">|  ^----^</strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">println</kbd> method is defined but the <kbd class="calibre11">printf</kbd> method, which was defined in the default startup, is not.</p>
<p class="calibre2">The feedback defines the prompt jshell prints and then waits for the input, the prompt for the continuation lines, and the message details after each command. There are predefined modes, which are as follows:</p>
<ul class="calibre14">
<li class="calibre15">Normal</li>
<li class="calibre15">Silent</li>
<li class="calibre15">Concise</li>
<li class="calibre15">Verbose</li>
</ul>
<p class="calibre2">Normal is selected by default. If you issue <kbd class="calibre11">/set feedback silent</kbd>, then prompt becomes <kbd class="calibre11">-&gt;</kbd> and jshell will not print details about the commands. The <kbd class="calibre11">/set feedback concise</kbd> code prints a bit more information and <kbd class="calibre11">/set feedback verbose</kbd> prints verbose information about the commands executed:</p>
<pre class="calibre20">
    <strong class="calibre1">jshell&gt; /set feedback verbose</strong><br class="title-page-name"/><strong class="calibre1">|  Feedback mode: verbose</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">jshell&gt; int z = 13</strong><br class="title-page-name"/><strong class="calibre1">z ==&gt; 13</strong><br class="title-page-name"/><strong class="calibre1">|  modified variable z : int</strong><br class="title-page-name"/><strong class="calibre1">|    update overwrote variable z : int</strong>
</pre>
<p class="calibre2">You can also define your own modes, giving a name to the new mode using the <kbd class="calibre11">/set mode xyz</kbd> command where <kbd class="calibre11">xyz</kbd> is the name of the new mode. After this, you can set prompt, truncation, and format for the mode. When the format is defined, you can use it the same way as the built-in modes.</p>
<p class="calibre2">Last, but not least, the most important command of jshell is <kbd class="calibre11">/exit</kbd>. This will just terminate the program and you will return to the operating system shell prompt.</p>
<p class="calibre2">Now, let's edit the <kbd class="calibre11">HelloWorld.java</kbd> file to create our first Java program. To do so, you can use vi, notepad, Emacs, or whatever is available on your machine and fits you. Later on, we will use some integrated development environment (IDE), NetBeans, Eclipse, or IntelliJ; however, for now, a simple text editor is enough.</p>
<p class="calibre2">Edit the file so that the content will be as follows:</p>
<pre class="calibre20">
public class HelloWorld { <br class="title-page-name"/>  public static void main(String[] args){ <br class="title-page-name"/>        System.out.println("Hello World"); <br class="title-page-name"/>       } <br class="title-page-name"/>  }
</pre>
<p class="calibre2">To compile the source code to byte code, which is executable by JVM, we have to use the Java compiler named <kbd class="calibre11">javac</kbd>:</p>
<pre class="calibre20">
    <strong class="calibre1">javac HelloWorld.java</strong>
</pre>
<p class="calibre2">This generates the <kbd class="calibre11">java.class</kbd> file in the current directory. This is a compiled code that can be executed as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">$ java HelloWorld</strong><br class="title-page-name"/><strong class="calibre1">Hello World</strong>
</pre>
<p class="calibre2">With this one, you have created and executed your first full Java program. You may still wonder what we were doing. How and why, I will explain it; but first, I wanted you to have a feeling that it works.</p>
<p class="calibre2">The file we edited contained only the snippet and we deleted most of the lines, except the declaration of the <kbd class="calibre11">main</kbd> method and we inserted the declaration of the class around it.</p>
<p class="calibre2">In Java, you cannot have standalone methods or functions, like in many other languages. Every method belongs to some class and every class should be declared in a separate file (well, almost, but for now, let's skip the exceptions). The name of the file has to be the same as the name of the class. The compiler requires this for <kbd class="calibre11">public</kbd> classes. Even for non-public classes we usually follow this convention. If you renamed the file from <kbd class="calibre11">HelloWorld.java</kbd> to <kbd class="calibre11">Hello.java</kbd>, the compiler will display an error when you try to compile the file with the new name.</p>
<pre class="calibre20">
    <strong class="calibre1">$ mv HelloWorld.java Hello.java</strong><br class="title-page-name"/><strong class="calibre1">~/Dropbox/java_9-by_Example$ javac Hello.java</strong><br class="title-page-name"/><strong class="calibre1">Hello.java:2: error: class HelloWorld is public, should be declared in a file named HelloWorld.java</strong><br class="title-page-name"/><strong class="calibre1">public class HelloWorld {</strong><br class="title-page-name"/><strong class="calibre1">       ^</strong><br class="title-page-name"/><strong class="calibre1">1 error</strong>
</pre>
<p class="calibre2">So, let's move it back to the original name: <kbd class="calibre11">mv Hello.java HelloWorld.java</kbd>.</p>
<p class="calibre2">The declaration of the class starts with the keyword <kbd class="calibre11">class</kbd>, then the name of the class, an opening curly brace, and lasts until the matching closing brace. Everything in between belongs to the class.</p>
<p class="calibre2">For now, let's skip why I wrote <kbd class="calibre11">public</kbd> in front of the class and focus on the main method in it. The method does not return any value, therefore; the return value of it is <kbd class="calibre11">void</kbd>. The argument, named <kbd class="calibre11">args</kbd>, is a string array. When JVM starts the <kbd class="calibre11">main</kbd> method, it passes the command-line arguments to the program in this array. However, this time we do not use it. The <kbd class="calibre11">main</kbd> method contains the line that prints out <kbd class="calibre11">Hello World</kbd>. Now, let's examine this line a bit more.</p>
<p class="calibre2">In other languages, printing something to the console requires only a <kbd class="calibre11">print</kbd> statement or a very similar command. I remember that some BASIC interpreters even allowed us to type <kbd class="calibre11">?</kbd> instead of <kbd class="calibre11">print</kbd> because printing to the screen was so common. This has changed a lot during the last 40 years. We use graphical screens, Internet, and many other input and output channels. These days, it is not very common to write to the console.</p>
<p class="calibre2">Usually, in professional large-scale enterprise applications, there is not even a single line that does that. Instead, we will direct the text to log files, send messages to message queues, and send requests and reply with responses over TCP/IP protocol. As this is so infrequently used, there is no reason to create a shortcut for the purpose in the language. After the first few programs, when you get acquainted with the debugger and logging possibilities, you will not print anything directly to the console yourself.</p>
<p class="calibre2">Still, Java has features that let you send text directly to the standard output of a process the good old way, as it was invented originally for UNIX. This is implemented in a Java way where everything has to be an object or class. To get access to the system output, there is a class named <kbd class="calibre11">System</kbd> and it, among other things, has the following three variables:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">in</kbd>: This is the standard input stream</li>
<li class="calibre15"><kbd class="calibre11">out</kbd>: This is the standard output stream</li>
<li class="calibre15"><kbd class="calibre11">err</kbd>: This is the standard error stream</li>
</ul>
<p class="calibre2">To refer to the output stream variable, because it is not in our class but in <kbd class="calibre11">System,</kbd> we will have to specify the class name so we will refer to it as <kbd class="calibre11">System.out</kbd> in our program. The type of this variable is <kbd class="calibre11">PrintStream</kbd>, which is also a class. Class and type are synonyms in Java. Every object that is of type <kbd class="calibre11">PrintStream</kbd> has a method named <kbd class="calibre11">println</kbd> that accepts a <kbd class="calibre11">String</kbd>. If the actual print stream is the standard output, and we are executing our Java code from the command line, then the string is sent to the console.</p>
<p class="calibre2">The method is named <kbd class="calibre11">main</kbd> and this is a special name in Java programs. When we start a Java program from the command line, JVM invokes the method named <kbd class="calibre11">main</kbd> from the class that we specify on the command line. It can do that because we declared this method <kbd class="calibre11">public</kbd> so that anyone can see and invoke it. If it was <kbd class="calibre11">private</kbd>, it would be seen and callable only from within the same class, or classes, that are defined in the same source file.</p>
<p class="calibre2">The method is also declared as <kbd class="calibre11">static</kbd>, which means that it can be invoked without an actual instance of the class that contains the methods. Using static methods is usually seen as not a good practice these days, unless they are implementing functions that cannot really ever be related to an instance, or have different implementations such as the functions in the <kbd class="calibre11">java.lang.Math</kbd> class; but, somewhere, the code execution has to start and the Java runtime will not usually create instances of classes for us automatically.</p>
<p class="calibre2">To start the code, the command line should be as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">java -cp . HelloWorld</strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">-cp</kbd> option stands for classpath. The classpath is a fairly complex idea for java but, for now, let's make it simple and say that it is a list of directories and JAR files that contain our classes. The list separator for the classpath is <kbd class="calibre11">:</kbd> (colon) on UNIX-like systems and <kbd class="calibre11">;</kbd> (semicolon) on Windows. In our case, the classpath is the actual directory, as that is the place where the Java compiler created <kbd class="calibre11">HelloWorld.class</kbd>. If we do not specify classpath on the command line, Java will use the current directory as a default. That is the reason our program was working without the <kbd class="calibre11">-cp</kbd> option in the first place.</p>
<p class="calibre2">Both <kbd class="calibre11">java</kbd> and <kbd class="calibre11">javac</kbd> handle many options. To get a list of the options type <kbd class="calibre11">javac -help</kbd> or <kbd class="calibre11">java -help</kbd>. We use the IDE to edit the code and, many times, to compile, build, and run it during development. The environment in this case sets the reasonable parameters. For production we use build tools that also support the configuration of the environment. Because of this, we rarely meet these command line options. Nevertheless, professionals have to understand their meanings at least and know where to learn their actual use in case it is needed.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Looking at the byte code</h1>
            

            <article>
                
<p class="calibre2">The class file is a binary file. The main role of this format is to be executed by the JVM and to provide symbolic information for the Java compiler when a code uses some of the classes from a library. When we compile our program that contains <kbd class="calibre11">System.out.println</kbd>, the compiler looks at the compiled <kbd class="calibre11">.class</kbd> files and not at the source code. It has to find the class named <kbd class="calibre11">System</kbd>, the field named <kbd class="calibre11">out</kbd>, and the method <kbd class="calibre11">println</kbd>. When we debug a piece of code or try to find out why a program does not find a class or method, we will need a way to look into the binary of the <kbd class="calibre11">.class</kbd> files. This is not an everyday task and it takes some advanced knowledge</p>
<p class="calibre2">To do so, there is a <em class="calibre12">decompiler</em> that can display the content of a <kbd class="calibre11">.class</kbd> file in a more or less readable format. This command is called <kbd class="calibre11">javap</kbd>. To execute it, you can issue the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">$ javap HelloWorld.class</strong><br class="title-page-name"/><strong class="calibre1">Compiled from "HelloWorld.java"</strong><br class="title-page-name"/><strong class="calibre1">public class HelloWorld {</strong><br class="title-page-name"/><strong class="calibre1">  public HelloWorld();</strong><br class="title-page-name"/><strong class="calibre1">  public static void main(java.lang.String[]);</strong><br class="title-page-name"/><strong class="calibre1">}</strong>
</pre>
<p class="calibre2">The output of the program shows that the class file contains Java class that has something called <kbd class="calibre11">HelloWorld()</kbd>; it seems to be a method having the same name as the class and it also contains the method we have written.</p>
<p class="calibre2">The <em class="calibre12">method</em> that has the same name as the class is the constructor of the class. As every class in java can be instantiated, there is a need for a constructor. If we do not give one, then the Java compiler will create one for us. This is the default constructor. The default constructor does nothing special but returns a new instance of the class. If we provide a constructor on our own, then the Java compiler will not have bothered creating one.</p>
<p class="calibre2">The <kbd class="calibre11">javap</kbd> decompiler does not show what is inside the methods or what Java code it contains unless we provide the <kbd class="calibre11">-c</kbd> option:</p>
<pre class="calibre20">
    <strong class="calibre1">$ javap -c HelloWorld.class</strong><br class="title-page-name"/><strong class="calibre1">Compiled from "HelloWorld.java"</strong><br class="title-page-name"/><strong class="calibre1">public class HelloWorld {</strong><br class="title-page-name"/><strong class="calibre1">  public HelloWorld();</strong><br class="title-page-name"/><strong class="calibre1">    Code:</strong><br class="title-page-name"/><strong class="calibre1">       0: aload_0</strong><br class="title-page-name"/><strong class="calibre1">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</strong><br class="title-page-name"/><strong class="calibre1">       4: return</strong><br class="title-page-name"/><strong class="calibre1">  public static void main(java.lang.String[]);</strong><br class="title-page-name"/><strong class="calibre1">    Code:</strong><br class="title-page-name"/><strong class="calibre1">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</strong><br class="title-page-name"/><strong class="calibre1">       3: ldc           #3                  // String hali</strong><br class="title-page-name"/><strong class="calibre1">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</strong><br class="title-page-name"/><strong class="calibre1">       8: return</strong><br class="title-page-name"/><strong class="calibre1">}</strong>
</pre>
<p class="calibre2">It is very cryptic and is not for ordinary humans. Only a few experts, who deal with the Java code generation, can fluently read that. But, to have a look at it helps you get a glimpse of what byte code means. It is something like a good old assembly. Although this is binary code, there is nothing secret in it: Java is open source, the class file format is well documented and debuggable for the experts.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Packaging classes into a JAR file</h1>
            

            <article>
                
<p class="calibre2">When you deliver a Java application, usually the code is packaged into JAR, WAR, EAR, or some other packaged format. We learn something again that seems to be obscure at first sight, but in reality, this is not that complex. They are all ZIP files. You can open any of these files using WinZip or some other zip manager that you have a license for. The extra requirement is that, for example, in the case of a JAR file, the archive should contain a directory named <kbd class="calibre11">META-INF</kbd> and inside it a file named <kbd class="calibre11">MANIFEST.MF</kbd>. This file is a text file and contains meta information in the format, which is as follows:</p>
<pre class="calibre20">
Manifest-Version: 1.0 <br class="title-page-name"/>Created-By: 9-ea (Oracle Corporation)
</pre>
<p class="calibre2">There can be a lot of other information in the file, but this is the minimum that the Java provided tool <kbd class="calibre11">jar</kbd> puts there if we package our class file into a jar issuing the following command:</p>
<pre class="calibre20">
         jar -cf hello.jar HelloWorld.class
</pre>
<p class="calibre2">The <kbd class="calibre11">-c</kbd> option tells the JAR archiver to create a new JAR file and the option <kbd class="calibre11">f</kbd> is used to specify the name of the new archive. The one we specified here is <kbd class="calibre11">hello.jar</kbd> and the file added to it is the class file.</p>
<p class="calibre2">The packaged JAR file can also be used to start the Java application. Java can read directly from JAR archives and load classes from there. The only requirement is that they are on the classpath.</p>
<div class="packttip">Note that you cannot put individual classes on the classpath, only directories. As JAR files are archives with an internal directory structure in them, they behave like a directory.</div>
<p class="calibre2">Check that the JAR file was created using <kbd class="calibre11">ls hello.jar</kbd> and remove the <kbd class="calibre11">rm HelloWorld.class</kbd> class file just to ensure that when we issue the command line, the code is executed from the JAR file and not the class.</p>
<pre class="calibre20">
    <strong class="calibre1">$ java -cp hello.jar HelloWorld</strong><br class="title-page-name"/><strong class="calibre1">Hello World</strong>
</pre>
<p class="calibre2">To see the content of the JAR file, however, it is recommended that you use the JAR tool and not WinZip even though that may be cozier. Real professionals use the Java tools to handle Java files.</p>
<pre class="calibre20">
$ jar -tf hello.jar <br class="title-page-name"/>META-INF/ <br class="title-page-name"/>META-INF/MANIFEST.MF <br class="title-page-name"/>HelloWorld.class
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Managing the running Java application</h1>
            

            <article>
                
<p class="calibre2">The Java toolset that comes with the JDK supports the execution and management of running Java applications as well. To have some program that we can manage while executing, we will need a code that runs not only for a few milliseconds but, while it runs, it also prints something to the console. Let's create a new program called <kbd class="calibre11">HelloWorldLoop.java</kbd> with the following content:</p>
<pre class="calibre20">
public class HelloWorldLoop { <br class="title-page-name"/>  public static void main(String[] args){ <br class="title-page-name"/>       for( ;; ){ <br class="title-page-name"/>         System.out.println("Hello World"); <br class="title-page-name"/>         } <br class="title-page-name"/>       } <br class="title-page-name"/>  }
</pre>
<p class="calibre2">The program contains a <kbd class="calibre11">for</kbd> loop. Loops allow repeated execution of a code block, and we will discuss them in <a href="part0041.html" class="calibre6">Chapter 2</a>, <em class="calibre12">The First Real Java Program - Sorting Names</em>. The loop we created here is a special one that never terminates but repeats the printing method call, printing <kbd class="calibre11">Hello World</kbd> until we kill the program by pressing <em class="calibre12">Ctrl</em> + <em class="calibre12">c</em> or issuing a <kbd class="calibre11">kill</kbd> command on Linux or on OSX, or terminate the program in the task manager under Windows.</p>
<p class="calibre2">Compile and start it in one window and open another Terminal window to manage the application.</p>
<p class="calibre2">The first command that we should get familiar with is <kbd class="calibre11">jps</kbd>. <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html" class="calibre6"><span>http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html</span></a> It lists the Java processes that run on the machine, which are as follows:</p>
<pre class="calibre20">
$ jps <br class="title-page-name"/>21873 sun.tools.jps.Jps <br class="title-page-name"/>21871 HelloWorldLoop
</pre>
<p class="calibre2">You can see that there are two processes—one is the program we execute and the other is the <kbd class="calibre11">jps</kbd> program itself. Not surprisingly, the jps tool is also written in Java. You can also pass options to <kbd class="calibre11">jps</kbd>, which are documented on the web.</p>
<p class="calibre2">There are many other tools and we will examine one of them, which is a very powerful and easy-to-use tool—Java VisualVM.</p>
<div class="packtfigure"><img class="image-border" src="../images/00018.jpeg"/></div>
<p class="calibre2">VisualVM is a command-line graphical tool that connects to the running Java process and displays the different performance parameters. To start the VisualVM tool, you will issue the <kbd class="calibre11">jvisualvm</kbd> command without any parameters. Soon, a window will appear with an exploring tree on the left-hand side and a welcome pane on the right. The left side shows all the running Java processes under the branch named <span>Local</span>. If you double click on <kbd class="calibre11">HelloWorldLoop</kbd>, it will open the details of the process on the right pane. On the header tabs, you can select <span>Overview</span>, <span>Monitor</span>, <span>Threads</span>, <span>Sampler</span>, and <span>Profiler</span>. The first three tabs are the most important and give you a good view of what is happening in JVM regarding the number of threads, CPU usage, memory consumption, and so on.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using an IDE</h1>
            

            <article>
                
<p class="calibre2">Integrated development environments are outstanding tools that help the development by offloading the mechanical tasks from the developer's shoulders. They recognize many of the programming errors as we type the code, help us find the needed library methods, display the documentation of the libraries, and provide extra tools for style checking, debugging, and so on.</p>
<p class="calibre2">In this section, we will look at some IDEs and how to leverage the functions they provide.</p>
<p class="calibre2">To get an IDE, you will have to download and install it. It does not come with the Java development tools because they are not part of the language environment. But, don't worry. They can be downloaded free of charge and are easy to install. They may be more complex to start up than a notepad editor, but even after a few hours of work, they will pay back the time you devote to learning them. After all, it is not without reason that no developer is coding Java in notepad or vi.</p>
<p class="calibre2">The three topmost IDEs are <em class="calibre12">NetBeans</em>, <em class="calibre12">Eclipse</em>, and <em class="calibre12">IntelliJ</em>. All are available in community versions, which means that you need not pay for them. IntelliJ has a <em class="calibre12">full</em> version that you can also buy. The community edition will be usable for learning the language. In case you do not like IntelliJ, you can use Eclipse or NetBeans. These are all free of charge. Personally, I use the IntelliJ community edition for most of my projects and the screen samples that show an IDE in this book will feature this IDE. But, it does not necessarily mean that you have to stick to this IDE.</p>
<div class="packtinfobox">In the developer community, there are topics that can be heavily debated. These topics are about opinions. Were they about facts the debate would easily be soon over. One such topic is: "Which is the best IDE?" It is a matter of taste. There is no definite answer. If you learn how to use one, you will like that and you will be reluctant to learn another one, unless you see that the other one is so much better. That is the reason developers love the IDE they use (or just hate, depending on their personality), but they keep using the same IDE usually for a long time. There is no best IDE.</div>
<p class="calibre2">To download the IDE of your choice, you can visit either one of the following websites:</p>
<ul class="calibre14">
<li class="calibre15"><a href="https://netbeans.org/" class="calibre6"><span>https://netbeans.org/</span></a> for NetBeans</li>
<li class="calibre15"><a href="http://www.eclipse.org/" class="calibre6"><span>http://www.eclipse.org/</span></a> for Eclipse</li>
<li class="calibre15"><a href="https://www.jetbrains.com/idea/" class="calibre6"><span>https://www.jetbrains.com/idea/</span></a> for IntelliJ</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">NetBeans</h1>
            

            <article>
                
<p class="calibre2">NetBeans is supported by Oracle and is continuously developed. It contains components, such as the NetBeans profiler, that became part of the Oracle Java distribution. You may notice that when you start Visual VM and start the profiling, the Java process started has <kbd class="calibre11">netbeans</kbd> in its name.</p>
<p class="calibre2">Generally, NetBeans is a framework to develop rich client applications and the IDE is only one application of the many that are built on top of the framework. It supports many languages, not only Java. You can develop PHP, C, or JavaScript code using NetBeans and have similar services for Java. For the support of different languages, you can download plugins or a special version of NetBeans. These special versions are available from the download page of the IDE and they are nothing more than the basic IDE with some preconfigured plugins. In the C package, the developers configure the plugins that are needed when you want to develop C; in the PHP version, they plugin for PHP.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Eclipse</h1>
            

            <article>
                
<p class="calibre2">Eclipse is supported by IBM. Similar to NetBeans, it is also a platform for rich client application and it is built around the <em class="calibre12">OSGi</em> container architecture, which itself is a topic that can fill a book like this. Most of the developers use Eclipse and, almost exclusively, it is the choice when developers create code for the <em class="calibre12">IBM WebSphere</em> application server. The Eclipse special version contains a developer version of WebSphere.</p>
<p class="calibre2">Eclipse also has plugins to support different programming languages and also has different variations similar to NetBeans. The variations are plugins prepackaged with the basic IDE.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">IntelliJ</h1>
            

            <article>
                
<p class="calibre2">The last one in the preceding enumeration is IntelliJ. This IDE is the only one that does not want to be a framework. IntelliJ is an IDE. It also has plugins, but most of the plugins that you will need to download to use in NetBeans or Eclipse are preconfigured. When you want to use some more advanced plugin, it may however be something you have to pay for, which should not be a problem when you are doing professional, paid work, should it? These things are not that expensive. For learning the subjects in this book, you will not need any plugin that is not in the community edition. As in this book, I will develop the samples using IntelliJ and I recommend that you follow me during your learning experience.</p>
<div class="packtinfobox">I want to emphasize that the examples in this book are independent of the actual IDE to be used. You can follow the book using NetBeans, Eclipse, or even Emacs, notepad, or vi.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">IDE services</h1>
            

            <article>
                
<p class="calibre2">Integrated development environments provide us with services. The most basic service is that you can edit files with them, but they also help build the code, find bugs, run the code, deploy to the application server in development mode, debug, and so on. In the following sections, we will look at these features. I will not give an exact and precise introduction on how to use one or the other IDE. A book like this is not a good medium for such a tutorial.</p>
<p class="calibre2">IDEs differ on menu placement, keyboard shortcuts, and they may even change as newer versions are released. It is best to look at the actual IDE tutorial video or online help. Their features, on the other hand, are very similar. IntelliJ has the video documentation at <a href="https://www.jetbrains.com/idea/documentation/" class="calibre6"><span>https://www.jetbrains.com/idea/documentation/</span></a>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">IDE screen structure</h1>
            

            <article>
                
<p class="calibre2">The different IDEs look similar, and have the same screen structure more or less. In the following screenshot, you can see an IntelliJ IDE:</p>
<div class="packtfigure"><img class="image-border13" src="../images/00019.jpeg"/></div>
<p class="calibre2">On the left side, you can see the file structure of a Java project. A Java project typically contains many files in different directories which we will discuss in the next chapter. The simple <em class="calibre12">HelloWorld</em> application contains a <kbd class="calibre11">pom.xml</kbd> project description file. This file is needed for the Maven build tool, which is also a topic for the next chapter. For now, you should only know that it is a file that describes the project structure for maven. The IDE also keeps track of some administrative data for itself. It is stored in <kbd class="calibre11">HelloWorld.iml</kbd>. The main program file is stored in the <kbd class="calibre11">src/main/java</kbd> directory and named <kbd class="calibre11">HelloWorld.java</kbd>.</p>
<p class="calibre2">On the right side, you can see the files. In the screenshot, we have only one file opened. In case there is more than one file opened, then there are tabs-one for each file. Now, the active file is <kbd class="calibre11">HelloWorld.java</kbd> that can be edited in the source code editor.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Editing files</h1>
            

            <article>
                
<p class="calibre2">When editing, you can type in characters or delete characters, words, and lines, but this is something that all editors can do. IDEs offer extra. IDEs analyze the source code and format it, which, in turn, automatically indents the lines. It also continuously compiles the code in the background while you edit it and if there is some syntax error, then it underlines it with a red waiving line. When you fix the error, the red underlining disappears.</p>
<div class="packtfigure"><img class="image-border14" src="../images/00020.jpeg"/></div>
<p class="calibre2">The editor also automatically gives suggestions for further characters as you type. You can ignore the window that pops up and continue typing. However, many times, it is easier to stop after a character and use the up and down arrows to select the word that needs finishing before pressing <em class="calibre12">Enter</em>: the word will be inserted into the source code automatically.</p>
<p class="calibre2">In the screenshot, you can see that I wrote <kbd class="calibre11">System.o</kbd> and the editor immediately suggested that I wanted to write <kbd class="calibre11">out</kbd>. The other alternatives are the other static fields and methods that are in the class <kbd class="calibre11">System</kbd> and which contain the letter <kbd class="calibre11">o</kbd>.</p>
<p class="calibre2">The IDE editor gives you hints not only when it can type for you, but also when it cannot type instead of you. In the screenshot, the IDE tells you to type some expression as argument to the <kbd class="calibre11">println()</kbd>method that is <kbd class="calibre11">boolean</kbd>, <kbd class="calibre11">char</kbd>, <kbd class="calibre11">int</kbd>, and so on. The IDE has absolutely no idea what to type there. You have to construct the expression. Still, it can tell you that it needs to be of a certain type.</p>
<div class="packtfigure"><img class="image-border15" src="../images/00021.jpeg"/></div>
<p class="calibre2">It is not only the built-in types that the editor knows. The editor integrated with the JDK continuously scans the source files and knows what classes, methods, and fields are there in the source code which are usable at the place of editing.</p>
<p class="calibre2">This knowledge is also heavily used when you want to rename a method or variable. The old method was to rename the field or method in the source file and then do an exhaustive search for all references to the variable. Using the IDE, the mechanical work is done by it. It knows all the uses of a field or method and automatically replaces the old identifier with the new one. It also recognizes whether a local variable happens to have the same name as the one that we rename, and the IDE only renames those occurrences that are really referring to the one we are renaming.</p>
<p class="calibre2">You can usually do more than just renaming. There are more or less mechanical tasks that programmers call <strong class="calibre1">refactoring</strong>. These are supported by the IDEs using some keyboard shortcut and context sensitive menu in the editor—right click on the mouse and click <span>Menu</span>.</p>
<div class="packtfigure"><img class="image-border16" src="../images/00022.jpeg"/></div>
<p class="calibre2">The IDE also helps you to read the documentation of the libraries and source code as shown in the following image:</p>
<div class="packtfigure"><img class="image-border17" src="../images/00023.jpeg"/></div>
<p class="calibre2">Libraries provide <em class="calibre12">Javadoc</em> documentation for the <kbd class="calibre11">public</kbd> methods and you should also write Javadoc for your own method. Javadoc documentation is extracted from special comments in the source code and we will learn how to create those in <a href="part0111.html" class="calibre6"><span>Chapter 4</span></a>, <em class="calibre12">Mastermind - Creating a Game</em>. These are located in comments in front of the actual method head. As creating compiled documentation is part of the compilation flow, the IDE also knows the documentation and it displays as a hovering box over the method names, class names, or whatever element you want to use in the source file when you position the cursor on the element.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Managing projects</h1>
            

            <article>
                
<p class="calibre2">On the left side of the IDE window, you can see the directory structure of the project. The IDE knows the different types of files and shows them in a way that is meaningful from the programming point of view. For example, it does not display <kbd class="calibre11">Main.java</kbd> as a filename. Instead, it displays <kbd class="calibre11">Main</kbd> and an icon that signals that <kbd class="calibre11">Main</kbd> is a class. It can also be an interface still in a file named <kbd class="calibre11">Main.java</kbd> but, in that case, the icon will show that this is an interface. This is again done by the IDE continuously scanning and compiling the code.</p>
<p class="calibre2">The files are structured into subdirectories when we develop a Java code. These subdirectories follow the packaging structure of the code. Many times, in Java, we use compound and long package names, and displaying it as a deep and nested directory structure will not be so easy to handle.</p>
<div class="packtinfobox">Packages are used to group the source files. The source files for classes that are related in some way should go into one package. We will discuss the notion of packages and how to use them in the next chapter</div>
<p class="calibre2">The IDE is capable of showing the package structure instead of the nested directories for those directories of the project that contain source files.</p>
<div class="packtfigure"><img class="image-border18" src="../images/00024.jpeg"/></div>
<p class="calibre2">When you move a class or an interface from one package to another, it happens in a similar way as renaming or other refactoring. All references to the class or interface in the source files get renamed to the new package. If a file contains an <kbd class="calibre11">import</kbd> statement referring to the class, the name of the class in the statement is corrected. To move a class, you can open the package and use the good old drag and drop.</p>
<p class="calibre2">Package hierarchy is not the only hierarchy displayed in the IDE. The classes are in packages but, at the same time, there is an inheritance hierarchy. Classes may implement interfaces and can extend other classes. The Java IDEs help us by showing type hierarchies where you can navigate across a graphical interface along the inheritance relations.</p>
<p class="calibre2">There is another hierarchy that IDEs can show to help us with development: method call hierarchy. After analyzing the code, the IDE can show us the graph displaying the relations between the methods: which method calls which other methods. Sometimes, this call graph is also important in showing the dependencies of methods on each other.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Build the code and run it</h1>
            

            <article>
                
<p class="calibre2">The IDEs usually compile the code for analysis to help us spot syntax errors or undefined classes and methods on the fly. This compilation is usually partial, covering a part of the code, and as it runs all the time, the source code changes and is never actually complete. To create the deployable file, that is, the final deliverable code of the project, a separate build process has to be started. Most of the IDEs have some built-in tool for that, but it's not recommended to use these except for the smallest projects. Professional development projects use Ant, Maven, or Gradle instead. Here is an example of Maven.</p>
<div class="packtfigure"><img class="image-border19" src="../images/00025.jpeg"/></div>
<p class="calibre2">The IDEs are prepared to use such an external tool, and they can help us in starting them. This way, the build process can run on the developer machine without starting a new shell window. IDEs can also import the settings from the configuration file of these external build tools to recognize the project structure, where source files are, and what to compile to support the error checking while editing.</p>
<p class="calibre2">The building process usually contains the execution of certain checks on the code. A bunch of the Java source file may compile smoothly and the code may still contain a lot of bugs and may be written in bad style, which will make the project becomes unmaintainable in the long run. To avoid such problems, we will use unit tests and static code analysis tools. These do not guarantee error free code but the chances are much better.</p>
<p class="calibre2">IDEs have plugins to run the static code analysis tools as well as unit tests. Being integrated into the IDE has a huge advantage. When there is any problem identified by the analysis tool, or by some unit tests, the IDE provides an error message that also functions like a link on a web page. If you click on the message, usually blue and underlined, exactly like on a web page, the editor opens the problematic file and places the cursor where the issue is.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Debugging Java</h1>
            

            <article>
                
<p class="calibre2">Developing code needs debugging. Java has very good facilities to debug code during development. JVM supports debuggers via the Java Platform Debugger Architecture. This lets you execute code in debug mode and JVM will accept external debugger tools to attach to it via a network, or it will try to attach to a debugger depending on command-line options. JDK contains a client, the <kbd class="calibre11">jdb</kbd> tool, which contains a debugger; however, it is so cumbersome to use when compared to the graphical client built into the IDEs that I have never heard of anyone using it for real work.</p>
<p class="calibre2">To start a Java program in debug mode so that JVM will accept a debugger client to attach the options to it, execute the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">-Xagentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=7896</strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">Xagentlib</kbd> option instructs the Java runtime to load the <kbd class="calibre11">jdwp</kbd> agent. The part of the option that follows <kbd class="calibre11">-Xagentlib:jdwp=</kbd> is interpreted by the debugger agent. These options are as follows:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">transport</kbd>: This should specify which transport to use. It can be a shared memory (<kbd class="calibre11">dt_shmem</kbd>) socket or a TCP/IP socket transport but, in practice, you will always use the latter. This is specified in the preceding <kbd class="calibre11">dt_socket</kbd> sample.</li>
<li class="calibre15"><kbd class="calibre11">server</kbd>: This specifies if the debugged JVM starts in server mode or client mode. When you start the JVM in server mode, it starts to listen on a socket and accepts the debugger to connect to it. If it is started in client mode, then it tries to connect a debugger that is supposed to be started in server mode, listening on a port. The value of the option is <kbd class="calibre11">y</kbd> meaning server mode or <kbd class="calibre11">n</kbd> meaning nonserver, a.k.a. client mode.</li>
<li class="calibre15"><kbd class="calibre11">suspend</kbd>: This can also be <kbd class="calibre11">y</kbd> or <kbd class="calibre11">n</kbd>. If JVM is started in suspend mode, it will not start the Java code until a debugger is attached to it. If it is started with <kbd class="calibre11">suspend=n</kbd>, then the JVM starts and when a debugger attaches, it stops as soon as a breakpoint is reached. If you start a standalone Java application, you will usually start the debugging with <kbd class="calibre11">suspend=y</kbd>, which is the default. If you want to debug an application in an application server or servlet-container environment, then it is better to start with <kbd class="calibre11">suspend=n</kbd>; otherwise, the server does not start until the debugger attaches to it. Starting the Java process in <kbd class="calibre11">suspend=y</kbd> mode in case servlet application is only useful when you want to debug the servlet static initializer code, which is executed when the server is starting up. Without suspend mode, you will be required to attach the debugger very fast. It is better that JVM just waits for you in that situation.</li>
<li class="calibre15"><kbd class="calibre11">address</kbd>: This should specify the address that JVM communicates with. If the JVM started in client mode, then it will start to connect to this address. If the JVM runs in server mode, then it will accept connections from the debugger on that address. The address may specify only the port. In this case, the IP address is that of the local machine.</li>
</ul>
<p class="calibre2">The other options the debugger agent may handle are for special cases. For the topics covered in this book, the preceding options are enough.</p>
<p class="calibre2">The following screenshot shows a typical debugging session where we debug the simplest program in IntelliJ IDE:</p>
<div class="packtfigure"><img class="image-border20" src="../images/00026.jpeg"/></div>
<p class="calibre2">When you start a program from the IDE in debug mode, all these options are automatically set for you. You can set breakpoint just by clicking on the source code in the editor. You can have a separate form to add, remove, and edit breakpoints. Breakpoints can be attached to specific lines or specific events, like when an exception is thrown. Breakpoints attached to a specific line can also have conditions that tell the debugger to stop the execution of the code only when the condition is true; for example, if a variable has some predefined value.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter we were introduced to each other with Java. We do not know too much from each other but we got acquainted. We have installed the Java environment: Java, JDK and integrated development environment. We have written a small program and had a brief look at what can be done using the development tools. This is far from mastery but even the longest journey starts with a first step, which is sometimes the hardest to make. We have done it in our Java journey. We started rolling and for the enthusiasts that we are, nothing can stop us walking all the way long.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>