<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Deploying Your Web Application to the Cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Deploying Your Web Application to the Cloud</h1></div></div></div><p>In this chapter, we'll take a tour of the different cloud providers, understand the challenges and benefits of a distributed architecture, and see how to deploy your web application to Pivotal Web Services and to Heroku.</p><div class="section" title="Choosing your host"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Choosing your host</h1></div></div></div><p>There are many forms of cloud hosting. For developers, the choice will be mainly between a Platform as a Service (PaaS) and an Infrastructure as a Service (IaaS).</p><p>Using the latest, you will often have a bare metal machine that you can manage and on which you<a id="id544" class="indexterm"/> can install all the services required by your application.</p><p>If we leave aside technologies such as Docker (which is absolutely amazing, you should absolutely give it a try), this is really similar to traditional hosting where your operation team will have to set up and maintain an environment in which the application can run.</p><p>On the other hand, PaaS makes it easy to deploy your application as you develop it with a simple push-to-deploy workflow.</p><p>The most well known providers are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cloud Foundry backed by Pivotal</li><li class="listitem" style="list-style-type: disc">OpenShift by Red Hat</li><li class="listitem" style="list-style-type: disc">Heroku acquired by Salesforce in 2010</li></ul></div><p>Each of these three providers come with different pros and cons. I will try to give you an overview of these.</p><div class="section" title="Cloud Foundry"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec66"/>Cloud Foundry</h2></div></div></div><p>Backed by Pivotal, the company behind Spring, Pivotal Web Service runs on Cloud Foundry, an <a id="id545" class="indexterm"/>open source PaaS maintained by a foundation, and comes with an interesting package.</p><p>They offer a 60<a id="id546" class="indexterm"/> day free trial and their pricing is a function of the memory allocated for your instances and the number of instances you own.</p><p>Their prices range from $2.70 per month for the smallest (128 Mb) instance to $43.20 per month for the 2 GB instance.</p><p>If you want to give it a try, no credit card is required for the free trial. They have a market place to easily install services, such as Redis or Postgre SQL, with rather limited free options. They have a good command-line utility to manage your application from your console. You can either use buildpacks or push a JAR directly for deployment.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>Build packs will try to guess the stack that you are using and build your application in the most standard way (<code class="literal">mvn package</code> for Maven, <code class="literal">./gradlew stage</code> for Gradle, and so on).</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Refer to the<a id="id547" class="indexterm"/> tutorial available at the following URL to deploy your application to Cloud Foundry:</p><p>
<a class="ulink" href="http://docs.cloudfoundry.org/buildpacks/java/gsg-spring.html">http://docs.cloudfoundry.org/buildpacks/java/gsg-spring.html</a>
</p></div></div></div><div class="section" title="OpenShift"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec67"/>OpenShift</h2></div></div></div><p>
<span class="strong"><strong>OpenShift</strong></span> is maintained by Red Hat and powered by OpenShift Origin, an open source facility running <a id="id548" class="indexterm"/>Docker containers on top of Google's Kubernetes.</p><p>It is priced <a id="id549" class="indexterm"/>well and offers a lot of freedom, as it is both a PaaS and an IaaS. Its pricing is based on gears, containers running an application, or a service such as Jenkins, or a database.</p><p>OpenShift has a free plan offering three small gears. Your application must be idle for 24 hours per month unless you enter your billing information.</p><p>Additional or bigger gears are billed at approximately $15 a month for the smallest, and $72 for the biggest.</p><p>To deploy a Spring Boot application on OpenShift, you will have to use the Do It Yourself cartridge. It is a bit more work than other buildpack-based PaaS but it is also easier to configure.</p><p>Take a look at the blog <a id="id550" class="indexterm"/>post for a Spring Boot tutorial with OpenShift, which<a id="id551" class="indexterm"/> is available at <a class="ulink" href="http://blog.codeleak.pl/2015/02/openshift-diy-build-spring-boot.html">http://blog.codeleak.pl/2015/02/openshift-diy-build-spring-boot.html</a>.</p></div><div class="section" title="Heroku"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec68"/>Heroku</h2></div></div></div><p>Heroku is a well known PaaS with extensive documentation and a code-centric approach based on build packs. It can connect to a lot of services called add-ons, but using them requires <a id="id552" class="indexterm"/>your billing information.</p><p>It is really interesting <a id="id553" class="indexterm"/>for a free project and is very fast to get started with. The downside is that it directly costs more than $25 per month if you want to scale up. Free instances will go into the sleep mode after 30 minutes of inactivity, which means free Heroku apps will always take as much as 30 seconds to load.</p><p>Heroku has a great administration dashboard and command-line tools. For this chapter, I chose Heroku because it is very straightforward. The concepts you will grasp here are applicable to most PaaS.</p><p>You can follow most of the chapter and deploy your application without providing your credit card information as long as you do not use the Redis add-on. You won't be charged if you select the free plan.</p></div></div></div>
<div class="section" title="Deploying your web application to Pivotal Web Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Deploying your web application to Pivotal Web Services</h1></div></div></div><p>Follow this <a id="id554" class="indexterm"/>section if you want to <a id="id555" class="indexterm"/>deploy your application to Pivotal Web Services (PWS).</p><div class="section" title="Installing the Cloud Foundry CLI tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec69"/>Installing the Cloud Foundry CLI tools</h2></div></div></div><p>The first<a id="id556" class="indexterm"/> thing we need to do to create a <a id="id557" class="indexterm"/>Cloud Foundry application is to set up an <a id="id558" class="indexterm"/>account on PWS. This is documented at <a class="ulink" href="http://docs.run.pivotal.io/starting/">http://docs.run.pivotal.io/starting/</a>.</p><p>You will be asked to create an organization and each new organization will have a default space (development) created within the organization. As shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_09_04.jpg" alt="Installing the Cloud Foundry CLI tools"/></div><p>On the left-hand <a id="id559" class="indexterm"/>side navigation bar, you<a id="id560" class="indexterm"/> will see a link to <span class="strong"><strong>Tools</strong></span> from which you download the CLI. It is also available from the developer console. Select the appropriate package for your operating system:</p><div class="mediaobject"><img src="graphics/2117_09_05.jpg" alt="Installing the Cloud Foundry CLI tools"/></div></div><div class="section" title="Assembling the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec70"/>Assembling the application</h2></div></div></div><p>Our application <a id="id561" class="indexterm"/>simply needs to be assembled for deployment.</p><p>The good thing with PWS is that you don't have to push your sources to deploy. You can generate the JAR, push it, and everything will be autodetected.</p><p>We can package this for deployment with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./gradlew assemble</strong></span>
</pre></div><p>This will create a jar file in the <code class="literal">build/libs</code> directory. At this point, you can execute the following command. The following command targets your deployment to your space within PWS (<code class="literal">run.pivotal.io</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cf login -a api.run.pivotal.io -u &lt;account email&gt; -p &lt;password&gt; -o &lt;organization&gt; -s development</strong></span>

<span class="strong"><strong>API endpoint: api.run.pivotal.io</strong></span>
<span class="strong"><strong>Authenticating...</strong></span>
<span class="strong"><strong>OK</strong></span>

<span class="strong"><strong>Targeted org &lt;account org&gt;</strong></span>

<span class="strong"><strong>Targeted space development</strong></span>


<span class="strong"><strong>                   </strong></span>
<span class="strong"><strong>API endpoint:   https://api.run.pivotal.io (API version: 2.33.0)   </strong></span>
<span class="strong"><strong>User:           &lt;account email&gt;   </strong></span>
<span class="strong"><strong>Org:            &lt;account organization&gt;   </strong></span>
<span class="strong"><strong>Space:          &lt;account space&gt;</strong></span>
</pre></div><p>Once you have successfully logged in, you can push your jar with the following command. You will need to come up with an available name:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cf push your-app-name -p build/libs/masterSpringMvc-0.0.1-SNAPSHOT.jar</strong></span>

<span class="strong"><strong>Creating app msmvc4 in org Northwest / space development as wlund@pivotal.io...</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>Creating route msmvc4.cfapps.io...</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>Binding msmvc4.cfapps.io to msmvc4...</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>Uploading msmvc4...</strong></span>
<span class="strong"><strong>Uploading app files from: build/libs/masterSpringMvc-0.0.1-SNAPSHOT.jar</strong></span>
<span class="strong"><strong>Uploading 690.8K, 108 files</strong></span>
<span class="strong"><strong>Done uploading               </strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>Starting app msmvc4 in org &lt;Organization&gt; / space development as &lt;account email&gt;</strong></span>
<span class="strong"><strong>-----&gt; Downloaded app package (15M)</strong></span>
<span class="strong"><strong>-----&gt; Java Buildpack Version: v3.1 | https://github.com/cloudfoundry/java-buildpack.git#7a538fb</strong></span>
<span class="strong"><strong>-----&gt; Downloading Open Jdk JRE 1.8.0_51 from https://download.run.pivotal.io/openjdk/trusty/x86_64/openjdk-1.8.0_51.tar.gz (1.5s)</strong></span>
<span class="strong"><strong>       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.4s)</strong></span>
<span class="strong"><strong>-----&gt; Downloading Open JDK Like Memory Calculator 1.1.1_RELEASE from https://download.run.pivotal.io/memory-calculator/trusty/x86_64/memory-calculator-1.1.1_RELEASE (0.1s)</strong></span>
<span class="strong"><strong>       Memory Settings: -Xmx768M -Xms768M -XX:MaxMetaspaceSize=104857K -XX:MetaspaceSize=104857K -Xss1M</strong></span>
<span class="strong"><strong>-----&gt; Downloading Spring Auto Reconfiguration 1.7.0_RELEASE from https://download.run.pivotal.io/auto-reconfiguration/auto-reconfiguration-1.7.0_RELEASE.jar (0.0s)</strong></span>
<span class="strong"><strong>-----&gt; Uploading droplet (59M)</strong></span>
<span class="strong"><strong>0 of 1 instances running, 1 starting</strong></span>
<span class="strong"><strong>1 of 1 instances running</strong></span>

<span class="strong"><strong>App started</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>App msmvc4 was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-1.1.1_RELEASE -memorySizes=metaspace:64m.. -memoryWeights=heap:75,metaspace:10,stack:5,native:10 -totMemory=$MEMORY_LIMIT) &amp;&amp; SERVER_PORT=$PORT $PWD/.java-buildpack/open_jdk_jre/bin/java -cp $PWD/.:$PWD/.java-buildpack/spring_auto_reconfiguration/spring_auto_reconfiguration-1.7.0_RELEASE.jar -Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY org.springframework.boot.loader.JarLauncher`</strong></span>

<span class="strong"><strong>Showing health and status for app msmvc4 in org &lt;Organization&gt; / space development as &lt;Account Email&gt;</strong></span>
<span class="strong"><strong>OK</strong></span>

<span class="strong"><strong>requested state: started</strong></span>
<span class="strong"><strong>instances: 1/1</strong></span>
<span class="strong"><strong>usage: 1G x 1 instances</strong></span>
<span class="strong"><strong>urls: msmvc4.cfapps.io</strong></span>
<span class="strong"><strong>last uploaded: Tue Jul 28 22:04:08 UTC 2015</strong></span>
<span class="strong"><strong>stack: cflinuxfs2</strong></span>
<span class="strong"><strong>buildpack: java-buildpack=v3.1-https://github.com/cloudfoundry/java-buildpack.git#7a538fb java-main open-jdk-like-jre=1.8.0_51 open-jdk-like-memory-calculator=1.1.1_RELEASE spring-auto-reconfiguration=1.7.0_RELEASE</strong></span>

<span class="strong"><strong>     state     since                    cpu    memory         disk         details   </strong></span>
<span class="strong"><strong>#0   running   2015-07-28 03:05:04 PM   0.0%   450.9M of 1G   137M of 1G</strong></span>
</pre></div><p>There is a lot that the platform is performing on your behalf. It provisions a container and detects <a id="id562" class="indexterm"/>which buildpack is needed, in this case, Java.</p><p>It then installs the required JDK and uploads the application we pointed it to. It creates a route to the application, which it reports to us, and then launches the application for us.</p><p>Now you can view the application on the developer console:</p><div class="mediaobject"><img src="graphics/2117_09_06.jpg" alt="Assembling the application"/></div><p>On selecting the highlighted route, the application will be available for use. Visit <a class="ulink" href="http://msmvc4.cfapps.io">http://msmvc4.cfapps.io</a>, then you will see the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_09_01.jpg" alt="Assembling the application"/></div><p>Bravo!</p><p>The only thing that <a id="id563" class="indexterm"/>will not work yet is the file upload. However, we will fix that in a minute.</p></div><div class="section" title="Activating Redis"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec71"/>Activating Redis</h2></div></div></div><p>In your application <a id="id564" class="indexterm"/>services, you can choose between many services. One of them is Redis Cloud, which has a free plan with 30 MB of storage. Go <a id="id565" class="indexterm"/>ahead and select this plan.</p><p>In the form, choose whatever name you fancy and bind the service to your application. By default, Cloud Foundry will inject some properties in relation to the service in your environment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">cloud.services.redis.connection.host</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">cloud.services.redis.connection.port</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">cloud.services.redis.connection.password</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">cloud.services.redis.connection.uri</code></li></ul></div><p>These properties <a id="id566" class="indexterm"/>will always follow the same convention, so it<a id="id567" class="indexterm"/> will be easy to keep track of your services as you add more.</p><p>By default, Cloud Foundry launches Spring applications and activates the Cloud profile.</p><p>We can take advantage of this and create an <code class="literal">application-cloud.properties</code> file in <code class="literal">src/main/resources</code>, which will be used when our application is running on PWS:</p><div class="informalexample"><pre class="programlisting">spring.profiles.active=prod,redis

spring.redis.host=${cloud.services.redis.connection.host}
spring.redis.port=${cloud.services.redis.connection.port}
spring.redis.password=${cloud.services.redis.connection.password}

upload.pictures.uploadPath=file:/tmp</pre></div><p>This will bind our Redis instance to our application and activate two additional profiles: <code class="literal">prod</code> and <code class="literal">redis</code>.</p><p>We also changed the path where the uploaded pictures will land. Note that using the file system on the cloud obeys different rules. Refer to the following link for more details:</p><p>
<a class="ulink" href="http://docs.run.pivotal.io/devguide/deploy-apps/prepare-to-deploy.html#filesystem">http://docs.run.pivotal.io/devguide/deploy-apps/prepare-to-deploy.html#filesystem</a>
</p><p>The last thing we need to do is deactivate one Spring Session feature that will not be available on our hosted instance:</p><div class="informalexample"><pre class="programlisting">@Bean
@Profile({"cloud", "heroku"})
public static ConfigureRedisAction configureRedisAction() {
    return ConfigureRedisAction.NO_OP;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>For more information, visit <a class="ulink" href="http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent">http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent</a>.</p></div></div><p>You will see that this configuration will also be applied on Heroku. </p><p>That's it. You <a id="id568" class="indexterm"/>can reassemble your web application and <a id="id569" class="indexterm"/>push it again. Now, your sessions and application cache will be stored on Redis!</p><p>You may want to explore the marketplace for other available features such as binding to data or messaging services, scaling the application, and managing the health of the applications that are beyond the scope of this introduction.</p><p>Have fun and enjoy the productivity the platform provides!</p></div></div>
<div class="section" title="Deploying your web application on Heroku"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Deploying your web application on Heroku</h1></div></div></div><p>In this section, we <a id="id570" class="indexterm"/>will deploy your application on<a id="id571" class="indexterm"/> Heroku for free. We will even use the free Redis instance available to store our session and cache.</p><div class="section" title="Installing the tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec72"/>Installing the tools</h2></div></div></div><p>The first thing <a id="id572" class="indexterm"/>we need to do to create a Heroku <a id="id573" class="indexterm"/>application is to download the command-line tools available at <a class="ulink" href="https://toolbelt.heroku.com">https://toolbelt.heroku.com</a>.</p><p>On Mac, you can also install it with <code class="literal">brew</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; brew install heroku-toolbelt</strong></span>
</pre></div><p>Create an account on Heroku and use <code class="literal">heroku login</code> to link the toolbelt to your account:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; heroku login</strong></span>
<span class="strong"><strong>Enter your Heroku credentials.</strong></span>
<span class="strong"><strong>Email: geowarin@mail.com</strong></span>
<span class="strong"><strong>Password (typing will be hidden):</strong></span>
<span class="strong"><strong>Authentication successful.</strong></span>
</pre></div><p>Then, go to your application root and type <code class="literal">heroku create appName --region eu</code>. Replace <code class="literal">appName</code> with a name of your choice. If you don't provide a name, it will be generated automatically:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; heroku create appname --region eu</strong></span>
<span class="strong"><strong>Creating appname... done, region is eu</strong></span>
<span class="strong"><strong>https://appname.herokuapp.com/ | https://git.heroku.com/appname.git</strong></span>
<span class="strong"><strong>Git remote heroku added</strong></span>
</pre></div><p>If you have already created an application with the UI, then go to your application root and simply add the remote <code class="literal">heroku git:remote -a yourapp</code>.</p><p>What these commands do is add a Git remote called <code class="literal">heroku </code>to our Git repository. The process of deploying on Heroku is just pushing one of your branches to Heroku. The Git hooks installed on the remote<a id="id574" class="indexterm"/> will take care of the rest.</p><p>If you type <code class="literal">git remote -v</code> command, you should see the <code class="literal">heroku</code> version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; git remote -v</strong></span>
<span class="strong"><strong>heroku    https://git.heroku.com/appname.git (fetch)</strong></span>
<span class="strong"><strong>heroku    https://git.heroku.com/appname.git (push)</strong></span>
<span class="strong"><strong>origin    https://github.com/Mastering-Spring-MVC-4/mastering-spring-mvc4-code.git (fetch)</strong></span>
<span class="strong"><strong>origin    https://github.com/Mastering-Spring-MVC-4/mastering-spring-mvc4-code.git (push)</strong></span>
</pre></div></div><div class="section" title="Setting up the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Setting up the application</h2></div></div></div><p>We need two <a id="id575" class="indexterm"/>ingredients to run a Gradle application<a id="id576" class="indexterm"/> with Heroku: a task in our build file called <code class="literal">stage</code> and a tiny file that contains the command used to run our application, called <code class="literal">ProcFile</code>.</p><div class="section" title="Gradle"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec01"/>Gradle</h3></div></div></div><p>The Gradle build pack <a id="id577" class="indexterm"/>will automatically try to run the <code class="literal">./gradlew stage</code> command <a id="id578" class="indexterm"/>on the root of your application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>You can <a id="id579" class="indexterm"/>get more information on the Gradle build pack at <a class="ulink" href="https://github.com/heroku/heroku-buildpack-gradle">https://github.com/heroku/heroku-buildpack-gradle</a>.</p></div></div><p>We do not have a "stage" task yet. Add the following code to your <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">task stage(type: Copy, dependsOn: [clean, build]) {
    from jar.archivePath
    into project.rootDir
    rename {
        'app.jar'
    }
}
stage.mustRunAfter(clean)

clean &lt;&lt; {
    project.file('app.jar').delete()
}</pre></div><p>This will define a task called <code class="literal">stage</code>, which will copy the jar generated by Spring Boot at the root of the application and call it <code class="literal">app.jar</code>.</p><p>The jar be much easier to find this way. The <code class="literal">stage</code> task depends on the <code class="literal">clean</code> task and the <code class="literal">build</code> task, which means that both of them will be executed before the stage task starts.</p><p>By default, Gradle <a id="id580" class="indexterm"/>will try to optimize the task dependency graph. So, we<a id="id581" class="indexterm"/> must provide a hint and force the <code class="literal">clean</code> task to be run before <code class="literal">stage</code>.</p><p>Finally, we add a new instruction to the already existing <code class="literal">clean</code> task, which is to delete the generated <code class="literal">app.jar</code> file.</p><p>Now, if you run <code class="literal">./gradlew stage</code>, it should run the tests and put the packaged app at the root of the project.</p></div><div class="section" title="Procfile"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec02"/>Procfile</h3></div></div></div><p>When Heroku detects a Gradle application, it will automatically run a container with Java 8 installed. So, we have very little configuration to take care of.</p><p>We will need a<a id="id582" class="indexterm"/> file containing the shell command used to run our application. Create <a id="id583" class="indexterm"/>a file named <code class="literal">Procfile</code> at the root of your application:</p><div class="informalexample"><pre class="programlisting">web: java -Dserver.port=$PORT -Dspring.profiles.active=heroku,prod -jar app.jar</pre></div><p>There are several things to note here. First, we declare our application as a web application. We also redefine the port on which our application will run using an environment variable. This is very important as your app will cohabit with many others and only one port will be allocated to each one.</p><p>Finally, you can see that our application will run using two profiles. The first is the <code class="literal">prod</code> profile, which we created in the previous chapter, to optimize the performance, and a new <code class="literal">heroku</code> profile that we will create in a moment.</p></div></div><div class="section" title="A Heroku profile"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec74"/>A Heroku profile</h2></div></div></div><p>We do not want to put sensible information, such as our Twitter app keys, into source control. So, we have to <a id="id584" class="indexterm"/>create some properties that will read those from the application environment:</p><div class="informalexample"><pre class="programlisting">spring.social.twitter.appId=${twitterAppId}
spring.social.twitter.appSecret=${twitterAppSecret}</pre></div><p>For this to work, you have to configure the two environment variables, which we discussed earlier, on Heroku. You can do this with the toolbelt:</p><div class="informalexample"><pre class="programlisting">&gt; heroku config:set twitterAppId=appId</pre></div><p>Alternatively, you can go to your dashboard and configure the environment in the settings tab:</p><div class="mediaobject"><img src="graphics/2117_09_02.jpg" alt="A Heroku profile"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Visit <a class="ulink" href="https://devcenter.heroku.com/articles/config-vars">https://devcenter.heroku.com/articles/config-vars</a> for more<a id="id585" class="indexterm"/> information.</p></div></div></div><div class="section" title="Running your application"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec75"/>Running your application</h2></div></div></div><p>It is now time<a id="id586" class="indexterm"/> to run our application on Heroku!</p><p>If you haven't <a id="id587" class="indexterm"/>already done so, commit all your changes to your master branch. Now, simply push your master branch to the <code class="literal">heroku</code> remote with <code class="literal">git push heroku master</code>. This will download all the dependencies and build your application from scratch, so it can take a little time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; git push heroku master</strong></span>
<span class="strong"><strong>Counting objects: 1176, done.</strong></span>
<span class="strong"><strong>Delta compression using up to 8 threads.</strong></span>
<span class="strong"><strong>Compressing objects: 100% (513/513), done.</strong></span>
<span class="strong"><strong>Writing objects: 100% (1176/1176), 645.63 KiB | 0 bytes/s, done.</strong></span>
<span class="strong"><strong>Total 1176 (delta 485), reused 1176 (delta 485)</strong></span>
<span class="strong"><strong>remote: Compressing source files... done.</strong></span>
<span class="strong"><strong>remote: Building source:</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Gradle app detected</strong></span>
<span class="strong"><strong>remote: -----&gt; Installing OpenJDK 1.8... done</strong></span>
<span class="strong"><strong>remote: -----&gt; Building Gradle app...</strong></span>
<span class="strong"><strong>remote:        WARNING: The Gradle buildpack is currently in Beta.</strong></span>
<span class="strong"><strong>remote: -----&gt; executing ./gradlew stage</strong></span>
<span class="strong"><strong>remote:        Downloading https://services.gradle.org/distributions/gradle-2.3-all.zip</strong></span>

<span class="strong"><strong>...</strong></span>

<span class="strong"><strong>remote:        :check</strong></span>
<span class="strong"><strong>remote:        :build</strong></span>
<span class="strong"><strong>remote:        :stage</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote:        BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote:        Total time: 2 mins 36.215 secs</strong></span>
<span class="strong"><strong>remote: -----&gt; Discovering process types</strong></span>
<span class="strong"><strong>remote:        Procfile declares types -&gt; web</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Compressing... done, 130.1MB</strong></span>
<span class="strong"><strong>remote: -----&gt; Launching... done, v4</strong></span>
<span class="strong"><strong>remote:        https://appname.herokuapp.com/ deployed to Heroku</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: Verifying deploy.... done.</strong></span>
<span class="strong"><strong>To https://git.heroku.com/appname.git</strong></span>
<span class="strong"><strong>* [new branch]      master -&gt; master</strong></span>
</pre></div><p>Once the<a id="id588" class="indexterm"/> application has been built, it will automatically<a id="id589" class="indexterm"/> run. Type <code class="literal">heroku logs</code> to see the latest logs or <code class="literal">heroku logs -t</code> to tail them.</p><p>You can see your application running in the console and if all goes as planned, you will be able to connect to <a class="ulink" href="http://yourapp.herokuapp.com">http://yourapp.herokuapp.com</a>. As shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_09_03.jpg" alt="Running your application"/></div><p>We are live! It's time to tell your friends!</p></div><div class="section" title="Activating Redis"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec76"/>Activating Redis</h2></div></div></div><p>To activate<a id="id590" class="indexterm"/> Redis in our application, we can choose between a few <a id="id591" class="indexterm"/>alternatives. The Heroku Redis add-on is the beta version. It is entirely free with 20 MB of storage, analytics, and logs.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>Visit <a class="ulink" href="https://elements.heroku.com/addons/heroku-redis">https://elements.heroku.com/addons/heroku-redis</a> for more <a id="id592" class="indexterm"/>details.</p></div></div><p>At this stage, you will have to provide your credit card details to proceed.</p><p>To install the Redis add-on for your application, type the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>heroku addons:create heroku-redis:test</strong></span>
</pre></div><p>Now, that we have activated the add-on, an environment variable called <code class="literal">REDIS_URL </code>will be available when our application will be running on Heroku.</p><p>You can<a id="id593" class="indexterm"/> check<a id="id594" class="indexterm"/> that the variable is defined with the <code class="literal">heroku config</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; heroku config</strong></span>
<span class="strong"><strong>=== masterspringmvc Config Vars</strong></span>
<span class="strong"><strong>JAVA_OPTS:        -Xmx384m -Xss512k -XX:+UseCompressedOops</strong></span>
<span class="strong"><strong>REDIS_URL:        redis://x:xxx@ec2-xxx-xx-xxx-xxx.eu-west-1.compute.amazonaws.com:6439</strong></span>
</pre></div><p>Since the <code class="literal">RedisConnectionFactory</code> class does not understand URIs, we need to tweak it a little bit:</p><div class="informalexample"><pre class="programlisting">@Configuration
@Profile("redis")
@EnableRedisHttpSession
public class RedisConfig {

    @Bean
    @Profile("heroku")
    public RedisConnectionFactory redisConnectionFactory() throws URISyntaxException {
        JedisConnectionFactory redis = new JedisConnectionFactory();

        String redisUrl = System.getenv("REDIS_URL");
        URI redisUri = new URI(redisUrl);
        redis.setHostName(redisUri.getHost());
        redis.setPort(redisUri.getPort());
        redis.setPassword(redisUri.getUserInfo().split(":", 2)[1]);

        return redis;
    }

    @Bean
         @Profile({"cloud", "heroku"})
    public static ConfigureRedisAction configureRedisAction() {
        return ConfigureRedisAction.NO_OP;
    }
}</pre></div><p>We now have two Heroku-specific beans in the <code class="literal">RedisConfig</code> class. These beans will only be active if both the <code class="literal">redis</code> and <code class="literal">heroku</code> profiles are active.</p><p>Note that we also deactivated some Spring Session configuration.</p><p>Spring Session will normally listen to events associated to destroyed session keys via the Redis Pub/Sub interface.</p><p>It will <a id="id595" class="indexterm"/>automatically try to configure the Redis environment to<a id="id596" class="indexterm"/> activate listeners on startup. In a secured environment like ours, adding listeners is not permitted unless you have an admin access.</p><p>These redis listeners are not really important in our case, so we can safely disable this behavior. For more information, visit <a class="ulink" href="http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent">http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent</a>.</p><p>We need to modify our <code class="literal">Procfile</code> file so that Heroku runs our application with the <code class="literal">redis</code> profile:</p><div class="informalexample"><pre class="programlisting">web: java -Dserver.port=$PORT -Dspring.profiles.active=heroku,redis,prod -jar app.jar</pre></div><p>Commit your change and push the code to Heroku.</p></div></div>
<div class="section" title="Improving your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Improving your application</h1></div></div></div><p>We have a pretty good application deployed online but it's not uber useful nor original until you <a id="id597" class="indexterm"/>make it so.</p><p>Try to make it better and more personal. Once you're proud of your achievement, tweet your application URL with the <code class="literal">#masterspringmvc</code> hashtag on Twitter.</p><p>Try to push the best application possible. There is so much that we didn't do. Here are some ideas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Delete users' old pictures to avoid keeping unused pictures</li><li class="listitem" style="list-style-type: disc">Use Twitter authentication information to fill the user profile</li><li class="listitem" style="list-style-type: disc">Interact with the user's account</li><li class="listitem" style="list-style-type: disc">See real-time searches happening on your app with a web socket channel</li></ul></div><p>Let your imagination fly!</p><p>My version of the application is deployed on <a class="ulink" href="http://masterspringmvc.herokuapp.com">http://masterspringmvc.herokuapp.com</a>. I will improve some details to make the application a little more reactive. Try to spot the differences!</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Summary</h1></div></div></div><p>Deploying our application on a cloud provider is really straightforward as it is a runnable jar, thanks to Spring Boot. Cloud deployment is very affordable nowadays and deploying a Java application has become almost too easy.</p><p>With sessions backed by Redis, we laid the basics of a scalable application. Indeed, we can effortlessly add multiple servers behind a load balancer and absorb high traffic on demand.</p><p>The only thing that is not scalable is our WebSocket that will need additional work to run on top of a message broker, such as Rabbit MQ.</p><p>I can certainly remember a time where finding a host running a Tomcat was rare and pricey. Those days are long gone and the future belongs to web developers, so make it happen!</p><p>In the next chapter, we will see what we can do to make our application even better, discuss the technologies we haven't covered, talk about the Spring ecosystem in general, and the challenges of modern web applications.</p></div></body></html>