<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Miscellaneous Improvements in JDK 11</h1>
                </header>
            
            <article>
                
<p>Java 11 covers a number of additional interesting changes that we cannot cover in individual chapters. However, this doesn't mean that they are not relevant or important enough, but because their details are beyond the scope of this book. For instance, nest-based access includes changes to the <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) specification, dynamic class-file constants extending existing class-file constants, improvements with cryptography layers and <strong>Transport Layer Security</strong> (<strong>TLS</strong>), and more.</p>
<p>This chapter includes an overview of the remaining JDK 11 features that are related to the SE, JDK, and implementation of Java 11 features.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Nest-based access control</li>
<li>Dynamic class-file constants</li>
<li>Improving AArch64 intrinsics</li>
<li>Removing the Java EE and CORBA modules</li>
<li>A key agreement with Curve25519 and Curve448</li>
<li>Unicode 10</li>
<li>ChaCha20 and Poly1305 cryptographic algorithms</li>
<li>Launching single file source code programs</li>
<li>TLS 1.3</li>
<li>Deprecating the Nashorn JavaScript engine</li>
<li>Deprecating the pack200 tools and API</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To work with the code that is included in this chapter, you'll need JDK 11, or later, installed on your system.</p>
<p>Since this chapter covers multiple features in Java 11, let's quickly map the features with their <strong>JDK Enhancement Proposal</strong> (<strong>JEP</strong>) number and scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing the JEPs that are used in this chapter</h1>
                </header>
            
            <article>
                
<p>The following table lists the JDK 11 features that are covered in this chapter, their corresponding JEP number, and scope:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td>
<p><strong>JEP</strong></p>
</td>
<td>
<p><strong>Scope</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>181</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>Nest-based access control</p>
</td>
</tr>
<tr>
<td>
<p>309</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>Dynamic class-file constants</p>
</td>
</tr>
<tr>
<td>
<p>315</p>
</td>
<td>
<p>Implementation</p>
</td>
<td>
<p>Improving AArch64 intrinsics</p>
</td>
</tr>
<tr>
<td>
<p>320</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>Removing the Java EE and CORBA modules</p>
</td>
</tr>
<tr>
<td>
<p>324</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>A key agreement with Curve25519 and Curve448</p>
</td>
</tr>
<tr>
<td>
<p>327</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>Unicode 10</p>
</td>
</tr>
<tr>
<td>
<p>329</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>ChaCha20 and Poly1305 cryptographic algorithms</p>
</td>
</tr>
<tr>
<td>
<p>330</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Launch single file source code programs</p>
</td>
</tr>
<tr>
<td>
<p>332</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>TLS 1.3</p>
</td>
</tr>
<tr>
<td>
<p>335</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Deprecate the Nashorn JavaScript engine</p>
</td>
</tr>
<tr>
<td>
<p>336</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>Deprecate the pack200 tools and API</p>
</td>
</tr>
</tbody>
</table>
<p>Let's get started with the first feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nest-based access control</h1>
                </header>
            
            <article>
                
<p>Imagine what happens when you define nested classes or interfaces? For instance, if you define a <em>two-level class</em>, say <kbd>Outer</kbd>, and an <em>inner class</em>, say <kbd>Inner</kbd>, can <kbd>Inner</kbd> access the <kbd>private</kbd> instance variables of <kbd>Outer</kbd>? Here's some sample code:</p>
<pre>public class Outer { 
    private int outerInt = 20; 
    public class Inner { 
        int innerInt = outerInt;     // Can Inner access outerInt? 
    } 
} </pre>
<p>Yes, it can. Since you define these classes within the same source code file, you might assume it to be obvious. However, it is not. The compiler generates separate bytecode files (<kbd>.class</kbd>) for the <kbd>Outer</kbd> and <kbd>Inner</kbd> classes. For the preceding example, the compiler creates two bytecode files: <kbd>Outer.class</kbd> and <kbd>Outer$Inner.class</kbd>. For your quick reference, the bytecode file of an inner class is preceded by the name of its outer class and a dollar sign.</p>
<p>To enable the access of variables across these classes and to preserve the expectations of programmers, the compiler broadens the access of private members to a package or adds bridge variables or methods in each of these classes. Here's the decompiled version of the <kbd>Outer</kbd> and <kbd>Inner</kbd> classes that have been decompiled using the <strong>JAD Java Decompiler</strong>:</p>
<pre>// Decompiled class Outer 
public class Outer { 
    public class Inner { 
        int innerInt; 
        final Outer this$0; 
 
        public Inner() { 
            this$0 = Outer.this; 
            super(); 
            innerInt = outerInt; 
        } 
    } 
    public Outer() { 
        outerInt = 20; 
    } 
    private int outerInt; 
} </pre>
<p>And here is the <kbd>Outer$Inner</kbd> <span>decompiled class, as follows:</span></p>
<pre>public class Outer$Inner { 
    int innerInt; 
    final Outer this$0; 
 
    public Outer$Inner() { 
        this$0 = Outer.this; 
        super(); 
        innerInt = outerInt; 
    } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>As you will notice, the decompiled versions verify that the compiler defined a bridge variable, that is, <kbd>this$0</kbd> of type <kbd>Outer</kbd> in the <kbd>Inner</kbd> class, to access members of <kbd>Outer</kbd> from <kbd>Inner</kbd>.</p>
<p>These bridge variables and methods risk encapsulation and increase the size of the deployed application. They can also confuse developers and tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is nest-based access?</h1>
                </header>
            
            <article>
                
<p>JEP 181 introduces nest-based access control. As you know, classes and interfaces, which are defined within another class or interface are compiled to separate class files. To access each other's private members, compilers had been either broadening their access levels or inserting bridge methods.</p>
<p>Nest-based access control allows such classes and interfaces to access each other's private members, without any workarounds (or bridge code) by the compiler.</p>
<p><span>Nest-based access control also results in changes to the JVM specification. You can refer to the following link to access these changes (removals are highlighted by a red font background and additions are highlighted using the green background): </span><a href="https://cr.openjdk.java.net/~dlsmith/nestmates.html"><span class="URLPACKT">https://cr.openjdk.java.net/~dlsmith</span><span class="URLPACKT">/</span><span class="URLPACKT">nestmates.html</span></a><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Affects of nest-based control</h1>
                </header>
            
            <article>
                
<p>Though it might seem simple, nest-based access control affects all specifications and APIs —which involve access control or method invocation—either implicitly or explicitly. As mentioned in the <em>What is nest-based access?</em> section, it includes changes in the JVM specification. It also affects class file attributes, access control rules, bytecode invocation rules, reflection, method invocation, and field access rules.</p>
<p>It also adds new class file attributes, modifies <kbd>MethodHandle</kbd> lookup rules, results in class transformation/redefinition—the JVM TI and <kbd>java.lang.instrument</kbd> APIs, JDWP, and JDI (<kbd>com.sun.jdi.VirtualMachine</kbd>).</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic class-file constants</h1>
                </header>
            
            <article>
                
<p>JEP 309 extends the existing Java class-file format, creating <kbd>CONSTANT_Dynamic</kbd>. This is a JVM feature and doesn't depend on the higher software layers. The loading of <kbd>CONSTANT_Dynamic</kbd> delegates the creation of a bootstrap method. When comparing it to the <strong>invokedynamic</strong> call, you will see how it delegates linking to a bootstrap method.</p>
<p>One of the main goals of dynamic class-file constants is to make it simple to create new forms of materializable class-file constants, which provides language designers and compiler implementers with broader options for expressivity and performance. This is achieved by creating a new constant pool form that can be parameterized using a bootstrap method with static arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving AArch64 intrinsics</h1>
                </header>
            
            <article>
                
<p>JEP 315 works by improving intrinsics on AArch64 processors. The current string and array intrinsic are improved. Also a new intrinsic is implemented for the sine, cosine, and logarithmic<em><span> </span></em>functions in <kbd>java.lang.Math</kbd>.</p>
<p>In order to enhance application performance, intrinsics utilize an assembly code that is specific to CPU architecture. It does not execute generic Java code.</p>
<p>Note that you will see AArch64 processors having an implementation of most of the intrinsics. However, JEP 315 implemented an optimized intrinsic for the following methods in the <kbd>java.lang.Math</kbd> class that was not up to the mark:</p>
<ul>
<li><kbd>sin()</kbd></li>
<li><kbd>cos()</kbd></li>
<li><kbd>log()</kbd></li>
</ul>
<p>It is also worth noting that some of the intrinsics that are previously implemented in the AArch64 port might not be completely optimal. Such intrinsic can take advantage of features such as memory address alignment or software prefetching instructions. Some of those methods are listed as follows:</p>
<ul>
<li><kbd>String::compareTo</kbd></li>
<li><kbd>String::indexOf</kbd></li>
<li><kbd>StringCoding::hasNegatives</kbd></li>
<li><kbd><kbd>Arrays::equals</kbd></kbd></li>
<li><kbd>StringUTF16::compress</kbd></li>
<li><kbd>StringLatin1::inflate</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing the Java EE and CORBA modules</h1>
                </header>
            
            <article>
                
<p>Java EE moved to the Eclipse Foundation with Java 9 under a new name – Jakarta EE (interestingly, still JEE). With Java 9, the modules and classes that were specific to Java EE were deprecated. With Java 11, these deprecated APIs and modules have been removed from the Java SE platform and the JDK. CORBA's APIs were also deprecated in Java 9 and were eventually removed in Java 11.</p>
<p class="mce-root">With Java SE 6 (core Java), you can develop web services using the following technologies:</p>
<ul>
<li><strong>JAX-WS</strong> (short for <strong>Java API for XML-Based Web Services</strong>)</li>
<li><strong>JAXB</strong> (short for <span><strong>Java Architecture for XML Binding</strong>)</span></li>
<li><strong>JAF</strong> (short for <strong>JavaBeans Activation Framework</strong>) </li>
<li><strong>Common annotations</strong></li>
</ul>
<p>When the code for the preceding tech stack was added to core Java, it was identical to its versions for <strong>Java's Enterprise Edition</strong> (<strong>JEE</strong>). However, over time, the JEE version evolved, leading to a mismatch in the functionality that was offered by the same APIs in Java SE and JEE.</p>
<p>JEP 320 removed the following modules in Java 11, deleting their source code from the OpenJDK repository and runtime JDK image:</p>
<ul>
<li><kbd>java.xml.ws</kbd> (JAX-WS)</li>
<li><kbd>java.xml.bind</kbd> (JAXB)</li>
<li><kbd>java.activation</kbd> (JAF)</li>
<li><kbd>java.xml.ws.annotation</kbd> (common annotations)</li>
<li><kbd>java.corba</kbd> (CORBA)</li>
<li><kbd>java.transaction</kbd> (JTA)</li>
<li><kbd>java.se.ee</kbd> (an aggregator module for the preceding six modules)</li>
<li><kbd>jdk.xml.ws</kbd> (JAX-WS tools)</li>
<li><kbd>jdk.xml.bind</kbd> (JAXB tools)</li>
</ul>
<p>Apart from marking the preceding modules as deprecated in Java 9, JDK didn't resolve them when code that was using these modules was compiled or executed. This forced the developers to use standalone versions of Java EE or CORBA on the classpath.</p>
<p>After their removal, tools such as <kbd>wsgen</kbd> and <kbd>wsimport</kbd> (from <kbd>jdk.xml.ws</kbd>), <kbd>schemagen</kbd> and <kbd>xjc</kbd> (from <kbd>jdk.xml.bind</kbd>), <kbd>idlj</kbd>, <kbd>orbd</kbd>, <kbd>servertool</kbd>, and <kbd>tnamesrv</kbd> (from <kbd>java.corba</kbd>) were no longer available. Developers couldn't enable them using runtime command-line flags, as follows:</p>
<pre>    <strong>--add-modules</strong></pre>
<p>CORBA, an ORB implementation, was included in Java SE in 1998. Over time, support for CORBA has outweighed its benefits. First of all, with better technologies available, hardly anyone is using CORBA now. CORBA evolves outside the <strong>Java Community Process</strong> (<strong>JCP</strong>) and it is becoming increasingly difficult to maintain JDK's CORBA implementation. With JEE now moving to the Eclipse Foundation, it makes no sense to synchronize ORB in JDK with Jakarta EE's ORB. To add to this, JEE 8 designated it as <strong>Proposed Optional</strong>, which essentially means that JEE might drop supporting CORBA in one of its future versions (marking it as deprecated).</p>
<div class="packt_infobox">Enterprises moving from Java 8 to Java 11 are at a higher risk if their applications use JEE or CORBA APIs. However, an alternate API is suggested by Oracle, easing the migration.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A key agreement with Curve25519 and Curve448</h1>
                </header>
            
            <article>
                
<p>With JEP 324, Java SE is making further advances in cryptography that offers security and performance. This feature implements a key agreement using Curve25519 and Curve448. Other cryptography libraries, such as OpenSSL and BoringSSL, already support key exchanges using Curve25519 and Curve448.</p>
<p>You can find more information on Cureve25519 and Curve448 at <a href="https://tools.ietf.org/html/rfc7748">https://tools.ietf.org/html/rfc7748</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unicode 10</h1>
                </header>
            
            <article>
                
<p>JEP 327 upgrades existing platform APIs to support Unicode 10 Standard (<a href="http://www.unicode.org/standard/standard.html">http://www.unicode.org/standard/standard.html</a>), mainly in the following classes:</p>
<ul>
<li><kbd>Character</kbd> and <kbd>String</kbd> (the <kbd>java.lang</kbd> package)</li>
<li><kbd>NumericShaper</kbd> (the <kbd>java.awt.font</kbd> package)</li>
<li><kbd>Bidi</kbd>, <kbd>BreakIterator</kbd>, and <kbd>Normalizer</kbd> (the <kbd>java.text</kbd> package)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ChaCha20 and Poly1305 cryptographic algorithms</h1>
                </header>
            
            <article>
                
<p>Java 11 includes multiple additions and enhancements in cryptographic toolkits and TLS implementations. JEP 329 implements the ChaCha20 and ChaCha20-Poly1305 ciphers. Being a comparatively new stream cipher, ChaCha20 is capable in taking place of the RC4 stream cipher.</p>
<p>At present, the RC4 stream cipher, which has been widely adopted, is not so secure. The industry is moving toward the adoption of the more secure ChaCha20-Poly1305. This has also been widely adopted across TLS implementations as well as in other cryptographic protocols.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching single file source code programs</h1>
                </header>
            
            <article>
                
<p>Imagine being able to execute a Java application without compilation; for instance, if you define the following Java class in <kbd>HelloNoCompilation.java</kbd>:</p>
<pre>class HelloNoCompilation { 
    public static void main(String[] args) { 
        System.out.println("No compilation! Are you kidding me?"); 
    } 
} </pre>
<p>With Java 11, you can execute it using the following command (no compilation takes place):</p>
<pre>    <strong>&gt; java HelloNoCompilation.java</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Note that the preceding command starts the JVM using <kbd>java</kbd>, which is passed the name of a source file with the <kbd>.java</kbd> extension. In this case, the class is compiled in memory before it is executed by the JVM. This applies to multiple classes or interfaces that are defined within the same source file. Here's another example (consider it to be defined within the same <kbd>HelloNoCompilation.java</kbd> <span>source file)</span>:</p>
<pre>class HelloNoCompilation { 
    public static void main(String[] args) { 
        System.out.println("No compilation! Are you kidding me?"); 
        EstablishedOrg org = new EstablishedOrg(); 
        org.invite(); 
        System.out.println(new Startup().name); 
    } 
} 
class Startup { 
    String name = "CoolAndExciting"; 
} 
interface Employs { 
    default void invite() { 
        System.out.println("Want to work with us?"); 
    } 
} 
class EstablishedOrg implements Employs { 
    String name = "OldButStable"; 
} </pre>
<p>On execution, you will see the following command:</p>
<pre>    <strong>&gt; java HelloNoCompilation.java</strong></pre>
<p>The preceding code will output as follows:</p>
<pre>    <strong>No compilation! Are you kidding me?</strong>
    <strong>Want to work with us?</strong>
    <strong>CoolAndExciting</strong>  </pre>
<p>With JEP 330, you can cut down the step of compiling your code and go to the execution of your Java applications <span>straight away</span>. However, this only applies to applications with a single source file. The source file can define multiple classes or interfaces, as shown in the preceding example code.</p>
<p>Launching single file source code programs helps to reduce the ceremony attached to simple code execution. This is the most helpful for students or professionals who are beginning to learn Java. However, when they move to working with multiple source files, they'll need to compile their code before executing them.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>However, if you compile your source class using the <kbd>javac</kbd> command and then try to launch it as a single file source code, it won't execute. For example, compile the <kbd>HelloNoCompilation</kbd> source file, as follows:</p>
<pre>    <strong>&gt; javac HelloNoCompilation.java</strong></pre>
<p>Then, try to execute the following command:</p>
<pre>    <strong>&gt; java HelloNoCompilation.java</strong>  </pre>
<p>You'll receive the following error:</p>
<pre>    <strong>error: class found on application class path: HelloNoCompilation</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TLS 1.3</h1>
                </header>
            
            <article>
                
<p>Here's another addition to the TLS implementation in Java. JEP 332 implements Version 1.3 of the TLS Protocol.</p>
<p>Version 1.3 of TLS supersedes and obsoletes its previous versions, including Version 1.2 (that is, RFC 5246, which can be found at <a href="https://tools.ietf.org/html/rfc5246">https://tools.ietf.org/html/rfc5246</a>). It also obsoletes or changes other TLS features, such as the <strong>OCSP</strong> (short for <strong>Online Certificate Status Protocol</strong>) stapling extensions (that is, RFC 6066, which can be found at <a href="https://tools.ietf.org/html/rfc6066">https://tools.ietf.org/html/rfc6066</a>; and RFC 6961, which can be found at <a href="https://tools.ietf.org/html/rfc6961">https://tools.ietf.org/html/rfc6961</a>), and the session hash and extended master secret extension (that is, RFC 7627; for more information, visit <a href="https://tools.ietf.org/html/rfc7627">https://tools.ietf.org/html/rfc7627</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deprecating the Nashorn JavaScript engine</h1>
                </header>
            
            <article>
                
<p>With JEP 335, Java 11 deprecates the Nashorn JavaScript script engine, its APIs, and its <kbd>jjs</kbd> tool. These will be removed in future Java versions.</p>
<p>The Nashorn JavaScript engine was first included in JDK in its recent versions—JDK 8. The reason for this was to replace the Rhino scripting engine. However, Java is unable to keep up the pace with the evolution of ECMAScript, on which the Nashorn JavaScript engine is based.</p>
<p>The challenge to maintain the Nashorn JavaScript engine outperforms the advantages that it offers, and therefore paving the way for its deprecation.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEP 336 – deprecating the pack200 tools and API</h1>
                </header>
            
            <article>
                
<p>Introduced in Java 5, pack200 was a compression scheme for JAR files. It was used to decrease the disk space and bandwidth demand when Java programs were packaged, transmitted, or delivered. Developers used pack200 and unpack200 to compress and decompress the Java JAR files.</p>
<p>However, these are becoming irrelevant in today's modern storage and transmission improvements. JEP 336 deprecates the pack200 and unpack200 tools, and also the corresponding pack200 API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered various features of Java 11. We saw how a number of changes have been introduced over different versions.</p>
<p>In the next chapter, we will discover the exciting new additions and modifications to the Java language as they are being worked on in <strong>Project Amber</strong> – which is about right-sizing the Java language ceremony.</p>


            </article>

            
        </section>
    </body></html>