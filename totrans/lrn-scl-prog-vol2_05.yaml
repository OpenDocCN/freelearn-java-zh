- en: Object-Oriented Scala Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象Scala基础
- en: '"There is a central quality which is the root criterion of life and spirit
    of a man, a town, a building, or a wilderness. This quality is subjective and
    precise."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “有一种核心品质，是人的生命和精神、城镇、建筑或荒野的根本标准。这种品质是主观且精确的。”
- en: '- The Timeless Way of Building'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 永恒的建筑方式'
- en: Scala is an obvious choice for many programmers because of the goodies it contains.
    It's a language that's functional as well as object-oriented, which means a lot
    to programmers. It gives us a way of building our applications in a modular and
    meaningful fashion. It's important to know that Scala's functional concepts are
    essential, powerful, and at the core of our programs. There is no doubt that algebraic
    data types have provided the essential abstractions and immutable data structures
    that have allowed the code to work in a concurrent environment. But real-world
    applications could need much more than that. Often, the amount of code we write
    makes it essential to have a way of managing it. That's where object-oriented
    abstractions come to the rescue. It's great to learn that we now have classes
    and objects that provide a way to create manageable code. In the next few chapters,
    we'll equip ourselves with these object-oriented concepts in Scala, and they will
    help us later when we'll start to use functional concepts and abstractions more
    and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Scala包含了许多优点，许多程序员会选择Scala。这是一种既具有函数式又具有面向对象特性的语言，这对程序员来说意义重大。它为我们提供了一种以模块化和有意义的方式构建应用程序的方法。重要的是要知道，Scala的函数式概念是基本、强大且位于我们程序核心的。毫无疑问，代数数据类型已经提供了必要的抽象和不可变数据结构，使得代码能够在并发环境中工作。但现实世界的应用可能需要更多。通常，我们编写的代码量使得管理它们变得至关重要。这就是面向对象抽象发挥作用的地方。现在我们有了类和对象，它们提供了一种创建可管理代码的方法。在接下来的几章中，我们将掌握Scala中的这些面向对象概念，它们将帮助我们在开始越来越多地使用函数式概念和抽象时。
- en: 'You''re probably familiar with object-oriented basics if you''re coming from
    Java or any other object-oriented language background. If not, we''ll discuss
    the concepts as we go along. Mainly, when we discuss object-oriented principles,
    we come up with four core principles, namely: *abstraction*, *encapsulation*,
    *inheritance*, and *polymorphism*. They work as their names suggest. For example, *abstraction*
    is basically hiding the concrete or internal processing of a task or process,
    in simpler words, making something abstract. In Scala, we have abstract classes,
    traits, and a few other concepts, which provide abstraction. *Classes* and *objects*
    are a way to provide *encapsulation,* basically encapsulating a meaningful piece
    of code in a unit.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java或其他面向对象语言背景，你可能熟悉面向对象的基础知识。如果不熟悉，我们将随着讨论的进行讨论这些概念。主要的是，当我们讨论面向对象原则时，我们会提出四个核心原则，即：*抽象*、*封装*、*继承*和*多态*。它们的工作方式正如其名。例如，*抽象*基本上是隐藏任务或过程的具体或内部处理，用更简单的话说，就是使某物抽象化。在Scala中，我们有抽象类、特性和一些其他概念，它们提供了抽象。*类*和*对象*是提供*封装*的方式，基本上是将有意义的一段代码封装在一个单元中。
- en: There's a way we can inherit members and their behaviors from parent classes
    and put them into other classes known as child classes. This property is known
    as *inheritance*. Finally, *polymorphism*, as the name suggests, means different
    ways to define and perform one operation. One of the examples of polymorphism
    is method overriding.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从父类继承成员及其行为，并将它们放入称为子类的其他类中。这种特性被称为*继承*。最后，*多态*，正如其名，意味着定义和执行一个操作的不同方式。多态的一个例子是方法重写。
- en: 'This chapter is a basic introduction to classes and objects in Scala. To make
    our agenda clear, we''ll mainly go through three topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是Scala中类和对象的基本介绍。为了使我们的议程清晰，我们将主要在本章中探讨三个主题：
- en: Classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Case classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况类
- en: Classes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: To understand classes in Scala, let's make it clear that classes don't just
    do one thing for us. Classes work as a container for members in our programs,
    and as in any other object-oriented language, we can create instances of our class
    constructs and reuse them. By members we mean the variables and methods defined
    within. Why not take a look at a simple Scala class?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Scala中的类，让我们先明确一点：类不仅仅为我们做一件事情。类在我们的程序中充当成员的容器，就像在任何其他面向对象的语言中一样，我们可以创建我们类构造的实例并重用它们。当我们提到成员时，我们指的是在内部定义的变量和方法。为什么不看看一个简单的Scala类呢？
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Yes, the preceding code is a class that we defined named `Country`*.* It has
    two members named `name` and `capital`*.* Let''s create a new country instance
    and print its values:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，前面的代码是我们定义的一个名为`Country`的类*.* 它有两个成员，分别命名为`name`和`capital`*.* 让我们创建一个新的国家实例并打印其值：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On running the preceding code, we get the following result:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码，我们得到以下结果：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, believe me, it''s going to be hard to resist Scala once I tell you that
    a class in Java with the same capabilities would need a few more lines. Take a
    look at the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请相信我，一旦我告诉你，具有相同功能的Java类可能需要更多几行代码，你将很难抗拒Scala。看看下面的代码：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This still isn''t finished. We''ll now create an instance and print the country
    object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是结束。现在我们将创建一个实例并打印国家对象：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将要输出的内容：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reason why we're differentiating based on the way we define classes is to
    see the conciseness. A lot of unnecessary or boilerplate code has been omitted.
    Accessors for our members such as `name` and `capital` are still there due to
    the `var` keyword we added while defining our class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以根据定义类的方式区分它们，是为了看到简洁性。很多不必要的或样板代码已经被省略。由于我们在定义类时添加了`var`关键字，所以我们的成员如`name`和`capital`的访问器仍然存在。
- en: 'Let''s try to omit the `var` or `val` keyword as part of the class constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试省略类构造函数中的`var`或`val`关键字：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These two, `name` and `capital`, will remain as class constructor arguments.
    Their scope will be limited; it won''t be possible to use these arguments outside
    the class scope. To understand better, think of a class constructor as a method
    with some parameters. While calling the method, we pass a certain number of arguments
    and their scope is limited to the definition of the function. The same happens
    with Scala classes. You can think of some use cases when it comes to using class
    constructor arguments:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个，`name`和`capital`，将作为类构造函数的参数保留。它们的范围将受到限制；在类作用域之外无法使用这些参数。为了更好地理解，可以将类构造函数想象成一个带有一些参数的方法。在调用方法时，我们传递一定数量的参数，它们的范围限制在函数的定义内。Scala类也是这样。你可以考虑一些使用类构造函数参数的用例：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compiler will not let you access `name` and `capital` members.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会让你访问`name`和`capital`成员。
- en: 'When we use the `var` keyword as a modifier of our constructor arguments, we
    get access to these arguments. So, if you instantiate your `Country` object outside
    this class, you''ll get a reference to these two fields and you can access them.
    Adding `var` as a prefix lets you reassign the parameter''s value; that''s not
    a good idea though. The following code snippet does the same:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`var`关键字作为构造函数参数的修饰符时，我们可以访问这些参数。所以，如果你在这个类外部实例化`Country`对象，你将得到这两个字段的引用并可以访问它们。将`var`作为前缀允许你重新分配参数的值；但这不是一个好主意。以下代码片段做了同样的事情：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将要输出的内容：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same happens with the `val` keyword. The only difference is that `val`
    parameters can only be read and not mutated. So in other words, your members become
    immutable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`val`关键字也是同样的情况。唯一的区别是`val`参数只能被读取而不能被修改。换句话说，你的成员变成了不可变的：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding definition lets you access the members named `name` and `capital`
    but it won''t let you change the value of `name` and `capital` once an instance
    is instantiated:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义允许你访问名为`name`和`capital`的成员，但它不会让你在实例化后更改`name`和`capital`的值：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you try to do this, the compiler will come up with an error stating, `reassignment
    to val`. There''s another construct that lets you do this, which means you don''t
    actually put `val` in constructor arguments, but use a `case` class instead. Defining
    a `case` class is as easy as defining any other class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这样做，编译器将抛出一个错误，指出“将值赋给val”。还有一个结构允许你这样做，这意味着你实际上并没有在构造函数参数中放置`val`，而是使用了一个`case`类。定义一个`case`类就像定义任何其他类一样简单：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Writing a `case` class with arguments by default means it takes them as immutable
    parameters; there is no need to explicitly make them a `val`. We''ll learn more
    about case classes in subsequent topics. We can also declare some methods in our
    classes, and those methods are going to be specific to the instance of our classes.
    For example, let''s add a method that gives the population for a given year. To
    make it work, we''ll add a map with the year and population in millions. The following
    is just for illustration purposes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认参数的`case`类意味着它将它们作为不可变参数接收；没有必要显式地将它们声明为`val`。我们将在后续主题中了解更多关于`case`类的信息。我们还可以在我们的类中声明一些方法，这些方法将特定于我们类的实例。例如，让我们添加一个方法，用于获取给定年份的人口。为了使其工作，我们将添加一个包含年份和人口的百万单位的映射。以下内容仅用于说明目的：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding class definition, we have defined a mutable map for `population`
    that stores the population of a country based on the year as a key. Passing a
    year will return the population in millions for that year. Now, every instance
    of the `country` class is going to contain a separate reference to these members.
    You can picture it as a separate `name`*,* `capital`*,* `populationMap`, and `getPopulation`
    method for each instance that we create. Then, values that we give to these members
    are also separate from each other. It''s possible, though, that we have two separate
    references pointing to the same value in cases where we have different values
    for our instance members pointing to different value objects. Let''s take a look
    at the following figure to make it clearer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们为`population`定义了一个可变的映射，它根据年份作为键存储一个国家的人口。传递一个年份将返回该年份的人口（以百万为单位）。现在，`country`类的每个实例都将包含对这些成员的单独引用。你可以想象，对于每个我们创建的实例，都有一个单独的`name`、`capital`、`populationMap`和`getPopulation`方法。然后，我们赋予这些成员的值也是相互独立的。然而，在实例成员指向不同的值对象时，我们可能有两个不同的引用指向相同的值。让我们看一下以下图示，以使其更清晰：
- en: '![](img/00026.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00026.jpeg)'
- en: Class instances
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类实例
- en: 'It''s important to know that when we compile our classes, they get converted
    to their Java equivalent code. A class with `var` constructor parameters when
    converted to the Java equivalent looks as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，当我们编译我们的类时，它们会被转换为它们的Java等效代码。当转换为Java等效代码时，具有`var`构造参数的类看起来如下：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding methods, `name()` and `capital()`*,* work as *getters* and return
    the values for these two fields. The other two are methods named `name_$eq` and
    `capital_$eq`*.* We can use these methods to assign values:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法，`name()`和`capital()`，作为*获取器*返回这两个字段的值。其他两个是名为`name_$eq`和`capital_$eq`的方法。我们可以使用这些方法来赋值：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出：
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It shows that we don't explicitly create these mutator methods, but the Scala
    compiler does this job for us. Note, `name_$eq` represents `name_=` and nothing
    more. Finally, the last method represented in the compiled form is actually a
    constructor for our `Country`class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们没有显式创建这些修改器方法，但Scala编译器为我们完成了这项工作。注意，`name_$eq`代表`name_=`，没有其他含义。最后，编译形式中最后表示的方法实际上是`Country`类的构造函数。
- en: 'Class constructors where we use `val` don''t get access to mutator methods.
    It means that the compiled form of the class does not contain mutator methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`val`的类构造函数无法访问修改器方法。这意味着类的编译形式不包含修改器方法：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code is the compiled form of our `Country` class with `val` arguments.
    Here, we have access to only accessor methods and not mutators.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们`Country`类使用`val`参数的编译形式。在这里，我们只能访问访问器方法，而不能访问修改器方法。
- en: 'By default, all the members that we define work as public members. This means
    it''s possible to access them outside the class. We can make them private just
    by adding a `private` modifier:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们定义的所有成员都作为公共成员工作。这意味着可以在类外部访问它们。我们可以通过添加`private`修饰符来使它们私有：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To illustrate this, let''s make our `getPopulation(year: String)` method private.
    After that, we won''t be able to perform this operation outside this class, even
    with an instance of the `Country` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '为了说明这一点，让我们将我们的`getPopulation(year: String)`方法设为私有。之后，即使有`Country`类的实例，我们也将无法在类外部执行此操作：'
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Scala compiler won''t let you perform this operation. Another thing to
    note about classes in Scala is that you have to define `toString`, `equals`, and
    `hashCode` implementation for your classes. These methods are essential if you
    want Scala to print your class instance in some particular format or perform equality
    operations. To remove this boilerplate, it''s recommended to use case classes.
    Without defining these methods, try running the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 编译器不会允许你执行此操作。关于 Scala 中的类，还有一点需要注意，那就是你必须为你的类定义 `toString`、`equals` 和
    `hashCode` 的实现。如果你想让 Scala 以某种特定格式打印你的类实例或执行相等操作，这些方法是必不可少的。为了消除这种冗余，建议使用 case
    类。如果不定义这些方法，尝试运行以下代码：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Scala will print the runtime instance as it is, that is, `Country@2d209079`*.*
    To make this meaningful, we can override the `toString` method and give its definition:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 将直接打印运行时实例，即 `Country@2d209079`*.* 为了使这个输出有意义，我们可以重写 `toString` 方法并给出其定义：
- en: '[PRE22]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, if you try printing an instance of `Country`*,* it will print in the preceding
    format:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试打印 `Country`*.* 的一个实例，它将以前面的格式打印：
- en: '[PRE23]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为结果：
- en: '[PRE24]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Sometimes we want to create classes that are abstract, contain nothing but the
    class name, and indicate a type that some subsequent classes do want to inherit.
    We declare these as abstract classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要创建只包含类名、表示某些后续类想要继承的类型、且为抽象的类。我们将这些声明为抽象类。
- en: Abstract classes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: We can define abstract classes using the `abstract`keyword*:*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `abstract` 关键字来定义抽象类：*
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, what we wanted was two subclasses that can also be treated as instances
    of a superclass, in our case, `Person`*.* For now, we have not shown any behavior
    in our abstract class. But, there are times when we want to imply some behaviors
    in our abstract classes that subsequent subclasses can inherit and define for
    themselves:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要的两个子类也可以被当作超类（在我们的例子中是 `Person`*.*）的实例。目前，我们在抽象类中还没有展示任何行为。但是，有时我们想在抽象类中暗示一些行为，以便后续的子类可以继承并自行定义：
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our intention to use abstract classes is clearer now. We may want a set of classes
    that inherit methods or values from a particular class. When we extend classes,
    we can use the `override` modifier in our definition. This kind of behavior is
    likely to present itself in one more concept we have in Scala, that is, a trait*.*
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对使用抽象类的意图更清晰了。我们可能想要一组继承自特定类的类。当我们扩展类时，我们可以在定义中使用 `override` 修饰符。这种行为很可能会在
    Scala 的另一个概念中体现出来，那就是 trait*.*
- en: Abstract classes and traits
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类和 traits
- en: 'It''s possible for you to declare things like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明如下内容：
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we used a trait*.* We''ll learn more about traits in the next chapter.
    For now, let''s see how they are different to abstract classes. We may be able
    to see that we''ve provided constructor parameters in abstract classes; this is
    not possible with traits:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 trait*.* 我们将在下一章中了解更多关于 traits 的内容。现在，让我们看看它们与抽象类有何不同。我们可能会发现，我们在抽象类中提供了构造函数参数；这是
    traits 所不可能的：
- en: '[PRE28]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We cannot give constructor parameters for traits. However, we can, give a definition
    of methods in both abstract classes and traits. This is not the only way we may
    want to use classes. It's also possible that you don't want any other class to
    inherit from your classes. In those scenarios, we may declare the class using
    the `final` keyword.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能为 traits 提供构造函数参数。然而，我们可以在抽象类和 traits 中定义方法。这不是我们想要使用类的唯一方式。也许你不想让任何其他类继承你的类。在这些情况下，我们可能需要使用
    `final` 关键字来声明类。
- en: The final classes
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终类
- en: 'If you''re coming from a Java background, you may have this idea of a `String`
    class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 Java 背景，你可能对 `String` 类有这个想法：
- en: '[PRE29]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `final` keyword tells you that you can''t inherit from the `String`class*.* In
    the same way, we can also use this `final` keyword to make classes with behaviors
    that can''t be modified or inherited by any other classes. You''ve got the idea.
    If you make our `Person` class final then you won''t be able to inherit it. It''s
    weird though, in Scala you can declare a class as final as well as `abstract`*.*
    Yes, it''s possible in the following way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`final` 关键字告诉你你不能从 `String` 类继承*.* 同样地，我们也可以使用这个 `final` 关键字来创建具有无法被任何其他类修改或继承的行为的类。你已经明白了这个概念。如果你将我们的
    `Person` 类声明为 `final`，那么你将无法继承它。但在 Scala 中，你还可以将类声明为 `final` 以及 `abstract`*.*
    是的，以下是这样做的：'
- en: '[PRE30]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Thankfully, the compiler doesn't let us inherit from abstract final classes.
    It would be great if you could find use cases though. For instant gratification,
    you may want to search for phantom types in Scala and think of use cases for our,
    can't instantiate or inherit abstract classes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编译器不允许我们从抽象最终类继承。虽然如此，如果你能找到用例那就太好了。为了即时满足，你可能想搜索Scala中的幻影类型，并考虑我们无法实例化或继承抽象类的情况。
- en: Also, if you're coming from an object-oriented programming background, or have
    an idea about `static` members in Java, you may be thinking, how do we achieve
    that in Scala? The basic usage of a static class or static member is that, for
    those that have only one instance, that particular member will be the same for
    all instances of a particular class. If you change the value of a static member,
    it'll be changed for all instances. You'll be getting more of an idea of what
    we're talking about in the next topic that we're going to discuss.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你来自面向对象编程的背景，或者对Java中的`static`成员有所了解，你可能正在想，在Scala中我们如何实现这一点？静态类或静态成员的基本用法是，对于只有一个实例的情况，特定成员对于该类的所有实例都是相同的。如果你改变静态成员的值，它将改变所有实例的值。你将在我们接下来要讨论的下一个主题中了解更多关于我们正在讨论的内容。
- en: Objects as singletons
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象作为单例
- en: There are no static members or classes in Scala. Once you feel the need to create
    a static member, for example a static method or a class that is going to have
    only one instance, you should create an object. Yes, up until now, almost all
    the time we have been creating an object that extends the `App` trait so that
    we don't have to define the `main` method. This is the entry point to our application.
    So, it's also obvious that when we mention `object`*,* we don't mean an instance
    of any class; rather, an `object` in Scala has a different meaning.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中没有静态成员或类。一旦你感觉到需要创建一个静态成员，例如一个静态方法或只将有一个实例的类，你应该创建一个对象。是的，到目前为止，我们几乎总是创建一个扩展`App`特质的对象，这样我们就不必定义`main`方法。这是我们的应用程序的入口点。所以，当提到`object`*时，我们并不是指任何类的实例；相反，Scala中的`object`有不同含义。
- en: An object*,* just like classes, is a container for functions and values. The
    reason why we may want to declare an object is so we can define utility methods
    for any particular type, or sometimes define JSON formatters and similar use cases.
    Let's take another look at how we can define an object*:*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象*，*就像类一样，是函数和值的容器。我们可能想要声明一个对象的原因是，我们可以为任何特定类型定义实用方法，或者有时定义JSON格式化器等类似用例。让我们再看看我们如何定义一个对象*：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Looks like we just created an object. Nothing fancy, just an `object` keyword along
    with the name of the object. We know that objects are singletons, hence it does
    not make any sense to pass arguments in the constructor and therefore, Scala doesn''t
    allow you to do so. That''s it. Why not use your `CountryUtil` object to define
    some utility methods such as a method that takes a sequence of populations and
    returns the average of them? Let''s try that in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们刚刚创建了一个对象。没有什么花哨的，只是一个`object`关键字和对象的名字。我们知道对象是单例的，因此，在构造函数中传递参数没有任何意义，因此Scala不允许这样做。就是这样。为什么不使用你的`CountryUtil`对象来定义一些实用方法，比如一个接受人口序列并返回其平均值的方法？让我们在下面的代码中尝试一下：
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的输出：
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And here we are, with the average population of France for the years we wanted.
    We achieved this by passing the map to our utility function named `populationAverage`
    that takes a sequence of population values in millions. The idea here was to present
    a container that can contain utility methods for a class, and that's why we have
    objects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经得到了我们想要的年份的法国平均人口。我们通过将映射传递给名为`populationAverage`的实用函数，该函数接受以百万为单位的连续人口值，实现了这一点。这里的想法是提供一个可以包含类实用方法的容器，这就是为什么我们有对象。
- en: 'In case you''re wondering, if it''s possible to extend from an object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在想，是否可以从对象扩展：
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: No, we cannot. The first reason is that it's unintended. Secondly, the Scala
    compiler creates a compiled Java version of our objects, which is a `final` class.
    What happens when we create an *object* and it gets compiled? Scala creates a
    few class files based on the modifiers you choose. In our case, if you compile
    the `CountryUtil` object, the compiler creates `CountryUtil.class` and `CountryUtil$.class`*,*
    and these are final by nature. Let's take a look at these.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们不能。第一个原因是这不是预期的。其次，Scala 编译器为我们创建了一个对象的编译后的 Java 版本，这是一个 `final` 类。当我们创建一个
    *对象* 并将其编译时会发生什么？Scala 会根据你选择的修饰符创建几个类文件。在我们的例子中，如果你编译 `CountryUtil` 对象，编译器会创建
    `CountryUtil.class` 和 `CountryUtil$.class`*.*，并且这些文件天生就是最终的。让我们看看这些文件。
- en: 'The following is an implementation of the `CountryUtil.class` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是 `CountryUtil.class` 类的实现：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is an implementation of the `CountryUtil$.class` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是 `CountryUtil$.class` 类的实现：
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Yes, this is quite some Java code. You may not be very interested in the details
    right now, but two things to look out for are the keywords `static` and `final`*.*
    First, these two classes are `final`, as we discussed, and the utility method
    is `static`. Thus, you may get an idea of what the Scala compiler is cooking in
    the background. Great. Also, this does not stop you from extending a class or
    trait from an object. Hence, writing something like the following is possible:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一些 Java 代码。你可能现在对细节不太感兴趣，但有两点需要注意：关键字 `static` 和 `final`*.* 首先，正如我们之前讨论的，这两个类是
    `final` 的，实用方法是 `static` 的。因此，你可能对 Scala 编译器在后台做了什么有一个大概的了解。太好了。此外，这并不会阻止你从一个对象或特质扩展一个类。因此，编写如下内容是可能的：
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Well, that said, let''s discuss more use cases of objects in Scala. We all
    know that we can define utility methods for a particular class in Scala objects.
    Using them is also easy, plus these utility methods can be used from anywhere.
    All you need to do is to add an `import` statement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，既然这样，我们就来讨论一下 Scala 中对象的更多用例。我们都知道，在 Scala 对象中，我们可以为特定类定义实用方法。使用它们也很简单，而且这些实用方法可以从任何地方使用。你只需要添加一个
    `import` 语句：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出是：
- en: '[PRE39]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We defined a `DateUtil` object with a utility `dayOfWeek(date: String)`function. This
    tells us the day of the week when we pass a date to it in a certain format. We
    also created an app which imports this `DateUtilobject` and from that, we get
    access to all functions inside that object. With this, we were able to directly
    make a call to our function and get the result.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '我们定义了一个 `DateUtil` 对象，并包含一个名为 `dayOfWeek(date: String)` 的实用函数。这告诉我们，当我们以特定格式将日期传递给它时，它是星期几。我们还创建了一个应用程序，它导入了这个
    `DateUtil` 对象，并从那里，我们可以访问该对象内部的所有函数。有了这个，我们能够直接调用我们的函数并获取结果。'
- en: This is a fair pattern where we define a class and then create some functions
    that are not instance-specific but can be used from instances, such as the example
    we had for the `Country` class and its utility object named `CountryUtil`*.* The
    language creators knew it well, and introduced the concept of what we call companion
    objects. That's what we're going to learn about next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的模式，我们定义一个类，然后创建一些不是实例特定的函数，但可以从实例中使用，例如我们之前为 `Country` 类及其名为 `CountryUtil`*.*
    的实用对象提供的例子。语言创造者对此了如指掌，并引入了我们所称的伴生对象的概念。这就是我们接下来要学习的内容。
- en: Companion objects
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象
- en: 'Companion objects are not very different to what we have already seen when
    we discussed objects. One specific difference is that we name those the same as
    our class names. It means that instead of defining `CountryUtil`*,* we can give
    this object the same name as our `Country` class and call it our companion object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 伴生对象与我们之前讨论的对象并没有太大的不同。一个具体的区别是，我们给它们的命名与我们的类名相同。这意味着我们不需要定义 `CountryUtil`*.*，我们可以给这个对象与我们的
    `Country` 类相同的名字，并称它为我们的伴生对象：
- en: '[PRE40]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code does what we had said earlier. We named our object the same
    as our `Country`class*.* This is how we define companion objects. This structures
    your code in a nice manner as well, as it provides you with the ability to make
    your types do something. It's handy to know that, to make your objects a *companion*
    you must define them in the same source file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码做了我们之前所说的。我们给我们的对象取的名字与我们的 `Country` 类相同。这就是我们定义伴生对象的方式。这样，你的代码结构也会很清晰，因为它为你提供了让你的类型做些事情的能力。知道这一点很有用，为了使你的对象成为 *伴生*
    对象，你必须将它们定义在同一个源文件中。
- en: If, by chance, you find yourself trying that in the Scala REPL it should be
    done in paste mode (`:paste`). Let's see what we mean by that. So, open the Scala
    REPL and try creating a class and its companion object. The REPL will show a warning: *previously
    defined class is not a companion to object. **Companions must be defined together;
    you may wish to use :paste mode for this.*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Scala REPL中尝试这样做，应该使用粘贴模式（`:paste`）。让我们看看我们是什么意思。所以，打开Scala REPL并尝试创建一个类及其伴随对象。REPL将显示一个警告：*之前定义的类不是对象的伴随。伴随对象必须一起定义；你可能希望使用`:paste`模式来做这件事。*
- en: So we do as suggested. We give the `:paste` command in the REPL, which will
    enable paste mode, and then write our class with companion mode. Then everything
    seems good.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们按照建议去做。在REPL中给出`:paste`命令，这将启用粘贴模式，然后以伴随模式编写我们的类。然后一切看起来都很好。
- en: 'These are useful constructs that we''ve used in various places already. When
    we use `case` *classes* or typeclass (we''ll learn about typeclasses in [Chapter
    10](part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84), *Advanced Functional
    Programming*) implementation, we''ll be searching for companion objects for them.
    In fact, whenever we see our class has a particular thing to do, we have this
    nice way of building its companion object with the `apply` method. Take a look
    at the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们已经在各个地方使用过的有用构造。当我们使用`case`类或类型类（我们将在第10章[part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84]，高级函数式编程）实现时，我们将寻找它们的伴随对象。实际上，每当我们看到我们的类有特定的事情要做时，我们就有一种很好的方式来使用`apply`方法构建它的伴随对象。看看以下例子：
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is the result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This example is for illustration purposes. There were different ways we could
    have achieved what we did here, but to understand *companion objects* with `apply`
    methods is simpler this way. So, what''s different in the preceding example? Is
    it the way we used our `DateApp` application? Yes, when we define the `apply`
    method in the companion object the Scala compiler lets us use it without an explicit
    call to itself. That''s what we did here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是为了说明目的。我们本来有其他不同的方法可以达到这里所做的东西，但为了理解带有`apply`方法的**伴随对象**，这种方式更简单。那么，前一个例子中有什么不同呢？是我们使用`DateApp`应用程序的方式吗？是的，当我们定义伴随对象中的`apply`方法时，Scala编译器允许我们无需显式调用它就能使用它。这正是我们在这里所做的事情：
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We defined a class named `Date`*,* and along with that we created its companion
    with the `apply` method. It gives us the advantage of manipulating the instance
    into giving us something back. In our case, we retrieved some more information
    to make the instances of `Date` more meaningful, and instantiated `Date` with
    more information. Users of `Date` will get more information than we give. This
    seems interesting. However, the actual implementation needs to take care of exceptional
    scenarios as well. For example, what if, while parsing the date, we encounter
    an exception? We won't go into detail right now, as our motto was to understand
    this pattern and find uses for it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Date`的类，并随之创建了一个带有`apply`方法的伴随对象。这给了我们操作实例并从中获取一些东西的优势。在我们的例子中，我们检索了一些更多信息，使`Date`的实例更有意义，并用更多信息实例化`Date`。`Date`的使用者将得到比我们给出的更多信息。这似乎很有趣。然而，实际的实现还需要注意异常情况。例如，如果在解析日期时遇到异常，会怎么样？我们现在不会深入细节，因为我们的座右铭是理解这个模式并找到它的用途。
- en: 'Think of simpler scenarios where we want to omit the unnecessary boilerplate
    code that we have to write when we create a simple class, such as this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 想想更简单的情况，我们想要省略在创建简单类时必须编写的冗余代码，比如这个：
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we have our simple `Country` class where, thanks to Scala, we don't have
    to define accessors and mutators for our class. However, this is not so great.
    We still have to define methods such as `toString`*,* `equals`, or `hashCode`*.*
    What if Scala could does it for you, along with the removal of extra keywords
    that we have to write such as `new`*,* `val`, and so on?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的简单`Country`类，由于Scala的存在，我们不需要为我们的类定义访问器和修改器。然而，这并不那么好。我们仍然需要定义像`toString`、`equals`或`hashCode`这样的方法。如果Scala能为我们做这些，同时移除我们必须写的额外关键字，如`new`、`val`等等，会怎么样呢？
- en: And yes, the entire point of mentioning all these is to affirm that we can do
    a lot in Scala using case classes, which we are going to discuss in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，提到所有这些的整个目的就是为了确认，我们可以在Scala中使用案例类做很多事情，我们将在下一节中讨论这一点。
- en: Case classes
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例类
- en: 'What are case classes, why do we have them, and how do we use them? These are
    a few questions you may want an answer to. So, in simpler words, a case class
    can omit the amount of code we may have to write to achieve this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 案例类是什么，为什么我们有它们，以及我们如何使用它们？这些问题你可能想要得到答案。所以，用更简单的语言来说，案例类可以省略我们可能需要编写的代码量以实现这一点：
- en: '[PRE45]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Instead of declaring `Country` as we do in the preceding code, we would prefer
    to do the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面代码中声明的`Country`不同，我们更愿意这样做：
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And our case class `Country` definition takes care of the rest. We have accessor
    methods for our `name` and `capital` members. We have our `toString` and `equals`
    methods defined by the Scala compiler, or let''s say, auto-generated for us:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的案例类`Country`定义处理了其余部分。我们有`name`和`capital`成员的访问器方法。我们有Scala编译器定义的`toString`和`equals`方法，或者说，为我们自动生成的方法：
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是输出：
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is an instance of the `Country$.class` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`Country$.class`类的实例：
- en: '[PRE49]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is an instance of the `Country.class` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`Country.class`类的实例：
- en: '[PRE50]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A lot of interesting things are going on in the background. The Scala compiler
    creates and defines all the necessary methods for our case class and making our
    life easy. All these conciseness is because of the compiler''s ability to remove
    all the boilerplate that we may have to write. A few important methods that the
    compiler defines for us are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后正在进行许多有趣的事情。Scala 编译器为我们的案例类创建并定义了所有必要的方法，使我们的生活变得简单。所有这些简洁性都是因为编译器能够删除我们可能需要编写的所有样板代码。编译器为我们定义的一些重要方法包括：
- en: '`apply`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`'
- en: '`unapply`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unapply`'
- en: '`copy`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`'
- en: '`canEqual`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canEqual`'
- en: '`hashCode`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode`'
- en: '`equals`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals`'
- en: '`toString`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString`'
- en: 'Along with these, the compiler also creates the constructor along with immutable
    fields, as well as accessors for those fields and a few utility methods such as
    `productArity`, `productPrefix`, and `productElement`*.* It''s worth noting that
    a few methods such as the `apply` and `unapply` methods are declared `static`
    in compiled form. It means that these can be called in the form of `Country.apply(...)`
    or `Country.unapply(...)`*,* but others can be called upon instances of the case
    class. It won''t be possible to call `Country.copy(...)`, as the compiler will
    not allow us to perform this operation. Speaking of all these, let''s try them
    for our example `Country`case class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，编译器还创建了构造函数以及不可变字段，以及这些字段的访问器，还有一些实用方法，如`productArity`、`productPrefix`和`productElement`*.*
    值得注意的是，一些方法，如`apply`和`unapply`方法，在编译后的形式中被声明为`static`。这意味着它们可以以`Country.apply(...)`或`Country.unapply(...)`*.*的形式调用，但其他方法可以在案例类的实例上调用。将无法调用`Country.copy(...)`，因为编译器不允许我们执行此操作。说到所有这些，让我们尝试我们的示例`Country`案例类：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is the result:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We saw all the methods applied in the preceding code. It's worth noting that
    these methods are useful and provide more information about the class instance
    along with the basic behavior. That was our intention of creating a companion
    object. Remember, we created our `Date` class with a companion object, whose instance
    happened to be more meaningful than the information provided at declaration time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了前面代码中应用的所有方法。值得注意的是，这些方法是有用的，并且提供了关于类实例的基本行为以及更多信息的更多信息。这就是我们创建伴随对象的目的。记住，我们创建了一个带有伴随对象的`Date`类，其实例在声明时提供的信息更为有意义。
- en: 'There are more than one reason to prefer using case classes over usual classes
    in Scala. It''s obvious that case classes are concise and yet give us more than
    we may get by writing our own. Due to that reason, we have more information about
    these case classes and their members. For example, the unapply method gives us
    information that you may need when inspecting an instance. We can use these in
    pattern matching and it''s also recommended to do so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，有多个原因使我们更愿意使用案例类而不是普通类。很明显，案例类既简洁又给我们提供了我们可能通过编写自己的代码所无法得到的东西。正因为如此，我们对这些案例类及其成员有了更多的了解。例如，`unapply`方法提供了在检查实例时你可能需要的信息。我们可以在模式匹配中使用这些方法，并且也建议这样做：
- en: '[PRE53]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This may look simple, but it''s a powerful construct and used heavily. No wonder
    you also find yourself matching case class instances more often. It''s simple
    to do so and, according to our snippet, it''ll print the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很简单，但它是一个强大的结构，并且被广泛使用。难怪你也发现自己更频繁地匹配案例类实例。这样做很简单，根据我们的代码片段，它将打印以下内容：
- en: '[PRE54]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It does this as expected due to the `unapply` method; pattern matching worked
    on our case class instance. It is also worth knowing that you can''t declare a
    case class along with a class with the same name. Scala won''t allow you to declare
    a class and case class with the same name in the same scope. By same scope, what
    we mean is that if you declare a case class, let''s say country with the same
    name as a Country class in the same compilation unit, it''s fair enough, because
    those belong to different scopes. To make the statement clear, look at an example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`unapply`方法按预期工作；模式匹配在我们的案例类实例上起作用。还值得知道的是，你不能声明一个与具有相同名称的类一起的案例类。Scala不会允许你在同一作用域内声明具有相同名称的类和案例类。当我们说同一作用域时，我们的意思是，如果你声明了一个案例类，比如说名为country的案例类，与同一编译单元中的Country类同名，这是完全可以的，因为它们属于不同的作用域。为了使这个声明更清晰，请看一个例子：
- en: '[PRE55]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code is totally fine to declare, but if we try to put our class
    inside `CountryUtil` or take our case class outside of `CountryUtil`, the compiler
    will not let us do this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码声明是完全可以的，但如果我们尝试将我们的类放入`CountryUtil`或把我们的案例类放在`CountryUtil`之外，编译器将不允许我们这样做：
- en: '[PRE56]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The Scala compiler will not let you do so, saying the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编译器不会允许你这样做，它会显示以下信息：
- en: '[PRE57]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Well, you may not want to do such a thing anyway. In case you''re wondering
    whether it''s possible to extend from a case class or not, it''s possible to do
    the following with case classes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你可能根本不想做这样的事情。如果你想知道是否可以从案例类扩展，使用案例类可以做到以下事情：
- en: '[PRE58]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We'll learn more about inheritance in the next chapter. For now, we've seen
    enough to be prepared for what comes next. It's time to summarize what we've learned
    in this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中学习更多关于继承的内容。到目前为止，我们已经看到了足够的，为接下来做好准备。现在是时候总结本章我们学到的内容了。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was interesting because we learned the details of Scala classes
    and object implementation. We started with what classes means in Scala, how we
    can declare them, and use them. Then we talked about objects as singleton instances
    in Scala. We then talked about interesting companion objects, which led us to
    case classes. We learned that case classes not only give us the conciseness we
    want but can also be very useful in scenarios where we may want to do pattern
    matching over instances. Finally, we discussed all the methods and goodies that
    case classes provide.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章很有趣，因为我们学习了Scala类和对象实现的细节。我们从Scala中类的含义开始，讨论了如何声明它们以及如何使用它们。然后我们讨论了Scala中对象作为单例实例的概念。接着我们讨论了有趣的伴生对象，这引出了案例类。我们了解到案例类不仅给我们带来了我们想要的简洁性，而且在可能需要进行实例模式匹配的场景中也非常有用。最后，我们讨论了案例类提供的所有方法和优点。
- en: In the next chapter, we'll take our knowledge of object-oriented Scala to the
    next level and talk more about traits, inheritance, and a lot more.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把面向对象的Scala知识提升到新的水平，并更多地讨论特质、继承以及更多内容。
