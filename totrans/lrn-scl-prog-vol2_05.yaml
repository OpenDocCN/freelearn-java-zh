- en: Object-Oriented Scala Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"There is a central quality which is the root criterion of life and spirit
    of a man, a town, a building, or a wilderness. This quality is subjective and
    precise."'
  prefs: []
  type: TYPE_NORMAL
- en: '- The Timeless Way of Building'
  prefs: []
  type: TYPE_NORMAL
- en: Scala is an obvious choice for many programmers because of the goodies it contains.
    It's a language that's functional as well as object-oriented, which means a lot
    to programmers. It gives us a way of building our applications in a modular and
    meaningful fashion. It's important to know that Scala's functional concepts are
    essential, powerful, and at the core of our programs. There is no doubt that algebraic
    data types have provided the essential abstractions and immutable data structures
    that have allowed the code to work in a concurrent environment. But real-world
    applications could need much more than that. Often, the amount of code we write
    makes it essential to have a way of managing it. That's where object-oriented
    abstractions come to the rescue. It's great to learn that we now have classes
    and objects that provide a way to create manageable code. In the next few chapters,
    we'll equip ourselves with these object-oriented concepts in Scala, and they will
    help us later when we'll start to use functional concepts and abstractions more
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re probably familiar with object-oriented basics if you''re coming from
    Java or any other object-oriented language background. If not, we''ll discuss
    the concepts as we go along. Mainly, when we discuss object-oriented principles,
    we come up with four core principles, namely: *abstraction*, *encapsulation*,
    *inheritance*, and *polymorphism*. They work as their names suggest. For example, *abstraction*
    is basically hiding the concrete or internal processing of a task or process,
    in simpler words, making something abstract. In Scala, we have abstract classes,
    traits, and a few other concepts, which provide abstraction. *Classes* and *objects*
    are a way to provide *encapsulation,* basically encapsulating a meaningful piece
    of code in a unit.'
  prefs: []
  type: TYPE_NORMAL
- en: There's a way we can inherit members and their behaviors from parent classes
    and put them into other classes known as child classes. This property is known
    as *inheritance*. Finally, *polymorphism*, as the name suggests, means different
    ways to define and perform one operation. One of the examples of polymorphism
    is method overriding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is a basic introduction to classes and objects in Scala. To make
    our agenda clear, we''ll mainly go through three topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand classes in Scala, let's make it clear that classes don't just
    do one thing for us. Classes work as a container for members in our programs,
    and as in any other object-oriented language, we can create instances of our class
    constructs and reuse them. By members we mean the variables and methods defined
    within. Why not take a look at a simple Scala class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, the preceding code is a class that we defined named `Country`*.* It has
    two members named `name` and `capital`*.* Let''s create a new country instance
    and print its values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding code, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, believe me, it''s going to be hard to resist Scala once I tell you that
    a class in Java with the same capabilities would need a few more lines. Take a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This still isn''t finished. We''ll now create an instance and print the country
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The reason why we're differentiating based on the way we define classes is to
    see the conciseness. A lot of unnecessary or boilerplate code has been omitted.
    Accessors for our members such as `name` and `capital` are still there due to
    the `var` keyword we added while defining our class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to omit the `var` or `val` keyword as part of the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These two, `name` and `capital`, will remain as class constructor arguments.
    Their scope will be limited; it won''t be possible to use these arguments outside
    the class scope. To understand better, think of a class constructor as a method
    with some parameters. While calling the method, we pass a certain number of arguments
    and their scope is limited to the definition of the function. The same happens
    with Scala classes. You can think of some use cases when it comes to using class
    constructor arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will not let you access `name` and `capital` members.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `var` keyword as a modifier of our constructor arguments, we
    get access to these arguments. So, if you instantiate your `Country` object outside
    this class, you''ll get a reference to these two fields and you can access them.
    Adding `var` as a prefix lets you reassign the parameter''s value; that''s not
    a good idea though. The following code snippet does the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The same happens with the `val` keyword. The only difference is that `val`
    parameters can only be read and not mutated. So in other words, your members become
    immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding definition lets you access the members named `name` and `capital`
    but it won''t let you change the value of `name` and `capital` once an instance
    is instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to do this, the compiler will come up with an error stating, `reassignment
    to val`. There''s another construct that lets you do this, which means you don''t
    actually put `val` in constructor arguments, but use a `case` class instead. Defining
    a `case` class is as easy as defining any other class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing a `case` class with arguments by default means it takes them as immutable
    parameters; there is no need to explicitly make them a `val`. We''ll learn more
    about case classes in subsequent topics. We can also declare some methods in our
    classes, and those methods are going to be specific to the instance of our classes.
    For example, let''s add a method that gives the population for a given year. To
    make it work, we''ll add a map with the year and population in millions. The following
    is just for illustration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding class definition, we have defined a mutable map for `population`
    that stores the population of a country based on the year as a key. Passing a
    year will return the population in millions for that year. Now, every instance
    of the `country` class is going to contain a separate reference to these members.
    You can picture it as a separate `name`*,* `capital`*,* `populationMap`, and `getPopulation`
    method for each instance that we create. Then, values that we give to these members
    are also separate from each other. It''s possible, though, that we have two separate
    references pointing to the same value in cases where we have different values
    for our instance members pointing to different value objects. Let''s take a look
    at the following figure to make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Class instances
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to know that when we compile our classes, they get converted
    to their Java equivalent code. A class with `var` constructor parameters when
    converted to the Java equivalent looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding methods, `name()` and `capital()`*,* work as *getters* and return
    the values for these two fields. The other two are methods named `name_$eq` and
    `capital_$eq`*.* We can use these methods to assign values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It shows that we don't explicitly create these mutator methods, but the Scala
    compiler does this job for us. Note, `name_$eq` represents `name_=` and nothing
    more. Finally, the last method represented in the compiled form is actually a
    constructor for our `Country`class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class constructors where we use `val` don''t get access to mutator methods.
    It means that the compiled form of the class does not contain mutator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the compiled form of our `Country` class with `val` arguments.
    Here, we have access to only accessor methods and not mutators.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all the members that we define work as public members. This means
    it''s possible to access them outside the class. We can make them private just
    by adding a `private` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate this, let''s make our `getPopulation(year: String)` method private.
    After that, we won''t be able to perform this operation outside this class, even
    with an instance of the `Country` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala compiler won''t let you perform this operation. Another thing to
    note about classes in Scala is that you have to define `toString`, `equals`, and
    `hashCode` implementation for your classes. These methods are essential if you
    want Scala to print your class instance in some particular format or perform equality
    operations. To remove this boilerplate, it''s recommended to use case classes.
    Without defining these methods, try running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala will print the runtime instance as it is, that is, `Country@2d209079`*.*
    To make this meaningful, we can override the `toString` method and give its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try printing an instance of `Country`*,* it will print in the preceding
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes we want to create classes that are abstract, contain nothing but the
    class name, and indicate a type that some subsequent classes do want to inherit.
    We declare these as abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define abstract classes using the `abstract`keyword*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, what we wanted was two subclasses that can also be treated as instances
    of a superclass, in our case, `Person`*.* For now, we have not shown any behavior
    in our abstract class. But, there are times when we want to imply some behaviors
    in our abstract classes that subsequent subclasses can inherit and define for
    themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our intention to use abstract classes is clearer now. We may want a set of classes
    that inherit methods or values from a particular class. When we extend classes,
    we can use the `override` modifier in our definition. This kind of behavior is
    likely to present itself in one more concept we have in Scala, that is, a trait*.*
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes and traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s possible for you to declare things like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used a trait*.* We''ll learn more about traits in the next chapter.
    For now, let''s see how they are different to abstract classes. We may be able
    to see that we''ve provided constructor parameters in abstract classes; this is
    not possible with traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We cannot give constructor parameters for traits. However, we can, give a definition
    of methods in both abstract classes and traits. This is not the only way we may
    want to use classes. It's also possible that you don't want any other class to
    inherit from your classes. In those scenarios, we may declare the class using
    the `final` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The final classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re coming from a Java background, you may have this idea of a `String`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `final` keyword tells you that you can''t inherit from the `String`class*.* In
    the same way, we can also use this `final` keyword to make classes with behaviors
    that can''t be modified or inherited by any other classes. You''ve got the idea.
    If you make our `Person` class final then you won''t be able to inherit it. It''s
    weird though, in Scala you can declare a class as final as well as `abstract`*.*
    Yes, it''s possible in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, the compiler doesn't let us inherit from abstract final classes.
    It would be great if you could find use cases though. For instant gratification,
    you may want to search for phantom types in Scala and think of use cases for our,
    can't instantiate or inherit abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you're coming from an object-oriented programming background, or have
    an idea about `static` members in Java, you may be thinking, how do we achieve
    that in Scala? The basic usage of a static class or static member is that, for
    those that have only one instance, that particular member will be the same for
    all instances of a particular class. If you change the value of a static member,
    it'll be changed for all instances. You'll be getting more of an idea of what
    we're talking about in the next topic that we're going to discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Objects as singletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no static members or classes in Scala. Once you feel the need to create
    a static member, for example a static method or a class that is going to have
    only one instance, you should create an object. Yes, up until now, almost all
    the time we have been creating an object that extends the `App` trait so that
    we don't have to define the `main` method. This is the entry point to our application.
    So, it's also obvious that when we mention `object`*,* we don't mean an instance
    of any class; rather, an `object` in Scala has a different meaning.
  prefs: []
  type: TYPE_NORMAL
- en: An object*,* just like classes, is a container for functions and values. The
    reason why we may want to declare an object is so we can define utility methods
    for any particular type, or sometimes define JSON formatters and similar use cases.
    Let's take another look at how we can define an object*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like we just created an object. Nothing fancy, just an `object` keyword along
    with the name of the object. We know that objects are singletons, hence it does
    not make any sense to pass arguments in the constructor and therefore, Scala doesn''t
    allow you to do so. That''s it. Why not use your `CountryUtil` object to define
    some utility methods such as a method that takes a sequence of populations and
    returns the average of them? Let''s try that in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: And here we are, with the average population of France for the years we wanted.
    We achieved this by passing the map to our utility function named `populationAverage`
    that takes a sequence of population values in millions. The idea here was to present
    a container that can contain utility methods for a class, and that's why we have
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you''re wondering, if it''s possible to extend from an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: No, we cannot. The first reason is that it's unintended. Secondly, the Scala
    compiler creates a compiled Java version of our objects, which is a `final` class.
    What happens when we create an *object* and it gets compiled? Scala creates a
    few class files based on the modifiers you choose. In our case, if you compile
    the `CountryUtil` object, the compiler creates `CountryUtil.class` and `CountryUtil$.class`*,*
    and these are final by nature. Let's take a look at these.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of the `CountryUtil.class` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an implementation of the `CountryUtil$.class` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, this is quite some Java code. You may not be very interested in the details
    right now, but two things to look out for are the keywords `static` and `final`*.*
    First, these two classes are `final`, as we discussed, and the utility method
    is `static`. Thus, you may get an idea of what the Scala compiler is cooking in
    the background. Great. Also, this does not stop you from extending a class or
    trait from an object. Hence, writing something like the following is possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that said, let''s discuss more use cases of objects in Scala. We all
    know that we can define utility methods for a particular class in Scala objects.
    Using them is also easy, plus these utility methods can be used from anywhere.
    All you need to do is to add an `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a `DateUtil` object with a utility `dayOfWeek(date: String)`function. This
    tells us the day of the week when we pass a date to it in a certain format. We
    also created an app which imports this `DateUtilobject` and from that, we get
    access to all functions inside that object. With this, we were able to directly
    make a call to our function and get the result.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a fair pattern where we define a class and then create some functions
    that are not instance-specific but can be used from instances, such as the example
    we had for the `Country` class and its utility object named `CountryUtil`*.* The
    language creators knew it well, and introduced the concept of what we call companion
    objects. That's what we're going to learn about next.
  prefs: []
  type: TYPE_NORMAL
- en: Companion objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Companion objects are not very different to what we have already seen when
    we discussed objects. One specific difference is that we name those the same as
    our class names. It means that instead of defining `CountryUtil`*,* we can give
    this object the same name as our `Country` class and call it our companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code does what we had said earlier. We named our object the same
    as our `Country`class*.* This is how we define companion objects. This structures
    your code in a nice manner as well, as it provides you with the ability to make
    your types do something. It's handy to know that, to make your objects a *companion*
    you must define them in the same source file.
  prefs: []
  type: TYPE_NORMAL
- en: If, by chance, you find yourself trying that in the Scala REPL it should be
    done in paste mode (`:paste`). Let's see what we mean by that. So, open the Scala
    REPL and try creating a class and its companion object. The REPL will show a warning: *previously
    defined class is not a companion to object. **Companions must be defined together;
    you may wish to use :paste mode for this.*
  prefs: []
  type: TYPE_NORMAL
- en: So we do as suggested. We give the `:paste` command in the REPL, which will
    enable paste mode, and then write our class with companion mode. Then everything
    seems good.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are useful constructs that we''ve used in various places already. When
    we use `case` *classes* or typeclass (we''ll learn about typeclasses in [Chapter
    10](part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84), *Advanced Functional
    Programming*) implementation, we''ll be searching for companion objects for them.
    In fact, whenever we see our class has a particular thing to do, we have this
    nice way of building its companion object with the `apply` method. Take a look
    at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is for illustration purposes. There were different ways we could
    have achieved what we did here, but to understand *companion objects* with `apply`
    methods is simpler this way. So, what''s different in the preceding example? Is
    it the way we used our `DateApp` application? Yes, when we define the `apply`
    method in the companion object the Scala compiler lets us use it without an explicit
    call to itself. That''s what we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We defined a class named `Date`*,* and along with that we created its companion
    with the `apply` method. It gives us the advantage of manipulating the instance
    into giving us something back. In our case, we retrieved some more information
    to make the instances of `Date` more meaningful, and instantiated `Date` with
    more information. Users of `Date` will get more information than we give. This
    seems interesting. However, the actual implementation needs to take care of exceptional
    scenarios as well. For example, what if, while parsing the date, we encounter
    an exception? We won't go into detail right now, as our motto was to understand
    this pattern and find uses for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of simpler scenarios where we want to omit the unnecessary boilerplate
    code that we have to write when we create a simple class, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have our simple `Country` class where, thanks to Scala, we don't have
    to define accessors and mutators for our class. However, this is not so great.
    We still have to define methods such as `toString`*,* `equals`, or `hashCode`*.*
    What if Scala could does it for you, along with the removal of extra keywords
    that we have to write such as `new`*,* `val`, and so on?
  prefs: []
  type: TYPE_NORMAL
- en: And yes, the entire point of mentioning all these is to affirm that we can do
    a lot in Scala using case classes, which we are going to discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Case classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are case classes, why do we have them, and how do we use them? These are
    a few questions you may want an answer to. So, in simpler words, a case class
    can omit the amount of code we may have to write to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of declaring `Country` as we do in the preceding code, we would prefer
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And our case class `Country` definition takes care of the rest. We have accessor
    methods for our `name` and `capital` members. We have our `toString` and `equals`
    methods defined by the Scala compiler, or let''s say, auto-generated for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an instance of the `Country$.class` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an instance of the `Country.class` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of interesting things are going on in the background. The Scala compiler
    creates and defines all the necessary methods for our case class and making our
    life easy. All these conciseness is because of the compiler''s ability to remove
    all the boilerplate that we may have to write. A few important methods that the
    compiler defines for us are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unapply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canEqual`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashCode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with these, the compiler also creates the constructor along with immutable
    fields, as well as accessors for those fields and a few utility methods such as
    `productArity`, `productPrefix`, and `productElement`*.* It''s worth noting that
    a few methods such as the `apply` and `unapply` methods are declared `static`
    in compiled form. It means that these can be called in the form of `Country.apply(...)`
    or `Country.unapply(...)`*,* but others can be called upon instances of the case
    class. It won''t be possible to call `Country.copy(...)`, as the compiler will
    not allow us to perform this operation. Speaking of all these, let''s try them
    for our example `Country`case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We saw all the methods applied in the preceding code. It's worth noting that
    these methods are useful and provide more information about the class instance
    along with the basic behavior. That was our intention of creating a companion
    object. Remember, we created our `Date` class with a companion object, whose instance
    happened to be more meaningful than the information provided at declaration time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more than one reason to prefer using case classes over usual classes
    in Scala. It''s obvious that case classes are concise and yet give us more than
    we may get by writing our own. Due to that reason, we have more information about
    these case classes and their members. For example, the unapply method gives us
    information that you may need when inspecting an instance. We can use these in
    pattern matching and it''s also recommended to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This may look simple, but it''s a powerful construct and used heavily. No wonder
    you also find yourself matching case class instances more often. It''s simple
    to do so and, according to our snippet, it''ll print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It does this as expected due to the `unapply` method; pattern matching worked
    on our case class instance. It is also worth knowing that you can''t declare a
    case class along with a class with the same name. Scala won''t allow you to declare
    a class and case class with the same name in the same scope. By same scope, what
    we mean is that if you declare a case class, let''s say country with the same
    name as a Country class in the same compilation unit, it''s fair enough, because
    those belong to different scopes. To make the statement clear, look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is totally fine to declare, but if we try to put our class
    inside `CountryUtil` or take our case class outside of `CountryUtil`, the compiler
    will not let us do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala compiler will not let you do so, saying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, you may not want to do such a thing anyway. In case you''re wondering
    whether it''s possible to extend from a case class or not, it''s possible to do
    the following with case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We'll learn more about inheritance in the next chapter. For now, we've seen
    enough to be prepared for what comes next. It's time to summarize what we've learned
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was interesting because we learned the details of Scala classes
    and object implementation. We started with what classes means in Scala, how we
    can declare them, and use them. Then we talked about objects as singleton instances
    in Scala. We then talked about interesting companion objects, which led us to
    case classes. We learned that case classes not only give us the conciseness we
    want but can also be very useful in scenarios where we may want to do pattern
    matching over instances. Finally, we discussed all the methods and goodies that
    case classes provide.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take our knowledge of object-oriented Scala to the
    next level and talk more about traits, inheritance, and a lot more.
  prefs: []
  type: TYPE_NORMAL
