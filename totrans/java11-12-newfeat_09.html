<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The HTTP Client API</h1>
                </header>
            
            <article>
                
<p>With the HTTP Client API, your Java code can request HTTP resources over the network, using the HTTP/2 protocol, in a non-blocking and asynchronous way. It brings major improvements to the existing <kbd>HttpURLConnection</kbd> class, which was added to Java in Version 1.1, and only works in a blocking and synchronous way.</p>
<p>The HTTP Client was incubated in Java 9, with multiple modifications in Java 10, and was standardized in Java 11. It resides in the <kbd>java.net.http</kbd><span> package and module.</span></p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>An introduction to the HTTP Client</li>
<li>Sending requests synchronously and asynchronously</li>
<li>Converting response bytes to high-level formats</li>
<li>Using Reactive Streams to handle HTTP requests and responses</li>
<li><kbd>BodyHandler</kbd>, <kbd>BodyPublisher</kbd>, and <kbd>BodySubscriber</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The code in this chapter will use the standardized HTTP Client API classes from Java 11. If you are using the incubated HTTP Client from the previous Java versions, such as 9 or 10, all of the code in this chapter won't work as specified. A lot of method names have changed.</p>
<p>All of the code in this chapter can be accessed at <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a>.</p>
<p>Before diving into the details, let's get a hang of the problem that led to the introduction of this new API for requesting HTTP resources.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A quick flashback</h1>
                </header>
            
            <article>
                
<p>The HTTP Client API was incubated in Java 9. Essentially, this means that this API wasn't a part of the Java SE. It was defined in the <kbd>jdk.incubator.httpclient</kbd> <span>package.</span> The incubated features should explicitly be added to a project's classpath. The incubated features are released by Oracle to enable developers to use and experiment with them and provide their feedback, which decides the fate of HTTP Client API. In a future Java version, incubated APIs and features are either included as a full feature or just dropped off. There is no partial inclusion.</p>
<p>Just in case you need a quick refresher on HTTP, we will provide one here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What can you do with HTTP?</h1>
                </header>
            
            <article>
                
<p>HTTP is a protocol to transfer hypertext (remember <kbd>&lt;html&gt;</kbd>?) on the <strong>World Wide Web</strong> (<strong>WWW</strong>). If you have used a web browser to access any website (chances are that you have), then you've already used HTTP. Your web browser works as a client on your system, requesting access to resources, such as web pages or files, over the network. Your web browser uses HTTP to send the request to the server. The requested resources are transferred from the server to the client, using the HTTP protocol.</p>
<p>The most common HTTP operations are <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>. Here are a few quick examples:</p>
<ul>
<li>Imagine registration on a website; you fill in your details and submit them. This is a <kbd>POST</kbd> request, in which the form values are not appended to the URI.</li>
<li>Now, imagine bookmarking the details page of your favorite book in an online portal (say, <a href="https://www.amazon.co.uk/">https://www.amazon.co.uk/</a>). You'll notice a set of variable names and values appended to the URI (separated by <kbd>&amp;</kbd>) following the question mark (<kbd>?</kbd>). There's an example at <a href="https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&amp;field-keywords=mala+oca+8">https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&amp;field-keywords=mala+oca+8</a>. This is a <kbd>GET</kbd> request.</li>
<li>The <kbd>PUT</kbd> request is used to create or update an entity on a server, using a URI. The <kbd>PUT</kbd> request refers to the entity, whereas a <kbd>POST</kbd> request refers to a resource that will handle the submitted data.</li>
<li>The <kbd>DELETE</kbd> request can delete an entity, using an identifying ID appended to a URI.</li>
</ul>
<div class="packt_infobox">Don't worry if you couldn't follow all of the HTTP operations, such as <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, or <kbd>DELETE</kbd>. You'll be able to follow them as you progress with the chapter.</div>
<p>In the same way that you can access resources over the network by using a web browser, you can use your Java code to access the same resources programmatically. There are multiple use cases; for example, imagine connecting to a website, downloading the latest news and simply listing it for the users of your application.</p>
<div class="packt_infobox">More information on HTTP/2 can be accessed at <a href="https://tools.ietf.org/html/rfc7540">https://tools.ietf.org/html/rfc7540</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The need for the HTTP Client API</h1>
                </header>
            
            <article>
                
<p>Until now, Java developers have been using the <kbd>HttpURLConnection</kbd> class to request HTTP resources over the network. However, it has multiple downsides, which led to the development of the HTTP Client API.</p>
<p>Introduced in JDK 1.1, the <kbd>HttpURLConnection</kbd> class was never designed to work in an asynchronous way; it works in a blocking mode only. This contrasts with the changing nature of the applications and the data that we work with today. The world is moving toward responsive programming, which deals with processing real-time data, and we can't afford to work with blocking communications or one request or response over a connection.</p>
<p>The <kbd>HttpURLConnection</kbd> class is also difficult to use for the developers; part of its behavior is not documented. The base class of <kbd>HttpURLConnection</kbd>, that is, the <kbd>URLConnection</kbd> API, supports multiple protocols, most of which are not used now (for example, Gopher). This API doesn't support HTTP/2, since it was created way earlier than the formulation of HTTP/2.</p>
<p>Also, similar advanced APIs were available, such as Apache <kbd>HttpClient</kbd>, Eclipse Netty and Jetty, and others. It was high time that Oracle updated its own HTTP access API, keeping pace with the development and supporting its developers. One of the main goals of the HTTP Client is to have its memory consumption and performance on par with Apache <kbd>HttpClient</kbd>, Netty, and Jetty.</p>
<p class="mce-root"/>
<div class="packt_infobox"><kbd>HttpURLConnection</kbd> can't work in an asynchronous, non-blocking manner, which was one of the main reasons for the creation of the HTTP Client.</div>
<p>Now that you know why you need the HTTP Client API, let's get to work with its usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP Client usage</h1>
                </header>
            
            <article>
                
<p>You can use the HTTP Client to access HTTP resources across the network, using either HTTP/1.1 or HTTP/2, sending a request and accepting responses asynchronously, in a non-blocking manner. It uses Reactive Streams to work asynchronously with requests and responses.</p>
<p>It can also be used to send requests and receive responses synchronously.</p>
<p>The HTTP Client API consists of three main classes or interfaces:</p>
<ul>
<li>The <kbd>HttpClient</kbd> c<span>lass </span></li>
<li>The <kbd>HttpRequest</kbd> c<span>lass </span></li>
<li>The <kbd>HttpResponse</kbd> i<span>nterface </span></li>
</ul>
<p>The <kbd>HttpClient</kbd> class is used to send a request and retrieve the corresponding responses; <kbd>HttpRequest</kbd> encapsulates the details of the requested resource, including the request URI. The <kbd>HttpResponse</kbd> class encapsulates the response from the server.</p>
<div class="packt_infobox">In Java 11, the standardized HTTP Client is defined in the <kbd>java.net.http</kbd> module and package.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A basic example</h1>
                </header>
            
            <article>
                
<p>Before diving into the details of the individual classes of the HTTP Client, I'm including a basic example to let you get a hang of sending a request to a server and processing the response using the HTTP Client. I'll add to this example as we move forward, covering <kbd>HttpClient</kbd>, <kbd>HttpRequest</kbd>, and <kbd>HttpResponse</kbd> in detail. This is to help you get the bigger picture and then<em> </em>dive into the details.</p>
<p class="mce-root"/>
<p>The following example shows how to create a basic <kbd>HttpClient</kbd> instance, use it to access a URI encapsulated by <kbd>HttpRequest</kbd>, and process the response, accessible as a <kbd>HttpResponse</kbd> instance:</p>
<pre>// basic HttpClient instance 
HttpClient client = HttpClient.newHttpClient();        
 
// Using builder pattern to get a basic HttpRequest instance with just //the URI 
HttpRequest request = HttpRequest.newBuilder()         
                     .uri(URI.create("http://www.ejavaguru.com/"))   
                     .build();                                       
 
// response instance not created using a builder. 
// HttpClient sends HttpRequests and makes HttpResponse available 
HttpResponse&lt;String&gt; response = client.send(request,  
                            HttpResponse.BodyHandlers.ofString()); 
System.out.println(response.body()); </pre>
<p>In the preceding code, the <kbd>newHttpClient()</kbd> factory method returns a basic <kbd>HttpClient</kbd> instance, which can be used to send an HTTP request and receive its corresponding response. <kbd>HttpRequest</kbd> is created using the builder pattern by passing it the URI to connect with (which is the minimum requirement). The <kbd>HttpResponse</kbd> instance is not created explicitly by a developer but is received after a request is sent from <kbd>HttpClient</kbd> to a server.</p>
<p>The <kbd>send()</kbd> method sends the request synchronously and waits for the response. When the client receives the response code and headers, it invokes <kbd>BodyHandler</kbd> before the response body is received. Upon invocation, <kbd>BodyHandler</kbd> creates <kbd>BodySubscriber</kbd> (a Reactive Stream subscriber), which receives the streams of response data from the server and converts them to an appropriate higher-level Java type.</p>
<p>If you didn't understand the preceding explanation completely, don't worry; I'll cover this in detail in the following sections.</p>
<div class="packt_infobox">The HTTP Client uses Reactive Streams (<kbd>BodyPublisher</kbd> and <kbd>BodySubscriber</kbd>) to send and receive data streams in an asynchronous and non-blocking way. Basic familiarity with Reactive Streams is recommended in order to understand how HTTP Client sends and receives data with them.</div>
<p>Let's dive into the details, starting with the <kbd>HttpClient</kbd> <span>class. </span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HttpClient class </h1>
                </header>
            
            <article>
                
<p>The <kbd>HttpClient</kbd> class is used to send requests and receive responses. It encapsulates details such as which version of the HTTP protocol to use, whether to follow redirects (if the resource you are trying to connect to has moved to another location), whether to use a proxy or an authenticator, and a few more things. The <kbd>HttpClient</kbd> <span>class </span>is used to configure a client state (an HTTP Client sends and receives data from a client to server). An <kbd>HttpClient</kbd> instance can be used to send multiple requests and receive their corresponding responses. However, once created, an <kbd>HttpClient</kbd> instance is immutable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an HttpClient instance</h1>
                </header>
            
            <article>
                
<p>You can create an instance of <kbd>HttpClient</kbd> in two ways: by using its static <kbd>getHttpClient()</kbd> method, or by using the <kbd>newBuilder()</kbd> method (this follows the builder pattern).</p>
<p>The static <kbd>getHttpClient()</kbd> method returns a <kbd>HttpClient</kbd> instance with basic or default settings, as follows:</p>
<pre>HttpClient client = HttpClient.newHttpClient(); </pre>
<p>To add custom settings, you can use its <kbd>newBuilder()</kbd> method, which follows the builder design pattern and calls relevant methods. Let's start with a basic version, and then add to it. For example, you can use the following code to set the HTTP version as <kbd>2</kbd>:</p>
<pre>HttpClient client = HttpClient.builder(). 
                     .version(Version.HTTP_2) 
                     .build(); </pre>
<div class="packt_infobox">If HTTP/2 protocol is not supported, the <kbd>HttpClient</kbd> instance defaults to HTTP/1.1.</div>
<p>Often, when you access a resource using a web browser, you see a message stating that the resource has moved to another location and that you are being redirected to the new address. In this case, your web browser receives the new URI. You can accomplish the redirection to the new URI programmatically, by specifying so, through the method <kbd>followRedirects()</kbd>. Here's an example:</p>
<pre>HttpClient client = HttpClient.builder(). 
                     .version(Version.HTTP_2) 
                     .followRedirects(Redirect.NORMAL), 
                     .build(); </pre>
<p>The preceding code calls <kbd>followRedirects()</kbd>, passing <kbd>Redirect.NORMAL</kbd>. Now, <kbd>Redirect</kbd> is a nested enum defined in the <kbd>HttpClient</kbd> class, with the following constant values:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td>
<p><strong>Enum Value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ALWAYS</kbd></p>
</td>
<td>
<p>Always redirect</p>
</td>
</tr>
<tr>
<td>
<p><kbd>NEVER</kbd></p>
</td>
<td>
<p>Never redirect</p>
</td>
</tr>
<tr>
<td>
<p><kbd>NORMAL</kbd></p>
</td>
<td>
<p>Always redirect, except for HTTPS URLs to HTTP URLs</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>It's common for a lot of websites to authenticate a user by its registered username and password. You can add the authentication values to <kbd>HttpClient</kbd> by using the <kbd>authenticator()</kbd> method. The following example uses the default authentication:</p>
<pre>HttpClient client = HttpClient.newBuilder(). 
                      .version(Version.HTTP_2) 
                      .followRedirects(redirect.NORMAL), 
                      .authenticator(Authenticator.getDefault()) 
                      .build(); </pre>
<p>The following code uses custom values (<kbd>"admin"</kbd> and <kbd>"adminPassword"</kbd>) for authentication:</p>
<pre>HttpClient client = HttpClient.newBuilder(). <br/>                      .version(Version.HTTP_2) 
                      .followRedirects(redirect.NORMAL), 
                      .authenticator(new Authenticator() { 
                        public PasswordAuthentication <br/>                         getPasswordAuthentication() { 
                          return new PasswordAuthentication( <br/>                          "admin", "adminPassword".toCharArray()); 
                       }) 
                    .build(); </pre>
<p>The code snippets in this section demonstrated how to create an instance of <kbd>HttpClient</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Methods of the HttpClient class </h1>
                </header>
            
            <article>
                
<p>To request an HTTP resource over the network, you'll need to call either of the methods <kbd>send()</kbd> or <kbd>sendAsync()</kbd> on the <kbd>HttpClient</kbd> instance. The <kbd>send()</kbd> method sends a request and receives its response synchronously; it will block until these tasks are not complete. The method <kbd>sendAsync()</kbd> communicates with a server asynchronously; it sends a request and immediately returns with <kbd>CompletableFuture</kbd>.</p>
<p>Before I include examples of the <kbd>send()</kbd> and <kbd>sendAsync()</kbd> methods, it is important to understand the other two classes: <kbd>HttpRequest</kbd> and <kbd>HttpResponse</kbd>. I'll cover these methods (<kbd>send()</kbd> and <kbd>sendAsync()</kbd>) in the section on <kbd>HttpResponse</kbd>.</p>
<p>Here's a quick list of the important methods of the <kbd>HttpClient</kbd><span> class:</span></p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td>
<p><strong>Method Return Type</strong></p>
</td>
<td>
<p><strong>Method Name</strong></p>
</td>
<td>
<p><strong>Method Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong><kbd>abstract Optional&lt;Authenticator&gt;</kbd></strong></p>
</td>
<td>
<p><strong><kbd>authenticator()</kbd></strong></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing the <kbd>Authenticator</kbd> instance set on this client</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract Optional&lt;Executor&gt;</kbd></p>
</td>
<td>
<p><kbd>executor()</kbd></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing this client's <kbd>Executor</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract HttpClient.Redirect</kbd></p>
</td>
<td>
<p><kbd>followRedirects()</kbd></p>
</td>
<td>
<p>Returns the <kbd>followRedirects</kbd> policy for this client</p>
</td>
</tr>
<tr>
<td>
<p><kbd>static HttpClient.Builder</kbd></p>
</td>
<td>
<p><kbd>newBuilder()</kbd></p>
</td>
<td>
<p>Creates a new <kbd>HttpClient</kbd> builder</p>
</td>
</tr>
<tr>
<td>
<p><kbd>static HttpClient</kbd></p>
</td>
<td>
<p><kbd>newHttpClient()</kbd></p>
</td>
<td>
<p>Returns a new <kbd>HttpClient</kbd> with default settings</p>
</td>
</tr>
<tr>
<td>
<p><kbd>WebSocket.Builder</kbd></p>
</td>
<td>
<p><kbd>newWebSocketBuilder()</kbd></p>
</td>
<td>
<p>Creates a new <kbd>WebSocket</kbd> builder (optional operation)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract Optional&lt;ProxySelector&gt;</kbd></p>
</td>
<td>
<p><kbd>proxy()</kbd></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing the <kbd>ProxySelector</kbd> instance supplied to this client</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract &lt;T&gt; HttpResponse&lt;T&gt;</kbd></p>
</td>
<td>
<p><kbd>send (HttpRequest request, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)</kbd></p>
</td>
<td>
<p>Sends the given request using this client, blocking, if necessary, to get the response</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;</kbd></p>
</td>
<td>
<p><kbd>sendAsync (HttpRequest request, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)</kbd></p>
</td>
<td>
<p>Sends the given request asynchronously, using this client with the given response body handler</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;</kbd></p>
</td>
<td>
<p><kbd>sendAsync (HttpRequest request, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler, HttpResponse.PushPromiseHandler&lt;T&gt; pushPromiseHandler)</kbd></p>
</td>
<td>
<p>Sends the given request asynchronously, using this client with the given response body handler and push promise handler</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract SSLContext</kbd></p>
</td>
<td>
<p><kbd>sslContext()</kbd></p>
</td>
<td>
<p>Returns this client's <kbd>SSLContext</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract SSLParameters</kbd></p>
</td>
<td>
<p><kbd>sslParameters()</kbd></p>
</td>
<td>
<p>Returns a copy of this client's <kbd>SSLParameters</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract HttpClient.Version</kbd></p>
</td>
<td>
<p><kbd>version()</kbd></p>
</td>
<td>
<p>Returns the preferred HTTP protocol version for this client</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The next step is to work with the <kbd>HttpRequest</kbd> class to define the details of the request.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HttpRequest</h1>
                </header>
            
            <article>
                
<p>The <kbd>HttpRequest</kbd> class encapsulates the information required to be sent across the network to the server by the client. It includes the URI to connect with, headers with a set of variable names and their corresponding values, the timeout value (the time to wait before discarding the request), and the HTTP method to invoke (<kbd>PUT</kbd>, <kbd>POST</kbd>, <kbd>GET</kbd>, or <kbd>DELETE</kbd>).</p>
<p>Unlike the <kbd>HttpClient</kbd> class, <kbd>HttpRequest</kbd> doesn't give you a class instance with the default values, and it makes sense not to. Imagine the URI that the client would connect to if you don't specify it.</p>
<p>Let's create an <kbd>HttpRequest</kbd> instance by calling its <kbd>newBuilder()</kbd> method and passing a URI to it:</p>
<pre>HttpRequest request = HttpRequest.newBuilder() 
                        .uri(URI.create("http://www.eJavaGuru.com/")) 
                        .build(); </pre>
<p>You can add the timeout to your requests by using the <kbd>timeout()</kbd> method, as follows:</p>
<pre>HttpRequest request = HttpRequest.newBuilder() 
                        .uri(URI.create("http://www.eJavaGuru.com/")) 
                        .timeout(Duration.ofSeconds(240)) <br/>                        .build(); </pre>
<p>A <kbd>request</kbd> instance must include the HTTP method to use. If no method is specified, a <kbd>GET</kbd> request is made, by default. In the preceding code, a <kbd>GET</kbd> request is made. Let's specify the HTTP method explicitly. The most common HTTP methods are <kbd>GET</kbd> and <kbd>POST</kbd>. The <kbd>DELETE</kbd> and <kbd>PUT</kbd> HTTP methods are also used.</p>
<p class="mce-root"/>
<p>The following example specifies the method as the <kbd>POST</kbd> method:</p>
<pre>HttpRequest request = HttpRequest.newBuilder() 
                     .uri(new URI("http://www.eJavaGuru.com/")) 
                     .timeout(Duration.ofSeconds(240)) 
                     .POST(HttpRequest.noBody()) 
                     .build(); </pre>
<p>The <kbd>POST</kbd> method requires you to pass an instance of the <kbd>BodyProcessor</kbd> class. For a <kbd>POST</kbd> request that doesn't require a body, you can pass <kbd>HttpRequest.noBody()</kbd>. You can use multiple sources, such as a string, <kbd>InputStream</kbd>, byte array, or file, and pass it to the <kbd>POST</kbd> method. Here's an example that passes a file to the <kbd>POST</kbd> method:</p>
<pre>HttpRequest request = HttpRequest.newBuilder() 
                        .uri(new URI("http://www.eJavaGuru.com/")) 
                        .timeout(Duration.ofSeconds(240)) 
                        .POST(HttpRequest.BodyProcessor 
                        .fromFile(Paths.get("data.txt"))) 
                        .build(); </pre>
<p>The following example passes a string to the <kbd>POST()</kbd> method:</p>
<pre>HttpRequest request = HttpRequest.newBuilder() 
                        .uri(new URI("http://www.eJavaGuru.com/")) 
                        .timeout(Duration.ofSeconds(240)) <br/>                        .POST(HttpRequest.BodyProcessor 
                        .fromString("This is sample data")) 
                        .build(); </pre>
<p>Imagine that you are working with an application that deals with buying shares when their prices rise or fall above or below a threshold. Here's some good news for you. <kbd>BodyProcessor</kbd> is a Reactive Stream publisher; you can deal with real-time data (such as stock prices) with controlled back pressure by using it.</p>
<div class="packt_infobox"><kbd>BodyProcessor</kbd> defines convenient methods, such as <kbd>fromFile()</kbd>, <kbd>fromString()</kbd>, <kbd>fromInputStream()</kbd>, and <kbd>fromByteArray()</kbd>, to pass varied values conveniently.</div>
<p>Another frequently used method is <kbd>header()</kbd>, which specifies the contents of the request. Here's an example, which specifies the contents of <kbd>request</kbd> as <kbd>text/plain</kbd>:</p>
<pre>HttpRequest request = HttpRequest.newBuilder() 
                        .uri(URI.create("http://www.eJavaGuru.com/")) 
                        .header("Content-Type", "text/plain") <br/>                        .build();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here's a list of the important methods of the <kbd>HttpClient</kbd> <span>class </span>:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td>
<p>Method Return Type</p>
</td>
<td>
<p>Method Name</p>
</td>
<td>
<p>Method Description</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract Optional&lt;HttpRequest.BodyPublisher&gt;</kbd></p>
</td>
<td>
<p><kbd>bodyPublisher()</kbd></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing the <kbd>HttpRequest.BodyPublisher</kbd> instance set on this request</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract boolean</kbd></p>
</td>
<td>
<p><kbd>expectContinue()</kbd></p>
</td>
<td>
<p>Returns the requests to continue setting</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract HttpHeaders</kbd></p>
</td>
<td>
<p><kbd>headers()</kbd></p>
</td>
<td>
<p>The (user-accessible) request headers that this request was (or will be) sent with</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract String</kbd></p>
</td>
<td>
<p><kbd>method()</kbd></p>
</td>
<td>
<p>Returns the request method for this request</p>
</td>
</tr>
<tr>
<td>
<p><kbd>static HttpRequest.Builder</kbd></p>
</td>
<td>
<p><kbd>newBuilder()</kbd></p>
</td>
<td>
<p>Creates an <kbd>HttpRequest</kbd> builder</p>
</td>
</tr>
<tr>
<td>
<p><kbd>static HttpRequest.Builder</kbd></p>
</td>
<td>
<p><kbd>newBuilder (URI uri)</kbd></p>
</td>
<td>
<p>Creates an <kbd>HttpRequest</kbd> builder with the given URI</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract Optional&lt;Duration&gt;</kbd></p>
</td>
<td>
<p><kbd>timeout()</kbd></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing this request's timeout duration</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract URI</kbd></p>
</td>
<td>
<p><kbd>uri()</kbd></p>
</td>
<td>
<p>Returns this request's URI</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abstract Optional&lt;HttpClient.Version&gt;</kbd></p>
</td>
<td>
<p><kbd>version()</kbd></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing the HTTP protocol version that will be requested for this <kbd>HttpRequest</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Unlike the <kbd>HttpClient</kbd> and <kbd>HttpRequest</kbd> classes, you don't create instances of the <kbd>HttpResponse</kbd> class. Let's look at how you can instantiate it in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HttpResponse</h1>
                </header>
            
            <article>
                
<p>When you send an <kbd>HttpRequest</kbd> instance using an <kbd>HttpClient</kbd> instance, you receive <kbd>HttpResponse</kbd>. Upon sending an HTTP request, a server typically returns the status code of the response, the response header, and the response body.</p>
<p>So, when can you access the response body? It depends on the <kbd>BodyHandler</kbd> that you specify to be used, when you send the request using the <kbd>HttpClient</kbd> <kbd>send()</kbd> or <kbd>sendAsync()</kbd> methods. Depending on the specified <kbd>BodyHandler</kbd>, you might be able to access the response body after the response status code and header are available (and before the response body is made available).</p>
<p class="mce-root"/>
<p>Let's revisit the first example from this chapter:</p>
<pre>HttpClient client = HttpClient.newHttpClient();        
 
HttpRequest request = HttpRequest.newBuilder()         
                       .uri(URI.create("http://google.com/"))   
                       .build();                                       
 
HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.<br/>                                            BodyHandlers.ofString()); 
System.out.println(response.body()); </pre>
<p>In the preceding example, the <kbd>send()</kbd> method specifies <kbd>BodyHandler</kbd> as <kbd>BodyHandlers.ofString()</kbd>. It converts the received response body bytes to a high-level Java type: string. You can also use <kbd>BodyHandlers.ofFile()</kbd>, <kbd>BodyHandlers.ofInputStream()</kbd>, or <kbd>BodyHandlers.discard()</kbd> to save the response to a file, use the response as an input stream, or discard it.</p>
<p><kbd>BodyHandler</kbd> is a static interface defined within the <kbd>HttpResponse</kbd> <span>interface.</span> <kbd>HttpResponse</kbd> also defines a static class, <kbd>BodyHandler</kbd>, which defines a varied and useful implementation of the <kbd>BodyHandler</kbd> interface. For example, you could use <kbd>BodyHandlers.ofFile()</kbd> to write the received response to the specified file. Behind the scenes, <kbd>BodyHandler</kbd> uses <kbd>BodySubscriber</kbd> (a Reactive Stream), which subscribes to the response bytes from the server.</p>
<div class="packt_infobox">The convenient static methods of <kbd>BodyHandlers</kbd> (<kbd>ofFile()</kbd>, <kbd>ofString()</kbd>, <kbd>ofInputStream()</kbd>, and <kbd>discard()</kbd>) let you work with a reactive data stream: <kbd>BodySubscriber</kbd>.</div>
<p>Here's a list of the important methods of the <kbd>HttpResponse</kbd> <span>interface: </span></p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td>
<p><strong>Method Return Type</strong></p>
</td>
<td>
<p><strong>Method Name</strong></p>
</td>
<td>
<p><strong>Method</strong> <strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>T</kbd></p>
</td>
<td>
<p><kbd>body()</kbd></p>
</td>
<td>
<p>Returns the body</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HttpHeaders</kbd></p>
</td>
<td>
<p><kbd>headers()</kbd></p>
</td>
<td>
<p>Returns the received response headers</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Optional&lt;HttpResponse&lt;T&gt;&gt;</kbd></p>
</td>
<td>
<p><kbd>previousResponse()</kbd></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing the previous intermediate response, if one was received</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HttpRequest</kbd></p>
</td>
<td>
<p><kbd>request()</kbd></p>
</td>
<td>
<p>Returns the <kbd>HttpRequest</kbd> instance corresponding to this response</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Optional&lt;SSLSession&gt;</kbd></p>
</td>
<td>
<p><kbd>sslSession()</kbd></p>
</td>
<td>
<p>Returns <kbd>Optional</kbd> containing the <kbd>SSLSession</kbd> instance in effect for this response</p>
</td>
</tr>
<tr>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p><kbd>statusCode()</kbd></p>
</td>
<td>
<p>Returns the status code for this response</p>
</td>
</tr>
<tr>
<td>
<p><kbd>URI</kbd></p>
</td>
<td>
<p><kbd>uri()</kbd></p>
</td>
<td>
<p>Returns the URI that the response was received from</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HttpClient.Version</kbd></p>
</td>
<td>
<p><kbd>version()</kbd></p>
</td>
<td>
<p>Returns the HTTP protocol version that was used for this response</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's work with some examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some examples</h1>
                </header>
            
            <article>
                
<p>What happens when you connect with a web application or web service using HTTP? The server can return text or data in multiple formats, including HTML, JSON, XML, binary, and many others. Also, the language or framework used to write the server-side application or service doesn't matter. For instance, a web application or service that you connect with might be written using PHP, Node, Spring, C#, Ruby on Rails, or others.</p>
<p>Let's work with some simple use cases, such as connecting to a web server using <kbd>GET</kbd> or <kbd>POST</kbd> requests, synchronously or asynchronously, submitting request data, and receiving the response and storing it using multiple formats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing HTML pages using synchronous GET</h1>
                </header>
            
            <article>
                
<p><kbd>HttpClient</kbd> can receive a response from a server in either a synchronous or asynchronous manner. To receive a response synchronously, use the <kbd>HttpClient</kbd> method, <kbd>send()</kbd>. This request will block the thread until the response is completely received.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The following code connects to Oracle's web server that hosts the API documentation of the <kbd>HttpClient</kbd> <span>class, </span>using a <kbd>GET</kbd> request sent synchronously:</p>
<pre>class SyncGetHTML { 
    public static void main(String args[]) throws Exception { 
        HttpClient client = HttpClient.newHttpClient(); 
        HttpRequest request = HttpRequest.newBuilder() 
        .uri(URI.create("https://docs.oracle.com/en/java/javase<br/>        /11/docs/api/java.net.http/java/net/http/HttpClient.html")) 
              .build(); 
 
        HttpResponse&lt;String&gt; response = 
              client.send(request, BodyHandlers.ofString()); 
        System.out.println(response.body()); 
    } 
} </pre>
<p>The preceding code generates a lot of text. The following are just a few initial lines from the output:</p>
<pre>&lt;!DOCTYPE HTML&gt; 
&lt;!-- NewPage --&gt; 
&lt;html lang="en"&gt; 
&lt;head&gt; 
&lt;!-- Generated by javadoc --&gt; 
&lt;title&gt;HttpClient (Java SE 11 &amp; JDK 11 )&lt;/title&gt; 
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
&lt;meta name="keywords" content="java.net.http.HttpClient class"&gt; </pre>
<p>The preceding code receives the HTML data as a string since it passes <kbd>BodyHandlers.ofString()</kbd> to the <kbd>send()</kbd> <span>method.</span> The variable used for the reception of this response is the <kbd>HttpResponse&lt;String&gt;</kbd> instance that matches with the response body subscriber (<kbd>BodyHandlers.ofString()</kbd>) used to process the response body bytes.</p>
<p>Let's see what happens if we store the response from the preceding request as a <kbd>.html</kbd> file. Here's the modified code:</p>
<pre>class SyncGetHTMLToFile { 
    public static void main(String args[]) throws Exception { 
        HttpClient client = HttpClient.newHttpClient(); 
        HttpRequest request = HttpRequest.newBuilder() 
        .uri(URI.create("https://docs.oracle.com/en<br/>        /java/javase/11/docs/api/java.net.http/java<br/>        /net/http/HttpClient.html")) 
              .build(); 
 
        HttpResponse&lt;Path&gt; response = 
           client.send(request, <br/>           BodyHandlers.ofFile(Paths.get("HttpClient.html"))); 
    } 
} </pre>
<p>In the preceding code, the content of <kbd>HttpClient.html</kbd> is the same as the text that is sent to the console in the previous example. In this example, the response body bytes are written to a file.</p>
<p>Since the file is saved as a <kbd>.html</kbd> file, you can view it in your web browser. However, the display of this file won't match with the display of the hosted <kbd>HttpClient</kbd> class, because your local <kbd>.html</kbd> file can't access <kbd>.css</kbd> or other hosted styles used by <kbd>HttpClient.html</kbd>.</p>
<p>The following screenshot compares the rendering of the local and hosted <kbd>HttpClient.html</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/42d3c4c3-6578-4782-b53d-493b24f16031.png"/></div>
<p>Let's modify the preceding example to receive the response asynchronously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing HTML pages using asynchronous GET</h1>
                </header>
            
            <article>
                
<p>To receive a response asynchronously, you can use the <kbd>HttpClient</kbd> <kbd>sendAsync()</kbd> method. This request will immediately return <kbd>CompletableFuture</kbd>. You can call the <kbd>get()</kbd> method on <kbd>CompletableFuture</kbd> to retrieve the response.</p>
<p class="mce-root"/>
<p>Let's modify the example used in the preceding section to receive the response (HTML text) in a file in an asynchronous manner:</p>
<pre>class AsyncGetHTMLToFile { 
    public static void main(String args[]) throws Exception { 
        HttpClient client = HttpClient.newHttpClient(); 
        HttpRequest request = HttpRequest.newBuilder() 
        .uri(URI.create("https://docs.oracle.com/en<br/>        /java/javase/11/docs/api/java.net.http/java/net<br/>        /http/HttpClient.html")) 
              .build(); 
 
        CompletableFuture&lt;Path&gt; response = 
            client.sendAsync(request, <br/>            BodyHandlers.ofFile(Paths.get("http.html"))) 
            .thenApply(HttpResponse::body); 
        response.get(); 
    } 
} </pre>
<p><kbd>BodyHandlers.ofFile()</kbd> is an implementation of the <kbd>BodyHandler</kbd> interface, which uses <kbd>BodySubscriber</kbd> (a Reactive Stream) to subscribe to the body response bytes. Upon receiving the response body, it writes it to the specified file.</p>
<div class="packt_infobox">With the HTTP <kbd>GET</kbd> request, you can also include a set of parameter names and their values as a part of the URI. For example, by defining the URI as <kbd>http://www.eJavaGuru.com/Java11.html?name="Mala"</kbd>, a client can pass the <kbd>Mala</kbd> value to the parameter name.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Downloading multiple hosted image files</h1>
                </header>
            
            <article>
                
<p>Imagine that you want to download multiple hosted images files without using an FTP client (or similar applications). Don't worry; you can do so by using the HTTP Client, either synchronously or asynchronously.</p>
<p>The code to do so is similar to what you saw in the preceding section; just save the response body bytes to a file with an appropriate file extension.</p>
<p class="mce-root"/>
<p>The following code downloads three hosted images from eJavaGuru (<a href="http://ejavaguru.com/">http://ejavaguru.com/</a>) to the same folder as your source code file:</p>
<pre>class MultipleImageDownload{ 
    public static void main(String args[]) throws Exception { 
        List&lt;URI&gt; imageURIs =  
List.of(  
URI.create("http://ejavaguru.com/images/about/jbcn-actual-2018.jpg"), 
URI.create("http://ejavaguru.com/images/about/iit-delhi.jpg"), 
URI.create("http://ejavaguru.com/images/about/techfluence.jpg")); 
 
        HttpClient client = HttpClient.newHttpClient(); 
 
        List&lt;HttpRequest&gt; imgDwnldRequests = imageURIs.stream() 
                                    .map(HttpRequest::newBuilder) 
                                    .map(builder -&gt; builder.build()) 
                                    .collect(Collectors.toList()); 
 
        CompletableFuture.allOf(imgDwnldRequests.stream() 
            .map(request -&gt; client.sendAsync(request, 
                                 BodyHandlers.ofFile( 
                                 Paths.get(((String)request.uri() 
                                        .getPath()).substring(14) 
                                     ) 
                                 ) 
                            )) 
                           .toArray(CompletableFuture&lt;?&gt;[]::new)) 
                           .join(); 
    } 
} </pre>
<p>The preceding code uses the same <kbd>HttpClient</kbd> instance, <kbd>client</kbd>, to download multiple hosted images, by sending multiple asynchronous requests to the server. The <kbd>URI</kbd> instance to the images is stored in a list of URIs: <kbd>imageURIs</kbd>. This list is then used to create multiple <kbd>HttpRequest</kbd> instances: <kbd>imgDwnldRequests</kbd>. Then, the code calls the <kbd>sendAsync()</kbd> method on the client, sending the requests asynchronously.</p>
<p>As stated in the previous example, <kbd>BodyHandlers.ofFile()</kbd> creates an implementation of <kbd>BodyHandler</kbd>, which creates and subscribes to <kbd>BodySubscriber</kbd>. <kbd>BodySubscriber</kbd> is a Reactive Stream subscriber that receives the response body from the server with non-blocking back pressure.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Posting form details</h1>
                </header>
            
            <article>
                
<p>Imagine that you want to post the details of a form to a web application or web service programmatically. You can do so by sending a <kbd>POST</kbd> request, using the HTTP Client API. The following code uses the <kbd>send()</kbd> method from <kbd>HttpClient</kbd> to post a set of parameter names and values to a server. The parameter names and their values are stored as a <kbd>String</kbd> value:</p>
<pre>public class HttpReqPost { 
    public static void main(String uri[]) throws Exception { 
        String postData = "?<br/>        name='Mala'&amp;email='info@ejavaguru<br/>        @gmail.com'"; 
        HttpClient client = HttpClient.newHttpClient(); 
        HttpRequest request = HttpRequest.newBuilder() 
       .uri(URI.create("http://www.ejavaguru.com/Java11/register.php")) 
            .POST(BodyPublishers.ofString(postData)) 
            .build(); 
 
        HttpResponse&lt;?&gt; response = client.send(request, <br/>        BodyHandlers.discarding()); 
        System.out.println(response.statusCode()); 
    } 
} </pre>
<p>In the preceding code, the <kbd>HttpRequest</kbd> builder includes the following code:</p>
<pre>.POST(BodyPublishers.ofString(postString)  </pre>
<p>The <kbd>BodyPublishers</kbd> class defines common implementations of <kbd>BodyPublisher</kbd>, which is a Reactive Stream to publish request body bytes to the server. <kbd>BodyPublishers</kbd> defines static methods as <kbd>ofString</kbd>, <kbd>ofFile</kbd>, <kbd>ofInputStream</kbd>, and <kbd>ofByteArray</kbd> to publish a request body from <kbd>String</kbd>, file, or <kbd>InputStream</kbd>, converting high-level Java types into a flow of data to be sent as a request body.</p>
<p>In this example, the <kbd>POST</kbd> data is stored in a string, <kbd>postData</kbd>, which is sent with the request to the server. In this case, I don't wish to process the received response from the server, so I use <kbd>BodyHandlers.discarding()</kbd> while accessing the response.</p>
<p>If you remember, all of the previous examples in this chapter used a Reactive Stream to receive the response body bytes from the server in a non-blocking and asynchronous manner. So, the HTTP Client enables you to send a request and receive responses to and from the server, using Reactive Streams.</p>
<p class="mce-root"/>
<div class="packt_infobox">The HTTP Client uses <kbd>BodySubscriber</kbd> and <kbd>BodyPublishers</kbd> to send and receive the response to and from the server asynchronously, in a non-blocking manner. The <kbd>BodyPublisher</kbd> interface extends the <kbd>Flow.Publisher</kbd> interface. The <kbd>BodySubcriber</kbd> <span>interface </span>extends the <kbd>Flow.Subscriber</kbd> interface.</div>
<p>When you work with the HTTP Client, you can also receive the response as a JSON, XML, or other data type. Similarly, you can also send multiple data types to a server. You can use the appropriate API from Java SE or another vendor to convert from one format to another.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Incubated in Java 9, the HTTP Client was standardized in Java 11. This chapter started with an introduction to the HTTP Client API, including the factors that led to its creation. Today's web applications and services should be responsive, supporting asynchronous, non-blocking data transfers. The HTTP Client uses Reactive Streams to achieve these goals.</p>
<p>The HTTP Client can be used to access HTTP resources across the network, using either HTTP/1.1 or HTTP/2, in both synchronous and non-synchronous manners. The HTTP Client API consists of three main classes or interfaces: the <kbd>HttpClient</kbd> <span>class, </span> the <kbd>HttpRequest</kbd> <span>class,</span> and the <kbd>HttpResponse</kbd> <span>interface.</span> The <kbd>HttpClient</kbd> class is used to send a request and retrieve the corresponding responses; <kbd>HttpRequest</kbd> encapsulates the details of the requested resource, including the request URI. The <kbd>HttpResponse</kbd> class encapsulates the response from the server.</p>
<p>Under the hood, the HTTP Client uses <kbd>BodySubscriber</kbd> and <kbd>BodyPublishers</kbd> to send and receive the response to and from the server asynchronously, in a non-blocking manner. The <kbd>BodyPublisher</kbd> <span>interface </span>extends the <kbd>Flow.Publisher</kbd> <span>interface.</span> The <kbd>BodySubcriber</kbd> <span>interface </span>extends the <kbd>Flow.Subscriber</kbd> interface. </p>
<p>The chapter included multiple examples to demonstrate common use cases.</p>
<p>A lot of interesting language additions and modifications are in progress as a part of Project Amber at the Oracle Corporation. We'll get started with exploring that in the next chapter.</p>


            </article>

            
        </section>
    </body></html>