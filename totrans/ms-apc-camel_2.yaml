- en: Chapter 2. Core Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 核心概念
- en: 'This chapter introduces the core concepts of Camel. These concepts are the
    key basis of all functionalities provided by Camel. We will use them in the next
    chapters. As we have seen in the previous chapter, Camel is an integration framework.
    This means that it provides everything to implement your mediation logic: messaging,
    routing, transformation, and connectivity.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Camel的核心概念。这些概念是Camel提供所有功能的关键基础。我们将在下一章中使用它们。正如我们在上一章中看到的，Camel是一个集成框架。这意味着它提供了实现您的中介逻辑所需的一切：消息传递、路由、转换和连接性。
- en: 'We will look at the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下概念：
- en: Messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: Exchanges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换
- en: Camel contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Camel上下文
- en: Messages
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: Messages transport the data between the different parts of the mediation logic.
    Your mediation logic will define the flow of messages between different nodes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 消息在中介逻辑的不同部分之间传输数据。您的中介逻辑将定义不同节点之间消息的流动。
- en: A message flows in one direction, from a sender to a receiver. It's not possible
    to use the same message to answer the sender, we will have to use another message.
    A message is described in the `org.apache.camel.Message` interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 消息单向流动，从发送者到接收者。不可能使用同一个消息来回答发送者，我们不得不使用另一个消息。消息由`org.apache.camel.Message`接口描述。
- en: The javadoc is available at [http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: javadoc可在[http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html)找到。
- en: 'A message contains the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个消息包含以下内容：
- en: 'ID: A message ID of type `String`. Camel creates an ID for you. This ID identifies
    the message and can be used for correlation or storage. For instance, we will
    see that the message ID is used in the idempotent consumer pattern to identify
    the message in a store.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID：一个类型为`String`的消息ID。Camel为您创建一个ID。此ID标识消息，可用于关联或存储。例如，我们将看到消息ID在幂等消费者模式中用于在存储中标识消息。
- en: 'Header: A set of headers, allowing you to store any kind of data associated
    with a message. The headers are stored as `org.apache.camel.util.CaseInsensitiveMap`
    by default. The `CaseInsensitiveMap` ([http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html))
    extends `HashMap<String,Object>`. This means you can store any kinds of objects
    (including very large objects) in the header. To access the map use a `String`
    key, which is case insensitive. The lifetime of the headers is the same as the
    message (as the headers are part of the message itself). The purpose of the headers
    is to add hints about the content encoding, authentication information, and so
    on. As we will see in the next chapters, Camel itself uses and populates the headers
    for its own needs and configurations.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题：一组标题，允许您存储与消息相关联的任何类型的数据。默认情况下，标题存储为`org.apache.camel.util.CaseInsensitiveMap`。`CaseInsensitiveMap`([http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html))扩展了`HashMap<String,Object>`。这意味着您可以在标题中存储任何类型的对象（包括非常大的对象）。要访问该映射，请使用一个`String`键，它是不区分大小写的。标题的寿命与消息相同（因为标题本身就是消息的一部分）。标题的目的是添加有关内容编码、认证信息等内容的信息。正如我们将在下一章中看到的，Camel本身会使用并填充标题以满足其自身的需求和配置。
- en: 'Attachment: A set of attachments is mostly to match the requirements of some
    protocols and components: WebService component (to provide SOAP Message Transmission
    Optimization Mechanism (MTOM) support) or the e-mail component (to provide support
    for e-mail attachments). The attachments are only used by some dedicated components,
    they are not as heavily used as the headers. The attachments are stored in the
    message as `Map<String,DataHandler>`. An attachment name is a `String`, which
    is case sensitive. An attachment is stored using `DataHandler` providing support
    of MIME type and consistent access to the data.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附件：一组附件主要用于满足某些协议和组件的需求：WebService组件（提供SOAP消息传输优化机制（MTOM）支持）或电子邮件组件（提供对电子邮件附件的支持）。附件仅由一些专用组件使用，它们不像标题那样被广泛使用。附件以`Map<String,DataHandler>`的形式存储在消息中。附件名称是一个`String`，它是区分大小写的。附件使用`DataHandler`存储，它提供对MIME类型和数据的统一访问。
- en: 'Fault flag: A fault flag Boolean that allows you to distinguish whether the
    message is a normal message or a faulted message. It allows some components or
    patterns to treat the message in a different way. For instance, instead of a SOAP
    Response, a message may contain a SOAP Fault. In that case, we have to inform
    the component that a message containing a SOAP Fault is not a normal message.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body: The body is the actual payload of the message. The body is stored as
    an `Object` in the message, allowing you to store any kind of data. In [Chapter
    1](ch01.html "Chapter 1. Key Features"), *Key Features* we saw that one of the
    Camel key features is to be payload-agnostic. The fact that the body is directly
    an `Object` is the implementation of the payload-agnostic feature.![Messages](img/3151EN_02_01.jpg)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchange
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel doesn't transport a message directly. The main reason is that a message
    flows only in one direction. When dealing with messaging, there are many Message
    Exchange Patterns (MEP) that we can use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the use cases, we can send a message without expecting any return
    from the destination: this pattern is named event message and uses InOnlyMEP.
    For instance, when you read a file from the filesystem, you just process the file
    content, without returning anything to the endpoint that read the file. In that
    case, the component responsible for reading the filesystem will define an InOnlyMEP.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you may want to implement a request reply pattern: a response
    message should be returned to the sender of the request message, and so it uses
    an InOutMEP. For instance, you receive a SOAP Request from a WebService component,
    so you should return a SOAP Response (or SOAP Fault) to the message sender.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'In Camel, MEP are described in the `org.apache.camel.ExchangePattern` enumeration
    ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html)).
    We can see that Camel supports the following MEP:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: InOnly
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InOptionalOut
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InOut
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OutIn
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OutOptionalIn
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RobustInOnly
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RobustOutOnly
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a message flows in only one direction, in order to support the different
    MEPs, we need two messages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The first message is mandatory as it's the `in` message
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second message is optional (depending on the MEP) as it's the `out` message
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s why Camel **wraps** the messages into an Exchange object: the actual
    object transported is the Exchange, acting as a messages container with all meta-data
    required for the routing logic.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: This Exchange object is used for the complete mediation process execution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The `org.apache.camel.Exchange` interface describes an exchange.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, an exchange contains the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Exchange ID: An exchange ID as a `String`. This is a unique identifier for
    the exchange. Camel creates it for you.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MEP: The Message Exchange Pattern (MEP) defines the exchange pattern.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exception: The `Exception` is used by the error handler, as we will see later.
    It stores the current cause of an exchange failure. If an error occurs at any
    time during routing, it will be set in this exception field.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常：`Exception`由错误处理器使用，正如我们稍后将要看到的。它存储交换失败的当前原因。如果在路由过程中任何时候发生错误，它将在异常字段中设置。
- en: 'Properties: The properties is a `Map<String, Object>` and may look like message
    headers. The main difference is their lifetime: the properties exist during the
    whole exchange execution, whereas the headers are limited to the message duration
    (and a message can change a lot during routing, so during the exchange execution).
    Camel itself may add some properties for some use cases.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：属性是一个`Map<String, Object>`，可能看起来像消息头。主要区别是它们的生命周期：属性在整个交换执行期间存在，而头信息仅限于消息的持续时间（并且消息在路由过程中可能会发生变化，因此在交换执行期间）。Camel本身可能为某些用例添加一些属性。
- en: Finally, we have the `in` and `out` messages.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有`in`和`out`消息。
- en: 'In Message: The `in` message is mandatory and always set. It''s the only message
    populated in the exchange with InOnlyMEP.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入消息：`in`消息是必需的，并且总是被设置。它是唯一在交换中使用InOnlyMEP填充的消息。
- en: 'Out Message: The `out` message is optional and is only used with InOutMEP.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出消息：`out`消息是可选的，并且仅与InOutMEP一起使用。
- en: With InOutMEP, at the end of the processing of the exchange, the `out` message
    will be used and returned to the mediation beginner (the first endpoint of the
    routing who created the exchange).
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用InOutMEP，在交换处理结束时，将使用并返回`out`消息到中介开始者（创建交换的路由的第一个端点）。
- en: '![Exchange](img/3151EN_02_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Exchange](img/3151EN_02_02.jpg)'
- en: Camel context
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Camel上下文
- en: The Camel context is the runtime system and the loading container of all resources
    required for the execution of the routing. It keeps everything together to allow
    the user to execute the routing logic. When the context starts, it also starts
    various components and endpoints, and activates the routing rules.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文是路由执行所需的所有资源的运行时系统和加载容器。它将所有内容组合在一起，使用户能够执行路由逻辑。当上下文启动时，它也会启动各种组件和端点，并激活路由规则。
- en: The Camel context is described by the `org.apache.camel.CamelContext` interface
    ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文由`org.apache.camel.CamelContext`接口描述 ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html))。
- en: '![Camel context](img/3151EN_02_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Camel context](img/3151EN_02_03.jpg)'
- en: 'A Camel context contains the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文包含以下内容：
- en: The components and endpoints used in the routing (see later for the details
    about components and endpoints)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由中使用的组件和端点（稍后详细介绍组件和端点）
- en: The type converters used to transform a message of one type to another
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将一种类型的消息转换为另一种类型的类型转换器
- en: The data formats used to define the format of a message body
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定义消息体格式的数据格式
- en: The registry where Camel will look for the beans used in the routing
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Camel将查找用于路由的bean的注册表
- en: The languages describing expressions and predicates used in the routing by a
    language (xpath, xquery, PHP, and so on)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述路由中使用的表达式和谓词的语言（如xpath、xquery、PHP等）
- en: The routes definition itself allowing you to design your mediation logic
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由定义本身，允许您设计您的中介逻辑
- en: Most of these resources are automatically loaded by Camel for you; most of the
    time, as an end user, you specify the routes definitions. However, we will see
    in the next chapters that we can tweak the Camel context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源中的大部分都是由Camel自动为您加载的；大多数情况下，作为最终用户，您指定路由定义。然而，我们将在下一章中看到，我们可以调整Camel上下文。
- en: A Camel context also has its own life cycle. As it's the runtime system of your
    routing, you have a control on this life cycle.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文也有自己的生命周期。作为你的路由的运行时系统，你可以控制这个生命周期。
- en: A Camel context can be started, loading all resources needed and activating
    the routing logic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文可以被启动，加载所需的所有资源并激活路由逻辑。
- en: '![Camel context](img/3151EN_02_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Camel context](img/3151EN_02_04.jpg)'
- en: 'Once started, a context can be stopped: it''s a cold stop. This means that
    all routes, components, endpoints, and other resources loaded by this context
    will be stopped, and all internal cache, metrics, and states will be lost.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，上下文可以被停止：这是一个冷启动。这意味着所有由该上下文加载的路由、组件、端点和其它资源都将停止，并且所有内部缓存、指标和状态都将丢失。
- en: 'Instead of stopped, from the started state, a context can be suspended. Suspend
    stops the routing of the messages, but keeps context resources loaded and the
    internal data (metrics, cache, states, and so on). That''s why a suspended context
    can return to the started state very quickly using resume: it just resumes the
    processing of the messages.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是停止，从启动状态，上下文可以被挂起。挂起停止消息的路由，但保持上下文资源加载和内部数据（指标、缓存、状态等）。这就是为什么挂起的上下文可以非常快速地使用恢复回到启动状态：它只是恢复了消息的处理。
- en: The end users are supposed to use only suspend and resume operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户应仅使用挂起和恢复操作。
- en: 'To restart a context, you can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要重启上下文，你可以执行以下操作：
- en: A hot restart using suspend operation first, and resume operation after. It's
    a fast restart, keeping all the internal data of the context.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先使用挂起操作进行热重启，然后进行恢复操作。这是一个快速重启，保持上下文的所有内部数据。
- en: A cold restart using the stop operation first, and the start operation later.
    In that case, all internal data (cache, states, and metrics) is lost.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用停止操作首先进行冷重启，然后进行启动操作。在这种情况下，所有内部数据（缓存、状态和指标）都会丢失。
- en: Both stop and resume operations will ensure that all inflight messages (messages
    currently in process) are completely processed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 停止和恢复操作都将确保所有正在处理的交换（当前正在处理的消息）被完全处理。
- en: Stopping or suspending a context will stop or suspend all the routing defined
    in this context. In order to guarantee a graceful and reliable shutdown of your
    routing, you can define a shutdown strategy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 停止或挂起上下文将停止或挂起在此上下文中定义的所有路由。为了确保路由的优雅和可靠关闭，你可以定义一个关闭策略。
- en: A shutdown strategy is described using the `org.apache.camel.spi.ShutdownStrategy`
    interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭策略是通过`org.apache.camel.spi.ShutdownStrategy`接口来描述的。
- en: Camel provides the `org.apache.camel.impl.DefaultShutdownStrategy` interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Camel提供了`org.apache.camel.impl.DefaultShutdownStrategy`接口。
- en: 'This default shutdown strategy works in two phases:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此默认关闭策略分为两个阶段：
- en: First, it does a graceful shutdown, by suspending or stopping all consumer (the
    first endpoint that creates the exchanges), and waiting for the completion of
    all inflight messages.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它通过挂起或停止所有消费者（第一个创建交换的端点）并等待所有未完成消息的完成来进行优雅关闭。
- en: After a timeout (5 minutes by default), if there are still some inflight messages,
    the strategy kills the exchanges, forcing a suspend or stop.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在超时（默认为5分钟）后，如果仍有未完成的交换，策略将终止交换，强制挂起或停止。
- en: We will see in the next chapters how to create and use our own shutdown strategy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到如何创建和使用自己的关闭策略。
- en: Processor
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: A processor is a node in the routing which is able to use, create, or modify
    an incoming exchange. During routing, the exchanges flow from one processor to
    another. This means all Enterprise Integration Patterns (EIP) are implemented
    using processors in Camel. The exchanges get in and out of a processor by using
    components and endpoints, as we will see later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是路由中的一个节点，能够使用、创建或修改传入的交换。在路由过程中，交换从一台处理器流向另一台处理器。这意味着所有企业集成模式（EIP）都是通过Camel中的处理器实现的。交换通过使用组件和端点进入和离开处理器，正如我们将在本章后面看到的。
- en: 'A processor is described using the `org.apache.camel.Processor` interface.
    To create your own processor, you just have to implement the `Processor` interface
    and override the `process()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是通过`org.apache.camel.Processor`接口来描述的。要创建自己的处理器，你只需实现`Processor`接口并重写`process()`方法：
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support
    ) and register to have the files e-mailed directly to you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt出版物的账户中下载示例代码文件[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Thanks to the `Exchange` argument of the `process()` method, you have complete
    access to the exchange: in and out messages, properties, and so on.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`process()`方法的`Exchange`参数，你可以完全访问交换：输入和输出消息、属性等。
- en: The `exchange.getIn()` gets the `in` message of the current exchange. As we
    want to get the body of this message, we use the `getBody()` method. This method
    accepts a type argument, casting the body in the destination class (a string in
    our example).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Camel route is the routing definition. It''s a graph of processors. The
    routes (routing definition) are loaded in the Camel context. The execution and
    flow of the exchange in a route is performed by the routing engine. The routes
    are used to decouple clients from servers, and producers from consumers: an exchange
    consumer doesn''t know where the exchange comes from, and on the other hand an
    exchange producer doesn''t know the destination of the exchange. Thanks to that,
    it provides a flexible way to add extra processing or change the routing with
    limited impact on the logic.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Each route has a unique identifier that you can specify (or Camel will create
    one for you). This identifier is used to easily find the route, especially when
    you want to log, debug, monitor, or manage a route (start or stop).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'A route has exactly one input source (the input endpoint). A route has a life
    cycle similar to the Camel context with the same states: started, stopped, and
    suspended. To Camel, a context controls the life cycle of the routes that it contains.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every Camel route, there is a channel that sits between each processor in
    the route graph. It's responsible for the routing of an Exchange to the next Processor
    in the graph. The channel acts as a controller that monitors and controls the
    routing at runtime. It allows Camel to enrich the route with interceptors. For
    instance, the Camel tracer or the error handling are functionalities implemented
    using an interceptor on the channel.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The channel is described by the `org.apache.camel.Channel` interface. You can
    configure your own interceptor on the channels by describing it in Camel context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports three kinds of interceptors on the channels:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Global interceptors: This intercepts all exchanges on the channels'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interceptors on the incoming exchanges: This has limited the scope of the interceptor
    only on the first channel (the one just after the first endpoint)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interceptors on the exchanges going to one specific endpoint: This limits the
    interceptor to the channel just before a given endpoint'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain Specific Languages (DSL)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Camel API directly would need you to write a lot of plumbing code.
    You will need to create all the objects and load a lot of objects into different
    ones.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the direct usage of API would be very time consuming. Moreover, as
    a flexible and easy-to-use integration framework, Camel doesn't have to force
    the use of one language (Java) to write the routing logic. Users may not be familiar
    with Java and might prefer to write their routing logic using another language.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why Camel provides a set of languages to directly write the routes:
    the Camel Domain Specific Languages (DSL).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Using a DSL, the user directly writes their routes and describes the Camel context
    using a DSL. Camel will load and interpret the DSL to create and instantiate all
    the objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The DSL is used to wire processors and endpoints together to define and form
    routes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a DSL, you mostly define the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The Camel context containing the routing rule base and resources
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routes definition
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Camel supports the following DSL:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Java DSL, allowing you to define the routes using a fluent Java API
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring XML, allowing you to define the routes using XML and the Spring framework
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint XML is similar to Spring XML but uses OSGi Blueprint instead of the
    Spring framework
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST DSL, allowing you to define the routes using a REST style API (in Java
    or XML)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groovy DSL, allowing you to define the routes using the Groovy language
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala DSL, allowing you to define the routes using the Scala language
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation DSL, allowing you to define the routes directly using annotations
    on Beans
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following routes are exactly the same, but written using two different DSLs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Java DSL:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using Spring or Blueprint DSL:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Component, endpoint, producer, and consumer
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components are the main extension points in Camel. We don''t directly use
    a component in a route, we define an endpoint from the component. This means a
    component acts as a factory for endpoints as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: First, you load the component in the Camel context
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, in the route definition, you define an endpoint on a component loaded
    in the Camel context
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can explicitly instantiate a component and load it in the Camel context
    (using code), or Camel will try to create and load the component (discover) for
    you based on the endpoint definition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Camel provides about 100 components (file, ftp, http, CXF, JMS, and so on) as
    you can see at [http://camel.apache.org/components.html](http://camel.apache.org/components.html).
    You can create your own component, as we will see in the next chapters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Using a component, we create the endpoints. An endpoint represents the end of
    a channel through which an external system can send or receive messages. It allows
    your Camel route to communicate with the environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Component, endpoint, producer, and consumer](img/3151EN_02_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'Depending on the location in the route, an endpoint can act as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: A producer receives a Camel Exchange, transforms it into an external message
    and communicates (sends the message) to the external system (environment)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A consumer receives a message from an external system (environment), wraps it
    as a Camel Exchange, and sends to the route
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We identify two kinds of consumers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Event Driven Consumers who will listen for incoming messages and create a Camel
    exchange at this time. For instance, consumer endpoints using the CXF component
    will **react** when they receive a SOAP Request.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling Consumers who periodically check for new resources and create a Camel
    exchange at this time. For instance, consumer endpoints using the File component
    will periodically poll the filesystem and create a Camel exchange for the new
    files.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The endpoints are described using a URI in the following format:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For instance, we can define an endpoint of the file component using the following
    code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At runtime, Camel will look up an endpoint based on the URI, check whether the
    component defined as prefix is in the Camel context (eventually load it, if it's
    not there), and use this component to actually create the endpoint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Data format
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel supports a pluggable data format allowing you to marshall and unmarshall
    the messages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you receive an XML message from an endpoint, you can:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Directly manipulate and transport the XML message in the route
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate the XML to a POJO using JAXB, for instance, JAXB is a data format
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmarshalling allows you to use a data format to convert from a raw format (XML
    in the previous example) into a Java object. On the other hand, when you send
    an exchange to an endpoint, you can marshall the transported object into another
    format. You specify where you want to unmarshall or marshall and the data format
    to use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can consume an XML message from a JMS queue, unmarshall using
    JAXB, and send the resulting object to another JMS queue:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also unmarshall files containing a serialized object, and then marshall
    using JAXB to send the resulting XML message to a JMS queue:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Camel provides a lot of ready-to-use data formats:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: For JVM native serialization marshalling, you can use the serialization or Stringdata
    formats
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For object marshalling, you can use Avro, JSON, or Protobuf data formats
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For XML data formats (marshalling and unmarshalling), you can use JAXB, XmlBeans,
    XStream, JiBX, or Castor libraries
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For XML or WebService marshalling, you can use the SOAP data format
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For XML or JSON marshalling, you can use the XmlJson data format
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For flat data structure marshalling (CSV, DelimitedLength, and so on), you can
    use BeanIO, Bindy, CSV, EDI, or Flatpack data formats
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For compression marshalling, you can use GZip or Zip data formats
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For security marshalling, you can use PGP, Crypto, or XML Sec data formats
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other marshalling, you can use Base64, RSS, TidyMarkup (with HTML, for instance),
    or Syslog data formats
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also create your own data format, providing the custom marshalling and
    unmarshalling mechanism.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Type converter
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even without a data format, when you route a message from one endpoint to another,
    it's common to convert the body of the message from one type to another. For instance,
    in an exchange created by a file endpoint, the body of the in message will be
    an InputStream. Depending on the target endpoint or processor, we may want to
    convert this InputStream to a String.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `getBody()` method on a message, you can specify the expected
    type. Camel will use a type converter to try to convert the actual body of the
    message into the specified type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在消息上使用 `getBody()` 方法时，您可以指定期望的类型。Camel 将使用类型转换器尝试将消息的实际体转换为指定的类型。
- en: 'For instance, in a processor, if you do the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个处理器中，如果您执行以下操作：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Camel will try to convert the body of the in message into a DOM document. A
    type converter is defined by the `org.apache.camel.TypeConverter` interface. The
    type converters are loaded into the Camel context, in a type converter's registry.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 将尝试将输入消息的体转换为 DOM 文档。类型转换器由 `org.apache.camel.TypeConverter` 接口定义。类型转换器被加载到
    Camel 上下文中，在类型转换器注册表中。
- en: 'The type converter''s registry contains the type converter with the supported
    types. In this registry, for each type converter, we have:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器注册表包含支持类型的类型转换器。在这个注册表中，对于每个类型转换器，我们都有：
- en: The **source** type
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**类型'
- en: The **destination** type
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**类型'
- en: The actual type converter instance
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际类型转换器实例
- en: 'For instance, we can add our own type converter in the Camel context as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 Camel 上下文中添加自己的类型转换器，如下所示：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the source type is `MyOrder`, the destination type is `String`,
    and to convert from a type `MyOrder` to `String`, I will use the `MyOrderTypeConverter()`
    method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到源类型是 `MyOrder`，目标类型是 `String`，要将类型 `MyOrder` 转换为 `String`，我将使用 `MyOrderTypeConverter()`
    方法。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We can see that even if the Camel core is light, the provided features are rich
    and it provides all the basics to extend Camel to match your needs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使 Camel 核心很轻，提供的功能却很丰富，它提供了所有基本功能以扩展 Camel 来满足您的需求。
- en: This chapter is an introduction to the Camel core concepts. It allows you to
    easily understand the next chapters, where we will get into the details of Camel.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这章是 Camel 核心概念的介绍。它使您能够轻松理解下一章，我们将深入探讨 Camel 的细节。
