- en: Chapter 2. Core Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces the core concepts of Camel. These concepts are the
    key basis of all functionalities provided by Camel. We will use them in the next
    chapters. As we have seen in the previous chapter, Camel is an integration framework.
    This means that it provides everything to implement your mediation logic: messaging,
    routing, transformation, and connectivity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messages transport the data between the different parts of the mediation logic.
    Your mediation logic will define the flow of messages between different nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A message flows in one direction, from a sender to a receiver. It's not possible
    to use the same message to answer the sender, we will have to use another message.
    A message is described in the `org.apache.camel.Message` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The javadoc is available at [http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'A message contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ID: A message ID of type `String`. Camel creates an ID for you. This ID identifies
    the message and can be used for correlation or storage. For instance, we will
    see that the message ID is used in the idempotent consumer pattern to identify
    the message in a store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Header: A set of headers, allowing you to store any kind of data associated
    with a message. The headers are stored as `org.apache.camel.util.CaseInsensitiveMap`
    by default. The `CaseInsensitiveMap` ([http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html))
    extends `HashMap<String,Object>`. This means you can store any kinds of objects
    (including very large objects) in the header. To access the map use a `String`
    key, which is case insensitive. The lifetime of the headers is the same as the
    message (as the headers are part of the message itself). The purpose of the headers
    is to add hints about the content encoding, authentication information, and so
    on. As we will see in the next chapters, Camel itself uses and populates the headers
    for its own needs and configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attachment: A set of attachments is mostly to match the requirements of some
    protocols and components: WebService component (to provide SOAP Message Transmission
    Optimization Mechanism (MTOM) support) or the e-mail component (to provide support
    for e-mail attachments). The attachments are only used by some dedicated components,
    they are not as heavily used as the headers. The attachments are stored in the
    message as `Map<String,DataHandler>`. An attachment name is a `String`, which
    is case sensitive. An attachment is stored using `DataHandler` providing support
    of MIME type and consistent access to the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fault flag: A fault flag Boolean that allows you to distinguish whether the
    message is a normal message or a faulted message. It allows some components or
    patterns to treat the message in a different way. For instance, instead of a SOAP
    Response, a message may contain a SOAP Fault. In that case, we have to inform
    the component that a message containing a SOAP Fault is not a normal message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body: The body is the actual payload of the message. The body is stored as
    an `Object` in the message, allowing you to store any kind of data. In [Chapter
    1](ch01.html "Chapter 1. Key Features"), *Key Features* we saw that one of the
    Camel key features is to be payload-agnostic. The fact that the body is directly
    an `Object` is the implementation of the payload-agnostic feature.![Messages](img/3151EN_02_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel doesn't transport a message directly. The main reason is that a message
    flows only in one direction. When dealing with messaging, there are many Message
    Exchange Patterns (MEP) that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the use cases, we can send a message without expecting any return
    from the destination: this pattern is named event message and uses InOnlyMEP.
    For instance, when you read a file from the filesystem, you just process the file
    content, without returning anything to the endpoint that read the file. In that
    case, the component responsible for reading the filesystem will define an InOnlyMEP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you may want to implement a request reply pattern: a response
    message should be returned to the sender of the request message, and so it uses
    an InOutMEP. For instance, you receive a SOAP Request from a WebService component,
    so you should return a SOAP Response (or SOAP Fault) to the message sender.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Camel, MEP are described in the `org.apache.camel.ExchangePattern` enumeration
    ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html)).
    We can see that Camel supports the following MEP:'
  prefs: []
  type: TYPE_NORMAL
- en: InOnly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InOptionalOut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InOut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OutIn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OutOptionalIn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RobustInOnly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RobustOutOnly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a message flows in only one direction, in order to support the different
    MEPs, we need two messages:'
  prefs: []
  type: TYPE_NORMAL
- en: The first message is mandatory as it's the `in` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second message is optional (depending on the MEP) as it's the `out` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s why Camel **wraps** the messages into an Exchange object: the actual
    object transported is the Exchange, acting as a messages container with all meta-data
    required for the routing logic.'
  prefs: []
  type: TYPE_NORMAL
- en: This Exchange object is used for the complete mediation process execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `org.apache.camel.Exchange` interface describes an exchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, an exchange contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exchange ID: An exchange ID as a `String`. This is a unique identifier for
    the exchange. Camel creates it for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MEP: The Message Exchange Pattern (MEP) defines the exchange pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exception: The `Exception` is used by the error handler, as we will see later.
    It stores the current cause of an exchange failure. If an error occurs at any
    time during routing, it will be set in this exception field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properties: The properties is a `Map<String, Object>` and may look like message
    headers. The main difference is their lifetime: the properties exist during the
    whole exchange execution, whereas the headers are limited to the message duration
    (and a message can change a lot during routing, so during the exchange execution).
    Camel itself may add some properties for some use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have the `in` and `out` messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Message: The `in` message is mandatory and always set. It''s the only message
    populated in the exchange with InOnlyMEP.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Out Message: The `out` message is optional and is only used with InOutMEP.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With InOutMEP, at the end of the processing of the exchange, the `out` message
    will be used and returned to the mediation beginner (the first endpoint of the
    routing who created the exchange).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Exchange](img/3151EN_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Camel context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Camel context is the runtime system and the loading container of all resources
    required for the execution of the routing. It keeps everything together to allow
    the user to execute the routing logic. When the context starts, it also starts
    various components and endpoints, and activates the routing rules.
  prefs: []
  type: TYPE_NORMAL
- en: The Camel context is described by the `org.apache.camel.CamelContext` interface
    ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Camel context](img/3151EN_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A Camel context contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The components and endpoints used in the routing (see later for the details
    about components and endpoints)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type converters used to transform a message of one type to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data formats used to define the format of a message body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The registry where Camel will look for the beans used in the routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The languages describing expressions and predicates used in the routing by a
    language (xpath, xquery, PHP, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routes definition itself allowing you to design your mediation logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these resources are automatically loaded by Camel for you; most of the
    time, as an end user, you specify the routes definitions. However, we will see
    in the next chapters that we can tweak the Camel context.
  prefs: []
  type: TYPE_NORMAL
- en: A Camel context also has its own life cycle. As it's the runtime system of your
    routing, you have a control on this life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: A Camel context can be started, loading all resources needed and activating
    the routing logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Camel context](img/3151EN_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once started, a context can be stopped: it''s a cold stop. This means that
    all routes, components, endpoints, and other resources loaded by this context
    will be stopped, and all internal cache, metrics, and states will be lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of stopped, from the started state, a context can be suspended. Suspend
    stops the routing of the messages, but keeps context resources loaded and the
    internal data (metrics, cache, states, and so on). That''s why a suspended context
    can return to the started state very quickly using resume: it just resumes the
    processing of the messages.'
  prefs: []
  type: TYPE_NORMAL
- en: The end users are supposed to use only suspend and resume operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To restart a context, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A hot restart using suspend operation first, and resume operation after. It's
    a fast restart, keeping all the internal data of the context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cold restart using the stop operation first, and the start operation later.
    In that case, all internal data (cache, states, and metrics) is lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both stop and resume operations will ensure that all inflight messages (messages
    currently in process) are completely processed.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping or suspending a context will stop or suspend all the routing defined
    in this context. In order to guarantee a graceful and reliable shutdown of your
    routing, you can define a shutdown strategy.
  prefs: []
  type: TYPE_NORMAL
- en: A shutdown strategy is described using the `org.apache.camel.spi.ShutdownStrategy`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Camel provides the `org.apache.camel.impl.DefaultShutdownStrategy` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This default shutdown strategy works in two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it does a graceful shutdown, by suspending or stopping all consumer (the
    first endpoint that creates the exchanges), and waiting for the completion of
    all inflight messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a timeout (5 minutes by default), if there are still some inflight messages,
    the strategy kills the exchanges, forcing a suspend or stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will see in the next chapters how to create and use our own shutdown strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A processor is a node in the routing which is able to use, create, or modify
    an incoming exchange. During routing, the exchanges flow from one processor to
    another. This means all Enterprise Integration Patterns (EIP) are implemented
    using processors in Camel. The exchanges get in and out of a processor by using
    components and endpoints, as we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A processor is described using the `org.apache.camel.Processor` interface.
    To create your own processor, you just have to implement the `Processor` interface
    and override the `process()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support
    ) and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the `Exchange` argument of the `process()` method, you have complete
    access to the exchange: in and out messages, properties, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The `exchange.getIn()` gets the `in` message of the current exchange. As we
    want to get the body of this message, we use the `getBody()` method. This method
    accepts a type argument, casting the body in the destination class (a string in
    our example).
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Camel route is the routing definition. It''s a graph of processors. The
    routes (routing definition) are loaded in the Camel context. The execution and
    flow of the exchange in a route is performed by the routing engine. The routes
    are used to decouple clients from servers, and producers from consumers: an exchange
    consumer doesn''t know where the exchange comes from, and on the other hand an
    exchange producer doesn''t know the destination of the exchange. Thanks to that,
    it provides a flexible way to add extra processing or change the routing with
    limited impact on the logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Each route has a unique identifier that you can specify (or Camel will create
    one for you). This identifier is used to easily find the route, especially when
    you want to log, debug, monitor, or manage a route (start or stop).
  prefs: []
  type: TYPE_NORMAL
- en: 'A route has exactly one input source (the input endpoint). A route has a life
    cycle similar to the Camel context with the same states: started, stopped, and
    suspended. To Camel, a context controls the life cycle of the routes that it contains.'
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every Camel route, there is a channel that sits between each processor in
    the route graph. It's responsible for the routing of an Exchange to the next Processor
    in the graph. The channel acts as a controller that monitors and controls the
    routing at runtime. It allows Camel to enrich the route with interceptors. For
    instance, the Camel tracer or the error handling are functionalities implemented
    using an interceptor on the channel.
  prefs: []
  type: TYPE_NORMAL
- en: The channel is described by the `org.apache.camel.Channel` interface. You can
    configure your own interceptor on the channels by describing it in Camel context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports three kinds of interceptors on the channels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Global interceptors: This intercepts all exchanges on the channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interceptors on the incoming exchanges: This has limited the scope of the interceptor
    only on the first channel (the one just after the first endpoint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interceptors on the exchanges going to one specific endpoint: This limits the
    interceptor to the channel just before a given endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain Specific Languages (DSL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Camel API directly would need you to write a lot of plumbing code.
    You will need to create all the objects and load a lot of objects into different
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the direct usage of API would be very time consuming. Moreover, as
    a flexible and easy-to-use integration framework, Camel doesn't have to force
    the use of one language (Java) to write the routing logic. Users may not be familiar
    with Java and might prefer to write their routing logic using another language.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why Camel provides a set of languages to directly write the routes:
    the Camel Domain Specific Languages (DSL).'
  prefs: []
  type: TYPE_NORMAL
- en: Using a DSL, the user directly writes their routes and describes the Camel context
    using a DSL. Camel will load and interpret the DSL to create and instantiate all
    the objects.
  prefs: []
  type: TYPE_NORMAL
- en: The DSL is used to wire processors and endpoints together to define and form
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a DSL, you mostly define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Camel context containing the routing rule base and resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routes definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Camel supports the following DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: Java DSL, allowing you to define the routes using a fluent Java API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring XML, allowing you to define the routes using XML and the Spring framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint XML is similar to Spring XML but uses OSGi Blueprint instead of the
    Spring framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST DSL, allowing you to define the routes using a REST style API (in Java
    or XML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groovy DSL, allowing you to define the routes using the Groovy language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala DSL, allowing you to define the routes using the Scala language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation DSL, allowing you to define the routes directly using annotations
    on Beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following routes are exactly the same, but written using two different DSLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Java DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Spring or Blueprint DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Component, endpoint, producer, and consumer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components are the main extension points in Camel. We don''t directly use
    a component in a route, we define an endpoint from the component. This means a
    component acts as a factory for endpoints as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you load the component in the Camel context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, in the route definition, you define an endpoint on a component loaded
    in the Camel context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can explicitly instantiate a component and load it in the Camel context
    (using code), or Camel will try to create and load the component (discover) for
    you based on the endpoint definition.
  prefs: []
  type: TYPE_NORMAL
- en: Camel provides about 100 components (file, ftp, http, CXF, JMS, and so on) as
    you can see at [http://camel.apache.org/components.html](http://camel.apache.org/components.html).
    You can create your own component, as we will see in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using a component, we create the endpoints. An endpoint represents the end of
    a channel through which an external system can send or receive messages. It allows
    your Camel route to communicate with the environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Component, endpoint, producer, and consumer](img/3151EN_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Depending on the location in the route, an endpoint can act as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A producer receives a Camel Exchange, transforms it into an external message
    and communicates (sends the message) to the external system (environment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A consumer receives a message from an external system (environment), wraps it
    as a Camel Exchange, and sends to the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We identify two kinds of consumers:'
  prefs: []
  type: TYPE_NORMAL
- en: Event Driven Consumers who will listen for incoming messages and create a Camel
    exchange at this time. For instance, consumer endpoints using the CXF component
    will **react** when they receive a SOAP Request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling Consumers who periodically check for new resources and create a Camel
    exchange at this time. For instance, consumer endpoints using the File component
    will periodically poll the filesystem and create a Camel exchange for the new
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The endpoints are described using a URI in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, we can define an endpoint of the file component using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At runtime, Camel will look up an endpoint based on the URI, check whether the
    component defined as prefix is in the Camel context (eventually load it, if it's
    not there), and use this component to actually create the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Data format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel supports a pluggable data format allowing you to marshall and unmarshall
    the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you receive an XML message from an endpoint, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly manipulate and transport the XML message in the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate the XML to a POJO using JAXB, for instance, JAXB is a data format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmarshalling allows you to use a data format to convert from a raw format (XML
    in the previous example) into a Java object. On the other hand, when you send
    an exchange to an endpoint, you can marshall the transported object into another
    format. You specify where you want to unmarshall or marshall and the data format
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can consume an XML message from a JMS queue, unmarshall using
    JAXB, and send the resulting object to another JMS queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also unmarshall files containing a serialized object, and then marshall
    using JAXB to send the resulting XML message to a JMS queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Camel provides a lot of ready-to-use data formats:'
  prefs: []
  type: TYPE_NORMAL
- en: For JVM native serialization marshalling, you can use the serialization or Stringdata
    formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For object marshalling, you can use Avro, JSON, or Protobuf data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For XML data formats (marshalling and unmarshalling), you can use JAXB, XmlBeans,
    XStream, JiBX, or Castor libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For XML or WebService marshalling, you can use the SOAP data format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For XML or JSON marshalling, you can use the XmlJson data format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For flat data structure marshalling (CSV, DelimitedLength, and so on), you can
    use BeanIO, Bindy, CSV, EDI, or Flatpack data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For compression marshalling, you can use GZip or Zip data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For security marshalling, you can use PGP, Crypto, or XML Sec data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other marshalling, you can use Base64, RSS, TidyMarkup (with HTML, for instance),
    or Syslog data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also create your own data format, providing the custom marshalling and
    unmarshalling mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Type converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even without a data format, when you route a message from one endpoint to another,
    it's common to convert the body of the message from one type to another. For instance,
    in an exchange created by a file endpoint, the body of the in message will be
    an InputStream. Depending on the target endpoint or processor, we may want to
    convert this InputStream to a String.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `getBody()` method on a message, you can specify the expected
    type. Camel will use a type converter to try to convert the actual body of the
    message into the specified type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in a processor, if you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Camel will try to convert the body of the in message into a DOM document. A
    type converter is defined by the `org.apache.camel.TypeConverter` interface. The
    type converters are loaded into the Camel context, in a type converter's registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type converter''s registry contains the type converter with the supported
    types. In this registry, for each type converter, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: The **source** type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **destination** type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual type converter instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, we can add our own type converter in the Camel context as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the source type is `MyOrder`, the destination type is `String`,
    and to convert from a type `MyOrder` to `String`, I will use the `MyOrderTypeConverter()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see that even if the Camel core is light, the provided features are rich
    and it provides all the basics to extend Camel to match your needs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is an introduction to the Camel core concepts. It allows you to
    easily understand the next chapters, where we will get into the details of Camel.
  prefs: []
  type: TYPE_NORMAL
