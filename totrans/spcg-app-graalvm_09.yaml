- en: '*Chapter 6*: Truffle – An Overview'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：Truffle – 概述'
- en: Support for polyglot development is one of the biggest features of GraalVM.
    In [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077), *Graal Just-In-Time
    Compiler*, and [*Chapter 5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097),
    *Graal Ahead-of-Time Compiler and Native Image*, we went into a lot of detail
    on how Graal optimizes code, both at build time and run time. We have only used
    Java in all the previous chapters. However, GraalVM extends most of its advanced
    features to other programming languages too. GraalVM provides a language implementation
    framework called **Truffle Language Implementation Framework** (commonly known
    as **Truffle**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言开发支持是GraalVM最大的特性之一。在[*第4章*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077)
    *Graal即时编译器*和[*第5章*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097) *Graal预编译器及原生图像*中，我们详细介绍了Graal如何在构建时间和运行时优化代码。在前面的所有章节中，我们只使用了Java。然而，GraalVM将其大多数高级特性扩展到了其他编程语言。GraalVM提供了一个名为**Truffle语言实现框架**（通常称为**Truffle**）的语言实现框架。
- en: GraalVM not only provides a high-performance runtime for JVM languages such
    as Java, Groovy, Kotlin, and Scala, but it also supports non-JVM languages such
    as JavaScript, Ruby, Python, R, WebAssembly, and LLVM languages that implement
    Truffle. A lot more languages are being implemented on Truffle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM不仅为Java、Groovy、Kotlin和Scala等JVM语言提供高性能运行时，还支持JavaScript、Ruby、Python、R、WebAssembly以及实现Truffle的LLVM语言等非JVM语言。还有更多语言正在Truffle上实现。
- en: This chapter provides a conceptual view of how Truffle helps guest language
    developers and provides a well-designed, high-performance framework to build applications
    using guest languages on top of GraalVM. This chapter does not get into too much
    detail on how to write in guest languages using Truffle. This is only intended
    to describe Truffle's architecture and concepts at a high level so that you can
    follow the subsequent chapters on how non-JVM languages are implemented on GraalVM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从概念上阐述了Truffle如何帮助客户端语言开发者，并提供了一个精心设计、高性能的框架，用于在GraalVM上使用客户端语言构建应用程序。本章不会过多涉及如何使用Truffle在客户端语言中编写代码。这只是为了描述Truffle的架构和概念，以便您能够理解后续章节中如何在GraalVM上实现非JVM语言。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Exploring the Truffle language implementation framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Truffle语言实现框架
- en: Exploring the Truffle interpreter/compiler pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Truffle解释器/编译器管道
- en: Learning Truffle DSL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Truffle DSL
- en: Understanding how Truffle supports interoperability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Truffle如何支持互操作性
- en: Understanding Truffle instrumentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Truffle仪表
- en: Ahead-of-time compilation using Truffle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Truffle进行即时编译
- en: Optimizing Truffle interpreter performance with launcher options
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用启动器选项优化Truffle解释器性能
- en: SimpleLanguage and Simple Tool
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SimpleLanguage和Simple Tool
- en: By the end of this chapter, you will have a good understanding of Truffle's
    architecture, and how Truffle provides a framework for other programming languages
    to run on GraalVM.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将很好地理解Truffle的架构以及Truffle如何为其他编程语言提供在GraalVM上运行的框架。
- en: Exploring the Truffle language implementation framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Truffle语言实现框架
- en: In [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    in the Truffle section, we briefly covered the architecture of Truffle. Truffle
    is an open source library that provides a framework to implement language interpreters.
    Truffle helps run guest programming languages that implement the framework to
    utilize the Graal compiler features to generate high-performance code. Truffle
    also provides a reference implementation called SimpleLanguage to guide developers
    to write interpreters for their languages. Truffle also provides a tools framework
    that helps integrate and utilize some of the modern diagnostic, debugging, and
    analysis tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054)中，*GraalVM架构*部分，我们简要介绍了Truffle的架构。Truffle是一个开源库，提供了一个框架来实现语言解释器。Truffle帮助运行实现该框架的客户端编程语言，以利用Graal编译器的功能生成高性能代码。Truffle还提供了一个名为SimpleLanguage的参考实现，以指导开发者为其语言编写解释器。Truffle还提供了一个工具框架，有助于集成和利用一些现代的诊断、调试和分析工具。
- en: Let's understand how Truffle fits into the overall GraalVM ecosystem. Along
    with interoperability between the languages, Truffle also provides embeddability.
    Interoperability allows the calling of code between different languages, while
    embeddability allows the embedding of code written in different languages in the
    same program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 Truffle 如何融入 GraalVM 整体生态系统。除了语言之间的互操作性外，Truffle 还提供了可嵌入性。互操作性允许在不同语言之间调用代码，而可嵌入性允许将不同语言编写的代码嵌入到同一程序中。
- en: 'Language interoperability is critical for the following reasons:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 语言互操作性对于以下原因至关重要：
- en: Different programming languages are built to solve different problems, and they
    come with their own strengths. For example, we use Python and R extensively for
    machine learning and data analytics, and we use C/C+ for high-performance mathematical
    operations. Imagine if we would reuse the code as it is, either by calling the
    code from a host language (such as Java) or embedding that code within the host
    language. This also increases the reusability of the code and allows us to use
    an appropriate language for the task at hand, rather than rewriting the logic
    in different languages.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的编程语言是为了解决不同的问题而构建的，它们各自具有自己的优势。例如，我们广泛使用 Python 和 R 进行机器学习和数据分析，而使用 C/C+
    进行高性能数学运算。想象一下，如果我们直接重用代码，无论是通过从宿主语言（如 Java）调用代码，还是将代码嵌入到宿主语言中，这将增加代码的可重用性，并允许我们使用适合当前任务的适当语言，而不是在不同语言中重写逻辑。
- en: Large migration projects where we are moving from one language to another can
    be phased out if we have the feature of multiple programming language interoperability.
    This brings down the risk of migration considerably.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们拥有多编程语言互操作性的功能，那么在从一种语言迁移到另一种语言的重大迁移项目中，我们可以分阶段进行。这大大降低了迁移的风险。
- en: 'The following figure illustrates how to run applications written in other languages
    on GraalVM:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了如何在 GraalVM 上运行用其他语言编写的应用程序：
- en: '![Figure 6.1 – Truffle stack'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – Truffle 堆栈'
- en: '](img/B16878_Figure_6.1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_6.1.jpg)'
- en: Figure 6.1 – Truffle stack
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Truffle 堆栈
- en: 'In the figure, we can see GraalVM, which is the JVM and Graal JIT compiler
    that we covered in the previous chapters. On top of that, we have the Truffle
    framework. Truffle has two major components. They are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们可以看到 GraalVM，这是我们在前几章中介绍过的 JVM 和 Graal JIT 编译器。在其之上，我们有 Truffle 框架。Truffle
    有两个主要组件。它们如下：
- en: '**Truffle API**: The Truffle API is the language implementation framework that
    any guest language programmers can use to implement the Truffle interpreter for
    their respective languages. Truffle provides a sophisticated API for **Abstract
    Syntax Tree** (**AST**) rewriting. The guest language is converted to AST for
    optimizing and running on GraalVM. The Truffle API also helps in providing an
    interoperability framework between languages that implement the Truffle API.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Truffle API**：Truffle API 是任何客语言程序员都可以使用的语言实现框架，用于为各自的语言实现 Truffle 解释器。Truffle
    提供了一个复杂的 API 用于**抽象语法树**（**AST**）重写。客语言被转换为 AST 以在 GraalVM 上进行优化和运行。Truffle API
    还有助于提供实现 Truffle API 的语言之间的互操作性框架。'
- en: '**Truffle optimizer**: The Truffle optimizer provides an additional layer of
    optimization for speculative optimization with partial evaluation. We will be
    going through this in more detail in the subsequent sections.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Truffle 优化器**：Truffle 优化器为部分评估的投机优化提供了一个额外的优化层。我们将在后续章节中更详细地介绍这一点。'
- en: 'Above the Truffle layer, we have the guest language. This is JavaScript, R,
    Ruby, and others that implement the Truffle Language Implementation framework.
    Finally, we have the application that runs on top of the guest language runtime.
    In most cases, application developers don''t have to worry about changing the
    code to run on GraalVM. Truffle makes it seamless by providing a layer in between.
    The following diagram shows a detailed stack view of the GraalVM and Truffle ecosystem:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Truffle 层之上，我们有客语言。这是 JavaScript、R、Ruby 等实现 Truffle 语言实现框架的语言。最后，我们有在客语言运行时之上运行的应用程序。在大多数情况下，应用程序开发者不必担心更改代码以在
    GraalVM 上运行。Truffle 通过提供中间层使其无缝。以下图显示了 GraalVM 和 Truffle 生态系统的详细堆栈视图：
- en: '![Figure 6.2 – Truffle and Graal detailed stack view'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – Truffle 和 Graal 详细堆栈视图'
- en: '](img/B16878_Figure_6.2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_6.2.jpg)'
- en: Figure 6.2 – Truffle and Graal detailed stack view
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Truffle 和 Graal 详细堆栈视图
- en: This diagram is a simple representation of how Truffle acts as a layer between
    non-JVM languages and GraalVM. Let's understand this in detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此图简单地展示了Truffle如何在非JVM语言和GraalVM之间充当一层。让我们详细了解这一点。
- en: Truffle provides the API that the individual interpreters implement to rewrite
    the code into ASTs. The AST representation is later converted to a Graal intermediate
    representation for Graal to execute and also optimize just in time. The guest
    languages run on top of the Truffle interpreter implementations of the respective
    guest languages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle提供API，供各个解释器实现，将代码重写为AST。AST表示随后被转换为Graal中间表示，以便Graal执行和即时优化。客语言在各自的Truffle解释器实现之上运行。
- en: Let's look at how these various layers interact and how Truffle helps the guest
    language to run on GraalVM.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些不同层如何交互，以及Truffle如何帮助客语言在GraalVM上运行。
- en: Exploring the Truffle interpreter/compiler pipeline
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Truffle解释器/编译器管道
- en: 'Truffle provides a Java library that can be used to write AST interpreters
    in Java for any language. The guest language semantics are expressed as an AST
    using the AST interpreters. Graal and Truffle specify the exact format of AST,
    and the framework enforces this specification. So, any guest language AST interpreter
    written using Truffle Language Implementation API will generate the semantics
    of the language in AST that GraalVM can then use to optimize just in time and
    run. The following figure provides a detailed flow of how Truffle and Graal work:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle提供API，供各个解释器实现，将代码重写为AST。AST表示随后被转换为Graal中间表示，以便Graal执行和即时优化。客语言在各自的Truffle解释器实现之上运行。
- en: '![Figure 6.3 – Truffle and Graal compilation pipeline'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – Truffle和Graal编译管道'
- en: '](img/B16878_Figure_6.3.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – Truffle和Graal编译管道'
- en: Figure 6.3 – Truffle and Graal compilation pipeline
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – Truffle和Graal编译管道
- en: Let's understand the flow diagram better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地理解流程图。
- en: 'The guest languages are parsed using a traditional syntactical and lexical
    analyzer. This generates an AST. The AST is an intermediate representation built
    as per the Truffle/Graal specifications. The AST is a tree structure where each
    parent node is an operation/function, and the child nodes are data/operands/dependencies.
    Each node that is part of the AST has an `execute()` method. The `execute()` method
    implements the semantics of the corresponding language construct. The guest language
    developers are supposed to design these nodes and provide facilities to parse
    the guest language code and build the tree. The following code snippet shows the
    abstract node object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 客语言使用传统的语法和词法分析器进行解析。这生成了一个AST。AST是根据Truffle/Graal规范构建的中间表示。AST是一个树结构，其中每个父节点是一个操作/函数，子节点是数据/操作数/依赖项。AST中的每个节点都有一个`execute()`方法。`execute()`方法实现了相应语言结构的语义。客语言开发者应该设计这些节点，并提供解析客语言代码和构建树的功能。以下代码片段显示了抽象节点对象：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the node types implement this abstract node. AST interpreters go through
    the AST node by node to execute using a stack frame to keep track of the execution
    and data. AST interpreters are easy to implement but have huge performance overheads.
    Let's now look at how Truffle interpreters optimize the AST by rewriting the tree.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点类型都实现了这个抽象节点。AST解释器逐个遍历AST节点以执行，使用栈帧来跟踪执行和数据。AST解释器易于实现，但具有巨大的性能开销。现在让我们看看Truffle解释器如何通过重写树来优化AST。
- en: Self-optimization and tree rewriting
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自优化和树重写
- en: The structure of the AST can be dynamically changed by rewriting. This is also
    sometimes referred to as AST rewriting. The AST interpreter can rewrite the AST
    dynamically based on the runtime profiling. This improves the performance significantly.
    The nodes can be updated at runtime by rewriting based on the runtime profiling
    and optimizing the AST.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地理解流程图。
- en: One of the biggest issues with dynamic languages, from a performance perspective,
    is the type declarations (unlike languages such as C, where the type is specified
    in the code). The types are not declared at coding time, which means the variables,
    at the start of the execution, may assume any type. The profiler can figure out
    the specific type after a few runs and can then specialize the type of the variables
    based on the runtime profiling. It then rewrites the AST with the specific type.
    This technique is called **Type Specialization**. This has a significant performance
    boost, as the operations/methods that are performed on this data can be specialized
    to the data type. The Truffle interpreter leaves a speculation *guard* in case
    the speculation/assumption made on the type is proven wrong in future executions.
    In this case, the guard is invoked to deoptimize the AST.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，动态语言最大的问题之一是类型声明（与C语言等语言不同，在代码中指定了类型）。类型不是在编码时声明的，这意味着在执行开始时，变量可能具有任何类型。分析器可以在几次运行后确定特定类型，然后可以根据运行时分析专门化变量的类型。然后它使用特定类型重写AST。这种技术称为**类型特殊化**。这具有显著的性能提升，因为在此数据上执行的操作/方法可以专门针对数据类型。Truffle解释器在假设的类型在未来的执行中被证明是错误的情况下留下一个推测*守卫*。在这种情况下，守卫被调用以去优化AST。
- en: 'Tree rewriting also happens when an operation/function has to be resolved at
    runtime. This is very important for the dynamic resolution of function or operations,
    due to polymorphic implementations of the operations or functions. When the profiler
    identifies a specific implementation of the function/operation, the resolved function/operation
    can be rewritten. A simple diagram that illustrates operation resolution follows
    this paragraph. The `Node` class has the `replace()` method, which is used for
    rewriting. The following figure illustrates a very simple expression, and shows
    how the AST gets rewritten after profiling:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作/函数需要在运行时解析时，也会发生树重写。这对于函数或操作的动态解析非常重要，因为操作或函数有多态实现。当分析器确定函数/操作的具体实现时，解析的函数/操作可以被重写。一个简单的图示说明操作解析紧随此段之后。`Node`类有`replace()`方法，用于重写。以下图示了一个非常简单的表达式，并显示了在分析后AST是如何被重写的：
- en: '![Figure 6.4 – AST specialization illustration'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – AST特殊化说明'
- en: '](img/B16878_Figure_6.4.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_6.4.jpg)'
- en: Figure 6.4 – AST specialization illustration
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – AST特殊化说明
- en: On the left side of the figure, the Truffle interpreter starts off as a generic
    AST node. Based on the profiler, the interpreter understands that it's mostly
    a specific type value, let's say an integer. It will rewrite the nodes with integer
    types and the operation nodes with integer operations. This optimizes the execution
    of the AST. In the left-most representation, + might mean the concatenation of
    strings or the addition of integers or longs or floats, or any other polymorphic
    execution of the operation that is reduced to the right-most representation, where
    it is very clearly an integer. A guard check is placed there in case the assumption
    made is proven wrong in the future. If the operands happen to be floats, or some
    other type, then a deoptimization is invoked, which might take it back to the
    left-most representation. The Truffle interpreter will once again profile to identify
    the right type specializations to apply. It may identify that it is more of a
    long or double, so it might rewrite the AST as a double and optimize. Type specialization
    is applied to local variables, return types, operations, and fields.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在图象的左侧，Truffle解释器从通用的AST节点开始。根据分析器，解释器理解它主要是一个特定类型的值，比如说一个整数。它将重写具有整数类型的节点和具有整数操作的运算节点。这优化了AST的执行。在最左侧的表示中，+可能意味着字符串的连接、整数、长整数或浮点数的加法，或者任何其他将运算减少到最右侧表示的多态执行，在那里它非常明显是一个整数。如果假设在未来被证明是错误的，则在那里放置一个守卫检查。如果操作数恰好是浮点数或某种其他类型，则将调用去优化，这可能会将其带回到最左侧的表示。Truffle解释器将再次分析以确定要应用的正确类型特殊化。它可能确定它更像是长整数或双精度浮点数，因此它可能将AST重写为双精度浮点数并优化。类型特殊化应用于局部变量、返回类型、操作和字段。
- en: AST rewriting based on type specialization provides a significant boost to performance,
    and by the time we get to more advanced optimizations that the Graal performs,
    we have a very stable AST.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类型特殊化的AST重写为性能提供了显著的提升，当我们达到Graal执行的更高级优化时，我们有一个非常稳定的AST。
- en: Since the AST interpreters are implemented in Java, the node `execute()` method
    is written to handle a generic object. Type specialization also helps by replacing
    the `execute()` method with a specialized `executeInt()` method, and also reduces
    the load on the CPU for boxing and unboxing by replacing the wrapper implementations
    (`Integer`, `Double`, and so on) with primitive types (`int`, `double`). This
    technique is sometimes referred to as *boxing elimination*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AST 解释器是用 Java 实现的，因此 `execute()` 节点方法被编写来处理通用对象。类型专业化还有助于通过用专门的 `executeInt()`
    方法替换 `execute()` 方法，以及通过用原始类型（`int`、`double` 等）替换包装器实现（`Integer`、`Double` 等）来减少
    CPU 的装箱和拆箱负载。这种技术有时被称为 *装箱消除*。
- en: Once the interpreter finds that there are no node rewrites, that means that
    the AST has been stable. The code is then compiled to machine code, and all the
    virtual calls are inlined with specific calls. This code is then passed to the
    Graal JIT compiler for further optimization at runtime. This is called **partial
    evaluation**. Guards are embedded into the code in case the assumptions made are
    valid. When any of the assumptions made are invalid, a guard code will bring back
    the execution to the AST interpreter, where node rewriting will once again happen.
    This is called **Transfer to Interpreter**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解释器发现没有节点重写，这意味着 AST 已经稳定。然后，将代码编译成机器码，并将所有虚拟调用内联为特定的调用。然后，将此代码传递给 Graal JIT
    编译器在运行时进行进一步优化。这被称为 **部分评估**。如果假设有效，则将守卫嵌入到代码中。当任何假设无效时，守卫代码将执行回 AST 解释器，在那里节点重写将再次发生。这被称为
    **转移到解释器**。
- en: Partial Evaluation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分评估
- en: The calls to these `execute()` methods are virtual dispatches, which have a
    significant overhead on the performance. As Truffle identifies the code that is
    stabilized, when no more AST rewriting happens and the code has a lot of calls,
    it performs partial evaluation to improve the performance of the execution of
    this code. Partial evaluation includes inlining the code, eliminating the virtual
    dispatches and replacing them with direct calls, and building a combined unit
    that will be submitted to the Graal compiler for further optimization. Truffle
    places guard points wherever the assumptions made might be disproved. These guard
    points trigger the deoptimization by invalidating the code and switching back
    to interpreter mode of execution. The code is then compiled to machine code for
    the guest language after aggressive constant folding, inlining, and escape analysis.
    Truffle performs inlining on the AST so that it is language agnostic. The inlining
    decisions are taken by performing partial evaluation on every candidate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这些 `execute()` 方法是虚拟调度，这会对性能产生显著的开销。当 Truffle 识别出稳定的代码，即没有更多的 AST 重写发生且代码中有大量调用时，它会执行部分评估来提高该代码的执行性能。部分评估包括内联代码、消除虚拟调度并用直接调用替换它们，以及构建一个将被提交给
    Graal 编译器进行进一步优化的组合单元。Truffle 在可能被证伪的假设处放置守卫点。这些守卫点通过使代码无效并切换回执行解释器模式来触发降级优化。然后，在进行了激进的常量折叠、内联和逃逸分析之后，将代码编译为客语言的目标机器码。Truffle
    在 AST 上执行内联，使其与语言无关。内联决策是通过在每个候选对象上执行部分评估来做出的。
- en: In the next section, we'll have a look at the Truffle framework in GraalVM,
    which is used to create DSLs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 GraalVM 中的 Truffle 框架，该框架用于创建 DSL。
- en: Learning Truffle DSL
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Truffle DSL
- en: 'Truffle defines a **Domain-Specific Language** (**DSL**) based on the Java
    annotation processor. The language developer has to write a lot of boilerplate
    code to manage the states of the specializations. To appreciate how Truffle DSL
    makes a programmer''s life easy, let''s take a quick example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 定义了一个基于 Java 注解处理器的 **领域特定语言（DSL**）。语言开发者必须编写大量的样板代码来管理特殊化的状态。为了理解 Truffle
    DSL 如何使程序员的生活变得容易，让我们快速举一个例子：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we discussed earlier in this chapter, in AST, every operation and operand
    is represented as a node. In Truffle, it is a Java class derived from `com.oracle.truffle.api.nodes.Node`.
    To understand the need for a DSL, let's oversimplify the implementation of AST
    for the preceding expression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面所讨论的，在 AST 中，每个操作和操作数都表示为一个节点。在 Truffle 中，它是一个从 `com.oracle.truffle.api.nodes.Node`
    派生的 Java 类。为了理解 DSL 的必要性，让我们对前面表达式的 AST 实现进行过度简化。
- en: 'Since we are looking at dynamically typed languages, `a` and `b` can be any
    type. We need an expression node that should implement an `execute` method, which
    checks for all the possible types for `a` and `b`. We will have to write logic
    something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在查看动态类型语言，`a` 和 `b` 可以是任何类型。我们需要一个表达式节点，该节点应该实现一个 `execute` 方法，用于检查 `a`
    和 `b` 的所有可能类型。我们可能需要编写类似于以下逻辑的代码：
- en: '![Figure 6.5 – Guard checks for implementing specialization – flow chart'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 实现特殊化的守卫检查 – 流程图'
- en: '](img/B16878_Figure_6.5.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_6.5.jpg)'
- en: Figure 6.5 – Guard checks for implementing specialization – flow chart
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 实现特殊化的守卫检查 – 流程图
- en: In the preceding flow chart, we are checking for all possible combinations of
    operand types and evaluating the expression based on that, and if none of these
    conditions satisfy, it throws a `TypeError` exception. This kind of logic needs
    to be written in the Truffle interpreter, as we are dealing with dynamically typed
    languages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的流程图中，我们正在检查所有可能的操作数类型组合，并根据这些组合评估表达式，如果这些条件都不满足，则抛出 `TypeError` 异常。这种逻辑需要在
    Truffle 解释器中编写，因为我们正在处理动态类型语言。
- en: If we convert this to Truffle interpreter code, this is a lot of code for a
    very simple expression. Imagine if we have more complex expressions and other
    operations and functions. The Truffle interpreter code will be a nightmare to
    write and manage.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此转换为 Truffle 解释器代码，这将是一个非常简单的表达式的大量代码。想象一下，如果我们有更复杂的表达式和其他操作和函数。Truffle
    解释器代码将难以编写和管理。
- en: This is where Truffle DSL solves the issue. Truffle DSL provides a very well-defined
    framework of node hierarchy, annotations, and annotation processors that can be
    used to handle this type of dynamism.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Truffle DSL 解决问题的所在。Truffle DSL 提供了一个非常明确的节点层次结构、注解和注解处理程序的框架，可以用来处理这种类型的动态性。
- en: 'The `@Specialization` annotation is a specialization annotation implemented
    by the `com.oracle.truffle.api.dsl.Specialization` class, and this is used as
    an annotation for all the possible evaluation cases (green boxes in the previous
    figure). Truffle DSL compiles this into a dynamic code where Truffle picks the
    right implementation (the first in the sequence) based on the operand parameters.
    The language developer code will look something like the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Specialization` 注解是由 `com.oracle.truffle.api.dsl.Specialization` 类实现的特殊化注解，它被用作所有可能的评估情况的注解（如图中之前的绿色框所示）。Truffle
    DSL 将其编译成动态代码，其中 Truffle 根据操作数参数选择正确的实现（序列中的第一个）。语言开发者的代码将类似于以下代码片段：'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code shows how Truffle DSL simplifies the job, and there is no
    need to write a lot of `if`/`else` statements. Truffle DSL annotations take care
    of compiling and generating that code for us. And finally, to handle the exception
    case, we can use the @`Fallback` annotation implemented by the `com.oracle.truffle.api.dsl.Fallback`
    class. The fallback code block will look something like the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了 Truffle DSL 如何简化工作，我们不需要编写大量的 `if`/`else` 语句。Truffle DSL 注解会为我们编译和生成这些代码。最后，为了处理异常情况，我们可以使用由
    `com.oracle.truffle.api.dsl.Fallback` 类实现的 `@Fallback` 注解。回退代码块将类似于以下代码片段：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As mentioned before, Truffle picks the right implementation based on the operand
    types dynamically, by default. However, this can be also modified by declaring
    guards with the `@Specilization` annotation. Four types of guard can be declared
    for the `@Specialization` annotation. They are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Truffle 根据操作数类型动态选择正确的实现，默认情况下。但是，也可以通过使用 `@Specilization` 注解声明守卫来修改这一点。可以为
    `@Specialization` 注解声明四种类型的守卫。它们如下：
- en: '`@NodeChild` in the `Node` class declaration) types match, then that particular
    method is executed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Node` 类声明中的 `@NodeChild` 类型匹配时，将执行特定的方法。
- en: '`@Specification` annotation. The expressions are very simple Java-like code
    that evaluates to a Boolean value. If this expression is evaluated to true, then
    that particular method is executed; if it is false, the interpreter skips that
    execution. Here is a simple example:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Specification` 注解。这些表达式非常简单，类似于 Java 代码，其结果为布尔值。如果这个表达式评估为真，那么将执行特定的方法；如果为假，解释器将跳过该执行。以下是一个简单的例子：'
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, the `executeTheMethod()` method gets picked by the Truffle
    interpreter if the expression that is passed in `guards` is `true`. In this case,
    it will be true if the operand is not an integer and is not a float. `guards`
    is actually a String array attribute in `com.oracle.truffle.api.dsl.Specialization`.
    We can pass multiple expressions.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果传递给`guards`的表达式为`true`，Truffle解释器会选择`executeTheMethod()`方法。在这种情况下，如果操作数既不是整数也不是浮点数，则该表达式为真。`guards`实际上是`com.oracle.truffle.api.dsl.Specialization`中的一个String数组属性。我们可以传递多个表达式。
- en: '`ArthimeticException`. We could have multiple specialization implementations
    to rewrite that execution to handle exception cases. To understand this better,
    let''s look at the following code example:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArithmeticException`。我们可以有多个特殊化实现来重写执行以处理异常情况。为了更好地理解这一点，让我们看看以下代码示例：'
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, Truffle will call the `executeWithOverflow()` method when integer
    types are matching (type guard), but if the integer values cause an overflow,
    `ArthimeticException` is thrown. In that case, Truffle will use the `executeNoOverflow()`
    method to overwrite the add method. This is an example of node rewriting based
    on specialization, which we discussed previously in this chapter.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，当整数类型匹配（类型守卫）时，Truffle将调用`executeWithOverflow()`方法，但如果整数值导致溢出，则会抛出`ArithmeticException`。在这种情况下，Truffle将使用`executeNoOverflow()`方法来覆盖加法方法。这是我们之前在本章中讨论过的基于特殊化的节点重写的一个例子。
- en: '`Assumption` object is used by Truffle to validate and invalidate an assumption
    where `com.oracle.truffle.api.Assumption` is an interface. Once an assumption
    is invalidated, it can never be valid in that runtime. This is used by Truffle
    to take decisions on optimization and deoptimization. It is like a global Boolean
    flag. The language developer can invalidate an assumption programmatically to
    let the Truffle runtime know that a particular assumption is no longer valid,
    and accordingly the Truffle runtime can take decisions. Assumption objects are
    typically stored in the nodes as final fields. An assumption guard is used to
    pick a specialization method if the assumptions are true.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assumption`对象由Truffle用于验证和无效化一个假设，其中`com.oracle.truffle.api.Assumption`是一个接口。一旦假设被无效化，在该运行时中它将永远不再有效。这被Truffle用于在优化和去优化中做出决策。它就像一个全局的布尔标志。语言开发者可以通过程序方式无效化一个假设，让Truffle运行时知道特定的假设不再有效，相应地，Truffle运行时可以做出决策。假设对象通常作为节点的最终字段存储。假设守卫用于在假设为真时选择特殊化方法。'
- en: Based on these various annotations, Truffle will generate the actual `execute()`
    method with all the `if`/`else` controls to make sure the right version of the
    method is called based on the constraints that we declared with the `@Specification`
    annotation. The Truffle DSL annotation generator also includes `CompilerDirectives.transferToInterpreterAndInvalidate()`
    in the `execute()` method, toward the end; this will tell the compiler to stop
    the compilation, insert a transfer to the interpreter, and invalidate the machine
    code. This will trigger the deoptimization and a return to the interpreter mode
    of execution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些各种注解，Truffle将生成实际的`execute()`方法，其中包含所有`if`/`else`控制，以确保根据我们使用`@Specification`注解声明的约束调用方法的确切版本。Truffle
    DSL注解生成器还在`execute()`方法的末尾包括了`CompilerDirectives.transferToInterpreterAndInvalidate()`；这将告诉编译器停止编译，插入一个转换到解释器的操作，并使机器代码无效。这将触发去优化并返回到执行的解释器模式。
- en: 'Apart from this, Truffle DSL also provides other annotations that make the
    job of a language developer easy. You can refer to the full list here: [https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，Truffle DSL还提供了其他使语言开发者工作变得容易的注解。您可以在此处查看完整列表：[https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html)。
- en: Truffle defines a TypeSystem, where the language developers can provide custom
    behavior for casting operand types. For example, the Truffle interpreter may not
    know how to typecast a `long` to `int`. Using TypeSystem, we can define the typecasting
    logic. The Truffle interpreter will use the TypeSystem during specialization.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle定义了一个TypeSystem，语言开发者可以在其中为操作数类型提供自定义的转换行为。例如，Truffle解释器可能不知道如何将`long`类型转换为`int`类型。使用TypeSystem，我们可以定义类型转换逻辑。在特殊化过程中，Truffle解释器将使用TypeSystem。
- en: One of the challenges with dynamically typed language is the polymorphic dispatch
    of the methods/functions. Truffle interpreters implement polymorphic inline caching
    to speed up the function lookups.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型语言的一个挑战是多态方法/函数的调度。Truffle解释器实现多态内联缓存以加快函数查找。
- en: Polymorphic inline caching
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态内联缓存
- en: In dynamically typed languages, the interpreters have to perform lookups to
    identify the right implementation of the method/function that is called. Looking
    up the functions and calling the functions is expensive and slows down the execution.
    In dynamically typed languages, when an object or function is called, the class
    is not declared, at build time or at run time, the interpreter has to do a lookup
    to find the actual class that is implementing the method. This is typically a
    hashtable lookup, unlike the vTable lookup that occurs in strongly typed languages.
    Hashtable lookups are time-consuming and very expensive and slow down execution.
    If we have only one class implementing the method, we have to only do the lookup
    once. This is called monomorphic inlining. If multiple classes implement the method,
    it's polymorphic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态类型语言中，解释器必须执行查找以确定被调用方法/函数的正确实现。查找函数和调用函数是昂贵的，并且会减慢执行速度。在动态类型语言中，当调用一个对象或函数时，类在构建时或运行时都没有声明，解释器必须执行查找以找到实际实现该方法的类。这通常是一个散列表查找，与强类型语言中发生的vTable查找不同。散列表查找耗时且非常昂贵，会减慢执行速度。如果我们只有一个类实现该方法，我们只需要执行一次查找。这被称为单态内联。如果有多个类实现该方法，则是多态的。
- en: Checking if the function lookup is valid is less expensive than the actual lookup.
    Truffle caches polymorphic lookups if there are lots of previous lookups for multiple
    (polymorphic) lookups of a function. When a function is redefined due to deoptimization,
    the `Assumption` object is used to invalidate and perform a fresh lookup. To improve
    the performance of lookups, Truffle provides the polymorphic inline cache. Truffle
    caches the lookups, and just checks if the lookup is still valid.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 检查函数查找是否有效比实际查找更便宜。如果对于多个（多态）函数的多次查找有很多之前的查找，Truffle会缓存多态查找。当函数由于去优化而重新定义时，使用`Assumption`对象来无效化并执行新的查找。为了提高查找性能，Truffle提供了多态内联缓存。Truffle缓存查找，并仅检查查找是否仍然有效。
- en: Understanding how Truffle supports interoperability
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Truffle如何支持互操作性
- en: Truffle provides a very well-designed interoperability framework to allow guest
    languages to read and store data. In this section, we will cover some of the key
    features that the Truffle interoperability framework provides. Let's have a rundown
    of each of them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle提供了一个非常精心设计的互操作性框架，允许客语言读取和存储数据。在本节中，我们将介绍Truffle互操作性框架提供的一些关键特性。让我们逐一了解它们。
- en: Frame management and local variables
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架管理和局部变量
- en: 'Truffle provides a standard interface to handle the local variables and data
    between host and guest language implementations. The frame provides the interface
    to read and store the data in the current namespace. When a function is called,
    the local variables'' data is passed as an instance of `com.oracle.truffle.api.frame.Frame`.
    There are two implementations of the frame:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle提供了一个标准接口来处理主机和客语言实现之间的局部变量和数据。框架提供了读取和存储当前命名空间中数据的接口。当调用函数时，局部变量的数据作为`com.oracle.truffle.api.frame.Frame`实例传递。框架有两种实现：
- en: '`execute()` method. This is lightweight, and preferable, as Graal optimizes
    this better. This frame lives in the scope of the function. It is the optimum
    and recommended way to pass data to functions. `VirtualFrame` does not escape,
    so it is easy to handle and inline.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()`方法。这是轻量级的，并且更可取，因为Graal可以更好地优化它。这个框架存在于函数的作用域内。这是传递数据给函数的最优和推荐方式。`VirtualFrame`不会逃逸，因此易于处理和内联。'
- en: '`MaterializedFrame` is allocated in the heap and is accessible to other functions.
    `MaterializedFrame` lives beyond the scope of the function. Graal cannot optimize
    it as it might optimize `VirtualFrame`. This frame implementation also has an
    effect on the memory and speed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaterializedFrame`在堆中分配，并且可以被其他函数访问。`MaterializedFrame`超出函数的作用域。Graal无法像优化`VirtualFrame`那样优化它。这种框架实现也对内存和速度有影响。'
- en: 'Frames keep track of the type of data that is stored as part of the key. The
    key used to get the data is an instance of `FrameSlot` and `FrameSlotKind`. The
    following code snippet shows the `Frame` interface definition:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 帧跟踪作为键的一部分存储的数据类型。用于获取数据的键是 `FrameSlot` 和 `FrameSlotKind` 的实例。以下代码片段显示了 `Frame`
    接口的定义：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`FrameSlot.getIdentifier()` provides the unique identifier for the data, and
    `FrameSlotKind` stores the type of data. `FrameSlotKind` is an enum of various
    types (Boolean, Byte, Double, Float, Illegal, Int , Long, Object).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameSlot.getIdentifier()` 提供了数据的唯一标识符，而 `FrameSlotKind` 存储数据的类型。`FrameSlotKind`
    是一个包含各种类型（布尔型、字节型、双精度型、浮点型、非法型、整型、长整型、对象型）的枚举。'
- en: The `FrameDescriptor` class keeps track of values stored in the frames. `FrameDiscriptor`
    describes the layout of `Frame`, providing a mapping of `FrameSlot` and `FrameSlotKind`
    and the value. Please refer to [https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html)
    for more details on the Frame API. SimpleLanguage has an implementation of frame
    management and is a good start to understand how the Frame API can be used to
    manage the data that is passed between languages while invoking methods/functions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameDescriptor` 类跟踪存储在帧中的值。`FrameDiscriptor` 描述了 `Frame` 的布局，提供了 `FrameSlot`
    和 `FrameSlotKind` 以及值的映射。请参阅 [https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html)
    了解 Frame API 的更多详细信息。SimpleLanguage 有一个帧管理的实现，是理解如何使用 Frame API 来管理在调用方法/函数时在不同语言之间传递的数据的好起点。'
- en: Dynamic Object Model
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态对象模型
- en: Truffle provides a **Dynamic Object Model** (**DOM**) that provides an object
    storage framework to enable the interoperability of data and objects between different
    languages. Truffle's DOM defines a standard and optimized way to share data, especially
    between dynamically typed languages. The DOM provides a language-independent shared
    infrastructure that allows developers to derive and implement various language
    implementations of the objects. This also helps us to share type objects between
    languages. Truffle's DOM is one of the core components of Truffle's interoperability
    and embedding feature. It provides a consistent in-memory object storage structure
    for host and guest languages. This allows the sharing of data between code written
    in different languages and the application of optimization across polyglot applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 提供了一个 **动态对象模型** (**DOM**)，它提供了一个对象存储框架，以实现不同语言之间数据和对象的可互操作性。Truffle
    的 DOM 定义了一种标准且优化的数据共享方式，尤其是在动态类型语言之间。DOM 提供了一个语言无关的共享基础设施，允许开发者派生和实现各种语言的对象实现。这也帮助我们实现不同语言之间的类型对象共享。Truffle
    的 DOM 是 Truffle 互操作性和嵌入功能的核心组件之一。它为主机和客户端语言提供了一致的内存对象存储结构。这允许不同语言编写的代码之间共享数据，并在多语言应用程序中应用优化。
- en: One of the challenges with dynamically typed languages is the dynamism that
    is expected of the data object model. The structure of the object may change dynamically.
    To support this, Truffle's DOM defines a Java class called `DynamicObject`. It
    provides extension arrays to provide the variability of primitive types and object
    extensions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型语言的一个挑战是期望数据对象模型具有动态性。对象的结构可能会动态改变。为了支持这一点，Truffle 的 DOM 定义了一个名为 `DynamicObject`
    的 Java 类。它提供了扩展数组以提供原始类型和对象扩展的可变性。
- en: The guest language objects should all derive from a base class that extends
    from `DynamicObject` and implements `TruffleObject`. Let's now understand the
    Truffle instrumentation in detail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端语言对象都应该继承自一个从 `DynamicObject` 扩展并实现 `TruffleObject` 的基类。现在让我们详细了解 Truffle
    仪表化。
- en: Understanding Truffle instrumentation
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Truffle 仪表化
- en: 'Truffle provides an Instrumentation API to help build instrumentation and tools
    for diagnosis, monitoring, and debugging. Truffle also provides a reference implementation
    called Simple Tool ([https://github.com/graalvm/simpletool](https://github.com/graalvm/simpletool)).
    Truffle provides a very high-performance instrumentation design. The instrumentation
    is achieved with the help of probes and tags. The probes are attached to the AST
    nodes to capture the instrumentation data, and the nodes are identified using
    tags. Multiple instruments can be attached to the probe. The following figure
    shows a typical instrumentation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 提供了一个 Instrumentation API，以帮助构建用于诊断、监控和调试的仪器和工具。Truffle 还提供了一个名为 Simple
    Tool 的参考实现（[https://github.com/graalvm/simpletool](https://github.com/graalvm/simpletool)）。Truffle
    提供了一个非常高性能的仪器化设计。仪器化是通过探针和标签实现的。探针附加到 AST 节点以捕获仪器化数据，节点使用标签进行标识。多个仪器可以附加到探针。以下图示了一个典型的仪器化：
- en: '![Figure 6.6 – Truffle instrumentation'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – Truffle 仪器化'
- en: '](img/B16878_Figure_6.6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_6.6.png)'
- en: Figure 6.6 – Truffle instrumentation
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – Truffle 仪器化
- en: The preceding figure illustrates how Truffle's Instrument API connects to the
    AST to collect the various metrics/data. Truffle displaces the original node by
    inserting a wrapper node and passes the information to the probe node, which can
    be connected to multiple instruments to collect the data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示说明了 Truffle 的 Instrument API 如何连接到 AST 以收集各种指标/数据。Truffle 通过插入包装节点替换原始节点，并将信息传递给探针节点，该节点可以连接到多个仪器以收集数据。
- en: Ahead-of-time compilation using Truffle
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Truffle 进行 AOT 编译
- en: 'Guest language developers can make use of Graal''s `RootNode.prepareForAOT()`
    method by returning a non-null value. If a null value is returned, Truffle/Graal
    understands that this language does not support building native images. To support
    AOT, the `prepraeForAOT()` method typically might implement the following tasks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端语言开发者可以通过返回非空值来使用 Graal 的 `RootNode.prepareForAOT()` 方法。如果返回空值，Truffle/Graal
    会理解该语言不支持构建原生镜像。为了支持 AOT，`prepraeForAOT()` 方法通常可能实现以下任务：
- en: Provide type information about the local variables and update them in `FrameDescriptor`.
    This will help the AOT compiler to resolve the types during build time.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供局部变量的类型信息并在 `FrameDescriptor` 中更新它们。这将有助于 AOT 编译器在构建时解析类型。
- en: Resolve and define the arguments and return types.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决并定义参数和返回类型。
- en: Truffle DSL provides helper classes to accelerate the development of AOT features.
    The `com.oracle.truffle.api.dsl.AOTSupport` class recursively prepares the AST
    for AOT. Each node in the AST has to have an implementation of the `prepareForAOT()`
    method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle DSL 提供了辅助类以加速 AOT 功能的开发。`com.oracle.truffle.api.dsl.AOTSupport` 类递归地准备
    AST 以进行 AOT。AST 中的每个节点都必须实现 `prepareForAOT()` 方法。
- en: AOT compilation can be triggered by passing the `--engine.CompileAOTOnCreate=true`
    argument to the language launcher. Each guest language will have a language launcher
    to run the application, for example, `js` for JavaScript, `graalpython` for Python,
    and so on. We will cover some of these guest language implementations in the next
    two chapters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将 `--engine.CompileAOTOnCreate=true` 参数传递给语言启动器来触发 AOT 编译。每个客户端语言都将有一个语言启动器来运行应用程序，例如，`js`
    用于 JavaScript，`graalpython` 用于 Python 等。我们将在下一章中介绍一些这些客户端语言实现。
- en: Optimizing Truffle interpreter performance with launcher options
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用启动器选项优化 Truffle 解释器性能
- en: 'Truffle defines a design and specification for providing various launcher options
    that can be used to diagnose, debug, and optimize the interpreter. All the guest
    language developers support these launcher options. In this section, we will cover
    some of these important launcher options:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 定义了一个设计和规范，用于提供各种启动器选项，这些选项可用于诊断、调试和优化解释器。所有客户端语言开发者都支持这些启动器选项。在本节中，我们将介绍一些这些重要的启动器选项：
- en: '`–help` command-line argument. `--help:expert` provides the expert options.
    For the language implementer''s internal options, we can use `--help:internal`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-help` 命令行参数。`--help:expert` 提供专家选项。对于语言实现者的内部选项，我们可以使用 `--help:internal`。'
- en: '`--vm.Dgraal.Dump=Truffle:1` argument. The Graal graphs generated with Truffle
    will have a phase called *After TruffleTier* that shows the optimizations performed
    by Truffle.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--vm.Dgraal.Dump=Truffle:1` 参数。使用 Truffle 生成的 Graal 图将包含一个名为 *After TruffleTier*
    的阶段，该阶段显示了 Truffle 执行的优化。'
- en: '`--cpusampler` can be used to find out the CPU time taken to run the application
    and provide a detailed breakdown of CPU usage by module.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`--cpusampler` 可以用来找出应用程序运行的 CPU 时间，并提供按模块详细分解的 CPU 使用情况。'
- en: The `--engine.TraceCompilation` argument can be passed to create a trace each
    time a method is compiled.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以传递 `--engine.TraceCompilation` 参数来在每次方法编译时创建一个跟踪。
- en: The `--engine.TraceCompilationDetail` argument can be passed to trace when compilation
    is queued, started, and finished.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以传递 `--engine.TraceCompilationDetail` 参数来跟踪编译队列、开始和完成时的编译过程。
- en: The `--engine.TraceCompilationAST` argument can be passed to trace the AST whenever
    the code is compiled.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以传递 `--engine.TraceCompilationAST` 参数来跟踪代码编译时的 AST。
- en: The `--engine.TraceInlining` argument can be passed to trace the inlining decisions
    taken by the guest language.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以传递 `--engine.TraceInlining` 参数来跟踪客语言所做的内联决策。
- en: The `--engine.TraceSplitting` argument can be passed to trace the splitting
    decisions taken by the language.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以传递 `--engine.TraceSplitting` 参数来跟踪语言所做的拆分决策。
- en: The `--engine.TraceTransferToInterpreter` argument can be passed to trace when
    the deoptimization is triggered and a transfer to the interpreter occurs.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以传递 `--engine.TraceTransferToInterpreter` 参数来跟踪在触发去优化并发生到解释器的转换时的情况。
- en: You can refer to the GraalVM documentation for more information ([https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/](https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/))
    or pass the `--help` argument in the language launcher.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 GraalVM 文档以获取更多信息 ([https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/](https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/))
    或在语言启动器中传递 `--help` 参数。
- en: SimpleLanguage and Simple Tool
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SimpleLanguage 和 Simple Tool
- en: The GraalVM team has created a reference implementation of a guest language
    called SimpleLanguage. SimpleLanguage demonstrates the features of Truffle and
    explains how to use the Truffle API. A guest language developer can use SimpleLanguage
    as a reference. It is completely open source and is available on GitHub at [https://github.com/graalvm/simplelanguage](https://github.com/graalvm/simplelanguage).
    SimpleLanguage is just a starting point and does not implement all the features.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 团队创建了一个名为 SimpleLanguage 的客语言参考实现。SimpleLanguage 展示了 Truffle 的功能，并解释了如何使用
    Truffle API。客语言开发者可以使用 SimpleLanguage 作为参考。它是完全开源的，可在 GitHub 上找到 [https://github.com/graalvm/simplelanguage](https://github.com/graalvm/simplelanguage)。SimpleLanguage
    只是一个起点，并不实现所有功能。
- en: There is also a reference implementation of Simple Tool. Simple Tool is an implementation
    of a code coverage tool that has been built using Truffle. This is also an open
    source project that can be used by tool developers to build new tools using Truffle
    to run on GraalVM. You can access the source code of this tool at [https://github.com/graalvm/simpletool](https://github.com/graalvm/simpletool).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 Simple Tool 的参考实现。Simple Tool 是一个使用 Truffle 构建的代码覆盖率工具的实现。这也是一个开源项目，工具开发者可以使用它来构建在
    GraalVM 上运行的新的工具。您可以在 [https://github.com/graalvm/simpletool](https://github.com/graalvm/simpletool)
    访问此工具的源代码。
- en: There is an increasing number of languages being developed with Truffle. We
    will be covering JavaScript, LLVM (C/C++), Ruby, Python, R, Java/Truffle, and
    WebAssemby in the next two chapters. You can see the status of some of the other
    programming languages at [https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/](https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Truffle 开发的语言数量正在不断增加。在接下来的两章中，我们将介绍 JavaScript、LLVM（C/C++）、Ruby、Python、R、Java/Truffle
    和 WebAssembly。您可以在 [https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/](https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/)
    查看一些其他编程语言的状态。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the architecture of Truffle and saw how it
    provides a well-designed framework for other languages (guest languages) to run
    on GraalVM. We also looked at how Truffle interpreters are implemented and how
    they can optimize the AST before submitting the stabilized AST to the Graal for
    further optimization.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Truffle 的架构，并了解了它是如何为其他语言（客语言）在 GraalVM 上运行提供精心设计的框架。我们还研究了 Truffle
    解释器的实现方式以及它们如何在提交稳定后的 AST 到 Graal 进行进一步优化之前对 AST 进行优化。
- en: In this chapter, you have gained a good understanding of Truffle architecture
    and how Truffle provides a framework and an implementation layer on top of Graal.
    You have also explored the optimizations Truffle performs before submitting the
    code to Graal JIT for further optimization and execution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经对Truffle架构以及Truffle如何在Graal之上提供框架和实现层有了很好的理解。您还探索了Truffle在将代码提交给Graal
    JIT进行进一步优化和执行之前所执行的优化。
- en: In the next chapter, we will look at how JavaScript and LLVM languages (C, C++,
    and so on) implement Truffle and run on GraalVM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨JavaScript和LLVM语言（C、C++等）如何在GraalVM上实现Truffle并运行。
- en: Questions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is specialization?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是特化？
- en: What is tree/node rewriting?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是树/节点重写？
- en: What is partial evaluation?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是部分评估？
- en: What is Truffle DSL?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Truffle DSL？
- en: What is a frame?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是框架？
- en: What is a Dynamic Object Model?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是动态对象模型？
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Truffle: A Self-Optimizing Runtime System ([https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf](https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf))'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle：一个自优化运行时系统 ([https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf](https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf))
- en: Specializing Dynamic Techniques For Implementing the Ruby Programming Language  ([https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language](https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language))
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特化动态技术以实现Ruby编程语言 ([https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language](https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language))
- en: A Domain-Specific Language for Building Self-Optimizing AST Interpreters ([http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf))
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建自优化AST解释器的领域特定语言 ([http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf))
- en: One VM to Rule Them All ([http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf))
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个虚拟机统治一切 ([http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf))
- en: High-Performance Cross-Language Interoperability in a Multi-language Runtime
    ([https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf](https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf))
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言运行时中的高性能跨语言互操作性 ([https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf](https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf))
- en: Writing a Language in Truffle ([http://cesquivias.github.io/index.html](http://cesquivias.github.io/index.html))
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Truffle中编写语言 ([http://cesquivias.github.io/index.html](http://cesquivias.github.io/index.html))
