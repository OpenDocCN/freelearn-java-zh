- en: '*Chapter 6*: Truffle – An Overview'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Support for polyglot development is one of the biggest features of GraalVM.
    In [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077), *Graal Just-In-Time
    Compiler*, and [*Chapter 5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097),
    *Graal Ahead-of-Time Compiler and Native Image*, we went into a lot of detail
    on how Graal optimizes code, both at build time and run time. We have only used
    Java in all the previous chapters. However, GraalVM extends most of its advanced
    features to other programming languages too. GraalVM provides a language implementation
    framework called **Truffle Language Implementation Framework** (commonly known
    as **Truffle**).
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM not only provides a high-performance runtime for JVM languages such
    as Java, Groovy, Kotlin, and Scala, but it also supports non-JVM languages such
    as JavaScript, Ruby, Python, R, WebAssembly, and LLVM languages that implement
    Truffle. A lot more languages are being implemented on Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a conceptual view of how Truffle helps guest language
    developers and provides a well-designed, high-performance framework to build applications
    using guest languages on top of GraalVM. This chapter does not get into too much
    detail on how to write in guest languages using Truffle. This is only intended
    to describe Truffle's architecture and concepts at a high level so that you can
    follow the subsequent chapters on how non-JVM languages are implemented on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Truffle language implementation framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Truffle interpreter/compiler pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Truffle DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Truffle supports interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Truffle instrumentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ahead-of-time compilation using Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing Truffle interpreter performance with launcher options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SimpleLanguage and Simple Tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of Truffle's
    architecture, and how Truffle provides a framework for other programming languages
    to run on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Truffle language implementation framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    in the Truffle section, we briefly covered the architecture of Truffle. Truffle
    is an open source library that provides a framework to implement language interpreters.
    Truffle helps run guest programming languages that implement the framework to
    utilize the Graal compiler features to generate high-performance code. Truffle
    also provides a reference implementation called SimpleLanguage to guide developers
    to write interpreters for their languages. Truffle also provides a tools framework
    that helps integrate and utilize some of the modern diagnostic, debugging, and
    analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand how Truffle fits into the overall GraalVM ecosystem. Along
    with interoperability between the languages, Truffle also provides embeddability.
    Interoperability allows the calling of code between different languages, while
    embeddability allows the embedding of code written in different languages in the
    same program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Language interoperability is critical for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Different programming languages are built to solve different problems, and they
    come with their own strengths. For example, we use Python and R extensively for
    machine learning and data analytics, and we use C/C+ for high-performance mathematical
    operations. Imagine if we would reuse the code as it is, either by calling the
    code from a host language (such as Java) or embedding that code within the host
    language. This also increases the reusability of the code and allows us to use
    an appropriate language for the task at hand, rather than rewriting the logic
    in different languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large migration projects where we are moving from one language to another can
    be phased out if we have the feature of multiple programming language interoperability.
    This brings down the risk of migration considerably.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure illustrates how to run applications written in other languages
    on GraalVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Truffle stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_6.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Truffle stack
  prefs: []
  type: TYPE_NORMAL
- en: 'In the figure, we can see GraalVM, which is the JVM and Graal JIT compiler
    that we covered in the previous chapters. On top of that, we have the Truffle
    framework. Truffle has two major components. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Truffle API**: The Truffle API is the language implementation framework that
    any guest language programmers can use to implement the Truffle interpreter for
    their respective languages. Truffle provides a sophisticated API for **Abstract
    Syntax Tree** (**AST**) rewriting. The guest language is converted to AST for
    optimizing and running on GraalVM. The Truffle API also helps in providing an
    interoperability framework between languages that implement the Truffle API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Truffle optimizer**: The Truffle optimizer provides an additional layer of
    optimization for speculative optimization with partial evaluation. We will be
    going through this in more detail in the subsequent sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Above the Truffle layer, we have the guest language. This is JavaScript, R,
    Ruby, and others that implement the Truffle Language Implementation framework.
    Finally, we have the application that runs on top of the guest language runtime.
    In most cases, application developers don''t have to worry about changing the
    code to run on GraalVM. Truffle makes it seamless by providing a layer in between.
    The following diagram shows a detailed stack view of the GraalVM and Truffle ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Truffle and Graal detailed stack view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_6.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Truffle and Graal detailed stack view
  prefs: []
  type: TYPE_NORMAL
- en: This diagram is a simple representation of how Truffle acts as a layer between
    non-JVM languages and GraalVM. Let's understand this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle provides the API that the individual interpreters implement to rewrite
    the code into ASTs. The AST representation is later converted to a Graal intermediate
    representation for Graal to execute and also optimize just in time. The guest
    languages run on top of the Truffle interpreter implementations of the respective
    guest languages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how these various layers interact and how Truffle helps the guest
    language to run on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Truffle interpreter/compiler pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Truffle provides a Java library that can be used to write AST interpreters
    in Java for any language. The guest language semantics are expressed as an AST
    using the AST interpreters. Graal and Truffle specify the exact format of AST,
    and the framework enforces this specification. So, any guest language AST interpreter
    written using Truffle Language Implementation API will generate the semantics
    of the language in AST that GraalVM can then use to optimize just in time and
    run. The following figure provides a detailed flow of how Truffle and Graal work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Truffle and Graal compilation pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_6.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Truffle and Graal compilation pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the flow diagram better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The guest languages are parsed using a traditional syntactical and lexical
    analyzer. This generates an AST. The AST is an intermediate representation built
    as per the Truffle/Graal specifications. The AST is a tree structure where each
    parent node is an operation/function, and the child nodes are data/operands/dependencies.
    Each node that is part of the AST has an `execute()` method. The `execute()` method
    implements the semantics of the corresponding language construct. The guest language
    developers are supposed to design these nodes and provide facilities to parse
    the guest language code and build the tree. The following code snippet shows the
    abstract node object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the node types implement this abstract node. AST interpreters go through
    the AST node by node to execute using a stack frame to keep track of the execution
    and data. AST interpreters are easy to implement but have huge performance overheads.
    Let's now look at how Truffle interpreters optimize the AST by rewriting the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Self-optimization and tree rewriting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of the AST can be dynamically changed by rewriting. This is also
    sometimes referred to as AST rewriting. The AST interpreter can rewrite the AST
    dynamically based on the runtime profiling. This improves the performance significantly.
    The nodes can be updated at runtime by rewriting based on the runtime profiling
    and optimizing the AST.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest issues with dynamic languages, from a performance perspective,
    is the type declarations (unlike languages such as C, where the type is specified
    in the code). The types are not declared at coding time, which means the variables,
    at the start of the execution, may assume any type. The profiler can figure out
    the specific type after a few runs and can then specialize the type of the variables
    based on the runtime profiling. It then rewrites the AST with the specific type.
    This technique is called **Type Specialization**. This has a significant performance
    boost, as the operations/methods that are performed on this data can be specialized
    to the data type. The Truffle interpreter leaves a speculation *guard* in case
    the speculation/assumption made on the type is proven wrong in future executions.
    In this case, the guard is invoked to deoptimize the AST.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tree rewriting also happens when an operation/function has to be resolved at
    runtime. This is very important for the dynamic resolution of function or operations,
    due to polymorphic implementations of the operations or functions. When the profiler
    identifies a specific implementation of the function/operation, the resolved function/operation
    can be rewritten. A simple diagram that illustrates operation resolution follows
    this paragraph. The `Node` class has the `replace()` method, which is used for
    rewriting. The following figure illustrates a very simple expression, and shows
    how the AST gets rewritten after profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – AST specialization illustration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_6.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – AST specialization illustration
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of the figure, the Truffle interpreter starts off as a generic
    AST node. Based on the profiler, the interpreter understands that it's mostly
    a specific type value, let's say an integer. It will rewrite the nodes with integer
    types and the operation nodes with integer operations. This optimizes the execution
    of the AST. In the left-most representation, + might mean the concatenation of
    strings or the addition of integers or longs or floats, or any other polymorphic
    execution of the operation that is reduced to the right-most representation, where
    it is very clearly an integer. A guard check is placed there in case the assumption
    made is proven wrong in the future. If the operands happen to be floats, or some
    other type, then a deoptimization is invoked, which might take it back to the
    left-most representation. The Truffle interpreter will once again profile to identify
    the right type specializations to apply. It may identify that it is more of a
    long or double, so it might rewrite the AST as a double and optimize. Type specialization
    is applied to local variables, return types, operations, and fields.
  prefs: []
  type: TYPE_NORMAL
- en: AST rewriting based on type specialization provides a significant boost to performance,
    and by the time we get to more advanced optimizations that the Graal performs,
    we have a very stable AST.
  prefs: []
  type: TYPE_NORMAL
- en: Since the AST interpreters are implemented in Java, the node `execute()` method
    is written to handle a generic object. Type specialization also helps by replacing
    the `execute()` method with a specialized `executeInt()` method, and also reduces
    the load on the CPU for boxing and unboxing by replacing the wrapper implementations
    (`Integer`, `Double`, and so on) with primitive types (`int`, `double`). This
    technique is sometimes referred to as *boxing elimination*.
  prefs: []
  type: TYPE_NORMAL
- en: Once the interpreter finds that there are no node rewrites, that means that
    the AST has been stable. The code is then compiled to machine code, and all the
    virtual calls are inlined with specific calls. This code is then passed to the
    Graal JIT compiler for further optimization at runtime. This is called **partial
    evaluation**. Guards are embedded into the code in case the assumptions made are
    valid. When any of the assumptions made are invalid, a guard code will bring back
    the execution to the AST interpreter, where node rewriting will once again happen.
    This is called **Transfer to Interpreter**.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The calls to these `execute()` methods are virtual dispatches, which have a
    significant overhead on the performance. As Truffle identifies the code that is
    stabilized, when no more AST rewriting happens and the code has a lot of calls,
    it performs partial evaluation to improve the performance of the execution of
    this code. Partial evaluation includes inlining the code, eliminating the virtual
    dispatches and replacing them with direct calls, and building a combined unit
    that will be submitted to the Graal compiler for further optimization. Truffle
    places guard points wherever the assumptions made might be disproved. These guard
    points trigger the deoptimization by invalidating the code and switching back
    to interpreter mode of execution. The code is then compiled to machine code for
    the guest language after aggressive constant folding, inlining, and escape analysis.
    Truffle performs inlining on the AST so that it is language agnostic. The inlining
    decisions are taken by performing partial evaluation on every candidate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll have a look at the Truffle framework in GraalVM,
    which is used to create DSLs.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Truffle DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Truffle defines a **Domain-Specific Language** (**DSL**) based on the Java
    annotation processor. The language developer has to write a lot of boilerplate
    code to manage the states of the specializations. To appreciate how Truffle DSL
    makes a programmer''s life easy, let''s take a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed earlier in this chapter, in AST, every operation and operand
    is represented as a node. In Truffle, it is a Java class derived from `com.oracle.truffle.api.nodes.Node`.
    To understand the need for a DSL, let's oversimplify the implementation of AST
    for the preceding expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are looking at dynamically typed languages, `a` and `b` can be any
    type. We need an expression node that should implement an `execute` method, which
    checks for all the possible types for `a` and `b`. We will have to write logic
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Guard checks for implementing specialization – flow chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_6.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Guard checks for implementing specialization – flow chart
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding flow chart, we are checking for all possible combinations of
    operand types and evaluating the expression based on that, and if none of these
    conditions satisfy, it throws a `TypeError` exception. This kind of logic needs
    to be written in the Truffle interpreter, as we are dealing with dynamically typed
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: If we convert this to Truffle interpreter code, this is a lot of code for a
    very simple expression. Imagine if we have more complex expressions and other
    operations and functions. The Truffle interpreter code will be a nightmare to
    write and manage.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Truffle DSL solves the issue. Truffle DSL provides a very well-defined
    framework of node hierarchy, annotations, and annotation processors that can be
    used to handle this type of dynamism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Specialization` annotation is a specialization annotation implemented
    by the `com.oracle.truffle.api.dsl.Specialization` class, and this is used as
    an annotation for all the possible evaluation cases (green boxes in the previous
    figure). Truffle DSL compiles this into a dynamic code where Truffle picks the
    right implementation (the first in the sequence) based on the operand parameters.
    The language developer code will look something like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows how Truffle DSL simplifies the job, and there is no
    need to write a lot of `if`/`else` statements. Truffle DSL annotations take care
    of compiling and generating that code for us. And finally, to handle the exception
    case, we can use the @`Fallback` annotation implemented by the `com.oracle.truffle.api.dsl.Fallback`
    class. The fallback code block will look something like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, Truffle picks the right implementation based on the operand
    types dynamically, by default. However, this can be also modified by declaring
    guards with the `@Specilization` annotation. Four types of guard can be declared
    for the `@Specialization` annotation. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@NodeChild` in the `Node` class declaration) types match, then that particular
    method is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Specification` annotation. The expressions are very simple Java-like code
    that evaluates to a Boolean value. If this expression is evaluated to true, then
    that particular method is executed; if it is false, the interpreter skips that
    execution. Here is a simple example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, the `executeTheMethod()` method gets picked by the Truffle
    interpreter if the expression that is passed in `guards` is `true`. In this case,
    it will be true if the operand is not an integer and is not a float. `guards`
    is actually a String array attribute in `com.oracle.truffle.api.dsl.Specialization`.
    We can pass multiple expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ArthimeticException`. We could have multiple specialization implementations
    to rewrite that execution to handle exception cases. To understand this better,
    let''s look at the following code example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, Truffle will call the `executeWithOverflow()` method when integer
    types are matching (type guard), but if the integer values cause an overflow,
    `ArthimeticException` is thrown. In that case, Truffle will use the `executeNoOverflow()`
    method to overwrite the add method. This is an example of node rewriting based
    on specialization, which we discussed previously in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Assumption` object is used by Truffle to validate and invalidate an assumption
    where `com.oracle.truffle.api.Assumption` is an interface. Once an assumption
    is invalidated, it can never be valid in that runtime. This is used by Truffle
    to take decisions on optimization and deoptimization. It is like a global Boolean
    flag. The language developer can invalidate an assumption programmatically to
    let the Truffle runtime know that a particular assumption is no longer valid,
    and accordingly the Truffle runtime can take decisions. Assumption objects are
    typically stored in the nodes as final fields. An assumption guard is used to
    pick a specialization method if the assumptions are true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on these various annotations, Truffle will generate the actual `execute()`
    method with all the `if`/`else` controls to make sure the right version of the
    method is called based on the constraints that we declared with the `@Specification`
    annotation. The Truffle DSL annotation generator also includes `CompilerDirectives.transferToInterpreterAndInvalidate()`
    in the `execute()` method, toward the end; this will tell the compiler to stop
    the compilation, insert a transfer to the interpreter, and invalidate the machine
    code. This will trigger the deoptimization and a return to the interpreter mode
    of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from this, Truffle DSL also provides other annotations that make the
    job of a language developer easy. You can refer to the full list here: [https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle defines a TypeSystem, where the language developers can provide custom
    behavior for casting operand types. For example, the Truffle interpreter may not
    know how to typecast a `long` to `int`. Using TypeSystem, we can define the typecasting
    logic. The Truffle interpreter will use the TypeSystem during specialization.
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges with dynamically typed language is the polymorphic dispatch
    of the methods/functions. Truffle interpreters implement polymorphic inline caching
    to speed up the function lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic inline caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In dynamically typed languages, the interpreters have to perform lookups to
    identify the right implementation of the method/function that is called. Looking
    up the functions and calling the functions is expensive and slows down the execution.
    In dynamically typed languages, when an object or function is called, the class
    is not declared, at build time or at run time, the interpreter has to do a lookup
    to find the actual class that is implementing the method. This is typically a
    hashtable lookup, unlike the vTable lookup that occurs in strongly typed languages.
    Hashtable lookups are time-consuming and very expensive and slow down execution.
    If we have only one class implementing the method, we have to only do the lookup
    once. This is called monomorphic inlining. If multiple classes implement the method,
    it's polymorphic.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if the function lookup is valid is less expensive than the actual lookup.
    Truffle caches polymorphic lookups if there are lots of previous lookups for multiple
    (polymorphic) lookups of a function. When a function is redefined due to deoptimization,
    the `Assumption` object is used to invalidate and perform a fresh lookup. To improve
    the performance of lookups, Truffle provides the polymorphic inline cache. Truffle
    caches the lookups, and just checks if the lookup is still valid.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how Truffle supports interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Truffle provides a very well-designed interoperability framework to allow guest
    languages to read and store data. In this section, we will cover some of the key
    features that the Truffle interoperability framework provides. Let's have a rundown
    of each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Frame management and local variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Truffle provides a standard interface to handle the local variables and data
    between host and guest language implementations. The frame provides the interface
    to read and store the data in the current namespace. When a function is called,
    the local variables'' data is passed as an instance of `com.oracle.truffle.api.frame.Frame`.
    There are two implementations of the frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execute()` method. This is lightweight, and preferable, as Graal optimizes
    this better. This frame lives in the scope of the function. It is the optimum
    and recommended way to pass data to functions. `VirtualFrame` does not escape,
    so it is easy to handle and inline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaterializedFrame` is allocated in the heap and is accessible to other functions.
    `MaterializedFrame` lives beyond the scope of the function. Graal cannot optimize
    it as it might optimize `VirtualFrame`. This frame implementation also has an
    effect on the memory and speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Frames keep track of the type of data that is stored as part of the key. The
    key used to get the data is an instance of `FrameSlot` and `FrameSlotKind`. The
    following code snippet shows the `Frame` interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`FrameSlot.getIdentifier()` provides the unique identifier for the data, and
    `FrameSlotKind` stores the type of data. `FrameSlotKind` is an enum of various
    types (Boolean, Byte, Double, Float, Illegal, Int , Long, Object).'
  prefs: []
  type: TYPE_NORMAL
- en: The `FrameDescriptor` class keeps track of values stored in the frames. `FrameDiscriptor`
    describes the layout of `Frame`, providing a mapping of `FrameSlot` and `FrameSlotKind`
    and the value. Please refer to [https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html)
    for more details on the Frame API. SimpleLanguage has an implementation of frame
    management and is a good start to understand how the Frame API can be used to
    manage the data that is passed between languages while invoking methods/functions.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Object Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Truffle provides a **Dynamic Object Model** (**DOM**) that provides an object
    storage framework to enable the interoperability of data and objects between different
    languages. Truffle's DOM defines a standard and optimized way to share data, especially
    between dynamically typed languages. The DOM provides a language-independent shared
    infrastructure that allows developers to derive and implement various language
    implementations of the objects. This also helps us to share type objects between
    languages. Truffle's DOM is one of the core components of Truffle's interoperability
    and embedding feature. It provides a consistent in-memory object storage structure
    for host and guest languages. This allows the sharing of data between code written
    in different languages and the application of optimization across polyglot applications.
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges with dynamically typed languages is the dynamism that
    is expected of the data object model. The structure of the object may change dynamically.
    To support this, Truffle's DOM defines a Java class called `DynamicObject`. It
    provides extension arrays to provide the variability of primitive types and object
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The guest language objects should all derive from a base class that extends
    from `DynamicObject` and implements `TruffleObject`. Let's now understand the
    Truffle instrumentation in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Truffle instrumentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Truffle provides an Instrumentation API to help build instrumentation and tools
    for diagnosis, monitoring, and debugging. Truffle also provides a reference implementation
    called Simple Tool ([https://github.com/graalvm/simpletool](https://github.com/graalvm/simpletool)).
    Truffle provides a very high-performance instrumentation design. The instrumentation
    is achieved with the help of probes and tags. The probes are attached to the AST
    nodes to capture the instrumentation data, and the nodes are identified using
    tags. Multiple instruments can be attached to the probe. The following figure
    shows a typical instrumentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Truffle instrumentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_6.6.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Truffle instrumentation
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure illustrates how Truffle's Instrument API connects to the
    AST to collect the various metrics/data. Truffle displaces the original node by
    inserting a wrapper node and passes the information to the probe node, which can
    be connected to multiple instruments to collect the data.
  prefs: []
  type: TYPE_NORMAL
- en: Ahead-of-time compilation using Truffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guest language developers can make use of Graal''s `RootNode.prepareForAOT()`
    method by returning a non-null value. If a null value is returned, Truffle/Graal
    understands that this language does not support building native images. To support
    AOT, the `prepraeForAOT()` method typically might implement the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide type information about the local variables and update them in `FrameDescriptor`.
    This will help the AOT compiler to resolve the types during build time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve and define the arguments and return types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle DSL provides helper classes to accelerate the development of AOT features.
    The `com.oracle.truffle.api.dsl.AOTSupport` class recursively prepares the AST
    for AOT. Each node in the AST has to have an implementation of the `prepareForAOT()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: AOT compilation can be triggered by passing the `--engine.CompileAOTOnCreate=true`
    argument to the language launcher. Each guest language will have a language launcher
    to run the application, for example, `js` for JavaScript, `graalpython` for Python,
    and so on. We will cover some of these guest language implementations in the next
    two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Truffle interpreter performance with launcher options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Truffle defines a design and specification for providing various launcher options
    that can be used to diagnose, debug, and optimize the interpreter. All the guest
    language developers support these launcher options. In this section, we will cover
    some of these important launcher options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`–help` command-line argument. `--help:expert` provides the expert options.
    For the language implementer''s internal options, we can use `--help:internal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--vm.Dgraal.Dump=Truffle:1` argument. The Graal graphs generated with Truffle
    will have a phase called *After TruffleTier* that shows the optimizations performed
    by Truffle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpusampler` can be used to find out the CPU time taken to run the application
    and provide a detailed breakdown of CPU usage by module.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `--engine.TraceCompilation` argument can be passed to create a trace each
    time a method is compiled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `--engine.TraceCompilationDetail` argument can be passed to trace when compilation
    is queued, started, and finished.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `--engine.TraceCompilationAST` argument can be passed to trace the AST whenever
    the code is compiled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `--engine.TraceInlining` argument can be passed to trace the inlining decisions
    taken by the guest language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `--engine.TraceSplitting` argument can be passed to trace the splitting
    decisions taken by the language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `--engine.TraceTransferToInterpreter` argument can be passed to trace when
    the deoptimization is triggered and a transfer to the interpreter occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can refer to the GraalVM documentation for more information ([https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/](https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/))
    or pass the `--help` argument in the language launcher.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleLanguage and Simple Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GraalVM team has created a reference implementation of a guest language
    called SimpleLanguage. SimpleLanguage demonstrates the features of Truffle and
    explains how to use the Truffle API. A guest language developer can use SimpleLanguage
    as a reference. It is completely open source and is available on GitHub at [https://github.com/graalvm/simplelanguage](https://github.com/graalvm/simplelanguage).
    SimpleLanguage is just a starting point and does not implement all the features.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a reference implementation of Simple Tool. Simple Tool is an implementation
    of a code coverage tool that has been built using Truffle. This is also an open
    source project that can be used by tool developers to build new tools using Truffle
    to run on GraalVM. You can access the source code of this tool at [https://github.com/graalvm/simpletool](https://github.com/graalvm/simpletool).
  prefs: []
  type: TYPE_NORMAL
- en: There is an increasing number of languages being developed with Truffle. We
    will be covering JavaScript, LLVM (C/C++), Ruby, Python, R, Java/Truffle, and
    WebAssemby in the next two chapters. You can see the status of some of the other
    programming languages at [https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/](https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the architecture of Truffle and saw how it
    provides a well-designed framework for other languages (guest languages) to run
    on GraalVM. We also looked at how Truffle interpreters are implemented and how
    they can optimize the AST before submitting the stabilized AST to the Graal for
    further optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have gained a good understanding of Truffle architecture
    and how Truffle provides a framework and an implementation layer on top of Graal.
    You have also explored the optimizations Truffle performs before submitting the
    code to Graal JIT for further optimization and execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how JavaScript and LLVM languages (C, C++,
    and so on) implement Truffle and run on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is specialization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is tree/node rewriting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is partial evaluation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Truffle DSL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a frame?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Dynamic Object Model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Truffle: A Self-Optimizing Runtime System ([https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf](https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specializing Dynamic Techniques For Implementing the Ruby Programming Language  ([https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language](https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Domain-Specific Language for Building Self-Optimizing AST Interpreters ([http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One VM to Rule Them All ([http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-Performance Cross-Language Interoperability in a Multi-language Runtime
    ([https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf](https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a Language in Truffle ([http://cesquivias.github.io/index.html](http://cesquivias.github.io/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
