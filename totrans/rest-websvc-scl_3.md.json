["```java\n  lazy val unfilteredVersion = \"0.8.4\"\n  val backendDeps = Seq(\n    \"net.databinder\" %% \"unfiltered-filter\" % unfilteredVersion,\n    \"net.databinder\" %% \"unfiltered-jetty\" % unfilteredVersion\n  )\n```", "```java\npackage org.restwithscala.chapter3.gettingstarted\n\nimport unfiltered.request._\nimport unfiltered.response._\n\nobject HelloUnfiltered extends App {\n\n  // explicitly set the thread name. If not, the server can't be \n  // stopped easily when started from an IDE\n  Thread.currentThread().setName(\"swj\");\n\n  // Start a minimalistic server\n  val echo = unfiltered.filter.Planify {\n    case GET(Path(\"/hello\")) => ResponseString(\"Hello Unfiltered\")\n  }\n  unfiltered.jetty.Server.http(8080).plan(echo).run()\n\n  println(\"Press <enter> to exit.\")\n  Console.in.read.toChar\n\n}\n```", "```java\n<configuration>\n\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern> %d{HH:mm:ss.SSS}[%thread]%-5level%logger{36}-%msg%n\n            </pattern>\n        </encoder>\n    </appender>\n\n    <root level=\"INFO\">\n        <appender-ref ref=\"STDOUT\"/>\n    </root>\n</configuration>\n```", "```java\n$ sbt runCH03-HelloUnfiltered\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Running org.restwithscala.chapter3.gettingstarted.HelloUnfiltered \n10:04:32.108 [swj] INFO  org.eclipse.jetty.server.Server - jetty-8.1.13.v20130916\n10:04:32.178 [swj] INFO  o.e.jetty.server.AbstractConnector - Started SocketConnector@0.0.0.0:8080\nEmbedded server listening at\n http://0.0.0.0:8080\nPress any key to stop.\n\n```", "```java\npackage org.restwithscala.chapter3.steps\n\nimport unfiltered.request._\nimport unfiltered.response._\n\nobject Step1 extends App {\n\nThread.currentThread().setName(\"swj\");\n\n  object api extends unfiltered.filter.Plan {\n    def intent = taskApi.onPass(fallback)\n\n    def taskApi = unfiltered.filter.Intent {\n      case GET(Path(\"/tasks\")) \n            => ResponseString(s\"Get all tasks\" )\n      case GET(Path(Seg(\"tasks\" :: id :: Nil))) \n            => ResponseString(s\"Get a single task with id: $id\" )\n      case DELETE(Path(Seg(\"tasks\" :: id :: Nil)))   \n           => ResponseString\n                     (s\"Delete an existing task with id $id\")\n\n      case req @ Path(\"/tasks\") => req match {\n        case POST(_) \n          => ResponseString(s\"Create a new\" +\n                           s\" task with body ${Body.string(req)}\")\n        case PUT(_) \n          => ResponseString(s\"Update a new task with\" +\n                            s\" body ${Body.string(req)}\")\n        case _ => Pass\n      }\n      case _ => Pass\n    }\n\n    def fallback = unfiltered.filter.Intent {\n      case _ => NotImplemented ~> \n                ResponseString(\"Function is not implemented\")\n    }\n  }\n\n  unfiltered.jetty.Server.http(8080).plan(api).run()\n\n  println(\"Press <enter> to exit.\")\n  Console.in.read.toChar\n\n}\n```", "```java\n      case GET(Path(\"/tasks\")) \n            => ResponseString(s\"Get all tasks\" )\n      case GET(Path(Seg(\"tasks\" :: id :: Nil))) \n            => ResponseString(s\"Get a single task with id: $id\" )\n      case DELETE(Path(Seg(\"tasks\" :: id :: Nil))) \n            => ResponseString(s\"Delete an existing task with id $id\")\n```", "```java\nobject Custom extends Accepting {\n val contentType = \"application/vnd+company.category\"\n val ext = \"json\"\n}\n\n```", "```java\n   case req @ Path(\"/tasks\") => req match {\n        case POST(_) \n          => ResponseString(s\"Create a new\" +\n                            s\" task with body ${Body.string(req)}\")\n        case PUT(_) \n          => ResponseString(s\"Update a new task with\" +\n                            s\" body ${Body.string(req)}\")\n        case _ => Pass\n      }\n```", "```java\n  object api extends unfiltered.filter.Plan {\n    def intent = taskApi.onPass(fallback)\n\n    def taskApi = unfiltered.filter.Intent { ... }\n    def fallback = unfiltered.filter.Intent {\n      case _ => NotImplemented ~> \n                ResponseString(\"Function is not implemented\")\n    }\n```", "```java\n$ sbt runCH03-runCH03Step1\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Running org.restwithscala.chapter3.steps.Step1 \n15:06:36.085 [swj] INFO  org.eclipse.jetty.server.Server - jetty-8.1.13.v20130916\n15:06:36.160 [swj] INFO  o.e.jetty.server.AbstractConnector - Started SocketConnector@0.0.0.0:8080\nEmbedded server listening at\n http://0.0.0.0:8080\nPress any key to stop.\n\n```", "```java\nobject Step2 extends App {\n\n  implicit def ec = ExecutionContext.Implicits.global\n\n  @io.netty.channel.ChannelHandler.Sharable\n  object api extends future.Plan with ServerErrorResponse {\n\n    implicit def executionContext = ec\n\n    def intent =  {\n      case GET(Path(\"/tasks\")) => Future \n       {ResponseString(s\"Get all tasks\" )}\n      case GET(Path(Seg(\"tasks\" :: id :: Nil))) => Future \n       {ResponseString(s\"Get a single task with id: $id\" )}\n      case DELETE(Path(Seg(\"tasks\" :: id :: Nil))) => Future\n       {ResponseString(s\"Delete an existing task with id $id\")}\n\n      case req @ Path(\"/tasks\")) => req match {\n        case POST(_) => \n         handleCreateTask(req).map(ResponseString(_))\n        case PUT(_) => \n           handleCreateTask(req).map(ResponseString(_))\n        case _ => Future {Pass}\n      }\n\n      case _ => Future{Pass}\n    }\n  }\n  @io.netty.channel.ChannelHandler.Sharable\n  object fallback extends future.Plan with ServerErrorResponse {\n    implicit def executionContext = ec\n    def intent =  {\n      case _ => Future {NotImplemented ~> \n               ResponseString(\"Function is not implemented\")}\n    }\n  }\n\n  def handleCreateTask(req: HttpRequest[Any]): Future[String] = {\n    val task = requestToTask(TaskService.nextTaskId(), req)\n    val inserted = task map(TaskService.insert(_).map(_.toString))\n\n    inserted.getOrElse(Future{\"Error inserting\"})\n  }\n\n  def paramExtractor(param: String): Extract[String] = {\n     new Extract[String]( param, \n               Params.first ~> Params.nonempty ~> Params.trimmed)\n  }\n\n  def requestToTask(id: Long, req: HttpRequest[Any])\n                                         : Option[Task] = {\n    val title = paramExtractor(\"title\")\n\n    req match {\n      case Params(title(param)) => Some(Task(\n        id, param, Body.string(req),\n        None, List.empty[Note], Status(\"\")))\n\n      case _ => None\n    }\n  }\n\n  unfiltered.netty.Server.http(8080)\n         .handler(api)\n         .handler(fallback).run\n  dispatch.Http.shutdown()\n}\n```", "```java\ndef paramExtractor(param: String): Extract[String] = {\n   new Extract[String]( param, Params.first ~> Params.nonempty)\n}\n\ndef requestToTask(id: Long, req: HttpRequest[Any]): Option[Task] = {\n  val title = paramExtractor(\"title\")\n\n  req match {\n    case Params(title(param)) => Some(Task(\n      id,\n      param,\n      Body.string(req),\n      None,\n      List.empty[Note],\n    Status(\"\")))\n\n    case _ => None\n  }\n}\n```", "```java\ndef paramExtractor(param: String): Extract[String] = {\n   new Extract[String]( param, Params.first ~> Params.nonempty)\n}\n```", "```java\n  req match {\n    case Params(title(param)) => ...\n```", "```java\nval title = new Extract[String]( \"title\", Params.first ~> Params.nonempty)\nval amount  = new Extract[String]( \"amount\", Params.first ~> Params.nonempty ~> int)\n```", "```java\ncase Params(title(titleValue) & amount(amountValue))\n```", "```java\n    case Params(title(param)) => Some(Task(\n      id,\n      param,\n      Body.string(req),\n      None,\n      List.empty[Note],\n    Status(\"\")))\n```", "```java\n  case req @ Path(\"/tasks\") => req match {\n    case POST(_) => handleCreateTask(req).map(ResponseString(_))\n    case PUT(_) => handleCreateTask(req).map(ResponseString(_))\n    case _ => Future {Pass}\n  }\n\n  ...\n\n  def handleCreateTask(req: HttpRequest[Any]): Future[String] = {\n    val task = requestToTask(TaskService.nextTaskId(), req)\n    val insertedTask = task \n           map(TaskService.insert(_).map(_.toString))\n\n    insertedTask.getOrElse(Future{\"Error inserting\"})\n  }\n```", "```java\n    \"net.databinder\" %% \"unfiltered-netty\" % \"0.8.4\"\n    \"net.databinder\" %% \"unfiltered-netty-server\" % \"0.8.4\"\n```", "```java\n  implicit def ec = ExecutionContext.Implicits.global\n\n  @io.netty.channel.ChannelHandler.Sharable\n  object api extends future.Plan with ServerErrorResponse {\n\n    def executionContext = ec\n\n    def intent =  ..\n\n  }\n```", "```java\n  unfiltered.netty.Server.http(8080)\n      .handler(api)\n      .handler(fallback).run\n  dispatch.Http.shutdown()\n```", "```java\n      case GET(Path(\"/tasks\")) => Future \n       {ResponseString(s\"Get all tasks\" )}\n      case GET(Path(Seg(\"tasks\" :: id :: Nil))) => Future \n       {ResponseString(s\"Get a single task with id: $id\" )}\n      case DELETE(Path(Seg(\"tasks\" :: id :: Nil))) => Future\n       {ResponseString(s\"Delete an existing task with id $id\")}\n\n      case req @ Path(\"/tasks\")) => req match {\n        case POST(_) => \n         handleCreateTask(req).map(ResponseString(_))\n        case PUT(_) => handleCreateTask(req).map(ResponseString(_))\n        case _ => Future {Pass}\n      }\n\n      case _ => Future{Pass}\n```", "```java\nimport unfiltered.directives._, Directives._\n\nval intent = { Directive.Intent {\n  case Path(\"/\") =>\n    for {\n      _ <- Accepts.Json\n      _ <- GET\n      amount <- data.as.Option[Int].named(\"amount\") } yield JsonContent ~> ResponseString(\n          \"\"\"{ \"response\": \"Ok\" }\"\"\")\n}\n```", "```java\nimplicit val intValue =\n  data.as.String ~> data.as.Int.fail { (k,v) =>\n    BadRequest ~> ResponseString(\n      s\"'$v' is not a valid int for $k\"\n    )\n}\n```", "```java\n ...\n for {\n  value <- data.as.Int.named(\"amount\")\n } yield {...}\n```", "```java\nimplicit def required[T] = data.Requiring[T].fail(name =>\n  BadRequest ~> ResponseString(name + \" is missing\\n\")\n)\n```", "```java\n...\n for {\n  value <- data.as.Required[Int].named(\"amount\")\n } yield {...}\n```", "```java\npackage org.restwithscala.chapter3.steps\n\nimport org.restwithscala.common.model._\nimport org.restwithscala.common.service.TaskService\nimport unfiltered.directives.{Directive => UDirective, ResponseJoiner, data}\nimport unfiltered.request._\nimport unfiltered.response._\nimport unfiltered.netty._\nimport scala.concurrent.{ExecutionContext}\nimport scala.concurrent.Future\nimport scalaz._\nimport scalaz.std.scalaFuture._\n\nobject Step3 extends App {\n\n  /**\n   * Object holds all the implicit conversions used by Unfiltered to\n   * process the incoming requests.\n   */\n  object Conversions {\n\n  case class BadParam(msg: String) extends ResponseJoiner(msg)(\n    msgs =>\n      BadRequest ~> ResponseString(msgs.mkString(\"\",\"\\n\",\"\\n\"))\n  )\n\n    implicit def requiredJoin[T] = data.Requiring[T].fail(name =>\n      BadParam(name + \" is missing\")\n    )\n\n    implicit val toStringInterpreter = data.as.String\n\n    val allowedStatus = Seq(\"new\", \"done\", \"progress\")\n    val inStatus = data.Conditional[String](\n                        allowedStatus contains (_)).fail(\n      (k, v) => BadParam(s\" value not allowed: $v, should be one of ${allowedStatus.mkString(\",\")} \")\n    )\n  }\n\n  Thread.currentThread().setName(\"swj\");\n  implicit def ec = ExecutionContext.Implicits.global\n\n  // This plan contains the complete API. Works asynchronously\n  // directives by default don't work with futures. Using the d2\n  // directives, we can wrap the existing directives and use the\n  // async plan.\n  @io.netty.channel.ChannelHandler.Sharable\n  object api extends async.Plan with ServerErrorResponse {\n\n    // Import the required d2 directives so we can work\n    // with futures and directives together. We also bring\n    // the implicit directive conversions into scope.\n    val D = d2.Directives[Future]\n    import D._\n    import D.ops._\n    import Conversions._\n\n    // maps the requests so that we can use directives with the\n    // async intent. In this case we pass on the complete request\n    // to the partial function\n    val MappedAsyncIntent = d2.Async.Mapping[Any, HttpRequest[Any]] {\n      case req: HttpRequest[Any] => req\n    }\n\n    // d2 provides a function to convert standard Unfiltered\n    // directives to d2 directives. This implicit conversion\n    // makes using this easier by adding a toD2 function to\n    // the standard directives.\n    implicit class toD2[T, L, R](s: UDirective[T, L, R]) {\n      def toD2 = fromUnfilteredDirective(s)\n    }\n\n    // our plan requires an execution context,\n    def executionContext = ec\n    def intent = MappedAsyncIntent {\n      case Path(\"/search\") => handleSearchSingleError\n    }\n\n    def handleSearchSingleError = for {\n      status <- inStatus.named(\"status\").toD2\n      text1 <- data.as.Required[String].named(\"text\").toD2\n      tasks <- TaskService\n               .search(status.get,Some(text1)).successValue\n    } yield {Ok ~> ResponseString(tasks.toString()) }\n  }\n  unfiltered.netty.Server.http(8080).handler(api).run\n  dispatch.Http.shutdown()\n}\n```", "```java\n@io.netty.channel.ChannelHandler.Sharable\n  object api extends async.Plan with ServerErrorResponse {\n```", "```java\n    val D = d2.Directives[Future]\n    import D._\n    import D.ops._\n    import Conversions._\n```", "```java\n    val MappedAsyncIntent = d2.Async.Mapping[Any, HttpRequest[Any]] {\n      case req: HttpRequest[Any] => req\n    }\n```", "```java\n    def intent = MappedAsyncIntent {\n      case Path(\"/search\") => handleSearchSingleError\n    }\n```", "```java\n    implicit class toD2[T, L, R](s: UDirective[T, L, R]) {\n      def toD2 = fromUnfilteredDirective(s)\n    }\n```", "```java\n  object Conversions {\n\n    case class BadParam(msg: String) extends ResponseJoiner(msg)(\n      msgs =>\n        BadRequest ~> ResponseString(msgs.mkString(\"\",\"\\n\",\"\\n\"))\n    )\n\n    implicit def required[T] = data.Requiring[T].fail(name =>\n      BadParam(name + \" is missing\")\n    )\n\n    implicit val toStringInterpreter = data.as.String\n\n    val allowedStatus = Seq(\"new\", \"done\", \"progress\")\n    val inStatus = data.Conditional[String](\n                        allowedStatus contains (_)).fail(\n      (k, v) => BadParam(s\" value not allowed: $v, should\n                be one of ${allowedStatus.mkString(\",\")} \")\n    )\n  }\n```", "```java\n    def handleSearchSingleError = for {\n      status <- inStatus.named(\"status\").toD2\n      text1 <- data.as.Required[String].named(\"text\").toD2\n      tasks <- TaskService\n               .search(status.get,Some(text1)).successValue\n    } yield {Ok ~> ResponseString(tasks.toString()) }\n```", "```java\n    def handleSearchCombinedError = for {\n      (status, text) <- (\n             (data.as.Required[String].named(\"status\")) &\n             (data.as.Required[String].named(\"text\"))\n            ).toD2\n      tasks <- TaskService.search(status,Some(text)).successValue\n    } yield {\n        Ok ~> ResponseString(tasks.toString())\n```"]