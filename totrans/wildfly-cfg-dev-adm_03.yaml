- en: Chapter 3. Configuring Enterprise Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the configuration of the Java Enterprise services that
    ship with the application server. Many of the services are configured within their
    own subsystem. These subsystems can be added or removed depending on whether or
    not the service is required in your application. We will look at the most common
    ones in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Enterprise JavaBeans container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the messaging service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the transaction service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow your application to connect to a database, you will need to configure
    your server by adding a datasource. Upon server startup, each datasource is prepopulated
    with a pool of database connections. Applications acquire a database connection
    from the pool by doing a `JNDI` lookup and then calling `getConnection()`. Take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After the connection has been used, you should always call `connection.close()`
    as soon as possible. This frees the connection and allows it to be returned to
    the connection pool—ready for other applications or processes to use.
  prefs: []
  type: TYPE_NORMAL
- en: Releases prior to JBoss AS 7 required a datasource configuration file (`ds.xml`)
    to be deployed with the application. Ever since the release of JBoss AS 7, this
    approach has no longer been mandatory due to the modular nature of the application
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, the application server ships with the H2 open source database
    engine ([http://www.h2database.com](http://www.h2database.com)), which, because
    of its small footprint and browser-based console, is ideal for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: However, a real-world application requires an industry-standard database, such
    as the Oracle database or MySQL. In the following section, we will show you how
    to configure a datasource for the MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any database configuration requires a two step procedure, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JDBC driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the datasource to your configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each section in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JDBC driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In WildFly's modular server architecture, you have a couple of ways to install
    your JDBC driver. You can install it either as a module or as a deployment unit.
  prefs: []
  type: TYPE_NORMAL
- en: The first and recommended approach is to install the driver as a module. In
    the *Installing the driver as a deployment unit* section, we will look at a faster
    approach to installing the driver. However, it does have various limitations,
    which we will cover shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please see the source code for this chapter for the complete module example.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to install a new module is to create the directory structure
    under the modules folder. The actual path for the module is `JBOSS_HOME/modules/<module>/main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` folder is where all the key module components are installed, namely,
    the driver and the `module.xml` file. So, next, we need to add the following units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JBOSS_HOME/modules/com/mysql/main/mysql-connector-java-5.1.30-bin.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JBOSS_HOME/modules/com/mysql/main/module.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL JDBC driver used in this example, also known as Connector/J, can be
    downloaded for free from the MySQL site ([http://dev.mysql.com/downloads/connector/j/](http://dev.mysql.com/downloads/connector/j/)).
    At the time of writing, the latest version is 5.1.30.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to do is to create the `module.xml` file. This file contains
    the actual module definition. It is important to make sure that the module name
    (`com.mysql`) corresponds to the `module` attribute defined in the your datasource.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must also state the path to the JDBC driver resource and finally add the
    module dependencies, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a diagram showing the final directory structure of this new module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the JDBC driver](img/6232OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that there is a directory structure already within the `modules`
    folder. All the system libraries are housed inside the `system/layers/base` directory.
    Your custom modules should be placed directly inside the `modules` folder and
    not with the system modules.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a local datasource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the JDBC driver is installed, you need to configure the datasource within
    the application server's configuration file. In WildFly, you can configure two
    kinds of datasources, **local** **datasources** and **xa-datasources**, which
    are distinguishable by the element name in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A local datasource does not support two-phase commits using a `java.sql.Driver`.
    On the other hand, an xa-datasource supports two-phase commits using a `javax.sql.XADataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a datasource definition can be completed by adding the datasource definition
    within the server configuration file or by using the management interfaces. The
    management interfaces are the recommended way, as they will accurately update
    the configuration for you, which means that you do not need to worry about getting
    the correct syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to add the datasource by modifying the server
    configuration file directly. Although this is not the recommended approach, it
    will allow you to get used to the syntax and layout of the file. In [Chapter 7](ch07.html
    "Chapter 7. Using the Management Interfaces"), *Using the Management Interfaces*,
    we will show you how to add a datasource using the management tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample MySQL datasource configuration that you can copy into your
    datasources subsystem section within the `standalone.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the configuration file uses the same XML schema definition from
    the earlier `-*.ds.xml` file, so it will not be difficult to migrate to WildFly
    from previous releases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In WildFly, it's mandatory that the datasource is bound into the `java:/` or
    `java:jboss/` JNDI namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the various elements of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connection-url`: This element is used to define the connection path to the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver`: This element is used to define the JDBC driver class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pool`: This element is used to define the JDBC connection pool properties.
    In this case, we are going to leave the default values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security`: This element is used to configure the connection credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statement`: This element is added just as a placeholder for statement-caching
    options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: This element is optional and contains a set of other elements, such
    as `query-timeout`, which is a static configuration of the maximum seconds before
    a query times out. Also the included `idle-timeout-minutes` element indicates
    the maximum time a connection may be idle before being closed; setting it to `0`
    disables it, and the default is `15` minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the connection pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One key aspect of the datasource configuration is the `pool` element. You can
    use connection pooling without modifying any of the existing WildFly configurations,
    as, without modification, WildFly will choose to use default settings. If you
    want to customize the pooling configuration, for example, change the pool size
    or change the types of connections that are pooled, you will need to learn how
    to modify the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of pool configuration, which can be added to your datasource
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The attributes included in the `pool` configuration are actually borrowed from
    earlier releases, so we include them here for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `initial-pool-size` | This means the initial number of connections a pool
    should hold (default is `0` (zero)). |'
  prefs: []
  type: TYPE_TB
- en: '| `min-pool-size` | This is the minimum number of connections in the pool (default
    is `0` (zero)). |'
  prefs: []
  type: TYPE_TB
- en: '| `max-pool-size` | This is the maximum number of connections in the pool (default
    is `20`). |'
  prefs: []
  type: TYPE_TB
- en: '| `prefill` | This attempts to prefill the connection pool to the minimum number
    of connections. |'
  prefs: []
  type: TYPE_TB
- en: '| `use-strict-min` | This determines whether idle connections below `min-pool-size`
    should be closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `allow-multiple-users` | This determines whether multiple users can access
    the datasource through the `getConnection` method. This has been changed slightly
    in WildFly. In WildFly, the line `<allow-multiple-users>true</allow-multiple-users>`
    is required. In JBoss AS 7, the empty element `<allow-multiple-users/>` was used.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `capacity` | This specifies the capacity policies for the pool—either `incrementer`
    or `decrementer`. |'
  prefs: []
  type: TYPE_TB
- en: '| `connection-listener` | Here, you can specify `org.jboss.jca.adapters.jdbc.spi.listener.ConnectionListener`
    that allows you to listen for connection callbacks, such as activation and passivation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `flush-strategy` | This specifies how the pool should be flushed in the event
    of an error (default is `FailingConnectionsOnly`). |'
  prefs: []
  type: TYPE_TB
- en: Configuring the statement cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For each connection within a connection pool, the WildFly server is able to
    create a statement cache. When a prepared statement or callable statement is used,
    WildFly will cache the statement so that it can be reused. In order to activate
    the statement cache, you have to specify a value greater than `0` within the `prepared-statement-cache-size`
    element. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have also set `track-statements` to `true`. This will enable
    automatic closing of `statements` and `ResultSets`. This is important if you want
    to use prepared statement caching and/or don't want to prevent cursor leaks.
  prefs: []
  type: TYPE_NORMAL
- en: The last element, `share-prepared-statements`, can only be used when the prepared
    statement cache is enabled. This property determines whether two requests in the
    same transaction should return the same statement (default is `false`).
  prefs: []
  type: TYPE_NORMAL
- en: Adding an xa-datasource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding an `xa-datasource` requires some modification to the datasource configuration.
    The `xa-datasource` is configured within its own element, that is, within the
    datasource. You will also need to specify the `xa-datasource` class within the
    `driver` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will add a configuration for our MySQL JDBC driver,
    which will be used to set up an `xa-datasource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Datasource versus xa-datasource**'
  prefs: []
  type: TYPE_NORMAL
- en: You should use an xa-datasource in cases where a single transaction spans multiple
    datasources, for example, if a method consumes a **Java Message Service** (**JMS**)
    and updates a **Java Persistence API** (**JPA**) entity.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the driver as a deployment unit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the WildFly application server, every library is a module. Thus, simply deploying
    the JDBC driver to the application server will trigger its installation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the JDBC driver consists of more than a single JAR file, you will not be
    able to install the driver as a deployment unit. In this case, you will have to
    install the driver as a core module.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to install the database driver as a deployment unit, simply copy the `mysql-connector-java-5.1.30-bin.jar`
    driver into the `JBOSS_HOME/standalone/deployments` folder of your installation,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the driver as a deployment unit](img/6232OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have deployed your JDBC driver, you still need to add the datasource
    to your server configuration file. The simplest way to do this is to paste the
    following datasource definition into the configuration file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use the **command-line interface** (**CLI**) or the web
    administration console to achieve the same result, as shown later in [Chapter
    7](ch07.html "Chapter 7. Using the Management Interfaces"), *Using the Management
    Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What about domain deployment?**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are discussing the configuration of standalone servers.
    The services can also be configured in the domain servers. Domain servers, however,
    don't have a specified folder scanned for deployment. Rather, the management interfaces
    are used to inject resources into the domain. [Chapter 5](ch05.html "Chapter 5. Configuring
    a WildFly Domain"), *Configuring a WildFly Domain*, will detail all the steps
    to deploy a module when using a domain server.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right driver deployment strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you might wonder about a best practice for deploying the JDBC
    driver. Installing the driver as a deployment unit is a handy shortcut; however,
    it can limit its usage. Firstly, it requires a JDBC 4-compliant driver.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a non-JDBC-4-compliant driver is possible, but it requires a simple
    patching procedure. To do this, create a `META-INF/services` structure containing
    the `java.sql.Driver` file. The content of the file will be the driver name. For
    example, let's suppose you have to patch a MySQL driver—the content will be `com.mysql.jdbc.Driver`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your structure, you can package your JDBC driver with
    any zipping utility or the `.jar` command, `jar -uf <your -jdbc-driver.jar> META-INF/services/java.sql.Driver`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most current JDBC drivers are compliant with JDBC 4 although, curiously,
    not all are recognized as such by the application server. The following table
    describes some of the most used drivers and their JDBC compliance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Driver | JDBC 4 compliant | Contains java.sql.Driver |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL | `mysql-connector-java-5.1.30-bin.jar` | Yes, though not recognized
    as compliant by WildFly | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| PostgreSQL | `postgresql-9.3-1101.jdbc4.jar` | Yes, though not recognized
    as compliant by WildFly | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle | `ojdbc6.jar`/`ojdbc5.jar` | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle | `ojdbc4.jar` | No | No |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the most notable exception to the list of drivers is the older
    Oracle `ojdbc4.jar`, which is not compliant with JDBC 4 and does not contain the
    driver information in `META-INF/services/java.sql.Driver`.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue with driver deployment is related to the specific case of xa-datasources.
    Installing the driver as deployment means that the application server by itself
    cannot deduce the information about the `xa-datasource` class used in the driver.
    Since this information is not contained inside `META-INF/services`, you are forced
    to specify information about the `xa-datasource` class for each xa-datasource
    you are going to create.
  prefs: []
  type: TYPE_NORMAL
- en: When you install a driver as a module, the `xa-datasource` class information
    can be shared for all the installed datasources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, if you are not too limited by these issues, installing the driver as a deployment
    is a handy shortcut that can be used in your development environment. For a production
    environment, it is recommended that you install the driver as a static module.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a datasource programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After installing your driver, you may want to limit the amount of application
    configuration in the server file. This can be done by configuring your datasource
    programmatically This option requires zero modification to your configuration
    file, which means greater application portability. The support to configure a
    datasource programmatically is one of the cool features of Java EE that can be
    achieved by using the `@DataSourceDefinition` annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined a datasource for an Oracle database. It's important
    to note that, when configuring a datasource programmatically, you will actually
    bypass JCA, which proxies requests between the client and the connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious advantage of this approach is that you can move your application
    from one application server to another without the need for reconfiguring its
    datasources. On the other hand, by modifying the datasource within the configuration
    file, you will be able to utilize the full benefits of the application server,
    many of which are required for enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Enterprise JavaBeans container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Enterprise** **JavaBeans** (**EJB**) container is a fundamental part of
    the Java Enterprise architecture. The EJB container provides the environment used
    to host and manage the EJB components deployed in the container. The container
    is responsible for providing a standard set of services, including caching, concurrency,
    persistence, security, transaction management, and locking services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container also provides distributed access and lookup functions for hosted
    components, and it intercepts all method invocations on hosted components to enforce
    declarative security and transaction contexts. Take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the Enterprise JavaBeans container](img/6232OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As depicted in this image, you will be able to deploy the full set of EJB components
    within WildFly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless session bean (SLSB)**: SLSBs are objects whose instances have no
    conversational state. This means that all bean instances are equivalent when they
    are not servicing a client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateful session bean (SFSB)**: SFSBs support conversational services with
    tightly coupled clients. A stateful session bean accomplishes a task for a particular
    client. It maintains the state for the duration of a client session. After session
    completion, the state is not retained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven bean (MDB)**: MDBs are a kind of enterprise beans that are
    able to asynchronously process messages sent by any JMS producer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton EJB**: This is essentially similar to a stateless session bean;
    however, it uses a single instance to serve the client requests. Thus, you are
    guaranteed to use the same instance across invocations. Singletons can use a set
    of events with a richer life cycle and a stricter locking policy to control concurrent
    access to the instance. In the next chapter, which is about web applications,
    we will illustrate a Java EE 7 application that makes use of a Singleton EJB to
    hold some cached data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No-interface EJB**: This is just another view of the standard session bean,
    except that local clients do not require a separate interface, that is, all public
    methods of the bean class are automatically exposed to the caller. Interfaces
    should only be used in EJB 3.x if you have multiple implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous EJB**: These are able to process client requests asynchronously
    just like MDBs, except that they expose a typed interface and follow a more complex
    approach to processing client requests, which are composed of:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fire-and-forget` asynchronous void methods, which are invoked by the client
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `retrieve-result-later` asynchronous methods having a `Future<?>` return
    type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: EJB components that don't keep conversational states (SLSB and MDB) can be optionally
    configured to emit timed notifications. See the *Configuring the timer service*
    section for more information about it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the EJB components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have briefly outlined the basic types of EJB, we will look at the
    specific details of the application server configuration. This comprises the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: The SLSB configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SFSB configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MDB configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Timer service configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see them all in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the stateless session beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: EJBs are configured within the `ejb3.2.0` subsystem. By default, no stateless
    session bean instances exist in WildFly at startup time. As individual beans are
    invoked, the EJB container initializes new SLSB instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'These instances are then kept in a pool that will be used to service future
    EJB method calls. The EJB remains active for the duration of the client''s method
    call. After the method call is complete, the EJB instance is returned to the pool.
    Because the EJB container unbinds stateless session beans from clients after each
    method call, the actual bean class instance that a client uses can be different
    from invocation to invocation. Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the stateless session beans](img/6232OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If all instances of an EJB class are active and the pool's maximum pool size
    has been reached, new clients requesting the EJB class will be blocked until an
    active EJB completes a method call. Depending on how you have configured your
    stateless pool, an acquisition timeout can be triggered if you are not able to
    acquire an instance from the pool within a maximum time.
  prefs: []
  type: TYPE_NORMAL
- en: You can either configure your session pool through your main configuration file
    or programmatically. Let's look at both approaches, starting with the main configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to configure your pool, you can operate on two parameters: the maximum
    size of the pool (`max-pool-size`) and the instance acquisition timeout (`instance-acquisition-timeout`).
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have configured the SLSB pool with a *strict* upper limit
    of `25` elements. The strict maximum pool is the only available pool instance
    implementation; it allows a fixed number of concurrent requests to run at one
    time. If there are more requests running than the pool's strict maximum size,
    those requests will get blocked until an instance becomes available. Within the
    pool configuration, we have also set an `instance-acquisition-timeout` value of
    `5` minutes, which will come into play if your requests are larger than the pool
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure as many pools as you like. The pool used by the EJB container
    is indicated by the attribute `pool-name` on the `bean-instance-pool-ref` element.
    For example, here we have added one more pool configuration, `largepool`, and
    set it as the EJB container''s pool implementation. Have a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using CLI to configure the stateless pool size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have detailed the steps necessary to configure the SLSB pool size through
    the main configuration file. However, the suggested best practice is to use CLI
    to alter the server model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can add a new pool named `large-pool` to your EJB 3 subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can set this pool as the default to be used by the EJB container,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can, at any time, change the pool size property by operating on
    the `max-pool-size` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the stateful session beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SFSBs are bound to a particular client. The application server uses a cache
    to store active EJB instances in memory so that they can be quickly retrieved
    for future client requests. The cache contains EJBs that are currently in use
    by a client and instances that were recently in use. Take a look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the stateful session beans](img/6232OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Having EJBs in memory is a costly operation, so you should move them out of
    memory as soon as possible by either passivating them or removing them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passivation** is a process by which the EJB container ensures that idle SFSB
    instances are freed from the cache by having their state saved to disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing a bean from the cache, on the other hand, is a process that can be
    triggered programmatically for the EJB container. To remove the EJB programmatically,
    add the `@javax.ejb.Remove` annotation to your method. When this method is invoked,
    the EJB will be removed. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows a section of the `ejb3:2.0` subsystem, which shows
    the configuration of a SFSB along with its cache and passivation store configuration.
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the stateful bean element references a cache definition (named
    `distributable`), which in turn is connected to a passivation store (named `infinispan`).
    Notice the optional `max-size` attribute that limits the amount of SFSBs that
    can be contained in the cache. You can also see that the clustered cache uses
    infinispan's `passivation-store` (see [Chapter 8](ch08.html "Chapter 8. Clustering"),
    *Clustering*, for more information about the infinispan cache).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In WildFly, the `file-passivation-store` and `cluster-passivation-store` elements
    have been deprecated in favor of `passivation-store`. Both deprecated elements
    will be removed completely in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the message-driven beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Message-driven** **beans** (**MDBs**) are stateless, server-side, transaction-aware
    components that are used to process asynchronous JMS messages.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important aspects of MDBs is that they can consume and process
    messages concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: This capability provides a significant advantage over traditional JMS clients,
    which must be custom-built to manage resources, transactions, and security in
    a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as the session beans have well-defined life cycles, so does an MDB. The
    MDB instance''s life cycle is pretty much the same as the stateless bean. An MDB
    has two states: **Does not Exist** and **Method ready Pool**. Take a look at the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the message-driven beans](img/6232OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a message is received, the EJB container checks whether any MDB instance
    is available in the pool. If a bean is available, WildFly uses that instance.
    After an MDB instance's `onMessage()` method returns, the request is complete,
    and the instance is placed back in the pool. This results in the best response
    time, as the request is served without waiting for a new instance to be created.
  prefs: []
  type: TYPE_NORMAL
- en: If no bean instances are available, the container checks whether there is room
    for more MDBs in the pool by comparing the MDB's `MaxSize` attribute with the
    pool size.
  prefs: []
  type: TYPE_NORMAL
- en: If `MaxSize` still has not been reached, a new MDB is initialized. The creation
    sequence, as pointed out in the preceding diagram, is the same as that of the
    stateless bean. Failure to create a new instance, on the other hand, will imply
    that the request will be blocked until an active MDB completes. If the request
    cannot acquire an instance from the pool within the time defined in `instance-acquisition-timeout`,
    an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of the MDB pool is exactly the same as for the SLSB, so we
    will just include it here without further explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the various types of enterprise beans, you can refer to
    the Java EE 7 tutorial at [http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm](http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the timer service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The EJB 3 timer service provides a way to allow methods to be invoked at specific
    times or time intervals. This is useful should your application business process
    need periodic notifications.
  prefs: []
  type: TYPE_NORMAL
- en: The EJB timer service can be used in any type of EJB 3, except for stateful
    session beans. Using the timer services is as simple as annotating a method with
    `@javax.ejb.Timeout`. This method will then be triggered by the container when
    the time interval expires.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to implement a very simple timer, which
    will be started by invoking the `scheduleTimer(long milliseconds)` method. Take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As far as configuration is concerned, you can store planned executions within
    the filesystem or in a database. To save them in the filesystem, you need to reference
    the `default-data-store` attribute from the `file-data-store` attribute (both
    called `file-store` in this example). The number of threads reserved for the timer
    service can be configured with the `thread-pool-name` attribute, which needs to
    reference a `thread-pool` element. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the messaging system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Message-oriented middleware has always been an integral part of the application
    server. Messaging systems allow you to loosely couple heterogeneous systems together
    while typically providing reliability, transactions, and many other features.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging is not part of the Java EE web profile, so you will not find a configuration
    for the messaging subsystem in the `standalone.xml` file. However, the messaging
    subsystem is included in the configuration file named `standalone-full.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Messaging systems normally support two main styles of asynchronous messaging:
    **Queues** (point-to-point messaging) and **Topics** (publish/subscribe messaging).'
  prefs: []
  type: TYPE_NORMAL
- en: In the point-to-point model, a sender posts messages to a particular queue,
    and a receiver reads messages from the queue. Here, the sender knows the destination
    of the message and posts the message directly to the receiver's queue.
  prefs: []
  type: TYPE_NORMAL
- en: The publish/subscribe model supports the publishing of messages to a particular
    message topic. Subscribers may register interest in receiving messages on a particular
    message topic. In this model, neither the publisher nor the subscriber know about
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the characteristics of the two different models:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Point-to-point messaging | Publish/Subscribe |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Only one consumer gets the message. | Multiple consumers (or none) will receive
    the message. |'
  prefs: []
  type: TYPE_TB
- en: '| The producer does not need to run at the time the consumer consumes the message,
    nor does the consumer need to run at the time the message is sent. | The publisher
    has to create a message topic for clients to subscribe. The subscriber has to
    remain continuously active to receive messages unless he has established a durable
    subscription. In that case, messages published while the subscriber is not connected
    will be redistributed whenever he reconnects. |'
  prefs: []
  type: TYPE_TB
- en: '| Every message successfully processed is acknowledged by the consumer. |'
  prefs: []
  type: TYPE_TB
- en: JBoss AS has used different JMS implementations across its releases. Since the
    release of Version 6.0, the default JMS provider is HornetQ ([http://www.jboss.org/hornetq](http://www.jboss.org/hornetq)),
    which provides a multi-protocol, embeddable, high-performance, clustered, asynchronous
    messaging system.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, HornetQ is designed simply as a set of **Plain** **Old** **Java**
    **Objects** (**POJOs**). It has only one JAR dependency, the Netty library, which
    leverages the Java **Non-blocking** **Input/Output** (**NIO**) API to build high-performance
    network applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of its easily adaptable architecture, HornetQ can be embedded in your
    own project or instantiated in any dependency injection framework, such as Spring
    or Google Guice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will cover the scenario where HornetQ is embedded into a WildFly
    subsystem as a module. The following diagram shows how the HornetQ server fits
    in the overall picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the messaging system](img/6232OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a key part of the HornetQ integration is the **JCA** **Adaptor**
    that handles the communication between the application server and the HornetQ
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why can''t you simply connect your resources to the HornetQ server?**'
  prefs: []
  type: TYPE_NORMAL
- en: This is theoretically possible; however, it violates Java EE specifications
    and will result in the loss of functionalities provided by the application server's
    JCA layer, such as connection pooling and automatic transaction enlistment. These
    functionalities are desirable when using messaging, say, from inside an EJB. For
    a description of JCA thread-pooling configuration, refer to the *The bounded-queue
    thread pool* section in [Chapter 2](ch02.html "Chapter 2. Configuring the Core
    WildFly Subsystems"), *Configuring the Core WildFly Subsystems*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the transport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuring the transport of a JMS message is a key part of the messaging system
    tuning. Out of the box, HornetQ uses Netty as its high-performance, low-level
    network library. Netty is a NIO client-server framework, which enables quick and
    easy development of network applications, such as **protocol** **servers** and
    **clients**. It greatly simplifies and streamlines network programming, such as
    those of the TCP and UDP socket servers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important concepts in HornetQ transport is the definition of
    acceptors and connectors.
  prefs: []
  type: TYPE_NORMAL
- en: An **acceptor** defines which type of connection is accepted by the HornetQ
    server. On the other hand, a **connector** defines how to connect to a HornetQ
    server. The connector is used by a HornetQ client.
  prefs: []
  type: TYPE_NORMAL
- en: 'HornetQ defines three types of acceptors and connectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**inVM**: This type can be used when both the HornetQ client and the server
    run in the same virtual machine (inVM stands for intra virtual machine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Netty**: This type defines a way for remote connections to be made over TCP
    (uses the Netty project to handle the I/O)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http**: This type is the default configuration in WildFly and defines a way
    for remote connections to be made to HornetQ over HTTP (it uses Undertow to upgrade
    from the HTTP protocol to the HornetQ protocol)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To communicate, a HornetQ client must use a connector compatible with the server''s
    acceptor. A compatible client-server communication requires that it is carried
    out using the same type of acceptor/connector shown by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the transport](img/6232OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that it's not possible to connect an InVM client connector to a Netty
    server acceptor. On the other hand, it's possible to connect a HTTP client connector
    to a HTTP server acceptor provided they are configured to run on the same host
    and port.
  prefs: []
  type: TYPE_NORMAL
- en: 'WildFly 8 comes with a preconfigured acceptor/connector pair that is part of
    the WildFly messaging subsystem, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, besides the `in-vm` acceptor/connector pair, each section defines
    two kinds of acceptors/connectors, one of which relies on the default configuration,
    `http-connector`, and the other one (`http-acceptor-throughput`) is specialized
    for higher messaging throughputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can further tune HTTP transport when you have a more complete knowledge
    of the parameters that can be added to the acceptor/connector section. Here''s
    a comprehensive list of all parameters and their meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `use-nio` | If this is `true`, then Java non-blocking I/O will be used. If
    set to `false`, then the old blocking Java I/O will be used. The default value
    is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `host` | This specifies the host name or IP address to connect to (when configuring
    a connector) or to listen on (when configuring an acceptor). The default value
    for this property is `localhost`. Multiple hosts or IP addresses can be specified
    by separating them with commas. |'
  prefs: []
  type: TYPE_TB
- en: '| `port` | This specifies the port to connect to (when configuring a connector)
    or to listen on (when configuring an acceptor). The default value for this property
    is `5445`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tcp-no-delay` | If this is `true`, then Nagle''s algorithm will be disabled.
    The default value for this property is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tcp-send-buffer-size` | This parameter determines the size of the TCP send
    buffer in bytes. The default value for this property is `32768` bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `tcp-receive-buffer-size` | This parameter determines the size of the TCP
    receive buffer in bytes. The default value for this property is `32768` bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `batch-delay` | This parameter lets you configure HornetQ so that messages
    are batched up to be written for a maximum of batch-delay milliseconds before
    sending them for transport. This can increase overall throughput for very small
    messages. The default value for this property is `0` ms. |'
  prefs: []
  type: TYPE_TB
- en: '| `direct-deliver` | This parameter lets you configure whether message delivery
    is done using the same thread as the one that carried the message. Setting this
    to `true` (default) reduces the thread context switch''s latency at the expense
    of message throughput. If your goal is a higher throughput, set this parameter
    to `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `nio-remoting-threads` | When using NIO, HornetQ will, by default, use a
    number of threads equal to three times the number of core processors required
    to process incoming packets. If you want to override this value, you can set the
    number of threads by specifying this parameter. The default value for this parameter
    is `-1`, which means use the value derived from `Runtime.getRuntime().availableProcessors()
    * 3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `http-client-idle-time` | This determines how long a client can be idle before
    sending an empty HTTP request to keep the connection alive. |'
  prefs: []
  type: TYPE_TB
- en: '| `http-client-idle-scan-period` | This determines how often we can scan for
    idle clients, in milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `http-response-time` | This determines how long the server can wait before
    sending an empty HTTP response to keep the connection alive. |'
  prefs: []
  type: TYPE_TB
- en: '| `http-server-scan-period` | This determines how often we can scan for clients
    needing responses, in milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `http-requires-session-id` | If `true`, the client will wait after the first
    call to receive a session ID. |'
  prefs: []
  type: TYPE_TB
- en: 'One frequent source of confusion among HornetQ users is why connectors are
    included in the server configuration if the server is in charge of accepting connections
    and delivering messages. There are two main reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the server acts as a client itself when it connects to another server,
    for example, when one server is bridged to another or when a server takes part
    in a cluster. In these cases, the server needs to know how to connect to other
    servers. That's defined by connectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're using JMS and the server-side JMS services to instantiate JMS `ConnectionFactory`
    instances and bind them in JNDI then, when creating the `HornetQConnectionFactory`,
    it needs to know what server that connection factory will create connections to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring connection factories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A JMS `ConnectionFactory` object is used by the client to make connections
    to the server. The definition of `connection-factory` instances is included in
    the default server configuration. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find two connection factory definitions, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InVmConnectionFactory`: This connection factory is bound under `java:/ConnectionFactory`
    and is used when the server and the client are running in the same JVM (and hence
    in the same WildFly server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoteConnectionFactory`: This connection factory, as the name implies, can
    be used when JMS connections are provided by a remote server. By default, this
    uses `http-connector` and is bound by the JNDI name, `java:jboss/exported/jms/RemoteConnectionFactory`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring JMS destinations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Along with the definition of connection factories in the JMS subsystem, you
    can find the JMS destinations (queues and topics), which are part of the server
    distribution. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `name` attribute of a queue defines the name of the queue. At the JMS level,
    the actual name of the queue follows a naming convention, so it will be `jms.queue.ExpiryQueue`.
  prefs: []
  type: TYPE_NORMAL
- en: The `entry` element configures the name that will be used to bind the queue
    to JNDI. This is a mandatory element, and the queue can contain many of these
    to bind the same queue to different names.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, here''s how you would configure a `MessageDrivenBean` component
    to consume messages from the `ExpiryQueue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why is it useful to know the actual destination name?**'
  prefs: []
  type: TYPE_NORMAL
- en: Apparently, it seems not important at all to know the server's destination name
    (in the example, `jms.queue.ExpiryQueue`). Rather, we would be concerned about
    the JNDI entry where the destination is bound. However, the actual destination
    name plays an important role if you want to define some properties across a set
    of destinations. See the next section, *Customizing destinations with an address*,
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Queues and topic definitions can optionally include some non-mandatory elements,
    such as `selector` and `durable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `selector` element defines what JMS message selector the predefined queue
    will have. Only messages that match the selector will be added to the queue. This
    is an optional element with a default value of `null` when omitted.
  prefs: []
  type: TYPE_NORMAL
- en: The `durable` element specifies whether or not the queue will be persisted.
    This again is optional and defaults to `true` if omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing destinations with an address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to provide some custom settings for JMS destinations, you can use
    the `address-setting` block, which can be applied both to a single destination
    and to a set of destinations. The default configuration applies a set of minimal
    attributes to all destinations. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here is a brief description of the address settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The address setting''s `match` attribute defines a filter for the destinations.
    When using the wildcard, `#`, the properties will be valid across all destinations.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the settings would apply to all queues defined in the `destination` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The settings would apply to the queue named `jms.queue.ExpiryQueue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A short description of the destination''s properties is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dead-letter-address` | This specifies the destination for messages that
    could not be delivered. |'
  prefs: []
  type: TYPE_TB
- en: '| `expiry-address` | This defines where to send a message that has expired.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `expiry-delay` | This defines the expiration time that will be used for messages
    using the default expiration time. |'
  prefs: []
  type: TYPE_TB
- en: '| `redelivery-delay` | This defines how long to wait before attempting redelivery
    of a cancelled message. |'
  prefs: []
  type: TYPE_TB
- en: '| `max-size-bytes` | This specifies the maximum size of the message in bytes
    before entering the `page` mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `page-size-bytes` | This specifies the size of each page file used on the
    paging system. |'
  prefs: []
  type: TYPE_TB
- en: '| `max-delivery-attempts` | This defines how many times a cancelled message
    can be redelivered before it is sent to the `dead-letter-address`. |'
  prefs: []
  type: TYPE_TB
- en: '| `message-counter-history-day-limit` | This specifies how many days the message
    counter history will be kept. |'
  prefs: []
  type: TYPE_TB
- en: '| `address-full-policy` | This is used when a destination maximum size is reached.
    When set to `PAGE`, further messages will be paged to the disk. If the value is
    `DROP`, further messages will be silently dropped. When `BLOCK` is used, client
    message producers will be blocked when they try to send further messages. |'
  prefs: []
  type: TYPE_TB
- en: HornetQ persistence configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last HornetQ topic we need to cover is message persistence. HornetQ has
    its own optimized persistence engine, which can be further configured when you
    know all about its various components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The secret of HornetQ's high data persistence consists in appending data to
    the journal files instead of using the costly random-access operations, which
    require a higher degree of disk-head movement.
  prefs: []
  type: TYPE_NORMAL
- en: Journal files are precreated and filled with padding characters at runtime.
    By precreating files, as one is filled, the journal can immediately resume with
    the next one without pausing to create it.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the default journal values for the messaging subsystem. Although
    these values are not explicitly set in the `standalone-full.xml` file, their absence
    causes these default values to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The default `journal-file-size` (expressed in bytes) is `100` KB. The minimum
    number of files the journal will maintain is indicated by the property `journal-min-files`,
    which states that at least two files will be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: The property `journal-type` indicates the type of input/output libraries used
    for data persistence. The valid values are `NIO` or `ASYNCIO`.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing `NIO` sets the Java NIO journal. Choosing `AIO` sets the Linux asynchronous
    I/O journal. If you choose `AIO` but are not running Linux or you do not have
    `libaio` installed, then HornetQ will detect this and automatically fall back
    to using `NIO`.
  prefs: []
  type: TYPE_NORMAL
- en: The `persistence-enabled` property, when set to `false`, will disable message
    persistence. That means no binding data, message data, large message data, duplicate
    ID caches, or paging data will be persisted. Disabling data persistence will give
    to your applications a remarkable performance boost; however, the other side of
    it is that your data messaging will inevitably lose reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, we include some additional properties that can
    be included if you want to customize the messages/paging and journal storage directories.
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For best performance, we recommend that the journal be located on its own physical
    volume in order to minimize disk-head movement. If the journal is on a volume
    that is shared with other processes, which might be writing other files (for example,
    bindings journal, database, or transaction coordinator), then the disk-head might
    move rapidly between these files as it writes them, thus drastically reducing
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the transactions service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A transaction can be defined as a group of operations that must be performed
    as a unit and can involve persisting data objects, sending a message, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When the operations in a transaction are performed across databases or other
    resources that reside on separate computers or processes, this is known as a distributed
    transaction. Such enterprise-wide transactions require special coordination between
    the resources involved and can be extremely difficult to program reliably. This
    is where **Java Transaction API** (**JTA**) comes in, providing the interface
    that resources can implement and to which they can bind in order to participate
    in a distributed transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The EJB container is a transaction manager that supports JTA and so can participate
    in distributed transactions involving other EJB containers as well as third-party
    JTA resources, such as many database management systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within WildFly 8, transactions are configured in their own subsystem. The transactions
    subsystem consists mainly of four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Core environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovery environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinator environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The core environment includes the `TransactionManager` interface, which allows
    the application server to control the transaction boundaries on behalf of the
    resource being managed. Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the transactions service](img/6232OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A transaction coordinator, in turn, manages communication with transactional
    objects and resources that participate in transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The recovery subsystem of JBossTS ensures that the results of a transaction
    are applied consistently to all resources affected by the transaction even if
    any of the application processes or the machine hosting them crashes or loses
    network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Within the transaction service, JBoss transaction service uses an object store
    to persistently record the outcomes of transactions for failure recovery. As a
    matter of fact, the recovery manager scans the object store and other locations
    of information looking for transactions and resources that require or might require
    recovery.
  prefs: []
  type: TYPE_NORMAL
- en: The core and recovery environments can be customized by changing their socket-binding
    properties, which are referenced in the `socket-binding-group` configuration section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might find it more useful to define custom properties in the coordinator
    environment section, which might include the default timeout and logging statistics.
    Here''s a sample custom transaction configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The value of `default-timeout` specifies the default transaction timeout to
    be used for new transactions, which is specified as an integer in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How does the transaction timeout impact your** **applications?**'
  prefs: []
  type: TYPE_NORMAL
- en: The transaction timeout defines the timeout for all JTA transactions enlisted
    and thus severely affects your application behavior. A typical JTA transaction
    might be started by your EJBs or by a JMS session. So, if the duration of these
    transactions exceeds the specified timeout setting, the transaction service will
    roll back the transactions automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `statistics-enabled` determines whether or not the transaction
    service should gather statistical information. The default is to not gather this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In WildFly, the `enable-statistics` property has been deprecated in favor of
    `statistics-enabled`. If you are migrating from JBoss AS 7, the deprecated property
    will still work but may be removed in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency utilities is new to WildFly 8\. As part of Java EE 7, are aim is
    to ease the task of multithreading within enterprise applications. Prior to Java
    EE 7, there was no safe way to create a new thread programmatically in your application.
  prefs: []
  type: TYPE_NORMAL
- en: With the new concurrency utilities, your new threads are now guaranteed to have
    access to other enterprise services, such as transactions, and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main concurrency components are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ContextService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ManagedThreadFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ManagedExecutorService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ManagedScheduledExecutorService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the context service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The context service is used to create contextual proxies from existent objects
    and is configured within the `ee` module of WildFly. The following is the default
    configuration in WildFly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `name` attribute is the name of your context service, and the `use-transaction-setup-provider`
    attribute states whether or not the contextual proxies should suspend and resume
    active transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the managed thread factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ManagedThreadFactory` component is used to create threads that are managed
    by the container. The default configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the default thread factory in your Java code, simply use the `@Resource`
    annotation without providing a value for the `lookup` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the managed executor service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class is used to execute tasks in a second thread within your enterprise
    application. You should always use this in preference over the executor service
    found within Java SE libraries. Here is an example of the configuration in WildFly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the full list of attributes you can use to configure your
    `managed-executor-service` in WildFly:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `context-service` | This defines which context service to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `core-threads` | This defines the number of threads within the executors
    thread pool, including idle threads. |'
  prefs: []
  type: TYPE_TB
- en: '| `hung-task-threshold` | This specifies how long, in milliseconds, the threads
    can be allowed to run before they are considered unresponsive. |'
  prefs: []
  type: TYPE_TB
- en: '| `jndi-name` | This specifies the JNDI name for this resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `keepalive-time` | This specifies how long threads can remain idle when the
    number of threads is greater than the core thread size. |'
  prefs: []
  type: TYPE_TB
- en: '| `long-running-tasks` | This checks whether the thread is a short-running
    or long-running thread. |'
  prefs: []
  type: TYPE_TB
- en: '| `max-threads` | This specifies the maximum number of threads to allow in
    the executor''s pool. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | This specifies the name of the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `queue-length` | This specifies the number of tasks that can be stored in
    the input queue. Zero means unlimited. |'
  prefs: []
  type: TYPE_TB
- en: '| `reject-policy` | This defines how you can handle a failed task. An `ABORT`
    value will cause an exception to be thrown; `RETRY_ABORT`, which will cause a
    retry, and then an abort if the retry fails. |'
  prefs: []
  type: TYPE_TB
- en: '| `thread-factory` | This specifies the name of the thread factory. If it''s
    not supplied, the default thread factory is used. |'
  prefs: []
  type: TYPE_TB
- en: Configuring the managed schedule executor service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the same as the `ManagedExecutorService`, except that it has additional
    functionality allowing you to schedule a thread to start at specific times. Here
    is an example of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The following is the list of attributes that can be used to configure your `managed-scheduled-executor-service`.
    Please see the preceding table in the `managed-executor-service` section for details
    of each property.
  prefs: []
  type: TYPE_NORMAL
- en: '`context-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-threads`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hung-task-threshold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jndi-name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keepalive-time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long-running-tasks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reject-policy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread-factory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continued the analysis of the application server configuration
    by looking at Java's enterprise services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first learned how to configure datasources, which can be used to add database
    connectivity to your applications. Installing a datasource in WildFly 8 requires
    two simple steps: installing the JDBC driver and adding the datasource into the
    server configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the enterprise JavaBeans subsystem, which allows you to configure
    and tune your EJB container. We looked at the basic EJB component configurations
    (SLSB, SFSB, and MDB) and then looked at the EJB timer service configuration that
    can be used to provide time-based services to your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we described the configuration of the message-oriented middleware, which
    allows you to loosely couple heterogeneous systems together while typically providing
    reliability, transactions, and various other features.
  prefs: []
  type: TYPE_NORMAL
- en: Then we moved on to the transaction subsystem configuration, which can be used
    to collect transaction logs and define the timeout for all JTA transactions enlisted.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we completed our journey by taking a look at how to configure concurrency
    within WildFly using the `ee` subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the web container configuration, providing
    a complete example, that uses a variety of enterprise technologies, and focusing
    on the structure and the packaging of the application.
  prefs: []
  type: TYPE_NORMAL
