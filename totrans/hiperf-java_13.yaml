- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance-Focused Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The performance of modern Java applications is a paramount concern that can
    significantly impact the success of an application and the organization. Performance
    can include execution speed, network responsiveness, and data handling optimization.
    Regardless of the type of performance you are trying to improve, selecting and
    properly implementing the most ideal tools and libraries are key to bringing your
    performance improvement goals to fruition.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter highlights a specific set of tools that can be instrumental in
    improving the performance of Java applications. The first tool reviewed is **Java
    Microbenchmark Harness** (**JMH**), which helps us create reliable benchmarks.
    Our JMH coverage will include fundamental knowledge and hands-on application.
    Netty, a network application framework focused on high performance, will also
    be covered. This framework’s greatest value is in applications that require rapid
    response times or scalable network architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Our coverage of performance-focused libraries includes an examination of FasterXML
    Jackson, a high-speed **JavaScript Object Notation** (**JSON**) processor that,
    as you will have the opportunity to learn, facilitates data processing efficiencies.
    FasterXML Jackson, also referred to as just Jackson, has streaming and data-binding
    APIs that can significantly improve performance when working with JSON data. The
    chapter concludes with a section on other notable libraries, including Eclipse
    Collections, Agrona, and Guava.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a foundational understanding of
    performance-focused libraries and be able to leverage the knowledge you gained
    from the hands-on exercises to improve the performance of your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Java Microbenchmark Harness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FasterXML Jackson
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other notable libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014), *Peeking Inside the
    Java Virtual* *Machine (JVM)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter13](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: Java Microbenchmark Harness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmarking is critical to the ability to measure performance. JMH is a toolkit
    used to implement rigorous benchmarks. This section explores JMH and its key features
    and provides implementation examples.
  prefs: []
  type: TYPE_NORMAL
- en: Java Microbenchmark Harness (JMH)
  prefs: []
  type: TYPE_NORMAL
- en: JMH is used to build and implement benchmarks to analyze the performance of
    Java code. It was written in Java by the team that created the **Java Virtual**
    **Machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: Developers that use JMH can measure the performance of Java code snippets with
    repeatable and controlled conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Key features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JMH is an open source toolkit used to build and implement benchmarks at the
    nano, micro, and macro levels. JMH is more than a performance tester; it is designed
    to overcome or avoid common performance measurement pitfalls, including warm-up
    times and the effects of **just-in-time** (**JIT**) compilations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of the JMH toolkit include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotations**: As you will see in the next section, JMH uses Java annotations
    to easily define benchmarks. This feature is developer-friendly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVM integration**: JMH works in step with JVM intervals. This provides us
    with consistent and reliable results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microbenchmarking support**: JMH, as the name suggests, focuses on small
    code snippets. This helps increase the accuracy of performance measurements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of the JMH toolkit, let’s look at how
    to write benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JMH libraries to your IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on your **Integrated Development Environment** (**IDE**) setup, you
    may have to manually add the JMH libraries to your Java project. The following
    steps can be used with Visual Studio Code to add the JMH libraries to a Java project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Maven** **quickstart** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `pom.xml` file by adding the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and reload the project using **Maven: Reload project** via the command
    palette.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might opt to use a more robust IDE, such as IntelliJ IDEA. Here are the
    steps to add these libraries to a project in that IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project in IntelliJ IDEA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **File** | **Project Structure** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project Structure** interface, select **Project Settings** | **Libraries**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **+** button to add a new library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **From** **Maven** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the search feature to find the most recent version of `org.openjdk.jmh:jmh-core`
    and click **OK** to add the library to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the search feature to find the most recent version of `org.openjdk.jmh:jmh-generator-annprocess`
    and click **OK** to add the library to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply** to apply the changes and then **OK** to close the **Project
    Structure** dialog window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, ensure that the libraries have been automatically added to your module.
    If this is not the case, select the **File** | **Project Structure** | **Modules**
    menu option. If the new JMH libraries are not listed in the **Dependencies** area,
    use the **+** button to add them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not using Visual Studio Code or IntelliJ IDEA, follow the steps appropriate
    for your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Writing benchmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use JMH in Java code, we simply add the `@Benchmark` annotation and use
    JMH’s core APIs to configure and execute our benchmarks. Let’s look at an example
    in code. Our example tests two methods, both with a different approach to string
    reversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s run our code and review the results.
  prefs: []
  type: TYPE_NORMAL
- en: Running benchmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we define our benchmarks, we simply run them via the `main()` method in
    our Java application or, alternatively, via the command line. If our application
    does not contain a `main()` method, then we would run the class containing the
    benchmarks. In our previous code example, that would be the `Ch13StringBenchmark()`
    class. JMH provides detailed output with time measurements and throughput rates.
    Analysis of this data can provide significant performance-related insights into
    the benchmarked code.
  prefs: []
  type: TYPE_NORMAL
- en: Even our simple test results in extensive output. The final segment of the output
    is provided in the following figure. The complete output is provided in the `Ch13StringBenchmarkOutput.txt`
    file in this chapter’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Final benchmark output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B21942_13_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Final benchmark output
  prefs: []
  type: TYPE_NORMAL
- en: Referring to the preceding output, let’s look at how that information can be
    analyzed to provide performance insights.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you saw in the previous section, JMH provides extensive output. Looking
    at the final three lines of output illustrated in *Figure 13**.1*, there are several
    columns that we should understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mode`: This is the benchmark mode. Our mode was `thrpt` for throughput. It
    could have alternatively been `avgt` for average time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cnt`: This is the count of benchmark iterations. In our case, it was `5` for
    each benchmark.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Score`: This is the benchmark score that shows, in our case, the average throughput
    time in microseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Error`: This column contains the margin of error for the score.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the output, we can see that the first benchmark was faster than the
    second benchmark. Viewing these types of results can help developers decide how
    to implement certain functionality to achieve high performance in their code.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few common JMH use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparative analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance regression tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMH empowers Java developers to create and implement benchmarks. Analyzing the
    results can help developers make informed decisions based on an analysis of empirical
    data. This can lead to more performant Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Netty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netty, cutely named for networking, is a high-performance, event-driven application
    framework. This framework helps developers create network applications by simplifying
    network functionality programming such as with **User Datagram Protocol** (**UDP**)
    and **Transmission Control Protocol** (**TCP**) socket servers.
  prefs: []
  type: TYPE_NORMAL
- en: Network programming often involves low-level APIs and Netty provides a level
    of abstraction making it easier to develop with. The Netty architecture is scalable,
    supports many connections, and is designed to minimize latency and resource overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Core features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Netty is the framework of choice for many network developers due to its reliability,
    scalability, and ease of use. The core features of Netty include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Built-in codec support**: Netty has built-in encoders and decoders to help
    developers work with various protocols including HTTP and WebSocket. Netty negates
    the need for separate implementations for supported protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizable pipeline**: The Netty framework includes a pipeline architecture
    that facilitates data encapsulation and handlers. It uses a modular approach,
    making pipeline configuration an easy task for developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven**: Netty’s event-driven design results in asynchronous input/output
    handling. This non-blocking approach minimizes network latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with an understanding of Netty’s core features, let’s review performance
    considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our focus throughout this book has been on high-performance Java applications.
    Netty is a great addition to our high-performance tool kit. It emphasizes high
    performance with its **thread model flexibility** and **zero-copy capabilities**.
    Let’s look at those performance considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread model flexibility**: Netty’s thread management is highly configurable.
    Developers can configure Netty to manage their application’s threads based on
    specific use cases, such as scaling up or down and reducing the number of threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero-copy capabilities**: Netty’s zero-copy API helps make data processing
    (input and output) more efficient. This is accomplished by minimizing unnecessary
    memory duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at an example of using Netty to create an echo server that simply
    echoes data it receives to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example demonstrates the relative ease with which Netty can be
    used to handle network events and how Netty can facilitate high performance in
    network communications. Note that you will document your dependencies in the `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is simulated output of the Netty echo server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Netty is a mature and robust framework for network application development.
    It is inherently scalable and offers performance benefits with network functionality.
    Netty also introduces development efficiencies and shorter development times.
  prefs: []
  type: TYPE_NORMAL
- en: FasterXML Jackson
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON is a file format used for interchanging data. It is structured and human-readable
    text used to transmit data objects. The format consists of arrays and attribute-value
    pairs. The example JSON object provided in the following code block represents
    a user profile for a social media system. As you can see, the fields contain the
    user’s name, age, email address, and hobbies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This JSON object consists of attribute-value or key-value pairs and an array
    of strings for the user’s hobbies. JSON is a common method of data representation
    in data storage and web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**FasterXML Jackson** is a library with the primary ability to rapidly process
    and create JSON objects. These objects are read sequentially and FasterXML Jackson,
    referred to from this point as **Jackson**, uses a cursor to keep track of its
    place. Jackson is lauded as a performance maximizer and memory minimizer.'
  prefs: []
  type: TYPE_NORMAL
- en: The *XML* in *FasterXML Jackson* suggests it can handle XML files too. In addition
    to Jackon’s ability to rapidly process JSON, it can also process **Comma-Separated
    Values** (**CSV**), **eXtensible Markup Language** (**XML**), **YAML Ain’t Markup
    Language** (**YAML**), and other file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Core features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Core features of Jackson include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data binding**: Data binding is a Jackson feature that supports efficient
    and reliable conversion between Java objects and JSON text. Implementation is
    straightforward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs: []
  type: TYPE_NORMAL
- en: A technique in computer programming that links (binds) data sources to the sender
    (provider) and receiver (client).
  prefs: []
  type: TYPE_NORMAL
- en: '**Streaming API**: Jackon has a highly efficient, low-level streaming API for
    parsing and generating JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree model**: When flexible JSON operations are needed, Jackson’s tree model
    can be implemented to represent JSON documents in a tree structure – a tree of
    nodes. This is often used when the JSON structures are complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you understand Jackson’s core features, let’s review performance considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The performance considerations detailed here illustrate how Jackson was designed
    as a performance-focused library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom serialization and deserialization**: Jackson empowers developers to
    define their own serializers and deserializers for custom fields. This can lead
    to significant performance enhancements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero-copy**: Like Netty, Jackson’s zero-copy API helps make data processing
    (input and output) efficient. This is accomplished by minimizing unnecessary memory
    duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at an example of using Jackson to serialize and deserialize Java
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by adding dependencies to our `pom.xml` file to include Jackson
    in our project. Here is what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example illustrates how straightforward Jackson is for developing
    object serialization and deserialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned that Jackson is a key tool for processing JSON.
    It is fast, flexible, and robust. Jackson can be the first tool you think of when
    needing to work with JSON in your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Other notable libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered JMH, Netty, and Jackson and posited that they are core
    libraries focused on high performance in Java. Each is designed for a specific
    type of task. There are other libraries available that are worth learning about.
    This section explores three additional libraries: **Agrona**, **Eclipse Collections**,
    and **Guava**.'
  prefs: []
  type: TYPE_NORMAL
- en: Agrona
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Agrona is a data structure collection specifically designed for creating high-performance
    Java applications. These data structures include maps and ring buffers. An example
    use case is a stock trading application whose success hinges on low latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of Agrona include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking data structures – this supports high throughput and results in
    low latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically designed for high-frequency stock and securities trading systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses direct buffers, contributing to off-heap memory management efficiencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at an implementation example of Agrona that illustrates how to use
    a specific high-performance data structure. For our example, we will use the `ManyToOneConcurrentArrayQueue`
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code and surmise from the in-code comments,
    we initialize `ManyToOneConcurrentArrayQueue` with a capacity value of `10`. This
    type of queue is well suited for use cases where there is a single **customer**
    and multiple **producers**. Our example includes consumer and producer threads.
    The code implemented basic thread handling.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eclipse Collections is a set of memory-efficient algorithms and data structures.
    These collections can be used to significantly improve performance. Engineered
    for large-scale systems, Eclipse collections come in both mutable and immutable
    forms. They offer efficient memory management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of Eclipse collections include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive set of data structures to include bags, lists, maps, sets, stacks,
    and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive collections and associated classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility methods that can transform collections and be used for filtering, iterating,
    and sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s demonstrate how to use an `ImmutableList` from an Eclipse collection.
    This is one of the more memory-efficient collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our example starts with the creation of an immutable list of fruits. Next, we
    add an element to the list, then we iterate through the list for output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Eclipse Collections in our applications, we need to include the library
    in our project. With the example of Maven, we would simply add the following to
    our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our code snippet provided a basic introduction to using Eclipse Collections.
  prefs: []
  type: TYPE_NORMAL
- en: Guava
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Guava is a product from Google that includes new collection types such as multimap
    and multiset. It also includes immutable collections, a graph library, support
    for primitives, and caching utilities. Here is a list of key features of Guava:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced collection types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced collection utilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching support using `CacheBuilder`. This can be used to improve application
    speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities for concurrency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities for hashing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities for input/output operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example application that demonstrates the use of Guava’s `CacheBuilder`.
    The application creates a cache that automatically loads and stores value-based
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Java has several libraries and frameworks that can be used to improve overall
    performance. Understanding what libraries are available to us and how to implement
    them can be crucial to an application’s success.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter explored several key high-performance libraries that we can employ
    to improve the performance of our Java applications. Specifically, we reviewed
    JMH and indicated that it provides reliable performance benchmarking. We also
    looked at Netty and identified its applicability to improving the performance
    of network applications. FastXML Jackson was also reviewed for its specialized
    use in handling JSON objects. Lastly, we covered three additional libraries: Agrona,
    Eclipse Collections, and Guava.'
  prefs: []
  type: TYPE_NORMAL
- en: Each library featured in the chapter is tailored to a specific Java programming
    need. These tools are poised to help us significantly improve the performance
    of our Java applications. Experimenting with these libraries with your own Java
    projects can help solidify your understanding of them and the best use case for
    each of them. Furthermore, implementing these libraries appropriately can lead
    to overall improved performance of your Java application.
  prefs: []
  type: TYPE_NORMAL
