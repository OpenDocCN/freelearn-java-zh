- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Style Programming – Extending APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter includes 24 problems covering a wide range of functional programming
    topics. We will start by introducing the JDK 16 `mapMulti()` operation, and continue
    with a handful of problems for working with predicates (`Predicate`), functions,
    and collectors.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have a background in functional programming in Java, then I strongly
    recommend you postpone this chapter until you have spent some time getting familiar
    with it. You could consider reading *Chapters 8* and *9* from *Java Coding Problems*,
    *First Edition*.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll be deeply skilled in functional programming
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following problems to test your programming prowess in functional programming
    in Java. I strongly encourage you to give each problem a try before you turn to
    the solutions and download the example programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with mapMulti()**: Explain and exemplify the JDK 16 `mapMulti()`.
    Provide a brief introduction, explain how it works in comparison with `flatMap()`,
    and point out when `mapMulti()` is a good fit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Streaming custom code to map**: Imagine a class that shapes some blog posts.
    Each post is identified by a unique integer ID, and the post has several properties,
    including its tags. The tags of each post are actually represented as a string
    of tags separated by a hashtag (`#`). Whenever we need the list of tags for a
    given post, we can call the `allTags()` helper method. Our goal is to write a
    stream pipeline that extracts from this list of tags a `Map<String, List<Integer>>`
    containing, for each tag (key), the list of posts (value).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exemplifying a method reference vs. a lambda**: Write a relevant snippet
    of code to highlight the difference in behavior between a method reference and
    the equivalent lambda expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hooking lambda laziness via Supplier/Consumer**: Write a Java program that
    highlights how `Supplier`/`Consumer` works. In this context, point out the lazy
    characteristic of lambdas.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactoring code to add lambda laziness:** Provide a simple example of refactoring
    a piece of imperative code via functional code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing a Function<String, T> to parse data**: Imagine a given text (`test,
    a, 1, 4, 5, 0xf5, 0x5, 4.5d, 6, 5.6, 50000, 345, 4.0f, 6$3, 2$1.1, 5.5, 6.7, 8,
    a11, 3e+1, -11199, 55`). Write an application that exposes a `Function<String,
    T>` capable of parsing this text, and extract only doubles, integers, longs, and
    so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Composing predicates in a Stream’s filters**: Write several examples that
    highlight the usage of composite predicates in filters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Filtering nested collections with Streams**: Imagine that you have two nested
    collections. Provide several stream pipeline examples to filter data from the
    inner collection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using BiPredicate:** Exemplify the usage of `BiPredicate`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Building a dynamic predicate for a custom model**: Write an application capable
    of dynamically generating predicates (`Predicate`) based on some simple inputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Building a dynamic predicate from a custom map of conditions**: Consider
    having a map of conditions (the map’s key is a field, and the map’s value is the
    expected value for that field). In this context, write an application that dynamically
    generates the proper predicate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Logging in predicates**: Write a custom solution that allows us to log failures
    in predicates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extending Stream with containsAll() and containsAny()**: Provide a solution
    that extends the Java Stream API with two final operations named `containsAll()`
    and `containsAny()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extending Stream with removeAll() and retainAll()**: Provide a solution that
    extends the Java Stream API with two final operations named `removeAll()` and
    `retainAll()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing stream comparators**: Provide a detailed covering (with examples)
    of using stream comparators.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sorting a map**: Write several snippets of code to highlight different use
    cases for sorting a map.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Filtering a map**: Write several snippets of code to highlight different
    use cases for filtering a map.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating a custom collector via Collector.of()**: Write an arbitrarily chosen
    set of custom collectors via the `Collector.of()` API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Throwing checked exceptions from lambdas**: Provide a hack that allows us
    to throw checked exceptions from lambdas.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing distinctBy() for the Stream API**: Write a Java application
    that implements the `distinctBy()` stream intermediate operation. This is like
    the built-in `distinct()`, only it allows us to filter distinct elements by a
    given property/field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing a custom collector that takes/skips a given number of elements**:
    Provide a custom collector that allows us to collect only the first *n* elements.
    Moreover, provide a custom collector that skips the first *n* elements and collects
    the rest of them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing a Function that takes five (or any other arbitrary number of)
    arguments**: Write and use a five-argument functional interface that represents
    a specialization of `java.util.function.Function`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing a Consumer that takes five (or any other arbitrary number of)
    arguments**: Write and use a five-argument functional interface that represents
    a specialization of `java.util.function.Consumer`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Partially applying a Function**: Write an *n*-arity functional interface
    that represents a specialization of `java.util.function.Function`. Moreover, this
    interface should provide support (i.e., provide the necessary `default` methods)
    to apply only *n*-1, *n*-2, *n*-3,…,1 argument(s).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: 185\. Working with mapMulti()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JDK 16, the Stream API was enriched with a new intermediate operation,
    named `mapMulti()`. This operation is represented by the following `default` method
    in the `Stream` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s follow the learning-by-example approach and consider the next classical
    example, which uses a combination of `filter()` and `map()` to filter even integers
    and double their value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The same result can be obtained via `mapMulti()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So instead of using two intermediate operations, we used only one, `mapMulti()`.
    The `filter()` role was replaced by an `if` statement, and the `map()` role is
    accomplished in the `accept()` method. This time, we filtered the evens and doubled
    their values via `mapper`, which is a `BiConsumer<? super T, ? super Consumer<R>>`.
    This bi-function is applied to each integer (each stream element), and only the
    even integers are passed to the consumer. This consumer acts as a buffer that
    simply passes downstream (in the stream pipeline) the received elements. The `mapper.accept(R
    r)` can be called any number of times, which means that, for a given stream element,
    we can produce as many output elements as we need. In the previous example, we
    have a one-to-zero mapping (when `i % 2 == 0` is evaluated as `false`) and a one-to-one
    mapping (when `i % 2 == 0` is evaluated as `true`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, `mapMulti()` gets an input stream of elements and outputs another
    stream containing zero, less, the same, or a larger number of elements that can
    be unaltered or replaced by other elements. This means that each element from
    the input stream can pass through a one-to-zero, one-to-one, or one-to-many mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed the `<Integer>mapMulti(…)` type-witness applied to the returned
    value? Without this type-witness, the code will not compile because the compiler
    cannot determine the proper type of `R`. This is the shortcoming of using `mapMulti()`,
    so we have to pay this price.
  prefs: []
  type: TYPE_NORMAL
- en: 'For primitive types (`double`, `long`, and `int`) we have `mapMultiToDouble()`,
    `mapMultiToLong()`, and `mapMultiToInt()`, which return `DoubleStream`, `LongStream`,
    and `IntStream`, respectively. For instance, if we plan to sum the even integers,
    then using `mapMultiToInt()` is a better choice than `mapMulti()`, since we can
    skip the type-witness and work only with a primitive `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, whenever you need a `Stream<T>` instead of `Double`/`Long`/`IntStream`,
    you still need to rely on `mapToObj()` or `boxed()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you get familiar with `mapMulti()`, you start to realize that it is pretty
    similar to the well-known `flatMap()`, which is useful to flatten a nested `Stream<Stream<R>>`
    model. Let’s consider the following one-to-many relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `Author` has a list of books. So a `List<Author>` (candidate to become
    `Stream<Author>`) will nest a `List<Book>` (candidate to become a nested `Stream<Book>`)
    for each `Author`. Moreover, we have the following simple model for mapping an
    `author` and a single `book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In functional programming, mapping this one-to-many model to the flat `Bookshelf`
    model is a classical scenario for using `flatMap()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with `flatMap()` is that we need to create a new intermediate stream
    for each author (for a large number of authors, this can become a performance
    penalty), and only afterward we can apply the `map()` operation. With `mapMulti()`,
    we don’t need these intermediate streams, and the mapping is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a one-to-many mapping. For each author, the consumer buffers a number
    of `Bookshelf` instances equal to the number of author’s books. These instances
    are flattened over the downstream and are finally collected in a `List<Bookshelf>`
    via the `toList()` collector.
  prefs: []
  type: TYPE_NORMAL
- en: And this route takes us to the following important note on `mapMulti()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapMulti()` intermediate operation is useful when we have to replace just
    a few elements of the stream. This statement is formulated in the official documentation
    as follows: “*When replacing each stream element with a small (possibly zero)
    number of elements*.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check out this example based on `flatMap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This example fits perfectly when using `mapMulti()`. An author has a relatively
    small number of books, and we apply a filter on them. So basically, we replace
    each stream element with a small (possibly zero) number of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is better than using `flatMap()`, since we reduce the number of intermediate
    operations (no more `filter()` calls), and we avoided intermediate streams. This
    is also more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case of `mapMulti()` is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapMulti()` operation is also useful when the imperative approach is preferable
    against the stream approach. This statement is formulated in the official documentation
    as follows: “*When it is easier to use an imperative approach for generating result
    elements than it is to return them in the form of a* `Stream`.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have added to the `Author` class the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get the `List<Bookshelf>` by simply using `mapMulti()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How cool is this?! In the next problem, we will use `mapMulti()` in another
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 186\. Streaming custom code to map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we have the following legacy class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have a class that shapes some blog posts. Each post has several properties,
    including its tags. The tags of each post are actually represented as a string
    of tags separated by hashtag (`#`). Whenever we need the list of tags for a given
    post, we can call the `allTags()` helper. For instance, here is a list of posts
    and their tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to extract from this list a `Map<String, List<Integer>>`, containing,
    for each tag (key) the list of posts (value). For instance, for the tag `#database`,
    we have articles 1 and 3; for tag `#rdbms`, we have articles 1, 2, 3, and 5, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Accomplishing this task in functional programming can be done via `flatMap()`
    and `groupingBy()`. In a nutshell, `flatMap()` is useful for flattening a nested
    `Stream<Stream<R>>` model, while `groupingBy()` is a collector useful for grouping
    data in a map by some logic or property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need `flatMap()` because we have the `List<Post>` that, for each `Post`,
    nests via `allTags()` a `List<String>` (so if we simply call `stream()`, then
    we get back a `Stream<Stream<R>>`). After flattening, we wrap each tag in `Map.Entry<String,
    Integer>`. Finally, we group these entries by tags into a `Map`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, based on the previous problem, we know that, starting with JDK 16,
    we can use `mapMulti()`. So, we can rewrite the previous snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, we saved the `map()` intermediate operation and intermediate streams.
  prefs: []
  type: TYPE_NORMAL
- en: 187\. Exemplifying a method reference vs. a lamda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever written a lambda expression and your IDE advises you to replace
    it with a method reference? You probably have! And I’m sure that you preferred
    to follow the replacement because *names matter*, and method references are often
    more readable than lambdas. While this is a subjective matter, I’m pretty sure
    you’ll agree that extracting long lambdas in methods and using/reusing them via
    method references is a generally accepted good practice.
  prefs: []
  type: TYPE_NORMAL
- en: However, beyond some esoteric JVM internal representations, do they behave the
    same? Is there any difference between a lambda and a method reference that may
    affect how the code behaves?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, let’s assume that we have the following simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we assume that `p1` is a method reference and `p2` is the corresponding
    lambda, then we can perform the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see two scenarios of working with `p1` and `p2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 1: Calling printReset()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first scenario, we call `printReset()` via `p1` and `p2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the code right now, then we get this output (the message generated
    by the `Printer` constructor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This output is caused by the method reference, `p1`. The `Printer` constructor
    is invoked right away, even if we didn’t call the `run()` method. Because `p2`
    (the lambda) is lazy, the `Printer` constructor is not called until we call the
    `run()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, we fire the chain of `run()` calls for `p1` and `p2`. The output
    will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If we analyze this output, we can see that the `Printer` constructor is called
    each time the lambda (`p2.run()`) is executed. On the other hand, for the method
    reference (`p1.run()`), the `Printer` constructor is not called. It was called
    a single time, at the `p1` declaration. So `p1` prints without resetting the printer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 2: Calling static printNoReset()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s call the static method `printNoReset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the code right away, then nothing will happen (no output). Next,
    we fire up the `run()` calls, and we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `printNoReset()` is a static method, so the `Printer` constructor is not
    invoked. We can interchangeably use `p1` or `p2` without having any difference
    in behavior. So, in this case, it is just a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When calling non-static methods, there is one main difference between a method
    reference and a lambda. A method reference calls the constructor immediately and
    only once (at method invocation (`run()`), the constructor is not called). On
    the other hand, lambdas are lazy. They call the constructor only at method invocation
    and at each such invocation (`run()`).
  prefs: []
  type: TYPE_NORMAL
- en: 188\. Hooking lambda laziness via Supplier/Consumer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.function.Supplier` is a functional interface capable of supplying
    results via its `get()` method. The `java.util.function.Consumer` is another functional
    interface capable of consuming the argument given via its `accept()` method. It
    returns no result (`void`). Both of these functional interfaces are lazy, so it
    is not that easy to analyze and understand code that uses them, especially when
    a snippet of code uses both. Let’s give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And let’s write the following `Supplier` and `Consumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So, at this point, what is the value of `Counter.c`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The correct answer is, `Counter.c` is 0\. The supplier and the consumer are
    lazy, so none of the `get()` or `accept()` methods were called at their declarations.
    The `Counter.count()` was not invoked, so `Counter.c` was not incremented.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a tricky one… how about now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We know that by calling `supplier.get()`, we trigger the `Counter.count()` execution,
    and `Counter.c` should be incremented and become 1\. However, the `supplier.get()`
    will return 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation resides in the `count()` method at line `return c++;`. When
    we write `c++`, we use the post-increment operation, so we use the current value
    of `c` in our statement (in this case, `return`), and afterward, we increment
    it by 1\. This means that `supplier.get()` gets back the value of `c` as 0, while
    the incrementation takes place after this `return`, and `Counter.c` is now 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If we switch from post-increment (`c++`) to pre-increment (`++c`), then `supplier.get()`
    will get back the value of 1, which will be in sync with `Counter.c`. This happens
    because the incrementation takes place before the value is used in our statement
    (here, `return`).
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so far we know that `Counter.c` is equal to 1\. Next, let’s call the consumer
    and pass in the `Counter.c` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Via this call, we push the `Counter.c` (which is 1) in the following computation
    and display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So `c = c + Counter.count()` can be seen as `Counter.c = Counter.c + Counter.count()`,
    which is equivalent to 1 = 1 + `Counter.count()`, so 1 = 1 + 1\. The output will
    be `Consumer: 2`. This time, `Counter.c` is also 2 (remember the post-increment
    effect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s invoke the supplier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that `get()` will receive the current value of `c`, which is 2\. Afterward,
    `Counter.c` becomes 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can continue like this forever, but I think you’ve got an idea of how the
    `Supplier` and `Consumer` functional interfaces work.
  prefs: []
  type: TYPE_NORMAL
- en: 189\. Refactoring code to add lambda laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this problem, let’s have a refactoring session designed to transform a dysfunctional
    code into a functional one. We start from the following given code – a simple
    piece of class mapping information about application dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Why did we highlight the `getDependencies()` method? Because this is the point
    in the application where there is dysfunction. More precisely, the following class
    needs the dependencies of an application in order to process them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This class relies on the `ApplicationDependency.getDependecies()` method, which
    just returns `null` (the default value of the `dependencies` fields). The expected
    application’s dependencies were not downloaded, since the `downloadDependecies()`
    method was not called. Most probably, a code reviewer will signal this issue and
    raise a ticket to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing in imperative fashion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A possible fix will be as follows (in `ApplicationDependency`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Calling `downloadDependencies()` at `dependencies` initialization will definitely
    fix the problem of loading the dependencies. When the `DependencyManager` calls
    `getDependencies()`, it will have access to the downloaded dependencies. However,
    is this a good approach? I mean, downloading the dependencies is a costly operation,
    and we do it every time an `ApplicationDependency` instance is created. If the
    `getDependencies()` method is never called, then this costly operation doesn’t
    pay off the effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'So a better approach would be to postpone the download of the application’s
    dependencies until `getDependencies()` is actually called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is better, but it is not the best approach! This time, the application’s
    dependencies are downloaded every time the `getDependencies()` method is called.
    Fortunately, there is a quick fix for this. We just need to add a `null` check
    before performing the download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, the application’s dependencies are downloaded only at the first call
    of the `getDependencies()` method. This imperative solution works like a charm
    and passes the code review.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing in functional fashion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How about providing this fix in a functional programming fashion? Practically,
    all we want is to lazy-download the application’s dependencies. Since laziness
    is a specialty of functional programming, and we’re now familiar with the `Supplier`
    (see the previous problem), we can start as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, we defined a `Supplier` that calls the `downloadDependencies()` method.
    We know that the `Supplier` is lazy, so nothing happens until its `get()` method
    is explicitly called.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we have modified `getDependencies()` to return `dependencies.get()`.
    So we delay the application’s dependencies downloading until they are explicitly
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Third, we modified the return type of the `downloadDependencies()` method from
    `void` to `String`. This is needed for the `Supplier.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a nice fix, but it has a serious shortcoming. We lost the caching! Now,
    the dependencies will be downloaded at every `getDependencies()` call.
  prefs: []
  type: TYPE_NORMAL
- en: We can avoid this issue via *memoization* ([https://en.wikipedia.org/wiki/Memoization](https://en.wikipedia.org/wiki/Memoization)).
    This concept is also covered in detail in *Chapter 8* of *The Complete Coding
    Interview Guide in Java*. In a nutshell, memoization is a technique used to avoid
    duplicate work by caching results that can be reused later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoization is a technique commonly applied in dynamic programming, but there
    are no restrictions or limitations. For instance, we can apply it in functional
    programming. In our particular case, we start by defining a functional interface
    that extends the `Supplier` interface (or, if you find it simpler, just use `Supplier`
    directly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we provide an implementation of `FSupplier` that basically cashes the
    unseen results and serves, from the cache, the already seen ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we replace our initial `Supplier` with `FSupplier`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Done! Our functional approach takes advantage of `Supplier`'s laziness and can
    cache the results.
  prefs: []
  type: TYPE_NORMAL
- en: 190\. Writing a Function<String, T> for parsing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we have the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The goal is to find a solution that extracts from this text only the numbers.
    Depending on a given scenario, we may need only the integers, or only the doubles,
    and so on. Sometimes, we may need to perform some text replacements before extraction
    (for instance, we may want to replace the `xf` characters with a dot, `0xf5 =
    0.5`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible solution to this problem is to write a method (let’s name it `parseText()`)
    that takes as an argument a `Function<String, T>`. The `Function<String, T>` gives
    us the flexibility to shape any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseText()` should perform several steps until it reaches the final result.
    Its signature can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: First, we have to split the received text by the comma delimiter and extract
    the items in a `String[]`. This way, we have access to each item from the text.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we can stream the `String[]` and filter any empty items.
  prefs: []
  type: TYPE_NORMAL
- en: Third, we can call the `Function.apply()` to apply the given function to each
    item (for instance, to apply `Double::valueOf`). This can be done via the intermediate
    operation `map()`. Since some items may be invalid numbers, we have to catch and
    ignore any `Exception` (it is bad practice to swallow an exception like this,
    but in this case, there is really nothing else to do). For any invalid number,
    we simply return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, we filter all `null` values. This means that the remaining stream contains
    only numbers that passed through `Function.apply()`.
  prefs: []
  type: TYPE_NORMAL
- en: Fifth, we collect the stream in a `List` and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting these five steps together will result in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Done! You can use this example to solve a wide range of similar problems.
  prefs: []
  type: TYPE_NORMAL
- en: 191\. Composing predicates in a Stream’s filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A predicate (basically, a condition) can be modeled as a Boolean-valued function
    via the `java.util.function.Predicate` functional interface. Its functional method
    is named `test(T t)` and returns a `boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying predicates in a stream pipeline can be done via several stream intermediate
    operations, but we are interested here only in the `filter(Predicate p)` operation.
    For instance, let’s consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a `List<Car>` and we want to express a filter that produces all
    the cars that are Chevrolets, then we can start by defining the proper `Predicate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use this `Predicate` in a stream pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Predicate` can be negated in at least three ways. We can negate the condition
    via the logical not (`!`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the `Predicate.negate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can call the `Predicate.not()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'No matter which of these three approaches you prefer, the following filter
    will produce all cars that are not Chevrolets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous examples, we applied a single predicate in a stream pipeline.
    However, we can apply multiple predicates as well. For instance, we may want to
    express a filter that produces all the cars that are not Chevrolets and have at
    least 150 horsepower. For the first part of this composite predicate, we can arbitrarily
    use `pChevrolets.negate()`, while, for the second part, we need the following
    `Predicate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can obtain a composite predicate by chaining the `filter()` calls, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It is shorter and more expressive to rely on `Predicate.and(Predicate<? super
    T> other)`, which applies the short-circuiting logical AND between two predicates.
    So the previous example is better expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to apply the short-circuiting logical OR between two predicates,
    then relying on `Predicate.or(Predicate<? super T> other)` is the proper choice.
    For instance, if we want to express a filter that produces all Chevrolets or electric
    cars, then we can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are in a scenario that heavily relies on composite predicates, then we
    can start by creating two helpers that make our job easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The goal of these helpers is to take several predicates and glue them into a
    single composite predicate, via the short-circuiting logical AND and OR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we want to express a filter that applies the following three
    predicates via the short-circuiting logical AND:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we join these predicates in a single one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, we express the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'How about expressing a filter that produces a stream containing all cars with
    horsepower between 100 and 200 or 300 and 400? The predicates are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The composite predicate can be obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressing the filter is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can find all these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 192\. Filtering nested collections with Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a classical problem in interviews that usually starts from a model,
    as follows (we assume that the collection is a `List`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Having `List<Author>` denoted as `authors`, write a stream pipeline that returns
    the `List<Book>` published in 2002\. You already should recognize this as a typical
    problem for `flatMap()`, so without further details, we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, that’s crystal clear! How about finding the `List<Author>` with books published
    in 2002? Of course, `mapMulti()` can help us again. All we have to do is to loop
    the books, and when we find a book published in 2002, we simply pass the `author`
    to the `consumer` instead of the book. Moreover, after passing the `author` to
    the `consumer`, we can break the loop for the current author and take the next
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach can rely on `anyMatch()` and a predicate that produces a stream
    of books published in 2002, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, we don’t want to alter the given list, but if that is not an issue
    (or it is exactly what we want), then we can rely on `removeIf()` to accomplish
    the same result directly on the `List<Author>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, you should have no issues if a problem like this comes up in your
    interviews.
  prefs: []
  type: TYPE_NORMAL
- en: 193\. Using BiPredicate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the `Car` model and a `List<Car>` denoted as `cars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal is to see if the following `Car` is contained in `cars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the `List` API exposes a method named `contains(Object o)`. This
    method returns `true` if the given `Object` is present in the given `List`. So,
    we can easily write a `Predicate`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the `test()` method, and we should get the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can obtain the same result in a stream pipeline via `filter()`, `anyMatch()`,
    and so on. Here is via `anyMatch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can rely on `BiPredicate`. This is a functional interface
    representing a two-arity specialization of the well-known `Predicate`. Its `test(Object
    o1, Object o2)` method gets two arguments, so it is a perfect fit for our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the next problem, you’ll see a more practical example of using a `BiPredicate`.
  prefs: []
  type: TYPE_NORMAL
- en: 194\. Building a dynamic predicate for a custom model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the `Car` model and a `List<Car>` denoted as cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Also, let’s assume that we need to dynamically produce a wide range of predicates
    that apply the operators `<`, `>`, `<=`, `>=`, `!=`, and `==` to the `horsepower`
    field. It will be cumbersome to hardcode such predicates, so we have to come up
    with a solution that can build, on the fly, any predicate that involves this field,
    and one of the comparison operators listed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few approaches to accomplish this goal, and one of them is to use
    a Java `enum`. We have a fixed list of operators that can be coded as `enum` elements,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to apply any of these `(t, u)` lambdas, we need a `BiPredicate` constructor
    (see *Problem 193*), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can define a `BiPredicate`, we can write the method that contains
    the actual test and returns a `Predicate<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to provide here the `Function<T, Integer>`, which is the getter
    corresponding to `horsepower`. We can do this via Java Reflection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it can be any other class and integer field as well, not only the
    `Car` class and the `horsepower` field. Based on this code, we can dynamically
    create a predicate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this predicate is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You can use this problem as a source of inspiration to implement more types
    of dynamic predicates. For example, in the next problem, we use the same logic
    in another scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 195\. Building a dynamic predicate from a custom map of conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the `Car` model and a `List<Car>` denoted as `cars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let’s assume that we receive a `Map` of conditions of type *field : value,*
    which could be used to build a dynamic `Predicate`. An example of such a `Map`
    is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have a `Map<String, String>`, so we are interested in an
    `equals()` comparison. This is useful to start our development via the following
    Java `enum` (we follow the logic from *Problem 194*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can add more operators, such as `startsWith()`, `endsWith()`,
    `contains()`, and so on. Next, based on the experience gained in *Problems 193*
    and *194*, we need to add a `BiPredicate` constructor, the `toPredicate()` method,
    and the Java Reflection code to fetch the getters corresponding to the given fields
    (here, `brand` and `fuel`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to define a predicate for each map entry and chain them via the
    short-circuiting AND operator. This can be done in a loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the resulting predicate to filter the cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: 196\. Logging in predicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that the `Predicate` functional interface relies on its `test()`
    method to perform the given check, and it returns a Boolean value. Let’s suppose
    that we want to alter the `test()` method to log the failure cases (the cases
    that lead to the return of a `false` value).
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick approach is to write a helper method that sneaks the logging part,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach consists of extending the `Predicate` interface and providing
    a `default` method for testing and logging the failure cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 197\. Extending Stream with containsAll() and containsAny()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the context of a stream pipeline, we want to check if `cars` contains
    all/any of `car1`, `car2`, `car3`, or `cars123`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Stream API comes with a rich set of intermediate and final operations,
    but it doesn’t have a built-in `containsAll()`/`containsAny()`. So, it is our
    mission to provide the following final operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We highlighted the methods that get a `Stream` argument, since these methods
    provide the main logic, while the rest of the methods just call these ones after
    converting their arguments to a `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing containsAll/Any() via a custom interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `containsAll(Stream<? extends T> items)` relies on a `Set` to accomplish
    its job, as follows (as a challenge, try to find an alternative implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `containsAny(Stream<? extends T> items)` method also relies on a `Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toSet()` method is just a helper that collects the `Stream` items into
    a `Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s sneak this code into its final place, which is a custom interface.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `containsAll(Stream<? extends T> items)` method and `containsAny(Stream<?
    extends T> items)` are declared as `default`, which means that they are part of
    an interface. Moreover, both of them call the `stream()` method, which is also
    part of this interface and hooks the regular `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, a quick approach for solving this problem (especially useful in
    interviews) consists of writing this custom interface (let’s arbitrarily name
    it `Streams`) that has access to the original built-in `Stream` interface, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the interface exposes a set of `default` methods that represent the `containsAll()`/`containsAny()`
    flavors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now, we can write different stream pipelines that use the brand-new `containsAll`/`Any()`
    operations. For instance, if we want to check if `cars` contains all items from
    `cars123`, we express the stream pipeline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are several more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Involving more operations can be done as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: A more expressive and complete solution to this problem consists of extending
    the `Stream` interface. Let’s do it!
  prefs: []
  type: TYPE_NORMAL
- en: Exposing containsAll/Any() via an extension of Stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous solution can be considered more like a hack. A more logical and
    realistic solution consists of extending the built-in Stream API and adding our
    `containsAll`/`Any()` methods as teammates next to the `Stream` operations. So
    the implementation starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Before implementing the `containsAll`/`Any()` methods, we need to handle some
    aspects resulting from extending the `Stream` interface. First, we need to override
    in `Streams` each of the `Stream` methods. Since the `Stream` interface has a
    lot of methods, we only list a few of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Since `Streams` can handle only sequential streams (parallelism is not supported),
    we can implement the `isParallel()`, `parallel()`, `unordered()`, and `sequential()`
    methods as `default` methods directly in `Streams`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in order to use `Streams`, we need a `from(Stream s)` method that is
    capable of wrapping the given `Stream`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StreamsWrapper` is a class that wraps the current `Stream` into sequential
    `Streams`. The `StreamsWrapper` class implements `Streams`, so it has to override
    all the `Streams` methods and properly wrap the `Stream` into `Streams`. Because
    `Streams` has quite a lot of methods (as a consequence of extending `Stream`),
    we list here only a few of them (the rest are available in the bundled code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add `Streams` to the `containsAll`/`Any()` methods, which are quite
    straightforward (since `Streams` extends `Stream`, we have access to all the `Stream`
    goodies without the need to write a `stream()` hack, as in the previous solution).
    First, we add the `containsAll()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we add the `containsAny()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the `toSet()` method, which you already know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Mission accomplished! Now, let’s write some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: You can find more examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 198\. Extending Stream with removeAll() and retainAll()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before reading this problem, I strongly recommend that you read *Problem 197*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Problem 197*, we extended the Stream API with two final operations named
    `containsAll()` and `containsAny()` via a custom interface. In both cases, the
    resulting interface was named `Streams`. In this problem, we follow the same logic
    to implement two intermediate operations, named `removeAll()` and `retainAll()`,
    with the following signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Since `removeAll()` and `retainAll()` are intermediate operations, they have
    to return `Stream`. More precisely, they have to return `Streams`, which is our
    implementation based on a custom interface or an interface that extends `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing removeAll()/retainAll() via a custom interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `removeAll(Stream<? extends T> items)` method relies on a `Set` to accomplish
    its job, as follows (as a challenge, try to find an alternative implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The `retainAll(Stream<? extends T> items)` method also relies on a `Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toSet()` method is just a helper that collects the `Stream` items into
    a `Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can sneak these `default` methods into a custom interface named `Streams`,
    exactly as we did in *Problem 197*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a big problem with this implementation. The problem becomes obvious
    when we try to chain `removeAll()`/`retainAll()` in a stream pipeline next to
    other `Stream` operations. Because these two methods return `Streams` (not `Stream`),
    we cannot chain a `Stream` operation after them without first calling the Java
    built-in `stream()` before them. This is needed to switch from `Streams` to `Stream`.
    Here is an example (using `cars`, `car1`, `car2`, `car3`, and `car123`, as introduced
    in *Problem 197*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem becomes even worse if we have to alternate between `Streams` and
    `Stream` multiple times. Check out this zombie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This hack is not a happy choice to enrich the Stream API with intermediate operations.
    However, it works quite well for terminal operations. So, the proper approach
    is to extend the `Stream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing removeAll/retainAll() via an extension of Stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already know from *Problem 197* how to extend the `Stream` interface. The
    implementation of `removeAll()` is also straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `retainAll()` follows in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'As you know from *Problem 197*, next, we have to override all the `Stream`
    methods to return `Streams`. While this part is available in the bundled code,
    here is an example of using `removeAll()`/`retainAll()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this time, the stream pipeline looks quite good. There is no
    need to perform switches between `Streams` and `Stream` via `stream()` calls.
    So, mission accomplished!
  prefs: []
  type: TYPE_NORMAL
- en: 199\. Introducing stream comparators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we have the following three lists (a list of numbers, a list
    of strings, and a list of `Car` objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Next, we want to sort these lists in a stream pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting via natural order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sorting via natural order is very simple. All we have to do is to call the
    built-in intermediate operation, `sorted()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: If `nrs` contains 1, 6, 3, 8, 2, 3, and 0, then `sorted()` will produce 0, 1,
    2, 3, 3, 6, and 8\. So, for numbers, the natural order is the ascending order
    by value.
  prefs: []
  type: TYPE_NORMAL
- en: If `strs` contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then
    `sorted()` will produce “around,” “book,” “new,” “old,” “quiz,” and “tick”. So,
    for strings, the natural order is the alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same result can be obtained if we explicitly call `Integer.compareTo()`
    and `String.compareTo()` via `sorted(Comparator<? super T> comparator)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `java.util.Comparator` functional interface,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: All three approaches return the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing the natural order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reversing the natural order can be done via `Comparator.reverseOrder()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: If `nrs` contains 1, 6, 3, 8, 2, 3, and 0, then `sorted()` will produce 8, 6,
    3, 3, 2, 1, and 0\. Reversing the natural order of numbers results in descending
    order by value.
  prefs: []
  type: TYPE_NORMAL
- en: If `strs` contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then
    `sorted()` will produce “tick,” “quiz,” “old,” “new,” “book,” and “around.” So
    for strings, reversing the natural order results in reversing the alphabetical
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and nulls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If `nrs`/`strs` contains `null` values as well, then all the previous examples
    will throw a `NullPointerException`. However, `java.util.Comparator` exposes two
    methods that allow us to sort `null` values first (`nullsFirst(Comparator<? super
    T> comparator)`) or last (`nullsLast(Comparator<? super T> comparator)`). They
    can be used as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The third example sorts the `null` values first, followed by the numbers in
    reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom comparators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we need a custom comparator. For instance, if we want to sort `strs`
    ascending by the last character, then we can write a custom comparator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: If `strs` contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then
    `sorted()` will produce “old,” “around,” “book,” “tick,” “new,” and “quiz.”
  prefs: []
  type: TYPE_NORMAL
- en: 'However, custom comparators are typically used to sort our models. For instance,
    if we need to sort the `cars` list, then we need to define a comparator. We cannot
    just say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not compile because there is no comparator for `Car` objects. An
    approach consists of implementing the `Comparable` interface and overriding the
    `compareTo(Car c)` method. For instance, if we want to sort `cars` ascending by
    `horsepower`, then we start by implementing `Comparable`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can successfully write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we cannot alter the `Car` code, we can try to use one of
    the existing `Comparator` methods, which allow us to push a function that contains
    the sort key and returns a `Comparator` that automatically compares by that key.
    Since `horsepower` is an integer, we can use `comparingInt(ToIntFunction<? super
    T> keyExtractor)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: You may also be interested in `comparingLong(ToLongFunction)` and `comparingDouble(ToDoubleFunction)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ToIntFunction`, `ToLongFunction`, and `ToDoubleFunction` are specializations
    of the `Function` method. In this context, we can say that `comparingInt()`,`comparingLong()`,
    and `comparingDouble()` are specializations of `comparing()`, which comes in two
    flavors: `comparing(Function<? super T,? extends U> keyExtractor)` and `comparing(Function<?
    super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using the second flavor of `comparing()` to sort `cars`
    ascending by the `fuel` type (natural order), with `null` values placed at the
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, here is another example of sorting `cars` ascending by the last character
    of the `fuel` type, with `null` values placed at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, chaining multiple comparators in a functional expression leads to
    a less readable code. In such cases, you can sustain the readablility of your
    code by importing statics and assigning the comparators to variables which names
    starting with “by” as in the following example (the result of this code is the
    same as the result of the previous example, but is more readable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Done! In the next problem, we will sort a map.
  prefs: []
  type: TYPE_NORMAL
- en: 200\. Sorting a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we have the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to sort this map into a `List<String>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the horsepower values are different, then sort in descending order by horsepower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the horsepower values are equal, then sort in ascending order by the map
    keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result, `List<String>`, should contain items of type *key(horsepower)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under these statements, sorting the `cars` map will result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this problem requires a custom comparator. Having two map entries
    `(c1, c2)`, we elaborate the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if `c2`'s horsepower is equal to `c1`'s horsepower
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they are equal, then compare `c1`'s key with `c2`'s key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, compare `c2`'s horsepower with `c1`'s horsepower
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the result into a `List`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In code lines, this can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we rely on `Map.Entry.comparingByValue()`, `comparingByKey()`,
    and `java.util.Comparator`, then we can write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: This approach is more readable and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 201\. Filtering a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to stream a map, we can start from the `entrySet()` of the `Map`,
    `values()`, or `keyset()`, followed by a `stream()` call. For instance, if we
    want to express a pipeline as *Map* -> *Stream* -> *Filter* -> *String* that returns
    a `List<String>` containing all the electric brands, then we can rely on `entrySet()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as you can see, this stream pipeline doesn’t use the map’s keys. This
    means that we can better express it via `values()` instead of `entrySet()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This is more readable, and it clearly expresses its intention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that you should be able to follow without further details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: So, when the stream pipeline needs only the map’s values, we can start from
    `values()`; when it needs only the keys, we can start from `keyset()`; and when
    it needs both (the values and the keys), we can start from `entrySet()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a stream pipeline expressed as *Map* -> *Stream* -> *Filter*
    -> *Map* that filters the top five cars by key and collects them into a resulting
    map needs the `entrySet()` starting point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example that returns a `Map` of the top five cars with more than
    100 horsepower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to express such pipelines quite often, then we may prefer to write
    some helpers. Here is a set of four generic helpers for filtering and sorting
    a `Map<K, V>` by key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'And a set for filtering and sorting a `Map` by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our code has become much shorter. For instance, we can filter the top
    five cars by key and collect them into a resulting map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can filter the top five cars with more than 100 horsepower,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right?! Feel free to extend `Filters` with more generic helpers to handle
    `Map` processing in stream pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 202\. Creating a custom collector via Collector.of()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a custom collector is a topic that we covered in detail in *Chapter
    9*, *Problem 193*, of *Java Coding Problem*, *First Edition*. More precisely,
    in that problem, you saw how to write a custom collector by implementing the `java.util.stream.Collector`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry if you haven’t read that book/problem; you can still follow this
    problem. First, we will create several custom collectors. This time, we will rely
    on two `Collector.of()` methods that have the following signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'In this context, `T`, `A`, and `R` represent the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` represents the type of elements from the `Stream` (elements that will be
    collected)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A` represents the type of object that was used during the collection process,
    known as the accumulator, which is used to accumulate the stream elements in a
    mutable result container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R` represents the type of the object after the collection process (the final
    result)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moreover, a `Collector` is characterized by four functions and an enumeration.
    Here’s a short note from *Java Coding Problems*, *First Edition*:'
  prefs: []
  type: TYPE_NORMAL
- en: “*These functions work together to accumulate entries into a mutable result
    container, and optionally perform a final transformation on the result. They are
    as follows:*
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a new empty mutable result container (the supplier argument)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Incorporating a new data element into the mutable result container (the accumulator
    argument)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Combining two mutable result containers into one (the combiner argument)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performing an optional final transformation on the mutable result container
    to obtain the final result (the finisher argument)*”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we have the `Collector.Characteristics...` enumeration that defines
    the collector behavior. Possible values are `UNORDERED` (no order), `CONCURRENT`
    (more threads accumulate elements), and `IDENTITY_FINISH` (the finisher is the
    identity function, so no further transformation will take place).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, let’s try to fire up a few examples. But first, let’s assume
    that we have the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s make some collectors in a helper class named `MyCollectors`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom collector that collects into a TreeSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a custom collector that collects into a `TreeSet` and the supplier is `TreeSet::new`,
    the accumulator is `TreeSet.add()`, the combiner relies on `TreeSet.addAll()`,
    and the finisher is the identity function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use this collector to collect all electric brands
    in a `TreeSet<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: That was easy!
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom collector that collects into a LinkedHashSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a custom collector that collects into a `LinkedHashSet` where the supplier
    is `LinkedHashSet::new`, the accumulator is `HashSet::add`, the combiner relies
    on `HashSet.addAll()`, and the finisher is the identity function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use this collector to collect the sorted cars’
    horsepower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Done! The `LinkedHashSet<Integer>` contains the horsepower values in ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom collector that excludes elements of another collector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this section is to provide a custom collector that takes, as arguments,
    a `Predicate` and a `Collector`. It applies the given `predicate` to elements
    to be collected, in order to exclude the failures from the given `collector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The custom collector uses the supplier, combiner, finisher, and characteristics
    of the given collector. It only influences the accumulator of the given collector.
    Basically, it explicitly calls the accumulator of the given collector only for
    the elements that pass the given predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we want to obtain the sorted horsepower less than 200 via
    this custom collector, then we call it as follows (the predicate specifies what
    should be excluded):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use two custom collectors, but we can easily replace the `toLinkedHashSet()`
    with a built-in collector as well. Challenge yourself to write the counterpart
    of this custom collector. Write a collector that includes the elements that pass
    the given predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom collector that collects elements by type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following `List<Vehicle>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal is to collect only the cars or the submersibles, but not both. For
    this, we can write a custom collector that collects by `type` into the given supplier,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can collect only the cars from `List<Vehicle>` into an `ArrayList`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can collect only the submersible into a `HashSet`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s write a custom collector for a custom data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom collector for SplayTree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Chapter 5*, *Problem 127*, we implemented a SplayTree data structure. Now,
    let’s write a custom collector capable of collecting elements into a SplayTree.
    Obviously, the supplier is `SplayTree::new`. Moreover, the accumulator is `SplayTree.insert()`,
    while the combiner is `SplayTree.insertAll()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example that collects the car’s horsepower into a SplayTree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Done! Challenge yourself to implement a custom collector.
  prefs: []
  type: TYPE_NORMAL
- en: 203\. Throwing checked exceptions from lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'What can we throw in the `catch` block? Most of you will know the answer; we
    can throw an unchecked exception such as a `RuntimeException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, most people know that we cannot throw a checked exception such as an
    `IOException`. The following snippet of code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we change this rule? Can we come up with a hack that allows us to throw
    checked exceptions from lambdas? Short answer: sure we can!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Long answer: sure we can, *if* we simply hide the checked exception for the
    compiler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all there is to it! Now, we can throw any checked exception. Here, we
    throw an `IOException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can catch it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'If a certain path was not found, then the reported error message will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right?!
  prefs: []
  type: TYPE_NORMAL
- en: 204\. Implementing distinctBy() for the Stream API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following model and data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the Stream API contains the `distinct()` intermediate operation,
    which is capable of keeping only the distinct elements based on the `equals()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'While this code prints the distinct cars, we may want a `distinctBy()` intermediate
    operation that is capable of keeping only the distinct elements based on a given
    property/key. For instance, we may need all the cars distinct by brand. For this,
    we can rely on the `toMap()` collector and the identity function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract this idea into a helper method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can use it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is a nice job that also works for `null` values, we can come up
    with other ideas that don’t work for `null` values. For instance, we can rely
    on `ConcurrentHashMap` and `putIfAbsent()`, as follows (again, this doesn’t work
    for `null` values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can optimize this approach a little bit and use a `Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use these two approaches, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: As a challenge, implement a `distinctByKeys()` operation using multiple keys.
  prefs: []
  type: TYPE_NORMAL
- en: 205\. Writing a custom collector that takes/skips a given number of elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Problem 202*, we wrote a handful of custom collectors grouped in the `MyCollectors`
    class. Now, let’s continue our journey, and let’s try to add two more custom collectors
    here to take and/or keep a given number of elements from the current stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume the following model and data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The Stream API provides an intermediate operation named `limit(long n)`, which
    can be used to truncate the stream to `n` elements. So, if this is exactly what
    we want, then we can use it out of the box. For instance, we can limit the resulting
    stream to the first five cars, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the Stream API provides an intermediate operation named `skip(long
    n)` , which can be used to skip the first `n` elements in the stream pipeline.
    For instance, we can skip the first five cars, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: However, there are cases when we need to compute different things and collect
    only the first/last five results. In such cases, a custom collector is welcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'By relying on the `Collector.of()` method (as detailed in *Problem 202*), we
    can write a custom collector that keeps/collects the first `n` elements, as follows
    (just for fun, let’s collect these *n* elements in an unmodifiable list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'So the supplier is `ArrayList::new`, the accumulator is `List.add()`, the combiner
    is `List.addAll()`, and the finalizer is `Collections::unmodifiableList`. Basically,
    the accumulator’s job is to accumulate elements only until the given `max` is
    reached. From that point forward, nothing gets accumulated. This way, we can keep
    only the first five cars, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we want to skip the first `n` elements and collect the
    rest, then we can try to accumulate `null` elements until we reach the given `index`.
    From this point forward, we accumulate the real elements. Finally, the finalizer
    removes the part of the list containing `null` values (from 0 to the given `index`)
    and returns an unmodifiable list from the remaining elements (from the given `index`
    to the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can optimize this approach by using a supplier class that
    contains the resulting list and a counter. While the given `index` is not reached,
    we simply increase the counter. Once the given `index` is reached, we start to
    accumulate elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these approaches can be used, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Challenge yourself to implement a custom collector that collects in a given
    range.
  prefs: []
  type: TYPE_NORMAL
- en: 206\. Implementing a Function that takes five (or any other arbitrary number
    of) arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that Java already has `java.util.function.Function` and the specialization
    of it, `java.util.function.BiFunction`. The `Function` interface defines the method
    `apply(T, t)`, while `BiFunction` has `apply(T t, U u)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, we can define a `TriFunction`, `FourFunction`, or (why not?)
    a `FiveFunction` functional interface, as follows (all of these are specializations
    of `Function`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: As its name suggests, this functional interface takes five arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use it! Let’s assume that we have the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The `compute()` method shapes a formula known as the Four-Parameter Logistic
    (4PL - [https://www.myassays.com/four-parameter-logistic-regression.html](https://www.myassays.com/four-parameter-logistic-regression.html)).
    Without getting into irrelevant details, we pass, as inputs, four variables (`a`,
    `b`, `c`, and `d`) and, for different values of the `x` coordinate, we compute
    the `y` coordinate. The (`x`, `y`) pair of coordinates describes a curve (linear
    graphic).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a `PL4` instance for each `x` coordinate, and for each such instance,
    we call the `compute()` method. This means that we can use the `FiveFunction`
    interface in `Logistics` via the following helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'This acts as a factory for `PL4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if all we need is just the list of `y` coordinates, then we can write
    a helper method in `Logistics`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this method as follows (here, we pass the 4PL formula, but it can
    be any other formula with five `double` parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete example in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 207\. Implementing a Consumer that takes five (or any other arbitrary number
    of) arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before continuing with this problem, I strongly recommend that you read *Problem
    206*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a custom `Consumer` that takes five arguments can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: This is the five-arity specialization of the Java `Consumer,` just as the built-in
    `BiConsumer` is the two-arity specialization of the Java `Consumer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `FiveConsumer` in conjunction with the PL4 formula, as follows (here,
    we compute `y` for `x` = 40.3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Logistics.pl4()` is the method that contains the formula and displays
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how we can partially apply a `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: 208\. Partially applying a Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Function` that is partially applied is a `Function` that applies only a
    part of its arguments, returning another `Function`. For instance, here is a `TriFunction`
    (a functional function with three arguments) that contains the `apply()` method,
    next to two `default` methods that partially apply this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `applyOnly(T1 t1)` applies only the `t1` argument and returns
    a `BiFunction`. On the other hand, `applyOnly(T1 t1, T2 t2)` applies only `t1`
    and `t2`, returning a `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can use these methods. For instance, let’s consider the formula
    (a+b+c)² = a²+b²+c²+2ab+2bc+2ca, which can be shaped via the `TriFunction`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we call `apply(T1 t1, T2 t2, T3 t3)` three times. As you can see, only
    the `c` term has a different value per call, while `a` and `b` are constantly
    equal with 1.0 and 2.0, respectively. This means that we can use `apply(T1 t1,
    T2 t2)` for `a` and `b`, and `apply(T1 t1)` for `c`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'If we assume that only `a` is constant (1.0) while `b` and `c` have different
    values per call, then we can use `apply(T1 t1)` for `a` and `apply(T1 t1, T2 t2)`
    for `b` and `c`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Mission accomplished!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered 24 problems. Most of them focused on working with predicates,
    functions, and collectors, but we also covered the JDK 16 `mapMulti()` operation,
    refactoring imperative code to functional code, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1139613064111216156.png)'
  prefs: []
  type: TYPE_IMG
