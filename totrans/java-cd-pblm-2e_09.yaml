- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Functional Style Programming – Extending APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式风格编程 – 扩展 API
- en: This chapter includes 24 problems covering a wide range of functional programming
    topics. We will start by introducing the JDK 16 `mapMulti()` operation, and continue
    with a handful of problems for working with predicates (`Predicate`), functions,
    and collectors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括涵盖广泛函数式编程主题的 24 个问题。我们将首先介绍 JDK 16 的 `mapMulti()` 操作，然后继续讨论一些使用谓词（`Predicate`）、函数和收集器的练习问题。
- en: If you don’t have a background in functional programming in Java, then I strongly
    recommend you postpone this chapter until you have spent some time getting familiar
    with it. You could consider reading *Chapters 8* and *9* from *Java Coding Problems*,
    *First Edition*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Java 函数式编程的背景，那么我强烈建议你推迟学习本章，直到你花了一些时间熟悉它。你可以考虑阅读《Java 编程问题》第一版中的第 8 章和第
    9 章。
- en: At the end of this chapter, you’ll be deeply skilled in functional programming
    in Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将精通 Java 中的函数式编程。
- en: Problems
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess in functional programming
    in Java. I strongly encourage you to give each problem a try before you turn to
    the solutions and download the example programs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在 Java 函数式编程中的编程能力。我强烈建议你在查看解决方案并下载示例程序之前尝试每个问题：
- en: '**Working with mapMulti()**: Explain and exemplify the JDK 16 `mapMulti()`.
    Provide a brief introduction, explain how it works in comparison with `flatMap()`,
    and point out when `mapMulti()` is a good fit.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 mapMulti()**：解释并举例说明 JDK 16 的 `mapMulti()`。提供简要介绍，解释它与 `flatMap()` 的工作方式，并指出何时
    `mapMulti()` 是一个好的选择。'
- en: '**Streaming custom code to map**: Imagine a class that shapes some blog posts.
    Each post is identified by a unique integer ID, and the post has several properties,
    including its tags. The tags of each post are actually represented as a string
    of tags separated by a hashtag (`#`). Whenever we need the list of tags for a
    given post, we can call the `allTags()` helper method. Our goal is to write a
    stream pipeline that extracts from this list of tags a `Map<String, List<Integer>>`
    containing, for each tag (key), the list of posts (value).'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将自定义代码流式传输到 map 中**：想象一个类，它处理一些博客文章。每篇文章都有一个唯一的整数 ID，文章有几个属性，包括其标签。每篇文章的标签实际上是以标签字符串的形式表示的，标签之间用井号（`#`）分隔。每当我们需要给定文章的标签列表时，我们都可以调用
    `allTags()` 辅助方法。我们的目标是编写一个流管道，从这个标签列表中提取一个 `Map<String, List<Integer>>`，其中每个标签（键）对应文章列表（值）。'
- en: '**Exemplifying a method reference vs. a lambda**: Write a relevant snippet
    of code to highlight the difference in behavior between a method reference and
    the equivalent lambda expression.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**展示方法引用与 lambda 的区别**：编写一段相关代码片段，以突出方法引用与等效 lambda 表达式之间的行为差异。'
- en: '**Hooking lambda laziness via Supplier/Consumer**: Write a Java program that
    highlights how `Supplier`/`Consumer` works. In this context, point out the lazy
    characteristic of lambdas.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过 Supplier/Consumer 捕获 lambda 的惰性**：编写一个 Java 程序，突出 `Supplier`/`Consumer`
    的工作方式。在此上下文中，指出 lambda 的惰性特征。'
- en: '**Refactoring code to add lambda laziness:** Provide a simple example of refactoring
    a piece of imperative code via functional code.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构代码以添加 lambda 惰性**：提供一个简单的示例，通过函数式代码重构一段命令式代码。'
- en: '**Writing a Function<String, T> to parse data**: Imagine a given text (`test,
    a, 1, 4, 5, 0xf5, 0x5, 4.5d, 6, 5.6, 50000, 345, 4.0f, 6$3, 2$1.1, 5.5, 6.7, 8,
    a11, 3e+1, -11199, 55`). Write an application that exposes a `Function<String,
    T>` capable of parsing this text, and extract only doubles, integers, longs, and
    so on.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写一个 Function<String, T> 来解析数据**：想象一个给定的文本（`test, a, 1, 4, 5, 0xf5, 0x5,
    4.5d, 6, 5.6, 50000, 345, 4.0f, 6$3, 2$1.1, 5.5, 6.7, 8, a11, 3e+1, -11199, 55`）。编写一个应用程序，公开一个能够解析此文本并提取双精度浮点数、整数、长整数等的
    `Function<String, T>`。'
- en: '**Composing predicates in a Stream’s filters**: Write several examples that
    highlight the usage of composite predicates in filters.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 Stream 的过滤器中组合谓词**：编写几个示例，突出复合谓词在过滤器中的使用。'
- en: '**Filtering nested collections with Streams**: Imagine that you have two nested
    collections. Provide several stream pipeline examples to filter data from the
    inner collection.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 Streams 过滤嵌套集合**：想象你有两个嵌套集合。提供几个流管道示例来从内部集合中过滤数据。'
- en: '**Using BiPredicate:** Exemplify the usage of `BiPredicate`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 BiPredicate**：举例说明 `BiPredicate` 的用法。'
- en: '**Building a dynamic predicate for a custom model**: Write an application capable
    of dynamically generating predicates (`Predicate`) based on some simple inputs.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为自定义模型构建动态谓词**：编写一个应用程序，能够根据一些简单的输入动态生成谓词（`Predicate`）。'
- en: '**Building a dynamic predicate from a custom map of conditions**: Consider
    having a map of conditions (the map’s key is a field, and the map’s value is the
    expected value for that field). In this context, write an application that dynamically
    generates the proper predicate.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从自定义条件映射构建动态谓词**：考虑有一个条件映射（映射的键是一个字段，映射的值是该字段的预期值）。在这种情况下，编写一个应用程序，动态生成适当的谓词。'
- en: '**Logging in predicates**: Write a custom solution that allows us to log failures
    in predicates.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在谓词中使用日志记录**：编写一个自定义解决方案，允许我们在谓词中记录失败。'
- en: '**Extending Stream with containsAll() and containsAny()**: Provide a solution
    that extends the Java Stream API with two final operations named `containsAll()`
    and `containsAny()`.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过containsAll()和containsAny()扩展Stream**：提供一个解决方案，通过名为`containsAll()`和`containsAny()`的两个最终操作扩展Java
    Stream API。'
- en: '**Extending Stream with removeAll() and retainAll()**: Provide a solution that
    extends the Java Stream API with two final operations named `removeAll()` and
    `retainAll()`.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过removeAll()和retainAll()扩展Stream**：提供一个解决方案，通过名为`removeAll()`和`retainAll()`的两个最终操作扩展Java
    Stream API。'
- en: '**Introducing stream comparators**: Provide a detailed covering (with examples)
    of using stream comparators.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍流比较器**：提供使用流比较器的详细说明（包括示例）。'
- en: '**Sorting a map**: Write several snippets of code to highlight different use
    cases for sorting a map.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排序映射**：编写几个代码片段来突出显示排序映射的不同用例。'
- en: '**Filtering a map**: Write several snippets of code to highlight different
    use cases for filtering a map.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过滤映射**：编写几个代码片段来突出显示过滤映射的不同用例。'
- en: '**Creating a custom collector via Collector.of()**: Write an arbitrarily chosen
    set of custom collectors via the `Collector.of()` API.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过Collector.of()创建自定义收集器**：通过`Collector.of()` API编写一组任意选择的自定义收集器。'
- en: '**Throwing checked exceptions from lambdas**: Provide a hack that allows us
    to throw checked exceptions from lambdas.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在lambda表达式中抛出检查型异常**：提供一个允许我们从lambda表达式中抛出检查型异常的技巧。'
- en: '**Implementing distinctBy() for the Stream API**: Write a Java application
    that implements the `distinctBy()` stream intermediate operation. This is like
    the built-in `distinct()`, only it allows us to filter distinct elements by a
    given property/field.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为Stream API实现distinctBy()**：编写一个Java应用程序，实现`distinctBy()`流中间操作。这类似于内置的`distinct()`，但它允许我们通过给定的属性/字段过滤不同的元素。'
- en: '**Writing a custom collector that takes/skips a given number of elements**:
    Provide a custom collector that allows us to collect only the first *n* elements.
    Moreover, provide a custom collector that skips the first *n* elements and collects
    the rest of them.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写一个自定义收集器，该收集器接受/跳过给定数量的元素**：提供一个自定义收集器，允许我们仅收集前*n*个元素。此外，提供一个自定义收集器，跳过前*n*个元素并收集其余元素。'
- en: '**Implementing a Function that takes five (or any other arbitrary number of)
    arguments**: Write and use a five-argument functional interface that represents
    a specialization of `java.util.function.Function`.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现一个接受五个（或任何其他任意数量）参数的函数**：编写并使用一个代表`java.util.function.Function`特殊化的五个参数的功能接口。'
- en: '**Implementing a Consumer that takes five (or any other arbitrary number of)
    arguments**: Write and use a five-argument functional interface that represents
    a specialization of `java.util.function.Consumer`.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现一个接受五个（或任何其他任意数量）参数的消费者**：编写并使用一个代表`java.util.function.Consumer`特殊化的五个参数的功能接口。'
- en: '**Partially applying a Function**: Write an *n*-arity functional interface
    that represents a specialization of `java.util.function.Function`. Moreover, this
    interface should provide support (i.e., provide the necessary `default` methods)
    to apply only *n*-1, *n*-2, *n*-3,…,1 argument(s).'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部分应用一个函数**：编写一个代表`java.util.function.Function`特殊化的*n*-元功能接口。此外，此接口应提供支持（即提供必要的`default`方法），以便仅应用*n*-1，*n*-2，*n*-3，…，1个参数。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节描述了先前问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节，并实验程序，请访问
    [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter09)。
- en: 185\. Working with mapMulti()
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 185. 使用 mapMulti()
- en: 'Starting with JDK 16, the Stream API was enriched with a new intermediate operation,
    named `mapMulti()`. This operation is represented by the following `default` method
    in the `Stream` interface:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 16 开始，Stream API 通过一个新的中间操作 `mapMulti()` 得到了增强。这个操作在 `Stream` 接口中由以下 `default`
    方法表示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s follow the learning-by-example approach and consider the next classical
    example, which uses a combination of `filter()` and `map()` to filter even integers
    and double their value:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用以例学例的方法，考虑下一个经典示例，它使用 `filter()` 和 `map()` 的组合来过滤偶数整数并加倍它们的值：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The same result can be obtained via `mapMulti()` as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式使用 `mapMulti()` 获得相同的结果：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So instead of using two intermediate operations, we used only one, `mapMulti()`.
    The `filter()` role was replaced by an `if` statement, and the `map()` role is
    accomplished in the `accept()` method. This time, we filtered the evens and doubled
    their values via `mapper`, which is a `BiConsumer<? super T, ? super Consumer<R>>`.
    This bi-function is applied to each integer (each stream element), and only the
    even integers are passed to the consumer. This consumer acts as a buffer that
    simply passes downstream (in the stream pipeline) the received elements. The `mapper.accept(R
    r)` can be called any number of times, which means that, for a given stream element,
    we can produce as many output elements as we need. In the previous example, we
    have a one-to-zero mapping (when `i % 2 == 0` is evaluated as `false`) and a one-to-one
    mapping (when `i % 2 == 0` is evaluated as `true`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是使用两个中间操作，而是只使用了一个，即 `mapMulti()`。`filter()` 的作用被一个 `if` 语句所取代，而 `map()`
    的作用则在 `accept()` 方法中完成。这次，我们通过 `mapper` 过滤了偶数并加倍了它们的值，其中 `mapper` 是一个 `BiConsumer<?
    super T, ? super Consumer<R>>`。这个双函数应用于每个整数（每个流元素），并且只有偶数整数被传递给消费者。这个消费者充当一个缓冲区，简单地向下传递（在流管道中）接收到的元素。`mapper.accept(R
    r)` 可以被调用任意次数，这意味着对于给定的流元素，我们可以产生我们需要的任意数量的输出元素。在先前的例子中，我们有一个一对一映射（当 `i % 2 ==
    0` 被评估为 `false` 时）和一个一对应多映射（当 `i % 2 == 0` 被评估为 `true` 时）。
- en: '**Important note**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: More precisely, `mapMulti()` gets an input stream of elements and outputs another
    stream containing zero, less, the same, or a larger number of elements that can
    be unaltered or replaced by other elements. This means that each element from
    the input stream can pass through a one-to-zero, one-to-one, or one-to-many mapping.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，`mapMulti()` 接收一个元素输入流，并输出另一个包含零个、较少、相同或更多元素（这些元素可以是未更改的或被其他元素替换）的流。这意味着输入流中的每个元素都可以通过一对一、一对应零或一对应多映射。
- en: Have you noticed the `<Integer>mapMulti(…)` type-witness applied to the returned
    value? Without this type-witness, the code will not compile because the compiler
    cannot determine the proper type of `R`. This is the shortcoming of using `mapMulti()`,
    so we have to pay this price.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到返回值上应用了 `<Integer>mapMulti(…)` 类型见证了吗？没有这个类型见证，代码将无法编译，因为编译器无法确定 `R` 的正确类型。这是使用
    `mapMulti()` 的不足之处，因此我们必须付出这个代价。
- en: 'For primitive types (`double`, `long`, and `int`) we have `mapMultiToDouble()`,
    `mapMultiToLong()`, and `mapMultiToInt()`, which return `DoubleStream`, `LongStream`,
    and `IntStream`, respectively. For instance, if we plan to sum the even integers,
    then using `mapMultiToInt()` is a better choice than `mapMulti()`, since we can
    skip the type-witness and work only with a primitive `int`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始类型（`double`、`long` 和 `int`），我们有 `mapMultiToDouble()`、`mapMultiToLong()`
    和 `mapMultiToInt()`，它们分别返回 `DoubleStream`、`LongStream` 和 `IntStream`。例如，如果我们计划求和偶数整数，那么使用
    `mapMultiToInt()` 比使用 `mapMulti()` 更好，因为我们可以跳过类型见证，只使用原始的 `int`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On the other hand, whenever you need a `Stream<T>` instead of `Double`/`Long`/`IntStream`,
    you still need to rely on `mapToObj()` or `boxed()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，无论何时你需要 `Stream<T>` 而不是 `Double`/`Long`/`IntStream`，你仍然需要依赖于 `mapToObj()`
    或 `boxed()`：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you get familiar with `mapMulti()`, you start to realize that it is pretty
    similar to the well-known `flatMap()`, which is useful to flatten a nested `Stream<Stream<R>>`
    model. Let’s consider the following one-to-many relationship:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦熟悉了 `mapMulti()`，你就会开始意识到它与众所周知的 `flatMap()` 非常相似，后者用于展开嵌套的 `Stream<Stream<R>>`
    模型。让我们考虑以下一对一关系：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Each `Author` has a list of books. So a `List<Author>` (candidate to become
    `Stream<Author>`) will nest a `List<Book>` (candidate to become a nested `Stream<Book>`)
    for each `Author`. Moreover, we have the following simple model for mapping an
    `author` and a single `book`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Author` 都有一系列书籍。因此，一个 `List<Author>`（可能成为 `Stream<Author>` 的候选）将为每个 `Author`
    嵌套一个 `List<Book>`（可能成为嵌套 `Stream<Book>` 的候选）。此外，我们还有以下简单的映射 `author` 和单个 `book`
    的模型：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In functional programming, mapping this one-to-many model to the flat `Bookshelf`
    model is a classical scenario for using `flatMap()` as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，将一对一多模型映射到扁平的 `Bookshelf` 模型是使用 `flatMap()` 的经典场景，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The problem with `flatMap()` is that we need to create a new intermediate stream
    for each author (for a large number of authors, this can become a performance
    penalty), and only afterward we can apply the `map()` operation. With `mapMulti()`,
    we don’t need these intermediate streams, and the mapping is straightforward:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()` 的问题在于我们需要为每位作者创建一个新的中间流（对于大量作者，这可能会成为性能惩罚），然后我们才能应用 `map()` 操作。使用
    `mapMulti()`，我们不需要这些中间流，映射过程非常直接：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a one-to-many mapping. For each author, the consumer buffers a number
    of `Bookshelf` instances equal to the number of author’s books. These instances
    are flattened over the downstream and are finally collected in a `List<Bookshelf>`
    via the `toList()` collector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一对一的映射。对于每位作者，消费者缓冲与作者书籍数量相等的 `Bookshelf` 实例。这些实例在下游中展开，最终通过 `toList()`
    收集器收集到一个 `List<Bookshelf>` 中。
- en: And this route takes us to the following important note on `mapMulti()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这条路径带我们来到了关于 `mapMulti()` 的另一个重要提示。
- en: '**Important note**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'The `mapMulti()` intermediate operation is useful when we have to replace just
    a few elements of the stream. This statement is formulated in the official documentation
    as follows: “*When replacing each stream element with a small (possibly zero)
    number of elements*.”'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须替换流中的少量元素时，`mapMulti()` 中间操作非常有用。这一陈述在官方文档中表述如下：“*当用少量（可能为零）的元素替换每个流元素时。”
- en: 'Next, check out this example based on `flatMap()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看基于 `flatMap()` 的这个示例：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This example fits perfectly when using `mapMulti()`. An author has a relatively
    small number of books, and we apply a filter on them. So basically, we replace
    each stream element with a small (possibly zero) number of elements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常适合使用 `mapMulti()`。一位作者有相对较少的书籍，我们对它们进行过滤。所以基本上，我们将每个流元素替换为少量（可能为零）的元素：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is better than using `flatMap()`, since we reduce the number of intermediate
    operations (no more `filter()` calls), and we avoided intermediate streams. This
    is also more readable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这比使用 `flatMap()` 更好，因为我们减少了中间操作的数量（不再有 `filter()` 调用），并且避免了中间流。这也更易于阅读。
- en: Another use case of `mapMulti()` is as follows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapMulti()` 的另一个用例如下。'
- en: '**Important note**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'The `mapMulti()` operation is also useful when the imperative approach is preferable
    against the stream approach. This statement is formulated in the official documentation
    as follows: “*When it is easier to use an imperative approach for generating result
    elements than it is to return them in the form of a* `Stream`.”'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用命令式方法生成结果元素比以 `Stream` 形式返回它们更容易时，`mapMulti()` 操作也非常有用。这一陈述在官方文档中表述如下：“*当使用命令式方法生成结果元素比以*
    `Stream` “*形式返回它们更容易时。”
- en: 'Imagine that we have added to the `Author` class the following method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们已经在 `Author` 类中添加了以下方法：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we get the `List<Bookshelf>` by simply using `mapMulti()`, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地使用 `mapMulti()` 来获取 `List<Bookshelf>`，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How cool is this?! In the next problem, we will use `mapMulti()` in another
    scenario.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？！在下一个问题中，我们将在另一个场景中使用 `mapMulti()`。
- en: 186\. Streaming custom code to map
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 186. 将自定义代码流式传输以映射
- en: 'Let’s assume that we have the following legacy class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下遗留类：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So we have a class that shapes some blog posts. Each post has several properties,
    including its tags. The tags of each post are actually represented as a string
    of tags separated by hashtag (`#`). Whenever we need the list of tags for a given
    post, we can call the `allTags()` helper. For instance, here is a list of posts
    and their tags:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个类，它塑造了一些博客文章。每篇文章都有几个属性，包括其标签。每篇文章的标签实际上是以哈希标签（`#`）分隔的标签字符串表示的。每当我们需要给定文章的标签列表时，我们可以调用`allTags()`辅助函数。例如，以下是一系列文章及其标签：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our goal is to extract from this list a `Map<String, List<Integer>>`, containing,
    for each tag (key) the list of posts (value). For instance, for the tag `#database`,
    we have articles 1 and 3; for tag `#rdbms`, we have articles 1, 2, 3, and 5, and
    so on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是从这个列表中提取一个`Map<String, List<Integer>>`，其中包含每个标签（键）的帖子列表（值）。例如，对于标签`#database`，我们有文章1和3；对于标签`#rdbms`，我们有文章1、2、3和5，等等。
- en: Accomplishing this task in functional programming can be done via `flatMap()`
    and `groupingBy()`. In a nutshell, `flatMap()` is useful for flattening a nested
    `Stream<Stream<R>>` model, while `groupingBy()` is a collector useful for grouping
    data in a map by some logic or property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中完成这项任务可以通过`flatMap()`和`groupingBy()`来实现。简而言之，`flatMap()`对于展开嵌套的`Stream<Stream<R>>`模型很有用，而`groupingBy()`是一个用于按某些逻辑或属性在map中分组数据的收集器。
- en: 'We need `flatMap()` because we have the `List<Post>` that, for each `Post`,
    nests via `allTags()` a `List<String>` (so if we simply call `stream()`, then
    we get back a `Stream<Stream<R>>`). After flattening, we wrap each tag in `Map.Entry<String,
    Integer>`. Finally, we group these entries by tags into a `Map`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`flatMap()`，因为我们有一个`List<Post>`，对于每个`Post`，通过`allTags()`嵌套一个`List<String>`（如果我们简单地调用`stream()`，那么我们得到的是一个`Stream<Stream<R>>`）。在展开后，我们将每个标签包装在`Map.Entry<String,
    Integer>`中。最后，我们将这些条目按标签分组到一个`Map`中，如下所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, based on the previous problem, we know that, starting with JDK 16,
    we can use `mapMulti()`. So, we can rewrite the previous snippet as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据前面的问题，我们知道从JDK 16开始，我们可以使用`mapMulti()`。因此，我们可以将之前的代码片段重写如下：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, we saved the `map()` intermediate operation and intermediate streams.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们保存了`map()`中间操作和中间流。
- en: 187\. Exemplifying a method reference vs. a lamda
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 187. 演示方法引用与lambda的区别
- en: Have you ever written a lambda expression and your IDE advises you to replace
    it with a method reference? You probably have! And I’m sure that you preferred
    to follow the replacement because *names matter*, and method references are often
    more readable than lambdas. While this is a subjective matter, I’m pretty sure
    you’ll agree that extracting long lambdas in methods and using/reusing them via
    method references is a generally accepted good practice.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经编写过一个lambda表达式，而你的IDE建议你用方法引用替换它？你很可能已经这样做了！我相信你更喜欢遵循替换，因为*名称很重要*，方法引用通常比lambda表达式更易读。虽然这是一个主观问题，但我很确信你会同意，在方法中提取长lambda表达式并通过方法引用使用/重用它们是一种普遍接受的良好实践。
- en: However, beyond some esoteric JVM internal representations, do they behave the
    same? Is there any difference between a lambda and a method reference that may
    affect how the code behaves?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了某些神秘的JVM内部表示之外，它们的行为是否相同？lambda表达式和方法引用之间是否有任何差异可能会影响代码的行为？
- en: 'Well, let’s assume that we have the following simple class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们假设我们有一个以下简单的类：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we assume that `p1` is a method reference and `p2` is the corresponding
    lambda, then we can perform the following calls:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设`p1`是一个方法引用，而`p2`是对应的lambda表达式，那么我们可以执行以下调用：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, let’s see two scenarios of working with `p1` and `p2`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看使用`p1`和`p2`的两个场景。
- en: 'Scenario 1: Calling printReset()'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景1：调用printReset()
- en: 'In the first scenario, we call `printReset()` via `p1` and `p2`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们通过`p1`和`p2`调用`printReset()`，如下所示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we run the code right now, then we get this output (the message generated
    by the `Printer` constructor):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行代码，那么我们会得到以下输出（由`Printer`构造函数生成的信息）：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This output is caused by the method reference, `p1`. The `Printer` constructor
    is invoked right away, even if we didn’t call the `run()` method. Because `p2`
    (the lambda) is lazy, the `Printer` constructor is not called until we call the
    `run()` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种输出是由方法引用`p1`引起的。即使我们没有调用`run()`方法，`Printer`构造函数也会立即被调用。因为`p2`（lambda表达式）是惰性的，所以只有在调用`run()`方法时才会调用`Printer`构造函数。
- en: 'Going further, we fire the chain of `run()` calls for `p1` and `p2`. The output
    will be:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，我们为`p1`和`p2`调用`run()`调用链。输出将是：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we analyze this output, we can see that the `Printer` constructor is called
    each time the lambda (`p2.run()`) is executed. On the other hand, for the method
    reference (`p1.run()`), the `Printer` constructor is not called. It was called
    a single time, at the `p1` declaration. So `p1` prints without resetting the printer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析这个输出，我们可以看到每次 lambda (`p2.run()`) 执行时都会调用 `Printer` 构造函数。另一方面，对于方法引用（`p1.run()`），`Printer`
    构造函数不会被调用。它只在一个地方被调用，即在 `p1` 声明时。所以 `p1` 打印时不会重置打印机。
- en: 'Scenario 2: Calling static printNoReset()'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景 2：调用静态 printNoReset()
- en: 'Next, let’s call the static method `printNoReset()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调用静态方法 `printNoReset()`：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we run the code right away, then nothing will happen (no output). Next,
    we fire up the `run()` calls, and we get this output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们立即运行代码，那么什么也不会发生（没有输出）。接下来，我们启动 `run()` 调用，我们得到以下输出：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `printNoReset()` is a static method, so the `Printer` constructor is not
    invoked. We can interchangeably use `p1` or `p2` without having any difference
    in behavior. So, in this case, it is just a matter of preference.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`printNoReset()` 是一个静态方法，所以不会调用 `Printer` 构造函数。我们可以互换使用 `p1` 或 `p2` 而不会有任何行为上的差异。所以，在这种情况下，这只是一种偏好。'
- en: Conclusion
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: When calling non-static methods, there is one main difference between a method
    reference and a lambda. A method reference calls the constructor immediately and
    only once (at method invocation (`run()`), the constructor is not called). On
    the other hand, lambdas are lazy. They call the constructor only at method invocation
    and at each such invocation (`run()`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用非静态方法时，方法引用和 lambda 之间有一个主要区别。方法引用立即且仅调用一次构造函数（在方法调用（`run()`）时，构造函数不会被调用）。另一方面，lambda
    是懒加载的。它们仅在方法调用时调用构造函数，并且在每个这样的调用（`run()`）中。
- en: 188\. Hooking lambda laziness via Supplier/Consumer
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 188. 通过 Supplier/Consumer 捕获 lambda 懒加载
- en: The `java.util.function.Supplier` is a functional interface capable of supplying
    results via its `get()` method. The `java.util.function.Consumer` is another functional
    interface capable of consuming the argument given via its `accept()` method. It
    returns no result (`void`). Both of these functional interfaces are lazy, so it
    is not that easy to analyze and understand code that uses them, especially when
    a snippet of code uses both. Let’s give it a try!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function.Supplier` 是一个可以通过其 `get()` 方法提供结果的函数式接口。`java.util.function.Consumer`
    是另一个可以通过其 `accept()` 方法消耗通过其提供的参数的函数式接口。它不返回任何结果（`void`）。这两个函数式接口都是懒加载的，因此分析和使用它们的代码并不容易，尤其是在代码片段同时使用这两个接口时。让我们试一试！'
- en: 'Consider the following simple class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的类：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And let’s write the following `Supplier` and `Consumer`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们编写以下 `Supplier` 和 `Consumer`：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, at this point, what is the value of `Counter.c`?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，到目前为止，`Counter.c` 的值是多少？
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The correct answer is, `Counter.c` is 0\. The supplier and the consumer are
    lazy, so none of the `get()` or `accept()` methods were called at their declarations.
    The `Counter.count()` was not invoked, so `Counter.c` was not incremented.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是，`Counter.c` 是 0。供应商和消费者都是懒加载的，所以在它们的声明中都没有调用 `get()` 或 `accept()` 方法。`Counter.count()`
    没有被调用，所以 `Counter.c` 没有增加。
- en: Here is a tricky one… how about now?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个棘手的问题……现在怎么样？
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We know that by calling `supplier.get()`, we trigger the `Counter.count()` execution,
    and `Counter.c` should be incremented and become 1\. However, the `supplier.get()`
    will return 0.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道通过调用 `supplier.get()`，我们触发了 `Counter.count()` 的执行，`Counter.c` 应该增加并变为 1。然而，`supplier.get()`
    将返回 0。
- en: 'The explanation resides in the `count()` method at line `return c++;`. When
    we write `c++`, we use the post-increment operation, so we use the current value
    of `c` in our statement (in this case, `return`), and afterward, we increment
    it by 1\. This means that `supplier.get()` gets back the value of `c` as 0, while
    the incrementation takes place after this `return`, and `Counter.c` is now 1:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解释位于 `count()` 方法的第 `return c++;` 行。当我们写 `c++` 时，我们使用后增量操作，因此我们在我们的语句中使用 `c`
    的当前值（在这种情况下，`return`），然后我们将其增加 1。这意味着 `supplier.get()` 返回 `c` 的值为 0，而增量操作发生在 `return`
    之后，此时 `Counter.c` 为 1：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we switch from post-increment (`c++`) to pre-increment (`++c`), then `supplier.get()`
    will get back the value of 1, which will be in sync with `Counter.c`. This happens
    because the incrementation takes place before the value is used in our statement
    (here, `return`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从后增量（`c++`）切换到前增量（`++c`），那么 `supplier.get()` 将返回 1，这将与 `Counter.c` 保持同步。这是因为增量操作在我们使用值之前发生（在这里，`return`）。
- en: 'OK, so far we know that `Counter.c` is equal to 1\. Next, let’s call the consumer
    and pass in the `Counter.c` value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止，我们知道`Counter.c`等于1。接下来，让我们调用消费者并传入`Counter.c`的值：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Via this call, we push the `Counter.c` (which is 1) in the following computation
    and display:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个调用，我们在以下计算和显示中推入`Counter.c`（它是1）：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So `c = c + Counter.count()` can be seen as `Counter.c = Counter.c + Counter.count()`,
    which is equivalent to 1 = 1 + `Counter.count()`, so 1 = 1 + 1\. The output will
    be `Consumer: 2`. This time, `Counter.c` is also 2 (remember the post-increment
    effect):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '因此`c = c + Counter.count()`可以看作`Counter.c = Counter.c + Counter.count()`，这相当于1
    = 1 + `Counter.count()`，所以1 = 1 + 1。输出将是`Consumer: 2`。这次，`Counter.c`也是2（记住后增量效应）：'
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, let’s invoke the supplier:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调用供应商：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We know that `get()` will receive the current value of `c`, which is 2\. Afterward,
    `Counter.c` becomes 3:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`get()`将接收`c`的当前值，它是2。之后，`Counter.c`变为3：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can continue like this forever, but I think you’ve got an idea of how the
    `Supplier` and `Consumer` functional interfaces work.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以永远这样继续下去，但我认为你已经了解了`Supplier`和`Consumer`函数式接口的工作方式。
- en: 189\. Refactoring code to add lambda laziness
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 189. 重新整理代码以添加lambda惰性
- en: 'In this problem, let’s have a refactoring session designed to transform a dysfunctional
    code into a functional one. We start from the following given code – a simple
    piece of class mapping information about application dependencies:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，让我们进行一次重构会话，将非功能代码转换为功能代码。我们从以下给定的代码开始——关于应用程序依赖项的简单类映射信息：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Why did we highlight the `getDependencies()` method? Because this is the point
    in the application where there is dysfunction. More precisely, the following class
    needs the dependencies of an application in order to process them accordingly:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们强调了`getDependencies()`方法？因为这是应用程序中存在功能障碍的点。更准确地说，以下类需要应用程序的依赖项以便相应地处理它们：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This class relies on the `ApplicationDependency.getDependecies()` method, which
    just returns `null` (the default value of the `dependencies` fields). The expected
    application’s dependencies were not downloaded, since the `downloadDependecies()`
    method was not called. Most probably, a code reviewer will signal this issue and
    raise a ticket to fix it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类依赖于`ApplicationDependency.getDependecies()`方法，它只返回`null`（`dependencies`字段的默认值）。由于没有调用`downloadDependecies()`方法，预期的应用程序依赖项没有被下载。很可能会有一位代码审查员指出这个问题并创建一个工单来修复它。
- en: Fixing in imperative fashion
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以命令式方式修复
- en: 'A possible fix will be as follows (in `ApplicationDependency`):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的修复方法如下（在`ApplicationDependency`中）：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Calling `downloadDependencies()` at `dependencies` initialization will definitely
    fix the problem of loading the dependencies. When the `DependencyManager` calls
    `getDependencies()`, it will have access to the downloaded dependencies. However,
    is this a good approach? I mean, downloading the dependencies is a costly operation,
    and we do it every time an `ApplicationDependency` instance is created. If the
    `getDependencies()` method is never called, then this costly operation doesn’t
    pay off the effort.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dependencies`初始化时调用`downloadDependencies()`肯定可以修复加载依赖项的问题。当`DependencyManager`调用`getDependencies()`时，它将能够访问已下载的依赖项。然而，这是一个好方法吗？我的意思是，下载依赖项是一个昂贵的操作，我们每次创建`ApplicationDependency`实例时都会这样做。如果`getDependencies()`方法从未被调用，那么这个昂贵的操作就没有得到回报。
- en: 'So a better approach would be to postpone the download of the application’s
    dependencies until `getDependencies()` is actually called:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个更好的方法是在`getDependencies()`实际调用之前推迟应用程序依赖项的下载：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is better, but it is not the best approach! This time, the application’s
    dependencies are downloaded every time the `getDependencies()` method is called.
    Fortunately, there is a quick fix for this. We just need to add a `null` check
    before performing the download:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前好，但还不是最佳方法！这次，每次调用`getDependencies()`方法时都会下载应用程序的依赖项。幸运的是，有一个快速的修复方法。我们只需要在执行下载之前添加一个`null`检查：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Done! Now, the application’s dependencies are downloaded only at the first call
    of the `getDependencies()` method. This imperative solution works like a charm
    and passes the code review.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，应用程序的依赖项只在第一次调用`getDependencies()`方法时下载。这个命令式解决方案效果很好，并且通过了代码审查。
- en: Fixing in functional fashion
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以函数式方式修复
- en: 'How about providing this fix in a functional programming fashion? Practically,
    all we want is to lazy-download the application’s dependencies. Since laziness
    is a specialty of functional programming, and we’re now familiar with the `Supplier`
    (see the previous problem), we can start as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于以函数式编程的方式提供这个修复方案怎么样？实际上，我们想要的只是惰性下载应用程序的依赖项。由于惰性是函数式编程的专长，我们现在已经熟悉了`Supplier`（参见前一个问题），我们可以从以下开始：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we defined a `Supplier` that calls the `downloadDependencies()` method.
    We know that the `Supplier` is lazy, so nothing happens until its `get()` method
    is explicitly called.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个调用`downloadDependencies()`方法的`Supplier`。我们知道`Supplier`是惰性的，所以直到其`get()`方法被明确调用之前，不会发生任何事情。
- en: Second, we have modified `getDependencies()` to return `dependencies.get()`.
    So we delay the application’s dependencies downloading until they are explicitly
    required.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们已修改`getDependencies()`方法，使其返回`dependencies.get()`。因此，我们将应用程序依赖项的下载延迟到它们被明确需要时。
- en: Third, we modified the return type of the `downloadDependencies()` method from
    `void` to `String`. This is needed for the `Supplier.get()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们将`downloadDependencies()`方法的返回类型从`void`修改为`String`。这是为了`Supplier.get()`。
- en: This is a nice fix, but it has a serious shortcoming. We lost the caching! Now,
    the dependencies will be downloaded at every `getDependencies()` call.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的修复方案，但它有一个严重的缺点。我们失去了缓存！现在，依赖项将在每次`getDependencies()`调用时下载。
- en: We can avoid this issue via *memoization* ([https://en.wikipedia.org/wiki/Memoization](https://en.wikipedia.org/wiki/Memoization)).
    This concept is also covered in detail in *Chapter 8* of *The Complete Coding
    Interview Guide in Java*. In a nutshell, memoization is a technique used to avoid
    duplicate work by caching results that can be reused later.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过*记忆化*（[https://en.wikipedia.org/wiki/Memoization](https://en.wikipedia.org/wiki/Memoization)）来避免这个问题。这个概念在*《Java完整编码面试指南》*的第*第8章*中也有详细说明。简而言之，记忆化是一种通过缓存可重用结果来避免重复工作的技术。
- en: 'Memoization is a technique commonly applied in dynamic programming, but there
    are no restrictions or limitations. For instance, we can apply it in functional
    programming. In our particular case, we start by defining a functional interface
    that extends the `Supplier` interface (or, if you find it simpler, just use `Supplier`
    directly):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一种在动态规划中常用到的技术，但没有任何限制或限制。例如，我们可以在函数式编程中应用它。在我们的特定情况下，我们首先定义了一个扩展`Supplier`接口的功能接口（或者，如果你觉得更简单，可以直接使用`Supplier`）：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we provide an implementation of `FSupplier` that basically cashes the
    unseen results and serves, from the cache, the already seen ones:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供了一个`FSupplier`的实现，它基本上缓存了未查看的结果，并从缓存中提供已查看的结果：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we replace our initial `Supplier` with `FSupplier`, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的初始`Supplier`替换为`FSupplier`，如下所示：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Done! Our functional approach takes advantage of `Supplier`'s laziness and can
    cache the results.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们的函数式方法利用了`Supplier`的惰性并可以缓存结果。
- en: 190\. Writing a Function<String, T> for parsing data
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 190. 编写一个`Function<String, T>`来解析数据
- en: 'Let’s assume that we have the following text:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下文本：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The goal is to find a solution that extracts from this text only the numbers.
    Depending on a given scenario, we may need only the integers, or only the doubles,
    and so on. Sometimes, we may need to perform some text replacements before extraction
    (for instance, we may want to replace the `xf` characters with a dot, `0xf5 =
    0.5`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是从这段文本中提取出数字。根据给定的场景，我们可能只需要整数，或者只需要双精度浮点数，等等。有时，我们可能需要在提取之前进行一些文本替换（例如，我们可能想要将`xf`字符替换为点，`0xf5
    = 0.5`）。
- en: 'A possible solution to this problem is to write a method (let’s name it `parseText()`)
    that takes as an argument a `Function<String, T>`. The `Function<String, T>` gives
    us the flexibility to shape any of the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的可能方法之一是编写一个方法（让我们称它为`parseText()`），它接受一个`Function<String, T>`作为参数。`Function<String,
    T>`给我们提供了灵活性，可以塑造以下任何一种：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `parseText()` should perform several steps until it reaches the final result.
    Its signature can be as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseText()`应该执行几个步骤，直到达到最终结果。它的签名可以是以下这样：'
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, we have to split the received text by the comma delimiter and extract
    the items in a `String[]`. This way, we have access to each item from the text.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须通过逗号分隔符拆分接收到的文本，并从`String[]`中提取项目。这样，我们就能够访问文本中的每个项目。
- en: Second, we can stream the `String[]` and filter any empty items.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以流式传输`String[]`并过滤掉任何空项。
- en: Third, we can call the `Function.apply()` to apply the given function to each
    item (for instance, to apply `Double::valueOf`). This can be done via the intermediate
    operation `map()`. Since some items may be invalid numbers, we have to catch and
    ignore any `Exception` (it is bad practice to swallow an exception like this,
    but in this case, there is really nothing else to do). For any invalid number,
    we simply return `null`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们可以调用`Function.apply()`将给定的函数应用于每个项目（例如，应用`Double::valueOf`）。这可以通过中间操作`map()`来完成。由于一些项目可能是无效的数字，我们必须捕获并忽略任何`Exception`（吞咽这样的异常是不良的做法，但在这个情况下，实际上没有其他事情可做）。对于任何无效的数字，我们简单地返回`null`。
- en: Fourth, we filter all `null` values. This means that the remaining stream contains
    only numbers that passed through `Function.apply()`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们过滤掉所有`null`值。这意味着剩余的流只包含通过`Function.apply()`过滤的数字。
- en: Fifth, we collect the stream in a `List` and return it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第五，我们将流收集到一个`List`中并返回它。
- en: 'Putting these five steps together will result in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将这五个步骤组合起来，将得到以下代码：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Done! You can use this example to solve a wide range of similar problems.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！您可以用这个例子解决一系列类似的问题。
- en: 191\. Composing predicates in a Stream’s filters
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 191. 在Stream的过滤器中组合谓词
- en: A predicate (basically, a condition) can be modeled as a Boolean-valued function
    via the `java.util.function.Predicate` functional interface. Its functional method
    is named `test(T t)` and returns a `boolean`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个谓词（基本上，一个条件）可以通过`java.util.function.Predicate`函数式接口建模为一个布尔值函数。它的函数方法是名为`test(T
    t)`并返回一个`boolean`。
- en: 'Applying predicates in a stream pipeline can be done via several stream intermediate
    operations, but we are interested here only in the `filter(Predicate p)` operation.
    For instance, let’s consider the following class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在流管道中应用谓词可以通过几个流中间操作来完成，但我们这里只对`filter(Predicate p)`操作感兴趣。例如，让我们考虑以下类：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we have a `List<Car>` and we want to express a filter that produces all
    the cars that are Chevrolets, then we can start by defining the proper `Predicate`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`List<Car>`并且我们想要表达一个过滤条件，产生所有雪佛兰汽车，那么我们可以先定义适当的`Predicate`：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we can use this `Predicate` in a stream pipeline, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在流管道中使用这个`Predicate`，如下所示：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A `Predicate` can be negated in at least three ways. We can negate the condition
    via the logical not (`!`) operator:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Predicate`可以通过至少三种方式取反。我们可以通过逻辑非(`!`)运算符取反条件：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can call the `Predicate.negate()` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`Predicate.negate()`方法：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Or we can call the `Predicate.not()` method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以调用`Predicate.not()`方法：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'No matter which of these three approaches you prefer, the following filter
    will produce all cars that are not Chevrolets:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您更喜欢哪种方法，以下过滤器将产生所有不是雪佛兰的汽车：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the previous examples, we applied a single predicate in a stream pipeline.
    However, we can apply multiple predicates as well. For instance, we may want to
    express a filter that produces all the cars that are not Chevrolets and have at
    least 150 horsepower. For the first part of this composite predicate, we can arbitrarily
    use `pChevrolets.negate()`, while, for the second part, we need the following
    `Predicate`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在流管道中应用了一个谓词。然而，我们也可以应用多个谓词。例如，我们可能想要表达一个过滤条件，产生所有不是雪佛兰且至少有150马力的汽车。对于这个复合谓词的第一部分，我们可以任意使用`pChevrolets.negate()`，而对于第二部分，我们需要以下`Predicate`：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can obtain a composite predicate by chaining the `filter()` calls, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过链式调用`filter()`来获得一个复合谓词，如下所示：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It is shorter and more expressive to rely on `Predicate.and(Predicate<? super
    T> other)`, which applies the short-circuiting logical AND between two predicates.
    So the previous example is better expressed as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于`Predicate.and(Predicate<? super T> other)`可以使代码更简洁、更易于表达，它会在两个谓词之间应用短路逻辑与。所以前面的例子可以这样表达：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we need to apply the short-circuiting logical OR between two predicates,
    then relying on `Predicate.or(Predicate<? super T> other)` is the proper choice.
    For instance, if we want to express a filter that produces all Chevrolets or electric
    cars, then we can do it as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在两个谓词之间应用短路逻辑或，那么依赖于`Predicate.or(Predicate<? super T> other)`是正确的选择。例如，如果我们想要表达一个过滤条件，产生所有雪佛兰或电动汽车，那么我们可以这样做：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we are in a scenario that heavily relies on composite predicates, then we
    can start by creating two helpers that make our job easier:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于一个高度依赖复合谓词的场景中，那么我们可以先创建两个辅助函数，使我们的工作更容易：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The goal of these helpers is to take several predicates and glue them into a
    single composite predicate, via the short-circuiting logical AND and OR.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助函数的目标是将几个谓词粘合在一起，通过短路逻辑与和或形成一个单一的组合谓词。
- en: 'Let’s assume that we want to express a filter that applies the following three
    predicates via the short-circuiting logical AND:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要表达一个通过短路逻辑与应用以下三个谓词的过滤条件：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, we join these predicates in a single one:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将这些谓词合并为一个单一的谓词：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Afterward, we express the filter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们表达过滤条件：
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'How about expressing a filter that produces a stream containing all cars with
    horsepower between 100 and 200 or 300 and 400? The predicates are:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 那么表达一个产生包含所有马力在100到200或300到400之间的汽车的流的过滤条件怎么样？谓词如下：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The composite predicate can be obtained as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 组合谓词可以按照以下方式获得：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Expressing the filter is straightforward:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表达过滤条件很简单：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can find all these examples in the bundled code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中找到所有这些示例。
- en: 192\. Filtering nested collections with Streams
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 192. 使用Streams过滤嵌套集合
- en: 'This is a classical problem in interviews that usually starts from a model,
    as follows (we assume that the collection is a `List`):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个面试中的经典问题，通常从一个模型开始，如下（我们假设集合是一个`List`）：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Having `List<Author>` denoted as `authors`, write a stream pipeline that returns
    the `List<Book>` published in 2002\. You already should recognize this as a typical
    problem for `flatMap()`, so without further details, we can write this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将`List<Author>`表示为`authors`，编写一个流管道，返回在2002年出版的`List<Book>`。你应该已经认识到这是一个典型的`flatMap()`问题，所以无需进一步细节，我们可以写出如下代码：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'OK, that’s crystal clear! How about finding the `List<Author>` with books published
    in 2002? Of course, `mapMulti()` can help us again. All we have to do is to loop
    the books, and when we find a book published in 2002, we simply pass the `author`
    to the `consumer` instead of the book. Moreover, after passing the `author` to
    the `consumer`, we can break the loop for the current author and take the next
    one:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这已经很清晰了！那么，我们如何找到在2002年出版的`List<Author>`呢？当然，`mapMulti()`可以再次帮助我们。我们只需要遍历书籍，当我们找到一个在2002年出版的书籍时，我们只需将`author`传递给`consumer`而不是书籍。此外，在将`author`传递给`consumer`之后，我们可以中断当前作者的循环，并取下一个作者：
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Another approach can rely on `anyMatch()` and a predicate that produces a stream
    of books published in 2002, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可以依赖于`anyMatch()`和一个产生2002年出版书籍流的谓词，如下所示：
- en: '[PRE69]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Typically, we don’t want to alter the given list, but if that is not an issue
    (or it is exactly what we want), then we can rely on `removeIf()` to accomplish
    the same result directly on the `List<Author>`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不想修改给定的列表，但如果这不是问题（或者这正是我们想要的），那么我们可以依赖`removeIf()`直接在`List<Author>`上完成相同的结果：
- en: '[PRE70]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Done! Now, you should have no issues if a problem like this comes up in your
    interviews.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，如果你在面试中遇到类似的问题，你应该不会有任何问题。
- en: 193\. Using BiPredicate
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 193. 使用BiPredicate
- en: 'Let’s consider the `Car` model and a `List<Car>` denoted as `cars`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`Car`模型和一个表示为`cars`的`List<Car>`：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Our goal is to see if the following `Car` is contained in `cars`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是查看以下`Car`是否包含在`cars`中：
- en: '[PRE72]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We know that the `List` API exposes a method named `contains(Object o)`. This
    method returns `true` if the given `Object` is present in the given `List`. So,
    we can easily write a `Predicate`, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`List` API公开了一个名为`contains(Object o)`的方法。此方法在给定的`Object`存在于给定的`List`中时返回`true`。因此，我们可以轻松地编写一个`Predicate`，如下所示：
- en: '[PRE73]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, we call the `test()` method, and we should get the expected result:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`test()`方法，我们应该得到预期的结果：
- en: '[PRE74]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can obtain the same result in a stream pipeline via `filter()`, `anyMatch()`,
    and so on. Here is via `anyMatch()`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`filter()`、`anyMatch()`等在流管道中获得相同的结果。这里是通过`anyMatch()`实现的：
- en: '[PRE75]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Alternatively, we can rely on `BiPredicate`. This is a functional interface
    representing a two-arity specialization of the well-known `Predicate`. Its `test(Object
    o1, Object o2)` method gets two arguments, so it is a perfect fit for our case:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以依赖`BiPredicate`。这是一个表示已知`Predicate`的两个参数特殊化的函数式接口。它的`test(Object o1,
    Object o2)`方法接受两个参数，因此它非常适合我们的情况：
- en: '[PRE76]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can perform the test as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式执行测试：
- en: '[PRE77]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the next problem, you’ll see a more practical example of using a `BiPredicate`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，你将看到一个使用`BiPredicate`的更实际的例子。
- en: 194\. Building a dynamic predicate for a custom model
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 194. 为自定义模型构建动态谓词
- en: 'Let’s consider the `Car` model and a `List<Car>` denoted as cars:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`Car`模型和一个表示为`cars`的`List<Car>`：
- en: '[PRE78]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Also, let’s assume that we need to dynamically produce a wide range of predicates
    that apply the operators `<`, `>`, `<=`, `>=`, `!=`, and `==` to the `horsepower`
    field. It will be cumbersome to hardcode such predicates, so we have to come up
    with a solution that can build, on the fly, any predicate that involves this field,
    and one of the comparison operators listed here.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设我们需要动态生成一系列谓词，这些谓词将`<`、`>`、`<=`、`>=`、`!=`和`==`运算符应用于`horsepower`字段。直接硬编码这些谓词会很麻烦，因此我们必须想出一个解决方案，可以即时构建任何涉及此字段和此处列出的比较运算符的谓词。
- en: 'There are a few approaches to accomplish this goal, and one of them is to use
    a Java `enum`. We have a fixed list of operators that can be coded as `enum` elements,
    as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这个目标，其中之一是使用Java `enum`。我们有一个固定的运算符列表，可以编码为`enum`元素，如下所示：
- en: '[PRE79]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In order to apply any of these `(t, u)` lambdas, we need a `BiPredicate` constructor
    (see *Problem 193*), as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用这些`(t, u)`lambda表达式之一，我们需要一个`BiPredicate`构造函数（参见*问题193*），如下所示：
- en: '[PRE80]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now that we can define a `BiPredicate`, we can write the method that contains
    the actual test and returns a `Predicate<T>`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够定义一个`BiPredicate`，我们可以编写包含实际测试并返回`Predicate<T>`的方法：
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we have to provide here the `Function<T, Integer>`, which is the getter
    corresponding to `horsepower`. We can do this via Java Reflection, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须提供这里的`Function<T, Integer>`，这是对应于`horsepower`的getter。我们可以通过Java反射来完成此操作，如下所示：
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Of course, it can be any other class and integer field as well, not only the
    `Car` class and the `horsepower` field. Based on this code, we can dynamically
    create a predicate, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也可以是任何其他类和整数字段，而不仅仅是`Car`类和`horsepower`字段。基于此代码，我们可以动态创建一个谓词，如下所示：
- en: '[PRE83]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Using this predicate is straightforward:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此谓词很简单：
- en: '[PRE84]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You can use this problem as a source of inspiration to implement more types
    of dynamic predicates. For example, in the next problem, we use the same logic
    in another scenario.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这个问题作为实现更多类型动态谓词的灵感来源。例如，在下一个问题中，我们在另一个场景中使用了相同的逻辑。
- en: 195\. Building a dynamic predicate from a custom map of conditions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 195. 从自定义条件映射构建动态谓词
- en: 'Let’s consider the `Car` model and a `List<Car>` denoted as `cars`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`Car`模型和表示为`cars`的`List<Car>`：
- en: '[PRE85]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Also, let’s assume that we receive a `Map` of conditions of type *field : value,*
    which could be used to build a dynamic `Predicate`. An example of such a `Map`
    is listed here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，假设我们收到一个类型为*field : value*的`Map`条件，这可以用来构建动态`Predicate`。此类`Map`的示例如下：'
- en: '[PRE86]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'As you can see, we have a `Map<String, String>`, so we are interested in an
    `equals()` comparison. This is useful to start our development via the following
    Java `enum` (we follow the logic from *Problem 194*):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个`Map<String, String>`，因此我们对`equals()`比较感兴趣。这有助于我们通过以下Java `enum`（我们遵循*问题194*中的逻辑）开始开发：
- en: '[PRE87]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Of course, we can add more operators, such as `startsWith()`, `endsWith()`,
    `contains()`, and so on. Next, based on the experience gained in *Problems 193*
    and *194*, we need to add a `BiPredicate` constructor, the `toPredicate()` method,
    and the Java Reflection code to fetch the getters corresponding to the given fields
    (here, `brand` and `fuel`):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以添加更多运算符，例如`startsWith()`、`endsWith()`、`contains()`等等。接下来，基于在*问题193*和*194*中获得的经验，我们需要添加一个`BiPredicate`构造函数、`toPredicate()`方法和Java反射代码来获取给定字段（此处为`brand`和`fuel`）对应的getter：
- en: '[PRE88]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we have to define a predicate for each map entry and chain them via the
    short-circuiting AND operator. This can be done in a loop, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须为每个映射条目定义一个谓词，并通过短路AND运算符将它们链接起来。这可以通过以下循环完成：
- en: '[PRE89]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, we can use the resulting predicate to filter the cars:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用生成的谓词来过滤汽车：
- en: '[PRE90]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Done!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: 196\. Logging in predicates
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 196. 谓词的登录
- en: We already know that the `Predicate` functional interface relies on its `test()`
    method to perform the given check, and it returns a Boolean value. Let’s suppose
    that we want to alter the `test()` method to log the failure cases (the cases
    that lead to the return of a `false` value).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道`Predicate`函数式接口依赖于其`test()`方法来执行给定的检查，并返回一个布尔值。假设我们想要修改`test()`方法以记录失败案例（导致返回`false`值的案例）。
- en: 'A quick approach is to write a helper method that sneaks the logging part,
    as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一种快速的方法是编写一个辅助方法，偷偷地包含日志部分，如下所示：
- en: '[PRE91]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Another approach consists of extending the `Predicate` interface and providing
    a `default` method for testing and logging the failure cases, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过扩展 `Predicate` 接口，并提供一个 `default` 方法来测试和记录失败案例，如下所示：
- en: '[PRE92]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You can practice these examples in the bundled code.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中练习这些示例。
- en: 197\. Extending Stream with containsAll() and containsAny()
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 197. 使用 containsAll() 和 containsAny() 扩展 Stream
- en: 'Let’s assume that we have the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下代码：
- en: '[PRE93]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Next, in the context of a stream pipeline, we want to check if `cars` contains
    all/any of `car1`, `car2`, `car3`, or `cars123`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在流管道的上下文中，我们想检查 `cars` 是否包含 `car1`、`car2`、`car3` 或 `cars123` 的所有/任何项。
- en: 'The Stream API comes with a rich set of intermediate and final operations,
    but it doesn’t have a built-in `containsAll()`/`containsAny()`. So, it is our
    mission to provide the following final operations:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Stream API 提供了一组丰富的中间和最终操作，但它没有内置的 `containsAll()`/`containsAny()`。因此，我们的任务是提供以下最终操作：
- en: '[PRE94]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We highlighted the methods that get a `Stream` argument, since these methods
    provide the main logic, while the rest of the methods just call these ones after
    converting their arguments to a `Stream`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们突出了获取 `Stream` 参数的方法，因为这些方法提供了主要逻辑，而其余的方法只是在将它们的参数转换为 `Stream` 后调用这些方法。
- en: Exposing containsAll/Any() via a custom interface
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过自定义接口来暴露 containsAll/Any()
- en: 'The `containsAll(Stream<? extends T> items)` relies on a `Set` to accomplish
    its job, as follows (as a challenge, try to find an alternative implementation):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`containsAll(Stream<? extends T> items)` 依赖于一个 `Set` 来完成其任务，如下所示（作为一个挑战，尝试找到另一种实现方法）：'
- en: '[PRE95]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `containsAny(Stream<? extends T> items)` method also relies on a `Set`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`containsAny(Stream<? extends T> items)` 方法也依赖于一个 `Set`：'
- en: '[PRE96]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `toSet()` method is just a helper that collects the `Stream` items into
    a `Set`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`toSet()` 方法只是一个辅助工具，它将 `Stream` 项收集到一个 `Set` 中：'
- en: '[PRE97]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Next, let’s sneak this code into its final place, which is a custom interface.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们偷偷地将这段代码放入其最终位置，即一个自定义界面。
- en: As you can see, the `containsAll(Stream<? extends T> items)` method and `containsAny(Stream<?
    extends T> items)` are declared as `default`, which means that they are part of
    an interface. Moreover, both of them call the `stream()` method, which is also
    part of this interface and hooks the regular `Stream`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`containsAll(Stream<? extends T> items)` 方法和 `containsAny(Stream<? extends
    T> items)` 被声明为 `default`，这意味着它们是接口的一部分。此外，它们都调用了 `stream()` 方法，这也是接口的一部分，并连接了常规的
    `Stream`。
- en: 'Basically, a quick approach for solving this problem (especially useful in
    interviews) consists of writing this custom interface (let’s arbitrarily name
    it `Streams`) that has access to the original built-in `Stream` interface, as
    follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，解决这个问题的快速方法（特别是在面试中非常有用）是编写这个自定义接口（让我们随意命名为 `Streams`），它能够访问原始的内置 `Stream`
    接口，如下所示：
- en: '[PRE98]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, the interface exposes a set of `default` methods that represent the `containsAll()`/`containsAny()`
    flavors, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，该接口公开了一组 `default` 方法，代表 `containsAll()`/`containsAny()` 的风味，如下所示：
- en: '[PRE99]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Done! Now, we can write different stream pipelines that use the brand-new `containsAll`/`Any()`
    operations. For instance, if we want to check if `cars` contains all items from
    `cars123`, we express the stream pipeline as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们可以编写使用全新的 `containsAll`/`Any()` 操作的不同流管道。例如，如果我们想检查 `cars` 是否包含 `cars123`
    中的所有项，我们可以将流管道表达如下：
- en: '[PRE100]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here are several more examples:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的例子：
- en: '[PRE101]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Involving more operations can be done as shown in the following example:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下示例所示，可以涉及更多操作：
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: A more expressive and complete solution to this problem consists of extending
    the `Stream` interface. Let’s do it!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的更简洁和完整的解决方案是扩展 `Stream` 接口。让我们来做吧！
- en: Exposing containsAll/Any() via an extension of Stream
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过扩展 Stream 来暴露 containsAll/Any()
- en: 'The previous solution can be considered more like a hack. A more logical and
    realistic solution consists of extending the built-in Stream API and adding our
    `containsAll`/`Any()` methods as teammates next to the `Stream` operations. So
    the implementation starts as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的解决方案更像是一种黑客行为。一个更合理和现实的解决方案是扩展内置的 Stream API，并将我们的 `containsAll`/`Any()`
    方法作为团队成员添加到 `Stream` 操作旁边。因此，实现开始如下：
- en: '[PRE103]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Before implementing the `containsAll`/`Any()` methods, we need to handle some
    aspects resulting from extending the `Stream` interface. First, we need to override
    in `Streams` each of the `Stream` methods. Since the `Stream` interface has a
    lot of methods, we only list a few of them here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `containsAll`/`Any()` 方法之前，我们需要处理一些由扩展 `Stream` 接口产生的问题。首先，我们需要在 `Streams`
    中覆盖每个 `Stream` 方法。由于 `Stream` 接口有很多方法，我们这里只列出其中一些：
- en: '[PRE104]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Since `Streams` can handle only sequential streams (parallelism is not supported),
    we can implement the `isParallel()`, `parallel()`, `unordered()`, and `sequential()`
    methods as `default` methods directly in `Streams`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Streams` 只能处理顺序流（不支持并行），我们可以直接在 `Streams` 中实现 `isParallel()`、`parallel()`、`unordered()`
    和 `sequential()` 方法作为 `default` 方法。
- en: 'Next, in order to use `Streams`, we need a `from(Stream s)` method that is
    capable of wrapping the given `Stream`, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了使用 `Streams`，我们需要一个 `from(Stream s)` 方法，它能够包装给定的 `Stream`，如下所示：
- en: '[PRE105]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `StreamsWrapper` is a class that wraps the current `Stream` into sequential
    `Streams`. The `StreamsWrapper` class implements `Streams`, so it has to override
    all the `Streams` methods and properly wrap the `Stream` into `Streams`. Because
    `Streams` has quite a lot of methods (as a consequence of extending `Stream`),
    we list here only a few of them (the rest are available in the bundled code):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamsWrapper` 是一个将当前 `Stream` 包装成顺序 `Streams` 的类。`StreamsWrapper` 类实现了 `Streams`，因此它必须覆盖所有
    `Streams` 方法，并正确地将 `Stream` 包装成 `Streams`。由于 `Streams` 有很多方法（这是扩展 `Stream` 的结果），我们这里只列出其中一些（其余的可以在捆绑的代码中找到）：'
- en: '[PRE106]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, we add `Streams` to the `containsAll`/`Any()` methods, which are quite
    straightforward (since `Streams` extends `Stream`, we have access to all the `Stream`
    goodies without the need to write a `stream()` hack, as in the previous solution).
    First, we add the `containsAll()` methods:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `Streams` 添加到 `containsAll`/`Any()` 方法中，这些方法相当直接（由于 `Streams` 扩展了 `Stream`，我们无需编写
    `stream()` 演技，就可以访问所有 `Stream` 的优点，就像在先前的解决方案中那样）。首先，我们添加 `containsAll()` 方法：
- en: '[PRE107]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Second, we add the `containsAny()` methods:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们添加 `containsAny()` 方法：
- en: '[PRE108]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Finally, we add the `toSet()` method, which you already know:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了 `toSet()` 方法，您已经知道了：
- en: '[PRE109]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Mission accomplished! Now, let’s write some examples:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！现在，让我们写一些示例：
- en: '[PRE110]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You can find more examples in the bundled code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中找到更多示例。
- en: 198\. Extending Stream with removeAll() and retainAll()
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 198\. 通过 `removeAll()` 和 `retainAll()` 扩展 Stream
- en: Before reading this problem, I strongly recommend that you read *Problem 197*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这个问题之前，我强烈建议您阅读 *问题 197*。
- en: 'In *Problem 197*, we extended the Stream API with two final operations named
    `containsAll()` and `containsAny()` via a custom interface. In both cases, the
    resulting interface was named `Streams`. In this problem, we follow the same logic
    to implement two intermediate operations, named `removeAll()` and `retainAll()`,
    with the following signatures:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *问题 197* 中，我们通过自定义接口扩展了 Stream API，添加了两个名为 `containsAll()` 和 `containsAny()`
    的最终操作。在两种情况下，生成的接口都命名为 `Streams`。在这个问题中，我们遵循相同的逻辑来实现两个名为 `removeAll()` 和 `retainAll()`
    的中间操作，其签名如下：
- en: '[PRE111]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Since `removeAll()` and `retainAll()` are intermediate operations, they have
    to return `Stream`. More precisely, they have to return `Streams`, which is our
    implementation based on a custom interface or an interface that extends `Stream`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `removeAll()` 和 `retainAll()` 是中间操作，它们必须返回 `Stream`。更确切地说，它们必须返回 `Streams`，这是我们基于自定义接口或扩展
    `Stream` 的接口的实现。
- en: Exposing removeAll()/retainAll() via a custom interface
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过自定义接口公开 `removeAll()`/`retainAll()`
- en: 'The `removeAll(Stream<? extends T> items)` method relies on a `Set` to accomplish
    its job, as follows (as a challenge, try to find an alternative implementation):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeAll(Stream<? extends T> items)` 方法依赖于 `Set` 来完成其任务，如下所示（作为一个挑战，尝试找到另一种实现）：'
- en: '[PRE112]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `retainAll(Stream<? extends T> items)` method also relies on a `Set`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`retainAll(Stream<? extends T> items)` 方法也依赖于 `Set`：'
- en: '[PRE113]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `toSet()` method is just a helper that collects the `Stream` items into
    a `Set`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`toSet()` 方法只是一个收集 `Stream` 项到 `Set` 的辅助工具：'
- en: '[PRE114]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Next, we can sneak these `default` methods into a custom interface named `Streams`,
    exactly as we did in *Problem 197*:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将这些 `default` 方法悄悄地放入一个名为 `Streams` 的自定义接口中，就像我们在 *问题 197* 中做的那样：
- en: '[PRE115]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'There is a big problem with this implementation. The problem becomes obvious
    when we try to chain `removeAll()`/`retainAll()` in a stream pipeline next to
    other `Stream` operations. Because these two methods return `Streams` (not `Stream`),
    we cannot chain a `Stream` operation after them without first calling the Java
    built-in `stream()` before them. This is needed to switch from `Streams` to `Stream`.
    Here is an example (using `cars`, `car1`, `car2`, `car3`, and `car123`, as introduced
    in *Problem 197*):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现有一个大问题。当我们尝试在流管道中链式调用`removeAll()`/`retainAll()`旁边其他`Stream`操作时，问题变得明显。因为这两个方法返回`Streams`（而不是`Stream`），我们无法在它们之后链式调用`Stream`操作，而必须首先调用Java内置的`stream()`。这是从`Streams`切换到`Stream`所需要的。以下是一个示例（使用在*问题197*中引入的`cars`，`car1`，`car2`，`car3`和`car123`）：
- en: '[PRE116]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The problem becomes even worse if we have to alternate between `Streams` and
    `Stream` multiple times. Check out this zombie:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须在`Streams`和`Stream`之间多次交替，问题会变得更加严重。查看这个僵尸：
- en: '[PRE117]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This hack is not a happy choice to enrich the Stream API with intermediate operations.
    However, it works quite well for terminal operations. So, the proper approach
    is to extend the `Stream` interface.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧并不是一个令人愉快的选项来丰富Stream API的中间操作。然而，它对于终端操作工作得相当好。因此，正确的方法是扩展`Stream`接口。
- en: Exposing removeAll/retainAll() via an extension of Stream
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过扩展Stream暴露removeAll/retainAll()
- en: 'We already know from *Problem 197* how to extend the `Stream` interface. The
    implementation of `removeAll()` is also straightforward:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从*问题197*中了解到如何扩展`Stream`接口。`removeAll()`的实现也是直接的：
- en: '[PRE118]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Then, `retainAll()` follows in the same manner:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以同样的方式跟随`retainAll()`：
- en: '[PRE119]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'As you know from *Problem 197*, next, we have to override all the `Stream`
    methods to return `Streams`. While this part is available in the bundled code,
    here is an example of using `removeAll()`/`retainAll()`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从*问题197*中知道，接下来，我们必须重写所有`Stream`方法以返回`Streams`。虽然这部分代码在捆绑代码中可用，以下是如何使用`removeAll()`/`retainAll()`的示例：
- en: '[PRE120]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As you can see, this time, the stream pipeline looks quite good. There is no
    need to perform switches between `Streams` and `Stream` via `stream()` calls.
    So, mission accomplished!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次，流管道看起来相当好。没有必要通过`stream()`调用在`Streams`和`Stream`之间进行切换。所以，任务完成了！
- en: 199\. Introducing stream comparators
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 199. 引入流比较器
- en: 'Let’s assume that we have the following three lists (a list of numbers, a list
    of strings, and a list of `Car` objects):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下三个列表（一个数字列表，一个字符串列表和一个`Car`对象列表）：
- en: '[PRE121]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Next, we want to sort these lists in a stream pipeline.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想在流管道中对这些列表进行排序。
- en: Sorting via natural order
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过自然顺序排序
- en: 'Sorting via natural order is very simple. All we have to do is to call the
    built-in intermediate operation, `sorted()`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自然顺序排序非常简单。我们只需要调用内置的中间操作`sorted()`：
- en: '[PRE122]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If `nrs` contains 1, 6, 3, 8, 2, 3, and 0, then `sorted()` will produce 0, 1,
    2, 3, 3, 6, and 8\. So, for numbers, the natural order is the ascending order
    by value.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nrs`包含1，6，3，8，2，3和0，那么`sorted()`将产生0，1，2，3，3，6和8。因此，对于数字，自然顺序是按值升序排列。
- en: If `strs` contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then
    `sorted()` will produce “around,” “book,” “new,” “old,” “quiz,” and “tick”. So,
    for strings, the natural order is the alphabetical order.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`strs`包含“book”，“old”，“new”，“quiz”，“around”和“tick”，那么`sorted()`将产生“around”，“book”，“new”，“old”，“quiz”和“tick”。因此，对于字符串，自然顺序是字母顺序。
- en: 'The same result can be obtained if we explicitly call `Integer.compareTo()`
    and `String.compareTo()` via `sorted(Comparator<? super T> comparator)`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们显式地通过`sorted(Comparator<? super T> comparator)`调用`Integer.compareTo()`和`String.compareTo()`，可以得到相同的结果：
- en: '[PRE123]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Alternatively, we can use the `java.util.Comparator` functional interface,
    as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`java.util.Comparator`函数式接口，如下所示：
- en: '[PRE124]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: All three approaches return the same result.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法返回相同的结果。
- en: Reversing the natural order
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转自然顺序
- en: 'Reversing the natural order can be done via `Comparator.reverseOrder()`, as
    follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`Comparator.reverseOrder()`反转自然顺序，如下所示：
- en: '[PRE125]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: If `nrs` contains 1, 6, 3, 8, 2, 3, and 0, then `sorted()` will produce 8, 6,
    3, 3, 2, 1, and 0\. Reversing the natural order of numbers results in descending
    order by value.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nrs`包含1，6，3，8，2，3和0，那么`sorted()`将产生8，6，3，3，2，1和0。反转数字的自然顺序将按值降序排列。
- en: If `strs` contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then
    `sorted()` will produce “tick,” “quiz,” “old,” “new,” “book,” and “around.” So
    for strings, reversing the natural order results in reversing the alphabetical
    order.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`strs`包含“book”，“old”，“new”，“quiz”，“around”和“tick”，那么`sorted()`将产生“tick”，“quiz”，“old”，“new”，“book”和“around”。所以对于字符串，反转自然顺序会导致反转字母顺序。
- en: Sorting and nulls
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和null值
- en: 'If `nrs`/`strs` contains `null` values as well, then all the previous examples
    will throw a `NullPointerException`. However, `java.util.Comparator` exposes two
    methods that allow us to sort `null` values first (`nullsFirst(Comparator<? super
    T> comparator)`) or last (`nullsLast(Comparator<? super T> comparator)`). They
    can be used as shown in the following examples:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nrs`/`strs`包含`null`值，那么所有之前的示例都将抛出`NullPointerException`。然而，`java.util.Comparator`提供了两个方法，允许我们首先（`nullsFirst(Comparator<?
    super T> comparator)`)或最后（`nullsLast(Comparator<? super T> comparator)`）对`null`值进行排序。它们的使用方法如下面的示例所示：
- en: '[PRE126]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The third example sorts the `null` values first, followed by the numbers in
    reverse order.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例首先对`null`值进行排序，然后按逆序排序数字。
- en: Writing custom comparators
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义比较器
- en: 'Sometimes, we need a custom comparator. For instance, if we want to sort `strs`
    ascending by the last character, then we can write a custom comparator, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个自定义比较器。例如，如果我们想按最后一个字符对`strs`进行升序排序，那么我们可以编写一个自定义比较器，如下所示：
- en: '[PRE127]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: If `strs` contains “book,” “old,” “new,” “quiz,” “around,” and “tick,” then
    `sorted()` will produce “old,” “around,” “book,” “tick,” “new,” and “quiz.”
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`strs`包含“book”，“old”，“new”，“quiz”，“around”和“tick”，那么`sorted()`将产生“old”，“around”，“book”，“tick”，“new”和“quiz”。
- en: 'However, custom comparators are typically used to sort our models. For instance,
    if we need to sort the `cars` list, then we need to define a comparator. We cannot
    just say:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自定义比较器通常用于对模型进行排序。例如，如果我们需要排序`cars`列表，那么我们需要定义一个比较器。我们不能只是说：
- en: '[PRE128]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'This will not compile because there is no comparator for `Car` objects. An
    approach consists of implementing the `Comparable` interface and overriding the
    `compareTo(Car c)` method. For instance, if we want to sort `cars` ascending by
    `horsepower`, then we start by implementing `Comparable`, as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译，因为没有为`Car`对象提供比较器。一种方法是实现`Comparable`接口并重写`compareTo(Car c)`方法。例如，如果我们想按`horsepower`对`cars`进行升序排序，那么我们首先实现`Comparable`，如下所示：
- en: '[PRE129]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, we can successfully write this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以成功编写这个：
- en: '[PRE130]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Alternatively, if we cannot alter the `Car` code, we can try to use one of
    the existing `Comparator` methods, which allow us to push a function that contains
    the sort key and returns a `Comparator` that automatically compares by that key.
    Since `horsepower` is an integer, we can use `comparingInt(ToIntFunction<? super
    T> keyExtractor)`, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们不能修改`Car`代码，我们可以尝试使用现有的`Comparator`方法之一，这些方法允许我们传递一个包含排序键的函数，并返回一个自动按该键比较的`Comparator`。由于`horsepower`是整数，我们可以使用`comparingInt(ToIntFunction<?
    super T> keyExtractor)`，如下所示：
- en: '[PRE131]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Here it is in reverse order:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是反转顺序：
- en: '[PRE132]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You may also be interested in `comparingLong(ToLongFunction)` and `comparingDouble(ToDoubleFunction)`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还对`comparingLong(ToLongFunction)`和`comparingDouble(ToDoubleFunction)`感兴趣。
- en: '`ToIntFunction`, `ToLongFunction`, and `ToDoubleFunction` are specializations
    of the `Function` method. In this context, we can say that `comparingInt()`,`comparingLong()`,
    and `comparingDouble()` are specializations of `comparing()`, which comes in two
    flavors: `comparing(Function<? super T,? extends U> keyExtractor)` and `comparing(Function<?
    super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)`.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToIntFunction`，`ToLongFunction`和`ToDoubleFunction`是`Function`方法的特殊化。在这个上下文中，我们可以说`comparingInt()`，`comparingLong()`和`comparingDouble()`是`comparing()`的特殊化，`comparing()`有两种风味：`comparing(Function<?
    super T,? extends U> keyExtractor)`和`comparing(Function<? super T,? extends U>
    keyExtractor, Comparator<? super U> keyComparator)`。'
- en: 'Here is an example of using the second flavor of `comparing()` to sort `cars`
    ascending by the `fuel` type (natural order), with `null` values placed at the
    end:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`comparing()`的第二种风味按`fuel`类型（自然顺序）对`cars`进行升序排序的示例，将`null`值放在末尾：
- en: '[PRE133]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Also, here is another example of sorting `cars` ascending by the last character
    of the `fuel` type, with `null` values placed at the end:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里还有一个按`fuel`类型的最后一个字符对`cars`进行升序排序的示例，将`null`值放在末尾：
- en: '[PRE134]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Usually, chaining multiple comparators in a functional expression leads to
    a less readable code. In such cases, you can sustain the readablility of your
    code by importing statics and assigning the comparators to variables which names
    starting with “by” as in the following example (the result of this code is the
    same as the result of the previous example, but is more readable):'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在函数表达式中链式多个比较器会导致代码可读性降低。在这种情况下，您可以通过导入静态并分配以“by”开头的变量来保持代码的可读性，如下例所示（此代码的结果与上一个示例相同，但更易于阅读）：
- en: '[PRE135]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Done! In the next problem, we will sort a map.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！在下一个问题中，我们将对映射进行排序。
- en: 200\. Sorting a map
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 200. 对映射进行排序
- en: 'Let’s assume that we have the following map:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下映射：
- en: '[PRE136]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Next, we want to sort this map into a `List<String>`, as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望将此映射排序到 `List<String>` 中，如下所示：
- en: If the horsepower values are different, then sort in descending order by horsepower
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果马力值不同，则按马力降序排序
- en: If the horsepower values are equal, then sort in ascending order by the map
    keys
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果马力值相等，则按映射键的升序排序
- en: The result, `List<String>`, should contain items of type *key(horsepower)*
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果 `List<String>` 应包含类型为 *键(马力)* 的项
- en: 'Under these statements, sorting the `cars` map will result in:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些语句下，对 `cars` 映射进行排序将得到：
- en: '[PRE137]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Obviously, this problem requires a custom comparator. Having two map entries
    `(c1, c2)`, we elaborate the following logic:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个问题需要一个自定义的比较器。有两个映射条目 `(c1, c2)`，我们详细阐述以下逻辑：
- en: Check if `c2`'s horsepower is equal to `c1`'s horsepower
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `c2` 的马力是否等于 `c1` 的马力
- en: If they are equal, then compare `c1`'s key with `c2`'s key
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们相等，则比较 `c1` 的键与 `c2` 的键
- en: Otherwise, compare `c2`'s horsepower with `c1`'s horsepower
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，比较 `c2` 的马力与 `c1` 的马力
- en: Collect the result into a `List`
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果收集到 `List` 中
- en: 'In code lines, this can be expressed as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，这可以表示如下：
- en: '[PRE138]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Alternatively, if we rely on `Map.Entry.comparingByValue()`, `comparingByKey()`,
    and `java.util.Comparator`, then we can write it as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们依赖于 `Map.Entry.comparingByValue()`、`comparingByKey()` 和 `java.util.Comparator`，则可以写成如下：
- en: '[PRE139]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This approach is more readable and expressive.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更易于阅读和表达。
- en: 201\. Filtering a map
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 201. 过滤映射
- en: 'Let’s consider the following map:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下映射：
- en: '[PRE140]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In order to stream a map, we can start from the `entrySet()` of the `Map`,
    `values()`, or `keyset()`, followed by a `stream()` call. For instance, if we
    want to express a pipeline as *Map* -> *Stream* -> *Filter* -> *String* that returns
    a `List<String>` containing all the electric brands, then we can rely on `entrySet()`
    as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 为了流映射，我们可以从 `Map` 的 `entrySet()`、`values()` 或 `keyset()` 开始，然后调用 `stream()`。例如，如果我们想表达一个表示为
    *Map* -> *Stream* -> *Filter* -> *String* 的管道，它返回包含所有电动汽车品牌的 `List<String>`，则可以依赖
    `entrySet()` 如下：
- en: '[PRE141]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'However, as you can see, this stream pipeline doesn’t use the map’s keys. This
    means that we can better express it via `values()` instead of `entrySet()`, as
    follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，这个流管道没有使用映射的键。这意味着我们可以通过 `values()` 而不是 `entrySet()` 更好地表达它，如下所示：
- en: '[PRE142]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This is more readable, and it clearly expresses its intention.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这更易于阅读，并且清楚地表达了其意图。
- en: 'Here is another example that you should be able to follow without further details:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，你应该能够理解而不需要进一步细节：
- en: '[PRE143]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: So, when the stream pipeline needs only the map’s values, we can start from
    `values()`; when it needs only the keys, we can start from `keyset()`; and when
    it needs both (the values and the keys), we can start from `entrySet()`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当流管道只需要映射的值时，我们可以从 `values()` 开始；当它只需要键时，我们可以从 `keyset()` 开始；当它需要两者（值和键）时，我们可以从
    `entrySet()` 开始。
- en: 'For instance, a stream pipeline expressed as *Map* -> *Stream* -> *Filter*
    -> *Map* that filters the top five cars by key and collects them into a resulting
    map needs the `entrySet()` starting point, as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个表示为 *Map* -> *Stream* -> *Filter* -> *Map* 的流管道，它通过键过滤前五辆汽车并将它们收集到结果映射中，需要从
    `entrySet()` 开始，如下所示：
- en: '[PRE144]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Here is an example that returns a `Map` of the top five cars with more than
    100 horsepower:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个返回具有超过 100 马力的前五辆汽车的映射的例子：
- en: '[PRE145]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'If we need to express such pipelines quite often, then we may prefer to write
    some helpers. Here is a set of four generic helpers for filtering and sorting
    a `Map<K, V>` by key:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要经常表达这样的管道，那么我们可能更喜欢编写一些辅助函数。以下是一组用于按键过滤和排序 `Map<K, V>` 的四个通用辅助函数：
- en: '[PRE146]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'And a set for filtering and sorting a `Map` by value:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 用于按值过滤和排序 `Map` 的集合：
- en: '[PRE147]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now, our code has become much shorter. For instance, we can filter the top
    five cars by key and collect them into a resulting map, as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码已经变得非常简短。例如，我们可以通过键过滤前五辆汽车并将它们收集到结果映射中，如下所示：
- en: '[PRE148]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Alternatively, we can filter the top five cars with more than 100 horsepower,
    as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以按照以下方式过滤出马力超过 100 的前五辆汽车：
- en: '[PRE149]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Cool, right?! Feel free to extend `Filters` with more generic helpers to handle
    `Map` processing in stream pipelines.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？！请随意扩展 `Filters` 以包含更多通用辅助函数，以处理流管道中的 `Map` 处理。
- en: 202\. Creating a custom collector via Collector.of()
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 202. 通过 Collector.of() 创建自定义收集器
- en: Creating a custom collector is a topic that we covered in detail in *Chapter
    9*, *Problem 193*, of *Java Coding Problem*, *First Edition*. More precisely,
    in that problem, you saw how to write a custom collector by implementing the `java.util.stream.Collector`
    interface.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Java Coding Problem*，第一版，第 *9* 章，*问题 193* 中，我们详细介绍了创建自定义收集器这个主题。更确切地说，在那个问题中，您看到了如何通过实现
    `java.util.stream.Collector` 接口来编写自定义收集器。
- en: 'Don’t worry if you haven’t read that book/problem; you can still follow this
    problem. First, we will create several custom collectors. This time, we will rely
    on two `Collector.of()` methods that have the following signatures:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有阅读那本书/问题，请不要担心；您仍然可以跟随这个问题。首先，我们将创建几个自定义收集器。这次，我们将依赖于两个具有以下签名的 `Collector.of()`
    方法：
- en: '[PRE150]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'In this context, `T`, `A`, and `R` represent the following:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`T`、`A` 和 `R` 代表以下内容：
- en: '`T` represents the type of elements from the `Stream` (elements that will be
    collected)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T` 代表 `Stream` 的元素类型（将被收集的元素）'
- en: '`A` represents the type of object that was used during the collection process,
    known as the accumulator, which is used to accumulate the stream elements in a
    mutable result container'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A` 代表在集合过程中使用的对象类型，称为累加器，它用于在可变结果容器中累积流元素'
- en: '`R` represents the type of the object after the collection process (the final
    result)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R` 代表集合过程之后对象的类型（最终结果）'
- en: 'Moreover, a `Collector` is characterized by four functions and an enumeration.
    Here’s a short note from *Java Coding Problems*, *First Edition*:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个 `Collector` 由四个函数和一个枚举来表征。以下是 *Java Coding Problems*，第一版中的一段简短笔记：
- en: “*These functions work together to accumulate entries into a mutable result
    container, and optionally perform a final transformation on the result. They are
    as follows:*
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: “*这些函数协同工作，将条目累积到可变结果容器中，并可选择对结果执行最终转换。它们如下：*
- en: '*Creating a new empty mutable result container (the supplier argument)*'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个新的空可变结果容器（提供者参数）*'
- en: '*Incorporating a new data element into the mutable result container (the accumulator
    argument)*'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将新的数据元素合并到可变结果容器中（累加器参数）*'
- en: '*Combining two mutable result containers into one (the combiner argument)*'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将两个可变结果容器合并为一个（组合器参数）*'
- en: '*Performing an optional final transformation on the mutable result container
    to obtain the final result (the finisher argument)*”'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对可变结果容器执行可选的最终转换以获得最终结果（完成器参数）*'
- en: In addition, we have the `Collector.Characteristics...` enumeration that defines
    the collector behavior. Possible values are `UNORDERED` (no order), `CONCURRENT`
    (more threads accumulate elements), and `IDENTITY_FINISH` (the finisher is the
    identity function, so no further transformation will take place).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有 `Collector.Characteristics...` 枚举，它定义了收集器的行为。可能的值有 `UNORDERED`（无顺序）、`CONCURRENT`（更多线程累积元素）和
    `IDENTITY_FINISH`（完成器是恒等函数，因此不会进行进一步转换）。
- en: 'In this context, let’s try to fire up a few examples. But first, let’s assume
    that we have the following model:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，让我们尝试运行几个示例。但首先，让我们假设我们有以下模型：
- en: '[PRE151]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Also, some data:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些数据：
- en: '[PRE152]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Next, let’s make some collectors in a helper class named `MyCollectors`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在名为 `MyCollectors` 的辅助类中创建一些收集器。
- en: Writing a custom collector that collects into a TreeSet
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个将元素收集到 TreeSet 的自定义收集器
- en: 'In a custom collector that collects into a `TreeSet` and the supplier is `TreeSet::new`,
    the accumulator is `TreeSet.add()`, the combiner relies on `TreeSet.addAll()`,
    and the finisher is the identity function:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个将元素收集到 `TreeSet` 并以 `TreeSet::new` 为提供者的自定义收集器中，累加器是 `TreeSet.add()`，组合器依赖于
    `TreeSet.addAll()`，完成器是恒等函数：
- en: '[PRE153]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'In the following example, we use this collector to collect all electric brands
    in a `TreeSet<String>`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用这个收集器收集所有电品牌到 `TreeSet<String>` 中：
- en: '[PRE154]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: That was easy!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单！
- en: Writing a custom collector that collects into a LinkedHashSet
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个将元素收集到 LinkedHashSet 的自定义收集器
- en: 'In a custom collector that collects into a `LinkedHashSet` where the supplier
    is `LinkedHashSet::new`, the accumulator is `HashSet::add`, the combiner relies
    on `HashSet.addAll()`, and the finisher is the identity function:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个将收集器收集到`LinkedHashSet`的自定义收集器中，其中供应商是`LinkedHashSet::new`，累加器是`HashSet::add`，组合器依赖于`HashSet.addAll()`，而完成器是恒等函数：
- en: '[PRE155]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'In the following example, we use this collector to collect the sorted cars’
    horsepower:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用这个收集器来收集排序后的汽车马力：
- en: '[PRE156]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Done! The `LinkedHashSet<Integer>` contains the horsepower values in ascending
    order.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！`LinkedHashSet<Integer>`包含按升序排列的马力值。
- en: Writing a custom collector that excludes elements of another collector
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个排除另一个收集器元素的定制收集器
- en: 'The goal of this section is to provide a custom collector that takes, as arguments,
    a `Predicate` and a `Collector`. It applies the given `predicate` to elements
    to be collected, in order to exclude the failures from the given `collector`:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是提供一个自定义收集器，它接受一个`Predicate`和一个`Collector`作为参数。它将给定的`predicate`应用于要收集的元素，以排除给定`collector`中的失败项：
- en: '[PRE157]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The custom collector uses the supplier, combiner, finisher, and characteristics
    of the given collector. It only influences the accumulator of the given collector.
    Basically, it explicitly calls the accumulator of the given collector only for
    the elements that pass the given predicate.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义收集器使用给定的供应商、组合器、完成器和特性。它只影响给定收集器的累加器。基本上，它只显式调用给定收集器的累加器，对于通过给定谓词的元素。
- en: 'For instance, if we want to obtain the sorted horsepower less than 200 via
    this custom collector, then we call it as follows (the predicate specifies what
    should be excluded):'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想通过这个自定义收集器获取小于200的排序马力，那么我们可以这样调用它（谓词指定了应该排除的内容）：
- en: '[PRE158]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Here, we use two custom collectors, but we can easily replace the `toLinkedHashSet()`
    with a built-in collector as well. Challenge yourself to write the counterpart
    of this custom collector. Write a collector that includes the elements that pass
    the given predicate.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两个自定义收集器，但我们可以轻松地将`toLinkedHashSet()`替换为一个内置收集器。挑战自己编写这个自定义收集器的对应版本。编写一个收集通过给定谓词通过的元素的收集器。
- en: Writing a custom collector that collects elements by type
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个按类型收集元素的定制收集器
- en: 'Let’s suppose that we have the following `List<Vehicle>`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下`List<Vehicle>`：
- en: '[PRE159]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Our goal is to collect only the cars or the submersibles, but not both. For
    this, we can write a custom collector that collects by `type` into the given supplier,
    as follows:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是只收集汽车或潜水艇，而不是两者。为此，我们可以编写一个自定义收集器，通过`type`收集到给定的供应商中，如下所示：
- en: '[PRE160]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Now, we can collect only the cars from `List<Vehicle>` into an `ArrayList`,
    as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以只将`List<Vehicle>`中的汽车收集到`ArrayList`中，如下所示：
- en: '[PRE161]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Also, we can collect only the submersible into a `HashSet`, as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们只能将潜水艇收集到`HashSet`中，如下所示：
- en: '[PRE162]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Finally, let’s write a custom collector for a custom data structure.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们编写一个用于自定义数据结构的定制收集器。
- en: Writing a custom collector for SplayTree
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个用于SplayTree的定制收集器
- en: 'In *Chapter 5*, *Problem 127*, we implemented a SplayTree data structure. Now,
    let’s write a custom collector capable of collecting elements into a SplayTree.
    Obviously, the supplier is `SplayTree::new`. Moreover, the accumulator is `SplayTree.insert()`,
    while the combiner is `SplayTree.insertAll()`:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*问题127*中，我们实现了SplayTree数据结构。现在，让我们编写一个能够将元素收集到SplayTree中的定制收集器。显然，供应商是`SplayTree::new`。此外，累加器是`SplayTree.insert()`，而组合器是`SplayTree.insertAll()`：
- en: '[PRE163]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Here is an example that collects the car’s horsepower into a SplayTree:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，它将汽车的马力收集到一个SplayTree中：
- en: '[PRE164]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Done! Challenge yourself to implement a custom collector.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！挑战自己实现一个自定义收集器。
- en: 203\. Throwing checked exceptions from lambdas
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 203. 从lambda表达式抛出检查型异常
- en: 'Let’s suppose that we have the following lambda:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下lambda表达式：
- en: '[PRE165]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'What can we throw in the `catch` block? Most of you will know the answer; we
    can throw an unchecked exception such as a `RuntimeException`:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`catch`块中可以抛出什么？你们大多数人都会知道答案；我们可以抛出一个未检查的异常，例如`RuntimeException`：
- en: '[PRE166]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Also, most people know that we cannot throw a checked exception such as an
    `IOException`. The following snippet of code will not compile:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数人知道我们不能抛出一个检查型异常，例如`IOException`。以下代码片段将无法编译：
- en: '[PRE167]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Can we change this rule? Can we come up with a hack that allows us to throw
    checked exceptions from lambdas? Short answer: sure we can!'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否改变这个规则？我们能否想出一个允许从lambda表达式抛出检查型异常的技巧？简短的回答是：当然可以！
- en: 'Long answer: sure we can, *if* we simply hide the checked exception for the
    compiler, as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 长答案：当然可以，*如果*我们简单地隐藏编译器对已检查异常的检查，如下所示：
- en: '[PRE168]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'That’s all there is to it! Now, we can throw any checked exception. Here, we
    throw an `IOException`:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他了！现在，我们可以抛出任何已检查的异常。这里，我们抛出一个`IOException`：
- en: '[PRE169]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Also, we can catch it as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以这样捕获它：
- en: '[PRE170]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'If a certain path was not found, then the reported error message will be:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个路径未找到，则报告的错误信息将是：
- en: '[PRE171]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Cool, right?!
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？！
- en: 204\. Implementing distinctBy() for the Stream API
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 204. 为Stream API实现distinctBy()
- en: 'Let’s suppose that we have the following model and data:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下模型和数据：
- en: '[PRE172]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'We know that the Stream API contains the `distinct()` intermediate operation,
    which is capable of keeping only the distinct elements based on the `equals()`
    method:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Stream API包含一个名为`distinct()`的中间操作，它能够根据`equals()`方法只保留不同的元素：
- en: '[PRE173]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'While this code prints the distinct cars, we may want a `distinctBy()` intermediate
    operation that is capable of keeping only the distinct elements based on a given
    property/key. For instance, we may need all the cars distinct by brand. For this,
    we can rely on the `toMap()` collector and the identity function, as follows:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的代码打印出不同的汽车，但我们可能希望有一个`distinctBy()`中间操作，它能够根据给定的属性/键只保留不同的元素。例如，我们可能需要所有品牌不同的汽车。为此，我们可以依赖`toMap()`收集器和恒等函数，如下所示：
- en: '[PRE174]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'We can extract this idea into a helper method, as follows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个想法提取到一个辅助方法中，如下所示：
- en: '[PRE175]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Also, we can use it as shown here:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以像下面这样使用它：
- en: '[PRE176]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'While this is a nice job that also works for `null` values, we can come up
    with other ideas that don’t work for `null` values. For instance, we can rely
    on `ConcurrentHashMap` and `putIfAbsent()`, as follows (again, this doesn’t work
    for `null` values):'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个很好的工作，也适用于`null`值，但我们还可以想出其他不适用于`null`值的方法。例如，我们可以依赖`ConcurrentHashMap`和`putIfAbsent()`，如下（再次，这不适用于`null`值）：
- en: '[PRE177]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Alternatively, we can optimize this approach a little bit and use a `Set`:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以稍微优化这种方法并使用一个`Set`：
- en: '[PRE178]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'We can use these two approaches, as shown in the following examples:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下示例中展示的这两种方法：
- en: '[PRE179]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: As a challenge, implement a `distinctByKeys()` operation using multiple keys.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，使用多个键实现一个`distinctByKeys()`操作。
- en: 205\. Writing a custom collector that takes/skips a given number of elements
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 205. 编写一个自定义收集器，它获取/跳过给定数量的元素
- en: In *Problem 202*, we wrote a handful of custom collectors grouped in the `MyCollectors`
    class. Now, let’s continue our journey, and let’s try to add two more custom collectors
    here to take and/or keep a given number of elements from the current stream.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在*问题202*中，我们在`MyCollectors`类中编写了一些自定义收集器。现在，让我们继续我们的旅程，并尝试在这里添加两个更多的自定义收集器，以从当前流中获取和/或保留给定数量的元素。
- en: 'Let’s assume the following model and data:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下模型和数据：
- en: '[PRE180]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The Stream API provides an intermediate operation named `limit(long n)`, which
    can be used to truncate the stream to `n` elements. So, if this is exactly what
    we want, then we can use it out of the box. For instance, we can limit the resulting
    stream to the first five cars, as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: Stream API提供了一个名为`limit(long n)`的中间操作，它可以用来截断流到`n`个元素。所以，如果这正是我们想要的，那么我们可以直接使用它。例如，我们可以将结果流限制在前五辆汽车，如下所示：
- en: '[PRE181]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Moreover, the Stream API provides an intermediate operation named `skip(long
    n)` , which can be used to skip the first `n` elements in the stream pipeline.
    For instance, we can skip the first five cars, as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Stream API提供了一个名为`skip(long n)`的中间操作，它可以用来跳过流管道中的前`n`个元素。例如，我们可以跳过前五辆汽车，如下所示：
- en: '[PRE182]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: However, there are cases when we need to compute different things and collect
    only the first/last five results. In such cases, a custom collector is welcome.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下我们需要计算不同的事情，并且只收集前五个/最后一个五个结果。在这种情况下，自定义收集器是受欢迎的。
- en: 'By relying on the `Collector.of()` method (as detailed in *Problem 202*), we
    can write a custom collector that keeps/collects the first `n` elements, as follows
    (just for fun, let’s collect these *n* elements in an unmodifiable list):'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖`Collector.of()`方法（如*问题202*中详细说明），我们可以编写一个自定义收集器，它保留/收集前`n`个元素，如下（只是为了好玩，让我们在不修改的列表中收集这些*n*个元素）：
- en: '[PRE183]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'So the supplier is `ArrayList::new`, the accumulator is `List.add()`, the combiner
    is `List.addAll()`, and the finalizer is `Collections::unmodifiableList`. Basically,
    the accumulator’s job is to accumulate elements only until the given `max` is
    reached. From that point forward, nothing gets accumulated. This way, we can keep
    only the first five cars, as follows:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，供应商是`ArrayList::new`，累加器是`List.add()`，组合器是`List.addAll()`，而最终化器是`Collections::unmodifiableList`。基本上，累加器的任务是在达到给定的`max`值之前只累积元素。从那个点开始，不再累积任何元素。这样，我们就可以只保留前五辆车，如下所示：
- en: '[PRE184]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'On the other hand, if we want to skip the first `n` elements and collect the
    rest, then we can try to accumulate `null` elements until we reach the given `index`.
    From this point forward, we accumulate the real elements. Finally, the finalizer
    removes the part of the list containing `null` values (from 0 to the given `index`)
    and returns an unmodifiable list from the remaining elements (from the given `index`
    to the end):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想跳过前`n`个元素并收集剩余的元素，那么我们可以尝试累积`null`元素，直到达到给定的`index`。从那个点开始，我们开始累积真实元素。最后，最终化器移除包含`null`值的列表部分（从0到给定的`index`），并从剩余元素（从给定的`index`到末尾）返回一个不可修改的列表：
- en: '[PRE185]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Alternatively, we can optimize this approach by using a supplier class that
    contains the resulting list and a counter. While the given `index` is not reached,
    we simply increase the counter. Once the given `index` is reached, we start to
    accumulate elements:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用包含结果列表和计数器的供应商类来优化这种方法。在达到给定的`index`之前，我们只需简单地增加计数器。一旦达到给定的`index`，我们就开始累积元素：
- en: '[PRE186]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Both of these approaches can be used, as shown in the following example:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都可以使用，如下面的示例所示：
- en: '[PRE187]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Challenge yourself to implement a custom collector that collects in a given
    range.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己实现一个在给定范围内收集的自定义收集器。
- en: 206\. Implementing a Function that takes five (or any other arbitrary number
    of) arguments
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 206. 实现一个接受五个（或任何其他任意数量）参数的函数
- en: We know that Java already has `java.util.function.Function` and the specialization
    of it, `java.util.function.BiFunction`. The `Function` interface defines the method
    `apply(T, t)`, while `BiFunction` has `apply(T t, U u)`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Java已经有了`java.util.function.Function`及其特殊化`java.util.function.BiFunction`。`Function`接口定义了`apply(T,
    t)`方法，而`BiFunction`有`apply(T t, U u)`。
- en: 'In this context, we can define a `TriFunction`, `FourFunction`, or (why not?)
    a `FiveFunction` functional interface, as follows (all of these are specializations
    of `Function`):'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，我们可以定义一个`TriFunction`、`FourFunction`或（为什么不呢？）一个`FiveFunction`函数式接口，如下所示（这些都是`Function`的特殊化）：
- en: '[PRE188]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: As its name suggests, this functional interface takes five arguments.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这个函数式接口接受五个参数。
- en: 'Now, let’s use it! Let’s assume that we have the following model:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来使用它！假设我们有以下模型：
- en: '[PRE189]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The `compute()` method shapes a formula known as the Four-Parameter Logistic
    (4PL - [https://www.myassays.com/four-parameter-logistic-regression.html](https://www.myassays.com/four-parameter-logistic-regression.html)).
    Without getting into irrelevant details, we pass, as inputs, four variables (`a`,
    `b`, `c`, and `d`) and, for different values of the `x` coordinate, we compute
    the `y` coordinate. The (`x`, `y`) pair of coordinates describes a curve (linear
    graphic).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute()`方法塑造了一个称为四参数逻辑（4PL - [https://www.myassays.com/four-parameter-logistic-regression.html](https://www.myassays.com/four-parameter-logistic-regression.html)）的公式。不涉及无关细节，我们传递四个变量（`a`、`b`、`c`和`d`）作为输入，并且对于不同的`x`坐标值，我们计算`y`坐标。坐标对（`x`，`y`）描述了一条曲线（线性图形）。'
- en: 'We need a `PL4` instance for each `x` coordinate, and for each such instance,
    we call the `compute()` method. This means that we can use the `FiveFunction`
    interface in `Logistics` via the following helper:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个`x`坐标创建一个`PL4`实例，并且对于每个这样的实例，我们调用`compute()`方法。这意味着我们可以通过以下辅助方法在`Logistics`中使用`FiveFunction`接口：
- en: '[PRE190]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'This acts as a factory for `PL4`:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这充当了`PL4`的工厂：
- en: '[PRE191]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'However, if all we need is just the list of `y` coordinates, then we can write
    a helper method in `Logistics`, as follows:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只需要`y`坐标的列表，那么我们可以在`Logistics`中编写一个辅助方法，如下所示：
- en: '[PRE192]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'We can call this method as follows (here, we pass the 4PL formula, but it can
    be any other formula with five `double` parameters):'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样调用这个方法（这里我们传递了4PL公式，但它可以是任何具有五个`double`参数的其他公式）：
- en: '[PRE193]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: You can find the complete example in the bundled code.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中找到完整的示例。
- en: 207\. Implementing a Consumer that takes five (or any other arbitrary number
    of) arguments
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 207. 实现一个接受五个（或任何其他任意数量）参数的消费者
- en: Before continuing with this problem, I strongly recommend that you read *Problem
    206*.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续这个问题之前，我强烈建议你阅读 *问题 206*。
- en: 'Writing a custom `Consumer` that takes five arguments can be done as follows:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个接受五个参数的自定义 `Consumer` 可以这样做：
- en: '[PRE194]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: This is the five-arity specialization of the Java `Consumer,` just as the built-in
    `BiConsumer` is the two-arity specialization of the Java `Consumer`.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Java `Consumer` 的五参数特殊化，正如内置的 `BiConsumer` 是 Java `Consumer` 的双参数特殊化。
- en: 'We can use `FiveConsumer` in conjunction with the PL4 formula, as follows (here,
    we compute `y` for `x` = 40.3):'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `FiveConsumer` 与 PL4 公式结合使用，如下（这里，我们计算 `y` 对 `x` = 40.3）：
- en: '[PRE195]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The `Logistics.pl4()` is the method that contains the formula and displays
    the result:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logistics.pl4()` 是包含公式并显示结果的方法：'
- en: '[PRE196]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Next, let’s see how we can partially apply a `Function`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何部分应用一个 `Function`。
- en: 208\. Partially applying a Function
  id: totrans-587
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 208. 部分应用一个 Function
- en: 'A `Function` that is partially applied is a `Function` that applies only a
    part of its arguments, returning another `Function`. For instance, here is a `TriFunction`
    (a functional function with three arguments) that contains the `apply()` method,
    next to two `default` methods that partially apply this function:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用的 `Function` 是只应用其部分参数的 `Function`，返回另一个 `Function`。例如，这里有一个包含 `apply()`
    方法的 `TriFunction`（一个具有三个参数的函数式函数），旁边有两个部分应用此函数的 `default` 方法：
- en: '[PRE197]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: As you can see, `applyOnly(T1 t1)` applies only the `t1` argument and returns
    a `BiFunction`. On the other hand, `applyOnly(T1 t1, T2 t2)` applies only `t1`
    and `t2`, returning a `Function`.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`applyOnly(T1 t1)` 只应用 `t1` 参数并返回一个 `BiFunction`。另一方面，`applyOnly(T1 t1,
    T2 t2)` 只应用 `t1` 和 `t2`，返回一个 `Function`。
- en: 'Let’s see how we can use these methods. For instance, let’s consider the formula
    (a+b+c)² = a²+b²+c²+2ab+2bc+2ca, which can be shaped via the `TriFunction`, as
    follows:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这些方法。例如，让我们考虑公式 (a+b+c)² = a²+b²+c²+2ab+2bc+2ca，它可以通过 `TriFunction`
    来实现，如下所示：
- en: '[PRE198]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Here, we call `apply(T1 t1, T2 t2, T3 t3)` three times. As you can see, only
    the `c` term has a different value per call, while `a` and `b` are constantly
    equal with 1.0 and 2.0, respectively. This means that we can use `apply(T1 t1,
    T2 t2)` for `a` and `b`, and `apply(T1 t1)` for `c`, as follows:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了 `apply(T1 t1, T2 t2, T3 t3)` 三次。正如你所见，每次调用中只有 `c` 项有不同的值，而 `a` 和 `b`
    分别始终等于 1.0 和 2.0。这意味着我们可以为 `a` 和 `b` 使用 `apply(T1 t1, T2 t2)`，为 `c` 使用 `apply(T1
    t1)`，如下所示：
- en: '[PRE199]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'If we assume that only `a` is constant (1.0) while `b` and `c` have different
    values per call, then we can use `apply(T1 t1)` for `a` and `apply(T1 t1, T2 t2)`
    for `b` and `c`, as follows:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设只有 `a` 是常数（1.0），而 `b` 和 `c` 每次调用有不同的值，那么我们可以为 `a` 使用 `apply(T1 t1)`，为
    `b` 和 `c` 使用 `apply(T1 t1, T2 t2)`，如下所示：
- en: '[PRE200]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Mission accomplished!
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！
- en: Summary
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered 24 problems. Most of them focused on working with predicates,
    functions, and collectors, but we also covered the JDK 16 `mapMulti()` operation,
    refactoring imperative code to functional code, and much more.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 24 个问题。大多数问题集中在使用谓词、函数和收集器，但我们还涵盖了 JDK 16 的 `mapMulti()` 操作，将命令式代码重构为函数式代码，等等。
- en: Join our community on Discord
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ)'
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1139613064111216156.png)'
