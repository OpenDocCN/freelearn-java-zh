- en: Using Server-Sent Events (SSEs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to take a look at **Server-Sent Events** (**SSE**).
    We will have a look at the characteristics of some usage scenarios, and then we'll
    be implementing and sending simple SSEs on the server side using JAX-RS. Next
    up, we'll be implementing SSEs on the client-side using JAX-RS engine HTML and
    finally, we will have a look at sending and receiving server-sent broadcast events
    to implement something like a simple HTML chat client.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: What are SSEs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing SSE on the server-side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing SSE REST clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and sending SSE broadcasts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are SSEs?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at SSEs, and take a look at some
    of its usage scenarios. We'll then be implementing and sending a simple SSE on
    the server side using JAX-RS. Next up, we'll implement SSE on the client-side
    using JAX-RS and HTML. Finally, we will have a look at sending and receiving server-sent
    broadcast events to implement something like a simple HTML chat client.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to take a look at SSEs, what they are, and some usage scenarios.
    We will also have a look at some differences to other related technologies like
    WebSockets, Polling, and Long Polling.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are SSEs, exactly? They are a very simple HTTP-based API, dedicated
    to Push communication, and currently SSEs are implemented in most recent browsers
    like Firefox, Chrome, Safari, and Opera. Unfortunately, SSEs are currently not
    implemented in Internet Explorer or Edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSE allows you to send simple text data from the server to the client. One
    important thing: SSEs are one-way in communication. You might be thinking, *hey,
    well I''ve used Polling and Long Polling in the past, and they kind of do the
    same thing*. The main difference is that with Polling and Long Polling, it is
    the client that occasionally tries to load new data. With SSE, it''s not the client
    Polling, it''s always the server pushing data to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: You might have heard of WebSockets before, but WebSockets are a totally different
    thing. First up, they are TCP-based. They provide a full duplex communication
    link between the client and the server. Using a WebSocket, the client can always
    send data to the server and the server can always send data to the client. In
    SSE, you can think of an event-stream of really simple text data. The text data
    must be encoded using UTF-8\. What we can do in the event-stream is send simple
    messages and encode these messages. These messages may even be in JSON or you
    maybe you can only send messages that are plain string or perhaps primitive data.
    Messages in the event-stream are separated by a pair of newline characters (`"\n"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: SSEs are simple Push communication mechanisms, and you can send an
    event-stream from the server to the client without the client leading to Polling.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to have a look at implementing SSE on the server-side
    using JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SSE on the server-side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at opening SSE sinks using the text/event-stream
    media type. We'll be sending simple data and also JSON data events. Finally, we'll
    be closing and disconnecting the SSE sink which we previously opened.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started, dive into the code, and open our IDE. As usual, we prepare
    a small template to get us started. Open the `EventsResource.java` file. The first
    thing we need to do is implement the opening of the event-stream. We can do that
    by implementing a plain HTTP `@GET` method, though the first thing is going to
    be the parameter, which is where we pass the `@Context` of type `SseEventSink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the object that we can use later to send events down to the client.
    You can also see the `@Produces` annotation, which is where we use `text/event-stream`
    as the `MediaType`. This is the special media type used to designate SSE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve opened the SSE event-stream, we can implement the sending of events.
    First up, we start with a simple `@POST` method. Again, mind the second parameter,
    which is a `@Context` object of type `Sse`. We use this `Sse` interface later
    to construct new events. Let''s send the first simple event down the event-stream. We
    do that using the `sse` context and construct a `newEvent` using the string `message`,
    and we use the `send` method on the `eventSink` and send this to the `event`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also send named events which can give your events some names. Again,
    we are using the `sse` context in order to construct a `newEvent`. We can see
    here that we gave it a name (`stringEvent`) and that we passed in the `message`
    as data. Again, we used the `localSink` and the `send` method to send this `event`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works for other primitive data. Perhaps we want to send the current
    time in milliseconds. As you can see, there''s also a `newEventBuilder` available
    in the `sse` context. We use `sse.newEventBuilder`, `name`, and `data` and call
    the `build` method on it. We then call the `send` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we can also send JSON events. For example, what we have is a simple
    POJO implementation using some `@JsonbPropertyOrder` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s send this down the wire. We used the `newEventBuilder`, we gave it a
    `name`, and we passed in an instance of our POJO as `data`. We can specify the
    `mediaType` of this event, which in our case is the application JSON. We can use `.build`
    and send it down the event-stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all there is to sending events. The last thing we need to do is close
    the event-stream. We can use the HTTP `DELETE` method for this one. If we call
    HTTP `DELETE` on this resource, we can simply call a `close` method on the `eventSink`
    and we''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put this to the test. Open a browser and navigate to the `GET` endpoint.
    As we can see, this call does not return, as it is waiting for events, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edbc67de-85eb-4571-b694-1537551a713d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we open our Postman to send some events and click Send a few times. Let''s
    go back to our browser. As we can see, our events have arrived, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e12279f6-aa7d-4dd7-bea4-44aedb87ac61.png)'
  prefs: []
  type: TYPE_IMG
- en: That's all there is to implementing services and events on the client-side.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be talking about implementing service and event
    REST clients as well as HTTP clients.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SSE REST clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at registering an JAX-RS client
    instance to receive SSE. We're going to send messages to the SSE service endpoint,
    and we want to receive those messages in our JAX-RS client. Finally, we will look
    at implementing a simple HTML client using JSP.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot of ground to cover in this section. Let''s begin and switch
    to our IDE. As usual, we will prepare a template project to get us started. What
    we need to do is implement a small JUnit integration test that we can use as our
    JAX-RS client. In the `setUp` method, we will first construct an executor (you''ll
    see in a bit why we need one). In order to do this, we will use the JAX-RS `clientBuilder`
    and construct a `newBuilder`. We wll specify the `connectTimeout` and the `readTimeout` and
    call the `.build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s left is that we need to construct and open the `webTarget` for our
    REST endpoint. What we do here is use the `client`, we specify the `target` as
    `localhost:8080` in this case, and we implement the `path` in the `events` endpoint
    like we did in the *Implementing SSE on the server-side* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `tearDown` method, we close the client and call the `executorService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the receiving of SSE. First, what we need to do is send some
    solid SSE so that we can try and implement an event loop. We send messages to
    an endpoint and we receive those messages which are sent. This is what we use
    the `executorService` for. Therefore in `executorService`, we occasionally send
    events every 500 milliseconds. We use `executorService.scheduleWithFixedDelay`,
    and `webTarget.requests`, we call `post`, and we enter some plain text data to
    our JAX-RS endpoint. As you can see, we have an initial delay of `250` milliseconds,
    and we do that every `500` milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the interesting bit: let''s receive those events. First, what we
    need to do is obtain an `SseEventSource`. We use `SseEventSource.target`, we give
    it the `webTarget` we previously constructed, and we call `.build`. This gives
    us an instance of `SseEventSource`. Let''s interact with `eventSource`. The first
    thing we need to do is register a handler that is called whenever we receive an
    event. To do that, we use `eventSource.register`, and all we do is log the event
    name and read the data of the event. All that''s left is that we need to start
    receiving those events. To do that, we need to call the `open` method on the `eventSource`.
    Just to make sure that this test doesn''t return immediately, we put in a sleeve
    of `5` seconds in here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see if that works. We''ll build and run this integration test, which
    will take some time to compile. We can see that it''s receiving the `JsonbEvent`,
    a simple message, a `primitiveEvent`, and also the `stringEvent` we just expected,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01e9a48e-077e-465b-afaa-f4b7520ce1db.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of integration tests showing events
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all there is to sending and receiving SSE using the JAX-RS client.
    Let''s look at one more bit, and that is regarding how you can consume these SSEs
    using plain HTML and JSP. We will prepare a small JSP showcase and, since most
    modern browsers support this, it''s going to be a good showcase. The first thing
    you need to do is add some JavaScript, and you need to open the `EventSource`.
    In JavaScript, you can open the `EventSource` by using `new EventSource`, and
    we give it the endpoint of our `events` endpoint. To receive normal unnamed events,
    we have to use the `onmessage`. We register `function` in `source.onmessage` and
    append the `event.data` to a `div` that we defined at the start of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For any named events, we have to do this in a slightly different manner. Here,
    we have to use a different method called the `addEventListener` method on our
    `source`. We register `addEventListener` for `"sringEvent"`, `"primitiveEvent"`,
    and `jsonEvent`. We append the data received from the event to the `div` tags
    we defined at the top of the JSP file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s open a browser and go to the URL (`localhost:8080/sse-service/events.jsp`).
    This is what our simple UI should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1bbba3a-bf7c-4b4f-972f-16aaa522c2d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I know it''s not very pretty, but it does the job. In the background, the SSE
    channel to our server has already been opened. If we open our Postman and start
    to `POST` some events and go back to our browser page, we can see that those events
    will appear, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdd2ccbb-0b6f-4486-ab0b-b15a9c2b3a85.png)'
  prefs: []
  type: TYPE_IMG
- en: We invoke these by sending them three times, and you can see here that we have
    three times the different messages.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for this section. In the next section, we will talk about implementing
    and sending SSE broadcasts.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and sending SSE broadcasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at creating SSE broadcaster instances.
    We're going to register SSE event sinks with this SSE broadcaster, and then we're
    going broadcast events to all registered sinks. Finally, we'll implement a simple
    HTML chat leveraging SSE.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot of ground to cover in this section. Let''s get started and open
    our IDE. As usual, to get started, we will prepare a small skeleton project. First
    up, we will implement the `BroadcastResource` class, which is the server side
    for sending SSE broadcasts. We have a few things to do. We will inject the SSE
    `@Context` which we need to construct new events. The next thing we need to do
    is initialize an SSE broadcaster. For this, we will use the `@Context` we just
    injected and we''ll define an `SseBroadcaster` so that this is the main instance.
    We will also use a `@PostConstruct` initializer to create a `newBroadcaster` using
    the `sse` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to implement is the registering of SSE event sinks with
    this broadcaster. We will implement a simple `@GET` method for that, but remember
    it''s annotated with the media type `text/event-stream`. All we need to do is
    call `sseBroadcaster.register` with the `sseEventSink` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The last bit that is missing is that we need to be able to broadcast and send
    SSE events. What we do here is define a `POST` method that we can use to consume
    an HTML form (`APPLICATION_FORM_URLENCODED`) and the `@FormParam` called `"message"`.
    We use this to construct an outbound SSE event (`OutboundSseEvent`) like we did
    in the previous section. We do this by using `sse.newEvent`, giving it a name,
    and passing it the `message`, and then we use the `broadcast` method on the `sseBroadcaster` instance
    to broadcast the event and we return `noContent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for the server side. Let''s have a quick look on the HTML side.
    Again, we will use a really simple plain JSP file for that like we did in a previous
    section. We will construct an `EventSource` and we will register an event listener
    (`addEventListener`) for our messages. That''s all, with only one minor bit missing—we
    need a simple `form` to post messages to our `BroadcastResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put this to the test. We will open up a couple of browser instances
    to see our super fancy HTML chat client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc934f2e-b921-4d2e-978a-28812645f950.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s enter `Hello Window 1` and click on Submit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fd1eea2-6977-4380-b5a4-7d951516ff60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we expect is to see this message in the second window. You should see
    the same message in the second window. From the second window, we will type a
    message `Hello from Window 2` and click Submit. Now, if we switch tabs to the
    first window, we should be able to see the Hello from Window 2 message sent from
    the second window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68de5d84-8073-429b-9817-e38c5d6496dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might think that this is faked, but it isn''t. Let''s open Postman and
    use it to also send messages to this broadcast resource. If you look at Headers,
    we have the `Content-Type` already mentioned, and we have a `message` under the Body tab.
    We will use Postman to send those events, and what we expect is to see this message
    in the browser windows. Let''s click once, maybe twice, maybe three times. Let''s
    switch back to our browser and you will see Hello SSE broadcast from Postman,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7e3e68b-0940-4b0c-bc3c-8fc1fec315a5.png)'
  prefs: []
  type: TYPE_IMG
- en: This proves that we have verified that this is a real broadcast working over
    several client types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it for this chapter. So, what did we have a look at? First up, we had
    to look at usage scenarios of service and events and we talked about what SSEs
    are and other related technologies. Next up, we implemented the sending of services
    events on the server side with JAX-RS. Then, we had a look at implementing SSE
    clients and receiving those events using JAX-RS client APIs as well as HTML. Finally,
    we implemented the sending of SSE broadcasts on the server side and we implemented
    a small HTML chat client.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will have a look at advanced REST APIs.
  prefs: []
  type: TYPE_NORMAL
