- en: Using Server-Sent Events (SSEs)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器发送事件（SSEs）
- en: In this chapter, we're going to take a look at **Server-Sent Events** (**SSE**).
    We will have a look at the characteristics of some usage scenarios, and then we'll
    be implementing and sending simple SSEs on the server side using JAX-RS. Next
    up, we'll be implementing SSEs on the client-side using JAX-RS engine HTML and
    finally, we will have a look at sending and receiving server-sent broadcast events
    to implement something like a simple HTML chat client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 **服务器发送事件**（**SSE**）。我们将查看一些使用场景的特点，然后我们将使用 JAX-RS 在服务器端实现和发送简单的
    SSE。接下来，我们将使用 JAX-RS 引擎 HTML 实现SSE，最后我们将查看发送和接收服务器发送的广播事件，以实现类似简单 HTML 聊天客户端的功能。
- en: 'This chapter includes the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下部分：
- en: What are SSEs?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是SSEs？
- en: Implementing SSE on the server-side
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端实现SSE
- en: Implementing SSE REST clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现SSE REST客户端
- en: Implementing and sending SSE broadcasts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和发送SSE广播
- en: What are SSEs?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是SSEs？
- en: In this section, we're going to take a look at SSEs, and take a look at some
    of its usage scenarios. We'll then be implementing and sending a simple SSE on
    the server side using JAX-RS. Next up, we'll implement SSE on the client-side
    using JAX-RS and HTML. Finally, we will have a look at sending and receiving server-sent
    broadcast events to implement something like a simple HTML chat client.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 SSEs，并查看一些其使用场景。然后，我们将使用 JAX-RS 在服务器端实现和发送一个简单的 SSE。接下来，我们将使用 JAX-RS
    和 HTML 在客户端实现 SSE。最后，我们将查看发送和接收服务器发送的广播事件，以实现类似简单 HTML 聊天客户端的功能。
- en: We're going to take a look at SSEs, what they are, and some usage scenarios.
    We will also have a look at some differences to other related technologies like
    WebSockets, Polling, and Long Polling.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨 SSEs（服务器发送事件），它们是什么，以及一些使用场景。我们还将查看与其他相关技术（如 WebSockets、轮询和长轮询）的一些区别。
- en: So, what are SSEs, exactly? They are a very simple HTTP-based API, dedicated
    to Push communication, and currently SSEs are implemented in most recent browsers
    like Firefox, Chrome, Safari, and Opera. Unfortunately, SSEs are currently not
    implemented in Internet Explorer or Edge.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，SSEs（服务器发送事件）究竟是什么呢？它们是一个非常简单的基于 HTTP 的 API，专门用于推送通信，目前 SSEs 已在大多数最新的浏览器中实现，如
    Firefox、Chrome、Safari 和 Opera。不幸的是，SSEs 目前在 Internet Explorer 或 Edge 中尚未实现。
- en: 'SSE allows you to send simple text data from the server to the client. One
    important thing: SSEs are one-way in communication. You might be thinking, *hey,
    well I''ve used Polling and Long Polling in the past, and they kind of do the
    same thing*. The main difference is that with Polling and Long Polling, it is
    the client that occasionally tries to load new data. With SSE, it''s not the client
    Polling, it''s always the server pushing data to the client.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 允许您从服务器向客户端发送简单的文本数据。一个重要的事情是：SSEs 在通信中是单向的。您可能会想，“嘿，我过去使用过轮询和长轮询，它们似乎做的是同一件事。”主要区别在于，使用轮询和长轮询时，是客户端偶尔尝试加载新数据。而使用
    SSE，不是客户端轮询，而是服务器始终向客户端推送数据。
- en: You might have heard of WebSockets before, but WebSockets are a totally different
    thing. First up, they are TCP-based. They provide a full duplex communication
    link between the client and the server. Using a WebSocket, the client can always
    send data to the server and the server can always send data to the client. In
    SSE, you can think of an event-stream of really simple text data. The text data
    must be encoded using UTF-8\. What we can do in the event-stream is send simple
    messages and encode these messages. These messages may even be in JSON or you
    maybe you can only send messages that are plain string or perhaps primitive data.
    Messages in the event-stream are separated by a pair of newline characters (`"\n"`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能之前听说过 WebSockets，但 WebSockets 是一个完全不同的东西。首先，它们是基于 TCP 的。它们在客户端和服务器之间提供了一个全双工的通信链路。使用
    WebSocket，客户端可以始终向服务器发送数据，服务器也可以始终向客户端发送数据。在 SSE 中，您可以将事件流想象成非常简单的文本数据。文本数据必须使用
    UTF-8 编码。在事件流中，我们可以发送简单的消息并对这些消息进行编码。这些消息甚至可以是 JSON 格式，或者您可能只能发送纯字符串或原始数据。事件流中的消息由一对换行符（`"\n"`）分隔。
- en: 'Remember: SSEs are simple Push communication mechanisms, and you can send an
    event-stream from the server to the client without the client leading to Polling.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：SSEs 是简单的推送通信机制，您可以从服务器向客户端发送事件流，而无需客户端轮询。
- en: In the next section, we're going to have a look at implementing SSE on the server-side
    using JAX-RS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看使用 JAX-RS 在服务器端实现 SSE。
- en: Implementing SSE on the server-side
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端实现SSE
- en: In this section, we're going to take a look at opening SSE sinks using the text/event-stream
    media type. We'll be sending simple data and also JSON data events. Finally, we'll
    be closing and disconnecting the SSE sink which we previously opened.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用text/event-stream媒体类型打开SSE接收器。我们将发送简单的数据和JSON数据事件。最后，我们将关闭并断开之前打开的SSE接收器。
- en: Let's get started, dive into the code, and open our IDE. As usual, we prepare
    a small template to get us started. Open the `EventsResource.java` file. The first
    thing we need to do is implement the opening of the event-stream. We can do that
    by implementing a plain HTTP `@GET` method, though the first thing is going to
    be the parameter, which is where we pass the `@Context` of type `SseEventSink`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，深入代码，打开我们的IDE。像往常一样，我们准备一个小模板来开始。打开`EventsResource.java`文件。我们首先需要做的是实现事件流的打开。我们可以通过实现一个普通的HTTP
    `@GET`方法来实现，但首先需要处理的是参数，这是我们传递类型为`SseEventSink`的`@Context`。
- en: 'This is the object that we can use later to send events down to the client.
    You can also see the `@Produces` annotation, which is where we use `text/event-stream`
    as the `MediaType`. This is the special media type used to designate SSE:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以稍后用来向客户端发送事件的对象。您还可以看到`@Produces`注解，这是我们使用`text/event-stream`作为`MediaType`的地方。这是用来指定SSE的特殊媒体类型：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we''ve opened the SSE event-stream, we can implement the sending of events.
    First up, we start with a simple `@POST` method. Again, mind the second parameter,
    which is a `@Context` object of type `Sse`. We use this `Sse` interface later
    to construct new events. Let''s send the first simple event down the event-stream. We
    do that using the `sse` context and construct a `newEvent` using the string `message`,
    and we use the `send` method on the `eventSink` and send this to the `event`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打开了SSE事件流，我们就可以实现事件的发送。首先，我们从一个简单的`@POST`方法开始。同样，请注意第二个参数，它是一个类型为`Sse`的`@Context`对象。我们稍后使用这个`Sse`接口来构建新的事件。让我们通过事件流发送第一个简单的事件。我们这样做是通过使用`sse`上下文，并使用字符串`message`构建一个`newEvent`，然后我们在`eventSink`上使用`send`方法，并将它发送到`event`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also send named events which can give your events some names. Again,
    we are using the `sse` context in order to construct a `newEvent`. We can see
    here that we gave it a name (`stringEvent`) and that we passed in the `message`
    as data. Again, we used the `localSink` and the `send` method to send this `event`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以发送命名的事件，这可以为您的事件赋予一些名称。同样，我们使用`sse`上下文来构建一个`newEvent`。在这里我们可以看到我们给它取了一个名字（`stringEvent`），并且将`message`作为数据传递。同样，我们使用了`localSink`和`send`方法来发送这个`event`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This also works for other primitive data. Perhaps we want to send the current
    time in milliseconds. As you can see, there''s also a `newEventBuilder` available
    in the `sse` context. We use `sse.newEventBuilder`, `name`, and `data` and call
    the `build` method on it. We then call the `send` method as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于其他原始数据。也许我们想要发送当前时间的毫秒数。如您所见，`sse`上下文中也有一个`newEventBuilder`可用。我们使用`sse.newEventBuilder`、`name`和`data`，并在其上调用`build`方法。然后我们按照如下方式调用`send`方法：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, we can also send JSON events. For example, what we have is a simple
    POJO implementation using some `@JsonbPropertyOrder` annotation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以发送JSON事件。例如，我们有一个简单的POJO实现，使用了`@JsonbPropertyOrder`注解：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s send this down the wire. We used the `newEventBuilder`, we gave it a
    `name`, and we passed in an instance of our POJO as `data`. We can specify the
    `mediaType` of this event, which in our case is the application JSON. We can use `.build`
    and send it down the event-stream:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其发送出去。我们使用了`newEventBuilder`，给它一个`name`，并传递我们POJO的一个实例作为`data`。我们可以指定这个事件的`mediaType`，在我们的例子中是application
    JSON。我们可以使用`.build`并将其发送到事件流：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s all there is to sending events. The last thing we need to do is close
    the event-stream. We can use the HTTP `DELETE` method for this one. If we call
    HTTP `DELETE` on this resource, we can simply call a `close` method on the `eventSink`
    and we''re done:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 发送事件就是这样。我们最后需要做的是关闭事件流。我们可以使用HTTP的`DELETE`方法来做这件事。如果我们对这个资源调用HTTP `DELETE`，我们可以在`eventSink`上简单地调用一个`close`方法，然后我们就完成了：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s put this to the test. Open a browser and navigate to the `GET` endpoint.
    As we can see, this call does not return, as it is waiting for events, as shown
    in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对其进行测试。打开浏览器并导航到`GET`端点。正如我们所见，这个调用不会返回，因为它正在等待事件，如下面的截图所示：
- en: '![](img/edbc67de-85eb-4571-b694-1537551a713d.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/edbc67de-85eb-4571-b694-1537551a713d.png)'
- en: 'Now, we open our Postman to send some events and click Send a few times. Let''s
    go back to our browser. As we can see, our events have arrived, as shown in the
    following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们打开Postman发送一些事件，点击几次“发送”。让我们回到我们的浏览器。正如我们所看到的，我们的事件已经到达，如下面的截图所示：
- en: '![](img/e12279f6-aa7d-4dd7-bea4-44aedb87ac61.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e12279f6-aa7d-4dd7-bea4-44aedb87ac61.png)'
- en: That's all there is to implementing services and events on the client-side.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是客户端实现服务和事件的所有内容。
- en: In the next section, we will be talking about implementing service and event
    REST clients as well as HTTP clients.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论实现服务和事件REST客户端以及HTTP客户端。
- en: Implementing SSE REST clients
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现SSE REST客户端
- en: In this section, we're going to take a look at registering an JAX-RS client
    instance to receive SSE. We're going to send messages to the SSE service endpoint,
    and we want to receive those messages in our JAX-RS client. Finally, we will look
    at implementing a simple HTML client using JSP.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何注册JAX-RS客户端实例以接收SSE。我们将向SSE服务端点发送消息，并希望在JAX-RS客户端中接收这些消息。最后，我们将看看如何使用JSP实现一个简单的HTML客户端。
- en: 'There''s a lot of ground to cover in this section. Let''s begin and switch
    to our IDE. As usual, we will prepare a template project to get us started. What
    we need to do is implement a small JUnit integration test that we can use as our
    JAX-RS client. In the `setUp` method, we will first construct an executor (you''ll
    see in a bit why we need one). In order to do this, we will use the JAX-RS `clientBuilder`
    and construct a `newBuilder`. We wll specify the `connectTimeout` and the `readTimeout` and
    call the `.build`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们需要涵盖很多内容。让我们开始，并切换到我们的IDE。像往常一样，我们将准备一个模板项目以开始。我们需要做的是实现一个小型的JUnit集成测试，我们可以将其用作我们的JAX-RS客户端。在`setUp`方法中，我们将首先构建一个执行器（你很快就会看到我们为什么需要它）。为了做到这一点，我们将使用JAX-RS的`clientBuilder`并构建一个`newBuilder`。我们将指定`connectTimeout`和`readTimeout`并调用`.build`：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What''s left is that we need to construct and open the `webTarget` for our
    REST endpoint. What we do here is use the `client`, we specify the `target` as
    `localhost:8080` in this case, and we implement the `path` in the `events` endpoint
    like we did in the *Implementing SSE on the server-side* section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是我们需要构造并打开我们的REST端点的`webTarget`。我们在这里做的是使用`client`，在这种情况下，我们将`target`指定为`localhost:8080`，并在`events`端点中实现`path`，就像我们在*在服务器端实现SSE*部分所做的那样：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `tearDown` method, we close the client and call the `executorService`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tearDown`方法中，我们关闭客户端并调用`executorService`：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s implement the receiving of SSE. First, what we need to do is send some
    solid SSE so that we can try and implement an event loop. We send messages to
    an endpoint and we receive those messages which are sent. This is what we use
    the `executorService` for. Therefore in `executorService`, we occasionally send
    events every 500 milliseconds. We use `executorService.scheduleWithFixedDelay`,
    and `webTarget.requests`, we call `post`, and we enter some plain text data to
    our JAX-RS endpoint. As you can see, we have an initial delay of `250` milliseconds,
    and we do that every `500` milliseconds:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现接收SSE。首先，我们需要发送一些稳定的事件SSE，这样我们就可以尝试实现一个事件循环。我们向一个端点发送消息，并接收发送的消息。这就是我们使用`executorService`的原因。因此，在`executorService`中，我们偶尔每500毫秒发送一次事件。我们使用`executorService.scheduleWithFixedDelay`和`webTarget.requests`，我们调用`post`，并向我们的JAX-RS端点输入一些纯文本数据。正如你所看到的，我们有`250`毫秒的初始延迟，并且每`500`毫秒就做一次：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now comes the interesting bit: let''s receive those events. First, what we
    need to do is obtain an `SseEventSource`. We use `SseEventSource.target`, we give
    it the `webTarget` we previously constructed, and we call `.build`. This gives
    us an instance of `SseEventSource`. Let''s interact with `eventSource`. The first
    thing we need to do is register a handler that is called whenever we receive an
    event. To do that, we use `eventSource.register`, and all we do is log the event
    name and read the data of the event. All that''s left is that we need to start
    receiving those events. To do that, we need to call the `open` method on the `eventSource`.
    Just to make sure that this test doesn''t return immediately, we put in a sleeve
    of `5` seconds in here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来到了有趣的部分：让我们接收这些事件。首先，我们需要做的是获取一个`SseEventSource`。我们使用`SseEventSource.target`，给它我们之前构造的`webTarget`，然后调用`.build`。这给了我们一个`SseEventSource`的实例。让我们与`eventSource`进行交互。我们首先需要做的是注册一个处理程序，每当收到事件时都会被调用。为了做到这一点，我们使用`eventSource.register`，我们只做的是记录事件名称并读取事件的资料。剩下的事情就是我们需要开始接收这些事件。为了做到这一点，我们需要在`eventSource`上调用`open`方法。为了确保这个测试不会立即返回，我们在里面放了一个`5`秒的袖子：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s see if that works. We''ll build and run this integration test, which
    will take some time to compile. We can see that it''s receiving the `JsonbEvent`,
    a simple message, a `primitiveEvent`, and also the `stringEvent` we just expected,
    as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这行不行。我们将构建并运行这个集成测试，这需要一些时间来编译。我们可以看到它正在接收 `JsonbEvent`，一个简单的消息，一个 `primitiveEvent`，以及我们刚刚期望的
    `stringEvent`，如下面的截图所示：
- en: '![](img/01e9a48e-077e-465b-afaa-f4b7520ce1db.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01e9a48e-077e-465b-afaa-f4b7520ce1db.png)'
- en: Output of integration tests showing events
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试输出的事件
- en: 'This is all there is to sending and receiving SSE using the JAX-RS client.
    Let''s look at one more bit, and that is regarding how you can consume these SSEs
    using plain HTML and JSP. We will prepare a small JSP showcase and, since most
    modern browsers support this, it''s going to be a good showcase. The first thing
    you need to do is add some JavaScript, and you need to open the `EventSource`.
    In JavaScript, you can open the `EventSource` by using `new EventSource`, and
    we give it the endpoint of our `events` endpoint. To receive normal unnamed events,
    we have to use the `onmessage`. We register `function` in `source.onmessage` and
    append the `event.data` to a `div` that we defined at the start of the file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 JAX-RS 客户端发送和接收 SSE 的全部内容。让我们再看一点，那就是关于如何使用纯 HTML 和 JSP 消费这些 SSE。我们将准备一个小型的
    JSP 展示，由于大多数现代浏览器都支持这个功能，这将是一个很好的展示。首先，你需要添加一些 JavaScript，并且需要打开 `EventSource`。在
    JavaScript 中，你可以通过 `new EventSource` 来打开 `EventSource`，我们给它我们的 `events` 端点的端点。为了接收普通未命名的事件，我们必须使用
    `onmessage`。我们在 `source.onmessage` 中注册 `function` 并将 `event.data` 附加到我们在文件开头定义的
    `div` 标签：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For any named events, we have to do this in a slightly different manner. Here,
    we have to use a different method called the `addEventListener` method on our
    `source`. We register `addEventListener` for `"sringEvent"`, `"primitiveEvent"`,
    and `jsonEvent`. We append the data received from the event to the `div` tags
    we defined at the top of the JSP file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何命名的事件，我们都需要以稍微不同的方式进行操作。在这里，我们必须使用一个不同的方法，即在我们的 `source` 上使用 `addEventListener`
    方法。我们为 `"sringEvent"`、`"primitiveEvent"` 和 `jsonEvent` 注册 `addEventListener`。我们将从事件接收到的数据附加到我们在
    JSP 文件顶部定义的 `div` 标签：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s open a browser and go to the URL (`localhost:8080/sse-service/events.jsp`).
    This is what our simple UI should look like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个浏览器并访问 URL (`localhost:8080/sse-service/events.jsp`)。这就是我们简单的 UI 应该看起来像的样子：
- en: '![](img/d1bbba3a-bf7c-4b4f-972f-16aaa522c2d3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1bbba3a-bf7c-4b4f-972f-16aaa522c2d3.png)'
- en: 'I know it''s not very pretty, but it does the job. In the background, the SSE
    channel to our server has already been opened. If we open our Postman and start
    to `POST` some events and go back to our browser page, we can see that those events
    will appear, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这看起来不太美观，但它确实完成了任务。在后台，我们已经打开了到我们服务器的 SSE 通道。如果我们打开 Postman 并开始 `POST` 一些事件，然后回到我们的浏览器页面，我们可以看到这些事件将出现，如下面的截图所示：
- en: '![](img/bdd2ccbb-0b6f-4486-ab0b-b15a9c2b3a85.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdd2ccbb-0b6f-4486-ab0b-b15a9c2b3a85.png)'
- en: We invoke these by sending them three times, and you can see here that we have
    three times the different messages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过发送它们三次来调用这些事件，你可以看到这里有三条不同的消息。
- en: That's all for this section. In the next section, we will talk about implementing
    and sending SSE broadcasts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节就到这里。在下一节中，我们将讨论实现和发送 SSE 广播。
- en: Implementing and sending SSE broadcasts
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现和发送 SSE 广播
- en: In this section, we're going to take a look at creating SSE broadcaster instances.
    We're going to register SSE event sinks with this SSE broadcaster, and then we're
    going broadcast events to all registered sinks. Finally, we'll implement a simple
    HTML chat leveraging SSE.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨创建 SSE 广播器实例。我们将使用这个 SSE 广播器注册 SSE 事件接收器，然后我们将向所有已注册的接收器广播事件。最后，我们将实现一个简单的基于
    SSE 的 HTML 聊天功能。
- en: 'There''s a lot of ground to cover in this section. Let''s get started and open
    our IDE. As usual, to get started, we will prepare a small skeleton project. First
    up, we will implement the `BroadcastResource` class, which is the server side
    for sending SSE broadcasts. We have a few things to do. We will inject the SSE
    `@Context` which we need to construct new events. The next thing we need to do
    is initialize an SSE broadcaster. For this, we will use the `@Context` we just
    injected and we''ll define an `SseBroadcaster` so that this is the main instance.
    We will also use a `@PostConstruct` initializer to create a `newBroadcaster` using
    the `sse` context:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中有很多内容需要介绍。让我们开始并打开我们的IDE。像往常一样，为了开始，我们将准备一个小型的骨架项目。首先，我们将实现`BroadcastResource`类，这是发送SSE广播的服务器端。我们有一些事情要做。我们将注入SSE
    `@Context`，我们需要用它来构造新的事件。接下来，我们需要初始化一个SSE广播器。为此，我们将使用我们刚刚注入的`@Context`并定义一个`SseBroadcaster`，这样它就是主要的实例。我们还将使用一个`@PostConstruct`初始化器来创建一个`newBroadcaster`，使用`sse`上下文：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next thing we need to implement is the registering of SSE event sinks with
    this broadcaster. We will implement a simple `@GET` method for that, but remember
    it''s annotated with the media type `text/event-stream`. All we need to do is
    call `sseBroadcaster.register` with the `sseEventSink` instance:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要实现的是将SSE事件接收器注册到这个广播器上。我们将为此实现一个简单的`@GET`方法，但请记住它被注解为媒体类型`text/event-stream`。我们只需要调用`sseBroadcaster.register`方法并传入`sseEventSink`实例：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last bit that is missing is that we need to be able to broadcast and send
    SSE events. What we do here is define a `POST` method that we can use to consume
    an HTML form (`APPLICATION_FORM_URLENCODED`) and the `@FormParam` called `"message"`.
    We use this to construct an outbound SSE event (`OutboundSseEvent`) like we did
    in the previous section. We do this by using `sse.newEvent`, giving it a name,
    and passing it the `message`, and then we use the `broadcast` method on the `sseBroadcaster` instance
    to broadcast the event and we return `noContent`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺失的部分是我们需要能够广播并发送SSE事件。我们在这里定义了一个`POST`方法，我们可以使用它来消费一个HTML表单（`APPLICATION_FORM_URLENCODED`）和名为`"message"`的`@FormParam`。我们使用这个来构造一个出站SSE事件（`OutboundSseEvent`），就像我们在前面的部分所做的那样。我们通过使用`sse.newEvent`，给它一个名字，并传递`message`，然后我们使用`sseBroadcaster`实例上的`broadcast`方法来广播事件，并返回`noContent`：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s all for the server side. Let''s have a quick look on the HTML side.
    Again, we will use a really simple plain JSP file for that like we did in a previous
    section. We will construct an `EventSource` and we will register an event listener
    (`addEventListener`) for our messages. That''s all, with only one minor bit missing—we
    need a simple `form` to post messages to our `BroadcastResource`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的操作就到这里。让我们快速看一下HTML端。同样，我们将会使用一个非常简单的纯JSP文件，就像我们在前面的部分所做的那样。我们将构造一个`EventSource`并为我们的消息注册一个事件监听器（`addEventListener`）。就是这样，只有一个小的细节缺失——我们需要一个简单的`form`来向我们的`BroadcastResource`发送消息：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s put this to the test. We will open up a couple of browser instances
    to see our super fancy HTML chat client:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。我们将打开几个浏览器实例来查看我们的超级酷炫的HTML聊天客户端：
- en: '![](img/dc934f2e-b921-4d2e-978a-28812645f950.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc934f2e-b921-4d2e-978a-28812645f950.png)'
- en: 'Let''s enter `Hello Window 1` and click on Submit, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入`Hello Window 1`并点击提交，如下所示：
- en: '![](img/2fd1eea2-6977-4380-b5a4-7d951516ff60.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fd1eea2-6977-4380-b5a4-7d951516ff60.png)'
- en: 'What we expect is to see this message in the second window. You should see
    the same message in the second window. From the second window, we will type a
    message `Hello from Window 2` and click Submit. Now, if we switch tabs to the
    first window, we should be able to see the Hello from Window 2 message sent from
    the second window, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在第二个窗口中看到这条消息。你应该在第二个窗口中看到相同的消息。从第二个窗口，我们将输入一条消息`Hello from Window 2`并点击提交。现在，如果我们切换到第一个窗口的标签页，我们应该能够看到从第二个窗口发送的`Hello
    from Window 2`消息，如下所示：
- en: '![](img/68de5d84-8073-429b-9817-e38c5d6496dc.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68de5d84-8073-429b-9817-e38c5d6496dc.png)'
- en: 'You might think that this is faked, but it isn''t. Let''s open Postman and
    use it to also send messages to this broadcast resource. If you look at Headers,
    we have the `Content-Type` already mentioned, and we have a `message` under the Body tab.
    We will use Postman to send those events, and what we expect is to see this message
    in the browser windows. Let''s click once, maybe twice, maybe three times. Let''s
    switch back to our browser and you will see Hello SSE broadcast from Postman,
    as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这是伪造的，但事实并非如此。让我们打开Postman并使用它来向这个广播资源发送消息。如果你查看头部信息，我们已经有了一个之前提到的`Content-Type`，在`Body`标签下有一个`message`。我们将使用Postman发送这些事件，我们期望在浏览器窗口中看到这条消息。让我们点击一次，也许两次，也许三次。然后让我们切换回我们的浏览器，你将看到来自Postman的“Hello
    SSE广播”，如下面的截图所示：
- en: '![](img/a7e3e68b-0940-4b0c-bc3c-8fc1fec315a5.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7e3e68b-0940-4b0c-bc3c-8fc1fec315a5.png)'
- en: This proves that we have verified that this is a real broadcast working over
    several client types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们已经验证了这是一个在多个客户端类型上工作的真实广播。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That's it for this chapter. So, what did we have a look at? First up, we had
    to look at usage scenarios of service and events and we talked about what SSEs
    are and other related technologies. Next up, we implemented the sending of services
    events on the server side with JAX-RS. Then, we had a look at implementing SSE
    clients and receiving those events using JAX-RS client APIs as well as HTML. Finally,
    we implemented the sending of SSE broadcasts on the server side and we implemented
    a small HTML chat client.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章的全部内容。那么，我们探讨了什么？首先，我们必须查看服务和事件的用例，并讨论了SSE是什么以及其他相关技术。接下来，我们使用JAX-RS在服务器端实现了服务事件的发送。然后，我们查看使用JAX-RS客户端API以及HTML实现SSE客户端和接收这些事件。最后，我们在服务器端实现了SSE广播的发送，并实现了一个小的HTML聊天客户端。
- en: In the next and final chapter, we will have a look at advanced REST APIs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将探讨高级REST API。
