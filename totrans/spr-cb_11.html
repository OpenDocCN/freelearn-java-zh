<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Using the Java RMI, HTTP Invoker, Hessian, and REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Using the Java RMI, HTTP Invoker, Hessian, and REST</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a Java RMI service</li><li class="listitem" style="list-style-type: disc">Querying an existing Java RMI service</li><li class="listitem" style="list-style-type: disc">Creating an HTTP Invoker service</li><li class="listitem" style="list-style-type: disc">Querying an existing HTTP Invoker service</li><li class="listitem" style="list-style-type: disc">Creating a Hessian service</li><li class="listitem" style="list-style-type: disc">Querying an existing Hessian service</li><li class="listitem" style="list-style-type: disc">Creating a REST service</li><li class="listitem" style="list-style-type: disc">Querying an existing REST service</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec113"/>Introduction</h1></div></div></div><p>This chapter is about making Spring interact with another piece of software over a network. Different protocols can be used for this, but each one of them uses a client/server architecture. Spring can be the client or server.</p><div class="mediaobject"><img src="graphics/5807OS_11_01.jpg" alt="Introduction"/></div><p>Java RMI and HTTP Invoker are remote method invocation technologies; a Java client executes a method located on a Java server just as with a normal method. The request contains the method's arguments and the response contains the method's return value.</p><p>Hessian, REST, and SOAP are web services; the request is an HTTP request to a web server, which sends back an HTTP response. Web services are platform agnostic; for example, the client could be a Spring application (Java) and the server could be a PHP application.</p><p>REST is currently the most popular option; it's simple, flexible, and cross-platform.</p><p>As a rule of thumb, use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">HTTP Invoker to interact with another Spring application</li><li class="listitem" style="list-style-type: disc">Java RMI to interact with another Java application not using Spring</li><li class="listitem" style="list-style-type: disc">Hessian to interact with another Java application not using Spring when you need to go over proxies and firewalls</li><li class="listitem" style="list-style-type: disc">SOAP if you have to; it won't be covered in this chapter</li><li class="listitem" style="list-style-type: disc">REST for all other cases</li></ul></div></div></div>
<div class="section" title="Creating a Java RMI service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec114"/>Creating a Java RMI service</h1></div></div></div><p>The Java RMI is <a id="id486" class="indexterm"/>a Java remote method invocation technology; a client executes a method ocated on a server, the Java RMI service.</p><p>In this recipe, we <a id="id487" class="indexterm"/>will set up a Java RMI service that will expose the methods of a normal Java class. The service will be part of an existing Spring web application but will use its own port.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec265"/>Getting ready</h2></div></div></div><p>The server will expose the methods of the <code class="literal">UserService</code> interface:</p><div class="informalexample"><pre class="programlisting">Public interface UserService {
  public abstract List&lt;User&gt; findAll();
  public abstract void addUser(User user);
}</pre></div><p>The <code class="literal">UserService</code> interface is implemented by <code class="literal">UserServiceImpl</code>:</p><div class="informalexample"><pre class="programlisting">public class UserServiceImpl implements UserService {
  private List&lt;User&gt; userList = new LinkedList&lt;User&gt;();

  public UserServiceImpl() {
    User user1 = new User("Merlin", 777);
    userList.add(user1);
    
    User user2 = new User("Arthur", 123);
    userList.add(user2);
  }
  
  public List&lt;User&gt; findAll() {
    return userList;
  }
  
  public void addUser(User user) {
    userList.add(user);
  }  
}</pre></div><p>The <code class="literal">UserService</code> methods will receive and send <code class="literal">User</code> objects:</p><div class="informalexample"><pre class="programlisting">public class User implements Serializable {    
  private String name;
  private int age;
  
  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // ... getters and setters
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Note<a id="id488" class="indexterm"/> that the <code class="literal">User</code> class implements <code class="literal">Serializable</code>; this is necessary because the <code class="literal">User</code> objects are serialized before they are transmitted over the network.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec266"/>How to do it…</h2></div></div></div><p>Here are the steps to create a Java RMI service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Spring configuration, add a <code class="literal">UserService</code> bean returning an instance of <code class="literal">UserServiceImpl</code>:<div class="informalexample"><pre class="programlisting">@Bean
public UserService userService() {
  return new UserServiceImpl();
}</pre></div></li><li class="listitem">Add an <code class="literal">RmiServiceExporter</code> bean. Define the Java RMI service name, the interface exposed by the service, and the object implementing it:<div class="informalexample"><pre class="programlisting">@Bean
public RmiServiceExporter rmiServiceExporter() {
  RmiServiceExporter rmiServiceExporter = new RmiServiceExporter();
  rmiServiceExporter.setServiceName("userService");
  rmiServiceExporter.setServiceInterface(UserService.class);
  rmiServiceExporter.setService(userService());
  return rmiServiceExporter;
}</pre></div></li><li class="listitem">The<a id="id489" class="indexterm"/> Java RMI service is now available at <code class="literal">rmi://localhost:1099/userService</code>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec267"/>How it works…</h2></div></div></div><p><code class="literal">RmiServiceExporter</code> is a Spring class generating an RMI service from a Java interface (<code class="literal">UserService</code>). For each method defined in <code class="literal">UserService</code>, the corresponding method from <code class="literal">userService()</code>, in <code class="literal">UserServiceImpl</code>, will be executed. The RMI service is made available by default on the <code class="literal">1099</code> port.</p></div></div>
<div class="section" title="Querying an existing Java RMI service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec115"/>Querying an existing Java RMI service</h1></div></div></div><p>In this recipe, we will configure a Spring web application, so that it will be able to execute a method on an existing RMI service.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec268"/>Getting ready</h2></div></div></div><p>We will <a id="id490" class="indexterm"/>query the Java RMI service of the previous <span class="emphasis"><em>Creating a Java RMI service</em></span> recipe.</p><p>We need the <code class="literal">UserService</code> interface so that our application knows the methods available on the RMI service:</p><div class="informalexample"><pre class="programlisting">public interface UserService {
  public abstract List&lt;User&gt; findAll();
  public abstract void addUser(User user);
}</pre></div><p><code class="literal">User</code> objects will be exchanged over the network, so we need the <code class="literal">User</code> class of the previous recipe as well:</p><div class="informalexample"><pre class="programlisting">public class User implements Serializable {    
  private String name;
  private int age;
  
  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // ... getters and setters
}</pre></div><p>In real applications, these classes could be provided to the RMI client as a JAR file.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec269"/>How to do it…</h2></div></div></div><p>Here are<a id="id491" class="indexterm"/> the steps to query a Java RMI service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Spring configuration, add a <code class="literal">RmiProxyFactoryBean</code> bean named <code class="literal">userService</code>. Define the Java RMI service URL and the <code class="literal">UserService</code> interface:<div class="informalexample"><pre class="programlisting">@Bean(name="userService")
public RmiProxyFactoryBean rmiProxyFactoryBean() {
  RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean();
  rmiProxyFactoryBean.setServiceUrl("rmi://localhost:1099/userService");
  rmiProxyFactoryBean.setServiceInterface(UserService.class);
  return rmiProxyFactoryBean;
}</pre></div></li><li class="listitem">In a controller class, add an autowired <code class="literal">UserService</code> field:<div class="informalexample"><pre class="programlisting">@Controller
public class UserController {
  @Autowired
  private UserService userService;</pre></div></li><li class="listitem">In a controller method, execute the <code class="literal">findAll()</code> method of the <code class="literal">UserService</code> object:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public void userList() {
  List&lt;User&gt; userList = userService.findAll();
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec270"/>How it works…</h2></div></div></div><p>The<a id="id492" class="indexterm"/> autowired <code class="literal">UserService</code> object is created behind the scenes by Spring. It's actually an <code class="literal">RmiProxyFactoryBean</code> object that will delegate the execution of the <code class="literal">findAll()</code>method to the Java RMI service located at <code class="literal">rmi://localhost:1099/userService</code>.</p></div></div>
<div class="section" title="Creating an HTTP Invoker service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec116"/>Creating an HTTP Invoker service</h1></div></div></div><p>HTTP Invoker, like<a id="id493" class="indexterm"/> the Java RMI, is a Java remote method invocation technology; here, a client<a id="id494" class="indexterm"/> executes a method located on a server-the HTTP invoker service. HTTP is used instead of a custom port, so it can go over proxies and firewalls. However, it's a Spring technology, so both the client and the server must use Java and Spring.</p><p>In this recipe, we will set up an HTTP Invoker service that will expose the methods of a normal Java class. The service will be part of an existing Spring web application.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec271"/>Getting ready</h2></div></div></div><p>The server will expose the methods of the <code class="literal">UserService</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface UserService {
  public abstract List&lt;User&gt; findAll();
  public abstract void addUser(User user);
}</pre></div><p>The <code class="literal">UserService</code> interface is implemented by <code class="literal">UserServiceImpl</code>:</p><div class="informalexample"><pre class="programlisting">public class UserServiceImpl implements UserService {
  private List&lt;User&gt; userList = new LinkedList&lt;User&gt;();

  public UserServiceImpl() {
    User user1 = new User("Merlin", 777);
    userList.add(user1);
    
    User user2 = new User("Arthur", 123);
    userList.add(user2);
  }
  
  public List&lt;User&gt; findAll() {
    return userList;
  }
  
  public void addUser(User user) {
    userList.add(user);
  }  
}</pre></div><p>The <code class="literal">UserService</code> methods will receive and send <code class="literal">User</code> objects:</p><div class="informalexample"><pre class="programlisting">public class User implements Serializable {    
  private String name;
  private int age;
  
  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // ... getters and setters
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Note that the <code class="literal">User</code> class implements <code class="literal">Serializable</code>; it's necessary because <code class="literal">User</code> objects are serialized before they are transmitted over the network.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec272"/>How to do it…</h2></div></div></div><p>Here <a id="id495" class="indexterm"/>are the steps to create an HTTP Invoker service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Spring configuration, add a <code class="literal">UserService</code> bean returning an instance of <code class="literal">UserServiceImpl</code>:<div class="informalexample"><pre class="programlisting">@Bean
public UserService userService() {
  return new UserServiceImpl();
}</pre></div></li><li class="listitem">Add an <code class="literal">HttpInvokerServiceExporter</code> bean named <code class="literal">/userService</code>. Define the interface exposed by the service and the object implementing it:<div class="informalexample"><pre class="programlisting">@Bean(name = "/userService")
public HttpInvokerServiceExporter httpInvokerServiceExporter() {
  HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
  exporter.setService(userService());
  exporter.setServiceInterface(UserService.class);
  return exporter;
}</pre></div></li><li class="listitem">The HTTP Invoker service is now available at the <code class="literal">/userService</code> URL of the Spring web application.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec273"/>How it works…</h2></div></div></div><p><code class="literal">HttpInvokerServiceExporter</code> is a Spring class generating an HTTP Invoker service from a <a id="id496" class="indexterm"/>Java interface (<code class="literal">UserService</code>). For each method defined in <code class="literal">UserService</code>, the corresponding method from <code class="literal">userService()</code>, in <code class="literal">UserServiceImpl</code>, will be executed.</p></div></div>
<div class="section" title="Querying an existing HTTP Invoker service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec117"/>Querying an existing HTTP Invoker service</h1></div></div></div><p>In this recipe, we will configure a Spring web application that will be able to execute a method on an <a id="id497" class="indexterm"/>existing HTTP Invoker service.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec274"/>Getting ready</h2></div></div></div><p>We will query the HTTP Invoker service of the previous <span class="emphasis"><em>Creating an HTTP Invoker service</em></span> recipe.</p><p>We need the <code class="literal">UserService</code> interface so that our application knows the methods available on the HTTP Invoker service:</p><div class="informalexample"><pre class="programlisting">public interface UserService {
  public abstract List&lt;User&gt; findAll();
  public abstract void addUser(User user);
}</pre></div><p><code class="literal">User</code> objects will be exchanged over the network, so we need the <code class="literal">User</code> class of the previous recipe as well:</p><div class="informalexample"><pre class="programlisting">public class User implements Serializable {    
  private String name;
  private int age;
  
  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // ... getters and setters
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec275"/>How to do it…</h2></div></div></div><p>Here are the steps for using an HTTP Invoker service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Spring configuration, add an <code class="literal">HttpInvokerProxyFactoryBean</code> bean named <code class="literal">userService</code>. Define the HTTP Invoker service URL and the <code class="literal">UserService</code> interface:<div class="informalexample"><pre class="programlisting">@Bean(name="userService")
public HttpInvokerProxyFactoryBean userService() {
  HttpInvokerProxyFactoryBean factory = new HttpInvokerProxyFactoryBean();
  factory.setServiceUrl("http://localhost:8080/http_invoker_server/userService");
  factory.setServiceInterface(UserService.class);
  return factory;
}</pre></div></li><li class="listitem">In a <a id="id498" class="indexterm"/>controller class, add a <code class="literal">UserService</code> field as a standard autowired service bean:<div class="informalexample"><pre class="programlisting">@Controller
public class UserController {
  @Autowired
  private UserService userService;</pre></div></li><li class="listitem">In a controller method, execute the <code class="literal">findAll()</code> method of the <code class="literal">UserService</code> object and log the results:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public void userList() {
  List&lt;User&gt; userList = userService.findAll();
  for (User user : userList) {
    System.out.println("User " + user.getAge() + " is " + user.getAge() + " years old");
  }
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec276"/>How it works…</h2></div></div></div><p>In the <code class="literal">UserController</code> class, the autowired <code class="literal">UserService</code> object is instantiated behind the scenes by Spring. It's actually an <code class="literal">HttpInvokerProxyFactoryBean</code>, which will delegate the execution of the <code class="literal">findAll()</code>method to the HTTP Invoker service located at <code class="literal">http://localhost:8080/http_invoker_server/userService</code>.</p></div></div>
<div class="section" title="Creating a Hessian service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec118"/>Creating a Hessian service</h1></div></div></div><p>Hessian<a id="id499" class="indexterm"/> is a remote method invocation technology; here, a client executes a method located on a server-the Hessian service. It uses HTTP, so it can go over proxies and firewalls. It also has implementations in multiple languages (PHP, Python, Ruby, and so on). So, for example, the client can use Java and the server can use PHP.</p><p>In this recipe, we<a id="id500" class="indexterm"/> will add a Hessian service to an existing Spring web application. It will expose the methods of a Java class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec277"/>Getting ready</h2></div></div></div><p>The server will expose the methods of the <code class="literal">UserService</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface UserService {
  public abstract List&lt;User&gt; findAll();
  public abstract void addUser(User user);
}</pre></div><p>The <code class="literal">UserService</code> interface is implemented by <code class="literal">UserServiceImpl</code>:</p><div class="informalexample"><pre class="programlisting">public class UserServiceImpl implements UserService {
  private List&lt;User&gt; userList = new LinkedList&lt;User&gt;();

  public UserServiceImpl() {
    User user1 = new User("Merlin", 777);
    userList.add(user1);
    
    User user2 = new User("Arthur", 123);
    userList.add(user2);
  }
  
  public List&lt;User&gt; findAll() {
    return userList;
  }
  
  public void addUser(User user) {
    userList.add(user);
  }  
}</pre></div><p>The <code class="literal">UserService</code> methods will receive and send <code class="literal">User</code> objects:</p><div class="informalexample"><pre class="programlisting">public class User {    
  private String name;
  private int age;
  
  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // ... getters and setters
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Note that the <code class="literal">User</code> class doesn't need to implement <code class="literal">Serializable</code>. Hessian uses its own object serialization mechanism.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec278"/>How to do it…</h2></div></div></div><p>Here are<a id="id501" class="indexterm"/> the steps to create a Hessian service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Spring configuration, add a <code class="literal">UserService</code> bean returning an instance of <code class="literal">UserServiceImpl</code>:<div class="informalexample"><pre class="programlisting">@Bean
public UserService userService() {
  return new UserServiceImpl();
}</pre></div></li><li class="listitem">Add a <code class="literal">HessianServiceExporter</code> bean named <code class="literal">/userService</code>. Define the interface exposed by the service and the object implementing it:<div class="informalexample"><pre class="programlisting">@Bean(name = "/userService")
public HessianServiceExporter hessianServiceExporter () {
  HessianServiceExporterexporter = new HessianServiceExporter ();
  exporter.setService(userService());
  exporter.setServiceInterface(UserService.class);
  return exporter;
}</pre></div></li><li class="listitem">The Hessian service is now available at the <code class="literal">/userService</code> URL of the Spring web application.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec279"/>How it works…</h2></div></div></div><p><code class="literal">HessianServiceExporter</code> is a Spring class generating a Hessian service from a Java interface (<code class="literal">UserService</code>). For each method defined in <code class="literal">UserService</code>, the corresponding method from <code class="literal">userService()</code>, in <code class="literal">UserServiceImpl</code>, will be executed.</p></div></div>
<div class="section" title="Querying an existing Hessian service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec119"/>Querying an existing Hessian service</h1></div></div></div><p>In this recipe, we will configure a Spring web application, so that it will be able to execute a method on an existing Hessian service.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec280"/>Getting ready</h2></div></div></div><p>We will<a id="id502" class="indexterm"/> query the Hessian service of the previous <span class="emphasis"><em>Creating a Hessian service</em></span> recipe.</p><p>We need the <code class="literal">UserService</code> interface, so that our application knows the methods available on the Hessian service:</p><div class="informalexample"><pre class="programlisting">public interface UserService {
  public abstract List&lt;User&gt; findAll();
  public abstract void addUser(User user);
}</pre></div><p><code class="literal">User</code> objects will be exchanged over the network, so we need the <code class="literal">User</code> class of the previous recipe as well:</p><div class="informalexample"><pre class="programlisting">public class User implements Serializable {    
  private String name;
  private int age;
  
  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // ... getters and setters
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec281"/>How to do it…</h2></div></div></div><p>Here are the steps for using a Hessian service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Spring configuration, add a <code class="literal">HessianProxyFactoryBean</code> bean named <code class="literal">userService</code>. Define the Hessian service URL and the <code class="literal">UserService</code> interface:<div class="informalexample"><pre class="programlisting">@Bean(name="userService")
public HessianProxyFactoryBean userService() {
  HessianProxyFactoryBean factory = new HessianProxyFactoryBean();
  factory.setServiceUrl("http://localhost:8080/hessian_server/userService");
  factory.setServiceInterface(UserService.class);
  return factory;
}</pre></div></li><li class="listitem">In a<a id="id503" class="indexterm"/> controller class, add a <code class="literal">UserService</code> field as a standard autowired service bean:<div class="informalexample"><pre class="programlisting">@Controller
public class UserController {
  @Autowired
  private UserService userService;</pre></div></li><li class="listitem">In a controller method, execute the <code class="literal">findAll()</code> method of the <code class="literal">UserService</code> object and log the results:<div class="informalexample"><pre class="programlisting">@RequestMapping("user_list")
@ResponseBody
public void userList() {
  List&lt;User&gt; userList = userService.findAll();
  for (User user : userList) {
    System.out.println("User " + user.getAge() + " is " + user.getAge() + " years old");
  }
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec282"/>How it works…</h2></div></div></div><p>In the <code class="literal">UserController</code> class, the autowired <code class="literal">UserService</code> object is instantiated behind the scenes by Spring. It's actually a <code class="literal">HessianProxyFactoryBean</code> that will delegate the execution of the <code class="literal">findAll()</code>method to the Hessian service located at <code class="literal">http://localhost:8080/hessian/userService</code>.</p></div></div>
<div class="section" title="Creating a REST service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec120"/>Creating a REST service</h1></div></div></div><p>REST uses a <a id="id504" class="indexterm"/>web service architecture; here, a client sends an HTTP request to a server, which sends back an HTTP response. JSON is most of the time used for data transfer. The list of URLs supported by the server is called the REST API. These <a id="id505" class="indexterm"/>URLs are kept<a id="id506" class="indexterm"/> simple using different HTTP methods. For example, the <code class="literal">/users/3</code> request using the GET method will return the user whose ID is 3. The <code class="literal">/users/3</code> request using the DELETE method will delete that same user.</p><p>In this recipe, we will create a simple REST service that will allow a REST client to query and modify a list of <code class="literal">User</code> objects on the server.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec283"/>Getting ready</h2></div></div></div><p>We will use the <code class="literal">User</code> class:</p><div class="informalexample"><pre class="programlisting">public class User {
    
  private Long id;
  private String name;
  private int age;
  
  public User() {
  }

  public User(Long id, String name, int age) {
    this.id = id;
    this.name = name;
    this.age = age;
  }

  // ... getters and setters
}</pre></div><p>We will <a id="id507" class="indexterm"/>use the <code class="literal">UserService</code> class with a preset list of users:</p><div class="informalexample"><pre class="programlisting">public class UserService {

  List&lt;User&gt; userList = new LinkedList&lt;User&gt;();

  public UserService() {
    User user1 = new User(1L, "Merlin", 777);
    userList.add(user1);
    
    User user2 = new User(2L, "Arthur", 123);
    userList.add(user2);
  }
  
  public List&lt;User&gt; findAll() {
    return userList;
  }
  
  public User findUser(Long id) {
    for (User user : userList) {
      if(user.getId().equals(id)) {
        return user;
      }
    }
    return null;
  }
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec284"/>How to do it…</h2></div></div></div><p>Here are<a id="id508" class="indexterm"/> the steps to create a REST service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the Maven dependencies for <code class="literal">jackson</code> in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
  &lt;version&gt;2.4.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
  &lt;version&gt;2.4.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">In the Spring configuration, add a <code class="literal">UserService</code> bean:<div class="informalexample"><pre class="programlisting">@Bean
public UserService userService() {
  return new UserService();
}</pre></div></li><li class="listitem">Create a controller class with a URL prefix annotated with <code class="literal">@RestController</code>:<div class="informalexample"><pre class="programlisting">@RestController
@RequestMapping("users*")
public class UserController {
}</pre></div></li><li class="listitem">Add an autowired <code class="literal">UserService</code> field:<div class="informalexample"><pre class="programlisting">@Autowired
private UserService userService;</pre></div></li><li class="listitem">Add a controller method returning the list of all users:<div class="informalexample"><pre class="programlisting">@RequestMapping
public List&lt;User&gt; userList() {
  List&lt;User&gt; userList = userService.findAll();
  return userList;
}</pre></div></li><li class="listitem">Add a controller method returning the user corresponding to a given ID:<div class="informalexample"><pre class="programlisting">@RequestMapping("/{id}")
public User findUser(@PathVariable("id") Long userId) {
  User user = userService.findUser(userId);
  return user;
}</pre></div></li><li class="listitem">The Spring web application is now a REST service. It will return User objects serialized to JSON in response to the <code class="literal">/users</code> and <code class="literal">/users/1</code> URL requests.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec285"/>How it works…</h2></div></div></div><p><code class="literal">UserController</code> is a standard Spring controller except for the <code class="literal">@RestController</code> annotation, which <a id="id509" class="indexterm"/>will automatically convert the objects returned by the controller methods to JSON, using the Jackson library.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec286"/>There's more…</h2></div></div></div><p>To use a specific HTTP method, add the <code class="literal">method</code> argument in the <code class="literal">@RequestMapping</code> annotation:</p><div class="informalexample"><pre class="programlisting">@RequestMapping(value = "/{id}", method = RequestMethod.POST)</pre></div><p>To secure a REST service:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use HTTPS so that data transfers between the client and server are encrypted. Refer to the <span class="emphasis"><em>Using HTTPS with Tomcat</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Managing Security">Chapter 6</a>, <span class="emphasis"><em>Managing Security</em></span>.</li><li class="listitem" style="list-style-type: disc">If you want only authorized clients to query it, you can use HTTP Basic Authentication. Refer to the <span class="emphasis"><em>Authenticating users using the default login page</em></span> recipe from <a class="link" href="ch06.html" title="Chapter 6. Managing Security">Chapter 6</a>, <span class="emphasis"><em>Managing Security</em></span>, especially, the <code class="literal">httpBasic()</code> method. Another possibility is to use an OAuth workflow. It's more complicated, but it avoids the client having to send a username and password at each request. That's the method chosen by Facebook and Twitter for their REST API, for example.</li></ul></div></div></div>
<div class="section" title="Querying an existing REST service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec121"/>Querying an existing REST service</h1></div></div></div><p>In this recipe, from<a id="id510" class="indexterm"/> a Spring controller method, we will retrieve data from an existing REST service.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec287"/>Getting ready</h2></div></div></div><p>We will query the REST service of the previous <span class="emphasis"><em>Creating a REST service</em></span> recipe.</p><p>We will convert the JSON data received from the REST service to <code class="literal">User</code> objects. We will use this <code class="literal">User</code> class:</p><div class="informalexample"><pre class="programlisting">public class User implements {    
  private String name;
  private int age;

  // ... getters and setters
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec288"/>How to do it…</h2></div></div></div><p>Here are the steps for using a REST service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the Maven dependencies for Jackson in <code class="literal">pom.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
  &lt;version&gt;2.4.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
  &lt;version&gt;2.4.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">In a controller method, define the URL of the REST service to query:<div class="informalexample"><pre class="programlisting">String url = "http://localhost:8080/rest_server/users/2";</pre></div></li><li class="listitem">Use the <code class="literal">RestTemplate</code> class and its <code class="literal">getForObject()</code> method to query the REST service and generate a <code class="literal">User</code> object from the JSON response:<div class="informalexample"><pre class="programlisting">RestTemplate restTemplate = new RestTemplate();
User user = restTemplate.getForObject(url, User.class);</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec289"/>How it works…</h2></div></div></div><p><code class="literal">RestTemplate</code> is a class provided by Spring that provides methods to easily query REST services and generate Java objects from the received JSON response.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec290"/>There's more…</h2></div></div></div><p>If the response is <a id="id511" class="indexterm"/>a list of objects, pass an array class as a second parameter to generate an array of objects:</p><div class="informalexample"><pre class="programlisting">User[] userList = restTemplate.getForObject(url, User[].class);</pre></div></div></div></body></html>