- en: Chapter 9. Creating ImageJ Plugins for Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。创建用于分析的ImageJ插件
- en: 'In this chapter, we will examine how to create plugins to perform analyses.
    This chapter will examine how to make a flexible plugin, and how to implement
    it in ImageJ to perform a simple analysis. The following topics will be dealt
    with in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何创建用于分析的插件。本章将探讨如何创建一个灵活的插件，以及如何在ImageJ中实现它以执行简单的分析。本章将涉及以下主题：
- en: Setting up a new plugin project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新的插件项目
- en: Using a plugin to process and analyze images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插件处理和分析图像
- en: Adding user interaction and preferences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用户交互和偏好
- en: Using external libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部库
- en: Sharing your plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享你的插件
- en: Plugin background and goal
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件背景和目标
- en: 'In this section, I will briefly describe an image-processing problem that we
    will try to solve using a plugin. The problem is a general one that is encountered
    in many experiments involving living cells or organisms: they move and change
    shape. When we want to quantify certain aspects of the cells that we have imaged,
    we need to perform three basic steps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将简要描述一个我们将尝试使用插件解决的问题。这个问题是一个普遍问题，在涉及活细胞或生物体的许多实验中都会遇到：它们会移动和改变形状。当我们想要量化我们所成像的细胞的一些方面时，我们需要执行三个基本步骤：
- en: Detect the object of interest.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测感兴趣的对象。
- en: Measure our object in the current frame.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前帧中测量我们的对象。
- en: Detect each object in our time series independently.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立检测我们时间序列中的每个对象。
- en: These steps are encountered in many different problems involving time series.
    For each of the three steps, we need to create a solution that solves the problem
    or quantifies the object in a meaningful manner. For detection, we can think of
    many methods that may be suitable to detect the object. When we think back to
    the topics discussed in [Chapter 4](ch04.html "Chapter 4. Image Segmentation and
    Feature Extraction with ImageJ"), *Image Segmentation and Feature Extraction with
    ImageJ* we may think of a threshold-based technique to segment the image, and
    use a particle analyzer to find objects that contain specific features. For measurements,
    we can go back to [Chapter 5](ch05.html "Chapter 5. Basic Measurements with ImageJ"),
    *Basic Measurements with ImageJ* where we looked at the basic methods to measure
    objects using ImageJ commands. The final component for this example uses the previous
    two methods for each of the identified objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在许多涉及时间序列的不同问题中都会遇到。对于这三个步骤中的每一个，我们需要创建一个解决方案来解决问题或以有意义的方式量化对象。对于检测，我们可以考虑许多可能适合检测对象的方法。当我们回顾到[第4章](ch04.html
    "第4章。使用ImageJ进行图像分割和特征提取")中讨论的主题，*使用ImageJ进行图像分割和特征提取*时，我们可能会考虑一个基于阈值的分割图像的技术，并使用粒子分析器找到具有特定特征的物体。对于测量，我们可以回到[第5章](ch05.html
    "第5章。使用ImageJ进行基本测量")，*使用ImageJ进行基本测量*，在那里我们研究了使用ImageJ命令测量对象的基本方法。本例的最终组件使用前两种方法对每个识别的对象进行处理。
- en: To make our plugin more general and widely usable, we will also need to specify
    some parameters that will influence the outcome for each of these steps. The detection
    might need different criteria about what is a valid object depending on the data.
    To this end, we can create a generic dialog that will ask the user for input using
    a few input fields. I will give different examples of the same code that can be
    used in different scenarios.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的插件更加通用和广泛使用，我们还需要指定一些参数，这些参数将影响每个步骤的结果。检测可能需要根据数据的不同，对有效对象有不同的标准。为此，我们可以创建一个通用的对话框，通过几个输入字段向用户请求输入。我将给出不同场景下可以使用的相同代码的不同示例。
- en: Basic project setup
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本项目设置
- en: For this project, I will be using the Maven system to set up the project and
    the dependencies that are required. Most of the source code can also be run without
    these steps, but I will set it up using the NetBeans IDE using a Maven POM project.
    As we saw in [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"),
    *Explanation of ImageJ Constructs* setting up a new project for ImageJ using Maven
    is done by navigating to **File** | **New Project**, and choosing **POM Project**
    from the **Maven** category in the wizard. For this plugin, I will use the project
    name `Object_Tracker`. After clicking **Finish**, the project will be created
    and should show up in the **Projects** view. If you cannot see the **Projects**
    view, go to **Window** | **Projects** from the menu to display it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此项目，我将使用 Maven 系统来设置项目和所需的依赖项。大部分源代码也可以不经过这些步骤运行，但我会使用 NetBeans IDE 和 Maven
    POM 项目来设置它。正如我们在 [第 7 章](ch07.html "第 7 章。ImageJ 构造解释") *ImageJ 构造解释* 中所看到的，使用
    Maven 为 ImageJ 设置新项目是通过导航到 **文件** | **新建项目**，并在向导中的 **Maven** 类别中选择 **POM 项目**
    来完成的。对于此插件，我将使用项目名称 `Object_Tracker`。点击 **完成** 后，项目将被创建，并应在 **项目** 视图中显示。如果您看不到
    **项目** 视图，请从菜单中选择 **窗口** | **项目** 来显示它。
- en: 'To start with, we need to tell Maven that we require ImageJ as a dependency.
    We do this by adding a `<dependencies>` section to our `pom.xml` file, as was
    shown in [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"),
    *Explanation of ImageJ Constructs*. We will first look at how to create this plugin
    as a legacy plugin using all the standard coding of a legacy plugin. To code it
    as a legacy plugin, we will use ImageJ version **1.50b** as a dependency by adding
    the following code to our `pom.xml` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要告诉 Maven 我们需要 ImageJ 作为依赖项。我们通过在 `pom.xml` 文件中添加一个 `<dependencies>` 部分来实现，正如在
    [第 7 章](ch07.html "第 7 章。ImageJ 构造解释") *ImageJ 构造解释* 中所展示的那样。我们将首先查看如何创建这个插件作为遗留插件，使用所有遗留插件的标准化编码。要将它编码为遗留插件，我们将通过在
    `pom.xml` 文件中添加以下代码，将 ImageJ 版本 **1.50b** 作为依赖项：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `<repositories>` section tells Maven where to find the sources for our dependencies,
    and in the optional `<version>` tag, we specify which version of ImageJ we wish
    to use. Note that if you start typing the version number in the tag, NetBeans
    will suggest version numbers that you can enter. At the time of writing **1.50b**
    was the latest version of ImageJ. If you leave this tag out, the version will
    be automatically set to the latest managed version. We will save the modifications
    to our POM file, which will trigger NetBeans to load the requested dependency
    from the repository and place it in the **Dependencies** folder within your project.
    If you issue the build command (**Run** | **Build Project**) for the project at
    this stage, we will still get an error. We are missing the source code for the
    plugin; this will be our next step.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`<repositories>` 部分告诉 Maven 我们依赖项的源在哪里，在可选的 `<version>` 标签中，我们指定我们希望使用的 ImageJ
    版本。请注意，如果您在标签中开始输入版本号，NetBeans 将建议您可以输入的版本号。在撰写本文时，**1.50b** 是 ImageJ 的最新版本。如果您省略此标签，版本将自动设置为最新管理的版本。我们将保存对
    POM 文件的修改，这将触发 NetBeans 从存储库加载请求的依赖项，并将其放置在项目中的 **依赖项** 文件夹内。如果您在此阶段为项目发出构建命令（**运行**
    | **构建项目**），我们仍然会得到一个错误。我们缺少插件的源代码；这将是我们的下一步。'
- en: 'To add our source code, we will need to add a new Java class file to our project.
    The following steps will let you create the main class file for this project;
    however, these steps are identical to generate other classes that you want to
    add to the same project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的源代码，我们需要在我们的项目中添加一个新的 Java 类文件。以下步骤将帮助您创建此项目的主体类文件；然而，这些步骤与生成您想要添加到同一项目的其他类是相同的：
- en: Right-click on the `Object_Tracker` project and go to **New | Java Class…**
    from the context menu.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Object_Tracker` 项目，从上下文菜单中选择 **新建 | Java 类…**。
- en: Enter `Object_Tracker` as the name for the new class, and set the **Location**
    to `/src/main/java`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类的名称输入为 `Object_Tracker`，并将 **位置** 设置为 `/src/main/java`。
- en: You will get a new java source file, and in the **Projects** view you will see
    the **Source Packages** directory is added to your project. You can now try and
    build the project again, which should now finish successfully. As a Maven project
    can also create Javadoc documentation for a project, we will also make sure that
    we add Javadoc comments to our class, and methods to document the API of our plugin.
    We will start the development of our plugin by implementing it as a `PlugInFilter`
    type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个新的 Java 源文件，在 **项目** 视图中，你会看到 **源包** 目录已被添加到你的项目中。现在你可以尝试再次构建项目，这次应该可以成功完成。由于
    Maven 项目也可以为项目创建 Javadoc 文档，我们还将确保我们为我们的类添加 Javadoc 注释，并为我们的插件 API 记录方法。我们将通过将其实现为
    `PlugInFilter` 类型来开始我们插件的开发。
- en: Creating a basic PlugInFilter
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的 PlugInFilter
- en: To create a `PlugInFilter` implementation, we add the `implements` keyword behind
    the class name and specify `PlugInFilter` as the implementation. When you do this
    using an IDE, such as NetBeans, it will place a red squiggly underline under this
    statement. When you place the cursor on the line with the squiggly underline and
    press *Alt* + *Enter* (in NetBeans), the editor will give you a list of suggestions
    to rectify the mistake that we made. The first complaint is that NetBeans cannot
    find the `PlugInFilter` symbol because we haven't added it yet. Press *Alt* +
    *Enter* and select the option called **Add import** for `ij.plugin.filter.PlugInFilter`.
    You will now see that the import statement is added to your source file (usually
    at the top of the source file). We now still have a squiggly underline in our
    class statement as it is missing the overrides for the abstract setup and run
    methods. As explained in [Chapter 8](ch08.html "Chapter 8. Anatomy of ImageJ Plugins"),
    *Anatomy of ImageJ Plugins* `PlugInFilter` requires these two methods to be present
    and overridden with your initialization code (setup) and your programming logic
    (run). Use the *Alt* + *Enter* method, and choose the option called **Implement
    all abstract methods** from the list of choices. At this stage, we have a basic
    `PlugInFilter` implementation that contains all the required elements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 `PlugInFilter` 实现，我们在类名后面添加 `implements` 关键字，并指定 `PlugInFilter` 作为实现。当你使用像
    NetBeans 这样的 IDE 做这件事时，它会在该语句下放置一个红色的波浪线。当你将光标放在带有波浪线的行上并按 *Alt* + *Enter*（在 NetBeans
    中）时，编辑器会给你一个建议列表来纠正我们犯的错误。第一个问题是 NetBeans 找不到 `PlugInFilter` 符号，因为我们还没有添加它。按 *Alt*
    + *Enter* 并选择名为 **添加导入** 的 `ij.plugin.filter.PlugInFilter` 选项。现在你会看到导入语句已经添加到你的源文件中（通常在源文件顶部）。我们现在仍然在我们的类声明中有波浪线，因为它缺少抽象设置和运行方法的覆盖。正如在
    [第 8 章](ch08.html "第 8 章。ImageJ 插件的解剖") 中所解释的，《ImageJ 插件的解剖》中的 `PlugInFilter`
    要求这两个方法存在，并且用你的初始化代码（设置）和你的编程逻辑（运行）覆盖。使用 *Alt* + *Enter* 方法，并从选择列表中选择名为 **实现所有抽象方法**
    的选项。在这个阶段，我们有一个基本的 `PlugInFilter` 实现包含了所有必需的元素。
- en: Testing our current implementation
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试当前实现
- en: 'There is no functional code yet, but let''s test what happens when we try to
    run the project at this stage. When you go to **Run** | **Run Project** from the
    menu, you will get a dialog that asks for the `main` class to be run. Since we
    did not specify a `main` method (yet), we cannot proceed and can only select cancel.
    We need to do two things: first, we need to add a `main` method to our source
    code file, and secondly, we need to tell Maven which class contains the `main`
    method. We will start with the first item on the list.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有功能性代码，但让我们测试一下在这个阶段尝试运行项目会发生什么。当你从菜单中选择 **运行** | **运行项目** 时，你会得到一个对话框，要求选择要运行的
    `main` 类。由于我们尚未指定 `main` 方法（尚无），我们无法继续，只能选择取消。我们需要做两件事：首先，我们需要在我们的源代码文件中添加一个 `main`
    方法，其次，我们需要告诉 Maven 哪个类包含 `main` 方法。我们将从列表中的第一项开始。
- en: 'To add the `main()` method, we add the following code somewhere within the
    body of our class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 `main()` 方法，我们在类的主体中某个位置添加以下代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a standard Java style declaration of a `main` method that takes a `String`
    list of parameters stored in the `args` variable. The triple dots behind the `String`
    type indicate that this method can be called with a variable number of `String`
    arguments ranging from none to many. This type of calling structure can be helpful
    if you want to run your plugin via a **Command Line Interface** (**CLI**). Since
    we will mostly ignore the input parameters for now, it is not important to use
    them within the body of the `main` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的Java风格的主方法声明，该方法接受存储在`args`变量中的`String`类型参数列表。`String`类型后面的三个点表示该方法可以通过可变数量的`String`参数调用，参数数量从零到多个。如果你希望通过**命令行界面**（**CLI**）运行你的插件，这种调用结构可能很有帮助。由于我们现在将主要忽略输入参数，所以在`main`方法体内使用它们并不重要。
- en: 'For the second step, we can modify our project in two separate ways. We can
    type the `<main-class>` tag in the `<properties>` tag in the POM file (see [Chapter
    7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"), *Explanation of ImageJ
    Constructs*), or we can use the features of the IDE. To edit how the project is
    run, you can right-click on the project in the **Projects** view and select **Properties**
    from the context menu. This will open the properties available for this type of
    project. Select the **Run** category from the left-hand side of the properties
    dialog:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二步，我们可以以两种不同的方式修改我们的项目。我们可以在POM文件中的`<properties>`标签内输入`<main-class>`标签（见[第7章](ch07.html
    "第7章。ImageJ构造解释")，*ImageJ构造解释*），或者我们可以使用IDE的功能。要编辑项目的运行方式，你可以在**项目**视图中右键单击项目，并从上下文菜单中选择**属性**。这将打开适用于此类项目的属性。从属性对话框的左侧选择**运行**类别：
- en: '![Testing our current implementation](img/B04909_09_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的当前实现](img/B04909_09_02.jpg)'
- en: 'You can now see that there is an option to set the **Main Class**. By pressing
    the **Browse…** button, you are able to select the `Object_Tracker` class that
    contains our `main` method. You may also notice that you can specify **Arguments**
    to your `main` method. The content of this field will be used as input parameters
    to your main method''s argument `args`. One option we might also want to enter
    at a later stage is the **VM Options** field. This option will allow us to control
    the amount of memory that is allocated to the application. For now, only select
    the `Object_Tracker` as the **Main Class**. This will generate two new files in
    NetBeans where the run configuration is stored: `nbactions.xml` and `nb-configuration.xml`.
    Alternatively, you can add the sections to the `pom.xml` file, as described in
    [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"), *Explanation
    of ImageJ Constructs*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到有一个选项可以设置**主类**。通过按下**浏览…**按钮，你可以选择包含我们的`main`方法的`Object_Tracker`类。你可能还会注意到，你可以指定`main`方法的**参数**。此字段的内容将用作主方法参数`args`的输入参数。我们可能在稍后阶段也想输入的另一个选项是**VM选项**字段。此选项将允许我们控制分配给应用程序的内存量。现在，只选择`Object_Tracker`作为**主类**。这将生成两个新的文件在NetBeans中，其中包含运行配置：`nbactions.xml`和`nb-configuration.xml`。或者，你可以按照[第7章](ch07.html
    "第7章。ImageJ构造解释")，*ImageJ构造解释*中所述，将这些部分添加到`pom.xml`文件中。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that using the **Properties** method, you will limit your application
    to the NetBeans framework. If you wish to exchange your code with others that
    do not use NetBeans, you always want to choose the pure Maven approach and define
    your `main` class in the `pom.xml` file directly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用**属性**方法，你将限制你的应用程序使用NetBeans框架。如果你希望与不使用NetBeans的其他人交换代码，你始终应该选择纯Maven方法，并在`pom.xml`文件中直接定义你的`main`类。
- en: 'If you try to run the project now by navigating to **Run** | **Run Project**,
    you will get no errors and the building will be successful. The only problem is
    that nothing happens; we don''t see ImageJ, and our plugin cannot be found. We
    still need to implement our main method to make sure that ImageJ is launched.
    To do this, we add a new instance of ImageJ to our `main` method, and save the
    source file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试通过导航到**运行** | **运行项目**来运行项目，你将不会得到任何错误，构建也将成功。唯一的问题是没有任何事情发生；我们没有看到ImageJ，我们的插件也无法找到。我们仍然需要实现我们的主方法以确保ImageJ被启动。为此，我们在`main`方法中添加一个新的ImageJ实例，并保存源文件：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After fixing the error by adding the import for `ij.ImageJ`, we run our project
    and we will see the ImageJ interface. If you go to **Help** | **About ImageJ**,
    you will see that the version is indeed set to **1.50b**. However, when we look
    in the **Plugins** menu, we will not find our plugin there. We will use the same
    trick as shown in [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"),
    *Explanation of ImageJ Constructs* to fix our plugins directory mix-up by adding
    the following code to our `main` method before calling `new ImageJ()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`ij.ImageJ`的导入来修复错误后，我们运行项目，将看到ImageJ界面。如果你去**帮助** | **关于ImageJ**，你会看到版本确实设置为**1.50b**。然而，当我们查看**插件**菜单时，我们不会在那里找到我们的插件。我们将使用[第7章](ch07.html
    "第7章。ImageJ构造解释")中展示的相同技巧，即*ImageJ构造解释*，通过在调用`new ImageJ()`之前向我们的`main`方法中添加以下代码来修复我们的插件目录混乱：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After saving the source file and running the project, we will now see our plugin
    in the **Plugins** menu. When you launch the plugin you will get an error specifying
    that this method is not implemented yet. This is caused by the fact that the body
    of the abstract `setup` and `run` methods only contain an exception that is being
    thrown (this depends on your installation of NetBeans and your templates). We
    have the plugin framework completed, and next, we will implement our functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保存源文件并运行项目后，我们现在将在**插件**菜单中看到我们的插件。当你启动插件时，你会得到一个错误，指出这个方法尚未实现。这是由于抽象的`setup`和`run`方法体中只包含一个被抛出的异常（这取决于你的NetBeans安装和模板）。我们已经完成了插件框架，接下来，我们将实现我们的功能。
- en: Implementing the setup method
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现setup方法
- en: 'We will start with implementing the `setup` method, which serves as a basic
    checkpoint to see if our plugin can process the currently active image. We can
    also use this method to make some preparations and perform some basic checks before
    we run our plugin. We will start with clearing the current statement from the
    body of the `setup` method and add a return value. The `setup` method requires
    that an integer value be returned, which tells ImageJ the type of image that can
    be processed using this plugin. We will also add some Javadoc comments to this
    function to explain what is going on in this function. For this project, I will
    assume that the following structure is the structure of the source code file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现`setup`方法，这个方法作为一个基本的检查点，用来查看我们的插件是否能够处理当前活动的图像。我们也可以使用这个方法来进行一些准备工作，并在运行插件之前进行一些基本的检查。我们将从清除`setup`方法体中的当前语句开始，并添加一个返回值。`setup`方法要求返回一个整数值，这个值告诉ImageJ可以使用这个插件处理哪种类型的图像。我们还将为此函数添加一些Javadoc注释来解释这个函数中正在发生的事情。对于这个项目，我将假设以下结构是源代码文件的结构：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You are of course free to deviate from this template (within the bounds of Java
    syntax and programming logic). This type of structure is common to Java files,
    and it contains some elements that are not strictly required, but which can be
    useful. The constructor is not required to be present in an ImageJ plugin. However,
    it can be useful to add it, as it allows an increase in usability when you want
    to call your plugin from within other projects. Using the constructor, you can
    implement certain initializations or assert control over how the plugin is created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以偏离这个模板（在Java语法和编程逻辑的范围内）。这种结构在Java文件中很常见，它包含一些不是严格必需但可能有用的元素。构造函数不是必需存在于ImageJ插件中。然而，添加它可能是有用的，因为它允许在你想在其他项目中调用你的插件时提高可用性。使用构造函数，你可以实现某些初始化或控制插件创建的方式。
- en: The return type and autocomplete
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型和自动完成
- en: 'We will start with adding the return statement specifying the type of images
    that we expect to process. For this project, we are interested in quantifying
    objects over time in a single channel (for now), so we will expect to process
    stacks of either 8 or 16-bit. Therefore, we add the following return statement:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个返回语句，指定我们期望处理的图像类型。对于这个项目，我们感兴趣的是在单个通道（目前）内随时间量化对象，因此我们期望处理8位或16位的堆栈。因此，我们添加以下返回语句：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When typing in an IDE, you can use its autocomplete functionality to determine
    which type you wish to return. If you type `DOES` and press *Ctrl* + Spacebar
    you will get a list of the possible autocomplete options. You can use the mouse
    or the arrow keys to select an option from the list, and by double-clicking it
    or pressing enter, it will be inserted at the point you were typing. If the list
    of options is very long, you can also continue typing after you have pressed *Ctrl*
    + Spacebar. For every character that you add, the list will become more selective
    to match what you are typing. For example, when you type `_1` after you typed
    `DOES`, you will only get the single option `DOES_16`. Another nice feature is
    that when you select an option from the autocomplete list, it will also show the
    Javadoc for that selection. However, you may have noticed that this didn't work
    here; the IDE stated that the Javadoc was not found. We will remedy this in the
    next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDE 中输入时，你可以使用它的自动完成功能来确定你希望返回的类型。如果你输入 `DOES` 并按 *Ctrl* + 空格键，你将得到一个可能的自动完成选项列表。你可以使用鼠标或箭头键从列表中选择一个选项，并通过双击它或按
    enter 键将其插入到你输入的位置。如果选项列表非常长，你还可以在按 *Ctrl* + 空格键后继续输入。对于你添加的每个字符，列表将变得更加具有选择性，以匹配你输入的内容。例如，当你输入
    `_1` 在你输入 `DOES` 之后，你将只得到单个选项 `DOES_16`。另一个很好的功能是，当你从自动完成列表中选择一个选项时，它也会显示该选择的
    Javadoc。然而，你可能已经注意到这在这里不起作用；IDE 表示未找到 Javadoc。我们将在下一节中解决这个问题。
- en: Javadoc for methods
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法 Javadoc
- en: As we saw, the Javadoc for our ImageJ project was not found. We will now fix
    this using the IDE, which only takes a few simple steps. First, we make sure that
    our Javadoc view is open by activating it. Go to **Window** | **IDE Tools** |
    **Javadoc Documentation** from the menu to activate the view. When we place our
    cursor on an object such as the `DOES_16` statement that we entered above, the
    Javadoc view will display the same message that we noticed in the autocomplete
    window. However, it also displays an option at the bottom called **Attach Javadoc…**
    in the form of a link. When you click on it, a window will ask you for the location
    of the documentation. There is also a button called **Download**, which will automatically
    download the Javadoc for the ImageJ version that we listed as a dependency in
    our project. After clicking OK, you will now see that the Javadoc view shows the
    documentation for the `DOES_16` field. You can also generate the Javadoc for your
    project by right-clicking on your project in the Projects view and selecting **Generate
    Javadoc** from the context menu.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们的 ImageJ 项目的 Javadoc 未找到。我们现在将使用 IDE 修复此问题，这只需要几个简单的步骤。首先，我们确保我们的 Javadoc
    视图已打开，通过激活它。从菜单中选择 **窗口** | **IDE 工具** | **Javadoc 文档** 来激活视图。当我们把光标放在我们上面输入的
    `DOES_16` 语句等对象上时，Javadoc 视图将显示我们在自动完成窗口中注意到的相同信息。然而，它还在底部显示一个名为 **附加 Javadoc…**
    的链接形式的选项。当你点击它时，一个窗口会要求你提供文档的位置。还有一个名为 **下载** 的按钮，它将自动下载我们项目中列为依赖项的 ImageJ 版本的
    Javadoc。点击确定后，你现在会看到 Javadoc 视图显示了 `DOES_16` 字段的文档。你还可以通过在项目视图中右键单击你的项目并从上下文菜单中选择
    **生成 Javadoc** 来为你的项目生成 Javadoc。
- en: We will now create our own Javadoc comments for our setup method. The easiest
    way to do this using the IDE is to place the cursor on the setup method and press
    *Alt* + *Enter*. An option will be displayed stating **Create missing Javadoc
    for setup**, which we will choose.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为我们的设置方法创建自己的 Javadoc 注释。使用 IDE 的最简单方法是，将光标放在设置方法上，然后按 *Alt* + *Enter*。将显示一个选项，表明
    **为设置创建缺失的 Javadoc**，我们将选择此选项。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also place your cursor above the method you wish to document, and type
    `/**`, and press *Enter*. In NetBeans, typing the start of a Javadoc comment and
    pressing *Enter* will autocomplete the Javadoc comment, and it will add the arguments
    and return type of your method as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将光标放在你想要文档化的方法上方，并输入 `/**`，然后按 *Enter*。在 NetBeans 中，输入 Javadoc 注释的开始并按 *Enter*
    将自动完成 Javadoc 注释，并且它还会添加你方法的参数和返回类型。
- en: 'After selecting this option, a Javadoc comment is added above the setup method
    containing the following information:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项后，将在设置方法上方添加一个 Javadoc 注释，包含以下信息：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the standard content for a Javadoc section that describes a method
    with input parameters and a return value. Parameters are designated as `@param`
    followed by the variable name. There is one `@param` line for each parameter in
    the methods arguments list. To add information about the parameter, you can start
    typing right after the variable name (make sure that there is a space between
    the variable name and your description). The first line above the parameter list
    is meant to provide a brief description of the methods purpose. Let''s add some
    of the information about the `setup` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是描述具有输入参数和返回值的方法的Javadoc部分的常规内容。参数被指定为`@param`后跟变量名。方法参数列表中的每个参数都有一个`@param`行。要添加有关参数的信息，你可以在变量名后开始输入（确保变量名和你的描述之间有一个空格）。参数列表上方的第一行旨在提供方法目的的简要描述。让我们添加一些关于`setup`方法的信息：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you look at the Javadoc viewer now, you will see the text that you added
    is displayed and formatted. Please note that you can use standard HTML tags to
    format your text with paragraphs, headings, tables, and lists. At this stage it
    is possible to generate the Javadoc for your plugin and view it in a browser.
    To do so, right-click on your project in the **Projects** view and select **Generate
    Javadoc** from the context menu. After waiting a bit while the IDE is busy scanning
    the project and building the documentation, you can open the Javadoc in a browser
    by opening the `index.html` file from the `target/site/apidocs/` folder in the
    root of your project. Alternatively, you can click on the link in the **Output**
    view which can be activated by navigating to **Window** | **Output** from the
    menu. The result will be as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在查看Javadoc查看器时，你会看到你添加的文本被显示和格式化。请注意，你可以使用标准的HTML标签来格式化你的文本，包括段落、标题、表格和列表。在这个阶段，你可以生成你插件的Javadoc并在浏览器中查看。要做到这一点，在**项目**视图中右键单击你的项目，并从上下文菜单中选择**生成Javadoc**。在IDE忙于扫描项目和构建文档的等待片刻后，你可以通过从项目根目录下的`target/site/apidocs/`文件夹打开`index.html`文件来在浏览器中打开Javadoc。或者，你也可以点击**输出**视图中的链接，该链接可以通过从菜单导航到**窗口**
    | **输出**来激活。结果如下：
- en: '![Javadoc for methods](img/B04909_09_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![方法Javadoc](img/B04909_09_03.jpg)'
- en: In the preceding screenshot, you can see the setup method with the text that
    we added as a description, and at the bottom, we see the details we entered for
    the parameters and the return value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到我们添加的文本作为描述的`setup`方法，底部我们看到的是我们输入的参数和返回值的详细信息。
- en: It is good practice to add this information as you develop your source code,
    both for your own benefit when you review your code weeks from now, as well as
    for other developers who may wish to use or expand your code for their own projects.
    As the Javadoc tool takes care of all the processing and layout of the documentation,
    you only need to add the descriptions for the methods and classes. I will not
    explicitly add the documentation sections in the code snippets in this chapter,
    but they will be part of the final source code. After this small digression, we
    will return to creating a plugin to detect objects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发源代码时添加此类信息是一种良好的做法，这不仅有助于你在几周后回顾自己的代码，也有助于其他可能希望在自己的项目中使用或扩展你的代码的开发者。由于Javadoc工具负责处理和布局文档，你只需要添加方法和类的描述。我不会在本书的代码片段中明确添加文档部分，但它们将是最终源代码的一部分。在这次短暂的偏离之后，我们将返回到创建检测对象的插件。
- en: Finishing the setup method
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成设置方法
- en: After completing the previous sections, we now have a `setup` method with a
    return value indicating that we will be processing all 8 or 16-bit images and
    stacks. We will now perform a few more checks that will be required for the processing
    to complete. The first step is to make sure that the ROI Manager is open so that
    we can see the detections and the results of our detection. At this stage, it
    might also be a good idea to think about the type of images we may want to process.
    Do we want to process RGB or multichannel images and stacks or only single channel
    stacks?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前几节内容后，我们现在有一个带有返回值的`setup`方法，表示我们将处理所有8位或16位图像和图像堆栈。现在我们将执行一些必要的检查，以确保处理完成。第一步是确保ROI管理器已打开，这样我们才能看到检测结果和我们的检测结果。在这个阶段，考虑我们可能想要处理的图像类型可能也是一个好主意。我们是要处理RGB或多通道图像和图像堆栈，还是只处理单通道图像堆栈？
- en: 'We will start with checking if the ROI Manager is available. To do this, we
    can use the `getInstance()` method from the `RoiManager` class. This method will
    return a value of `null` when it is not open yet; otherwise, it will return the
    reference of the ROI Manager instance. Add the following to the `setup` method
    before the return statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从检查 ROI 管理器是否可用开始。为此，我们可以使用 `RoiManager` 类中的 `getInstance()` 方法。当它尚未打开时，此方法将返回
    `null` 值；否则，它将返回 ROI 管理器实例的引用。在返回语句之前，将以下内容添加到 `setup` 方法中：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you used the autocomplete option to select the `RoiManager` class, NetBeans
    also automatically added the required import statement at the top of your source
    code file. If you copied and pasted the code, you will need to add the import
    statement yourself using either the *Alt* + *Enter* option or by typing it manually.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了自动完成选项来选择 `RoiManager` 类，NetBeans 也会自动在你的源代码文件顶部添加所需的导入语句。如果你复制并粘贴了代码，你需要自己使用
    *Alt* + *Enter* 选项或手动输入来添加导入语句。
- en: 'The only thing left to do in the setup is to check the image type; it needs
    to be a single channel image with a single frame or slice, or multiple frames
    and a single slice. The first step is to obtain the dimensions of the current
    image and then check whether it matches our specifications. For the current incarnation
    of the plugin, I will make these specifications binding so that when it fails,
    the plugin will not run. The code for retrieving the dimensions and checking whether
    they match our specifications is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置过程中，剩下要做的就是检查图像类型；它需要是单通道图像，包含单个帧或切片，或者多个帧和单个切片。第一步是获取当前图像的尺寸，然后检查它是否符合我们的规格。对于当前版本的插件，我将使这些规格具有约束力，这样当它失败时，插件将不会运行。检索尺寸并检查它们是否符合我们规格的代码如下：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `getDimensions()` method returns a vector of length `5`, with the width,
    height, channels, slices, and frames (in that order).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDimensions()` 方法返回一个长度为 `5` 的向量，包含宽度、高度、通道、切片和帧（按此顺序）。'
- en: At this stage, I would like to introduce another useful feature of an IDE that
    will make your coding life much easier. When the IDE added the abstract methods
    for setup and run, it used the `ip` parameter name for both the `ImagePlus` type
    in the `setup` method and the `ImageProcessor` type in the `run` method. This
    is slightly confusing and inconsistent. The convention for `ImagePlus` objects
    is to use `imp` as a reference name, and `ip` for `ImageProcessor` references.
    We will now use the **Refactor** option in the IDE to fix this problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我想介绍 IDE 的另一个有用功能，这将使你的编码生活变得更加容易。当 IDE 添加设置和运行时的抽象方法时，它为 `setup` 方法中的
    `ImagePlus` 类型以及 `run` 方法中的 `ImageProcessor` 类型都使用了 `ip` 参数名称。这有点令人困惑且不一致。`ImagePlus`
    对象的惯例是使用 `imp` 作为引用名称，而 `ip` 用于 `ImageProcessor` 引用。我们现在将使用 IDE 中的 **重构** 选项来解决这个问题。
- en: We will start by selecting the parameter that we would like to change; in this
    case, the `ip` parameter in the `setup` method. We then go to **Refactor** | **Rename**
    from the context menu or press *Ctrl* + *R*. You will now see that there is a
    red box around the parameter, and you can change the name by typing a new name.
    When you now type `imp`, you will see that only the names associated with the
    `setup` method are changed. This does not affect the parameter of the `run` method.
    Also, the Javadoc section is updated to reflect the new variable name. This is
    a great feature to use when changing the name of a variable, and it is much more
    effective than a search-and-replace style approach. If you would have used search
    and replace, the variable name in the run method may have also been changed, making
    it inconsistent again.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择我们想要更改的参数；在这种情况下，`setup` 方法中的 `ip` 参数。然后我们转到上下文菜单中的 **重构** | **重命名** 或按
    *Ctrl* + *R*。现在你会看到参数周围有一个红色框，你可以通过输入新名称来更改名称。当你现在输入 `imp` 时，你会看到只有与 `setup` 方法相关的名称被更改。这不会影响
    `run` 方法的参数。此外，Javadoc 部分也更新以反映新的变量名称。这是一个在更改变量名称时非常有用的功能，它比搜索和替换风格的方法更有效。如果你使用了搜索和替换，`run`
    方法中的变量名称也可能被更改，使其再次不一致。
- en: 'If we now run our project, we should see the plugin in the **Plugins** menu,
    but when we launch it, we will receive a `NullPointerException` exception. This
    is caused by the fact that we tried to retrieve the dimensions from a nonexistent
    image. So, we need to add a final check before we call the `getDimensions()` method
    to check if the `imp` parameter is not equal to `null`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的项目，我们应该在**插件**菜单中看到插件，但当我们启动它时，我们将收到一个`NullPointerException`异常。这是由于我们试图从一个不存在的图像中检索尺寸。因此，我们在调用`getDimensions()`方法之前需要添加一个最后的检查，以检查`imp`参数是否不等于`null`：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will make sure that nothing happens when you have no image open or the
    wrong kind of image compared to what the plugin expects. It is currently not very
    user-friendly. When the user activates a plugin, he or she would expect something
    to happen. It would be nice if there were some feedback to indicate why nothing
    happened. As an example, I will add a message stating that the plugin requires
    a stack to be opened before exiting. To do so, we add the following statement
    to the body of the statement checking for the image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在没有打开图像或与插件期望的图像类型不正确时不会发生任何操作。目前这并不非常用户友好。当用户激活插件时，他们期望发生某些操作。如果有一些反馈来指示为什么没有发生任何操作，那将很好。例如，我将添加一条消息，说明插件在退出之前需要打开一个栈。为此，我们在检查图像的主体中添加以下语句：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now when you run your project and launch the plugin, the following message
    will be displayed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行你的项目并启动插件时，将显示以下消息：
- en: '![Finishing the setup method](img/B04909_09_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![完成setup方法](img/B04909_09_04.jpg)'
- en: This is much more user-friendly and avoids generating unnecessary errors, which
    can be confusing to users. Most of the errors and exceptions generated by compilers
    are cryptic at best, and most non-programmers will not understand what went wrong.
    Now that we have finished the setup method, we will now focus on implementing
    the actual functional code that will perform the processing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得操作更加用户友好，并避免了生成不必要的错误，这些错误可能会使用户感到困惑。编译器生成的错误和异常最多是晦涩难懂的，大多数非程序员都不会明白出了什么问题。现在我们已经完成了setup方法的设置，我们将现在专注于实现实际的功能代码，该代码将执行处理。
- en: Implementing the run method
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现run方法
- en: As mentioned in [Chapter 8](ch08.html "Chapter 8. Anatomy of ImageJ Plugins"),
    *Anatomy of ImageJ Plugins* the run method is the entry point for the `PlugInFilter`
    type. At this stage we know for sure that we have an 8 or 16-bit stack with a
    single channel; otherwise, we would have never reached the run method. We can
    now start implementing our algorithm to detect the object. After that, we will
    look at the required methods to measure the object in the current frame, and finally,
    how to process each object across frames in the case of multiple objects. We will
    start with the detection first, as this is the primary step that needs to be solved.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第8章](ch08.html "第8章。ImageJ插件的解剖结构")《ImageJ插件的解剖结构》中所述，run方法是`PlugInFilter`类型的入口点。在这个阶段，我们肯定有一个8位或16位的单通道栈；否则，我们永远不会达到run方法。现在我们可以开始实现我们的算法来检测对象。之后，我们将查看测量当前帧中对象的所需方法，最后，在存在多个对象的情况下，我们将探讨如何处理每一帧中的每个对象。我们将首先从检测开始，因为这是需要解决的主要步骤。
- en: Detecting an object
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测对象
- en: To be able to detect an object, we need to know about some of the properties
    that make the object identifiable. This may sound simpler than it really is. The
    human visual system is highly capable of finding objects in all types of lighting
    conditions and situations. Computer algorithms are only starting to approach the
    same levels of detection that feel natural to humans. For this example, I will
    limit the detection of objects based on the intensity of the object relative to
    the background. I'm going to assume that the object we wish to detect is bright
    compared to the darker background, as is the case in fluorescence imaging for
    example. We will use the **Confocal Series** sample image to practice with as
    an example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够检测对象，我们需要了解一些使对象可识别的属性。这听起来可能比实际情况简单。人类的视觉系统在所有类型的照明条件和情况下都能高度有效地找到对象。计算机算法才刚刚开始接近人类感觉自然的那种检测水平。在这个例子中，我将基于对象相对于背景的强度来限制对象的检测。我将假设我们希望检测的对象相对于较暗的背景是明亮的，例如在荧光成像的情况下。我们将使用**Confocal
    Series**样本图像作为练习的例子。
- en: 'We need to make a few small preparations before we can start using this image.
    The image contains two channels, which is an exclusion criterion for our plugin!
    So we split the image into separate channels, and convert one of them to 16-bit
    before saving them both to disk as TIFF files. Using the knowledge from [Chapter
    2](ch02.html "Chapter 2. Basic Image Processing with ImageJ"), *Basic Image Processing
    with ImageJ* and [Chapter 3](ch03.html "Chapter 3. Advanced Image Processing with
    ImageJ"), *Advanced Image Processing with ImageJ* you should be capable of performing
    these steps. We will use a threshold to detect the object based on the intensity,
    and based on that threshold, create a selection that will be added to the ROI
    manager. For the detection, we will create a method called `performDetection()`
    that will be called from the `run` method. As we assume a stack, we will also
    need to add a loop to go over each of the slices. We will start with the loop
    statement in the `run` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用这张图片之前，需要做一些小准备。这张图片包含两个通道，这是我们的插件的一个排除标准！因此，我们将图片分割成单独的通道，并在保存到磁盘作为TIFF文件之前，将其中一个通道转换为16位。通过使用[第2章](ch02.html
    "第2章。使用ImageJ的基本图像处理")，*使用ImageJ的基本图像处理*和[第3章](ch03.html "第3章。使用ImageJ的高级图像处理")，*使用ImageJ的高级图像处理*的知识，你应该能够执行这些步骤。我们将使用阈值来根据强度检测对象，并基于这个阈值创建一个将被添加到ROI管理器的选择。对于检测，我们将创建一个名为`performDetection()`的方法，它将从`run`方法中被调用。由于我们假设一个堆栈，我们还需要添加一个循环来遍历每个切片。我们将在`run`方法中从循环语句开始：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice the slightly odd behavior for the `setSlice` method. Unlike arrays and
    other indexed objects in Java, the slice indices for an image are not zero-based.
    This idiosyncrasy was observed back in [Chapter 2](ch02.html "Chapter 2. Basic
    Image Processing with ImageJ"), *Basic Image Processing with ImageJ*. Next, we
    create the method to perform the detection, and we add the following statements:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`setSlice`方法的略微异常行为。与Java中的数组和其他索引对象不同，图像的切片索引不是基于零的。这种古怪的行为在[第2章](ch02.html
    "第2章。使用ImageJ的基本图像处理")，*使用ImageJ的基本图像处理*中已经观察到。接下来，我们创建执行检测的方法，并添加以下语句：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This sets an automatic threshold using the default method (first parameter)
    and using a dark background (second parameter). When using the autocomplete option,
    many of these values will be filled in by default making it easier to write code,
    but not necessarily to understand it. We then add the new threshold to the current
    image using a reference to a class-wide variable that we added to our class definition
    (see the template for the class file that was mentioned earlier).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用默认方法（第一个参数）和深色背景（第二个参数）设置自动阈值。当使用自动完成选项时，许多这些值将默认填充，这使得编写代码更容易，但并不一定有助于理解。然后我们使用对类定义中添加的类级别变量的引用将新的阈值添加到当前图像中（参见前面提到的类文件模板）。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This allows us access to the current image and the ROI Manager throughout our
    class. We also modify the setup method slightly to accommodate these changes using
    the `rm` reference to get the instance or store a new reference to the ROI Manager.
    We do the same for the class-wide `ImagePlus` variable (`this.imp`) by storing
    the current image that comes in with the `setup` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以在整个类中访问当前图像和ROI管理器。我们还稍微修改了`setup`方法，以适应这些变化，使用`rm`引用获取实例或存储对ROI管理器的新引用。我们同样为类级别的`ImagePlus`变量（`this.imp`）执行相同的操作，通过存储`setup`方法中传入的当前图像。
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To add our thresholded object to the ROI manager, we use the `ThresholdToSelection`
    class (another `PlugInFilter` type) that comes with ImageJ. This is the class
    that is activated when you navigate to **Edit** | **Selection** | **Create Selection**
    from the ImageJ menu. This is a nice example of one plugin calling the `run` method
    of another plugin. This means that we can also use the `run` method of our plugin
    in other plugins or macros.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的阈值对象添加到ROI管理器，我们使用ImageJ附带的一个名为`ThresholdToSelection`的类（另一种`PlugInFilter`类型）。这是当你从ImageJ菜单导航到**编辑**
    | **选择** | **创建选择**时被激活的类。这是一个很好的例子，说明一个插件调用了另一个插件的`run`方法。这意味着我们也可以在其他插件或宏中使用我们插件的`run`方法。
- en: We will now test our plugin by running the project and opening one of the images
    we saved, before launching our plugin. It should now run through all the slices
    of the stack and populate the ROI manager at every frame. The ROIs look quite
    good, but there are still a few small problems. There are holes in some of the
    ROIs, and some ROIs have small isolated pixels that are not connected to the main
    object. In the next section, we will examine ways to refine the detection using
    the techniques that we learned back in [Chapter 4](ch04.html "Chapter 4. Image
    Segmentation and Feature Extraction with ImageJ"), *Image Segmentation and Feature
    Extraction with ImageJ*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过运行项目并打开我们在启动插件之前保存的一张图像来测试我们的插件。它现在应该运行通过堆栈的所有切片，并在每一帧填充ROI管理器。ROI看起来相当不错，但仍然存在一些小问题。一些ROI中存在孔洞，有些ROI有与主要对象不相连的小孤立像素。在下一节中，我们将探讨使用我们在[第4章](ch04.html
    "第4章. 使用ImageJ进行图像分割和特征提取")学到的技术来细化检测的方法，即《使用ImageJ进行图像分割和特征提取》。
- en: Refining the detection
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精细化检测
- en: 'When we tested the plugin at the end of the previous section, we noted some
    shortcomings of the current detection method using only a threshold. We saw holes
    in the object and small isolated pixels that we would like to remove. This is
    something that can be achieved using binary processing as discussed in [Chapter
    4](ch04.html "Chapter 4. Image Segmentation and Feature Extraction with ImageJ"),
    *Image Segmentation and Feature Extraction with ImageJ*. We will now implement
    this processing before we convert the threshold to a selection. The first step
    is to take our ROI and use it to create a mask image, which we will process using
    the techniques that we learned in [Chapter 4](ch04.html "Chapter 4. Image Segmentation
    and Feature Extraction with ImageJ"), *Image Segmentation and Feature Extraction
    with ImageJ*. To create our mask image, we do the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的最后测试插件时，我们注意到了当前仅使用阈值进行检测的方法的一些不足。我们看到了物体中的孔洞和希望去除的小孤立像素。这是可以使用第4章中讨论的二值处理实现的事情，即《使用ImageJ进行图像分割和特征提取》。现在，在我们将阈值转换为选择之前，我们将实现这种处理。第一步是使用我们的ROI创建一个掩码图像，我们将使用我们在[第4章](ch04.html
    "第4章. 使用ImageJ进行图像分割和特征提取")学到的技术来处理这个掩码图像。为了创建我们的掩码图像，我们执行以下操作：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code is inserted between the `Roi roi...` statement and the `rm.addRoi(roi)`
    statement in the `performDetection` method. The first line creates a new image
    called mask with a `ByteProcessor` for the `ImageProcessor`; this results in an
    8-bit image. The width and the height are set to be equal to the original image.
    This is important when you want to measure the object in the original image. If
    you create a mask directly from the image, its size will be the size of the bounding
    rectangle of the ROI. Next we add the ROI to the new image, and get a reference
    to the `ImageProcessor` for this image. This will allow us to modify the pixels
    of the mask. Next, we set the foreground color to white `(255)` and fill the mask
    with white. Finally, we invert the LUT for the binary processing. Next, we will
    perform the binary processing. We want to fill the holes and get rid of the isolated
    pixels.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码插入到`performDetection`方法中的`Roi roi...`语句和`rm.addRoi(roi)`语句之间。第一行创建了一个名为mask的新图像，使用`ByteProcessor`作为`ImageProcessor`；这导致了一个8位图像。宽度和高度被设置为与原始图像相等。当你想要在原始图像中测量对象时，这是很重要的。如果你直接从图像创建掩码，其大小将是ROI的边界矩形的大小。接下来，我们将ROI添加到新图像中，并获取该图像的`ImageProcessor`引用。这将允许我们修改掩码的像素。接下来，我们将前景色设置为白色（255）并用白色填充掩码。最后，我们反转二值处理的LUT。接下来，我们将执行二值处理。我们想要填充形状中的孔洞并去除孤立像素。
- en: 'We will start with filling the holes in the shape using the `Binary` plugin.
    This is a class that implements a `PlugInFilter`; however, the use is a little
    different this time. We first need to create an instance of the class, and then
    set up the class for our purpose. We will add the following code directly underneath
    the last statement of the previous code listing:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Binary`插件开始填充形状中的孔洞。这是一个实现了`PlugInFilter`的类；然而，这次的使用略有不同。我们首先需要创建类的实例，然后设置类以适应我们的目的。我们将在上一段代码列表的最后一行下面直接添加以下代码：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we create a new instance of the `Binary` class and add the import statement
    for `ij.plugin.filter.Binary` at the top of our source code file. Next, we set
    up the plugin to perform the task that we want, in this case, filling the holes
    in our mask. We do this by calling the `setup` method with a `String` argument
    (`"fill"`) and an `ImagePlus` argument (our mask image). Our own plugin has a
    similar form for the setup; this means that we could also choose to implement
    a similar system later on. In the last step, we call the `run` method of the `Binary`
    plugin, which will perform the actual processing on our image.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`Binary`类的新实例，并在我们的源代码文件顶部添加`ij.plugin.filter.Binary`的导入语句。接下来，我们设置插件以执行我们想要的任务，在这种情况下，填充我们的掩模中的孔。我们通过调用带有`String`参数（`"fill"`）和`ImagePlus`参数（我们的掩模图像）的`setup`方法来完成此操作。我们的插件具有类似的设置形式；这意味着我们也可以选择稍后实现类似系统。在最后一步，我们调用`Binary`插件的`run`方法，它将在我们的图像上执行实际处理。
- en: 'Next, we will use the erode and dilate operators to get rid of isolated pixels.
    We will run the erode operator three times and the dilate operator five times
    to create a smooth mask:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用腐蚀和膨胀算子来去除孤立像素。我们将腐蚀算子运行三次，膨胀算子运行五次以创建平滑的掩模：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These values are quite arbitrary and other values might be more suitable when
    using different images. Finally, we set a threshold on our mask image to obtain
    a new ROI using the `ThresholdToSelection` method, just like we did before:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值相当随意，当使用不同的图像时，其他值可能更合适。最后，我们使用`ThresholdToSelection`方法在我们的掩模图像上设置一个阈值，以获得一个新的ROI，就像我们之前做的那样：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We use the `roi` variable again because we don't need the ROI that we created
    in the original image. We then add the new ROI to the ROI Manager, which is the
    last step for our detection. If you run the project and try it on the test images,
    you will see the effect of the binary processing—the ROIs are a bit more smooth
    and contain almost no isolated pixels anymore. The following image shows all the
    ROIs overlaid on the first frame of the original stack. I used the green channel
    for this example, but you can also try to run the plugin on the red channel.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`roi`变量，因为我们不需要在原始图像中创建的ROI。然后我们将新的ROI添加到ROI Manager中，这是我们的检测的最后一步。如果你运行项目并在测试图像上尝试，你会看到二值处理的效应——ROI变得更加平滑，几乎不再包含孤立像素。以下图像显示了所有ROI叠加在原始堆栈的第一帧上。我使用了绿色通道作为这个例子，但你也可以尝试在红色通道上运行插件。
- en: '![Refining the detection](img/B04909_09_05.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![精炼检测](img/B04909_09_05.jpg)'
- en: Detecting multiple objects
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测多个对象
- en: Up to this point, we assumed that we have only a single object in our frames.
    I will now look at a method that allows detecting multiple objects. To do this,
    we will use another technique that we learned in [Chapter 3](ch03.html "Chapter 3. Advanced
    Image Processing with ImageJ"), *Advanced Image Processing with ImageJ*. There,
    we looked at Z-projections and how they can be used to flatten a stack into a
    single image. We will now use this same technique to define our search space to
    detect the objects in the time series. By creating a maximum intensity projection,
    we can visualize all the pixels that our object will occupy at one time or another
    during the time series. This projection will help us define the search space.
    For *N* number of objects that do not overlap, you will get *N* search spaces.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设我们的帧中只有一个对象。现在我将研究一种允许检测多个对象的方法。为此，我们将使用我们在[第3章](ch03.html "第3章。使用ImageJ的高级图像处理")中学习的技术，即《使用ImageJ的高级图像处理》。在那里，我们研究了Z投影以及它们如何将堆栈展平成单个图像。现在我们将使用同样的技术来定义我们的搜索空间以检测时间序列中的对象。通过创建最大强度投影，我们可以可视化对象在时间序列中某个时刻或某个时刻之后将占据的所有像素。这个投影将帮助我们定义搜索空间。对于不重叠的*N*个对象，你会得到*N*个搜索空间。
- en: 'To start with, we need to create the maximum intensity projection. To do this,
    we can use the `ZProjector` class and set it to maximum intensity using `MAX_METHOD`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建最大强度投影。为此，我们可以使用`ZProjector`类，并使用`MAX_METHOD`将其设置为最大强度：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We start by creating a new `ZProjector` instance using the original stack as
    an input. Next, we set the method to be used, and perform the projection. Finally,
    we retrieve the maximum intensity projection image using the `getProjection()`
    method. Next up, we will use the `ParticleAnalyzer` class to detect the objects
    in our maximum intensity projection that will define our search spaces.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用原始栈作为输入创建一个新的`ZProjector`实例。接下来，我们设置要使用的方法，并执行投影。最后，我们使用`getProjection()`方法检索最大强度投影图像。接下来，我们将使用`ParticleAnalyzer`类来检测我们最大强度投影中的对象，这些对象将定义我们的搜索空间。
- en: 'To use the particle analyzer, we create an instance of the class and set its
    parameters to determine the search spaces. For this example, we want to find objects
    that are relatively large, so we will set a minimum size limit for the particles
    but not for the shape. To do this, we can use the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用粒子分析器，我们创建该类的实例并设置其参数以确定搜索空间。在这个例子中，我们想要找到相对较大的对象，所以我们将为粒子设置最小尺寸限制，但不为形状设置限制。为此，我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We start by setting the options and the measurements that we want. In this case,
    we only care about the found objects' location, so we need ROIs at the end of
    the detection (indicated by the `ADD_TO_MANAGER` option). The option for measurements
    is set to none to avoid generating results or other objects (indicated by `SHOW_NONE`).
    We then initialize the particle analyzer using the options and sizes that we specified.
    Next, we create an instance of an ROI Manager that will not be displayed. This
    instance of our ROI Manager will be assigned to our particle analyzer before we
    analyze our image using the `analyze()` method. This is necessary because we don't
    want to measure these intermediate ROIs, we only use them to identify and process
    each search space. In the last step, we extract the search spaces as ROI objects
    from our temporary ROI Manager instance. With our search spaces defined, we can
    start the detections for each search space individually.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置选项和我们要进行的测量。在这种情况下，我们只关心找到的对象的位置，因此我们需要在检测结束时设置ROI（由`ADD_TO_MANAGER`选项指示）。测量选项设置为无，以避免生成结果或其他对象（由`SHOW_NONE`指示）。然后我们使用指定的选项和大小初始化粒子分析器。接下来，我们创建一个ROI
    Manager的实例，这个实例将不会显示。在我们使用`analyze()`方法分析图像之前，这个ROI Manager的实例将被分配给我们的粒子分析器。这是必要的，因为我们不想测量这些中间ROI，我们只使用它们来识别和处理每个搜索空间。在最后一步，我们从临时的ROI
    Manager实例中提取搜索空间作为ROI对象。定义了搜索空间后，我们可以开始对每个搜索空间进行单独的检测。
- en: 'The detections can be created in a similar way as we saw before with a small
    alteration: instead of using the entire image, we want to perform our detection
    within the search space for the individual object. We can achieve this by setting
    the search space ROI on our image and duplicate it using the `duplicate()` method.
    We then have access to the pixels from this cropped region:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 检测可以通过与之前类似的方式创建，但有一些小的改动：我们不是使用整个图像，而是希望在单个对象的搜索空间内进行检测。我们可以通过在图像上设置搜索空间ROI并使用`duplicate()`方法进行复制来实现这一点。然后我们可以访问这个裁剪区域的像素：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We do this for each of our search spaces using the for-each syntax, and perform
    the detection as before. There are some other alterations that are required to
    make this work, so take a look at the complete code listed in the code bundle
    at Packt Publishing's website.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用for-each语法对每个搜索空间都这样做，并像之前一样进行检测。还有一些其他的改动是必须的，所以请查看Packt Publishing网站上列出的完整代码。
- en: Implementing the measurements
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施测量
- en: 'Now that we have our objects identified for each slice, we can start to look
    at measuring our object. We will use some of the knowledge from [Chapter 5](ch05.html
    "Chapter 5. Basic Measurements with ImageJ"), *Basic Measurements with ImageJ*
    to design a measurement for this object. Depending on the type of object, we may
    want to look at different measurements that may be important, but I will start
    with some of the obvious ones for the type of ROIs that we created. Our ROIs are
    area selections, so the first metric that seems relevant is the area of the object(s).
    Other relevant measurements are the mean intensity and the shape of the object(s).
    We will implement the measurements in a separate method that we will add to our
    class. The method will have the following declaration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为每个切片确定了对象，我们可以开始测量我们的对象了。我们将使用[第5章](ch05.html "第5章。使用ImageJ进行基本测量")中的一些知识，即*使用ImageJ进行基本测量*，来设计针对该对象的测量方法。根据对象类型，我们可能需要考虑不同的可能重要的测量，但我将首先从我们创建的ROI类型的一些明显指标开始。我们的ROI是面积选择，因此第一个似乎相关的指标是对象（们）的面积。其他相关的测量包括对象（们）的平均强度和形状。我们将在类中添加一个单独的方法来实现这些测量。该方法将具有以下声明：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will be using the ROIs in the ROI Manager so that we don''t require an input
    argument. We will set the measurements according to the values that we discussed
    before by adding a variable called `msrmnt` at the beginning of our class declaration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ROI管理器中的ROI，这样我们就不需要输入参数。我们将通过在类声明开头添加一个名为`msrmnt`的变量来设置测量值，这些值是我们之前讨论过的：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is used to set the measurements to the slice number, area, circularity,
    and mean. We use the `Analyzer` class and its `setMeasurements` method to get
    the desired results. Finally, we call the `unlock` method on our image to allow
    the macro command of the ROI Manager to gain access to our image for the measurements.
    If you omit this statement, the plugin will run without visible errors, but you
    will not get any results. To get the results, we call our measurement method directly
    after the loop has finished. In the next section, we will add some user interaction
    to our plugin, allowing us to change some of the parameters that are used in the
    detection. We will also introduce the preferences system of ImageJ to allow the
    storage of our parameters for future use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于将测量值设置为切片号、面积、圆形度和平均值。我们使用`Analyzer`类及其`setMeasurements`方法来获取所需的结果。最后，我们在图像上调用`unlock`方法，以便ROI管理器的宏命令能够访问我们的图像进行测量。如果您省略此语句，插件将无错误地运行，但您将不会得到任何结果。要获取结果，我们将在循环结束后直接调用我们的测量方法。在下一节中，我们将向我们的插件添加一些用户交互，允许我们更改检测中使用的某些参数。我们还将介绍ImageJ的偏好设置系统，以便存储我们的参数以供将来使用。
- en: Adding user interaction and preferences
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户交互和偏好设置
- en: The plugin that we have created thus far runs fine as a standalone plugin. However,
    it is also very easy to increase its power by allowing it to run in batch mode
    over a folder containing a large set of data files. This section will look at
    some of the changes that need to be incorporated for it to work. By setting certain
    steps as individual methods that can be called when the main class is instantiated,
    we can perform specific steps in a similar way as we have been doing for other
    classes. In our example, we used the `ParticleAnalyzer`, `ThresholdToSelection`
    and the `Binary` plugin classes in a similar way. The only requirements that we
    need to add are some constants and default settings that allow this class to work
    with minimal configuration. In the following sections, I will show you a few alterations
    that can make this class a bit more flexible to use in other plugins.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的插件作为一个独立插件运行良好。然而，通过允许它在包含大量数据文件的文件夹中以批处理模式运行，我们也可以很容易地增强其功能。本节将探讨需要整合的一些更改，以便它能够正常工作。通过将某些步骤设置为可以在主类实例化时调用的独立方法，我们可以以与其他类类似的方式执行特定步骤。在我们的例子中，我们以类似的方式使用了`ParticleAnalyzer`、`ThresholdToSelection`和`Binary`插件类。我们只需要添加一些常量和默认设置，以便这个类能够以最小配置工作。在接下来的章节中，我将向您展示一些修改，可以使这个类在与其他插件一起使用时更加灵活。
- en: Settings and options dialog
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和选项对话框
- en: 'We have several parameters in our plugin that will influence how it behaves.
    Variables, such as particle size and the thresholding method, will influence the
    outcome, and have to be adjusted to match the data. ImageJ allows you to set and
    get preferences that can be stored specifically for your plugin. It uses a key-value
    system that stores the value for a preference using a specific key name. The key
    name is a string, which must be unique to your plugin preferably. To set and get
    a preference, such as the minimum particle size, you can use the following syntax:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插件中有几个参数会影响其行为。例如，粒子大小和阈值方法等变量会影响结果，并且需要调整以匹配数据。ImageJ 允许您设置和获取特定于您插件的偏好设置。它使用一个键值系统，使用特定的键名存储偏好设置的值。键名是一个字符串，最好对您的插件是唯一的。要设置和获取偏好设置，例如最小粒子大小，您可以使用以下语法：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line shows you how to store the double value `500.0` into a preference
    using the `object_tracker.minParticleSize` key. The naming of keys does not really
    have a strict convention, but using the `<class name>.<key name>` construction
    makes sure that the key will be unique and identifiable. The second line retrieves
    the setting from the preferences. The second value that is supplied is a default
    value. If the key does not exist, the `DMIN` variable will be set to this default
    value (in this case `500.0`). Finally, we can save the preferences using the `savePreferences()`
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了如何使用 `object_tracker.minParticleSize` 键将双精度值 `500.0` 存储到偏好设置中。键的命名没有严格的约定，但使用
    `<class name>.<key name>` 构造确保键是唯一且可识别的。第二行从偏好设置中检索设置。提供的第二个值是默认值。如果键不存在，`DMIN`
    变量将设置为该默认值（在这种情况下为 `500.0`）。最后，我们可以使用 `savePreferences()` 方法保存偏好设置。
- en: 'To change the values used in our plugin, we can display a small dialog that
    allows the user to enter values or make selections. When we use the dialog, we
    will save the results in the preferences. This means that we can run it as a batch
    process from this moment onward. To let the user set the key parameters for the
    detection, we can create the following preference dialog:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改我们插件中使用的值，我们可以显示一个小对话框，允许用户输入值或进行选择。当我们使用对话框时，我们将结果保存在偏好设置中。这意味着从现在起我们可以将其作为批处理过程运行。为了让用户设置检测的关键参数，我们可以创建以下偏好设置对话框：
- en: '![Settings and options dialog](img/B04909_09_07.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![设置和选项对话框](img/B04909_09_07.jpg)'
- en: 'This is done using the `GenericDialog` class available in the `ij.gui` package.
    You start with creating an instance of the `GenericDialog` class, and then adding
    your fields of choice to it in the order that you wish for them to be displayed.
    For this example, we want to set the detection mode, the threshold method, the
    minimum particle size, and the maximum particle size. If you want, you could add
    more parameters to the preferences to allow more flexibility. The following code
    will create a dialog, add the fields, and display it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在 `ij.gui` 包中可用的 `GenericDialog` 类实现的。您首先创建 `GenericDialog` 类的一个实例，然后按照您希望它们显示的顺序将您选择的字段添加到其中。对于这个例子，我们想要设置检测模式、阈值方法、最小粒子大小和最大粒子大小。如果您愿意，可以向偏好设置中添加更多参数以提供更多灵活性。以下代码将创建一个对话框，添加字段，并显示它：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At the end, we store the values that the user selected in the preferences using
    the keys. To obtain the values, we use the `getNext<>` methods. These are called
    in the order that the fields were added to the dialog, so the first call to `getNextChoice`
    will get the value from the first choice list (in this case the detection mode
    selection). The call to `getNextNumber` will retrieve the number from the first
    numeric field (in this case the minimum particle size). The order of the fields
    in a `GenericDialog` implementation becomes fixed when the fields are added, so
    this needs to be accounted for when retrieving the values. Refer to listing 9.2
    for the complete code of the plugin.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用键存储用户在偏好设置中选择的值。要获取值，我们使用 `getNext<>` 方法。这些方法按照字段添加到对话框中的顺序调用，因此 `getNextChoice`
    的第一次调用将获取第一个选择列表的值（在这种情况下是检测模式选择）。`getNextNumber` 的调用将检索第一个数字字段中的数字（在这种情况下是最小粒子大小）。在
    `GenericDialog` 实现中，字段的顺序在添加字段时变得固定，因此在检索值时需要考虑这一点。请参阅列表 9.2 以获取插件的完整代码。
- en: Adding external libraries
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加外部库
- en: When you have created a plugin for processing, you may want to add some functionality
    that is not available in the ImageJ core API. In this case, you may want to use
    an external library that has the functionality that you require. If you use Maven
    to set up your project, adding a library is as easy as listing it in your `<dependencies>`
    section of your POM file. As an example, I will show you how to add the Apache
    POI library to add an option to export the results of our work to an MS Excel
    file. The advantage of this library is that it can create an `.xls(x)` file on
    all platforms, regardless of whether MS Excel is installed. I will briefly show
    you how to create an Excel file, write some data to it, and then save the result
    as an `.xls` file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为处理创建了一个插件时，你可能想要添加一些在ImageJ核心API中不可用的功能。在这种情况下，你可能想要使用一个具有你所需要功能的第三方库。如果你使用Maven来设置你的项目，添加一个库就像在你的POM文件中的`<dependencies>`部分列出它一样简单。作为一个例子，我将向你展示如何添加Apache
    POI库来添加一个选项，以便将我们工作的结果导出到一个MS Excel文件。这个库的优点是它可以在所有平台上创建`.xls(x)`文件，无论MS Excel是否已安装。我将简要向你展示如何创建一个Excel文件，向其中写入一些数据，然后将结果保存为`.xls`文件。
- en: Adding the dependency for Apache POI
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Apache POI的依赖项
- en: 'To add the dependency of the POI project in your POM file, you will need to
    add the `org.apache.poi` project to your `<dependencies>` section. The IDE can
    help you with this process using its autocomplete feature. Let''s suppose you
    create a basic dependency template similar to the one shown as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要在POM文件中添加POI项目的依赖项，你需要在`<dependencies>`部分添加`org.apache.poi`项目。IDE可以使用其自动完成功能帮助你完成这个过程。假设你创建了一个类似于以下所示的简单依赖项模板：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this case, you can then place your cursor within the `<groupId>` tag and
    press *Ctrl* + Spacebar. You will then get a list of possible IDs that you can
    select. When you start typing the first part (`org.`), you will notice that the
    list becomes more limited as you continue to type. When you get to `org.apache.po`,
    the list only contains two options, including the POI package. If you repeat the
    process for the remaining tags, you may end up with the following dependency section:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以将光标放在`<groupId>`标签内，然后按*Ctrl* + 空格键。你将得到一个你可以选择的可能ID列表。当你开始输入第一部分（`org.`）时，你会注意到随着你继续输入，列表变得更加有限。当你输入到`org.apache.po`时，列表中只包含两个选项，包括POI包。如果你对剩余的标签重复此过程，你可能会得到以下依赖项部分：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point you can start to use the library and its interfaces, classes,
    and methods to create an Excel file (or Word documents and PowerPoint presentations).
    Please note that the packages for Excel files are designated with the **HSSF**
    moniker (**Horrible SpreadSheet** **Format**). After saving the POM file, you
    will get a new JAR file in your projects dependencies folder. In this, case it
    is the `poi-3.13.jar` file, and it contains the packages for the POI project.
    Make sure you build your project before proceeding further by navigating to **Run**
    | **Build Project** from the menu. We will now look at how to implement this library
    in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以开始使用这个库及其接口、类和方法来创建一个Excel文件（或Word文档和PowerPoint演示文稿）。请注意，用于Excel文件的包被指定为**HSSF**标识（**Horrible
    SpreadSheet Format**）。在保存POM文件后，你将在项目的依赖项文件夹中获得一个新的JAR文件。在这种情况下，是`poi-3.13.jar`文件，它包含POI项目的包。在继续之前，确保通过导航到菜单中的**Run**
    | **Build Project**来构建你的项目。我们现在将查看如何在下一节中实现这个库。
- en: Creating an Excel file
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Excel文件
- en: 'To create an Excel file, we need to create a new instance of an Excel workbook
    using Apache POI. This is relatively simple using the `usermodel` package in `org.apache.poi.ss`.
    We create an instance of the Workbook interface and add a sheet with a specific
    name that will contain the data in a method we call `saveResultsToExcel`. Every
    time we add a new class, we can add our import statements automatically by pressing
    *Alt* + *Enter*. Just make sure that you select the correct ones. If you want
    to add the `Cell` class, you have multiple options, but we require the package
    for `org.apache.poi.ss.usermodel.Cell` in this example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Excel文件，我们需要使用Apache POI创建一个新的Excel工作簿实例。这通过`org.apache.poi.ss`中的`usermodel`包相对简单。我们创建一个Workbook接口的实例，并在一个名为`saveResultsToExcel`的方法中添加一个包含数据的特定名称的工作表。每次我们添加一个新的类，我们都可以通过按*Alt*
    + *Enter*自动添加我们的导入语句。只需确保你选择了正确的选项。如果你想添加`Cell`类，你有多个选项，但在这个例子中我们需要`org.apache.poi.ss.usermodel.Cell`的包：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, I assumed that the data is in the form of an ImageJ `ResultsTable`
    object. In the loop, we go over the rows and then add cells to each row, one column
    at a time. We use the headers of the results table to make a header in the Excel
    file as well. We use a separate `Font` object (`fb` in this example) to make the
    style different from the data by making it bold. At the end, we save the results
    to a file using the generic `FileOutputStream` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我假设数据是以ImageJ的`ResultsTable`对象的形式存在的。在循环中，我们遍历行，然后逐列向每一行添加单元格。我们使用结果表的标题在Excel文件中创建标题。我们使用一个单独的`Font`对象（在这个例子中是`fb`）通过使其加粗来使样式与数据不同。最后，我们使用通用的`FileOutputStream`类将结果保存到文件中。
- en: 'To get the results table that is generated when you press the **Measure** button
    in the ROI manager, you can use the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取在ROI管理器中按下**测量**按钮时生成的结果表，你可以使用以下代码：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After asking the user for a file name, you can call the `saveResultsToExcel`
    method to generate an Excel file. The example code above works only to generate
    `.xls` files. To generate `.xlsx` files, you need to implement a workbook of the
    `XSSFWorkbook` class. The main difference between these two Excel formats is that
    the size of the data that can be contained on a sheet; `.xls` files have a limitation
    of 255 columns per sheet. If you expect to generate tables with more columns,
    you need to make sure to use the `XSSFWorkbook` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在询问用户文件名之后，你可以调用`saveResultsToExcel`方法来生成一个Excel文件。上面的示例代码仅用于生成`.xls`文件。要生成`.xlsx`文件，你需要实现`XSSFWorkbook`类的电子表格。这两种Excel格式之间的主要区别在于一个工作表上可以包含的数据量；`.xls`文件每个工作表有255列的限制。如果你预计要生成包含更多列的表格，你需要确保使用`XSSFWorkbook`类。
- en: Sharing your plugin
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享你的插件
- en: When you have finished implementing all the routines and completed (extensive)
    testing, you are ready to distribute your plugin to the world. Currently, there
    are several options available to distribute your plugin, ranging from sending
    it using e-mail to an automated update mechanism in ImageJ. Here, I will discuss
    the latter option, which has some great benefits that makes it very user-friendly
    and efficient. Fiji, and ImageJ2 have a system that allows you to set a website
    as a source for your plugin. This website will be checked to see whether there
    is a newer version available, and if so, it will be automatically updated. The
    only thing your users have to do is add that site to their list of update sites
    to install and update your plugin(s). The following sections will describe how
    to setup this site, and how users can add the site to ImageJ (ImageJ2 and Fiji,
    specifically).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成所有例程的实现并完成了（广泛的）测试后，你就可以将你的插件分发到全世界了。目前，有几种分发插件的方法可供选择，从通过电子邮件发送到ImageJ的自动更新机制。在这里，我将讨论后者，它具有一些很好的优点，使得它非常用户友好且高效。Fiji和ImageJ2有一个系统，允许你将一个网站设置为插件源。该网站将被检查以查看是否有更新的版本可用，如果有，它将自动更新。用户需要做的只是将此网站添加到他们的更新网站列表中，以便安装和更新你的插件（们）。以下章节将描述如何设置此网站，以及用户如何将网站添加到ImageJ（特别是Fiji和ImageJ2）中。
- en: Creating a site
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个网站
- en: 'To create a site, you have different options available: you can host your own
    update site, or you can use the ImageJ Wiki site. I will now focus on the latter
    option as it is easy, free, and accessible to everyone. Note that your users need
    to have ImageJ2 or Fiji to be able to use this mechanism. For this section, I
    will assume that you are using Fiji, but it works in a similar manner in ImageJ2\.
    To create the site, you can go to **Help** | **Update…** in the menu. In the window
    that opens, press the **Manage update sites** button on the bottom right to get
    the sites currently available.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个网站，你有不同的选项可用：你可以托管自己的更新网站，或者你可以使用ImageJ Wiki网站。现在我将专注于后者，因为它简单、免费且对每个人都是可访问的。请注意，你的用户需要使用ImageJ2或Fiji才能使用此机制。对于本节，我将假设你正在使用Fiji，但在ImageJ2中它的工作方式类似。要创建网站，你可以转到菜单中的**帮助**
    | **更新…**。在打开的窗口中，按下右下角的**管理更新网站**按钮以获取当前可用的网站。
- en: '![Creating a site](img/B04909_09_06.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个网站](img/B04909_09_06.jpg)'
- en: You can press the **Add my site** button in this window and either create a
    new account or use an existing account. If you already have an account, you only
    have to enter your user name, and if your password hasn't yet been stored, also
    enter your password. If you want to create a new account, you can enter a user
    name. If it doesn't yet exist, you can enter your e-mail address and press **OK**.
    You will receive an e-mail message on the account that you provided with a temporary
    password. You must then go to the Wiki login page at [http://imagej.net/Special:UserLogin](http://imagej.net/Special:UserLogin)
    to change your password. Once you have modified your password, you can enter it
    in the **Add personal site** window of ImageJ. You are now ready to add your plugins
    to the website.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此窗口中按下**添加我的站点**按钮，然后创建一个新账户或使用现有账户。如果您已经有了账户，您只需输入用户名，如果您的密码尚未存储，也请输入密码。如果您想创建一个新账户，您可以输入一个用户名。如果它还不存在，您可以输入您的电子邮件地址并按下**确定**。您将收到一封电子邮件，其中包含您提供的账户的临时密码。然后您必须前往[http://imagej.net/Special:UserLogin](http://imagej.net/Special:UserLogin)的Wiki登录页面来更改您的密码。一旦您更改了密码，您就可以在ImageJ的**添加个人站点**窗口中输入它。现在您就可以将您的插件添加到网站上了。
- en: Uploading your plugin
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传您的插件
- en: To upload your plugin, you cannot just upload your file directly to the server.
    In order for it to be recognized as a proper update site and plugins, some additional
    files are required. Luckily, the ImageJ updater can also take care of this process
    for you. Open the updater by navigating to **Help** | **Update…** from the menu
    and click on the **Advanced mode** button. The first time you upload a plugin,
    you need to select the **View local-only files** from the **View options** drop-down
    list. You can now select your plugin on the left-hand side, and edit the details
    in the **Details** view on the right-hand side. By right-clicking on your plugin,
    you can open a context menu and select **Upload to My Site**. The **Status/Action**
    column should now display **Upload it**, and after pressing the **Apply** **changes**
    button and providing your credentials, the upload will start.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传您的插件，您不能直接将文件上传到服务器。为了让它被识别为合适的更新站点和插件，需要一些额外的文件。幸运的是，ImageJ更新器也可以为您处理这个过程。通过从菜单中选择**帮助**
    | **更新…**来打开更新器，并点击**高级模式**按钮。第一次上传插件时，您需要从**视图选项**下拉列表中选择**仅查看本地文件**。现在您可以在左侧选择您的插件，并在右侧的**详情**视图中编辑详细信息。通过右键单击您的插件，您可以打开一个上下文菜单并选择**上传到我的站点**。现在**状态/操作**列应该显示**上传它**，在按下**应用**
    **更改**按钮并提供您的凭据后，上传将开始。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a legacy plugin from scratch using the Maven system
    and the NetBeans IDE. We applied some of the image processing techniques that
    we learned in the previous chapters in our plugin. We saw how to add a basic user
    interface to our plugin, allowing the user to change some of the parameters that
    influence the way the plugin functions. We also saw how to store our settings
    in the preferences so that they can be recalled the next time we use the plugin.
    We added an external library to provide additional functionality that was not
    present in ImageJ. Finally, we looked at an automated way of publishing our plugin
    and sharing it with the world.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从头开始使用Maven系统和NetBeans IDE开发了一个遗留插件。我们在插件中应用了之前章节中学到的一些图像处理技术。我们看到了如何为我们的插件添加一个基本用户界面，使用户能够更改影响插件功能的一些参数。我们还看到了如何将设置存储在首选项中，以便下次使用插件时可以调用它们。我们添加了一个外部库来提供ImageJ中不存在的一些附加功能。最后，我们探讨了自动发布我们的插件并与世界分享的方法。
- en: In the next chapter, we will look at the resources that are available to further
    your knowledge and skills in image processing and project development.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨可用于进一步扩展您在图像处理和项目开发方面的知识和技能的资源。
