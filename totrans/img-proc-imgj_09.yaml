- en: Chapter 9. Creating ImageJ Plugins for Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine how to create plugins to perform analyses.
    This chapter will examine how to make a flexible plugin, and how to implement
    it in ImageJ to perform a simple analysis. The following topics will be dealt
    with in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new plugin project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a plugin to process and analyze images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding user interaction and preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing your plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugin background and goal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, I will briefly describe an image-processing problem that we
    will try to solve using a plugin. The problem is a general one that is encountered
    in many experiments involving living cells or organisms: they move and change
    shape. When we want to quantify certain aspects of the cells that we have imaged,
    we need to perform three basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the object of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure our object in the current frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detect each object in our time series independently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are encountered in many different problems involving time series.
    For each of the three steps, we need to create a solution that solves the problem
    or quantifies the object in a meaningful manner. For detection, we can think of
    many methods that may be suitable to detect the object. When we think back to
    the topics discussed in [Chapter 4](ch04.html "Chapter 4. Image Segmentation and
    Feature Extraction with ImageJ"), *Image Segmentation and Feature Extraction with
    ImageJ* we may think of a threshold-based technique to segment the image, and
    use a particle analyzer to find objects that contain specific features. For measurements,
    we can go back to [Chapter 5](ch05.html "Chapter 5. Basic Measurements with ImageJ"),
    *Basic Measurements with ImageJ* where we looked at the basic methods to measure
    objects using ImageJ commands. The final component for this example uses the previous
    two methods for each of the identified objects.
  prefs: []
  type: TYPE_NORMAL
- en: To make our plugin more general and widely usable, we will also need to specify
    some parameters that will influence the outcome for each of these steps. The detection
    might need different criteria about what is a valid object depending on the data.
    To this end, we can create a generic dialog that will ask the user for input using
    a few input fields. I will give different examples of the same code that can be
    used in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Basic project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, I will be using the Maven system to set up the project and
    the dependencies that are required. Most of the source code can also be run without
    these steps, but I will set it up using the NetBeans IDE using a Maven POM project.
    As we saw in [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"),
    *Explanation of ImageJ Constructs* setting up a new project for ImageJ using Maven
    is done by navigating to **File** | **New Project**, and choosing **POM Project**
    from the **Maven** category in the wizard. For this plugin, I will use the project
    name `Object_Tracker`. After clicking **Finish**, the project will be created
    and should show up in the **Projects** view. If you cannot see the **Projects**
    view, go to **Window** | **Projects** from the menu to display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to tell Maven that we require ImageJ as a dependency.
    We do this by adding a `<dependencies>` section to our `pom.xml` file, as was
    shown in [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"),
    *Explanation of ImageJ Constructs*. We will first look at how to create this plugin
    as a legacy plugin using all the standard coding of a legacy plugin. To code it
    as a legacy plugin, we will use ImageJ version **1.50b** as a dependency by adding
    the following code to our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `<repositories>` section tells Maven where to find the sources for our dependencies,
    and in the optional `<version>` tag, we specify which version of ImageJ we wish
    to use. Note that if you start typing the version number in the tag, NetBeans
    will suggest version numbers that you can enter. At the time of writing **1.50b**
    was the latest version of ImageJ. If you leave this tag out, the version will
    be automatically set to the latest managed version. We will save the modifications
    to our POM file, which will trigger NetBeans to load the requested dependency
    from the repository and place it in the **Dependencies** folder within your project.
    If you issue the build command (**Run** | **Build Project**) for the project at
    this stage, we will still get an error. We are missing the source code for the
    plugin; this will be our next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our source code, we will need to add a new Java class file to our project.
    The following steps will let you create the main class file for this project;
    however, these steps are identical to generate other classes that you want to
    add to the same project:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Object_Tracker` project and go to **New | Java Class…**
    from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Object_Tracker` as the name for the new class, and set the **Location**
    to `/src/main/java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get a new java source file, and in the **Projects** view you will see
    the **Source Packages** directory is added to your project. You can now try and
    build the project again, which should now finish successfully. As a Maven project
    can also create Javadoc documentation for a project, we will also make sure that
    we add Javadoc comments to our class, and methods to document the API of our plugin.
    We will start the development of our plugin by implementing it as a `PlugInFilter`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic PlugInFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a `PlugInFilter` implementation, we add the `implements` keyword behind
    the class name and specify `PlugInFilter` as the implementation. When you do this
    using an IDE, such as NetBeans, it will place a red squiggly underline under this
    statement. When you place the cursor on the line with the squiggly underline and
    press *Alt* + *Enter* (in NetBeans), the editor will give you a list of suggestions
    to rectify the mistake that we made. The first complaint is that NetBeans cannot
    find the `PlugInFilter` symbol because we haven't added it yet. Press *Alt* +
    *Enter* and select the option called **Add import** for `ij.plugin.filter.PlugInFilter`.
    You will now see that the import statement is added to your source file (usually
    at the top of the source file). We now still have a squiggly underline in our
    class statement as it is missing the overrides for the abstract setup and run
    methods. As explained in [Chapter 8](ch08.html "Chapter 8. Anatomy of ImageJ Plugins"),
    *Anatomy of ImageJ Plugins* `PlugInFilter` requires these two methods to be present
    and overridden with your initialization code (setup) and your programming logic
    (run). Use the *Alt* + *Enter* method, and choose the option called **Implement
    all abstract methods** from the list of choices. At this stage, we have a basic
    `PlugInFilter` implementation that contains all the required elements.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our current implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no functional code yet, but let''s test what happens when we try to
    run the project at this stage. When you go to **Run** | **Run Project** from the
    menu, you will get a dialog that asks for the `main` class to be run. Since we
    did not specify a `main` method (yet), we cannot proceed and can only select cancel.
    We need to do two things: first, we need to add a `main` method to our source
    code file, and secondly, we need to tell Maven which class contains the `main`
    method. We will start with the first item on the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the `main()` method, we add the following code somewhere within the
    body of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard Java style declaration of a `main` method that takes a `String`
    list of parameters stored in the `args` variable. The triple dots behind the `String`
    type indicate that this method can be called with a variable number of `String`
    arguments ranging from none to many. This type of calling structure can be helpful
    if you want to run your plugin via a **Command Line Interface** (**CLI**). Since
    we will mostly ignore the input parameters for now, it is not important to use
    them within the body of the `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second step, we can modify our project in two separate ways. We can
    type the `<main-class>` tag in the `<properties>` tag in the POM file (see [Chapter
    7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"), *Explanation of ImageJ
    Constructs*), or we can use the features of the IDE. To edit how the project is
    run, you can right-click on the project in the **Projects** view and select **Properties**
    from the context menu. This will open the properties available for this type of
    project. Select the **Run** category from the left-hand side of the properties
    dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our current implementation](img/B04909_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now see that there is an option to set the **Main Class**. By pressing
    the **Browse…** button, you are able to select the `Object_Tracker` class that
    contains our `main` method. You may also notice that you can specify **Arguments**
    to your `main` method. The content of this field will be used as input parameters
    to your main method''s argument `args`. One option we might also want to enter
    at a later stage is the **VM Options** field. This option will allow us to control
    the amount of memory that is allocated to the application. For now, only select
    the `Object_Tracker` as the **Main Class**. This will generate two new files in
    NetBeans where the run configuration is stored: `nbactions.xml` and `nb-configuration.xml`.
    Alternatively, you can add the sections to the `pom.xml` file, as described in
    [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"), *Explanation
    of ImageJ Constructs*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that using the **Properties** method, you will limit your application
    to the NetBeans framework. If you wish to exchange your code with others that
    do not use NetBeans, you always want to choose the pure Maven approach and define
    your `main` class in the `pom.xml` file directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to run the project now by navigating to **Run** | **Run Project**,
    you will get no errors and the building will be successful. The only problem is
    that nothing happens; we don''t see ImageJ, and our plugin cannot be found. We
    still need to implement our main method to make sure that ImageJ is launched.
    To do this, we add a new instance of ImageJ to our `main` method, and save the
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After fixing the error by adding the import for `ij.ImageJ`, we run our project
    and we will see the ImageJ interface. If you go to **Help** | **About ImageJ**,
    you will see that the version is indeed set to **1.50b**. However, when we look
    in the **Plugins** menu, we will not find our plugin there. We will use the same
    trick as shown in [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"),
    *Explanation of ImageJ Constructs* to fix our plugins directory mix-up by adding
    the following code to our `main` method before calling `new ImageJ()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After saving the source file and running the project, we will now see our plugin
    in the **Plugins** menu. When you launch the plugin you will get an error specifying
    that this method is not implemented yet. This is caused by the fact that the body
    of the abstract `setup` and `run` methods only contain an exception that is being
    thrown (this depends on your installation of NetBeans and your templates). We
    have the plugin framework completed, and next, we will implement our functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the setup method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with implementing the `setup` method, which serves as a basic
    checkpoint to see if our plugin can process the currently active image. We can
    also use this method to make some preparations and perform some basic checks before
    we run our plugin. We will start with clearing the current statement from the
    body of the `setup` method and add a return value. The `setup` method requires
    that an integer value be returned, which tells ImageJ the type of image that can
    be processed using this plugin. We will also add some Javadoc comments to this
    function to explain what is going on in this function. For this project, I will
    assume that the following structure is the structure of the source code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You are of course free to deviate from this template (within the bounds of Java
    syntax and programming logic). This type of structure is common to Java files,
    and it contains some elements that are not strictly required, but which can be
    useful. The constructor is not required to be present in an ImageJ plugin. However,
    it can be useful to add it, as it allows an increase in usability when you want
    to call your plugin from within other projects. Using the constructor, you can
    implement certain initializations or assert control over how the plugin is created.
  prefs: []
  type: TYPE_NORMAL
- en: The return type and autocomplete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start with adding the return statement specifying the type of images
    that we expect to process. For this project, we are interested in quantifying
    objects over time in a single channel (for now), so we will expect to process
    stacks of either 8 or 16-bit. Therefore, we add the following return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When typing in an IDE, you can use its autocomplete functionality to determine
    which type you wish to return. If you type `DOES` and press *Ctrl* + Spacebar
    you will get a list of the possible autocomplete options. You can use the mouse
    or the arrow keys to select an option from the list, and by double-clicking it
    or pressing enter, it will be inserted at the point you were typing. If the list
    of options is very long, you can also continue typing after you have pressed *Ctrl*
    + Spacebar. For every character that you add, the list will become more selective
    to match what you are typing. For example, when you type `_1` after you typed
    `DOES`, you will only get the single option `DOES_16`. Another nice feature is
    that when you select an option from the autocomplete list, it will also show the
    Javadoc for that selection. However, you may have noticed that this didn't work
    here; the IDE stated that the Javadoc was not found. We will remedy this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Javadoc for methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw, the Javadoc for our ImageJ project was not found. We will now fix
    this using the IDE, which only takes a few simple steps. First, we make sure that
    our Javadoc view is open by activating it. Go to **Window** | **IDE Tools** |
    **Javadoc Documentation** from the menu to activate the view. When we place our
    cursor on an object such as the `DOES_16` statement that we entered above, the
    Javadoc view will display the same message that we noticed in the autocomplete
    window. However, it also displays an option at the bottom called **Attach Javadoc…**
    in the form of a link. When you click on it, a window will ask you for the location
    of the documentation. There is also a button called **Download**, which will automatically
    download the Javadoc for the ImageJ version that we listed as a dependency in
    our project. After clicking OK, you will now see that the Javadoc view shows the
    documentation for the `DOES_16` field. You can also generate the Javadoc for your
    project by right-clicking on your project in the Projects view and selecting **Generate
    Javadoc** from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: We will now create our own Javadoc comments for our setup method. The easiest
    way to do this using the IDE is to place the cursor on the setup method and press
    *Alt* + *Enter*. An option will be displayed stating **Create missing Javadoc
    for setup**, which we will choose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also place your cursor above the method you wish to document, and type
    `/**`, and press *Enter*. In NetBeans, typing the start of a Javadoc comment and
    pressing *Enter* will autocomplete the Javadoc comment, and it will add the arguments
    and return type of your method as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting this option, a Javadoc comment is added above the setup method
    containing the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the standard content for a Javadoc section that describes a method
    with input parameters and a return value. Parameters are designated as `@param`
    followed by the variable name. There is one `@param` line for each parameter in
    the methods arguments list. To add information about the parameter, you can start
    typing right after the variable name (make sure that there is a space between
    the variable name and your description). The first line above the parameter list
    is meant to provide a brief description of the methods purpose. Let''s add some
    of the information about the `setup` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you look at the Javadoc viewer now, you will see the text that you added
    is displayed and formatted. Please note that you can use standard HTML tags to
    format your text with paragraphs, headings, tables, and lists. At this stage it
    is possible to generate the Javadoc for your plugin and view it in a browser.
    To do so, right-click on your project in the **Projects** view and select **Generate
    Javadoc** from the context menu. After waiting a bit while the IDE is busy scanning
    the project and building the documentation, you can open the Javadoc in a browser
    by opening the `index.html` file from the `target/site/apidocs/` folder in the
    root of your project. Alternatively, you can click on the link in the **Output**
    view which can be activated by navigating to **Window** | **Output** from the
    menu. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Javadoc for methods](img/B04909_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see the setup method with the text that
    we added as a description, and at the bottom, we see the details we entered for
    the parameters and the return value.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to add this information as you develop your source code,
    both for your own benefit when you review your code weeks from now, as well as
    for other developers who may wish to use or expand your code for their own projects.
    As the Javadoc tool takes care of all the processing and layout of the documentation,
    you only need to add the descriptions for the methods and classes. I will not
    explicitly add the documentation sections in the code snippets in this chapter,
    but they will be part of the final source code. After this small digression, we
    will return to creating a plugin to detect objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the setup method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After completing the previous sections, we now have a `setup` method with a
    return value indicating that we will be processing all 8 or 16-bit images and
    stacks. We will now perform a few more checks that will be required for the processing
    to complete. The first step is to make sure that the ROI Manager is open so that
    we can see the detections and the results of our detection. At this stage, it
    might also be a good idea to think about the type of images we may want to process.
    Do we want to process RGB or multichannel images and stacks or only single channel
    stacks?
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with checking if the ROI Manager is available. To do this, we
    can use the `getInstance()` method from the `RoiManager` class. This method will
    return a value of `null` when it is not open yet; otherwise, it will return the
    reference of the ROI Manager instance. Add the following to the `setup` method
    before the return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you used the autocomplete option to select the `RoiManager` class, NetBeans
    also automatically added the required import statement at the top of your source
    code file. If you copied and pasted the code, you will need to add the import
    statement yourself using either the *Alt* + *Enter* option or by typing it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do in the setup is to check the image type; it needs
    to be a single channel image with a single frame or slice, or multiple frames
    and a single slice. The first step is to obtain the dimensions of the current
    image and then check whether it matches our specifications. For the current incarnation
    of the plugin, I will make these specifications binding so that when it fails,
    the plugin will not run. The code for retrieving the dimensions and checking whether
    they match our specifications is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `getDimensions()` method returns a vector of length `5`, with the width,
    height, channels, slices, and frames (in that order).
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, I would like to introduce another useful feature of an IDE that
    will make your coding life much easier. When the IDE added the abstract methods
    for setup and run, it used the `ip` parameter name for both the `ImagePlus` type
    in the `setup` method and the `ImageProcessor` type in the `run` method. This
    is slightly confusing and inconsistent. The convention for `ImagePlus` objects
    is to use `imp` as a reference name, and `ip` for `ImageProcessor` references.
    We will now use the **Refactor** option in the IDE to fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by selecting the parameter that we would like to change; in this
    case, the `ip` parameter in the `setup` method. We then go to **Refactor** | **Rename**
    from the context menu or press *Ctrl* + *R*. You will now see that there is a
    red box around the parameter, and you can change the name by typing a new name.
    When you now type `imp`, you will see that only the names associated with the
    `setup` method are changed. This does not affect the parameter of the `run` method.
    Also, the Javadoc section is updated to reflect the new variable name. This is
    a great feature to use when changing the name of a variable, and it is much more
    effective than a search-and-replace style approach. If you would have used search
    and replace, the variable name in the run method may have also been changed, making
    it inconsistent again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run our project, we should see the plugin in the **Plugins** menu,
    but when we launch it, we will receive a `NullPointerException` exception. This
    is caused by the fact that we tried to retrieve the dimensions from a nonexistent
    image. So, we need to add a final check before we call the `getDimensions()` method
    to check if the `imp` parameter is not equal to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make sure that nothing happens when you have no image open or the
    wrong kind of image compared to what the plugin expects. It is currently not very
    user-friendly. When the user activates a plugin, he or she would expect something
    to happen. It would be nice if there were some feedback to indicate why nothing
    happened. As an example, I will add a message stating that the plugin requires
    a stack to be opened before exiting. To do so, we add the following statement
    to the body of the statement checking for the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run your project and launch the plugin, the following message
    will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finishing the setup method](img/B04909_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is much more user-friendly and avoids generating unnecessary errors, which
    can be confusing to users. Most of the errors and exceptions generated by compilers
    are cryptic at best, and most non-programmers will not understand what went wrong.
    Now that we have finished the setup method, we will now focus on implementing
    the actual functional code that will perform the processing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the run method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 8](ch08.html "Chapter 8. Anatomy of ImageJ Plugins"),
    *Anatomy of ImageJ Plugins* the run method is the entry point for the `PlugInFilter`
    type. At this stage we know for sure that we have an 8 or 16-bit stack with a
    single channel; otherwise, we would have never reached the run method. We can
    now start implementing our algorithm to detect the object. After that, we will
    look at the required methods to measure the object in the current frame, and finally,
    how to process each object across frames in the case of multiple objects. We will
    start with the detection first, as this is the primary step that needs to be solved.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting an object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be able to detect an object, we need to know about some of the properties
    that make the object identifiable. This may sound simpler than it really is. The
    human visual system is highly capable of finding objects in all types of lighting
    conditions and situations. Computer algorithms are only starting to approach the
    same levels of detection that feel natural to humans. For this example, I will
    limit the detection of objects based on the intensity of the object relative to
    the background. I'm going to assume that the object we wish to detect is bright
    compared to the darker background, as is the case in fluorescence imaging for
    example. We will use the **Confocal Series** sample image to practice with as
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make a few small preparations before we can start using this image.
    The image contains two channels, which is an exclusion criterion for our plugin!
    So we split the image into separate channels, and convert one of them to 16-bit
    before saving them both to disk as TIFF files. Using the knowledge from [Chapter
    2](ch02.html "Chapter 2. Basic Image Processing with ImageJ"), *Basic Image Processing
    with ImageJ* and [Chapter 3](ch03.html "Chapter 3. Advanced Image Processing with
    ImageJ"), *Advanced Image Processing with ImageJ* you should be capable of performing
    these steps. We will use a threshold to detect the object based on the intensity,
    and based on that threshold, create a selection that will be added to the ROI
    manager. For the detection, we will create a method called `performDetection()`
    that will be called from the `run` method. As we assume a stack, we will also
    need to add a loop to go over each of the slices. We will start with the loop
    statement in the `run` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the slightly odd behavior for the `setSlice` method. Unlike arrays and
    other indexed objects in Java, the slice indices for an image are not zero-based.
    This idiosyncrasy was observed back in [Chapter 2](ch02.html "Chapter 2. Basic
    Image Processing with ImageJ"), *Basic Image Processing with ImageJ*. Next, we
    create the method to perform the detection, and we add the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This sets an automatic threshold using the default method (first parameter)
    and using a dark background (second parameter). When using the autocomplete option,
    many of these values will be filled in by default making it easier to write code,
    but not necessarily to understand it. We then add the new threshold to the current
    image using a reference to a class-wide variable that we added to our class definition
    (see the template for the class file that was mentioned earlier).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This allows us access to the current image and the ROI Manager throughout our
    class. We also modify the setup method slightly to accommodate these changes using
    the `rm` reference to get the instance or store a new reference to the ROI Manager.
    We do the same for the class-wide `ImagePlus` variable (`this.imp`) by storing
    the current image that comes in with the `setup` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To add our thresholded object to the ROI manager, we use the `ThresholdToSelection`
    class (another `PlugInFilter` type) that comes with ImageJ. This is the class
    that is activated when you navigate to **Edit** | **Selection** | **Create Selection**
    from the ImageJ menu. This is a nice example of one plugin calling the `run` method
    of another plugin. This means that we can also use the `run` method of our plugin
    in other plugins or macros.
  prefs: []
  type: TYPE_NORMAL
- en: We will now test our plugin by running the project and opening one of the images
    we saved, before launching our plugin. It should now run through all the slices
    of the stack and populate the ROI manager at every frame. The ROIs look quite
    good, but there are still a few small problems. There are holes in some of the
    ROIs, and some ROIs have small isolated pixels that are not connected to the main
    object. In the next section, we will examine ways to refine the detection using
    the techniques that we learned back in [Chapter 4](ch04.html "Chapter 4. Image
    Segmentation and Feature Extraction with ImageJ"), *Image Segmentation and Feature
    Extraction with ImageJ*.
  prefs: []
  type: TYPE_NORMAL
- en: Refining the detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we tested the plugin at the end of the previous section, we noted some
    shortcomings of the current detection method using only a threshold. We saw holes
    in the object and small isolated pixels that we would like to remove. This is
    something that can be achieved using binary processing as discussed in [Chapter
    4](ch04.html "Chapter 4. Image Segmentation and Feature Extraction with ImageJ"),
    *Image Segmentation and Feature Extraction with ImageJ*. We will now implement
    this processing before we convert the threshold to a selection. The first step
    is to take our ROI and use it to create a mask image, which we will process using
    the techniques that we learned in [Chapter 4](ch04.html "Chapter 4. Image Segmentation
    and Feature Extraction with ImageJ"), *Image Segmentation and Feature Extraction
    with ImageJ*. To create our mask image, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code is inserted between the `Roi roi...` statement and the `rm.addRoi(roi)`
    statement in the `performDetection` method. The first line creates a new image
    called mask with a `ByteProcessor` for the `ImageProcessor`; this results in an
    8-bit image. The width and the height are set to be equal to the original image.
    This is important when you want to measure the object in the original image. If
    you create a mask directly from the image, its size will be the size of the bounding
    rectangle of the ROI. Next we add the ROI to the new image, and get a reference
    to the `ImageProcessor` for this image. This will allow us to modify the pixels
    of the mask. Next, we set the foreground color to white `(255)` and fill the mask
    with white. Finally, we invert the LUT for the binary processing. Next, we will
    perform the binary processing. We want to fill the holes and get rid of the isolated
    pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with filling the holes in the shape using the `Binary` plugin.
    This is a class that implements a `PlugInFilter`; however, the use is a little
    different this time. We first need to create an instance of the class, and then
    set up the class for our purpose. We will add the following code directly underneath
    the last statement of the previous code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new instance of the `Binary` class and add the import statement
    for `ij.plugin.filter.Binary` at the top of our source code file. Next, we set
    up the plugin to perform the task that we want, in this case, filling the holes
    in our mask. We do this by calling the `setup` method with a `String` argument
    (`"fill"`) and an `ImagePlus` argument (our mask image). Our own plugin has a
    similar form for the setup; this means that we could also choose to implement
    a similar system later on. In the last step, we call the `run` method of the `Binary`
    plugin, which will perform the actual processing on our image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use the erode and dilate operators to get rid of isolated pixels.
    We will run the erode operator three times and the dilate operator five times
    to create a smooth mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These values are quite arbitrary and other values might be more suitable when
    using different images. Finally, we set a threshold on our mask image to obtain
    a new ROI using the `ThresholdToSelection` method, just like we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We use the `roi` variable again because we don't need the ROI that we created
    in the original image. We then add the new ROI to the ROI Manager, which is the
    last step for our detection. If you run the project and try it on the test images,
    you will see the effect of the binary processing—the ROIs are a bit more smooth
    and contain almost no isolated pixels anymore. The following image shows all the
    ROIs overlaid on the first frame of the original stack. I used the green channel
    for this example, but you can also try to run the plugin on the red channel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refining the detection](img/B04909_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Detecting multiple objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, we assumed that we have only a single object in our frames.
    I will now look at a method that allows detecting multiple objects. To do this,
    we will use another technique that we learned in [Chapter 3](ch03.html "Chapter 3. Advanced
    Image Processing with ImageJ"), *Advanced Image Processing with ImageJ*. There,
    we looked at Z-projections and how they can be used to flatten a stack into a
    single image. We will now use this same technique to define our search space to
    detect the objects in the time series. By creating a maximum intensity projection,
    we can visualize all the pixels that our object will occupy at one time or another
    during the time series. This projection will help us define the search space.
    For *N* number of objects that do not overlap, you will get *N* search spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to create the maximum intensity projection. To do this,
    we can use the `ZProjector` class and set it to maximum intensity using `MAX_METHOD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a new `ZProjector` instance using the original stack as
    an input. Next, we set the method to be used, and perform the projection. Finally,
    we retrieve the maximum intensity projection image using the `getProjection()`
    method. Next up, we will use the `ParticleAnalyzer` class to detect the objects
    in our maximum intensity projection that will define our search spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the particle analyzer, we create an instance of the class and set its
    parameters to determine the search spaces. For this example, we want to find objects
    that are relatively large, so we will set a minimum size limit for the particles
    but not for the shape. To do this, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We start by setting the options and the measurements that we want. In this case,
    we only care about the found objects' location, so we need ROIs at the end of
    the detection (indicated by the `ADD_TO_MANAGER` option). The option for measurements
    is set to none to avoid generating results or other objects (indicated by `SHOW_NONE`).
    We then initialize the particle analyzer using the options and sizes that we specified.
    Next, we create an instance of an ROI Manager that will not be displayed. This
    instance of our ROI Manager will be assigned to our particle analyzer before we
    analyze our image using the `analyze()` method. This is necessary because we don't
    want to measure these intermediate ROIs, we only use them to identify and process
    each search space. In the last step, we extract the search spaces as ROI objects
    from our temporary ROI Manager instance. With our search spaces defined, we can
    start the detections for each search space individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The detections can be created in a similar way as we saw before with a small
    alteration: instead of using the entire image, we want to perform our detection
    within the search space for the individual object. We can achieve this by setting
    the search space ROI on our image and duplicate it using the `duplicate()` method.
    We then have access to the pixels from this cropped region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We do this for each of our search spaces using the for-each syntax, and perform
    the detection as before. There are some other alterations that are required to
    make this work, so take a look at the complete code listed in the code bundle
    at Packt Publishing's website.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the measurements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our objects identified for each slice, we can start to look
    at measuring our object. We will use some of the knowledge from [Chapter 5](ch05.html
    "Chapter 5. Basic Measurements with ImageJ"), *Basic Measurements with ImageJ*
    to design a measurement for this object. Depending on the type of object, we may
    want to look at different measurements that may be important, but I will start
    with some of the obvious ones for the type of ROIs that we created. Our ROIs are
    area selections, so the first metric that seems relevant is the area of the object(s).
    Other relevant measurements are the mean intensity and the shape of the object(s).
    We will implement the measurements in a separate method that we will add to our
    class. The method will have the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using the ROIs in the ROI Manager so that we don''t require an input
    argument. We will set the measurements according to the values that we discussed
    before by adding a variable called `msrmnt` at the beginning of our class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is used to set the measurements to the slice number, area, circularity,
    and mean. We use the `Analyzer` class and its `setMeasurements` method to get
    the desired results. Finally, we call the `unlock` method on our image to allow
    the macro command of the ROI Manager to gain access to our image for the measurements.
    If you omit this statement, the plugin will run without visible errors, but you
    will not get any results. To get the results, we call our measurement method directly
    after the loop has finished. In the next section, we will add some user interaction
    to our plugin, allowing us to change some of the parameters that are used in the
    detection. We will also introduce the preferences system of ImageJ to allow the
    storage of our parameters for future use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding user interaction and preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The plugin that we have created thus far runs fine as a standalone plugin. However,
    it is also very easy to increase its power by allowing it to run in batch mode
    over a folder containing a large set of data files. This section will look at
    some of the changes that need to be incorporated for it to work. By setting certain
    steps as individual methods that can be called when the main class is instantiated,
    we can perform specific steps in a similar way as we have been doing for other
    classes. In our example, we used the `ParticleAnalyzer`, `ThresholdToSelection`
    and the `Binary` plugin classes in a similar way. The only requirements that we
    need to add are some constants and default settings that allow this class to work
    with minimal configuration. In the following sections, I will show you a few alterations
    that can make this class a bit more flexible to use in other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Settings and options dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several parameters in our plugin that will influence how it behaves.
    Variables, such as particle size and the thresholding method, will influence the
    outcome, and have to be adjusted to match the data. ImageJ allows you to set and
    get preferences that can be stored specifically for your plugin. It uses a key-value
    system that stores the value for a preference using a specific key name. The key
    name is a string, which must be unique to your plugin preferably. To set and get
    a preference, such as the minimum particle size, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first line shows you how to store the double value `500.0` into a preference
    using the `object_tracker.minParticleSize` key. The naming of keys does not really
    have a strict convention, but using the `<class name>.<key name>` construction
    makes sure that the key will be unique and identifiable. The second line retrieves
    the setting from the preferences. The second value that is supplied is a default
    value. If the key does not exist, the `DMIN` variable will be set to this default
    value (in this case `500.0`). Finally, we can save the preferences using the `savePreferences()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the values used in our plugin, we can display a small dialog that
    allows the user to enter values or make selections. When we use the dialog, we
    will save the results in the preferences. This means that we can run it as a batch
    process from this moment onward. To let the user set the key parameters for the
    detection, we can create the following preference dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Settings and options dialog](img/B04909_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is done using the `GenericDialog` class available in the `ij.gui` package.
    You start with creating an instance of the `GenericDialog` class, and then adding
    your fields of choice to it in the order that you wish for them to be displayed.
    For this example, we want to set the detection mode, the threshold method, the
    minimum particle size, and the maximum particle size. If you want, you could add
    more parameters to the preferences to allow more flexibility. The following code
    will create a dialog, add the fields, and display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At the end, we store the values that the user selected in the preferences using
    the keys. To obtain the values, we use the `getNext<>` methods. These are called
    in the order that the fields were added to the dialog, so the first call to `getNextChoice`
    will get the value from the first choice list (in this case the detection mode
    selection). The call to `getNextNumber` will retrieve the number from the first
    numeric field (in this case the minimum particle size). The order of the fields
    in a `GenericDialog` implementation becomes fixed when the fields are added, so
    this needs to be accounted for when retrieving the values. Refer to listing 9.2
    for the complete code of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Adding external libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have created a plugin for processing, you may want to add some functionality
    that is not available in the ImageJ core API. In this case, you may want to use
    an external library that has the functionality that you require. If you use Maven
    to set up your project, adding a library is as easy as listing it in your `<dependencies>`
    section of your POM file. As an example, I will show you how to add the Apache
    POI library to add an option to export the results of our work to an MS Excel
    file. The advantage of this library is that it can create an `.xls(x)` file on
    all platforms, regardless of whether MS Excel is installed. I will briefly show
    you how to create an Excel file, write some data to it, and then save the result
    as an `.xls` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the dependency for Apache POI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the dependency of the POI project in your POM file, you will need to
    add the `org.apache.poi` project to your `<dependencies>` section. The IDE can
    help you with this process using its autocomplete feature. Let''s suppose you
    create a basic dependency template similar to the one shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you can then place your cursor within the `<groupId>` tag and
    press *Ctrl* + Spacebar. You will then get a list of possible IDs that you can
    select. When you start typing the first part (`org.`), you will notice that the
    list becomes more limited as you continue to type. When you get to `org.apache.po`,
    the list only contains two options, including the POI package. If you repeat the
    process for the remaining tags, you may end up with the following dependency section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At this point you can start to use the library and its interfaces, classes,
    and methods to create an Excel file (or Word documents and PowerPoint presentations).
    Please note that the packages for Excel files are designated with the **HSSF**
    moniker (**Horrible SpreadSheet** **Format**). After saving the POM file, you
    will get a new JAR file in your projects dependencies folder. In this, case it
    is the `poi-3.13.jar` file, and it contains the packages for the POI project.
    Make sure you build your project before proceeding further by navigating to **Run**
    | **Build Project** from the menu. We will now look at how to implement this library
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Excel file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an Excel file, we need to create a new instance of an Excel workbook
    using Apache POI. This is relatively simple using the `usermodel` package in `org.apache.poi.ss`.
    We create an instance of the Workbook interface and add a sheet with a specific
    name that will contain the data in a method we call `saveResultsToExcel`. Every
    time we add a new class, we can add our import statements automatically by pressing
    *Alt* + *Enter*. Just make sure that you select the correct ones. If you want
    to add the `Cell` class, you have multiple options, but we require the package
    for `org.apache.poi.ss.usermodel.Cell` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I assumed that the data is in the form of an ImageJ `ResultsTable`
    object. In the loop, we go over the rows and then add cells to each row, one column
    at a time. We use the headers of the results table to make a header in the Excel
    file as well. We use a separate `Font` object (`fb` in this example) to make the
    style different from the data by making it bold. At the end, we save the results
    to a file using the generic `FileOutputStream` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the results table that is generated when you press the **Measure** button
    in the ROI manager, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After asking the user for a file name, you can call the `saveResultsToExcel`
    method to generate an Excel file. The example code above works only to generate
    `.xls` files. To generate `.xlsx` files, you need to implement a workbook of the
    `XSSFWorkbook` class. The main difference between these two Excel formats is that
    the size of the data that can be contained on a sheet; `.xls` files have a limitation
    of 255 columns per sheet. If you expect to generate tables with more columns,
    you need to make sure to use the `XSSFWorkbook` class.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have finished implementing all the routines and completed (extensive)
    testing, you are ready to distribute your plugin to the world. Currently, there
    are several options available to distribute your plugin, ranging from sending
    it using e-mail to an automated update mechanism in ImageJ. Here, I will discuss
    the latter option, which has some great benefits that makes it very user-friendly
    and efficient. Fiji, and ImageJ2 have a system that allows you to set a website
    as a source for your plugin. This website will be checked to see whether there
    is a newer version available, and if so, it will be automatically updated. The
    only thing your users have to do is add that site to their list of update sites
    to install and update your plugin(s). The following sections will describe how
    to setup this site, and how users can add the site to ImageJ (ImageJ2 and Fiji,
    specifically).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a site, you have different options available: you can host your own
    update site, or you can use the ImageJ Wiki site. I will now focus on the latter
    option as it is easy, free, and accessible to everyone. Note that your users need
    to have ImageJ2 or Fiji to be able to use this mechanism. For this section, I
    will assume that you are using Fiji, but it works in a similar manner in ImageJ2\.
    To create the site, you can go to **Help** | **Update…** in the menu. In the window
    that opens, press the **Manage update sites** button on the bottom right to get
    the sites currently available.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a site](img/B04909_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can press the **Add my site** button in this window and either create a
    new account or use an existing account. If you already have an account, you only
    have to enter your user name, and if your password hasn't yet been stored, also
    enter your password. If you want to create a new account, you can enter a user
    name. If it doesn't yet exist, you can enter your e-mail address and press **OK**.
    You will receive an e-mail message on the account that you provided with a temporary
    password. You must then go to the Wiki login page at [http://imagej.net/Special:UserLogin](http://imagej.net/Special:UserLogin)
    to change your password. Once you have modified your password, you can enter it
    in the **Add personal site** window of ImageJ. You are now ready to add your plugins
    to the website.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading your plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To upload your plugin, you cannot just upload your file directly to the server.
    In order for it to be recognized as a proper update site and plugins, some additional
    files are required. Luckily, the ImageJ updater can also take care of this process
    for you. Open the updater by navigating to **Help** | **Update…** from the menu
    and click on the **Advanced mode** button. The first time you upload a plugin,
    you need to select the **View local-only files** from the **View options** drop-down
    list. You can now select your plugin on the left-hand side, and edit the details
    in the **Details** view on the right-hand side. By right-clicking on your plugin,
    you can open a context menu and select **Upload to My Site**. The **Status/Action**
    column should now display **Upload it**, and after pressing the **Apply** **changes**
    button and providing your credentials, the upload will start.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a legacy plugin from scratch using the Maven system
    and the NetBeans IDE. We applied some of the image processing techniques that
    we learned in the previous chapters in our plugin. We saw how to add a basic user
    interface to our plugin, allowing the user to change some of the parameters that
    influence the way the plugin functions. We also saw how to store our settings
    in the preferences so that they can be recalled the next time we use the plugin.
    We added an external library to provide additional functionality that was not
    present in ImageJ. Finally, we looked at an automated way of publishing our plugin
    and sharing it with the world.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the resources that are available to further
    your knowledge and skills in image processing and project development.
  prefs: []
  type: TYPE_NORMAL
