<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits and Mixin Compositions</h1>
                </header>
            
            <article>
                
<p>Before digging into some actual design patterns, we have to make sure that many of the Scala language concepts are clear to the reader. Many of those concepts will later be used in implementing the actual design patterns, and being aware of the possibilities, limitations, and pitfalls are key factors that enable us to correctly and efficiently write code. Even though those concepts are not considered <em>official</em> design patterns, they could still be used to write good software. In some cases, due to the richness of Scala, some concepts could replace a design pattern by just using language features. After all, as we have already said before, design patterns are there because a programming language lacks features and is not rich enough to complete certain tasks.</p>
<p>The first topic that we will look into is about traits and mixin compositions. They provide the developer with a possibility to share already implemented functionality or to define interfaces for classes in an application. Many of the possibilities, which are provided by traits and mixin compositions for developers, are useful to implement some of the design patterns that we will focus on later in this book. We will go through the following main topics in this chapter:</p>
<ul>
<li>Traits</li>
<li>Mixin compositions</li>
<li>Multiple inheritance</li>
<li>Linearization</li>
<li>Testing traits</li>
<li>Traits versus classes</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits</h1>
                </header>
            
            <article>
                
<p>Many of you might have different perspectives of traits in Scala. They can be viewed not only as interfaces in other languages, but also as classes with only parameter-less constructors.</p>
<div class="packt_infobox"><span class="packt_screen">Trait parameters</span><br/>
<br/>
The Scala programming language is quite dynamic and has evolved quickly throughout the years. According to the language creators, the Dotty project is the future of Scala and it is a place where passing parameters to traits and many other features are being tested and implemented. The main idea behind it is language simplification, and more information can be found at <a href="http://dotty.epfl.ch">http://dotty.epfl.ch</a> and <a href="https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html">https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html</a>.</div>
<p>In the following few sections, we will see the traits from different points of view and try to give you some ideas about how they can be used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits as interfaces</h1>
                </header>
            
            <article>
                
<p>Traits can be viewed as interfaces in other languages, for example, Java. However t<span>hey</span>, allow the developers to implement some or all of their methods. Whenever there is some code in a trait, the trait is called a <strong>mixin</strong>. Let's have a look at the following example:</p>
<pre class="mce-root">trait Alarm {<br/>  def trigger(): String<br/>}</pre>
<p class="mce-root">Here, <kbd>Alarm</kbd> is an interface. Its only method, <kbd>trigger</kbd>, does not have any implementation and if mixed in a non-abstract class, an implementation of the method will be required.</p>
<p>Let's see another trait example:</p>
<pre>trait Notifier {<br/>  val notificationMessage: String<br/><br/>  def printNotification(): Unit = {<br/>    System.out.println(notificationMessage)<br/>  }<br/><br/>  def clear()<br/>}</pre>
<p>The <kbd>Notifier</kbd> interface shown previously has one of its methods implemented, and <kbd>clear</kbd> and the value of <kbd>notificationMessage</kbd> have to be handled by the classes that will mix with the <kbd>Notifier</kbd> interface. Moreover, the traits can require a class to have a specific variable inside it. This is somewhat similar to abstract classes in other languages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixing in traits with variables</h1>
                </header>
            
            <article>
                
<p>As we just pointed out, traits might require a class to have a specific variable. An interesting use case would be when we pass a variable to the constructor of a class. This will cover the trait requirements:</p>
<pre>class NotifierImpl(val notificationMessage: String) extends Notifier {<br/>  override def clear(): Unit = System.out.println("cleared")<br/>}</pre>
<p>The only requirement here is for the variable to have the same name and to be preceded by the <kbd>val</kbd> keyword in the class definition. If we don't use <kbd>val</kbd> in front of the parameter in the preceding code, the compiler would still ask us to implement the trait. In this case, we would have to use a different name for the class parameter and would have an <kbd>override val notificationMessage</kbd> assignment in the class body. The reason for this behavior is simple: if we explicitly use <kbd>val</kbd> (or <kbd>var</kbd>), the compiler will create a field with a getter with the same scope as the parameter. If we just have the parameter, a field and internal getter will be created only if the parameter is used outside the constructor scope, for example, in a method. For completeness, case classes automatically have the <kbd>val</kbd> keyword <em>prepended</em> to parameters. After what we said it means that when using <kbd>val</kbd>, we actually have a field with the given name and the right scope, and it will automatically override whatever the trait requires us to do.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits as classes</h1>
                </header>
            
            <article>
                
<p>Traits can also be seen from the perspective of classes. In this case, they have to implement all their methods and have only one constructor that does not accept any parameters. Consider the following:</p>
<pre>trait Beeper {<br/>  def beep(times: Int): Unit = {<br/>    1 to times foreach(i =&gt; System.out.println(s"Beep number: $i"))<br/>  }<br/>}</pre>
<p>Now, we can actually instantiate <kbd>Beeper</kbd> and call its method. The following is a console application that does just this:</p>
<pre>object BeeperRunner {<br/>  val TIMES = 10<br/>  <br/>  def main (args: Array[String]): Unit = {<br/>    val beeper = new Beeper {}<br/>    beeper.beep(TIMES)<br/>  }<br/>}</pre>
<p>As expected, after running the application, we will see the following output in our Terminal:</p>
<pre><strong>Beep number: 1</strong><br/><strong>Beep number: 2</strong><br/><strong>Beep number: 3</strong><br/><strong>Beep number: 4</strong><br/><strong>Beep number: 5</strong><br/><strong>Beep number: 6</strong><br/><strong>Beep number: 7</strong><br/><strong>Beep number: 8</strong><br/><strong>Beep number: 9</strong><br/><strong>Beep number: 10</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extending classes</h1>
                </header>
            
            <article>
                
<p>It is possible for traits to extend classes. Let's have a look at the following example:</p>
<pre>abstract class Connector {<br/>  def connect()<br/>  def close()<br/>}<br/><br/>trait ConnectorWithHelper extends Connector {<br/>  def findDriver(): Unit = {<br/>    System.out.println("Find driver called.")<br/>  }<br/>}<br/><br/>class PgSqlConnector extends ConnectorWithHelper {<br/>  override def connect(): Unit = {<br/>    System.out.println("Connected...")<br/>  }<br/><br/>  override def close(): Unit = {<br/>    System.out.println("Closed...")<br/>  }<br/>}</pre>
<p>Here, as expected, <kbd>PgSqlConnector</kbd> will be obliged to implement the abstract class methods. As you can guess, we could have other traits that extend other classes and then we might want to mix them in. Scala, however, will put a limit in some cases, and we will see how it will affect us later in this chapter when we look at compositions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extending traits</h1>
                </header>
            
            <article>
                
<p>Traits can also extend each other. Have a look at the following example:</p>
<pre>trait Ping {<br/>  def ping(): Unit = {<br/>    System.out.println("ping")<br/>  }<br/>}<br/><br/>trait Pong {<br/>  def pong(): Unit = {<br/>    System.out.println("pong")<br/>  }<br/>}<br/><br/>trait PingPong extends Ping with Pong {<br/>  def pingPong(): Unit = {<br/>    ping()<br/>    pong()<br/>  }<br/>}<br/><br/>object Runner extends PingPong {<br/>  def main(args: Array[String]): Unit = {<br/>    pingPong()<br/>  }<br/>}</pre>
<div class="packt_infobox">The preceding example is simple and it should really just make the <kbd>Runner</kbd> object mix the two traits separately. Extending traits is useful in a design pattern called <strong>Stackable Traits</strong>, which we will be looking into later in this book.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixin compositions</h1>
                </header>
            
            <article>
                
<p>Scala allows developers to extend many traits in a single class. This adds the possibility of achieving multiple inheritance and saves a lot of effort in code writing, which has to be performed in languages where extending many classes is not allowed. In this subtopic, we will show how traits can be mixed in a specific class or used to create anonymous classes with some specific functionality while writing our code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixing traits in</h1>
                </header>
            
            <article>
                
<p>First of all, let's modify the code from the previous example. It is a really simple change and it will also show exactly how traits can be mixed in:</p>
<pre>object MixinRunner extends Ping with Pong {<br/>  def main(args: Array[String]): Unit = {<br/>    ping()<br/>    pong()<br/>  }<br/>}</pre>
<p>As can be seen from the preceding code, we can add multiple traits to a class. We've used objects in the example just because of the main method. This would be similar to creating a class with no constructor parameters (objects in Scala are singleton classes).</p>
<div class="packt_tip"><span class="packt_screen">How to mix traits in?</span><br/>
<p>Mixing traits into a class is done with the following syntax:<br/>
<kbd>extends T1 with T2 with … with Tn</kbd>.<br/>
If a class already extends another class, we just keep on adding the traits using the <kbd>with</kbd> keyword.<br/>
If a trait method is not implemented inside the trait body and the class we are mixing it into is not abstract, the class will have to implement the trait. Otherwise, a compilation error will occur.</p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composing</h1>
                </header>
            
            <article>
                
<p>Composing at creation time gives us an opportunity to create anonymous classes without the need to explicitly define them. Also, if there are many different traits that we might want to combine, creating all the possibilities would involve too much work, so this helps make things easier for us.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composing simple traits</h1>
                </header>
            
            <article>
                
<p>Let's see an example where we compose simple traits, which do not extend other traits or classes:</p>
<pre>class Watch(brand: String, initialTime: Long) {<br/>  def getTime(): Long = System.currentTimeMillis() - initialTime<br/>}<br/><br/>object WatchUser {<br/>  def main(args: Array[String]): Unit = {<br/>    val expensiveWatch = new Watch("expensive brand", 1000L) with Alarm with Notifier {<br/>      override def trigger(): String = "The alarm was triggered."<br/>      override def clear(): Unit = {<br/>        System.out.println("Alarm cleared.")<br/>      }<br/>      override val notificationMessage: String = "Alarm is running!"<br/>    }<br/>    val cheapWatch = new Watch("cheap brand", 1000L) with Alarm {<br/>      override def trigger(): String = "The alarm was triggered."<br/>    }<br/>    // show some watch usage.<br/>    System.out.println(expensiveWatch.trigger())<br/>    expensiveWatch.printNotification()<br/>    System.out.println(s"The time is ${expensiveWatch.getTime()}.")<br/>    expensiveWatch.clear()<br/><br/>    System.out.println(cheapWatch.trigger())<br/>    System.out.println("Cheap watches cannot manually stop the alarm...")<br/>  }<br/>}</pre>
<p class="mce-root">In the preceding example, we used the <kbd>Alarm</kbd> and <kbd>Notifier</kbd> traits from before. We created two watch instances—one is expensive that has more functionality and is more useful, and the other one is a cheap one that does not give too much control. Essentially, they are anonymous classes, which are defined during instantiation. Another thing to note is that, as expected, we have to implement the abstract methods from the traits we include. I hope this gives you an idea of how many combinations there might be in the cases where we have more traits.</p>
<p class="mce-root">Just for the sake of completeness, here is an example output of the preceding program:</p>
<pre>The alarm was triggered.<br/>Alarm is running!<br/><strong>The time is 1234567890562.</strong><br/>Alarm cleared.<br/>The alarm was triggered.<br/>Cheap watches cannot manually stop the alarm...</pre>
<p>As expected, the highlighted time value will be different in the different runs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composing complex traits</h1>
                </header>
            
            <article>
                
<p>It is possible that in some cases, we would have to compose more complex traits, which extend other traits or classes. If a trait and no other trait up the inheritance chain extends a specific class explicitly, then things will be pretty simple and they don't change much. In this case, we would simply have access to the methods from the super traits. However, let's see what happens if any of the traits in the hierarchy extend a specific class. For the next example, we will be using the <kbd>ConnectorWithHelper</kbd> trait defined previously. This trait extends the abstract <kbd>Connector</kbd> class. Imagine that we want to have another really expensive smart watch, which can also connect to a database:</p>
<pre>object ReallyExpensiveWatchUser {<br/>  def main(args: Array[String]): Unit = {<br/>    val reallyExpensiveWatch = new Watch("really expensive brand", 1000L) with ConnectorWithHelper {<br/>      override def connect(): Unit = {<br/>        System.out.println("Connected with another connector.")<br/>      }<br/>      override def close(): Unit = {<br/>        System.out.println("Closed with another connector.")<br/>      }<br/>    }<br/><br/>    System.out.println("Using the really expensive watch.")<br/>    reallyExpensiveWatch.findDriver()<br/>    reallyExpensiveWatch.connect()<br/>    reallyExpensiveWatch.close()<br/>  }<br/>}</pre>
<p>It seems that everything is fine; however, when we compile, we get the following error message:</p>
<pre class="mce-root">Error:(36, 80) illegal inheritance; superclass Watch<br/> is not a subclass of the superclass Connector<br/> of the mixin trait ConnectorWithHelper<br/>    val reallyExpensiveWatch = new Watch("really expensive brand", 1000L) with ConnectorWithHelper {<br/>^</pre>
<p>This error message tells us that since the <kbd>ConnectorWithHelper</kbd> trait extends the <kbd>Connector</kbd> class, all the classes that use this trait for composition must be subclasses of <kbd>Connector</kbd>. Let's now imagine that we wanted to mix in another trait that also extends a class, but a different one in this case. According to the preceding logic, it will be required that <kbd>Watch</kbd> should also be a subclass of the other class. This, however, wouldn't be possible, as we can only extend one class at a time and this is how Scala limits multiple inheritance in order to prevent dangerous errors from happening.</p>
<p>If we want to fix the compilation issue in the example, we will have to modify the original <kbd>Watch</kbd> class and make sure it is a subclass of <kbd>Connector</kbd>. This, however, might not be desired and some refactoring might be needed in such cases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composing with self-types</h1>
                </header>
            
            <article>
                
<p>In the previous subsection, we saw how we were forced to extend <kbd>Connector</kbd> in our <kbd>Watch</kbd> class in order to properly compile our code. There are cases where we might actually want to enforce a trait to be mixed into a class that also has another trait or multiple traits mixed into it. Let's imagine that we want to have an alarm that must be able to notify us, no matter what:</p>
<pre class="mce-root">trait AlarmNotifier {<br/>  this: Notifier =&gt;<br/>  <br/>  def trigger(): String<br/>}</pre>
<p>In the preceding code, we've shown a <strong>self-type</strong>. The highlighted piece of code brings all the methods of <kbd>Notifier</kbd> to the scope of our new trait and it also requires that any class that mixes in <kbd>AlarmNotifier</kbd> should also mix in <kbd>Notifier</kbd>. Otherwise, a compilation error will occur. Instead of this, we can use <kbd>self</kbd> and then refer to the <kbd>Notifier</kbd> methods inside <kbd>AlarmNotifier</kbd> by typing, for example, <kbd>self. printNotification()</kbd>.</p>
<p>The following code is an example of how to use the new trait:</p>
<pre>object SelfTypeWatchUser {<br/>  def main(args: Array[String]): Unit = {<br/>    // uncomment to see the self-type error.<br/>    // val watch = new Watch("alarm with notification", 1000L) with AlarmNotifier {<br/>    //}<br/>    val watch = new Watch("alarm with notification", 1000L) with AlarmNotifier with Notifier {<br/>      override def trigger(): String = "Alarm triggered."<br/><br/>      override def clear(): Unit = {<br/>        System.out.println("Alarm cleared.")<br/>      }<br/><br/>      override val notificationMessage: String = "The notification."<br/>    }<br/><br/>    System.out.println(watch.trigger())<br/>    watch.printNotification()<br/>    System.out.println(s"The time is ${watch.getTime()}.")<br/>    watch.clear()<br/>  }<br/>}</pre>
<p class="mce-root">If we comment out the <kbd>watch</kbd> variable in the preceding code and uncomment the commented bit, we will see a compilation error that is raised due to the fact that we must also mix <kbd>Notifier</kbd> in.</p>
<p>In this subsection, we showed a simple use of self-types. One trait can require multiple other traits to be mixed in. In such cases, they are just separated with the <kbd>with</kbd> keyword. Self-types are a key part of the <strong>cake design pattern</strong>, which is used for dependency injection. We will see more interesting use cases later in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Clashing traits</h1>
                </header>
            
            <article>
                
<p>Some of you might already have a question in your mind—what if we mix in traits that have methods with identical signatures? We will look at this in the next few sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Same signatures and return types</h1>
                </header>
            
            <article>
                
<p>Consider an example where we want to mix two traits into a class and their declaration of a method is identical:</p>
<pre>trait FormalGreeting {<br/>  def hello(): String<br/>}<br/><br/>trait InformalGreeting {<br/>  def hello(): String<br/>}<br/><br/>class Greeter extends FormalGreeting with InformalGreeting {<br/>  override def hello(): String = "Good morning, sir/madam!"<br/>}<br/><br/>object GreeterUser {<br/>  def main(args: Array[String]): Unit = {<br/>    val greeter = new Greeter()<br/>    System.out.println(greeter.hello())<br/>  }<br/>}</pre>
<p class="mce-root">In the preceding example, the greeter is always polite and mixes both formal and informal greetings. While implementing, it just has to implement the method once.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Same signatures and different return types traits</h1>
                </header>
            
            <article>
                
<p>What if our greeting traits have more methods that have the same signatures, but a different return type? Let's add the following declaration to <kbd>FormalGreeting</kbd>:</p>
<pre>def getTime(): String</pre>
<p>Also, add the following to <kbd>InformalGreeting</kbd>:</p>
<pre>def getTime(): Int</pre>
<p>We will have to implement these in our <kbd>Greeter</kbd> class. However, the compiler will not allow us the message that <kbd>getTime</kbd> was defined twice in, which shows that Scala prevents such things from happening.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Same signatures and return types mixins</h1>
                </header>
            
            <article>
                
<p>Before going further, a quick reminder that a mixin is just a trait that has some code implemented inside. This means that in the following examples, we do not have to implement the methods inside the class that uses them.</p>
<p>Let's have a look at the following example:</p>
<pre class="mce-root">trait A {<br/>  def hello(): String = "Hello, I am trait A!"<br/>}<br/><br/>trait B {<br/>  def hello(): String = "Hello, I am trait B!"<br/>}<br/><br/>object Clashing extends A with B {<br/>  def main(args: Array[String]): Unit = {<br/>    System.out.println(hello())<br/>  }<br/>}</pre>
<p>Probably as expected, our compilation will fail with the following message:</p>
<pre>Error:(11, 8) object Clashing inherits conflicting members:<br/>  method hello in trait A of type ()String and<br/>  method hello in trait B of type ()String<br/><strong>(Note: this can be resolved by declaring an override in object Clashing.)</strong><br/><strong>object Clashing extends A with B {</strong><br/><strong>       ^</strong></pre>
<p class="mce-root">The message is useful and it even gives us a hint about how to fix the problem. Clashing methods is a problem in multiple inheritances, but as you can see, we are forced to pick one of the available methods. Here is a possible fix inside the <kbd>Clashing</kbd> object:</p>
<pre>override def hello(): String = super[A].hello()</pre>
<p>However, what if we want to use both the <kbd>hello</kbd> methods for some reason? In this case, we can create other methods that are named differently and call the specific traits as in the preceding example (the <kbd>super</kbd> notation). We can also directly refer to the methods with the <kbd>super</kbd> notation instead of wrapping them in a method. My personal preference, though, would be to wrap it, as the code could get messy otherwise.</p>
<div class="mce-root packt_tip"><span class="packt_screen">The super notation</span><br/>
<br/>
What would happen if in the preceding example, instead of <kbd>super[A]. hello()</kbd>, we do the following: <kbd>override def hello(): String = super.hello()</kbd>?<br/>
Which hello method will be called and why? In the current case, it will be the one in the <kbd>B</kbd> trait and the output will be <kbd>Hello, I am trait B!</kbd> This depends on linearization in Scala, and we will be looking at this later in this chapter.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Same signatures and different return types mixins</h1>
                </header>
            
            <article>
                
<p>As expected, the previous problem does not exist when input parameters to the methods differ either by type or by count since this is a new signature. However, the problem will still be there if we have the following two methods in our traits:</p>
<pre class="mce-root">def value(a: Int): Int = a // in trait A<br/>def value(a: Int): String = a.toString // in trait B</pre>
<p>You will be surprised to see that the approach we used will not work here. If we decide to override only the value method in the <kbd>A</kbd> trait, we will get the following compilation error:</p>
<pre>Error:(19, 16) overriding method value in trait B of type (a: Int)String;<br/> method value has incompatible type<br/>  override def value(a: Int): Int = super[A].value(a)<br/>               ^</pre>
<p class="mce-root">If we override the <kbd>value</kbd> method in the <kbd>B</kbd> trait, the error will change respectively.</p>
<p>If we try and override both, then the error will be as follows:</p>
<pre>Error:(20, 16) method value is defined twice<br/>  conflicting symbols both originated in file '/path/to/traits/src/main/scala/com/ivan/nikolov/composition/Clashing.scala'<br/>  override def value(a: Int): String = super[B].value(a)</pre>
<p>This shows that Scala actually prevents us from doing some dangerous things that can occur in multiple inheritance. For the sake of completeness, if you face a similar issue, there is a workaround (by sacrificing the mix in functionality). It will look as follows:</p>
<pre>trait C {<br/>  def value(a: Int): Int = a<br/>}<br/><br/>trait D {<br/>  def value(a: Int): String = a.toString<br/>}<br/><br/>object Example {<br/><br/>  val c = new C {}<br/>  val d = new D {}<br/><br/>  def main (args: Array[String]): Unit = {<br/>    System.out.println(s"c.value: ${c.value(10)}")<br/>    System.out.println(s"d.value: ${d.value(10)}")<br/>  }<br/>}</pre>
<p class="mce-root">The preceding code uses traits as collaborators, but it also loses the fact that the class that uses them is also an instance of the trait type, which can be useful for other operations as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Multiple inheritance</h1>
                </header>
            
            <article>
                
<p>We inevitably had to mention multiple inheritance in the previous sections due to the fact that we can mix multiple traits and they can all have their own implementations of the methods. Multiple inheritance is not only a powerful technique, but also a dangerous one, and some languages such as Java have decided to not even allow it. As we already saw, Scala allows this, but with some limitations. In this subsection, we will present the problems of multiple inheritance and show how Scala deals with them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The diamond problem</h1>
                </header>
            
            <article>
                
<p>Multiple inheritance suffers from the <strong>diamond problem</strong>.</p>
<p>Let's have a look at the following diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/4440c811-73f7-4033-8106-54ec31594489.png" style="width:14.75em;height:17.00em;" width="240" height="276"/></div>
<p>Here, both <strong>B</strong> and <strong>C</strong> extend <strong>A</strong>, and then <strong>D</strong> extends <strong>B</strong> and <strong>C</strong>. Some ambiguities might arise from this. Let's say that there was a method that was originally defined in <strong>A</strong>, but both <strong>B</strong> and <strong>C</strong> override it. What would happen if <strong>D</strong> calls this method? Which one will it exactly call?</p>
<p>All the preceding questions make things ambiguous and this could lead to mistakes. Let's try and reproduce this in Scala using traits:</p>
<pre class="mce-root">trait A {<br/>  def hello(): String = "Hello from A"<br/>}<br/><br/>trait B extends A {<br/>  override def hello(): String = "Hello from B"<br/>}<br/><br/>trait C extends A {<br/>  override def hello(): String = "Hello from C"<br/>}<br/><br/>trait D extends B with C {<br/><br/>}<br/><br/>object Diamond extends D {<br/>  def main(args: Array[String]): Unit = {<br/>    System.out.println(hello())<br/>  }<br/>}</pre>
<p>What would be the output of the program? Here is the output:</p>
<pre><strong>Hello from C</strong></pre>
<p>What if we just change the <kbd>D</kbd> trait to look as follows:</p>
<pre>trait D extends C with B {<br/><br/>}</pre>
<p>Then the output of our program will be as follows:</p>
<pre><strong>Hello from B</strong></pre>
<p>As you can see, even though the example is still ambiguous and prone to errors, we can actually tell exactly which method will be called. This is achieved using linearization, which we will look at in greater depth in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The limitations</h1>
                </header>
            
            <article>
                
<p>Before focusing on linearization, let's point out the multiple inheritance limitations that Scala imposes. We already saw many of them before, so here we will simply summarize them.</p>
<div class="packt_infobox">
<p><span class="packt_screen">Scala multiple inheritance limitations</span></p>
<p>Multiple inheritance in Scala is achieved using traits and it follows the rules of linearization.<br/>
In the inheritance hierarchy, if there is a trait that explicitly extends a class, the class that mixes in this trait must also be a subclass of the trait parent. This means that when mixing in traits that extend classes, they must all have the same parent.<br/>
It is not possible to mix traits in, which define or declare methods with the same signatures, but different return types.</p>
</div>
<p>Special care has to be taken when multiple traits define methods with the same signatures and return types. In cases where the methods are declared and expected to be implemented, this is not an issue and only one implementation is enough.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linearization</h1>
                </header>
            
            <article>
                
<p>As we already saw, traits offer a form of multiple inheritance. In such cases, the hierarchy is not necessarily linear, but forms an acyclic graph that needs to be flattened upon compilation. What linearization does is this—it specifies a single linear order for all of the ancestors of a class, including both the regular superclass chain and the parent chains of all of the traits.</p>
<p>We will not have to deal with linearization in traits that contain no code. However, if we use mixins, we will have to consider it. The following will be affected by linearization:</p>
<ul>
<li>Method definitions</li>
<li>Variables (both mutable—<kbd>var</kbd> and immutable—<kbd>val</kbd>)</li>
</ul>
<p>We already saw a simple example of linearization previously. Things, however, can get much more complicated and unexpected if the rules of linearization are not clear.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rules of inheritance hierarchies</h1>
                </header>
            
            <article>
                
<p>Before looking into linearization rules, we need to be clear on some inheritance rules in Scala:</p>
<ul>
<li>In Java, even if a class does not explicitly extend another one, its superclass will be <kbd>java.lang.Object</kbd>. The same stands for Scala, and the equivalent base is <kbd>AnyRef</kbd>.</li>
<li>There is a similarity between directly extending a trait and extending the trait superclass and mixing the trait in using the <kbd>with</kbd> keyword.</li>
</ul>
<div class="packt_infobox">In older Scala versions, there was another type called <kbd>ScalaObject</kbd> that was implicitly added to all traits and classes.</div>
<p>Using those rules, we can always get to a canonical form for all traits and classes, where the base class is specified using <kbd>extends</kbd> and then all traits are added using the <kbd>with</kbd> keyword.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linearization rules</h1>
                </header>
            
            <article>
                
<p>Linearization rules in Scala are defined and exist in order to ensure well-defined behavior. The rules state the following:</p>
<ul>
<li>The linearization of any class must include the unmodified linearization of any <em>class</em> (but not trait) that it extends.</li>
<li>The linearization of any class must include all the classes and mixin traits in the linearization of any <em>trait</em> it extends, but the mixin traits are not bound to appear in the same order as they appear in the linearization of the traits being mixed in.</li>
<li>Each class or trait in the linearization can appear only once. Duplicates are ignored.</li>
</ul>
<p>We already saw in some of the previous examples that it is not possible to mix in traits that have different base classes or to mix in a trait into a class when their base classes differ.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How linearization works</h1>
                </header>
            
            <article>
                
<p>In Scala, linearizations are listed from left to right where the right-most class is the most general, for example, <kbd>AnyRef</kbd>. While doing linearization, <kbd>Any</kbd> is also added to the hierarchy list. This, combined with the rule that any class must include the linearization of its superclass, means that the superclass linearization will appear as a suffix of the class linearization.</p>
<p>Let's see an example with some really simple classes:</p>
<pre>class Animal extends AnyRef<br/>class Dog extends Animal</pre>
<p>The linearization of these two classes will be, respectively:</p>
<pre>Animal -&gt; AnyRef -&gt; Any<br/>Dog -&gt; Animal -&gt; AnyRef -&gt; Any</pre>
<p>Now, let's try and formalize an algorithm that describes how a linearization is calculated:</p>
<ol>
<li>Start with the following class declaration—<kbd>class A extends B with T1 with T2</kbd>.</li>
<li>Reverse the order of the list except the first item and drop the keywords. This way, the superclass will come as a suffix—<kbd>A T2 T1 B</kbd>.</li>
<li>Each item gets replaced with its linearization—<kbd>A T2L T1L BL</kbd>.</li>
</ol>
<ol start="4">
<li>Concatenate the list elements using the right-associative concatenation operation: <kbd>A +: T2L +: T1L +: BL</kbd>.</li>
<li>Append the standard <kbd>AnyRef</kbd> and <kbd>Any</kbd> classes—<kbd>A +: T2L +: T1L +: BL +: AnyRef +: Any</kbd>.</li>
<li>Evaluate the preceding expression. Due to the right-associative concatenation, we start from the right and move to the left. In each step, we remove any element that has already appeared on the right-hand side. In our case, when we get to <kbd>BL</kbd>, we will not add <kbd>AnyRef</kbd> and <kbd>Any</kbd> that it also contains; we will just add <kbd>BL</kbd> and then we will continue. At <kbd>T1L</kbd>, we will skip the step to add anything that was added before and so on, until we reach <kbd>A</kbd>.</li>
</ol>
<p>In the end, after the linearization finishes, we will have a list of classes and traits without duplicates.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Initialization</h1>
                </header>
            
            <article>
                
<p>Now that we know what happens during linearization, we will understand how instances are being created. The rule is that the constructor code is executed in a reverse order compared to the linearization order. This means that, going from right to left, first the <kbd>Any</kbd> and <kbd>AnyRef</kbd> constructors will be invoked and then the actual class constructor will be called. Also, the superclass constructor will be called before the actual class or any of its mixins because, as we have already mentioned previously, it is added as a suffix.</p>
<p>Keeping in mind that we traverse the linearization from right to left also means that after the superclass constructor is called, the mixin trait constructors will be called. Here, they will be called in the order in which they appear in the original class definition (because of the right to left direction and the fact that their order is reversed when the linearization is created).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Method overriding</h1>
                </header>
            
            <article>
                
<p>When overriding a method in a subclass, you may want to call the original implementation as well. This is achieved by prefixing the <kbd>super</kbd> keyword to the method name. The developer also has control to qualify the <kbd>super</kbd> keyword with a trait type, thus calling the method in the specific trait. We already saw an example of this earlier in the chapter, where we called <kbd>super[A].hello()</kbd>. In that example, we had mixins with the same methods; however, the methods themselves did not refer to <kbd>super</kbd>, but just defined their own implementations.</p>
<p>Let's see an example here, where we actually refer to the <kbd>super</kbd> class when overriding a method:</p>
<pre class="mce-root">class MultiplierIdentity {<br/>  def identity: Int = 1<br/>}</pre>
<p>Let's now define two traits that respectively double and triple the identity in our original class:</p>
<pre class="mce-root">trait DoubledMultiplierIdentity extends MultiplierIdentity {<br/>  override def identity: Int = 2 * super.identity<br/>}<br/><br/>trait TripledMultiplierIdentity extends MultiplierIdentity {<br/>  override def identity: Int = 3 * super.identity<br/>}</pre>
<p>As we saw in some of the previous examples, the order in which we mix in the traits matters. We will provide three implementations, where we first mix in <kbd>DoubledMultiplierIdentity</kbd> and then <kbd>TripledMultiplierIdentity</kbd>. The first one will not override the identity method, which is equivalent to using the following super notation: <kbd>super.identity</kbd>. The other two will override the method and will refer to a specific parent:</p>
<pre class="mce-root">// first Doubled, then Tripled<br/>class ModifiedIdentity1 extends DoubledMultiplierIdentity with TripledMultiplierIdentity<br/><br/>class ModifiedIdentity2 extends DoubledMultiplierIdentity with TripledMultiplierIdentity {<br/>  override def identity: Int = super[DoubledMultiplierIdentity].identity<br/>}<br/><br/>class ModifiedIdentity3 extends DoubledMultiplierIdentity with TripledMultiplierIdentity {<br/>  override def identity: Int = super[TripledMultiplierIdentity].identity<br/>}<br/>// first Doubled, then Tripled</pre>
<p>Let's do the same thing as shown in the preceding code, but this time, we first mix in <kbd>TripledMultiplierIdentity</kbd> and then <kbd>DoubledMultiplierIdentity</kbd>. The implementations are similar to the preceding ones:</p>
<pre>// first Tripled, then Doubled<br/>class ModifiedIdentity4 extends TripledMultiplierIdentity with DoubledMultiplierIdentity<br/><br/>class ModifiedIdentity5 extends TripledMultiplierIdentity with DoubledMultiplierIdentity {<br/>  override def identity: Int = super[DoubledMultiplierIdentity].identity<br/>}<br/><br/>class ModifiedIdentity6 extends TripledMultiplierIdentity with DoubledMultiplierIdentity {<br/>  override def identity: Int = super[TripledMultiplierIdentity].identity<br/>}<br/>// first Tripled, then Doubled</pre>
<p class="mce-root">Finally, let's use our classes:</p>
<pre class="mce-root">object ModifiedIdentityUser {<br/>  def main(args: Array[String]): Unit = {<br/>    val instance1 = new ModifiedIdentity1<br/>    val instance2 = new ModifiedIdentity2<br/>    val instance3 = new ModifiedIdentity3<br/>    val instance4 = new ModifiedIdentity4<br/>    val instance5 = new ModifiedIdentity5<br/>    val instance6 = new ModifiedIdentity6<br/><br/>    System.out.println(s"Result 1: ${instance1.identity}")<br/>    System.out.println(s"Result 2: ${instance2.identity}")<br/>    System.out.println(s"Result 3: ${instance3.identity}")<br/>    System.out.println(s"Result 4: ${instance4.identity}")<br/>    System.out.println(s"Result 5: ${instance5.identity}")<br/>    System.out.println(s"Result 6: ${instance6.identity}")<br/>  }<br/>}</pre>
<p>The example shows a multiple inheritance hierarchy, where we can see a diamond relationship exactly as in the previous figure in which we explained what it means. We have all the possibilities here in terms of the order of mixing <kbd>DoubledMultiplier</kbd> and <kbd>TripledMultiplier</kbd>, as well as how we call the identity base method.</p>
<p>So, what would the output of this program be? One would expect that in the cases where we don't override the identity method, it would call the identity method of the right-most trait. Since in both the cases they call the super method of the class they extend, the results should be <kbd>2</kbd> and <kbd>3</kbd>. Let's see this here:</p>
<pre class="mce-root"><strong>Result 1: 6</strong><br/><strong>Result 2: 2</strong><br/><strong>Result 3: 6</strong><br/><strong>Result 4: 6</strong><br/><strong>Result 5: 6</strong><br/><strong>Result 6: 3</strong></pre>
<p>The preceding output is rather unexpected. This is, however, how the Scala type system works. In the case of linearization, where we have a multiple inheritance, the calls to the same method are chained from right to left according to the order of the appearance of the traits in the class declaration. Note that if we did not use the super notation, we would have broken the chain, as can be seen in some of the preceding examples.</p>
<div class="packt_infobox">
<div>The previous example is rather amusing and proves how important it is to know the rules of linearization and how linearization works. Not being aware of this feature could result in a serious pitfall, which could lead to critical mistakes in your code.</div>
<div>My advice would still be to try and avoid cases of diamond inheritance, even though one can argue that this way, some quite complex systems can be implemented seamlessly and without writing too much code. A case such as the preceding one could make the programs really hard to read and maintain in the future.</div>
<div>You should be aware that linearization exists everywhere in Scala—not just when dealing with traits. This is just how the Scala-type system works. This means that it is a good idea to be aware of the order in which constructors are called in order to avoid mistakes and generally, to try and keep the hierarchies relatively simple.</div>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing traits</h1>
                </header>
            
            <article>
                
<p>Testing is a really important part of software development. It ensures that changes to a certain piece of code do not end up producing errors either in the methods that were changed, or somewhere else.</p>
<p>There are different testing frameworks that one can use, and it really is a matter of personal preference. In this book, we have used <strong>ScalaTest</strong> (<a href="http://www.scalatest.org">http://www.scalatest.org</a>), as this is the one I use in my projects; it is understandable, readable, and easy to use.</p>
<p>In some cases, if a trait is mixed into a class, we could end up testing the class. However, we might want to test only a specific trait. It does not make much sense to test a trait that doesn't have all its methods implemented, so here we will look into the ones that have their code written (mixins). Also, the unit tests that we will show here are quite simple, but they are just for illustration purposes. We will be looking into more complex and meaningful tests in the following chapters of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using a class</h1>
                </header>
            
            <article>
                
<p>Let's have a look at how <kbd>DoubledMultiplierIdentity</kbd>, which we saw previously, would be tested. One would try to simply mix the trait into a test class and test the methods:</p>
<pre>class DoubledMultiplierIdentityTest extends FlatSpec with ShouldMatchers with DoubledMultiplierIdentity</pre>
<p>This, however, won't compile and will lead to the following error:</p>
<pre class="mce-root">Error:(5, 79) illegal inheritance; superclass FlatSpec<br/> is not a subclass of the superclass MultiplierIdentity<br/> of the mixin trait DoubledMultiplierIdentity<br/>class DoubledMultiplierIdentityTest extends FlatSpec with ShouldMatchers with DoubledMultiplierIdentity {<br/>^</pre>
<p>We already talked about this before and the fact that a trait can only be mixed in a class that has the same super class as itself. This means that in order to test the trait, we should create a dummy class inside our test class and then use it:</p>
<pre>package com.ivan.nikolov.linearization<br/><br/>import org.scalatest.{ShouldMatchers, FlatSpec}<br/><br/>class DoubledMultiplierIdentityTest extends FlatSpec with ShouldMatchers {<br/><br/>  class DoubledMultiplierIdentityClass extends DoubledMultiplierIdentity<br/><br/>  val instance = new DoubledMultiplierIdentityClass<br/><br/>  "identity" should "return 2 * 1" in {<br/>    instance.identity should equal(2)<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixing the trait in</h1>
                </header>
            
            <article>
                
<p>We can test a trait by mixing it in. There are a few places where we can do this—into a test class or into separate test cases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixing into the test class</h1>
                </header>
            
            <article>
                
<p>Mixing in a trait into a test class is only possible if the trait does not extend any other class explicitly, hence the super class of the trait and the test will be the same. Other than this, everything else is absolutely the same as done previously.</p>
<p>Let's test the <kbd>A</kbd> trait from earlier in this chapter, which says <kbd>hello</kbd>. We've also added an extra <kbd>pass</kbd> method, and now the trait looks as follows:</p>
<pre class="mce-root">trait A {<br/>  def hello(): String = "Hello, I am trait A!"<br/>  def pass(a: Int): String = s"Trait A said: 'You passed $a.'"<br/>}</pre>
<p>This is what the unit test will look like:</p>
<pre><span>package </span>com.ivan.nikolov.composition<br/><br/><span>import </span>org.scalatest.{FlatSpec<span>, </span>Matchers}<br/><br/><span>class </span>TraitATest <span>extends </span>FlatSpec <span>with </span>Matchers <span>with </span>A {<br/><br/>  <span>"hello" </span>should <span>"greet properly." </span>in {<br/>    hello() should equal(<span>"Hello, I am trait A!"</span>)<br/>  }<br/>  <br/>  <span>"pass" </span>should <span>"return the right string with the number." </span>in {<br/>    pass(<span>10</span>) should equal(<span>"Trait A said: 'You passed 10.'"</span>)<br/>  }<br/>  <br/>  it should <span>"be correct also for negative values." </span>in {<br/>    pass(-<span>10</span>) should equal(<span>"Trait A said: 'You passed -10.'"</span>)<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixing into the test cases</h1>
                </header>
            
            <article>
                
<p>We can also mix traits into the individual test cases separately. This could allow us to apply customizations specific to those test cases only. The following is just a different representation of the preceding unit test:</p>
<pre><span>package </span>com.ivan.nikolov.composition<br/><br/><span>import </span>org.scalatest.{FlatSpec<span>, </span>Matchers}<br/><br/><span>class </span>TraitACaseScopeTest <span>extends </span>FlatSpec <span>with </span>Matchers {<br/>  <span>"hello" </span>should <span>"greet properly." </span>in <span>new </span>A {<br/>    hello() should equal(<span>"Hello, I am trait A!"</span>)<br/>  }<br/><br/>  <span>"pass" </span>should <span>"return the right string with the number." </span>in <span>new </span>A {<br/>    pass(<span>10</span>) should equal(<span>"Trait A said: 'You passed 10.'"</span>)<br/>  }<br/><br/>  <span>it </span>should <span>"be correct also for negative values." </span>in <span>new </span>A {<br/>    pass(-<span>10</span>) should equal(<span>"Trait A said: 'You passed -10.'"</span>)<br/>  }<br/>}</pre>
<p>As you can see in the preceding code, the test cases are identical to the previous ones. They, however, individually mix <kbd>A</kbd> in. This would allow us to apply different customizations in the cases where a trait requires an implementation of a method or a variable initialization. This way, we can also focus specifically on the trait being tested, rather than creating actual instances of it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running the tests</h1>
                </header>
            
            <article>
                
<p>After the tests are written, it is useful to run them in order to see whether everything works as expected. If you're using Maven, just run the following command from the root of your project and it will execute all the tests:</p>
<pre><strong>mvn clean test</strong></pre>
<p>If you're using SBT, then the tests can be triggered using the following command:</p>
<pre><strong>sbt test</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits versus classes</h1>
                </header>
            
            <article>
                
<p>Traits could be similar, but also very different to classes. It could be hard for a developer to choose which one to use in various cases, but here we will try to provide some general guidelines that should help.</p>
<p><strong>Use classes</strong>:</p>
<ul>
<li>When a behavior is not going to be reused at all or in multiple places</li>
<li>When you plan to use your Scala code from another language, for example, if you are building a library that could be used in Java</li>
</ul>
<p><strong>Use traits</strong>:</p>
<ul>
<li>When a behavior is going to be reused in multiple unrelated classes.</li>
<li>When you want to define interfaces and want to use them outside Scala, for example, Java. The reason is that the traits that do not have any implementations are compiled similar to interfaces.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we went through traits and mixin compositions in Scala. By now, you should have a good understanding of what these are and what can be achieved by using them. We also went through the examples of the different uses of traits and what to watch out for when using them. We presented the limitations of using traits for multiple inheritance. Traits are an extremely powerful concept, but they have their pitfalls as we saw with multiple inheritance, so you should use them carefully. Linearization was covered in depth and you should be familiar with what to expect when using traits for multiple inheritance and why things work exactly the way they currently do.</p>
<p>Testing is an essential part of every good software project, and we also presented how it should be done for traits. Last, but not least, we prepared a few guidelines that should help developers choose between working with traits or classes in Scala.</p>
<p>In the next chapter, we will spend some time on <strong>unification</strong>. We will show why it is useful and what it helps the developer to achieve in their programs.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  </body></html>