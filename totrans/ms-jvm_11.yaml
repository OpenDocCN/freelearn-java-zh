- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JVM Ecosystem and Alternative JVMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JVM is the cornerstone of Java’s *write once, run anywhere* philosophy,
    enabling the execution of Java bytecode on diverse platforms. While the HotSpot
    JVM has long been the stalwart choice, the expansive JVM ecosystem extends far
    beyond, offering alternative implementations that cater to specific needs and
    performance considerations. In this chapter, we’ll explore the JVM landscape comprehensively,
    delving into alternative JVMs such as OpenJ9 and Correto. As we unravel their
    nuances, you will gain valuable insights into the diverse options available, each
    with unique features, optimizations, and trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey commences with an in-depth overview of these alternative JVMs, shedding
    light on their architectures and critical differentiators. Subsequent sections
    delve into the performance characteristics and benchmarks that distinguish these
    implementations, providing a nuanced understanding of how alternative JVMs stack
    up against the conventional HotSpot. Through real-world performance metrics, we
    aim to empower you with the knowledge to make informed decisions tailored to your
    specific use cases. Additionally, we’ll explore practical scenarios and use points
    where alternative JVMs shine, showcasing their strengths in various application
    domains. This chapter will also discuss the seamless integration of these JVMs
    with Java applications, offering insights into compatibility, tooling support,
    and interoperability. Finally, we’ll wrap up with essential considerations that
    guide the judicious selection of a JVM, ensuring that you are equipped to navigate
    the complexities of the JVM ecosystem with confidence and precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The diversity of the JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse J9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Corretto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azul Zulu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IBM Semeru
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse Temurin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even more JVM vendors and SDKMan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diversity of the JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A captivating exploration of the JVM and its remarkable tapestry is interwoven
    within the programming world. While Java often takes center stage, the JVM’s true
    prowess lies in its versatility, extending far beyond a mere executor of Java
    bytecode. Contrary to popular belief, the JVM is not a monolithic entity but a
    testament to diversity, accommodating a rich ecosystem of alternative implementations
    and vendors. Let’s embark on a journey to uncover the manifold facets of the JVM
    that make it an unparalleled force in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being the bedrock of Java, the JVM is not confined to a single language.
    Its extensibility has paved the way for many programming languages to flourish
    under its aegis. From Kotlin and Scala to Groovy and Clojure, the JVM acts as
    a unifying platform that fosters an environment where developers can seamlessly
    harness the power of different languages. Moreover, the landscape of JVM distributors
    is a testament to the ecosystem’s robustness. Beyond Oracle’s HotSpot JVM, there’s
    a tapestry of alternatives, each bringing its unique blend of optimizations, features,
    and licensing models. In fact, over the JVM’s storied history, more than 20 implementations
    have emerged, catering to diverse needs and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most remarkable aspects of the JVM is its ability to transcend the
    boundaries of languages and vendors. Thanks to meticulously crafted specifications,
    developers can write code in one JVM implementation and confidently execute it
    in another, regardless of vendor disparities. This interoperability fosters code
    reuse and promotes an ecosystem where innovation can thrive. As we navigate this
    section, we’ll explore how the JVM’s universal bridge enables developers to compile
    code on one JVM and seamlessly run it on another, underscoring the platform’s
    adaptability and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: The question of why there are multiple JVM implementations when code can seamlessly
    run across them is a multifaceted exploration of software development’s diverse
    needs and specialized contexts. While the ability to run code across different
    JVMs promotes interoperability, multiple implementations stem from the desire
    to cater to specific use cases, optimize performance, and adapt to varying hardware
    and software environments. It’s important to note that most distributions are
    not different JVM implementations but builds of the OpenJDK project, sometimes
    with slight modifications. Additionally, all distributions must succeed in the
    Java **Technology Compatibility Kit** (**TCK**) ([https://foojay.io/pedia/tck/](https://foojay.io/pedia/tck/)),
    ensuring they adhere to Java standards and maintain compatibility across the Java
    ecosystem. The sources of OpenJDK are available at [https://github.com/openjdk/jdk/](https://github.com/openjdk/jdk/),
    and you can even build the runtime yourself by following the instructions in the
    “building” file. This stringent requirement ensures developers can rely on consistent
    behavior and functionality, regardless of the distribution chosen when running
    their Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Each JVM possesses unique strengths that can be harnessed in specific contexts,
    making them powerful tools for developers. Consider, for instance, the OpenJ9
    JVM. Its emphasis on resource efficiency and swift startup times makes it a compelling
    choice for cloud-based applications, where responsiveness and resource utilization
    are critical factors. On the other hand, Amazon Corretto, with its focus on **long-term
    support** (**LTS**) and seamless integration with **Amazon Web Services** (**AWS**),
    is well-suited for enterprises deeply entrenched in the AWS ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the JVM’s adaptability extends to the hardware level. The ability
    to run the same code on diverse platforms, whether on Lego Mindstorms or specific
    hardware such as OpenSolaris, exemplifies the JVM’s portability. It simplifies
    the development process and empowers developers to create applications seamlessly
    transitioning between different environments without compromising functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The power of each JVM lies in its ability to execute code and in the optimizations
    and features it brings to the table. For instance, GraalVM, known for its **just-in-time**
    (**JIT**) compiler and polyglot capabilities, opens the door to language interoperability,
    allowing developers to seamlessly integrate languages such as JavaScript, Python,
    and Ruby into their Java applications. This versatility is invaluable in scenarios
    where diverse languages must coexist within a single code base.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the existence of multiple JVMs is a testament to the adaptability
    and diversity of the Java ecosystem. Developers can leverage these implementations
    to tailor their choices based on performance requirements, integration needs,
    and the specific characteristics of the target environment. This variety fosters
    innovation and ensures that the JVM remains a robust and dynamic platform that
    can evolve alongside the ever-changing software development landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we conclude this section on the diverse and influential landscape of the
    JVM, we’ve unveiled the intricacies that make it a unifying force across programming
    languages and hardware platforms. The ability to seamlessly run code across multiple
    JVMs while maintaining compatibility underscores the flexibility and robustness
    of this foundational technology. Yet, the question lingers: with such compatibility,
    why do we have a multitude of JVM implementations?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer lies in the nuanced strengths and optimizations each JVM brings to
    the table, catering to specific use cases, performance demands, and integration
    scenarios. In the next section, we will embark on a hands-on exploration of selected
    JVM implementations that exemplify this diversity. Join us as we delve into Eclipse
    J9, Amazon Corretto, Azul, and Eclipse Temurin and dissect their unique features,
    performance characteristics, and real-world applications. Through this deep dive,
    we aim to equip you with the knowledge to navigate the rich tapestry of JVM choices,
    ensuring you can make informed decisions aligned with your development goals.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse J9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this dedicated section, we’ll delve into the capabilities of Eclipse J9,
    a JVM implementation that stands out for its emphasis on efficiency, scalability,
    and resource optimization. As we navigate the intricacies of Eclipse J9, we’ll
    uncover the unique features that set it apart in the vast landscape of JVM implementations
    and explore why developers should consider this powerhouse for their Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse J9, developed by the Eclipse Foundation, represents a cutting-edge JVM
    implementation that’s designed to maximize efficiency and minimize resource footprint.
    Known for its compact size and swift startup times, Eclipse J9 excels in critical
    resource utilization scenarios, making it a prime candidate for cloud-based applications,
    microservices, and other environments where responsiveness is paramount. Its architecture
    incorporates advanced JIT compilation techniques and aggressive memory management,
    contributing to a nimble and responsive runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eclipse J9, as a distinguished JVM implementation, unfolds many advantages
    that position it as a compelling choice for discerning developers. At the forefront
    is its commendable commitment to resource efficiency. Eclipse J9’s compact footprint
    optimizes system resources, making it an optimal solution for applications where
    minimizing overhead is pivotal. This efficiency extends to memory utilization
    and processor engagement, a crucial feature for applications operating in resource-constrained
    environments. Swift startup times further amplify its appeal, enhancing user experience
    and responsiveness, especially in scenarios where time-to-operation is of the
    essence. Eclipse J9’s scalability is another noteworthy benefit, accommodating
    the dynamic demands of diverse environments, from small-scale applications to
    expansive enterprise systems. As we explore the landscape of Eclipse J9, these
    benefits emerge as critical pillars, underlining its capacity to empower developers
    to create applications that seamlessly balance performance and resource consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource efficiency**: Eclipse J9’s compact footprint ensures efficient utilization
    of system resources, making it an ideal choice for applications where minimizing
    overhead is crucial. This efficiency extends to both memory usage and processor
    utilization, allowing for optimal performance in resource-constrained environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swift startup times**: The JVM’s startup time is pivotal in particular application
    domains, and Eclipse J9 shines in this regard. Its rapid startup ensures that
    applications become operational swiftly, enhancing user experience and responsiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Eclipse J9 is designed to scale seamlessly across various
    environments, adapting to the demands of both small-scale applications and large-scale
    enterprise systems. Its scalability makes it well-suited for dynamic workloads
    and applications that may experience fluctuating markets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering Eclipse J9 for your Java applications becomes imperative when efficiency,
    rapid responsiveness, and optimal resource utilization are paramount. Whether
    you’re developing cloud-native applications or microservices or deploying in resource-constrained
    environments, Eclipse J9 provides a compelling solution. The benefits of Eclipse
    J9 translate into tangible advantages, offering developers the flexibility to
    balance performance and resource consumption according to their application’s
    unique requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we conclude our exploration into the efficiency and scalability offered
    by Eclipse J9, we’ve witnessed how this JVM implementation can be a strategic
    choice for developers seeking optimal resource utilization and rapid responsiveness
    in their Java applications. The benefits of Eclipse J9, from its compact footprint
    to swift startup times and scalable architecture, underscore its versatility across
    various application landscapes. In the next section, we will seamlessly transition
    into an in-depth examination of another notable JVM implementation: Amazon Corretto.
    We’ll uncover the distinctive features and advantages that Amazon Corretto brings
    to the table, further expanding our understanding of the diverse and dynamic world
    of JVM. The journey continues, and the exploration of JVM implementations remains
    the key to unlocking the full potential of Java development.'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Corretto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll embark on an insightful journey into Amazon Corretto,
    a JVM implementation crafted by Amazon that combines reliability, performance,
    and LTS. As we navigate the nuances of Amazon Corretto, we’ll explore its unique
    features, performance optimizations, and compelling reasons developers should
    consider integrating this JVM implementation into their Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Corretto represents Amazon’s commitment to delivering a high-quality,
    open source JVM that meets the demands of modern Java development. Built on the
    solid foundation of OpenJDK (Java Development Kit), Corretto is designed to provide
    a reliable and secure Java runtime environment. Amazon Corretto is free to use
    and comes with LTS, making it an attractive choice for enterprises looking for
    a stable and dependable JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In navigating the intricacies of JVM implementations, Amazon Corretto emerges
    as a beacon of reliability, performance, and sustained support. This segment delves
    into the distinct advantages that make Amazon Corretto a compelling choice for
    Java developers across diverse landscapes. From its commitment to LTS to performance
    optimizations and a steadfast focus on security, Amazon Corretto offers a comprehensive
    suite of benefits that elevate the development experience and ensure the longevity
    and stability of Java applications. Join us as we unravel the layers of Amazon
    Corretto’s advantages, providing a nuanced understanding of why this JVM implementation
    deserves a prominent place in your toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LTS**: One of the standout features of Amazon Corretto is its LTS. Enterprises
    can benefit from extended support and updates, ensuring the stability and security
    of their Java applications over an extended period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance optimizations**: Amazon Corretto is equipped with performance
    enhancements that optimize the execution of Java applications. These optimizations
    improve responsiveness and throughput, making it well-suited for a wide range
    of use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and stability**: Built with a focus on security and stability, Amazon
    Corretto undergoes rigorous testing and quality assurance processes. It ensures
    developers can rely on a robust, secure runtime environment for their Java applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility with OpenJDK**: Amazon Corretto maintains compatibility with
    OpenJDK, allowing developers to transition from other OpenJDK-based JVMs seamlessly.
    This compatibility simplifies the migration process while providing the benefits
    of Amazon’s additional optimizations and support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering Amazon Corretto for your Java applications is a strategic decision,
    especially when LTS, performance optimizations, and a commitment to security are
    paramount. Whether you are developing cloud-native applications, serverless functions,
    or traditional enterprise systems, Amazon Corretto offers a compelling JVM solution
    backed by the reliability and scale of AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we conclude our exploration of the robust world of Amazon Corretto, we’ve
    witnessed the confluence of reliability, performance, and LTS that defines this
    JVM implementation. The benefits of Amazon Corretto, from its unwavering commitment
    to security to the optimization of Java applications, resonate as compelling reasons
    for developers to consider integrating it into their projects. Our journey into
    the diverse landscape of JVM implementations continues, and in the next section,
    we will unravel the intricacies of another noteworthy player: Azul. Join us as
    we explore Azul’s distinctive features and advantages to Java development, expanding
    our understanding of the myriad possibilities that JVM implementations offer.
    The path to Java excellence unfolds, and the exploration of Azul awaits in the
    next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Azul Zulu and Zing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll delve into the dynamic realm of **Azul Zulu Builds of
    OpenJDK** (**Azul Zulu**), a JVM implementation that is a pivotal part of Azul’s
    comprehensive offerings in the Java runtime space. Azul, renowned for its commitment
    to providing JVM runtimes and additional tools to enhance Java performance while
    reducing costs, brings Azul Zulu to the forefront. As a TCK-certified build of
    OpenJDK, Azul Zulu aligns with the performance standards of most distributors
    as they all base their builds on the OpenJDK project. Azul’s active participation
    in monitoring and resolving CVE security issues sets it apart, allowing it to
    adhere to a 3-month release cycle. It enables Azul to provide free and commercial
    builds of all supported versions with timely security fixes, ensuring the safe
    operation of Java applications in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Azul Zulu’s distinction lies in its groundbreaking contributions
    to the OpenJDK ecosystem. Azul initiated the OpenJDK project known as **Coordinated
    Restore at Checkpoint** (**CraC**) ([https://openjdk.org/projects/crac/](https://openjdk.org/projects/crac/)),
    making Zulu the first JVM runtime to incorporate this feature, enabling ultrafast
    startup of Java applications. Zulu’s versatility extends to JavaFX integrations,
    catering to various use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azul Zing Builds of OpenJDK** (**Azul Zing**) emerges as a stalwart in the
    JVM landscape, offering a tapestry of benefits that elevate Java development to
    new heights. Azul Zing introduces the innovative **Continuously Concurrent Compacting
    Collector** (**C4**) Garbage Collector at its core, setting a benchmark for low-latency
    and pauseless garbage collection. This key feature ensures that Java applications
    remain responsive, even in the face of intensive workloads. Beyond its cutting-edge
    garbage collection, Azul Zing is distinguished by its unwavering commitment to
    enhanced runtime performance. It is a formidable choice for applications demanding
    high throughput and minimal latency. Its scalability and elasticity further position
    Azul Zing as a versatile solution, seamlessly adapting to the dynamic requirements
    of both small-scale applications and large enterprise systems. With a foundation
    rooted in LTS and stability, Azul Zing becomes a strategic choice for projects
    with extended life cycles, promising developers a robust platform for crafting
    Java applications that excel in performance, responsiveness, and reliability.
    Join us in exploring the manifold benefits of Azul Zing as we uncover how this
    JVM implementation stands as a beacon of innovation and efficiency in the ever-evolving
    landscape of Java development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C4 Garbage Collector**: Azul Zing incorporates the innovative C4 Garbage
    Collector. This collector distinguishes itself by providing low-latency and pauseless
    garbage collection, ensuring that Java applications maintain consistent responsiveness
    even under heavy workloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced runtime performance**: Azul Zing is engineered to deliver enhanced
    runtime performance, making it well-suited for high-throughput and low-latency
    applications. Its optimizations contribute to improved application responsiveness
    and reduced execution times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and elasticity**: Azul Zing is designed to scale seamlessly across
    diverse workloads, adapting to the demands of both small-scale applications and
    large, enterprise-level systems. Its elasticity ensures optimal performance in
    dynamic and fluctuating environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LTS and stability**: Azul Zing offers LTS and stability, providing enterprises
    with a reliable foundation for their Java applications. This commitment to stability
    is crucial for projects with extended life cycles and stringent reliability requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azul Zing for Java development is a strategic choice when performance, scalability,
    and low latency are non-negotiable. The advanced features, including the C4 Garbage
    Collector, position Azul Zing as an ideal solution for applications where consistent
    responsiveness and optimal resource utilization are paramount. Let’s unravel the
    capabilities of Azul Zing and discover how this JVM implementation can be a catalyst
    for achieving unprecedented levels of performance in your Java applications. This
    section aims to equip you with insights to make informed decisions and leverage
    the advantages of Azul Zing across a diverse range of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In navigating the intricacies of Azul Zulu and Zing, we’ve unraveled a tapestry
    of benefits that positions these JVM implementations as a beacon of innovation
    and efficiency. Azul Zulu is a build of OpenJDK with additional integrations such
    as CRaC and JavaFX. Azul Zing is a powerful catalyst for achieving peak Java application
    performance, from the groundbreaking C4 Garbage Collector to its commitment to
    enhanced runtime performance and scalability. As our journey through diverse JVM
    implementations continues, our next destination beckons us toward IBM Semeru.
    In the upcoming section, we’ll delve into the distinctive features and advantages
    that IBM Semeru brings to the forefront, further expanding our understanding of
    the multifaceted landscape of Java development. Our exploration of IBM Semeru
    awaits, promising new insights and perspectives in our quest for Java excellence.
  prefs: []
  type: TYPE_NORMAL
- en: IBM Semeru
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore IBM Semeru, a JVM implementation that encapsulates
    the expertise and innovation of IBM in the realm of Java development. As we navigate
    the intricacies of IBM Semeru, we will unravel its distinctive features, optimizations,
    and compelling reasons developers should consider integrating this JVM implementation
    into their Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: IBM Semeru, based on the OpenJ9 JVM, represents IBM’s commitment to delivering
    a high-performance, scalable, and efficient Java runtime environment. With a focus
    on resource efficiency, rapid startup times, and advanced optimizations, IBM Semeru
    is designed to cater to various application scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'IBM Semeru emerges as a beacon of innovation in Java development, encapsulating
    a spectrum of benefits that redefine the possibilities of efficient and scalable
    runtime environments. Anchored by the robust OpenJ9 virtual machine, Semeru introduces
    a harmonious blend of resource efficiency and rapid startup times, making it an
    ideal choice for contemporary cloud-native applications and microservices. Integrating
    **ahead-of-time** (**AOT**) compilation further distinguishes IBM Semeru, translating
    Java bytecode into machine code before runtime to enhance startup performance
    and reduce the memory footprint. With a container-friendly architecture optimized
    for cloud deployments, IBM Semeru caters to the evolving needs of modern application
    deployment, ensuring adaptability, scalability, and efficiency. For developers
    seeking a comprehensive solution that aligns with the demands of dynamic cloud
    environments, IBM Semeru is a compelling choice, promising a sophisticated and
    optimized Java runtime experience. Join us in exploring the benefits that IBM
    Semeru brings to the forefront as we delve into a new era of Java development
    excellence:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenJ9 virtual machine**: IBM Semeru leverages the OpenJ9 virtual machine,
    known for its efficient memory usage and fast startup times. This optimization
    is particularly beneficial for cloud-native applications and microservices where
    resource efficiency is paramount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AOT compilation**: IBM Semeru incorporates AOT compilation, a feature that
    translates Java bytecode into machine code before runtime. This approach enhances
    startup performance, reduces the memory footprint, and contributes to consistent
    and predictable application behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container-friendly architecture**: With a container-friendly architecture,
    IBM Semeru is well-suited for deployment in containerized environments. Its efficient
    resource utilization and compatibility with container orchestration platforms
    make it ideal for modern, scalable infrastructures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimized for cloud deployments**: IBM Semeru is optimized for cloud deployments,
    aligning with the demands of cloud-native applications. Its adaptability to dynamic
    and scalable cloud environments positions it as a strategic choice for developers
    building applications in cloud ecosystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consideration of IBM Semeru becomes imperative when resource efficiency, rapid
    startup times, and compatibility with modern deployment paradigms are critical
    for your Java applications. Whether you are developing cloud-native applications
    microservices or deploying in containerized environments, IBM Semeru offers a
    robust JVM implementation with the backing of IBM’s expertise and commitment to
    innovation. Join us as we uncover the capabilities of IBM Semeru, providing you
    with insights to make informed decisions and harness the advantages of this feature-rich
    JVM implementation for your Java development endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: Our exploration into the world of JVM implementations reaches a crescendo with
    the comprehensive insights gained from IBM Semeru. The distinctive benefits, from
    resource efficiency to cloud optimization, underscore its significance in the
    ever-evolving landscape of Java development. As our journey continues, the spotlight
    now shifts toward Eclipse Temurin. In the forthcoming section, we will unravel
    the unique features and advantages that Eclipse Temurin brings to the table, enriching
    our understanding of JVM implementations. This exploration of Eclipse Temurin
    promises new perspectives and innovations as we strive toward Java excellence.
    Join us in continuing our journey through the diverse tapestry of JVM implementations
    as we uncover Eclipse Temurin’s capabilities in the dynamic world of Java development.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Temurin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore Eclipse Temurin, a robust and versatile JVM implementation
    that stands as a testament to the collaborative efforts within the Eclipse community.
    As we navigate the intricacies of Eclipse Temurin, we will uncover its distinctive
    features, optimizations, and compelling reasons why developers should consider
    embracing this JVM implementation for their Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Temurin, formerly AdoptOpenJDK, is a community-driven, open source project
    that provides free, high-quality, and production-ready builds of the OpenJDK.
    Fueled by a commitment to transparency and collaboration, Eclipse Temurin ensures
    that developers can access a reliable and well-supported Java runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eclipse Temurin emerges as a beacon of reliability and versatility in the Java
    development landscape, offering a rich tapestry of benefits that resonate with
    the needs of modern developers. With a commitment to timely updates and security
    patches for OpenJDK, Eclipse Temurin ensures developers have access to the latest
    enhancements, contributing to the security and stability of Java applications.
    Its platform independence provides the flexibility to deploy Java applications
    seamlessly across diverse operating systems and architectures, catering to the
    demands of projects targeting multiple environments. What sets Eclipse Temurin
    apart is its transparent and open community collaboration within the Eclipse ecosystem.
    Developers can actively contribute, fostering a sense of community-driven development
    and ensuring the JVM evolves in sync with the diverse needs of its users. The
    ease of adoption, coupled with a commitment to providing hassle-free builds of
    OpenJDK, positions Eclipse Temurin as an essential component in the toolkit of
    developers seeking a reliable, well-supported, and community-driven Java runtime
    environment. Join us as we unravel the benefits Eclipse Temurin brings to Java
    development, fostering a new era of collaboration and innovation within the Eclipse
    community:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timely updates and security patches**: Eclipse Temurin offers timely updates
    and security patches for OpenJDK, ensuring developers can access the latest enhancements
    and fixes. This commitment to regular updates contributes to the security and
    stability of Java applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform independence**: Eclipse Temurin supports various platforms, allowing
    developers to deploy Java applications seamlessly across diverse operating systems
    and architectures. This platform independence is crucial for projects targeting
    multiple environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparent and open community collaboration**: Being part of the Eclipse
    community, Eclipse Temurin benefits from transparent and open collaboration. Developers
    can actively contribute to the project, fostering a sense of community-driven
    development and ensuring that the JVM evolves in tandem with the diverse needs
    of its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of adoption**: Eclipse Temurin’s commitment to providing easy-to-adopt
    OpenJDK builds simplifies incorporating the latest Java features into projects.
    This ease of adoption is precious for developers seeking a hassle-free integration
    of new Java capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering Eclipse, Temurin becomes imperative for developers prioritizing
    access to up-to-date OpenJDK builds, a collaborative community-driven approach,
    and seamless platform independence. Whether you are developing applications for
    deployment across various operating systems or contributing to an open source
    ecosystem, Eclipse Temurin provides a reliable and well-supported foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey through the diverse landscape of JVM implementations has been a
    rich tapestry of innovation and optimization, from Eclipse Temurin’s community-driven
    excellence to the unique strengths of IBM Semeru, Azul Zulu’s performance prowess,
    Amazon Corretto’s reliability, and the efficiency of Eclipse J9\. As we conclude
    these individual explorations, the next section promises a holistic view, showcasing
    the remarkable diversity that defines the world of JVM implementations. Join us
    in the upcoming section, where we will navigate multiple JVM implementations in
    a single section, highlighting the dynamic choices available to developers. From
    Eclipse Temurin to other notable players, witness how the JVM ecosystem thrives
    on versatility, offering developers many options to tailor their choices based
    on specific needs and preferences. The exploration continues, unveiling the depth
    and breadth of the JVM implementation world.
  prefs: []
  type: TYPE_NORMAL
- en: Even more JVM vendors and SDKMan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll embark on a fascinating exploration of the expansive
    diversity within the JVM ecosystem. Our focus will extend beyond individual JVM
    implementations, encompassing a spectrum of specialized builds tailored for distinct
    use cases and environments. Join us as we delve into the nuances of Dragonwell,
    Tencent Kona, Liberica, Mandrel, the Microsoft Build of OpenJDK, and SapMachine
    – each representing a unique facet of JVM diversity, optimized to cater to specific
    demands and scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be embarking on a captivating journey into the multifaceted world of
    JVM diversity, where a kaleidoscope of specialized builds awaits exploration.
    Each JVM implementation represents a distinctive approach to addressing unique
    challenges in application development. From extreme scaling demands to cloud computing,
    big data, and SAP-supported ecosystems, each JVM is meticulously crafted to meet
    specific use cases. Join us as we unravel the intricacies of these implementations,
    gaining insights into how they cater to diverse scenarios, thus offering developers
    a rich palette of options to align with the unique requirements of their projects.
    This exploration promises a deeper understanding of the adaptability and versatility
    ingrained in the diverse world of JVMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dragonwell (Alibaba)**: Engineered as the in-house OpenJDK implementation
    at Alibaba, Dragonwell is optimized for the extreme scaling demands of online
    eCommerce and financial and logistics applications. Dive into how Dragonwell powers
    the intricate web of Java applications across Alibaba’s massive server infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tencent Kona**: Serving as Tencent’s default JDK for cloud computing, big
    data, and various Java applications, Kona is a production-ready distribution of
    OpenJDK with LTS. Uncover the features that make Tencent Kona a robust choice
    for diverse computing needs within Tencent’s ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liberica (BellSoft)**: As a 100% open source Java implementation built from
    OpenJDK, Liberica is thoroughly tested, including passing the **Java Compatibility
    Kit** (**JCK**). Explore how Liberica’s commitment to openness ensures JavaFX
    support across all its versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mandrel (Red Hat)**: Focused on GraalVM’s native-image component, Mandrel
    facilitates the generation of native images for Quarkus applications. Delve into
    how Mandrel simplifies the journey from Java source code to efficient, native
    applications, a crucial capability for cloud-native application development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Build of OpenJDK**: Microsoft’s contribution to JVM diversity comes
    from a no-cost distribution of OpenJDK. With LTS binaries for Java 11 and Java
    16 across multiple operating systems and architectures, understand how Microsoft’s
    build provides a versatile option for developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SapMachine (SAP)**: As a downstream version of the OpenJDK project, SapMachine
    is meticulously crafted to support SAP customers and partners. Discover how SAP’s
    commitment ensures the success of Java applications within the SAP ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring this rich tapestry of JVM implementations is paramount for developers
    seeking solutions tailored to specific use cases, from extreme scaling in eCommerce
    to cloud computing, big data, and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: As we explore the plethora of JVM implementations discussed earlier SDKMAN ([https://sdkman.io/](https://sdkman.io/))
    emerges as a versatile companion, simplifying the management of various vendors
    and versions. The need for different JVM versions is common in real-world production
    scenarios, whether for stability, optimization, or during migration phases. Join
    us as we delve into how SDKMAN streamlines the process of managing JVM implementations,
    providing developers with a seamless experience in experimenting with, switching
    between, and maintaining diverse JVM versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pivotal segment, we’ll embark on a journey to unravel the potent capabilities
    of SDKMAN. This tool is a linchpin in simplifying the intricate landscape of JVM
    diversity. As we explore the vast array of JVM implementations and versions, SDKMAN
    emerges as a versatile ally, streamlining the management process with finesse.
    It extends the gift of vendor agnosticism, allowing developers to seamlessly navigate
    between JVM vendors such as Alibaba, Tencent, BellSoft, Red Hat, Microsoft, and
    SAP. Let’s dive into the intricacies of version management, where SDKMAN empowers
    developers to effortlessly install, switch, and utilize diverse JVM versions,
    addressing the nuanced needs of projects in real-world production scenarios. With
    seamless integration into popular build tools and a commitment to community-driven
    updates, SDKMAN becomes the linchpin in ensuring a smooth and agile development
    experience, freeing developers to focus on their code in the dynamic and diverse
    landscape of Java development. Join us as we unlock the power of SDKMAN, demystifying
    the complexities and enhancing the agility of JVM management for developers worldwide:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vendor agnosticism**: SDKMAN embraces vendor agnosticism, allowing developers
    to switch between JVM vendors such as Alibaba, Tencent, BellSoft, Red Hat, Microsoft,
    and SAP. Experience the freedom to choose the most suitable JVM for your specific
    use case without the hassle of manual installations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version management**: Managing multiple JVM versions is essential in the
    dynamic landscape of Java development. SDKMAN simplifies version management, enabling
    developers to quickly install, switch, and use different versions based on project
    requirements or migration needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seamless integration of and integration with build tools**: SDKMAN integrates
    with popular build tools such as Maven and Gradle, facilitating a smooth transition
    between different JVM versions within your build and deployment processes. It
    ensures that your projects stay aligned with the chosen JVM without disruptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community-driven updates**: SDKMAN is a community-driven initiative that
    ensures continuous updates and support for the latest JVM releases. Stay in sync
    with the vibrant Java ecosystem ([https://foojay.io/today/disco-api-helping-you-to-find-any-openjdk-distribution](https://foojay.io/today/disco-api-helping-you-to-find-any-openjdk-distribution))
    and access the latest features and optimizations as soon as they become available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the ever-evolving landscape of Java development, SDKMAN emerges as a valuable
    ally for developers seeking agility and flexibility in managing JVM implementations.
    Whether you are exploring diverse JVM vendors, experimenting with versions, or
    navigating migration phases, SDKMAN streamlines the process, empowering developers
    to stay focused on their code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude our exploration of the intricate world of JVM diversity and the
    instrumental role of SDKMAN, you have gained a profound understanding of alternative
    JVMs, including Alibaba’s Dragonwell, Tencent Kona, Liberica, Mandrel, the Microsoft
    Build of OpenJDK, and SapMachine. This chapter not only shed light on the unique
    characteristics of these implementations, catering to diverse use cases, but also
    emphasized the pivotal role of SDKMAN in simplifying JVM management. The insights
    garnered set the stage for the upcoming chapter, where you will delve into the
    fundamental principles shaping Java frameworks. From design patterns to modularity,
    these principles are essential for creating robust, scalable, and maintainable
    applications. The practical utility of the information provided in this chapter
    will become evident, equipping you with the knowledge needed to navigate the dynamic
    Java development landscape. As we transition into Java framework principles, the
    comprehensive understanding you’ve gained here promises to be invaluable, guiding
    you on a seamless journey toward excellence in your coding endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the primary focus of Alibaba’s Dragonwell JVM implementation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud computing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Online eCommerce and financial and logistics applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Big data
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which JVM implementation is Tencent’s default JDK for cloud computing and big
    data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Corretto
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tencent Kona
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Eclipse Temurin
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Azul Zulu
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary focus of the Mandrel JVM implementation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: High-performance computing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Running applications on containers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Native image generation for Quarkus applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud-native application development
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one of the key benefits of Eclipse Temurin (formerly AdoptOpenJDK)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Closed source development
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Timely updates and security patches
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited platform support
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Exclusive focus on cloud environments
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does SDKMAN simplify JVM management for developers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By limiting the number of JVM vendors available
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By restricting the use of different JVM versions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By seamlessly integrating with build tools
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By supporting only proprietary JVM implementations
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What differentiates Azul Zulu from Azul Zing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azul Zulu is not TCK-certified
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Azul Zing is based on OpenJDK
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Azul Zulu incorporates the G1 Garbage Collector
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Azul Zing focuses on small-scale applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What key feature of Azul Zulu ensures that Java applications remain responsive
    even under heavy workloads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C4 Garbage Collector
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Falcon compiler
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Elasticity
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: JavaFX integration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: B. Online eCommerce and financial and logistics applications
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. Tencent Kona
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C. Native image generation for Quarkus applications
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. Timely updates and security patches
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C. By seamlessly integrating with build tools
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. Azul Zing is based on OpenJDK
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. C4 Garbage Collector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
