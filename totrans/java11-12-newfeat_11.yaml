- en: Flight Recorder and Mission Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Flight Recorder** (**JFR**) is a high-performance, low-overhead profiler
    that is built into the JVM. It is a data collection framework that records events
    that you can use to troubleshoot your Java applications and HotSpot JVM.'
  prefs: []
  type: TYPE_NORMAL
- en: JFR records the events from OS, HotSpot JVM, and JDK binary events as **binary
    data**. This essentially means that you need a parser, such as **Mission Control**
    (**MC**), to make sense of this binary data.
  prefs: []
  type: TYPE_NORMAL
- en: MC is an advanced tool for program developers and administrators to analyze
    the data collected by the JFR profiler in detail. It can be used to analyze the
    data collected for applications running in local or remote environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for JFR and MC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of JFR and MC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of JFR and MC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JFR is included in the OpenJDK distributions from Java 11\. Depending on which
    JDK distribution you are using, you might need to download and install MC separately.
    **Java Mission Control** (**JMC**) is not part of the OpenJDK distribution. It
    has been a part of OracleJDK since JDK version 7, update 40.
  prefs: []
  type: TYPE_NORMAL
- en: If JMC is not included in your JDK, you can download it from [https://jdk.java.net/jmc/](https://jdk.java.net/jmc/).
  prefs: []
  type: TYPE_NORMAL
- en: All code in this chapter can be accessed from [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with exploring why we need JFR.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation behind JFR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vaults at banks are created with near zero defects, but they aren't invincible.
    Imagine what happens after the vault of a bank is broken. One of the steps might
    include scanning the security camera footage—to check *when* and *how* the theft
    happened. This can lead to varied results—from determining the cause of fixing
    the issues and formulating measures to prevent it from happening in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can never foresee all the challenges with your application in
    production. A profiler, such as JFR, helps you to record the events when your
    application is executing. When your application crashes or doesn't perform as
    expected, you can monitor or troubleshoot it, using the data collected by the
    profiler. This data can provide you with the feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: MC reads the application profiling data recorded by JFR and displays it *visually*,
    on varied values (hence saving you from wading through piles of text).
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JFR can record a whole lot of events—from your applications to your JVM to the
    OS. It is a high performance, but low overhead profiler.
  prefs: []
  type: TYPE_NORMAL
- en: JFR extends the capabilities of **event-based JVM tracing** (JEP 167), which
    adds an initial set of events to HotSpot, to create events in Java. It also provides
    a high-performance backend to write data from the events to a binary format.
  prefs: []
  type: TYPE_NORMAL
- en: MC displays the application profiling data collected by JFR in a visual environment.
    You can select the category you want to analyze—from class loading to JVM internals
    (such as garbage collection), application threads, memory allocation, to complete
    application data analysis. We'll work with some of the MC features in this chapter
    (complete coverage of all of its features is beyond the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JFR defines the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jdk.jfr`: This defines the API and internals for the JFR profiler. You can
    use it to profile your applications that run on resource-constrained devices such
    as the **IoT** (short for **Internet of Things**) or mobile devices. `Jdk.jfr`
    only needs the `java.base` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdk.management.jfr`: To use flight recording remotely over **Java Management
    Extensions** (**JMX**), you can use this module. It requires the `jdk.jfr` and
    `jdk.management` modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't cover the code of JMC, just its features and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with JFR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with a simple `HelloWorld` example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To start flight recording for the preceding application, execute the following
    command on your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line instructs the Java Runtime to start flight recording for your
    `HelloWorld` application and save it to the `HelloWorldRecording.jfr` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three parts to the previous command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting JFR with the `-XX:StartFlightRecording` JVM option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the target file to save the recording to `hello.jfr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the application to run `HelloWorld`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start MC to view the profiling data stored in `hello.jfr`. Use the `jmc.exe`
    file to start JMC. You''ll see a window similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b06ed055-bc05-4aa2-af2b-759c0bea5d06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Click here to start using JDK Mission Control option at the bottom.
    Using the File | Open menu options, open the `hello.jfr` file you previously created.
    Here''s what it displays at the Automated Analysis Results landing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7413d7b-d5b6-446a-b412-8d95df0103d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Processes are not the only category on which MC analyzes your application. Depending
    on your application and how it is profiled, additional categories are included
    (you can see a few of them in the preceding screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s profile another application that creates a lot of (`500`) threads; each
    thread creates `ArrayList` of 1,000,000 `Double` values, populating it with random
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute the preceding `TestFlightRecorder` application, profiling it
    with JFR using Epsilon GC (to check whether we also get any data on the memory
    allocation) for 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the landing page when you open `Epsilon.jfr` in MC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dcd6516-9ee2-4eec-b9ea-14c8c2d2c0b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we discuss the results shown by MC in detail, let's quickly revisit the
    `TestFlightRecorder` application that was profiled. `TestFlightRecorder` creates
    500 instances of the `AThread` class. The `AThread` class implements `Runnable`.
    On starting, each `AThread` instance creates `ArrayList` of 1,000,000 `Double`
    values, populates them with random values and outputs them to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s visit the preceding screenshot now—MC displays a consolidated report
    on how your application fares overall. It includes the environment of the machine
    that is executing your Java application, the JVM internals, and blocking of threads
    on locks in your application. Here''s a quick listing of these categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Java Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context Switches (indent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Blocking (indent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM Internals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since MC reports that this application is performing poorly on the Context
    Switches and thread blocking categories, let''s browse through the options under
    the Java Application category on the left-side panel menu in MC and figure out
    which option will include the relevant information. As you will notice, the Lock
    Instances option displays an exclamation mark right next to it. The following
    screenshot indicates what you will see when you click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd8022f4-20c7-4fee-a25b-fdf927d52134.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that all 500 threads that you created in the
    `TestFlightRecorder` application were blocking on `PrintStream` and `Object`.
    It even displays the total blocked time, that is, 2 hours and 40 minutes (calculated
    collectively for all blocked threads—for 20 seconds of application profiling).
  prefs: []
  type: TYPE_NORMAL
- en: Since the JFR profiler records the profiled data in a binary format to a file,
    you can view this data with MC at a later time and figure out a whole lot of other
    issues. For instance, if you click on Processes, you'll know that your CPU is
    being used by a lot of other processes that are being executed on your host machine,
    which can also include auto software updates. Make sure you switch all of these
    off. Let's say you are tuning the performance of your application on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what you see if you click on Processes in MC (of course, the results
    will vary across systems):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d816b66-3332-4b5f-87a1-fdbc9e91850b.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a developer, you can also create your own custom events using the JFR API
    and view and analyze them using MC. Here''s an example; let''s define a custom
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s modify the `AThread` class to use events, instead of printing to
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the same command line options to execute your application, profiling
    it with JFR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of using MC to view these events, you can create another application
    that reads the logged events from `CustomEvents.jfr`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the JFR profiler. With JFR, a high performance,
    low overhead profiler, built into the JVM, you won't need to rely on third-party
    profilers to troubleshoot your Java applications and HotSpot JVM.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered MC—an advanced tool for developers and administrators to analyze
    the data collected by JFR in detail—visually, in local and remote environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover multiple improvements and additions in JDK
    11.
  prefs: []
  type: TYPE_NORMAL
