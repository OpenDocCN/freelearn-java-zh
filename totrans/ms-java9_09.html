<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making Use of the ProcessHandle API</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discovered the <strong>Java Microbenchmark Harness</strong> (<strong>JMH</strong>). We explored performance tests and how to write them using JMH, the Java library for writing benchmarks for the Java Virtual Machine. We started with an overview of microbenchmarking, then looked at microbenchmarking with Maven, reviewed benchmarking options, and concluded with techniques for avoiding microbenchmarking pitfalls.</p>
<p>In this chapter, we will focus on the updates to the <kbd>Process</kbd> class and the new <kbd>java.lang.ProcessHandle</kbd> API. Prior to Java 9, managing processes in Java was never easy, because Java was rarely used to automate the controlling of other processes. The API was insufficient with some features lacking and some tasks needed to be solved in a system specific manner. For example, in Java 8, giving a process access to its own <strong>process identifier</strong> (<strong>PID</strong>) was an unnecessarily difficult task.</p>
<p>In this chapter, the reader will gain all the knowledge that is needed to write an application that manages other processes and utilizes the modern process management API of Java.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>What is and how to use the new <kbd>ProcessHandle</kbd> interface</li>
<li>How to get the PID of the current process</li>
<li>How to list different processes that run in the operating system</li>
<li>How to effectively wait for an external process to finish</li>
<li>How to terminate external processes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are processes?</h1>
                </header>
            
            <article>
                
<p>In this section, we will review what processes are in the context of Java application programming. If you are already familiar with processes, you might consider skipping this section.</p>
<p>Processes are executional units in the operating system. When you start a program, you start a process. When the machine boots the code, the first thing it does is, execute the boot process. This process then starts other processes that become the child of the boot process. These child processes may start other processes. This way, when the machine runs there are trees of processes running. When the machine does something, it is done in some code executing inside some process. The operating system also runs as several processes that execute simultaneously. Applications are executed as one or more processes. Most of the applications run as a single process but as an example, the Chrome browser starts several processes to do all the rendering and network communication operations that finally function as a browser.</p>
<p>To get a better idea about what processes are, start the task manager on Windows or the <span class="packt_screen">Activity Monitor</span> on OS X and click on the <span class="packt_screen">Process</span> tab. You will see the different processes that currently exist on the machine. Using these tools, you can look at the parameters of the processes, or you can kill an individual process.</p>
<p>The individual processes have their memory allocated for their work and they are not allowed to freely access each other's memory.</p>
<p>The execution unit scheduled by the operating system is a thread. A process consists of one or more threads. These threads are scheduled by the operating system scheduler and are executed in time slots.</p>
<p>With every operating system, processes have a process identifier, which is a number that identifies the process. No two processes can be active at a time, sharing the same PID. When we want to identify an active process in the operating system we use the PID. On Linux and other Unix-like operating systems, the <kbd>kill</kbd> command terminates a process. The argument to be passed to this program is the PID of the process, to terminate. Termination can be graceful. It is something like asking the process to exit. If the process decides not to, it can keep running. Programs can be prepared to stop upon such requests. For example, a Java application may add a <kbd>Thread</kbd> object calling the <kbd>Runtime.getRuntime().addShutdownHook(Thread t)</kbd> method. The <span>thread</span> passed is supposed to start when the process is asked to stop and the thread can perform all tasks that the program has to do before it exits. However, there is no guarantee that it does start. It depends on the actual implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The new ProcessHandle interface</h1>
                </header>
            
            <article>
                
<p>There are two new interfaces and also their implementations in Java 9 supporting the handling of operating system processes. One of them is <kbd>ProcessHandle</kbd>, the other one is <kbd>ProcessHandle.Info</kbd>, a nested interface of the prior.</p>
<p>A <kbd>ProcessHandle</kbd> object identifies an operating system process and provides methods to manage the process. In prior versions of Java, this was possible only using operating system specific methods using the PID to identify the process. The major problem with this approach is that the PID is unique only while the process is active. When a process finishes, the operating system is free to reuse the <span>PID</span> for a new process. When we know only the PID of a process and check to see if the process is still running, what we are really doing is checking if there is an active process with that PID. Our process may be alive when we check it, but the next time our program queries the process state, it might be a different process.</p>
<p>The desktop and server operating systems try not to reuse the PID values for as long as possible. On some embedded systems the operating system may only use 16-bit to store the <span>PID</span>. When only 16-bit values are used, there is a greater chance that the PIDs will be reused. We can avoid this problem using the <kbd>ProcessHandle</kbd> API. We can receive a <kbd>ProcessHandle</kbd> and can call the <kbd>handle.isAlive()</kbd> method. This method will return <kbd>false</kbd> when the process finishes. This works even if the PID was reused.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the PID of the current process</h1>
                </header>
            
            <article>
                
<p>We can gain access to the PID of the processes via the handle. The <kbd>handle.getPid()</kbd><span>method</span> returns a <kbd>Long</kbd> representing the numerical value of the PID. Since it is safer to access the processes through the handle, the importance of this method is limited. It may come in handy when our code wants to give information about itself to some other management tool. It is a common practice for programs to create a file that has the numeric PID as the name of the file. It may be a requirement that a certain program does not run in multiple processes. In that case, the code writes its own PID file to a specific directory. If a PID file with that name already exists, processing stops. If the previous process crashed and terminated without deleting the PID file, then the system manager can easily delete the file and start the new process. If the program hangs, then the system manager can easily kill the dead process if s/he knows the PID.</p>
<p>To get the PID of the current process, the call chain <kbd>ProcessHandle.current(). getPid()</kbd> can be used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting information about a process</h1>
                </header>
            
            <article>
                
<p>To get information about a process, we need access to the <kbd>Info</kbd> object of the process. This is available through a <kbd>ProcessHandle</kbd>. We use a call to the <kbd>handle.info()</kbd> method to return it.</p>
<p>The <kbd>Info</kbd> interface defines query methods that deliver information about the process. These are:</p>
<ul>
<li><kbd>command()</kbd> returns an <kbd>Optional&lt;String&gt;</kbd> containing the command that was used to start the process</li>
<li><kbd>arguments()</kbd> returns an <kbd>Optional&lt;String[]&gt;</kbd> that contains the arguments that were used on the command-line after the command to start the process</li>
<li><kbd>commandLine()</kbd> returns an <kbd>Optional&lt;String&gt;</kbd> that contains the whole command-line</li>
<li><kbd>startInstant()</kbd> returns an <kbd>Optional&lt;Instant&gt;</kbd>, which essentially represents the time the process was started</li>
<li><kbd>totalCpuDuration()</kbd> returns an <kbd>Optional&lt;Duration&gt;</kbd>, which represents the CPU time used by the process since it was started</li>
<li><kbd>user()</kbd> returns an <kbd>Optional&lt;String&gt;</kbd> that holds the name of the user the process belongs to</li>
</ul>
<p>The values returned by these methods are all <kbd>Optional</kbd> because there is no guarantee that the actual operating system or the Java implementation can return the information. However, on most operating systems it should work and the returned values should be present.</p>
<p>The following sample code displays the information on a given process:</p>
<pre class="mce-root">    import java.io.IOException;<br/>    import java.time.Duration;<br/>    import java.time.Instant;<br/>    public class ProcessHandleDemonstration<br/>    {<br/>      public static void main(String[] args) throws <br/>       InterruptedException, IOException<br/>      {<br/>        provideProcessInformation(ProcessHandle.current());<br/>        Process theProcess = new<br/>         ProcessBuilder("SnippingTool.exe").start();<br/>        provideProcessInformation(theProcess.toHandle());<br/>        theProcess.waitFor();<br/>        provideProcessInformation(theProcess.toHandle());<br/>      }<br/>      static void provideProcessInformation(ProcessHandle theHandle)<br/>      {<br/>        // get id<br/>        long pid = ProcessHandle.current().pid();<br/>        // Get handle information (if available)<br/>        ProcessHandle.Info handleInformation = theHandle.info();<br/>        // Print header<br/>        System.out.println("|=============================|");<br/>        System.out.println("| INFORMATION ON YOUR PROCESS |");<br/>        System.out.println("|=============================|\n");<br/>        // Print the PID<br/>        System.out.println("Process id (PID): " + pid);<br/>        System.out.println("Process Owner: " + <br/>          handleInformation.user().orElse(""));<br/>        // Print additional information if available<br/>        System.out.println("Command:" + <br/>         handleInformation.command().orElse(""));<br/>        String[] args = handleInformation.arguments().orElse<br/>         (new String[]{});<br/>        System.out.println("Argument(s): ");<br/>        for (String arg: args) System.out.printf("\t" + arg);<br/>        System.out.println("Command line: " + handleInformation.<br/>         commandLine().orElse(""));<br/>        System.out.println("Start time: " + <br/>         handleInformation.startInstant().<br/>         orElse(Instant.now()).toString());<br/>        System.out.printf("Run time duration: %sms%n",<br/>         handleInformation.totalCpuDuration()<br/>         .orElse(Duration.ofMillis(0)).toMillis());<br/>      }<br/>    }</pre>
<p>Here is the console output for the preceding code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/01c7d993-eb46-489a-a822-2446f98f5f41.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing processes</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, we did not have the means to obtain a list of active processes. With Java 9 it is now possible to get the processes in a stream. There are three methods that return a <kbd>Stream&lt;ProcessHandle&gt;</kbd>. One lists the child processes. The other lists all the descendants; the children and the children of those recursively. The third lists all the processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing children</h1>
                </header>
            
            <article>
                
<p>To get the stream of process handles that can be used to control the children, the static method <kbd>processHandle.children()</kbd> should be used. This will create a snapshot of the children processes of the process represented by <kbd>processHandle</kbd> and create the <kbd>Stream</kbd>. Since processes are dynamic there is no guarantee that during the code execution, while our program attends to the handles, that all children processes are still active. Some of them may terminate and our process may spawn new children, perhaps from a different thread. Thus the code should not assume that each of the <kbd>ProcessHandle</kbd> elements of the stream represents an active and running process.</p>
<p>The following program starts 10 command prompts in Windows and then counts the number of children processes and prints it to standard output:</p>
<pre>    package packt.mastering.java9.process;<br/>    <br/>    import java.io.IOException;<br/><br/>    public class ChildLister {<br/>      public static void main(String[] args) throws IOException {<br/>        for (int i = 0; i &lt; 10; i++) {<br/>          new ProcessBuilder().command("cmd.exe").start();<br/>        }<br/>        System.out.println("Number of children :" +<br/>         ProcessHandle.current().children().count());<br/>      }<br/>    }</pre>
<p>Executing the program will result in the following:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/428546ae-2d8a-4920-b3e9-2d9bc9857f80.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing descendants</h1>
                </header>
            
            <article>
                
<p>Listing the descendants is very similar to listing children, but if we call the <kbd>processHandle.descendants()</kbd> method then the <kbd>Stream</kbd> will contain all the children processes and the children processes of those processes and so on. The following program starts command prompts with command-line arguments so that they also spawn another <kbd>cmd.exe</kbd> that terminates:</p>
<pre>    package packt.mastering.java9.process;<br/><br/>    import java.io.IOException;<br/>    import java.util.stream.Collectors;<br/><br/>    public class DescendantLister {<br/>      public static void main(String[] args) throws IOException {<br/>        for (int i = 0; i &lt; 10; i++) {<br/>          new ProcessBuilder().command("cmd.exe","/K","cmd").                <br/>           start();<br/>        }<br/>        System.out.println("Number of descendants: " +<br/>         ProcessHandle.current().descendants().count();<br/>      }<br/>    }</pre>
<p>Running the command a few times will result in the following, non-deterministic output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/436363b5-24ff-40dd-85fe-8142b6a03b20.png"/></div>
<p>The output clearly demonstrates that when the <kbd>Stream</kbd> of the descendants is created not all processes are alive. The sample code starts 10 processes and each of them starts another. The <kbd>Stream</kbd> does not have 20 elements because some of these sub-processes were terminated during processing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing all processes</h1>
                </header>
            
            <article>
                
<p>Listing all the processes is slightly different from listing descendants and children. The method <kbd>allProcess()</kbd> is static and returns a <kbd>Stream</kbd> of handles of all processes that are active in the operating system at the time of execution.</p>
<p>The following sample code prints the process commands to the console that seem to be Java processes:</p>
<pre>    package packt.mastering.java9.process;<br/>    import java.lang.ProcessHandle.Info;<br/>    public class ProcessLister {<br/>      private static void out(String format, Object... params) {<br/>        System.out.println(String.format(format, params));<br/>      }<br/>      private static boolean looksLikeJavaProcess(Info info) {<br/>        return info.command().isPresent() &amp;&amp;<br/>         info.command().get().<br/>         toLowerCase().indexOf("java") != -1;<br/>      }<br/><br/>      public static void main(String[] args) {<br/>        ProcessHandle.allProcesses().<br/>         map(ProcessHandle::info).<br/>         filter(info -&gt; looksLikeJavaProcess(info)).<br/>         forEach(<br/>           (info) -&gt; System.out.println(<br/>             info.command().orElse("---"))<br/>         );<br/>      }<br/><br/>    }</pre>
<p>The output of the program lists all the process commands that have the string <kbd>java</kbd> inside:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/54047251-3202-4d28-a69c-408420319f40.png"/></div>
<p>Your actual output may, of course, be different.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Waiting for processes</h1>
                </header>
            
            <article>
                
<p>When a process starts another process, it may wait for the process many times because it needs the result of the other program. If the structure of the task can be organized in a way that the parent program can do something else while waiting for the child process to finish, then the parent process can invoke the <kbd>isAlive()</kbd> method on the process handle. Many times, the parent process has nothing to do until the spawned process finishes. Old applications implemented loops that called the <kbd>Thread.sleep()</kbd> method so CPU was not excessively wasted and from time to time the process was checked to see if it was still alive. Java 9 offers a much better approach to the waiting process.</p>
<p>The <kbd>ProcessHandle</kbd> interface has a method called <kbd>onExit</kbd> that returns a <kbd>CompletableFuture</kbd>. This class was introduced in Java 8 and makes it possible to wait for a task to be finished without looping. If we have the handle to a process we can simply call the <kbd>handle.onExit().join()</kbd> method to wait until the process finishes. The <kbd>get()</kbd> method of the returned <kbd>CompletableFuture</kbd> will return the <kbd>ProcessHandle</kbd> instance that was used to create it in the first place.</p>
<p>We can call the <kbd>onExit()</kbd> method on the handle many times and each time it will return a different <kbd>CompletableFuture</kbd> object, each related to the same process. We can call the <kbd>cancel()</kbd> method on the object but it will only cancel the <kbd>CompletableFuture</kbd> object and not the process and also does not have any effect on the other <kbd>CompletableFuture</kbd> objects that were created from the same <kbd>ProcessHandle</kbd> instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terminating processes</h1>
                </header>
            
            <article>
                
<p>To terminate a process we can call the <kbd>destroy()</kbd> method or the <kbd>destroyForcibly()</kbd> method on the <kbd>ProcessHandle</kbd> instance. Both of these methods will terminate the process. The <kbd>destroy()</kbd> method is expected to terminate the process gracefully executing the process shutdown sequence. In this case the shutdown hooks added to the run time are executed if the actual implementation supports the graceful, normal termination of processes. The <kbd>destroyForcibly()</kbd> method will enforce process termination, and in this case the shutdown sequence will not be executed.</p>
<p>If the process managed by the handle is not alive then nothing happens when the code calls any of these methods. If there are any <kbd>CompletableFuture</kbd> objects created calling the <kbd>onExit()</kbd> method on the handle then they will be completed after the call to the <kbd>destroy()</kbd> or <kbd>destroyForcefully()</kbd> method when the process has terminated. This means that the <kbd>CompletableFuture</kbd> object will return from a <kbd>join()</kbd> or some similar method after some time when the process termination is complete and not immediately after <kbd>destroy()</kbd> or <kbd>destroyForcefully()</kbd> returned.</p>
<p>It is also important to note that process termination may depend on many things. If the actual process that is waiting to terminate another does not have the right to terminate the other process then the request will fail. In this case the return value of the method is <kbd>false</kbd>. It is also important to understand that a return value of <kbd>true</kbd> does not mean that the process has actually terminated. It only means that the termination request was accepted by the operating system and that the operating system will terminate the process at some point in the future. This will actually happen rather soon, but not instantaneously and thus it should not be a surprise if the method <kbd>isAlive()</kbd> returns <kbd>true</kbd> for some time after the method <kbd>destroy()</kbd> or <kbd>destroyForcefully()</kbd> returned the value <kbd>true</kbd>.</p>
<p>The difference between <kbd>destroy()</kbd> and <kbd>destroyForcefully()</kbd> is implementation specific. The Java standard does not state that <kbd>destroy()</kbd> does terminate the process letting the shutdown sequence be executed. It only <em>requests the process be killed. Whether the process represented by this ProcessHandle object is</em> <em>normally terminated</em> <em>or not is implementation dependent</em> (<a href="http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--">http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--</a>)<em>.</em></p>
<div class="packt_infobox">To learn more about <kbd>ProcessHandle</kbd> interface, visit <span class="URLPACKT"><a href="http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html">http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html</a>.</span></div>
<p>This is because some operating systems do not implement the graceful process termination feature. In such situations, the implementation of <kbd>destroy()</kbd> is the same as calling <kbd>destroyForcefully()</kbd>.The system specific implementation of the interface <kbd>ProcessHandle</kbd> must implement the method <kbd>supportsNormalTermination()</kbd> that is <kbd>true</kbd> only if the implementation supports normal (not forceful) process termination. The method is expected to return the same value for all invocations in an actual implementation and should not change the return value during the execution of a JVM instance. There is no need to call the method multiple times.</p>
<p>The following examples demonstrate process starting, process termination, and waiting for the process to terminate. In our example, we use two classes. This first class demonstrates the <kbd>.sleep()</kbd> method:</p>
<pre>    package packt.mastering.java9.process; 
 
    public class WaitForChildToBeTerminated  
    { 
      public static void main(String[] args) 
       throws InterruptedException  
      { 
        Thread.sleep(10_000); 
      } 
    } </pre>
<p>The second class in our example calls the <kbd>WaitForChildToBeTerminated</kbd> class:</p>
<pre>    package packt.mastering.java9.process;<br/><br/>    import java.io.IOException;<br/>    import java.util.Arrays;<br/>    import java.util.concurrent.CompletableFuture;<br/>    import java.util.stream.Collectors;<br/><br/>    public class TerminateAProcessAfterWaiting {<br/>      private static final int N = 10;<br/><br/>      public static void main(String[] args)<br/>       throws IOException, InterruptedException {  <br/>         ProcessHandle ph[] = new ProcessHandle[N];<br/> 
         for (int i = 0; i &lt; N; i++)  
         {<br/>           final ProcessBuilder pb = ew ProcessBuilder(). <br/>            command("java", "-cp", "build/classes/main",<br/>            "packt.mastering.java9.process.<br/>            WaitForChildToBeTerminated");<br/>           Process p = pb.start();<br/>           ph[i] = p.toHandle();<br/>         }<br/>         long start = System.currentTimeMillis();<br/>         Arrays.stream(ph).forEach(ProcessHandle::destroyForcibly);<br/><br/><br/>         CompletableFuture.allOf(Arrays.stream(ph).<br/>          map(ProcessHandle::onExit).<br/>          collect(Collectors.toList()).<br/>          toArray(new CompletableFuture[ph.length])).<br/>          join();<br/>         long duration = System.currentTimeMillis() - start;<br/>         System.out.println("Duration " + duration + "ms");<br/>      }<br/>    }</pre>
<p>The preceding code starts 10 processes, each executing the program that sleeps <kbd>10</kbd> seconds. Then it forcibly destroys the processes, more specifically, the operating system is asked to destroy them. Our example joins the <kbd>CompletableFuture</kbd> that is composed from the array of <kbd>CompletableFuture</kbd> objects, which are created using the handles of the individual processes.</p>
<p>When all the processes are finished then it prints out the measured time in milliseconds. The time interval starts when the processes are created and the process creation loop finished. The end of the measured time interval is when the processes are recognized by the JVM returning from the <kbd>join()</kbd> method.</p>
<p>The sample code sets the sleeping time to 10 seconds. This is a more noticeable time period. Running the code twice and deleting the line that destroys the processes can result a much slower printout. Actually the measured and printed elapsed times will also show that terminating the processes has an effect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A small process controller application</h1>
                </header>
            
            <article>
                
<p>To summarize and put into use all that we have learned in this chapter we look at a sample process control application. The functionality of the application is very simple. It reads from a series of configuration file(s) parameters how to start some processes and then if any of them stops, it tries to restart the process.</p>
<p>Even a real life application can be created from this demo version. You can extend the set of parameters of the process with environment variable specifications. You can add default directory for the process, input and output redirection or even how much CPU a process is allowed to consume without the controlling application killing and restarting it.</p>
<p>The application consists of four classes.</p>
<ul>
<li><kbd>Main</kbd>: This class that contains the public static void main method and is used to start up the daemon.</li>
<li><kbd>Parameters</kbd>: This class contains the configuration parameters for a process. In this simple case it will only contain one field, the <kbd>commandLine</kbd>. If the application gets extended this class will contain the default directory, the redirections, and CPU use limiting data.</li>
<li><kbd>ParamsAndHandle</kbd>: This class that is nothing else than a data tuple holding a reference to a <kbd>Parameters</kbd> object and also a process handle. When a process dies and gets restarted the process handle is replaced by the new handle, but the reference to the <kbd>Parameters</kbd> object never changes, it is configuration.</li>
</ul>
<ul>
<li><kbd>ControlDaemon</kbd>: This class implements the interface <kbd>Runnable</kbd> and is started as a separate thread.</li>
</ul>
<p>In the code we will use most of the process API we discussed in the previous sections, <em>Terminating processes</em> and we will use a lot of threading code and stream operations. Understanding the threading work of the JVM is important independent of the process management also. It has, however emphasized importance when used together with the process API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main class</h1>
                </header>
            
            <article>
                
<p>The main method takes the name of the directory from the command line argument. It treats this as relative to the current working directory. It uses a separate method from the same class to read the set of configurations from the files in the directory and then starts the control daemon. The following code if the <kbd>main</kbd> method of the program:</p>
<pre>    public static void main(String[] args) throws IOException, 
     InterruptedException  
    {<br/>      // DemoOutput.out() simulated - implementation no shown<br/>      DemoOutput.out(new File(".").getAbsolutePath().toString());<br/>      if (args.length == 0)    {<br/>        System.err.println("Usage: daemon directory");<br/>        System.exit(-1);<br/>      }<br/>      Set&lt;Parameters&gt; params = parametersSetFrom(args[0]);<br/>      Thread t = new Thread(new ControlDaemon(params));<br/>      t.start();<br/>    }</pre>
<p>Although this is a daemon, we are starting it as a normal thread and not as a daemon thread. When a thread is set to be a daemon thread it will not keep the JVM alive. When all other non-daemon threads stop, the JVM will just exit and the daemon threads will be stopped. In our case, the daemon thread we execute is the only one that keeps the code running. After that was started the main thread has nothing more to do, but the JVM should stay alive, until it is killed by the operator issuing a Unix <kbd>kill</kbd> command or pressing <em><span class="KeyPACKT">Control</span></em> + <em><span class="KeyPACKT">C</span></em> on the command line.</p>
<p>Getting the list of the files that are in the directory specified and getting the parameters from the file is simple using the new <kbd>Files</kbd> and <kbd>Paths</kbd> classes from the JDK:</p>
<pre>    private static Set&lt;Parameters&gt;  
     GetListOfFilesInDirectory(String directory) throws IOException  
    {<br/>      return Files.walk(Paths.get(directory))<br/>       .map(Path::toFile)<br/>       .filter(File::isFile)<br/>       .map(file -&gt; Parameters.fromFile(file))<br/>       .collect(Collectors.toSet());<br/>    }</pre>
<p>We get a stream of the files in the form of <kbd>Path</kbd> objects, map it to <kbd>File</kbd> objects, then we filter out the directories if there are any in the configuration directory and map the remaining plain files to <kbd>Parameters</kbd> objects using the static method <kbd>fromFile</kbd> of the <kbd>Parameters</kbd> class. Finally, we return a <kbd>Set</kbd> of the objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameters class</h1>
                </header>
            
            <article>
                
<p>Our <kbd>Parameters</kbd> class has a field and a constructor as listed as follows:</p>
<pre>    final String[] commandLine;<br/><br/>    public Parameters(String[] commandLine) {<br/>      this.commandLine = commandLine;<br/>    }</pre>
<p>The parameter class has two methods. The first method, <kbd>getCommandLineStrings</kbd>, gets the command line strings from the properties. This array contains the command and the command line parameters. If it was not defined in the file then we return an empty array:</p>
<pre>    private static String[] getCommandLineStrings(Properties props)  
    {<br/>      return Optional<br/>       .ofNullable(props.getProperty("commandLine"))<br/>       .orElse("")<br/>       .split("\\s+");<br/>    }</pre>
<p>The second method is the <kbd>static fromFile</kbd> that reads the properties from a properties file:</p>
<pre>    public static Parameters fromFile(final File file)  
    {<br/>      final Properties props = new Properties();<br/>      try (final InputStream is = new FileInputStream(file)) {<br/>        props.load(is);<br/>      }  catch (IOException e) {<br/>           throw new RuntimeException(e);<br/>      }<br/>      return new Parameters(getCommandLineStrings(props));<br/>    }</pre>
<p>If the set of parameters handled by the program is extended then this class should also be modified.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ParamsAndHandle class</h1>
                </header>
            
            <article>
                
<p>The <kbd>ParamsAndHandle</kbd> is a very simple class that holds two fields. One for the parameters and the other is the handle to the process handle that is used to access the process started using the parameters:</p>
<pre>    public class ParamsAndHandle  
    {<br/>      final Parameters params;<br/>      ProcessHandle handle;<br/><br/>      public ParamsAndHandle(Parameters params,<br/>        ProcessHandle handle) {<br/>          this.params = params;<br/>          this.handle = handle;<br/>      }<br/><br/>      public ProcessHandle toHandle() {<br/>        return handle;<br/>      }<br/>    }</pre>
<p>Since the class is closely tied to the <kbd>ControlDaemon</kbd> class from where it is used there is no mutator or accessor associated with the field. We see the two classes as something inside the same encapsulation boundaries. The <kbd>toHandle</kbd> method is there so that we can use it as a method handle, as we will see in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ControlDaemon class</h1>
                </header>
            
            <article>
                
<p>The <kbd>ControlDaemon</kbd> class implements the <kbd>Runnable</kbd> interface and is started as a separate thread. The constructor gets the set of the parameters that were read from the properties files and converts them to a set of <kbd>ParamsAndHandle</kbd> objects:</p>
<pre>    private final Set&lt;ParamsAndHandle&gt; handlers;<br/><br/>    public ControlDaemon(Set&lt;Parameters&gt; params) {<br/>      handlers = params<br/>      .stream()<br/>      .map( s -&gt; new ParamsAndHandle(s,null))<br/>      .collect(Collectors.toSet());<br/>    }</pre>
<p>Because the processes are not started at this point, the handles are all <kbd>null</kbd>. The <kbd>run()</kbd> method starts the processes:</p>
<pre>    @Override<br/>    public void run() {<br/>      try {<br/>        for (ParamsAndHandle pah : handlers) {<br/>          log.log(DEBUG, "Starting {0}", pah.params);<br/>          ProcessHandle handle = start(pah.params);<br/>          pah.handle = handle;<br/>        }<br/>        keepProcessesAlive();<br/>        while (handlers.size() &gt; 0) {<br/>          allMyProcesses().join();<br/>        } 
      } catch (IOException e)  
        {<br/>          log.log(ERROR, e);<br/>        }<br/>    }</pre>
<p>Processing goes through the set of parameters and uses the method (implemented in this class later) to start the processes. The handles to each process get to the <kbd>ParamsAndHandle</kbd> object. After that, the <kbd>keepProcessesAlive</kbd> method is called and waits for the processes to finish. When a process stops it gets restarted. If it cannot be restarted it will be removed from the set.</p>
<p>The <kbd>allMyProcesses</kbd> method (also implemented in this class) returns a <kbd>CompletableFuture</kbd> that gets completed when all the started processes have stopped. Some of the processes may have been restarted by the time the <kbd>join()</kbd> method returns. As long as there is at least one process running, the thread should run.</p>
<p>Using the <kbd>CompletableFuture</kbd> to wait for the processes and the <kbd>while</kbd> loop, we use minimal CPU to keep the thread alive so long as long there is at least one process we manage running, presumably even after a few restarts. We have to keep this thread alive even if it does not use CPU and executes no code most of the time to let the <kbd>keepProcessesAlive()</kbd> method do its work using <kbd>CompletableFutures</kbd>. The method is shown in the following code snippet:</p>
<pre>    private void keepProcessesAlive()  
    {<br/>      anyOfMyProcesses()<br/>       .thenAccept(ignore -&gt; {<br/>         restartProcesses();<br/>         keepProcessesAlive();<br/>       });<br/>    }</pre>
<p>The <kbd>keepProcessesAlive()</kbd> method calls the <kbd>anyOfMyProcesses()</kbd> method that returns a <kbd>CompletableFuture</kbd>, which is completed when any of the managed processes exits. The method schedules to execute the lambda passed as an argument to the <kbd>thenAccept()</kbd> method for the time the <kbd>CompletableFuture</kbd> is completed. The lambda does two things:</p>
<ul>
<li>Restarts the processes that are stopped (probably only one)</li>
<li>Calls the <kbd>keepProcessesAlive()</kbd> method</li>
</ul>
<p>It is important to understand that this call is not performed from within the <kbd>keepProcessesAlive()</kbd> method itself. This is not a recursive call. This is scheduled as a <kbd>CompletableFuture</kbd> action. We are not implementing a loop in a recursive call, because we would run out of stack space. We ask the JVM executors to execute this method again when the processes are restarted.</p>
<p>It is important to know that the JVM uses the default <kbd>ForkJoinPool</kbd> to schedule these tasks and this pool contains daemon threads. That is the reason we have to wait and keep the method running because that is the only non-daemon thread that prevents the JVM from exiting.</p>
<p>The next method is <kbd>restartProcesses()</kbd>:</p>
<pre>    private void restartProcesses()  
    {<br/>      Set&lt;ParamsAndHandle&gt; failing = new HashSet&lt;&gt;();<br/>      handlers.stream()<br/>       .filter(pah -&gt; !pah.toHandle().isAlive())<br/>       .forEach(pah -&gt; {<br/>         try {<br/>           pah.handle = start(pah.params);<br/>         } catch (IOException e) {<br/>             failing.add(pah);<br/>         }<br/>       });<br/>       handlers.removeAll(failing);<br/>    }</pre>
<p>This method starts the processes that are in our set of managed processes and which are not alive. If any of the restarts fail it removes the failing processes from the set. (Be aware not to remove it in the loop to avoid <kbd>ConcurrentModificationException</kbd>.)</p>
<p>The <kbd>anyOfMyProcesses()</kbd> and <kbd>allMyProcesses()</kbd> methods are using the auxiliary <kbd>completableFuturesOfTheProcessesand()</kbd> method and are straight forward:</p>
<pre>    private CompletableFuture anyOfMyProcesses()  
    {<br/>      return CompletableFuture.anyOf(<br/>        completableFuturesOfTheProcesses());<br/>    }<br/><br/>    private CompletableFuture allMyProcesses() {<br/>      return CompletableFuture.allOf(<br/>        completableFuturesOfTheProcesses());<br/>    }</pre>
<p>The <kbd>completableFuturesOfTheProcesses()</kbd> method returns an array of <kbd>CompletableFutures</kbd> created from the currently running managed processes calling their <kbd>onExit()</kbd> method. This is done in a compact and easy to read functional programming style, as shown here:</p>
<pre>    private CompletableFuture[] completableFuturesOfTheProcesses()  
    {<br/>      return handlers.stream()<br/>       .map(ParamsAndHandle::toHandle)<br/>       .map(ProcessHandle::onExit)<br/>       .collect(Collectors.toList())<br/>       .toArray(new CompletableFuture[handlers.size()]);<br/>    }</pre>
<p>The set is converted to a <kbd>stream</kbd>, mapped to a <kbd>stream</kbd> of <kbd>ProcessHandle</kbd> objects (this is why we needed the <kbd>toHandle()</kbd> method in the <kbd>ParamsAndHandle</kbd> class). Then the handles are mapped to <kbd>CompletableFuture</kbd> stream using the <kbd>onExit()</kbd> method and finally we collect it to a list and convert to an array.</p>
<p>Our last method to complete our sample application is as follows:</p>
<pre>    private ProcessHandle start(Parameters params)<br/>     throws IOException {<br/>       return new ProcessBuilder(params.commandLine)<br/>        .start()<br/>        .toHandle();<br/>    }</pre>
<p>This method starts the process using a <kbd>ProcessBuilder</kbd> and returns the <kbd>ProcessHandle</kbd> so that we can replace the old one in our set and manage the new process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter we discussed how Java 9 better enables us to manage processes. Prior to Java 9, process management from within Java required OS specific implementations and was less than optimal in terms of CPU use and coding practice. The modern API, with new classes like <kbd>ProcessHandle,</kbd> makes it possible to handle almost all aspects of processes. We listed the new API, and had simple example codes for the use of each of them. In the second half of the chapter we put together a whole application managing processes where the learned API was put into practice.</p>
<p>In the next chapter, we will take a detailed look at the new Java Stack Walking API released with Java 9. We will use code samples to illustrate how to use the API.</p>


            </article>

            
        </section>
    </body></html>