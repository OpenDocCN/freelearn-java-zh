<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Artificial Intelligence"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Artificial Intelligence</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a reusable AI control class</li><li class="listitem" style="list-style-type: disc">Sensing – vision</li><li class="listitem" style="list-style-type: disc">Sensing – hearing</li><li class="listitem" style="list-style-type: disc">Decision making – Finite State Machine</li><li class="listitem" style="list-style-type: disc">Creating the AI using cover</li><li class="listitem" style="list-style-type: disc">Generating NavMesh in SDK</li><li class="listitem" style="list-style-type: disc">Pathfinding – using NavMesh</li><li class="listitem" style="list-style-type: disc">Controlling groups of AI</li><li class="listitem" style="list-style-type: disc">Pathfinding – our own A* pathfinder</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Introduction</h1></div></div></div><p>
<span class="strong"><strong>Artificial Intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>) is an extremely vast field. Even for games it can be very diverse, depending on the type of game and requirements.</p><p>Many<a id="id346" class="indexterm"/> developers enjoy working with AI. It gives you a sense of creating something alive, something intelligent, and rational. A good question to ask before designing AI for a game is what the expected behavior should be, from a player's perspective. In an FPS, it might be the case that the AI can separate the friend from the foe, find cover when attacked, flee when injured, and not get stuck on things as they move around. AI in an RTS might need to not only evaluate the current situation, but also plan ahead and divide resources between aggressive and defensive behavior. A group of soldiers and a tactical shooter might have advanced and dynamic group behavior. Another option is to have individual behaviors that still make them appear to work together, to the player.</p><p>The recipes in this chapter will, in most cases, work with isolated functionality, but revolve around a central AI control class. As such, the results might not always be impressive on their own, but at the same time, it should be quite easy to combine several of them into a more powerful AI.</p></div></div>
<div class="section" title="Creating a reusable AI control class"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Creating a reusable AI control class</h1></div></div></div><p>In this<a id="id347" class="indexterm"/> recipe, we will create a control that is going to steer an AI character. Using <code class="literal">Control</code> to do this is beneficial since it can add the AI functionality and be used together with other <code class="literal">Controls</code> in the game. We can use <code class="literal">GameCharacterControl</code> from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span> for both the player and AI characters by adding <code class="literal">AIControl</code> to its spatial. To get a quick and visual result, we'll apply it to the bullet-based <code class="literal">BetterCharacterControl</code> class in this recipe.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec128"/>How to do it...</h2></div></div></div><p>We need to perform the following steps to get a basic, but functional attacking (or following) AI:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by creating a new class called <code class="literal">AIControl</code>, extending <code class="literal">AbstractControl</code>. The core of the recipe will be based around an enum (enumeration) called <code class="literal">state</code>. For now it only needs two values: <code class="literal">Idle</code> and <code class="literal">Follow</code>.</li><li class="listitem">Add fields for <code class="literal">BetterCharacterControl</code>, called <code class="literal">physicsCharacter</code>, Booleans <code class="literal">forward</code> and <code class="literal">backwards</code>, a <code class="literal">Vector3f</code> field for <code class="literal">walkDirection</code>, and another for <code class="literal">viewDirection</code>. If it's going to follow something, it also needs a <code class="literal">target</code> field, which can be <code class="literal">Spatial</code>.</li><li class="listitem">The bulk of the logic is carried out in a <code class="literal">switch</code> statement in the <code class="literal">controlUpdate</code> method, as shown in the following code. The first case is <code class="literal">Idle</code>. In this case, the AI shouldn't do anything:<div class="informalexample"><pre class="programlisting">switch(state){
  case Idle:
    forward = false;
    backward = false;
  break;</pre></div></li><li class="listitem">In the <code class="literal">Follow</code> case, we should first check whether <code class="literal">target</code> is set. If there is a target, we find the direction to the target and make the AI face it by setting <code class="literal">viewDirection</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">case Follow:
  if(target != null){
    Vector3f dirToTarget = target.getWorldTranslation().subtract(spatial.getWorldTranslation());
    dirToTarget.y = 0;
    dirToTarget.normalizeLocal();
    viewDirection.set(dirToTarget);</pre></div></li><li class="listitem">We <a id="id348" class="indexterm"/>check the distance to the target. If it's more than <code class="literal">5</code> the AI will try to get closer. If the distance instead is less than <code class="literal">3</code>, it will try to back up a bit. The AI can also lose track of the target if it is more than 20 units away. In this case, it also changes state to <code class="literal">Idle</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">if (distance &gt; 20f){
  state = State.Idle;
  target = null;
} else if(distance &gt; 5f){
  forward = true;
  backward = false;
} else if (distance &lt; 3f){
  forward = false;
  backward = true;
} else {
  forward = false;
  backward = false;
}</pre></div></li><li class="listitem">When it comes to movement, we can get the forward facing direction with the following line of code:<div class="informalexample"><pre class="programlisting">Vector3f modelForwardDir = spatial.getWorldRotation().mult(Vector3f.UNIT_Z);</pre></div></li><li class="listitem">Depending on whether forward or backward is true, we can multiply this value with a suitable movement speed, and the call <code class="literal">setWalkDirection</code> on the <code class="literal">BetterCharacterControl</code> class with the result shown in the following code:<div class="informalexample"><pre class="programlisting">if (forward) {
  walkDirection.addLocal(modelForwardDir.mult(3));
} else if (backward) {
  walkDirection.addLocal(modelForwardDir.negate().multLocal(3));
}
physicsCharacter.setWalkDirection(walkDirection);</pre></div></li><li class="listitem">Finally, we should also call <code class="literal">setViewDirection</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">physicsCharacter.setViewDirection(viewDirection);</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec129"/>How it works…</h2></div></div></div><p>Using <code class="literal">BetterCharacterControl</code>, we get a lot of functionality for free. We only need a couple <a id="id349" class="indexterm"/>of Booleans to keep track of movement, and two <code class="literal">Vector3f</code> instances for directions. Target is what the AI will focus on (or follow, for now).</p><p>If we're familiar with <code class="literal">TestBetterCharacter</code> from jMonkeyEngine's test examples, we can recognize the movement handling from that class. For now, we only use the <code class="literal">forward</code>/<code class="literal">backward</code> functionality. It is a good idea to keep the rotation code as well, just in case we would like it to turn more smoothly in the future. The <code class="literal">walkDirection</code> vector is <code class="literal">0</code> by default. It can either be sent as it is sent to <code class="literal">physicsCharacter</code>, in which case the character will stop, or be modified to move in either direction. The <code class="literal">viewDirection</code> vector is simply set to look at the target for now, and passed on to <code class="literal">physicsCharacter</code>.</p><p>The logic in the <code class="literal">Follow</code> case mentioned previously is mostly there to have something to test with. Even so, it's AI behavior that seems to be sufficient for many MMOs. Once a target has been acquired, it will try to keep itself at a certain distance. It can also lose track of the target if it gets too far away. In this case, it falls back to the <code class="literal">Idle</code> state.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec130"/>There's more…</h2></div></div></div><p>By linking this recipe together with <a class="link" href="ch04.html" title="Chapter 4. Mastering Character Animations">Chapter 4</a>, <span class="emphasis"><em>Mastering Character Animations</em></span>, we can easily make Jaime play some animations while he's moving.</p><p>Start by adding the <code class="literal">AnimationManagerControl</code> class to the AI character using the following code:</p><div class="informalexample"><pre class="programlisting">aiCharacter.addControl(new AnimationManagerControl());</pre></div><p>We need to tell it to play animations. In <code class="literal">AIControl</code>, find the forward and backwards brackets inside the <code class="literal">controlUpdate</code> method and add the following lines:</p><div class="informalexample"><pre class="programlisting">if (forward) {
            ... spatial.getControl(AnimationManagerControl.class).setAnimation(AnimationManagerControl.Animation.Walk);
  } else if (backward) {
            ... spatial.getControl(AnimationManagerControl.class).setAnimation(AnimationManagerControl.Animation.Walk);
  } else {
spatial.getControl(AnimationManagerControl.class).setAnimation(AnimationManagerControl.Animation.Idle);
}</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec131"/>There's more…</h2></div></div></div><p>Let's create a test case world we can use for both this and many of the following recipes. First we need a world with physics:</p><div class="informalexample"><pre class="programlisting">BulletAppState bulletAppState = new BulletAppState();
stateManager.attach(bulletAppState);</pre></div><p>We will<a id="id350" class="indexterm"/> need some kind of object to stand on. The <code class="literal">PhysicsTestHelper</code> class has a few example worlds we can use.</p><p>We load up good old Jaime. Again, we use the <code class="literal">BetterCharacterControl</code> class since it offloads a lot of code for us. Since the Bullet physics world is different from the ordinary scenegraph, Jaime is added to <code class="literal">physicsSpace</code> as well as to the <code class="literal">rootNode</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">bulletAppState.getPhysicsSpace().add(jaime);
rootNode.attachChild(jaime);</pre></div><p>We also need to add our newly created AI control using the following code:</p><div class="informalexample"><pre class="programlisting">jaime.addControl(new AIControl());</pre></div><p>There's one more thing we need to do for this to work. The AI needs to track something. The easiest way we can get a moving target is to add a <code class="literal">CameraNode</code> class and supply <code class="literal">cam</code> from the application, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">CameraNode camNode = new CameraNode("CamNode", cam);
camNode.setControlDir(CameraControl.ControlDirection.CameraToSpatial);
rootNode.attachChild(camNode);</pre></div><p>We set <code class="literal">camNode</code> to be the target, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">jaime.getControl(AIControl.class).setState(AIControl.State.Follow);
jaime.getControl(AIControl.class).setTarget(camNode);</pre></div><p>If we're familiar with cameras in OpenGL, we know they don't really have a physical existence. A <code class="literal">CameraNode</code> class in jMonkeyEngine gives us that. It tracks the camera's position and rotation, giving us something easy to measure. This will make it easier for us when we want the AI to follow it, since we can use the convenience of it being spatial.</p><p>For this reason, we can set <code class="literal">CameraNode</code> to be its target.</p></div></div>
<div class="section" title="Sensing &#x2013; vision"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Sensing – vision</h1></div></div></div><p>No matter how clever our AI is, it needs some senses to become aware of its surroundings. <a id="id351" class="indexterm"/>In this recipe, we'll accomplish an AI that can look in a configurable arc in front of it, as <a id="id352" class="indexterm"/>shown in the following screenshot. It will build upon the AI control from the previous recipe, but the implementation should work well for many other patterns as well. The following screenshot shows Jaime with a visible representation of his line of sight:</p><div class="mediaobject"><img src="graphics/6478OS_05_01.jpg" alt="Sensing – vision"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec132"/>How to do it...</h2></div></div></div><p>To get our AI to sense something, we need to modify the <code class="literal">AIControl</code> class from the previous recipe by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to define some values, a float called <code class="literal">sightRange</code>, for how far the AI can see, and an angle representing the field of view (to one side) in radians.</li><li class="listitem">With this done, we create a <code class="literal">sense()</code> method. Inside we define a Quaternion called <code class="literal">aimDirection</code> that will be the ray direction relative to the AI's <code class="literal">viewDirection</code> field.</li><li class="listitem">We convert the angle to a Quaternion and multiply it with <code class="literal">viewDirection</code> to get the direction of the ray, as shown in the following code:<div class="informalexample"><pre class="programlisting">rayDirection.set(viewDirection);
aimDirection.fromAngleAxis(angleX, Vector3f.UNIT_Y);
aimDirection.multLocal(rayDirection);</pre></div></li><li class="listitem">We check whether the ray collides with any of the objects in our <code class="literal">targetableObjects</code> list using the following code:<div class="informalexample"><pre class="programlisting">CollisionResults col = new CollisionResults();
for(Spatial s: targetableObjects){
  s.collideWith(ray, col);
}</pre></div></li><li class="listitem">If this<a id="id353" class="indexterm"/> happens, we set the target to be this object and exit the <a id="id354" class="indexterm"/>sensing loop, as shown in the following code. Otherwise, it should continue searching for it:<div class="informalexample"><pre class="programlisting">if(col.size() &gt; 0){
  target = col.getClosestCollision().getGeometry();
  foundTarget = true;
  break;
}</pre></div></li><li class="listitem">If the sense method returns true, the AI now has a target, and should switch to the <code class="literal">Follow</code> state. We add a check for this in the <code class="literal">controlUpdate</code> method and the <code class="literal">Idle</code> case, as shown in the following code:<div class="informalexample"><pre class="programlisting">case Idle:
  if(!targetableObjects.isEmpty() &amp;&amp; sense()){
    state = State.Follow;
  }
break;</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec133"/>How it works...</h2></div></div></div><p>The AI begins in an idle state. As long as it has some items in the <code class="literal">targetableObjects</code> list, it will run the <code class="literal">sense</code> method on each update. If it sees anything, it will switch to the <code class="literal">Follow</code> state and stay there until it loses track of the target.</p><p>The <code class="literal">sense</code> method consists of a <code class="literal">for</code> loop that sends rays in an arc representing a field of view. Each ray is limited by <code class="literal">sightRange</code> and the loop will exit if a ray has collided with anything from the <code class="literal">targetableObjects</code> list.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec134"/>There's more…</h2></div></div></div><p>Currently, it's very difficult to visualize the results. Exactly what does the AI see? One way of finding out is to create <code class="literal">Lines</code> for each ray we cast. These should be removed before each new cast. By following this example, we will be able to see the extent of the vision. The following steps will give us a way of seeing the extent of an AI's vision:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we need to define an array for the lines; it should have the same capacity as the number of rays we're going to cast. Inside the <code class="literal">for</code> loop, add the following code at the start and end:<div class="informalexample"><pre class="programlisting">for(float x = -angle; x &lt; angle; x+= FastMath.QUARTER_PI * 0.1f){
if(debug &amp;&amp; sightLines[i] != null){
                ((Node)getSpatial().getParent()).detachChild(sightLines[i]);
}
...Our sight code here...
if(debug){
  Geometry line = makeDebugLine(ray);
  sightLines[i++] = line;     ((Node)getSpatial().getParent()).attachChild(line);
}</pre></div></li><li class="listitem">The <code class="literal">makeDebugLine</code> method that we mentioned previously will look like the following<a id="id355" class="indexterm"/> code:<div class="informalexample"><pre class="programlisting">private Geometry makeDebugLine(Ray r){
  Line l = new Line(r.getOrigin(), r.getOrigin().add(r.getDirection().mult(sightRange)));
  Geometry line = new Geometry("", l);
  line.setMaterial(TestAiControl.lineMat);
  return line;
}</pre></div></li></ol></div><p>This simply <a id="id356" class="indexterm"/>takes each ray and makes something that can be seen by human eyes.</p></div></div>
<div class="section" title="Sensing &#x2013; hearing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Sensing – hearing</h1></div></div></div><p>The <a id="id357" class="indexterm"/>hearing we'll implement is one of the more basic models you can have. It's <a id="id358" class="indexterm"/>not as direct as vision, and requires a different approach. We'll assume that hearing is defined by <code class="literal">hearingRange</code>, and that the hearing ability has a linear fall off to that radius. We'll also assume that the sound emits something (in this case, footsteps), the volume of which is relative to the object's velocity. This would make sense in a stealth game, where sneaking should emit less sound than running. Sound is not blocked by obstacles or modified in any other way, apart from the distance between the target and the listener.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec135"/>How to do it...</h2></div></div></div><p>We will start by defining a class that all objects emitting sounds will use. This will require the following steps to be performed:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a class called <code class="literal">SoundEmitterControl</code>, extending <code class="literal">AbstractControl</code>.</li><li class="listitem">It needs three fields, a <code class="literal">Vector3f</code> called <code class="literal">lastPosition</code>, a float for <code class="literal">noiseEmitted</code>, and another float called <code class="literal">maxSpeed</code>.</li><li class="listitem">In the <code class="literal">controlUpdate</code> method, we sample the velocity the spatial has. This is the distance between the current <code class="literal">worldTranslation</code> and <code class="literal">lastPosition</code>. Divided by <code class="literal">tpf</code> (time-per-frame) we get the distance per second, as shown in the following code:<div class="informalexample"><pre class="programlisting">float movementSpeed = lastPosition.distance(spatial.getWorldTranslation()) / tpf;</pre></div></li><li class="listitem">If it's <a id="id359" class="indexterm"/>actually moving, we see how much it moves<a id="id360" class="indexterm"/> compared to <code class="literal">maxSpeed</code>. Normalized between 0 and 1, this value becomes <code class="literal">noiseEmitted</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">movementSpeed = Math.min(movementSpeed, maxSpeed);
noiseEmitted = movementSpeed / maxSpeed;</pre></div></li><li class="listitem">Finally, we set <code class="literal">lastPosition</code> to current <code class="literal">worldTranslation</code>. Now we will implement the changes to detect sound in <code class="literal">AIControl</code>. This will have five steps. We start by defining a float called <code class="literal">hearingRange</code>. In the <code class="literal">sense()</code> method, we parse the list of <code class="literal">targetableObjects</code> and see if they have <code class="literal">SoundEmitterControl</code>. If any does, we check the distance between it and the AI using the following code:<div class="informalexample"><pre class="programlisting">float distance = s.getWorldTranslation().distance(spatial.getWorldTranslation());</pre></div></li><li class="listitem">We get the <code class="literal">noiseEmitted</code> value from <code class="literal">SoundEmitterControl</code> and see how much is picked up by the AI, as shown in the following code:<div class="informalexample"><pre class="programlisting">float distanceFactor = 1f - Math.min(distance, hearingRange) / hearingRange;
float soundHeard = distanceFactor * noiseEmitted;</pre></div></li><li class="listitem">If the threshold of 0.25f is exceeded, the AI has heard the sound and will react.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec136"/>How it works...</h2></div></div></div><p>The <code class="literal">SoundEmitterControl</code> class is meant to define how much sound a moving character makes. It does this by measuring the distance traveled each frame, and translates it to speed per second by dividing by the time-per-frame. It's been adapted slightly to work for the free-flying camera used in the test case. That's why <code class="literal">maxSpeed</code> is set to <code class="literal">25</code>. It uses <code class="literal">maxSpeed</code> to define how much noise the spatial is causing, on a scale of <code class="literal">0</code> to <code class="literal">1</code>.</p><p>In the AI control class, we use the <code class="literal">sense()</code> method to test whether the AI has heard anything. It has a <code class="literal">hearingRange</code> field, with the range falling in a linear fashion from the location of the AI. Outside this range, no sound would be detected by the AI.</p><p>The method<a id="id361" class="indexterm"/> measures the distance from the sound emitting spatial, and <a id="id362" class="indexterm"/>factors this with the noise value it emits. For this example, a threshold of 0.25 is used to define whether the sound is loud enough for the AI to react.</p></div></div>
<div class="section" title="Decision making &#x2013; Finite State Machine"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Decision making – Finite State Machine</h1></div></div></div><p>Decision making for AI can be handled in many different ways, and one common way is to use a <span class="strong"><strong>Finite State Machine</strong></span> (<span class="strong"><strong>FSM</strong></span>). An FSM contains <a id="id363" class="indexterm"/>a number of predefined states. Each state<a id="id364" class="indexterm"/> has a set of functionality and behavior tied to it. Each state also has a number of conditions for when it can change to another state.</p><p>In this recipe, we'll define a state machine that will emulate a common AI behavior in games. In fact, it will be more advanced than many games, which usually have AI that can only either <a id="id365" class="indexterm"/>move <a id="id366" class="indexterm"/>around on a path, or attack. Our AI <a id="id367" class="indexterm"/>will have three states, <span class="strong"><strong>Patrol</strong></span>, <span class="strong"><strong>Attack</strong></span>, and <span class="strong"><strong>Retreat</strong></span>, as shown in the following diagram:.</p><div class="mediaobject"><img src="graphics/6478OS_05_02.jpg" alt="Decision making – Finite State Machine"/><div class="caption"><p>State diagram</p></div></div><p>The <code class="literal">PatrolState</code> will be the default and fallback state. It will perform random movement<a id="id368" class="indexterm"/> and will switch to <code class="literal">AttackState</code> if it spots an enemy.</p><p>The <code class="literal">AttackState</code> will<a id="id369" class="indexterm"/> handle firing and ammunition and will attack a target as long as it's visible and it has ammunition left. Then it will either return to <code class="literal">PatrolState</code> or flee using <code class="literal">RetreatState</code>.</p><p>The <code class="literal">RetreatState</code> will<a id="id370" class="indexterm"/> try to get away from a target for a set amount of time. After this, it will return to <code class="literal">PatrolState</code>, forgetting any fears it might previously have had.</p><p>All of our <a id="id371" class="indexterm"/>states will extend an abstract class called <code class="literal">AIState</code>, which we will also create in this recipe. This class in turn extends <code class="literal">AbstractControl</code>.</p><p>Worth noting is<a id="id372" class="indexterm"/> that all AI decision making and actions are handled from within the states. The states only relies on the AI control class to supply it with sensing updates (although this could also be handled by the states themselves).</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec137"/>How to do it...</h2></div></div></div><p>We will start by <a id="id373" class="indexterm"/>creating the <code class="literal">AIState</code> class. This will have two steps, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We add a field to store <code class="literal">AIControl</code> and give it two abstract methods called <code class="literal">stateEnter</code> and <code class="literal">stateExit</code>.</li><li class="listitem">These should be triggered when enabling and disabling the class, respectively. We override <code class="literal">setEnabled</code> to achieve this, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void setEnabled(boolean enabled) {
  if(enabled &amp;&amp; !this.enabled){
    stateEnter();
  }else if(!enabled &amp;&amp; this.enabled){
    stateExit();
  }
  this.enabled = enabled;
}</pre></div></li></ol></div><p>With <code class="literal">AIState</code> done, we can look at the first behavior, <code class="literal">PatrolState</code>. We can implement this by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all we add a <code class="literal">Vector3f</code> field called <code class="literal">moveTarget</code>. This is the position it will try to reach, relative to the current position.</li><li class="listitem">We add an <code class="literal">if</code> statement with three outcomes in the <code class="literal">controlUpdate</code> method, which is the main bulk of the logic in the class. The first clause should disable it and enable the <code class="literal">AttackState</code> if <code class="literal">AIControl</code> has found a suitable target using the following code:<div class="informalexample"><pre class="programlisting">if(aiControl.getTarget() != null){
  this.setEnabled(false);
  Vector3f direction = aiControl.getTarget().getWorldTranslation().subtract(spatial.getWorldTranslation());
  this.spatial.getControl(BetterCharacterControl.class).setViewDirection(direction);
  this.spatial.getControl(AttackState.class).setEnabled(true);
}</pre></div></li><li class="listitem"><a id="id374" class="indexterm"/>If its location is close enough to the <code class="literal">moveTarget</code> vector, it <a id="id375" class="indexterm"/>should pick a new one nearby, as shown in the following code:<div class="informalexample"><pre class="programlisting">else if(moveTarget == null || this.spatial.getWorldTranslation().distance(moveTarget) &lt; 1f){
  float x = (FastMath.nextRandomFloat() - 0.5f) * 2f;
  moveTarget = new Vector3f(x, 0, (1f - FastMath.abs(x)) - 0.5f).multLocal(5f);
  moveTarget.addLocal(this.spatial.getWorldTranslation());
}</pre></div></li><li class="listitem">Otherwise, it should keep moving towards the target, as shown in the following code:<div class="informalexample"><pre class="programlisting">else {
  Vector3f direction = moveTarget.subtract(this.spatial.getWorldTranslation()).normalizeLocal();
  aiControl.move(direction, true);
}</pre></div></li><li class="listitem">Finally, in the <code class="literal">stateExit</code> method, we should make it stop moving using the following code:<div class="informalexample"><pre class="programlisting">aiControl.move(Vector3f.ZERO, false);</pre></div></li></ol></div><p>That's one state out of three; let's look at the <code class="literal">AttackState</code>. We can implement this by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">AttackState</code> keeps track of values related to firing. It needs to have a float for <code class="literal">fireDistance</code>, which is how far the AI can fire; an integer called <code class="literal">clip</code>, which is how many rounds it has in the current clip; another integer called <code class="literal">ammo</code>, which <a id="id376" class="indexterm"/>defines how many rounds it has in total; and finally, a float called <code class="literal">fireCooldown</code>, which defines the time between each shot the AI fires.</li><li class="listitem">In the <code class="literal">stateEnter</code> method, we give the AI some ammunition. This is mostly for testing purposes, as shown in the following code:<div class="informalexample"><pre class="programlisting">clip = 5;
ammo = 10;</pre></div></li><li class="listitem">In the state's <code class="literal">controlUpdate</code> method, we do a number of checks. First we check whether <code class="literal">clip</code> is <code class="literal">0</code>. If<a id="id377" class="indexterm"/> this is true, we check whether <code class="literal">ammo</code> is <a id="id378" class="indexterm"/>also <code class="literal">0</code>. If this is also true, the AI must flee! We disable this state and enable <code class="literal">RetreatState</code> instead using the following code:<div class="informalexample"><pre class="programlisting">if(clip == 0){
  if(ammo == 0){
    this.setEnabled(false);
  this.spatial.getControl(RetreatState.class).setEnabled(true);
  }</pre></div></li><li class="listitem">If the state still has ammo, it should refill the clip. We also set a longer time until it can fire again, as shown in the following code:<div class="informalexample"><pre class="programlisting">else {
  clip += 5;
  ammo -= 5;
  fireCooldown = 5f;
}</pre></div></li><li class="listitem">In the main <code class="literal">if</code> statement, if the state has lost the target, it should disable the state and switch to <code class="literal">PatrolState</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">else if(aiControl.getTarget() == null){
  this.setEnabled(false);
  this.spatial.getControl(PatrolState.class).setEnabled(true);
}</pre></div></li><li class="listitem">If it still has a target and is in a position to fire, it should fire, as shown in the following code:<div class="informalexample"><pre class="programlisting">else if(fireCooldown &lt;= 0f &amp;&amp; aiControl.getSpatial().getWorldTranslation().distance(aiControl.getTarget().getWorldTranslation()) &lt; fireDistance){
  clip--;
  fireCooldown = 2f;
}</pre></div></li><li class="listitem">Finally, if it is still waiting for the weapon to cool down since the last shot, it should keep waiting, as shown in the following code:<div class="informalexample"><pre class="programlisting">else if(fireCooldown &gt; 0f){
  fireCooldown -= tpf;
}</pre></div></li></ol></div><p>The third<a id="id379" class="indexterm"/> and final state for our AI is <code class="literal">RetreatState</code>. We <a id="id380" class="indexterm"/>can implement this by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Like the <code class="literal">PatrolState</code>, it should have a <code class="literal">moveTarget</code> field that it tries to reach.</li><li class="listitem">We also add a float called <code class="literal">fleeTimer</code> that defines for how long it will try to get away.</li><li class="listitem">In its <code class="literal">controlUpdate</code> method, if <code class="literal">fleeTimer</code> has not reached <code class="literal">0</code> yet, and it still feels a threat, it will pick a location opposite from the target and move towards it, as shown in the following code:<div class="informalexample"><pre class="programlisting">Vector3f worldTranslation = this.spatial.getWorldTranslation();
if (fleeTimer &gt; 0f &amp;&amp; aiControl.getTarget() != null) {
  if (moveTarget == null || worldTranslation.distance(moveTarget) &lt; 1f) {
    moveTarget = worldTranslation.subtract(aiControl.getTarget().getWorldTranslation());
    moveTarget.addLocal(worldTranslation);
  }
  fleeTimer -= tpf;
  Vector3f direction = moveTarget.subtract(worldTranslation).normalizeLocal();
  aiControl.move(direction, true);
}</pre></div></li><li class="listitem">Otherwise, it's all clear, and it will switch to <code class="literal">PatrolState</code>.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec138"/>How it works...</h2></div></div></div><p>The first thing we did was define an abstract class called <code class="literal">AIState</code>. It's convenient to use the control pattern since it means we have access to the spatial and familiar ways to attach/detach states and turn them on and off.</p><p>The <code class="literal">stateEnter</code> and <code class="literal">stateExit</code> methods are called when the state is enabled and disabled, and happens on transition from and to other states. The class also expects there to be some kind of AI control class.</p><p>The first state extending <code class="literal">AIState</code> was the <code class="literal">PatrolState</code>. Its update method has three outcomes. If the AI has spotted something it can attack, it will change to the <code class="literal">AttackState</code>. Otherwise, if it's close to the place it has selected to move to, it will select a new target. Or, if it still has some way to go, it will just continue moving towards it.</p><p>The <code class="literal">AttackState</code> has a bit more functionality, as it also handles firing and ammunition management. Remember, if it has come here, the AI has already decided it should attack something. Hence, if it has no ammunition, it will switch to the <code class="literal">RetreatState</code> (although we <a id="id381" class="indexterm"/>generously give it some ammo every time it enters the state). Otherwise, it will attack or try attacking.</p><p>The <code class="literal">RetreatState</code> only has one goal: to try to get as far away from the threat as possible. Once it<a id="id382" class="indexterm"/> has lost sight of the target, or has fled for the specified amount of time, it will switch to <code class="literal">PatrolState</code>.</p><p>As we can see, the logic is all contained within the associated state, which can be very convenient. The flow of the states will also always make sure the AI ends up in the <code class="literal">PatrolState</code> in the end.</p></div></div>
<div class="section" title="Creating the AI using cover"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Creating the AI using cover</h1></div></div></div><p>Having <a id="id383" class="indexterm"/>AI using cover is a huge step towards making characters seem more <a id="id384" class="indexterm"/>believable and it usually makes them more challenging as they don't die as quickly.</p><p>There are many ways to implement this functionality. In the simplest form, the AI is not aware of any cover. It's simply scripted (by a designer) to move to a predefined favorable position when they spot an enemy. A player playing the sequence for the first time can't possibly notice the difference between an AI taking the decision by itself. Hence, the task of creating a believable AI (for that situation) is accomplished.</p><p>A much more advanced way would be to use the same principles for cover, which was established in <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>. However, evaluating options also becomes far more complex and unpredictable. Unpredictable AI might be good from the player's perspective, but it's a nightmare from a designer's perspective.</p><p>In this recipe, we'll go for a middle ground. First of all, we will base the AI on the FSM created in the previous recipe, and add a new state that handles finding cover. We will then add cover points to a scene, from which the AI can pick a suitable one and move there before attacking.</p><div class="mediaobject"><img src="graphics/6478OS_05_03.jpg" alt="Creating the AI using cover"/><div class="caption"><p>State diagram</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec139"/>How to do it...</h2></div></div></div><p>Let's begin <a id="id385" class="indexterm"/>by defining a class called <code class="literal">CoverPoint</code>, extending <code class="literal">AbstractControl</code> by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For <a id="id386" class="indexterm"/>now we can add a <code class="literal">Vector3f</code> called <code class="literal">coverDirection</code>. With getters and setters, that's all that's needed.</li><li class="listitem">We create a class called <code class="literal">SeekCoverState</code>, extending our <code class="literal">AIState</code> class from the previous recipe.</li><li class="listitem">It needs a list of <code class="literal">CoverPoints</code> called <code class="literal">availableCovers</code>, and a <code class="literal">CoverPoint</code> called <code class="literal">targetCover</code>.</li><li class="listitem">In the <code class="literal">stateEnter</code> method, it should look for a suitable cover point. We can do this with the following piece of code. It parses the list and takes the first <code class="literal">CoverPoint</code> where the dot product of the direction and <code class="literal">coverDirection</code> is positive:<div class="informalexample"><pre class="programlisting">for(CoverPoint cover: availableCovers){
  if(aiControl.getTarget() != null){
    Vector3f directionToTarget = cover.getSpatial().getWorldTranslation().add(aiControl.getTarget().getWorldTranslation()).normalizeLocal();
                if(cover.getCoverDirection().dot(directionToTarget) &gt; 0){
      targetCover = cover;
      break;
    }
  }
}</pre></div></li><li class="listitem">In the <code class="literal">controlUpdate</code> method, the AI should move towards <code class="literal">targetCover</code> if it has one.</li><li class="listitem">Once it gets close enough, <code class="literal">targetCover</code> should be set to null, indicating it should switch to <code class="literal">AttackState</code>.</li><li class="listitem">When this happens, <code class="literal">stateExit</code> should tell the AI to stop moving.</li><li class="listitem">After adding the new state to the AI control class, to let it know it has the ability<a id="id387" class="indexterm"/> to seek cover, we also need to modify other <a id="id388" class="indexterm"/>states to enable it.</li><li class="listitem">Most suitable is <code class="literal">PatrolState</code>, where it can switch to <code class="literal">SeekCoverState</code> instead of <code class="literal">AttackState</code> when it spots a target.</li><li class="listitem">If we have a test case for the Finite State Machine, all we would now need to do is to add some <code class="literal">CoverPoints</code> to a scene and see what happens.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec140"/>How it works...</h2></div></div></div><p>The <code class="literal">CoverPoint</code> class we created adds the behavior to any <code class="literal">Spatial</code> instances to act as a cover. In a game, you would most likely not see the <code class="literal">CoverPoint</code> spatial, but it's good for debug and editing purposes. The concept can be expanded to cover other types of interest points for AI, as well as modified to handle volumes, rather than points using the spatial's geometry.</p><p>Once the <code class="literal">SeekCoverState</code> is enabled, it will try to find a suitable cover point that's relative to the target's position (at that time). It does this using the dot product between <code class="literal">coverDirection</code> and the direction to the target. If this is positive, it means the target is in front of the cover, and it picks this as <code class="literal">targetCover</code>.</p><p>When the AI reaches this, it sets <code class="literal">targetCover</code> to <code class="literal">null</code>. This means that when <code class="literal">controlUpdate</code> is called the next time, it will exit the state and enable <code class="literal">AttackState</code> instead. In a real game, the AI would most likely use some kind of navigation or pathfinding to get there. You can get an introduction to navigation in the next recipe. There is also the <span class="emphasis"><em>Pathfinding: Our own A* pathfinder</em></span> recipe that covers implementing pathfinding later in the chapter.</p><p>With the current implementation of the AI, the result might be a bit erratic, since it doesn't remember the target's position. It might very well be that it doesn't see the target once it reaches the cover and instantly switches to <code class="literal">PatrolState</code>.</p></div></div>
<div class="section" title="Generating NavMesh in SDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Generating NavMesh in SDK</h1></div></div></div><p>Automatic<a id="id389" class="indexterm"/> NavMesh generation is a feature of the SDK available<a id="id390" class="indexterm"/> in the SceneExplorer. The NavMesh, as its name implies, is a mesh in which pathfinding can be applied to have AIs navigate through the game world. The generator takes a set of input values and, based on these, will create a mesh that stretches around obstacles. It can be seen as painted lines that the AI can use to know where it's safe to walk.</p><div class="mediaobject"><img src="graphics/6478OS_05_04.jpg" alt="Generating NavMesh in SDK"/><div class="caption"><p>NavMesh on top of the terrain</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec141"/>Getting ready</h2></div></div></div><p>The feature is available through a plugin, which we have to download first. Refer to the <span class="emphasis"><em>Downloading the plugins</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec142"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Once the plugin has been downloaded, we can open any scene in the <span class="strong"><strong>SceneComposer</strong></span> window, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/6478OS_05_05.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <span class="strong"><strong>SceneExplorer</strong></span> window, right-click on the top node, and navigate to <span class="strong"><strong>Add Spatial.. | NavMesh..</strong></span> to bring up the <span class="strong"><strong>options</strong></span> window.</li><li class="listitem">The<a id="id391" class="indexterm"/> simplest procedure from here is to click<a id="id392" class="indexterm"/> on <span class="strong"><strong>Finish</strong></span> and see what happens.</li><li class="listitem">A geometry called <code class="literal">NavMesh</code> will shortly appear in the list, and selecting it will display its reach. Blue lines indicate navigable paths.</li><li class="listitem">If we're happy with it (which might be difficult to say if it's the first time we see one), we save the scene.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec143"/>How it works...</h2></div></div></div><p>The method by which the generator works is controllable by the large number of settings available. It can be difficult to know how they all affect the result, and what kind of result we're after, anyway. The best way is simply to test different parameters until a desired result is achieved. Each line is a path the pathfinder can follow, and there should be no isolated islands. The less lines there are in the mesh, the more restricted the AI will be. Remember, that different settings are optimal for different scenes.</p></div></div>
<div class="section" title="Pathfinding &#x2013; using NavMesh"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Pathfinding – using NavMesh</h1></div></div></div><p>Pathfinding can<a id="id393" class="indexterm"/> be <a id="id394" class="indexterm"/>done in many different ways, and in this recipe we'll look at how to use the NavMesh generated in the previous recipe for pathfinding. We'll use jMonkeyEngine's AI plugin, which has a pathfinder designed to navigate NavMeshes.</p><p>We achieve this using the Control pattern, and will also implement a way to generate paths in a thread-safe way separate from the main update thread, to not impact the performance of the application.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec144"/>Getting ready</h2></div></div></div><p>We'll need <a id="id395" class="indexterm"/>a scene with a NavMesh geometry in it. We also need to download the AI library plugin. Instructions on how to download a plugin in the SDK can be found in the <span class="emphasis"><em>Downloading the plugins</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments</em></span>. The plugin is called <code class="literal">jME3 AI Library</code>. Once we have downloaded the plugin, we need to add it to the project. Right-click on the project and select <span class="strong"><strong>Properties</strong></span>, then select <span class="strong"><strong>Libraries</strong></span>, and then select <span class="strong"><strong>Add Library...</strong></span>. Select <span class="strong"><strong>jME3 AI Library</strong></span> and click on <span class="strong"><strong>Add Library</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec145"/>How to do it...</h2></div></div></div><p>We start by defining the class that will generate the paths for us. This part will be implemented by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class called <code class="literal">PathfinderThread</code>, which extends the <code class="literal">Thread</code> class.</li><li class="listitem">It needs a couple of fields, a <code class="literal">Vector3f</code> called <code class="literal">target</code>, a <code class="literal">NavMeshPathfinder</code> called <code class="literal">pathfinder</code>, and two Booleans, <code class="literal">pathfinding</code> and <code class="literal">running</code>, where <code class="literal">running</code> should be set to <code class="literal">true</code> by default.</li><li class="listitem">The constructor should take a <code class="literal">NavMesh</code> object as input, and we instantiate the <code class="literal">pathfinder</code> with the same, as shown in the following code:<div class="informalexample"><pre class="programlisting">public PathfinderThread(NavMesh navMesh) {
  pathfinder = new NavMeshPathfinder(navMesh);
  this.setDaemon(true);
}</pre></div></li><li class="listitem">We override the <code class="literal">run</code> method to handle <code class="literal">pathfinding</code>. While running is <code class="literal">true</code>, the following logic should apply:<div class="informalexample"><pre class="programlisting">if (target != null) {
  pathfinding = true;
  pathfinder.setPosition(getSpatial().getWorldTranslation());
  boolean success = pathfinder.computePath(target);
  if (success) {
    target = null;
  }
  pathfinding = false;
}</pre></div></li><li class="listitem">If <code class="literal">target</code> is not <code class="literal">null</code>, we set <code class="literal">pathfinding</code> to <code class="literal">true</code>.</li><li class="listitem">Then we set the start position of the pathfinder to the AI's current position, as shown in the following code:<div class="informalexample"><pre class="programlisting">pathfinder.setPosition(getSpatial().getWorldTranslation());</pre></div></li><li class="listitem">If the <a id="id396" class="indexterm"/>pathfinder can find a path, we set <code class="literal">target</code> to <code class="literal">null</code>.</li><li class="listitem">In either case, pathfinding is done, and <code class="literal">pathfinding</code> is set to <code class="literal">false</code>.</li><li class="listitem">Finally, we tell the thread to sleep for one second until trying again, as shown in the following code:<div class="informalexample"><pre class="programlisting">Thread.sleep(1000);</pre></div></li></ol></div><p>That's the first step of the pathfinding handling. Next, we'll define a class that will use this. This will be implemented by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class that extends <code class="literal">AbstractControl</code> called <code class="literal">NavMeshNavigationControl</code>.</li><li class="listitem">It needs two fields, a <code class="literal">PathfinderThread</code> called <code class="literal">pathfinderThread</code> and a <code class="literal">Vector3f</code> called <code class="literal">waypointPosition</code>.</li><li class="listitem">Its constructor should take a node as input, and we use this to extract a <code class="literal">NavMesh</code> from, and pass it on to <code class="literal">pathfinderThread</code>, which is instantiated in the constructor as follows:<div class="informalexample"><pre class="programlisting">public NavMeshNavigationControl(Node world) {
  Mesh mesh = ((Geometry) world.getChild("NavMesh")).getMesh();
  NavMesh navMesh = new NavMesh(mesh);
  pathfinderThread = new PathfinderThread(navMesh);
  pathfinderThread.start();
}</pre></div></li><li class="listitem">Now, we create a method to pass a position it should pathfind to using the following code:<div class="informalexample"><pre class="programlisting">public void moveTo(Vector3f target) {
  pathfinderThread.setTarget(target);
}</pre></div></li><li class="listitem">The <code class="literal">controlUpdate</code> method is what does the bulk of the work.</li><li class="listitem">We start by checking whether <code class="literal">waypointPosition</code> is <code class="literal">null</code>.</li><li class="listitem">If it is not null, we project <code class="literal">waypointPosition</code> and the spatials <code class="literal">worldTranslation</code> onto a 2D plane (by removing the <code class="literal">y</code> value), to see how far apart they are as follows:<div class="informalexample"><pre class="programlisting">Vector2f aiPosition = new Vector2f(spatialPosition.x, spatialPosition.z);
Vector2f waypoint2D = new Vector2f(waypointPosition.x, waypointPosition.z);
float distance = aiPosition.distance(waypoint2D);</pre></div></li><li class="listitem">If the <a id="id397" class="indexterm"/>distance is more than <code class="literal">1f</code>, we tell the spatial to move in the direction of the waypoint. This recipe uses the <code class="literal">GameCharacterControl</code> class from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>:<div class="informalexample"><pre class="programlisting">if(distance &gt; 1f){
  Vector2f direction = waypoint2D.subtract(aiPosition);
  direction.mult(tpf);
  spatial.getControl(GameCharacterControl.class).setViewDirection(new Vector3f(direction.x, 0, direction.y).normalize());
  spatial.getControl(GameCharacterControl.class).onAction("MoveForward", true, 1);
}</pre></div></li><li class="listitem">If the distance is less than <code class="literal">1f</code>, we set <code class="literal">waypointPosition</code> to <code class="literal">null</code>.</li><li class="listitem">If <code class="literal">waypointPosition</code> is null, and there is another waypoint to get from the pathfinder, we tell the pathfinder to step to the next waypoint and apply its value to our <code class="literal">waypointPosition</code> field as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">else if (!pathfinderThread.isPathfinding() &amp;&amp; pathfinderThread.pathfinder.getNextWaypoint() != null &amp;&amp; !pathfinderThread.pathfinder.isAtGoalWaypoint() ){
  pathfinderThread.pathfinder.goToNextWaypoint();
  waypointPosition = new Vector3f(pathfinderThread.pathfinder.getWaypointPosition());
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec146"/>How it works...</h2></div></div></div><p>The <code class="literal">PathfinderThread</code> handles pathfinding. To do this in a thread-safe way, we use the pathfinding Boolean to let other threads know it's currently busy, so that they don't try to read from the pathfinder.</p><p>Target is the position the pathfinder should try to reach. This is set externally and will be used to indicate whether the thread should attempt to pathfind or not. This is why we set it to null once pathfinding is successful.</p><p>We keep the thread running all the time, to avoid having to initialize it every time. The thread will wake up once a second to see whether there is any pathfinding to perform. If the delay was not there, it would use up resources, unnecessarily.</p><p>This class uses the <code class="literal">waypointPosition</code> field to store the current waypoint we're trying to reach. This is so that we don't need to look it up in the pathfinder every time, and thus risk interrupting an ongoing pathfinding. It also allows the AI to keep moving even if it's currently <a id="id398" class="indexterm"/>contemplating a new path.</p><p>The <code class="literal">controlUpdate</code> method first checks whether the <code class="literal">waypointPosition</code> is <code class="literal">null</code>. Null indicates it has no current goal, and should go to the pathfinder to see whether there is a new waypoint for it.</p><p>It can only get a new waypoint if <code class="literal">pathfinderThread</code> currently is not actively <code class="literal">pathfinding</code> and if there is a next waypoint to get.</p><p>If it already has a <code class="literal">waypointPosition</code> field, it will convert both the spatials position and the <code class="literal">waypointPosition</code> to 2D and see how far apart they are. This is necessary as we can't guarantee that <code class="literal">NavMesh</code> is exactly on the same plane as the spatial.</p><p>If it finds out that the distance is further than <code class="literal">1f</code>, it will find out the direction to the <code class="literal">waypointPosition</code> field and tell the spatial to move in that direction. Otherwise (if it's close enough), it will set the <code class="literal">waypointPosition</code> field to <code class="literal">null</code>.</p><p>Once it has reached the final waypoint, it will tell the spatial to stop.</p></div></div>
<div class="section" title="Controlling groups of AI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Controlling groups of AI</h1></div></div></div><p>In this <a id="id399" class="indexterm"/>recipe, we'll kill two birds with one stone and implement both an interface for group AI management and look at weighted decision making.</p><p>In many ways, the architecture will be similar to the <span class="emphasis"><em>Decision making – Finite State Machine</em></span> recipe. It's recommended to have a look at it before making this recipe. The big difference from the normal state machine is that instead of the states having definite outcomes, an AI Manager will look at the current needs, and assign units to different tasks.</p><p>This recipe will also make use of an <code class="literal">AIControl</code> class. This is also an extension of the <code class="literal">AIControl</code> that can be found in the <span class="emphasis"><em>Creating a reusable AI control class</em></span> recipe.</p><p>As an example, we'll use resource gathering units in an RTS. In this simplified game, there are two resources, wood and food. Food is consumed continuously by the workers and is the driving force behind the decision. The AI Manager will try to keep the levels of the food storage at a set minimum level, taking into account the current consumption rate. The scarcer the food becomes, the more units will be assigned to gather it. Any unit not occupied by food gathering will be assigned to wood gathering instead.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec147"/>How to do it...</h2></div></div></div><p>We'll start by defining a <code class="literal">GatherResourceState</code> class. It extends the same <code class="literal">AIState</code> we defined in the <span class="emphasis"><em>Decision making – Finite State Machine</em></span> recipe. This will be implemented by performing the <a id="id400" class="indexterm"/>following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all it needs access to the AIControl called <code class="literal">aiControl</code>.</li><li class="listitem">It needs two additional fields, a <code class="literal">Spatial</code> defining something to pick up called <code class="literal">resource</code>, and an integer called <code class="literal">amountCarried</code>.</li><li class="listitem">In <code class="literal">controlUpdate</code> method, we define two branches. The first is for if the unit isn't carrying anything, <code class="literal">amountCarried == 0</code>. In this case, the unit should move towards <code class="literal">resource</code>. Once it gets close enough, it should pick up some, and <code class="literal">amountCarried</code> should be increased, as shown in the following code:<div class="informalexample"><pre class="programlisting">Vector3f direction = resource.getWorldTranslation().subtract(this.spatial.getWorldTranslation());
if(direction.length() &gt; 1f){
  direction.normalizeLocal();
  aiControl.move(direction, true);
} else {
  amountCarried = 10;
}</pre></div></li><li class="listitem">In the other case, <code class="literal">amountCarried</code> is more than <code class="literal">0</code>. Now, the unit should move towards the HQ instead. Once it's close enough, <code class="literal">finishTask()</code> is called.</li><li class="listitem">The <code class="literal">finishTask</code> method calls the AI Manager via <code class="literal">aiControl</code> to increase the <a id="id401" class="indexterm"/>resource amount that the state handles with the supplied amount as follows:<div class="informalexample"><pre class="programlisting">aiControl.getAiManager().onFinishTask(this.getClass(), amountCarried);
amountCarried = 0;</pre></div></li><li class="listitem">Finally, we create two new classes that extend this class, namely <code class="literal">GatherFoodState</code> and <code class="literal">GatherWoodState</code>.</li></ol></div><p>With the new state handled, we can focus on the <code class="literal">AIControl</code> class. It will follow the pattern established elsewhere in the chapter, but it needs some new functionality. This will be implemented by performing the following three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It needs two new fields. The first is an <code class="literal">AIAppState</code> called <code class="literal">aiManager</code>. It also needs to keep track of its state in an <code class="literal">AIAppState</code> called <code class="literal">currentState</code>.</li><li class="listitem">In the <code class="literal">setSpatial</code> method, we add the two gathering states to our control, and make sure they're disabled, as shown in the following code:<div class="informalexample"><pre class="programlisting">this.spatial.addControl(new GatherFoodState());
this.spatial.addControl(new GatherWoodState());
this.spatial.getControl(GatherFoodState.class).setEnabled(false);
this.spatial.getControl(GatherWoodState.class).setEnabled(false);</pre></div></li><li class="listitem">We also <a id="id402" class="indexterm"/>add a method to set the state, <code class="literal">setCurrentState</code>. Sidestepping conventions, it should not set an instance of a state, but enable an existing state the AI control class has, while disabling the previous state (if any), as shown in the following code:<div class="informalexample"><pre class="programlisting">public void setCurrentState(Class&lt;? extends AIStateRTS&gt; newState) {
  if(this.currentState != null &amp;&amp; this.currentState.getClass() != newState){
    this.currentState.setEnabled(false);
  }
  this.currentState = state;
  this.currentState.setEnabled(true);
}</pre></div></li></ol></div><p>Now we have to write a class that manages the units. It will be based on the <code class="literal">AppState</code> pattern, and consists of the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by creating a new class called <code class="literal">AIAppState</code> that extends <code class="literal">AbstractAppState</code>.</li><li class="listitem">It needs a <code class="literal">List&lt;AIControl&gt;</code> of the units it controls, called <code class="literal">aiList</code>. We also add <code class="literal">Map&lt;Class&lt;? extends AIStateRTS&gt;</code>, <code class="literal">Spatial&gt;</code> called <code class="literal">resources</code> that contains the resources in the world that can be gathered.</li><li class="listitem">It then needs to keep track of its stock of <code class="literal">wood</code> and <code class="literal">food</code>. There are also fields for the current <code class="literal">foodConsumption</code> value per second, <code class="literal">minimumFoodStorage</code> it would like to keep, and a <code class="literal">timer</code> for how long before it wants to reevaluate its decisions.</li><li class="listitem">The <code class="literal">update</code> method is pretty simple. It starts by subtracting <code class="literal">foodConsumption</code> from the storage. Then, if <code class="literal">timer</code> has reached <code class="literal">0</code>, it will call the <code class="literal">evaluate</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">food -= foodConsumption * tpf;
food = Math.max(0, food);
timer-= tpf;
if(timer &lt;= 0f){
  evaluate();
  timer = 5f;
}</pre></div></li><li class="listitem">In the <code class="literal">evaluate</code> method, we begin by establishing the food requirement, as shown in the following code:<div class="informalexample"><pre class="programlisting">float foodRequirement = foodConsumption * 20f + minimumFoodStorage;</pre></div></li><li class="listitem">Then we decide how urgent food gathering is, on a factor of 0.0 - 1.0, as shown in the following code:<div class="informalexample"><pre class="programlisting">float factorFood = 1f - (Math.min(food, foodRequirement)) / foodRequirement;</pre></div></li><li class="listitem">Now<a id="id403" class="indexterm"/> we decide how many workers should be assigned to food gathering by taking that factor and multiplying it by the total amount of workers, as shown in the following code:<div class="informalexample"><pre class="programlisting">int numWorkers = aiList.size();
int requiredFoodGatherers = (int) Math.round(numWorkers * factorFood);
int foodGatherers = workersByState(GatherFoodState.class);</pre></div></li><li class="listitem">We create a helper method, called <code class="literal">workersByState</code>, that returns the number of workers assigned to a given state, as shown in the following code:<div class="informalexample"><pre class="programlisting">private int workersByState(Class&lt;? extends AIStateRTS&gt; state){
  int amount = 0;
  for(AIControl_RTS ai: aiList){
    if(ai.getCurrentState() != null &amp;&amp; ai.getCurrentState().getClass() == state){
      amount++;
    }
  }
  return amount;
}</pre></div></li><li class="listitem">Comparing the current gathers with the required amount, we know whether to increase or decrease the number of food gatherers. We then set the state to change according to whether more or less food gatherers are required, as shown in the following code:<div class="informalexample"><pre class="programlisting">int foodGatherers = workersByState(GatherFoodState.class);
int toSet = requiredFoodGatherers – foodGatherers;
Class&lt;? extends AIStateRTS&gt; state = null;
if(toSet &gt; 0){
  state = GatherFoodState.class;
} else if (toSet &lt; 0){
  state = GatherWoodState.class;
  toSet = -toSet;
}</pre></div></li><li class="listitem">We can create another method, called <code class="literal">setWorkerState</code>, that loops through <code class="literal">aiList</code> and calls <code class="literal">setCurrentState</code> of the first available worker. It reruns <code class="literal">true</code> if it has successfully set the state of a unit, as shown in the following code:<div class="informalexample"><pre class="programlisting">private boolean setWorkerState(Class&lt;? extends AIStateRTS&gt; state){
  for(AIControl_RTS ai: aiList){
    if(ai.getCurrentState() == null || ai.getCurrentState().getClass() != state){
      ai.setCurrentState(state);
      ((GatherResourceState)ai.getCurrentState()).setResource(resources.get(state));
      return true;
    }
  }
  return false;
}</pre></div></li><li class="listitem">The<a id="id404" class="indexterm"/> example implementation also requires that we set the resource for that state in the form of a spatial. This is so that the units know where they can pick up some of the resource. It can be set somewhere in the application, as shown in the following code:<div class="informalexample"><pre class="programlisting">aiAppState.setResource(GatherFoodState.class, foodSpatial);
aiAppState.setResource(GatherWoodState.class, woodSpatial);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec148"/>How it works...</h2></div></div></div><p>At the beginning of the game, we add one green food resource, and one brown wood resource, some distance away from the HQ (at 0,0,0). The <code class="literal">AIAppState</code> starts by looking at the current food storage, seeing it's low, it will assign an AI to go to the food resource and bring back food.</p><p>The <code class="literal">AIAppState</code> evaluate method starts by establishing the need for food gathering. It does this by dividing the food stores by the current requirement. By setting the food in the algorithm to not be able to exceed the requirement, we make sure we get a figure between 0.0 and 1.0.</p><p>It then takes the amount of units available, and decides how many of those should be gathering food, based on the <code class="literal">factorFood</code> figure, rounding it off to the nearest integer.</p><p>The result is compared to how many are currently on a food gathering mission, and adjusts the number to suit the current need, assigning them to either food or wood gathering.</p><p>The worker AI is completely controlled by the state they're set to by the manager, and in this recipe, all they can do is move to one resource or the other. They have no idle state, and are expected to always have some task.</p><p>The two<a id="id405" class="indexterm"/> states we use in the recipe are actually the same class. Both resources are gathered in the same way, and <code class="literal">GatherFoodState</code> and <code class="literal">GatherWoodState</code> are only used as identifiers. In a real game, they might well behave differently from each other. If not, it might be a good idea to use a parameterized version of <code class="literal">GatherResourceState</code> instead.</p></div><div class="section" title="There's more"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec149"/>There's more</h2></div></div></div><p>This recipe only has two different states, where one is the deciding one. What do we do if we have, let's say five equally important resources or tasks to consider? The principles are very much the same:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Begin by normalizing the need for each task between 0.0 and 1.0. This makes it easier to balance things.</li><li class="listitem" style="list-style-type: disc">Next, add all the values together, and divide each value by the sum. Now, each value is balanced with each other, and the total of all values is 1.0.</li></ul></div><p>In this recipe, the evaluation is done continuously, but it might just as well be applied when an AI has finished a task, to see what it should do next. In that case, the task could be picked at random among the distributed values to make it more dynamic.</p></div></div>
<div class="section" title="Pathfinding &#x2013; our own A* pathfinder"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Pathfinding – our own A* pathfinder</h1></div></div></div><p>Using the <a id="id406" class="indexterm"/>built-in functions of the <code class="literal">NavMesh</code> package might be enough for some, but in many cases we need customized pathfinding for our projects. Knowing how to implement, or even better, understanding A* (a-star) pathfinding, can take us a long way in our AI endeavors. It's easy to implement and very versatile. Correctly set up, it will always find the shortest path (and pretty fast too!). One of the drawbacks is that it can be memory-intensive in large areas if not kept in check.</p><p>A* is an algorithm that finds the shortest path in a graph. It's good at finding this quickly using <span class="strong"><strong>heuristics</strong></span>, or <a id="id407" class="indexterm"/>an estimation of the cost to get from a position in the graph to the goal position.</p><p>Finding a good value for the heuristic (H) is very important in order to make it effective. In technical terms, H needs <a id="id408" class="indexterm"/>to be <span class="strong"><strong>admissible</strong></span>. This means that the estimated cost should never exceed the actual cost.</p><p>Each position, called <a id="id409" class="indexterm"/>a node, will keep track of how the cost from the starting node to itself, using the current path. It will then choose the next node to go to base on this, cost plus the cost to the next node plus the estimated cost to the goal node.</p><p>A* could be <a id="id410" class="indexterm"/>said to work something like this; imagine that we're trying to find our way to a castle, through a maze. We're at an intersection, and can choose either the left path or the right path. We can see the castle in the distance to our left. We don't know anything about either path beyond the point where we're standing, but at least, taking the left path brings us closer to the castle, so it's natural to test that path.</p><p>Now, it could very well be that the left path is wrong, and much longer. That's the reason it also keeps track of how far it's travelled along the path. This is called G. The longer it travels along a path, the higher G will become. If the path also starts to deviate from the way to the castle, H will rise again. At some point G plus H might be higher than it would be at the entrance to the right path at the intersection. Then it will hop back to that point and see where the other path leads, until the point where G plus H along that path is higher.</p><p>This way, the AI using A* knows it's always traveled the shortest path once it exits the maze.</p><p>In this recipe, we'll use an estimated cost to the goal, H, that is the distance as-the-bird-flies between two nodes. This will guarantee that H is admissible and always equal to or less than the actual distance to travel.</p><p>We'll use the distance between nodes to calculate the cost to travel between them. This will be a lot to take in, but once done, we have a pathfinder we can use for many different applications.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec150"/>How to do it...</h2></div></div></div><p>We'll start by <a id="id411" class="indexterm"/>defining the node object, in a bean pattern. This will be implemented by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class called <code class="literal">WaypointNode</code> that extends <code class="literal">AbstractControl</code>.</li><li class="listitem">It needs three integers, <code class="literal">f</code>, <code class="literal">h</code>, and <code class="literal">g</code>.</li><li class="listitem">We also have to add two Booleans, <code class="literal">open</code> and <code class="literal">closed</code>, to aid the pathfinder, a list of <a id="id412" class="indexterm"/>other nodes, called <code class="literal">connections</code>, it's current position stored in <code class="literal">Vector3f</code> and another node as <code class="literal">parent</code>.</li></ol></div><p>Now we can <a id="id413" class="indexterm"/>create the pathfinder itself. This will be implemented by performing the following steps. We create a new class called AStarPathfinder.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The pathfinder class needs a list of nodes, called <code class="literal">openList</code>, which are the nodes currently considered.</li><li class="listitem">It has to know of the <code class="literal">startNode</code> and <code class="literal">goalNode</code>.</li><li class="listitem">The <code class="literal">pathfind</code> method is the heart of the class. We can take a look at it in full, before explaining it, as shown in the following code:<div class="informalexample"><pre class="programlisting">private void pathfind() {
  openList.add(startNode);
  WaypointNode current;
  while(!openList.isEmpty()) {
    current = openList.get(0);
    for (WaypointNode neighbor : current.getConnections()) {
      if (!neighbor.isClosed()) {
        if (!neighbor.isOpen()) {
          openList.add(neighbor);
          neighbor.setOpen(true);
          setParent(current, neighbor);
        } else if (current.getG() + neighbor.getPosition().distance(goalNode.getPosition()) &lt; neighbor.getG()) { // new path is shorter
          setParent(current, neighbor);
        }
      }
    }
      openList.remove(current);
    current.setClosed(true);
    if (goalNode.isClosed()) {
      break;
    }
    // sort list
    Collections.sort(openList, waypointComparator);
  }
  backtrack();
}</pre></div></li><li class="listitem">It should begin by adding the <code class="literal">startNode</code> to <code class="literal">openList</code>.</li><li class="listitem">Next, we define a while loop that always picks the first node in <code class="literal">openList</code>.</li><li class="listitem">Inside this loop, we create another <code class="literal">for</code> loop that iterates through all the currently selected connected nodes, called neighbors.</li><li class="listitem">If the <a id="id414" class="indexterm"/>neighboring node is not in <code class="literal">openList</code>, it should be added there. It should also set the current node to <code class="literal">parentNode</code> of the <code class="literal">neighbor</code> node, as shown in the following code:<div class="informalexample"><pre class="programlisting">openList.add(neighbor);
neighbor.setOpen(true);
neighbor.setParent(current);</pre></div></li><li class="listitem">While doing this, <code class="literal">g</code> of the neighbor should be set to current node's <code class="literal">G</code> plus the distance between the two nodes, as shown in the following code:<div class="informalexample"><pre class="programlisting">neighbor.setG(current.getG() + (int) (current.getPosition().distance(neighbor.getPosition()) * multiple));</pre></div></li><li class="listitem">Also, if <code class="literal">H</code> has not already been calculated for <code class="literal">neighbor</code>, it should, by measuring the distance between <code class="literal">neighbor</code> and <code class="literal">goalNode</code>. <code class="literal">F</code> should be updated by adding <code class="literal">G</code> and <code class="literal">H</code> together, as shown in the following code:<div class="informalexample"><pre class="programlisting">if(neighbor.getH() == 0){
  neighbor.setH((int) (neighbor.getPosition().distance(goalNode.getPosition()) * multiple));
}
neighbor.updateF();</pre></div></li><li class="listitem">It might also be that a shorter path has been discovered since <code class="literal">neighbor</code> was calculated. In this case, the neighbor should be updated again with the <code class="literal">current</code> node as <code class="literal">parent</code>. Do that and repeat the previous two steps.</li><li class="listitem">If <code class="literal">neighbor</code> is closed, it shouldn't do anything with it.</li><li class="listitem">Once the neighbors have been parsed, the current node should be removed from <code class="literal">openList</code>. <code class="literal">openList</code> should then be reordered according to the total cost, <code class="literal">F</code>, of the nodes.</li><li class="listitem">The looping of <code class="literal">openList</code> should exit, either when it's empty, or when the <code class="literal">goalNode</code> has been reached, which is indicated by when it's closed.</li><li class="listitem">When the pathfinding is done, the shortest path can be extracted by going through the parent nodes starting with the <code class="literal">goalNode</code>, as shown in the following code. Reversing the resulting list will yield the best path, from <code class="literal">startNode</code> to <code class="literal">goalNode</code>. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">private void backtrack() {
  List&lt;WaypointNode&gt; path = new ArrayList&lt;WaypointNode&gt;();
  path.add(goalNode);
  WaypointNode parent = goalNode;
  while (parent != null) {
    parent = parent.getParent();
    path.add(parent);
  }
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec151"/>How it works...</h2></div></div></div><p>The node bean that we created stores information about the state of the node, which is set by the pathfinder as it passes, or considers passing a node. The <code class="literal">g</code> value is the total cost to this<a id="id415" class="indexterm"/> node, along the current path, from the starting node. <code class="literal">h</code> is the estimated value left to the <code class="literal">goalNode</code>. In this recipe, it's the shortest distance possible. To be the most effective, it should be as close to the actual distance as possible, without exceeding it. This is to guarantee that it finds the shortest path. <code class="literal">F</code> is simply <code class="literal">g</code> and <code class="literal">h</code> added together, becoming the total estimated cost of the path using this node, and is the value used by the algorithm to consider.</p><p>These values are stored as integers, rather than floats. This is better both for memory and processing purposes. We get around lower-than-one distances by multiplying them with 100.</p><p>It also keeps track of whether it's currently open or closed. It's quicker to query the node itself, than seeing if the list contains it. The node actually has three states, either open, closed, or the standard, neither which is when it has not yet been considered for the path. The parent of a node defines from which other node the path came to this node.</p><p>
<code class="literal">openList</code> contains all the nodes the pathfinder is currently considering. It starts with only the <code class="literal">startNode</code>, adding all its neighbors, since none are either open or closed at this stage. It also sets the parent of the node, calculates the cost to get to this node, and estimates the cost left to the goal (if it has not been calculated before). It only needs to do this once per node, as long as the goal is not moving.</p><p>Now, <code class="literal">openList</code> has a few new nodes to work with, and the current node is removed from the list. At the end of the <code class="literal">while</code> loop, we sort <code class="literal">openList</code> according to <code class="literal">f-cost</code> of the nodes, so that it always starts looking at the node with the lowest total cost. This is to make sure it doesn't spend any unnecessary time looking at paths which are not optimal.</p><p>The algorithm can be considered to be successful once the <code class="literal">goalNode</code> has been put in <code class="literal">openList</code> and is set to closed. We can't end searching just because the <code class="literal">goalNode</code> enters <code class="literal">openList</code>. Since we also reconsider nodes if we find a shorter path to the node, we want to check all the <code class="literal">goalNodes</code> neighbors as well before ending the search.</p><a id="id416" class="indexterm"/><p>If there is no path available to the <code class="literal">goalNode</code>, <code class="literal">openList</code> will become empty before the <code class="literal">goalNode</code> is closed, and the search will fail.</p></div></div></body></html>