- en: Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next stop of our journey through design patterns will focus on the family
    of **structural design patterns**. We will be doing a Scala point of view exploration
    of the following structural design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will give a better understanding of what structural design patterns
    are and why they are useful. After familiarizing ourselves with what they are,
    we will be looking into each of them separately and in detail, including code
    examples and hints about when to use each of them and when to avoid them, as well
    as what to be careful with when using them.
  prefs: []
  type: TYPE_NORMAL
- en: Defining structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structural design patterns are concerned with composing objects and classes
    in our software. They use different approaches in order to obtain new functionality
    and larger and potentially more complex structures. These approaches include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly identifying the relationships between objects in an application is
    key to simplifying the application's structure. In the following sections, we
    will be looking at different design patterns and provide examples, which will
    give us a better feel of how to use the various structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, we have to make applications work by combining different components
    together. However, quite often, we have a problem where the component interfaces
    are incompatible with each other. Similarly with using public or any libraries,
    which we cannot modify ourselves, it is quite rare that someone else's views will
    be exactly the same as ours in our current settings. This is where adapters help.
    Their purpose is to help incompatible interfaces work together without modifying
    their source code.
  prefs: []
  type: TYPE_NORMAL
- en: We will be showing how adapters work using a class diagram and an example in
    the next few subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the adapter class diagram, let''s imagine that we want to switch to using
    a new logging library in our application. The library we are trying to use has
    a log method that takes the message and the severity of the log. However, throughout
    our whole application, we expect to have the `info`, `debug`, `warning`, and `error`
    methods that only take the message and automatically set the right severity. Of
    course, we cannot edit the original library code, so we have to use the adapter
    pattern. The following figure shows the class diagram that represents the adapter
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c53c864-1ecb-4912-b6da-524f164b035d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see our adapter (**AppLogger**) extend and
    also use an instance of **Logger** as a field. While implementing the methods,
    we then simply call the log method with different parameters. This is the general
    adapter implementation and we will see the code for it in the next subsection.
    There are some cases where extending might not be possible and we will show how
    Scala can deal with this. Also, we will show some advanced usage of the language
    features to achieve the adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let''s see the code for our `Logger` that we assume that we cannot
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve tried to keep it as simple as possible in order to not distract the
    reader from the main purpose of this book. Next, we could either just write a
    class that extends `Logger` or we could provide an interface for abstraction.
    Let''s take the second approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can create our `AppLogger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, our output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d24f61fd-75e9-4fdc-b394-ee70ee9630c6.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we haven't implemented the class diagram exactly as shown.
    We don't need the `Logger` instance as a field of our class, because our class
    is an instance of `Logger` already and we have access to its methods anyway. If
    we were to expand the behavior of the original `log` method, then we would need
    an instance of `Logger` as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we implement and use the basic adapter design pattern. However,
    there are cases where the class we want to adapt is declared as `final` and we
    are unable to extend it. We will show how to handle this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter design pattern with final classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we declare our original logger as final, we will see that our code will
    not compile. There is a different way to use the adapter pattern in this case.
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we simply wrap the final logger inside a class and then use it
    to call the `log` method with different parameters. The usage is absolutely the
    same as before. This could have a variation where the logger is passed as a constructor
    parameter as well. This is useful in cases where creating the logger requires
    some extra parameterization during creation.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter design pattern the Scala way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already mentioned multiple times, Scala is a rich programming language.
    Because of this fact, we can use implicit classes to achieve what the adapter
    pattern does. We will be using the same `FinalLogger` that we had in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit classes provide implicit conversions in places where possible. In
    order for the implicit conversions to work, we need to have the implicits imported
    and that''s why they are often defined in objects or package objects. For this
    example, we will use a package object. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a `package object` for the package where our logger examples are defined.
    It will automatically convert a `FinalLogger` instance to our implicit class.
    The following code snippet shows an example usage of our logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The final output will be exactly the same as our first example.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter design pattern is useful in cases *after* the code is designed and
    written. It allows us to make, otherwise incompatible, interfaces work together.
    It is also pretty straightforward to implement and use.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a problem with the last implementation mentioned in the preceding section.
    It is the fact that we will have to always import our package or normal object
    when using the logger. Also, implicit classes and conversions sometimes make the
    code much harder to read and understand. Implicit classes have some limitations,
    as described here:Â [http://docs.scala-lang.org/overviews/core/implicitclasses.html.](https://docs.scala-lang.org/overviews/core/implicit-classes.html)
  prefs: []
  type: TYPE_NORMAL
- en: As we already mentioned, the adapter design pattern is useful when we have code
    that we cannot change. If we are able to fix our source code, then this might
    be a better decision because using adapters throughout our program will make it
    difficult to maintain and hard to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where we might want to add some extra functionality to a class
    in an application. This could be done via inheritance; however, we might not want
    to do this or it may affect all the other classes in our application. This is
    where the decorator design pattern is useful.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the decorator design pattern is to add functionality to objects
    without extending them and without affecting the behavior of other objects from
    the same class.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator design pattern works by wrapping the decorated object, and it
    can be applied during runtime. Decorators are extremely useful in the cases where
    there could be multiple extensions of a class and they could be combined in various
    ways. Instead of writing all the possible combinations, decorators can be created
    and they can stack the modifications on top of each other. The next few subsections
    will show how and when to use decorators in real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw previously with the adapter design pattern, its aim is to change
    an interface to a different one. The decorator, on the other hand, helps us to
    enhance an interface by adding extra functionality to methods. For the class diagram,
    we will use an example with data streams. Imagine that we have a basic stream.
    We might want to be able to encrypt it, compress it, replace its characters, and
    so on. Here is the class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d9bc629-779f-4eae-bf5b-a574a4fd21e5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the `AdvancedInputReader` provides a basic implementation
    of the `InputReader`. It wraps a standard `BufferedReader`. Then, we have an abstract
    `InputReaderDecorator` class that extends the `InputReader` and contains an instance
    of it. By extending the base decorator, we provide the possibility to have streams
    that capitalize, compress, or `Base64` encode the input they get. We might want
    to have different streams in our application and they could be able to do one
    or more of the preceding operations in different orders. Our code will quickly
    become difficult to maintain and messy if we try and provide all possibilities,
    especially when the number of possible operations is even more. With decorators,
    it is nice and clean, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the actual code that describes the decorator design
    pattern shown in the previous diagram. First of all, we define our `InputReader`
    interface using a trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we provide the basic implementation of the interface in the `AdvancedInputReader`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to apply the decorator design pattern, we have to create different
    decorators. We have a base decorator that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have different implementations of our decorator. First, we implement
    a decorator that turns all text into upper case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we implement a decorator that uses `gzip` to compress each line of our
    input separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a decorator that encodes each line to `Base64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have demonstrated the decorator design pattern using an intermediate abstract
    class that all decorators extend. We could have achieved this design pattern without
    the intermediate class and by just directly extending and wrapping `InputReader`.
    This implementation, however, adds a bit more structure to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use these decorators in our application to add extra functionality
    to our input stream as needed. The usage is straightforward. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used the text file part of our classpath with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the order in which we apply decorators will define the order in
    which their enhancements will be applied. The output of the preceding example
    will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5385309-e4b2-4a19-b217-d37d2fe3ee06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see another example, but this time we will apply all the decorators
    we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will read the text, capitalize it, `Base64` encode it, and finally
    compress it with `gzip`. The following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deaa0b3e-110f-42d7-90cc-1ce7f0d09fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, in the compressing decorator code,
    we are logging the size of the lines in bytes. The output is gzipped and this
    is the reason for the text showing up as unreadable characters. You can experiment
    and change the order of the application of the decorators or add new ones in order
    to see how things can differ.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator design pattern the Scala way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the other design patterns, this one has an implementation that takes
    advantage of the richness of Scala and uses some of the concepts we looked at
    throughout the initial chapters of this book. The decorator design pattern in
    Scala is also called **stackable traits**. Let's see what it looks like and how
    to use it. The `InputReader` and `AdvancedInputReader` code will remain exactly
    as shown in the previous section. We are actually reusing it in both examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, instead of defining an `abstract` decorator class, we will just define
    the different reader modifications in new traits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the compressing input reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Base64` encoder reader is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation here is not much different. Here, we used
    traits instead of classes, extended the base `InputReader` trait, and used `abstract
    override`.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract override allows us to call `super` for a method in a trait that is
    declared abstract. This is permissible for traits as long as the trait is mixed
    in after another trait or a class that implements the preceding method. The abstract
    override tells the compiler that we are doing this on purpose and it will not
    fail our compilationâit will check later, when we use the trait, whether the requirements
    for using it are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we presented two examples. We will now show you what they look
    like with stackable traits. The first one that only capitalizes will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example that capitalizes, `Base64` encodes, and compresses the stream
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output of both the examples will be exactly the same as in the original
    examples. Here, however, we are using mixin composition and things look somewhat
    cleaner. We also have one class less, as we don't need the abstract decorator
    class. Understanding how modifications are applied is also easyâwe just follow
    the order in which the stackable traits are mixed in.
  prefs: []
  type: TYPE_NORMAL
- en: Stackable traits follow the rules of linearizationThe fact that in our current
    example the modifications are applied from left to right is deceiving. The reason
    this happens is because we push calls on the stack until we reach the basic implementation
    of `readLines` and then apply modifications in a reverse order. We will see more
    in-depth examples of stackable traits that will showcase all of their specifics
    in the coming chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators add a lot of flexibility to our applications. They don't change the
    original classes, hence they don't introduce errors in the older code and can
    save on a lot of code writing and maintenance. Also, they could prevent us from
    forgetting or not foreseeing some use cases with the classes we create.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples, we showed some static behavior modifications. However,
    it is also possible to dynamically decorate instances at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the positive aspects of using decorators; however, we should
    point out that overusing decorators could cause issues as well. We might end up
    with a high number of small classes and they could make our libraries much harder
    to use and more demanding in terms of requiring more domain knowledge. They also
    complicate the instantiation process, which would require other (creational) design
    patterns, for example, factories or builders.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some applications can have multiple different implementations of a specific
    functionality. The implementations could be in the form of different algorithms
    or something to do with multiple platforms. The implementations tend to vary often
    and they could also have new implementations throughout the life cycle of a program.
    Moreover, the implementations could be used in different ways for different abstractions.
    In cases like these, it is good to decouple things in our code, or else we are
    in danger of a class explosion.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the bridge design pattern is to decouple an abstraction from
    its implementation so that the two can vary independently.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge design pattern is quite useful in the cases where the abstractions
    or the implementations could vary often and independently. If we directly implement
    an abstraction, variations to the abstraction or the implementations would always
    affect all other classes in the hierarchy. This makes it hard to extend, modify,
    and reuse classes independently.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge design pattern eliminates a problem by directly implementing an abstraction,
    thus making the abstractions and implementations reusable and easier to change.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge design pattern is very similar to the adapter design pattern. The
    difference between them is that in the former, we apply it when we design our
    application, and the latter is used for legacy or third-party code.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the class diagram and the code example, let's imagine that we are writing
    a library that hashes passwords. In practice, storing passwords in plain text
    is something that should be avoided. This is what our library will help our users
    to do. There are many different hashing algorithms that can be used. Some are
    **SHA-1**, **MD5**, and **SHA-256**. We want to be able to support at least these
    and have the possibility to add new ones easily. There are different hashing strategiesâyou
    can hash multiple times, combine different hashes, add salt to the passwords,
    and so on. These strategies make our passwords harder to guess using rainbow tables,
    for example. For this example, we will show hashing with salt and simple hashing
    with any of the algorithms we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f53c6b0-bebc-4b1a-995a-5aab1e36e9be.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding diagram, we separated the implementation (**Hasher**
    and its implementations) from the abstraction (**PasswordConverter**). This allows
    us to easily add a new hashing implementation and then instantly use it by just
    providing an instance of it when creating a **PasswordConverter**. If we hadn't
    used the preceding builder pattern, we would probably have to create a password
    converter for each hashing algorithm separatelyâsomething that would make our
    code explode in size or become tedious to use.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the previous class diagram from the point of view
    of Scala code. First, we will focus on the implementation side with the `Hasher`
    trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have three classes that implement itâ`Md5Hasher`, `Sha1Hasher`, and
    `Sha256Hasher`. Their code is pretty simple and similar, but yields different
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the abstraction side of things. This is what our
    clients will use. The following listing shows the `PasswordConverter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have chosen to provide two different implementations hereâ`SimplePasswordConverter`
    and `SaltedPasswordConverter`. The code for them is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if a client wanted to use our library, they could write a program similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example application will look like the one in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cb79fc0-190c-4630-8fae-63445a675fde.png)'
  prefs: []
  type: TYPE_IMG
- en: Our library now allows us to easily add new strategies or new hashing algorithms
    and use them instantly. We don't have to change any of the existing classes.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge design pattern the Scala way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bridge design pattern is another example of those that can be achieved
    with the powerful features of the Scala programming language. Here, we will be
    using self types. The initial `Hasher` trait remains unchanged. Then, the actual
    implementations become traits instead of classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Having traits would allow us to mix them in when needed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve changed some names for this version of our example just to avoid confusion.
    The `PasswordConverter` (`PasswordConverterBase` in this case) abstraction now
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the compiler that when we useÂ `PasswordConverterBase`, we also need
    to have a `Hasher` mixed in. Then, we change the converter implementation to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use our new implementations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The output of this program will be identical to the original one. However, when
    we use our abstractions, we can mix in the hash algorithms we want to use. The
    benefits will become more obvious in the cases where we might have more implementations
    that we might want to combine together with hashing. Using mixins also looks more
    natural and is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already said, the bridge design pattern is similar to the adapter. Here,
    however, we apply it when we design our applications. One obvious benefit of using
    it is that we don't end up with an exponential number of classes in our application,
    which could make the use and maintenance of the pattern pretty complicated. The
    separation of hierarchies allows us to independently extend them without affecting
    the other one.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bridge design pattern requires us to write some boilerplate. It could complicate
    the use of the library in terms of which implementation is exactly picked, and
    it might be a good idea to use the bridge design pattern together with some creational
    design patterns. All in all, it doesn't have any major drawbacks, but the developer
    should be wise whether to use it or not depending on the current circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: The composite design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The composite design pattern is used to describe groups of objects that should
    be treated the same way as a single one.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the composite design pattern is to compose objects into tree
    structures to represent whole-part hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: The composite design pattern is useful for removing code duplication and avoiding
    errors in cases where groups of objects are generally treated the same way. A
    popular example could be a filesystem in which we have directories, which can
    have other directories or files. Generally, the interface to interact with directories
    and files is the same, so they are good candidates for a composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, filesystems are a good candidate for the composite
    design pattern. Essentially, they are just tree structures, so for our example,
    we will show you how to build a tree using the composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81048397-08ee-4e1c-a5cc-abb7b7b4f0dd.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding diagram, **Tree** is our composite object.
    It contains children, which could be either other **Tree** objects with more children
    nested recursively or just **Leaf** nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code representation for the previous diagram. First
    of all, we have to define the `Node` interface through a trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `prefix` parameter in the `print` method is used to aid visualization when
    printing the tree to a console.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have the interface, we can now define the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, using our code becomes pretty straightforward. While printing,
    we don''t need to care whether we do it on a leaf or a tree. Our code will automatically
    take care of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What this code actually does is depth-first traversal of our data structure.
    The actual example data structure that we have looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2afbd256-5117-4f2e-a920-adc3218c5639.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the output of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6171338c-ad8d-4fec-b25d-442f4f1cddd4.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, using composite, we can compose hierarchies of objects that
    have similar uses.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The composite design pattern is useful for reducing code duplication and simplification
    when we create hierarchies. The simplification part comes from the fact that clients
    do not need to know which type of objects they are dealing with. Adding new types
    of nodes is also easy and won't make us change anything else.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The composite design pattern pattern does not have any major drawbacks. It really
    is applicable in specific cases. One thing developers should be careful about
    is when they deal with massive hierarchies. The reason is that in such cases,
    we could have really deeply recursive nested items and this could cause stack
    overflow issues.
  prefs: []
  type: TYPE_NORMAL
- en: The facade design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we are building libraries or big systems, we quite often depend on
    other libraries and functionality. Implementing methods sometimes requires the
    use of multiple classes at the same time. This requires knowledge. Whenever we
    build a library for someone, we usually try and make it simpler for the users
    by assuming they do not have (and do not need) as extensive knowledge as we do.
    Additionally, developers make sure that components are easy to use throughout
    their application. This is where the facade design pattern can become useful.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the facade design pattern is to wrap a complex system with a
    simpler interface in order to hide the usage complexities and ease the client
    interaction.
  prefs: []
  type: TYPE_NORMAL
- en: We already looked at other design patterns based on wrapping. While the adapter
    design pattern transforms one interface to another and the decorator adds extra
    functionality, the facade makes things simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the class diagram, let''s imagine the following settingâwe want our users
    to be able to download some data from a server and get it de-serialized in the
    form of objects. The server returns our data in encoded form, so we should decode
    it first, then parse it, and finally return the right objects. This involves many
    operations and makes things complicated. That''s why we use a facade design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7608af3-84fd-4db5-ad28-4e9644fa97c5.png)'
  prefs: []
  type: TYPE_IMG
- en: When clients use the preceding application, they will just have to interact
    with the **DataReader**. Internally, it will take care of downloading, decoding,
    and deserializing the data.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding diagram shows the `DataDownloader`, `DataDecoder`, and `DataDeserializer`
    as composed objects inside `DataReader`. This is straightforward and clear to
    achieveâthey can be either created with their default constructors, or they can
    be passed as parameters. For the code representation of our example, however,
    we have chosen to use traits instead of classes and mix them in with the `DataReader`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the `DataDownloader`, `DataDecoder`, and `DataDeserializer`
    traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataDecoder` trait is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is of the `DataDeserializer` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementations are pretty straightforward and they are separated
    from each other, since they deal with different tasks. Anyone can use them; however,
    it requires some knowledge and makes things more complicated. That''s why we have
    a facade class called `DataReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This example clearly shows that instead of using three different interfaces,
    we now have a simple method to call. All complexity is hidden inside this method.
    The following listing shows a sample usage of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code makes use of our libraries, which are hidden from the client,
    really easy. Here is a sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfd4cb1d-9cf4-4428-9444-28bef266e265.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, in the preceding example, we could have used classes inside `DataReader`
    instead of mixing traits in. This really depends on the requirements and should
    yield the same results anyway.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The facade design pattern is useful when we want to hide the implementation
    details of many libraries, make an interface much easier to use, and interact
    with complex systems.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common mistake some people could make is try and put everything into a facade.
    This is something that usually doesn't help and the developers remain with a complex
    system, if not more, as before. Moreover, facade could prove to be restrictive
    for those users who have enough domain knowledge to use the original functionality.
    This is especially true if facade is the only way to interact with the underlying
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually when software is written, developers try to make it fast and efficient.
    Normally, this means less processing cycles and a smaller memory footprint. There
    are different ways to achieve these two aspects. Most of the time, a good algorithm
    will take care of the first one. The amount of used memory can have many causes
    and solutions, and the flyweight design pattern is there to help and reduce the
    memory used.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the flyweight design pattern is to minimize the memory usage
    with the help of an object that shares as much data as possible with other similar
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: There are many cases where many objects share the same information. A common
    example when talking about flyweight is word processing. Instead of representing
    each character with all the information about font, size, color, image, and so
    on, we could just store the positions for similar characters and have a reference
    to one object that contains the common information. This makes the usage of memory
    significantly smaller. Otherwise, such applications would become unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the class diagram,Â first let''s imagine that we are trying to represent
    a drawing for a color blindness test similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ade3b12d-4f5e-4f46-9bcb-d1e166734227.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, it is composed of circles of different sizes and colors. Potentially,
    this can be an infinitely big picture and it can have any number of circles. To
    make things simple, let''s just set a limitation where we can only have five different
    circle colorsâred, green, blue, yellow, and magenta. Here is what our class diagram
    will look likeÂ in order to represent an image like the preceding one using the
    flyweight design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b92d4fb5-f5d3-4ed4-b06e-cd9b52ef4481.png)'
  prefs: []
  type: TYPE_IMG
- en: The actual flyweight design pattern is implemented through the **CircleFactory**,
    **Circle**, and **Client** classes. The client requests the factory and it returns
    either a new instance of **Circle** or if one with the required parameters exists,
    it returns it from the cache. For this example, the shared data will be the **Circle**
    objects with their colors, and then each specific circle will have its own position
    and a radius. The **Graphic** will contain the actual circles with all of their
    information. Things will get much clearer with our code example, which the preceding
    diagram is based on.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to see how the flyweight design pattern looks like when expressed
    in Scala code. We will be using the same example as shown previously. It is worth
    noting that in the code version, some classes have different names than in the
    diagram. The reasons for this are Scala naming conventions. We will explicitly
    point out where this happens while going through the code.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing about the flyweight design pattern and our example is that
    it actually uses other design patterns and techniques that we already went through
    before. We will also point them out while looking at the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ve done is represent the colors. This has nothing to do
    with the actual flyweight design pattern, but we''ve decided to use ADTs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have the colors defined, we can implement our `Circle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The circles will be flyweight objects, so the model only has the data that
    will be shared with the other circle instances. Now that we have the model for
    the circles, we can create our `CircleFactory`. As the name suggests, it uses
    the factory design pattern. Here is the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a companion object that is used to implement the factory design pattern
    in Scala. This is why the name here is different than in the diagram shown previously.
    This representation allows us to either get an old instance of a circle or create
    a new one using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our circle and factory, we can implement the `Graphic` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Graphic` class will actually hold our circles with all other data related
    to them. The `Client` in the previous diagram does not have a specific representation
    in our codeâit will just be the code that uses the factory to obtain circles.
    Similarly, theÂ `Graphic` object will retrieve the circle objects by the program
    and not through explicit access to a client. Here is how all this is implemented
    in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/912b9415-dcae-4af1-a9f5-34abfbb765a4.png)'
  prefs: []
  type: TYPE_IMG
- en: While defining the `Circle` class earlier, we added a print message to the construction.
    From the preceding figure, we can see that each circle was created with a specific
    color only once, even though we requested it more times to build our graphic.
    The last line shows that we have exactly five distinct circle objects, even though
    our graphic contains 10 different circles.
  prefs: []
  type: TYPE_NORMAL
- en: This is just an example to illustrate how flyweight works. In real life, the
    flyweight objects will share many more attributes, thus lowering the overall memory
    footprint of the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already mentioned before, the flyweight design pattern is useful when
    we are trying to lower the memory used by an application. Using shared objects,
    our application will require less constructions and destructions of objects, which
    could further improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the amount of shared data, sometimes the number of distinct shared
    objects could dramatically grow and not bring too much benefit. Moreover, it can
    complicate the factory and its usage. Multithreaded applications need extra care
    while working with factories. Last but not least, the developers need to be really
    careful while using shared objects, as any change in them could affect the entire
    application. Luckily, in Scala, this is less of a concern due to immutability.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some applications, developers could face the need to provide access control
    to objects. This could be due to many reasons. Some of them include hiding implementation
    details, improving interaction with expensive resources, interfacing with remote
    resources, caching, providing lazy or eager initialization, and so on. The proxy
    design pattern helps to achieve these.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the proxy design pattern is to provide an interface to something
    else that then gets served behind the scenes to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy design pattern is another example of a wrapper. It is pretty similar
    to the decorator design pattern, but feels more basic and limited. The reason
    for this is that the relationship between the proxy and the wrapped object is
    established during compile time and decorators could be applied at runtime. In
    the end, its purpose is different.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the class diagram, let''s imagine that we have an application that visualizes
    text from files. It might need to visualize the text, or might not depending on
    user actions. These files could be enormous or could be somewhere in a remote
    location. Here is how the proxy design pattern could help us achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e670c45-10ea-4aab-959a-9996977aa397.png)'
  prefs: []
  type: TYPE_IMG
- en: According to the preceding diagram, we could use the **FileReaderProxy** objects
    and only when someone needs to access the file contents, we will delegate the
    functionality to the **FileReaderReal**. This design is nice and convenient because
    we can actually use the **FileReader** object; however, we can keep our application
    efficient by not needing to load everything at the same time, but just once when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s have a closer look at the code that implements the preceding class
    diagram. The first thing we need to define is the interface (using a Scala trait):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create two classes that implement itâ`FileReaderReal` and `FileReaderProxy`.
    First, let''s see how the former implements the file read as it has nothing of
    real significance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'During the construction of the object, it will get the file, read it, and store
    it in the contents variable. Then, whenever `readFileContents` is called, the
    class will return whatever it has buffered. Now, let''s take a look at the `FileReaderProxy`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The implementation contains an instance of `FileReaderReal`, which is created
    the first time `readFileContents` is called. The actual file read is then delegated
    to the `FileReaderReal` class.
  prefs: []
  type: TYPE_NORMAL
- en: A more elegant implementation of the `FileReaderProxy` would use a `lazy val`
    instead of a mutable variable. In such a case, the `if` statement won't be needed
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how our proxy can be used in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth noting that each file is actually a resource in the application
    and contains a line of text in the form of `I am file x`. After running the preceding
    example, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13ba72fe-f774-47b8-9f45-725ad691d1a2.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot , the real object is lazily created
    and so the actual file read is done on demand. This causes our application to
    skip reading `file2.txt` because we don't even request for it. Someone might come
    up with a different solution that serves the same purpose, but it will probably
    be a different design pattern or something similar to proxy.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proxy design pattern is good when we want to delegate some expensive operations
    to other classes, do operations lazily, and thus make our applications more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proxy design pattern is pretty simple and really, there are no drawbacks
    that could be mentioned. As with every other design pattern, they should be used
    carefully and only when actually needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about structural design patterns and specifically
    about the followingâadapter, decorator, bridge, composite, facade, flyweight,
    and proxy. We went through the details of each of them and showed a class diagram
    as well as a code example for each. Because of the richness of Scala, sometimes
    there can be a better implementation using some of the nice features of Scala,
    but sometimes the design pattern just looks the same as it would in a language
    such as Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, the structural design patterns seem quite similar. This, however,
    shouldn''t confuse you as they still have different purposes. Some examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapter versus Bridge**: Adapter is used to convert one interface to another
    when we do not have access to the code. Bridge is used while designing software
    and it decouples abstraction from implementation for easier extensions in the
    future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy versus Decorator**: Decorators usually enhance an interface. Proxies
    provide the same interface, but help with application efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you should have a good understanding of the structural design patterns
    and will have enough knowledge to apply them in real-world projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about *behavioral design patterns*.
  prefs: []
  type: TYPE_NORMAL
