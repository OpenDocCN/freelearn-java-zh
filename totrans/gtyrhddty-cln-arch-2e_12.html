<html><head></head><body>
<div id="_idContainer091">
<h1 class="hapter-number" id="_idParaDest-105"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.2.1">Enforcing Architecture Boundaries</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We talked a lot about architecture in previous chapters and it feels good to have a target architecture to guide us in our decisions on how to craft code and where to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">put it.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In every above-playsize software project, however, architecture tends to erode over time. </span><span class="koboSpan" id="kobo.5.2">Boundaries between layers weaken, code becomes harder to test, and we generally need more and more time to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">new features.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’ll discuss some measures that we can take to enforce the boundaries within our architecture and thus fight </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">architecture erosion.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.9.1">Boundaries and dependencies</span></h1>
<p><span class="koboSpan" id="kobo.10.1">Before we talk </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.11.1">about different ways of enforcing architecture </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.12.1">boundaries, let’s discuss where the boundaries lie within our architecture and what </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">enforcing a boundary</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.14.1">actually means.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.15.1"><img alt="Figure 12.1 – Enforcing architecture boundaries means enforcing that dependencies point in the right direction﻿ (dashed arrows mark dependencies that are not allowed according to our architecture﻿)" src="image/Figure_12.1._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.16.1">Figure 12.1 – Enforcing architecture boundaries means enforcing that dependencies point in the right direction (dashed arrows mark dependencies that are not allowed according to our architecture)</span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.17.1">Figure 12</span></em></span><em class="itali"><span class="koboSpan" id="kobo.18.1">.1 </span></em><span class="koboSpan" id="kobo.19.1">shows how the elements of our Hexagonal Architecture might be distributed across four layers, resembling the generic Clean Architecture approach introduced in </span><a href="B19916_03.xhtml#_idTextAnchor029"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.20.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.21.1">, </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.22.1">Inverting Dependencies</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">The innermost </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.25.1">layer contains domain entities and domain services. </span><span class="koboSpan" id="kobo.25.2">The application layer around it may access those entities and services to implement </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.26.1">a use case, usually through an application service. </span><span class="koboSpan" id="kobo.26.2">Adapters access those services through incoming ports or are being accessed by those services through outgoing ports. </span><span class="koboSpan" id="kobo.26.3">Finally, the configuration layer contains factories that create adapter and service objects and provides them to a dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">injection mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">In the preceding figure, our architecture boundaries become pretty clear. </span><span class="koboSpan" id="kobo.28.2">There is a boundary between each layer and its next inward and outward neighbor. </span><span class="koboSpan" id="kobo.28.3">According to the Dependency Rule, dependencies that cross such a layer boundary must always </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">point inward.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">This chapter is </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.31.1">about ways to enforce the Dependency Rule. </span><span class="koboSpan" id="kobo.31.2">We want to </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.32.1">make sure that there are no illegal dependencies that point in the wrong direction (dashed arrows in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the figure).</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.34.1">Visibility modifiers</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Let’s start with the most basic tool that object-oriented languages in general, and Java in particular, provide us with to enforce boundaries: </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.36.1">visibility modifiers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Visibility modifiers have </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.39.1">been a topic in almost every entry-level job interview I have conducted in the last couple of years. </span><span class="koboSpan" id="kobo.39.2">I would ask the interviewee which visibility modifiers Java provides and what their </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">differences are.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Most of the interviewees only list the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.42.1">public</span></strong><span class="koboSpan" id="kobo.43.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.44.1">protected</span></strong><span class="koboSpan" id="kobo.45.1">, and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.46.1">private</span></strong><span class="koboSpan" id="kobo.47.1"> modifiers. </span><span class="koboSpan" id="kobo.47.2">Only a few of them know the </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">package-private</span></strong><span class="koboSpan" id="kobo.49.1"> (or </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.50.1">default</span></strong><span class="koboSpan" id="kobo.51.1">) modifier. </span><span class="koboSpan" id="kobo.51.2">This is always a welcome opportunity for me to ask some questions about why such a visibility modifier would make sense in order to find out whether the interviewee can abstract from their </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">previous knowledge.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">So, why is the package-private modifier such an important modifier? </span><span class="koboSpan" id="kobo.53.2">Because it allows us to use Java packages to group classes into cohesive “modules.” </span><span class="koboSpan" id="kobo.53.3">Classes within such a module can access each other, but cannot be accessed from outside of the package. </span><span class="koboSpan" id="kobo.53.4">We can then choose to make specific classes public to act as entry points to the module. </span><span class="koboSpan" id="kobo.53.5">This reduces the risk of accidentally violating the Dependency Rule by introducing a dependency that points in the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">wrong direction.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Let’s have another look at the package structure discussed in </span><a href="B19916_04.xhtml#_idTextAnchor037"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.56.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.57.1">, </span><em class="itali"><span class="koboSpan" id="kobo.58.1">Organizing Code</span></em><span class="koboSpan" id="kobo.59.1">, with visibility modifiers </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">in mind:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.61.1"><img alt="" src="image/code-12.1.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.62.1">We can make the classes in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.63.1">persistence</span></strong><span class="koboSpan" id="kobo.64.1"> package package-private (marked with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.65.1">o</span></strong><span class="koboSpan" id="kobo.66.1"> in the tree above) because they don’t need to be accessed by the outside world. </span><span class="koboSpan" id="kobo.66.2">The persistence adapter </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.67.1">is accessed through the output ports it implements. </span><span class="koboSpan" id="kobo.67.2">For the same reason, we can make the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.68.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.69.1"> class package-private. </span><span class="koboSpan" id="kobo.69.2">Dependency injection mechanisms usually use reflection to instantiate classes, so they will still be able to instantiate those classes even if </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">they’re package-private.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">With Spring, this approach only works if we use the classpath scanning approach discussed in </span><a href="B19916_10.xhtml#_idTextAnchor089"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.72.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.73.1">, </span><em class="itali"><span class="koboSpan" id="kobo.74.1">Assembling the Application</span></em><span class="koboSpan" id="kobo.75.1">, however, since the other approaches require us to create instances of those objects ourselves, which requires </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">public access.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">The rest of the classes in the example have to be public (marked with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.78.1">+</span></strong><span class="koboSpan" id="kobo.79.1">) as defined by our architecture: the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.80.1">domain</span></strong><span class="koboSpan" id="kobo.81.1"> package needs to be accessible by the other layers and the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.82.1">application</span></strong><span class="koboSpan" id="kobo.83.1"> layer needs to be accessible by the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.84.1">web</span></strong><span class="koboSpan" id="kobo.85.1"> and </span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.86.1">persistence</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1"> adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">The package-private modifier is awesome for small modules with no more than a handful of classes. </span><span class="koboSpan" id="kobo.88.2">Once a package reaches a certain number of classes, however, it grows confusing to have so many classes in the same package. </span><span class="koboSpan" id="kobo.88.3">In this case, I like to create sub-packages to make the code easier to find (and, I admit, to satisfy my sense of aesthetics). </span><span class="koboSpan" id="kobo.88.4">This is where the package-private modifier fails to deliver, since Java treats sub-packages as </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.89.1">different packages and we cannot access a package-private member of a sub-package. </span><span class="koboSpan" id="kobo.89.2">So, members in sub-packages must be </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.90.1">public</span></strong><span class="koboSpan" id="kobo.91.1">, exposing them to the outside world and thus making our architecture vulnerable to </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">illegal dependencies.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.93.1">Post-compile fitness function</span></h1>
<p><span class="koboSpan" id="kobo.94.1">As soon as we use the public modifier on a class, the compiler will let any other class use it, even if the </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.95.1">direction of the dependency points in the wrong direction according to </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">our architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">Since the compiler won’t help us out in these cases, we have to find other means to check that the Dependency Rule </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">isn’t violated.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">One way is to </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.100.1">introduce a </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">fitness function</span></strong><span class="koboSpan" id="kobo.102.1"> – a function that takes our architecture as input and determines its fitness in regard to a specific aspect. </span><span class="koboSpan" id="kobo.102.2">In our case, </span><em class="itali"><span class="koboSpan" id="kobo.103.1">fitness</span></em><span class="koboSpan" id="kobo.104.1"> is defined as </span><em class="itali"><span class="koboSpan" id="kobo.105.1">the Dependency Rule is </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.106.1">not violated</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Ideally, a compiler runs a fitness function for us during compilation, but, lacking that, we can run such a function at runtime, after the code has already been compiled. </span><span class="koboSpan" id="kobo.108.2">Such runtime checks are best run during automated tests within a continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">integration build.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">A tool that supports this kind of architectural </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.111.1">fitness function for Java is </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">ArchUnit</span></strong><span class="koboSpan" id="kobo.113.1">.</span><span id="footnote-039-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-039"><span class="koboSpan" id="kobo.114.1">1</span></a></span><span class="koboSpan" id="kobo.115.1"> Among other things, ArchUnit provides an API to check whether dependencies point in the expected direction. </span><span class="koboSpan" id="kobo.115.2">If it finds a violation, it will throw an exception. </span><span class="koboSpan" id="kobo.115.3">It’s best run from within a test based on a unit testing framework such as JUnit, making the test fail in case of a </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">dependency violation.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-039">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-039-backlink"><span class="koboSpan" id="kobo.117.1">1</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.118.1">ArchUnit: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">https://github.com/TNG/ArchUnit</span></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.121.1">With ArchUnit, we can now check the dependencies between our layers, assuming that each layer has its own package, as defined in the package structure discussed in the previous section. </span><span class="koboSpan" id="kobo.121.2">For example, we can check that there is no dependency from the domain model on anything outside the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">domain model:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.123.1"><img alt="" src="image/code-12.2.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.124.1">This rule </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.125.1">validates the dependency rules visualized in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.126.1">Figure 12</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.127.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.129.1"><img alt="" src="image/Figure_12.2._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.130.1">Figure 12.2 – Our domain model may access itself and some library packages, but it may not access code in any other packages, for example, the packages containing our adapters (inspired by the diagrams at https://www.archunit.org/use-cases)</span></p>
<p><span class="koboSpan" id="kobo.131.1">The problem with the preceding rule is that if we use some library code in the domain model, we have to add an exception to this rule for every dependency we introduce (like I did with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.132.1">lombok</span></strong><span class="koboSpan" id="kobo.133.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.134.1">java</span></strong><span class="koboSpan" id="kobo.135.1"> in the example). </span><span class="koboSpan" id="kobo.135.2">In </span><a href="B19916_14.xhtml#_idTextAnchor118"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.136.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.137.1">, </span><em class="itali"><span class="koboSpan" id="kobo.138.1">A Component-Based Approach to Software Architecture</span></em><span class="koboSpan" id="kobo.139.1">, we will see a rule that doesn’t have </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">this problem.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">With a little work, we can </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.142.1">even create a kind of </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">domain-specific language</span></strong><span class="koboSpan" id="kobo.144.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.145.1">DSL</span></strong><span class="koboSpan" id="kobo.146.1">) on top of the ArchUnit API that allows us to specify all relevant packages within our Hexagonal Architecture and then automatically check whether all dependencies between those packages point in the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">right direction:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.148.1"><img alt="" src="image/code-12.3.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.149.1">In the preceding code example, we first specify the parent package of our application. </span><span class="koboSpan" id="kobo.149.2">We then go </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.150.1">on to specify the sub-packages for the domain, adapter, application, and configuration layers. </span><span class="koboSpan" id="kobo.150.2">The final call to </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.151.1">check()</span></strong><span class="koboSpan" id="kobo.152.1"> will then execute a set of checks, verifying that the package dependencies are valid according to the Dependency Rule. </span><span class="koboSpan" id="kobo.152.2">The code for this Hexagonal Architecture DSL is available on GitHub if you would like to play around </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">with it.</span></span><span class="No-Break"><span id="footnote-038-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-038"><span class="koboSpan" id="kobo.154.1">2</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-038">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-038-backlink"><span class="koboSpan" id="kobo.155.1">2</span></a><span class="koboSpan" id="kobo.156.1">	Hexagonal Architecture DSL for </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">ArchUnit: </span></span><a href="https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java"><span class="No-Break"><span class="koboSpan" id="kobo.158.1">https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.159.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.160.1">While post-compile checks like the previous one can be a great help in fighting illegal dependencies, they are not fail-safe. </span><span class="koboSpan" id="kobo.160.2">If we misspell the package name </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.161.1">buckpal</span></strong><span class="koboSpan" id="kobo.162.1"> in the preceding code example, for example, the test will find no classes and thus no dependency violations. </span><span class="koboSpan" id="kobo.162.2">A single typo, or, more importantly, a single refactoring renaming a package, can make the whole test useless. </span><span class="koboSpan" id="kobo.162.3">We should strive to make these tests refactoring-safe, or at least make them fail when a refactoring has broken them. </span><span class="koboSpan" id="kobo.162.4">In the preceding example, we can fail the test when one of the mentioned packages does not exist, for example (because it </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">was renamed).</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.164.1">Build artifacts</span></h1>
<p><span class="koboSpan" id="kobo.165.1">Until now, our only tool for demarcating architecture boundaries within our code base was packages. </span><span class="koboSpan" id="kobo.165.2">All of our code has been part of the same monolithic </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">build artifact.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">A build artifact is the </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.168.1">result of a (hopefully automated) build process. </span><span class="koboSpan" id="kobo.168.2">The most popular build tools in the Java world are currently Maven and Gradle. </span><span class="koboSpan" id="kobo.168.3">So, until now, imagine we had a single Maven or Gradle build script and we could call Maven or Gradle to compile, test, and package the code of our application into a single </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">JAR file.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">A main feature of </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.171.1">build tools is dependency resolution. </span><span class="koboSpan" id="kobo.171.2">To transform a certain code base into a build artifact, a build tool first checks whether all the artifacts the code base depends on are available. </span><span class="koboSpan" id="kobo.171.3">If not, it tries to load them from an artifact repository. </span><span class="koboSpan" id="kobo.171.4">If this fails, the build will fail with an error before even trying to compile </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">We can leverage this to enforce the dependencies (and thus enforce the boundaries) between the modules and layers of our architecture. </span><span class="koboSpan" id="kobo.173.2">For each such module or layer, we create a separate build module with its own code base and its own build artifact (JAR file) as a result. </span><span class="koboSpan" id="kobo.173.3">In the build script of each module, we specify only those dependencies to other modules that are allowed according to our architecture. </span><span class="koboSpan" id="kobo.173.4">Developers can no longer inadvertently create illegal dependencies because the classes are not even available on the classpath and they would run into </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">compile errors.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.175.1"><img alt="Figure 12.3 – Different ways of dividing our architecture into multiple build artifacts to prohibit illegal dependencies" src="image/Figure_12.3._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">Figure 12.3 – Different ways of dividing our architecture into multiple build artifacts to prohibit illegal dependencies</span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.177.1">Figure 12</span></em></span><em class="itali"><span class="koboSpan" id="kobo.178.1">.3</span></em><span class="koboSpan" id="kobo.179.1"> shows an incomplete set of options to divide our architecture into separate </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">build artifacts.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Starting on the left, we see a basic three-module build with a separate build artifact for the configuration, adapter, and application layers. </span><span class="koboSpan" id="kobo.181.2">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.182.1">configuration</span></strong><span class="koboSpan" id="kobo.183.1"> module may access the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.184.1">adapters</span></strong><span class="koboSpan" id="kobo.185.1"> module, which in turn may access the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.186.1">application</span></strong><span class="koboSpan" id="kobo.187.1"> module. </span><span class="koboSpan" id="kobo.187.2">The configuration module </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.188.1">may also access the application module due to the implicit, transitive dependency between them. </span><span class="koboSpan" id="kobo.188.2">The adapters module contains the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.189.1">web</span></strong><span class="koboSpan" id="kobo.190.1"> adapter as well as the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.191.1">persistence</span></strong><span class="koboSpan" id="kobo.192.1"> adapter. </span><span class="koboSpan" id="kobo.192.2">This means that the build tool will not prohibit dependencies between those adapters. </span><span class="koboSpan" id="kobo.192.3">While dependencies between those adapters are not strictly forbidden by the Dependency Rule (since both adapters are within the same outer layer), in most cases, it’s sensible to keep adapters isolated from each other. </span><span class="koboSpan" id="kobo.192.4">After all, we usually don’t want changes in the persistence layer to leak into the web layer and vice versa (remember the Single Responsibility Principle!). </span><span class="koboSpan" id="kobo.192.5">The same holds true for other types of adapters, for example adapters connecting our application to a certain third-party API. </span><span class="koboSpan" id="kobo.192.6">We don’t want details of that API leaking into other adapters by adding accidental dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">between adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Thus, we may split the single adapters module into multiple build modules, one for each adapter, as shown in the second column of </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.195.1">Figure 12</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.196.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">Next, we could decide to split up the application module further. </span><span class="koboSpan" id="kobo.198.2">It currently contains the incoming and outgoing ports to our application, the services that implement or use those ports, and the domain entities that should contain much of our </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">domain logic.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">If we decide that our domain entities are not to be used as transfer objects within our ports (i.e., we want to disallow the </span><em class="itali"><span class="koboSpan" id="kobo.201.1">No Mapping</span></em><span class="koboSpan" id="kobo.202.1"> strategy from </span><a href="B19916_09.xhtml#_idTextAnchor081"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.203.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.204.1">, </span><em class="itali"><span class="koboSpan" id="kobo.205.1">Mapping between Boundaries</span></em><span class="koboSpan" id="kobo.206.1">), we can apply the Dependency Inversion Principle and pull out a separate </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.207.1">api</span></strong><span class="koboSpan" id="kobo.208.1"> module that contains only the port interfaces (the third column in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.209.1">Figure 12</span></em></span><em class="itali"><span class="koboSpan" id="kobo.210.1">.3</span></em><span class="koboSpan" id="kobo.211.1">). </span><span class="koboSpan" id="kobo.211.2">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.212.1">adapter</span></strong><span class="koboSpan" id="kobo.213.1"> modules and the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.214.1">application</span></strong><span class="koboSpan" id="kobo.215.1"> module may access the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.216.1">api</span></strong><span class="koboSpan" id="kobo.217.1"> module, but not the other way around. </span><span class="koboSpan" id="kobo.217.2">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.218.1">api</span></strong><span class="koboSpan" id="kobo.219.1"> module does not have access to the domain entities and cannot use them within the port interfaces. </span><span class="koboSpan" id="kobo.219.2">Also, the adapters no longer have direct access to the entities and services, so they must go through </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">the ports.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">We can even go a step </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.222.1">further and split the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.223.1">api</span></strong><span class="koboSpan" id="kobo.224.1"> module in two, one part containing only the incoming ports and the other part only containing the outgoing ports (the fourth column in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.225.1">Figure 12</span></em></span><em class="itali"><span class="koboSpan" id="kobo.226.1">.3</span></em><span class="koboSpan" id="kobo.227.1">). </span><span class="koboSpan" id="kobo.227.2">This way, we can make it very clear whether a certain adapter is an incoming adapter or an outgoing adapter by declaring a dependency only on the input or the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">outgoing ports.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">Also, we could split the application module even further, creating a module containing only the services and another containing only the domain model. </span><span class="koboSpan" id="kobo.229.2">This ensures that the domain model doesn’t access the services, and it would allow other applications (with different use cases and thus different services) to use the same domain model by simply declaring a dependency on the domain </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">build artifact.</span></span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.231.1">Figure 12</span></em></span><em class="itali"><span class="koboSpan" id="kobo.232.1">.3</span></em><span class="koboSpan" id="kobo.233.1"> illustrates that there are a lot of different ways to divide an application into build modules, and there are of course more than just the four ways depicted in the figure. </span><span class="koboSpan" id="kobo.233.2">The gist is that the finer we cut our modules, the stronger we can control dependencies between them. </span><span class="koboSpan" id="kobo.233.3">The finer we cut, however, the more mapping we have to do between those modules, enforcing one of the mapping strategies introduced in </span><a href="B19916_09.xhtml#_idTextAnchor081"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.234.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.235.1">, </span><em class="itali"><span class="koboSpan" id="kobo.236.1">Mapping </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.237.1">between Boundaries</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Besides that, demarcating architecture boundaries with build modules has a number of advantages over using simple packages </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">as boundary:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.241.1">First, build tools absolutely hate circular dependencies. </span><span class="koboSpan" id="kobo.241.2">Circular dependencies are bad because a change in one module within the circle would potentially mean a change in all other modules within the circle, which is a violation of the Single Responsibility Principle. </span><span class="koboSpan" id="kobo.241.3">Build tools don’t allow circular dependencies because they would run into an endless loop while trying to resolve them. </span><span class="koboSpan" id="kobo.241.4">Thus, we can be sure that there are no circular dependencies between our </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">build modules.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.243.1">The Java compiler, on the other hand, doesn’t care at all if there is a circular dependency between two or more packages.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.244.1">Second, build modules allow isolated code changes within certain modules without having to take </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.245.1">the other modules into consideration. </span><span class="koboSpan" id="kobo.245.2">Imagine we have to do a major refactoring in the application layer that causes temporary compile errors in a certain adapter. </span><span class="koboSpan" id="kobo.245.3">If the adapters and application layer are within the same build module, some IDEs will insist that all compile errors in the adapters must be fixed before we can run the tests in the application layer, even though the tests don’t need the adapters to compile. </span><span class="koboSpan" id="kobo.245.4">If the application layer is in its own build module, however, the IDE won’t care about the adapters at the moment, and we could run the application layer tests at will. </span><span class="koboSpan" id="kobo.245.5">The same goes for running a build process with Maven or Gradle: if both layers are in the same build module, the build would fail due to compile errors in </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">either layer.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.247.1">So, multiple build modules allow isolated changes in each module. </span><span class="koboSpan" id="kobo.247.2">We could even choose to put each module into its own code repository, allowing different teams to maintain different modules.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.248.1">Finally, with each inter-module dependency explicitly declared in a build script, adding a new dependency becomes a conscious act instead of an accident. </span><span class="koboSpan" id="kobo.248.2">A developer who needs access to a certain class they currently cannot access will hopefully give some thought to the question if the dependency is really reasonable before adding it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">build script.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.250.1">These advantages come with the added cost of having to maintain a build script, though, so the architecture should be somewhat stable before splitting it into different </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">build modules.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Also, build modules tend to be less supple to change over time. </span><span class="koboSpan" id="kobo.252.2">Once chosen, we tend to stick with the modules we have initially defined. </span><span class="koboSpan" id="kobo.252.3">If the slicing of modules wasn’t right from the start, we are less </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.253.1">likely to correct it later because of the added effort of refactoring. </span><span class="koboSpan" id="kobo.253.2">Refactoring is easier when all the code lies within a single </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">build module.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.255.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.256.1">Software architecture is basically all about managing dependencies between architecture elements. </span><span class="koboSpan" id="kobo.256.2">If the dependencies become a big ball of mud, the architecture becomes a big ball </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">of mud.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">So, to preserve the architecture over time, we need to continually make sure that dependencies point in the </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">right direction.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">When producing new code or refactoring existing code, we should keep the package structure in mind and use package-private visibility when possible, to avoid dependencies to classes that should not be accessed from outside </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">the package.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">If we need to enforce architecture boundaries within a single build module, and the package-private modifier doesn’t work because the package structure won’t allow it, we can make use of post-compile tools such </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">as ArchUnit.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Any time we feel that the architecture is stable enough, we should extract architecture elements into their own build modules because this gives explicit control over </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">All three approaches can be combined to enforce architecture boundaries and thus keep the code base maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">In the next chapter, we’ll continue to explore architecture boundaries, but from a different perspective: we’ll think about how to manage multiple domains (or bounded contexts) in the same application, while keeping the boundaries between </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">them distinct.</span></span></p>
</div>
</body></html>