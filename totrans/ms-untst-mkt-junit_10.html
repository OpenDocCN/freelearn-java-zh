<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Best Practices</h1></div></div></div><div class="blockquote"><blockquote class="blockquote1"><p class="calibre20">"It is insanity to keep doing things the same way and expect things to improve."</p><p class="calibre20">—Anonymous</p></blockquote></div><p class="calibre9">Writing clean, readable, and maintainable JUnit test cases, just like writing clean code, is an art. A well-written unit test can prevent maintenance nightmare and acts as a system documentation; however, if not used carefully, it can produce meaningless boilerplate test cases. Mistakes are part of the learning process as long as you aren't making them repeatedly. JUnit is not rocket science, so we can practice, follow guidelines, and learn from others to make it perfect.</p><p class="calibre9">This chapter covers JUnit guidelines and best practices. The following categories are covered in depth:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Writing meaningful tests</li><li class="listitem">Test automation</li><li class="listitem">Test configuration</li><li class="listitem">Assertion convention</li><li class="listitem">Exception handling</li><li class="listitem">Test smells and refactoring test smells</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec52" class="calibre1"/>Writing meaningful tests</h1></div></div></div><p class="calibre9">The common understanding of unit testing is<a id="id742" class="calibre1"/> testing the smallest possible part of software, specifically a method. In reality, we do not test methods; rather, we test a logical unit or the behavior of the system.</p><p class="calibre9">Logical units can extent<a id="id743" class="calibre1"/> to a single method, to an entire class, or a collaboration of multiple classes. For example, a standard calculator program can have an add method for adding two numbers. We can verify the add behavior by invoking the <code class="literal">add</code> method, or we can design the calculator program to have a simple calculate API that can take two numbers and an operation (add, subtract, divide, and so on), and depending on the operand type (integer, double, and so on), the calculator may delegate the calculation to a collaborator class, such as a double calculator or a long calculator. We can still unit test the add behavior, but now multiple classes are involved. We can call this new test an integration test.</p><p class="calibre9">A unit test verifies an assumption about the behavior of the system. In addition to this, if a test tests the entire system, it can't be a unit test—we call these <a id="id744" class="calibre1"/>tests <span class="strong"><strong class="calibre10">confederation</strong></span> tests because they set up the entire ecosystem, including setting up the necessary components.</p><p class="calibre9">The following section elaborates on writing meaningful tests.</p></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Improving readability"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec53" class="calibre1"/>Improving readability</h2></div></div></div><p class="calibre9">Martin Fowler said <span class="strong"><em class="calibre11">Any fool can write code that a computer can understand. Good programmers write code that humans can understand</em></span>. Writing obscure code can be fashionable for old timers but it's not a standard Java practice. We should write readable and maintainable code such that anybody can understand the purpose of the code and enhance or maintain the code in future.</p><p class="calibre9">JUnit tests are written to<a id="id745" class="calibre1"/> test logical units. A test method name should portray the intention of the test so that a reader can understand what is being tested, such as the condition and the expectation or action.</p><p class="calibre9">Suppose you are <a id="id746" class="calibre1"/>writing a test for a role-based system and the system denies unauthorized access. You can use the following patterns, but if you choose to follow one pattern, it's best to stick to it:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">testDenialOfUnauthorizedAccess()</code></li><li class="listitem"><code class="literal">when_unauthorized_user_then_denies_the_access()</code></li><li class="listitem"><code class="literal">should_deny_access_for_unauthorized_users()</code></li></ul></div><p class="calibre9">I prefer the underscore (_) pattern as it's more readable.</p><p class="calibre9">For boundary value conditions, you can follow these patterns:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">testRegisteringNullUser()</code></li><li class="listitem"><code class="literal">should_not_register_a_null_user()</code></li><li class="listitem"><code class="literal">should_throw_exception_when_a_null_user_is_registered()</code></li><li class="listitem"><code class="literal">when_null_user_then_registrar_throws_exception()</code></li></ul></div><p class="calibre9">Likewise, a test class should portray the intention of the tests. Usually, we follow two conventions, <code class="literal">Test&lt;class name&gt;</code> or <code class="literal">&lt;class name&gt;Test</code>. Suppose you are testing the <code class="literal">UserRegistration</code> behavior. You can use <code class="literal">UserRegistrationTest</code> or <code class="literal">TestUserRegistration</code>. Several test coverage tools fail to recognize classes without the <code class="literal">Test</code> suffix. So, <code class="literal">UserRegistrationTest</code> is a safe choice.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Breaking everything that could possibly break"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec54" class="calibre1"/>Breaking everything that could possibly break</h2></div></div></div><p class="calibre9">An Extreme Programming concept is <span class="strong"><em class="calibre11">test everything that could possibly break</em></span>. This means trying all different combinations of inputs to make sure we don't miss any combination that can cause the class to generate an error. However, this is an impossible thing to do in practice. We can<a id="id747" class="calibre1"/> test boundary value conditions. We can even cover all branches and lines, but we cannot test all input combinations. Suppose a method adds two integers. We can pass <code class="literal">NULL</code>, <code class="literal">0</code>, <code class="literal">Integer.MAX_VALUE</code>, negative numbers, and so on, but we literally cannot test the method with all possible integer values.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Ignoring simple test cases"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec55" class="calibre1"/>Ignoring simple test cases</h2></div></div></div><p class="calibre9">Writing trivial JUnits (such that for getter and setter) is mostly a waste of time and money. We don't have the luxury to write infinite tests as it can eat our development time, application <a id="id748" class="calibre1"/>build time, and reduce test maintainability. If we start writing tests for getter/setters, we may miss more useful test cases. Usually, unit tests are automated and run during a build process. A build is required to finish early<a id="id749" class="calibre1"/> providing feedback, but the process will be delayed if we keep adding trivial tests. Unit tests are system documentation, so they portray the system behavior; however, if we keep adding tests for trivial things, then it defeats the purpose. Write tests that will pay you back with information.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Verifying invalid parameters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch10lvl2sec56" class="calibre1"/>Verifying invalid parameters</h2></div></div></div><p class="calibre9">Test invalid parameters to every method. Your code needs to recognize and handle invalid data. The tests that <a id="id750" class="calibre1"/>pass using incorrect data and boundary value conditions provide comprehensive API documentation.</p><p class="calibre9">Suppose you are writing a test for an <code class="literal">add</code> method. It takes two integers and returns an integer. The following is the <code class="literal">Adder</code> class:</p><div class="informalexample"><pre class="programlisting">public class Adder {
  public Integer add(Integer first, Integer second) {
    if (first == null || second == null) {
      throw new IllegalArgumentException("Invalid inputs first=[" + first+ "], second=[" + second + "]");
    }

    return first + second;
  }
}</pre></div><p class="calibre9">The boundary values that can be tested<a id="id751" class="calibre1"/> are null, zero, negative numbers, and overflow conditions, as follows:</p><div class="informalexample"><pre class="programlisting">public class AdderTest {
  Adder adder = new Adder();

<span class="strong"><strong class="calibre10">  @Test(expected=IllegalArgumentException.class)</strong></span>
<span class="strong"><strong class="calibre10">  public void should_throw_exception_when_encounters_a_NULL_input(){</strong></span>
<span class="strong"><strong class="calibre10">    adder.add(null, 1);</strong></span>
<span class="strong"><strong class="calibre10">  }</strong></span>
  
<span class="strong"><strong class="calibre10">  @Test(expected=IllegalArgumentException.class)</strong></span>
<span class="strong"><strong class="calibre10">  public void should_throw_exception_when_second_input_is_NULL(){</strong></span>
<span class="strong"><strong class="calibre10">    adder.add(2, null);</strong></span>
<span class="strong"><strong class="calibre10">  }</strong></span>
  
  @Test
  public void should_return_zero_when_both_inputs_are_zero(){
    int actual =adder.add(0, 0);
    assertEquals(0, actual);
  }
  
  @Test
  public void should_return_first_input_when_second_input_is_zero()  {
    int actual =adder.add(1, 0);
    assertEquals(1, actual);
  }
  
  @Test
  public void should_return_second_input_when_first_input_is_zero()  {
    int actual =adder.add(0, 2);
    assertEquals(2, actual);
  }
  
  @Test
  public void <span class="strong"><strong class="calibre10">should_return_zero_when_summation_is_zero()</strong></span>{
    int actual =adder.add(5, -5);
    assertEquals(0, actual);
  }
  
  @Test public void <span class="strong"><strong class="calibre10">should_return_a_negative_when_both_inputs_are_negative()</strong></span> {
    int actual =adder.add(-8, -5);
    assertTrue(actual &lt; 0);
  }
  
  
  @Test
  public void <span class="strong"><strong class="calibre10">should_overflow_when_summation_exceeds_integer_limit()</strong></span> {
    int actual =adder.add(Integer.MAX_VALUE, 1);
    assertTrue(actual&lt; 0);
  }
}</pre></div><p class="calibre9">Your class may have a public API that accepts user input and delegates input formatting to a dependent <a id="id752" class="calibre1"/>class or method. You should verify the user input in the public API only, not on all methods or dependent classes.</p><p class="calibre9">Suppose the class <code class="literal">A</code> has a <code class="literal">doSomething(String input)</code> method. <code class="literal">A</code> calls <code class="literal">B</code> to format the input. If clients can call only class <code class="literal">A</code>, then you should not worry about validating the null input in class <code class="literal">B</code>. However, if both <code class="literal">A</code> and <code class="literal">B</code> are exposed, then <code class="literal">B</code> definitely should check for the <code class="literal">NULL</code> values. Checking <code class="literal">NULL</code> everywhere is defensive programming.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Relying on direct testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch10lvl2sec57" class="calibre1"/>Relying on direct testing</h2></div></div></div><p class="calibre9">Suppose you have a <a id="id753" class="calibre1"/>facade class that depends on a utility class. Testing the facade class can cover the utility class. This is<a id="id754" class="calibre1"/> an example of indirect testing. The following <code class="literal">Facade</code> class depends on a <code class="literal">StringService</code> class for formatting; when we test<a id="id755" class="calibre1"/> the <code class="literal">Facade</code> class with a <code class="literal">String</code> value, then the <code class="literal">StringService</code> class is also tested:</p><div class="informalexample"><pre class="programlisting">public class Facade {
  private final StringService stringService;
  public Facade(StringService utility) {
    this.stringService= utility;
  }

  public Object doSomething(Object o) {
    if (o instanceof String) {
      return stringService.format((String) o);
    }

    if (o instanceof Integer) {
      return Integer.MIN_VALUE;
    }

    return null;
  }
}</pre></div><p class="calibre9">We should test <code class="literal">StringService</code> directly, even though its methods are also invoked by the tests of the <code class="literal">Facade</code> class. We should have two test classes: <code class="literal">FacadeTest</code> and <code class="literal">StringServiceTest</code>.</p><p class="calibre9">It's not a good idea to rely on indirect testing because if we change the implementation of the <code class="literal">Facade</code> class, then the dependent<a id="id756" class="calibre1"/> class may be uncovered. Suppose we change the implementation of the <code class="literal">Facade</code> class, so that it no longer depends on <code class="literal">StringService</code>. The tests in <code class="literal">StringServiceTest</code> will no longer invoke the methods of <code class="literal">StringService</code>, so we will lose code coverage.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Staying away from debugging"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch10lvl2sec58" class="calibre1"/>Staying away from debugging</h2></div></div></div><p class="calibre9">A common practice when we find a bug is to start debugging an application—stop doing this. Rather, add more tests to break the code; this will enrich<a id="id757" class="calibre1"/> your test suite and improve the system<a id="id758" class="calibre1"/> documentation. Similarly, don't put a catch block to print stacktrace. Rather, assert the exception message using the <code class="literal">ExpectedException</code> rule (explained in the <span class="strong"><em class="calibre11">Handling exceptions</em></span> section). Sometimes, it's not possible to avoid debugging entirely. So anyway, before starting to debug, create a (integration) test that reproduces the issue and then debug it. This will narrow down the problem, create a unit test for the lowest possible unit, and keep both the tests for future reference.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Avoiding generic matchers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch10lvl2sec59" class="calibre1"/>Avoiding generic matchers</h2></div></div></div><p class="calibre9">We tend to use wildcard matchers to stub mock object methods; in the same way, verify the method invocations<a id="id759" class="calibre1"/> with<a id="id760" class="calibre1"/> generic matchers. This is a bad practice; you should go for an exact parameter match when possible. The following example demonstrates the wildcard argument matching.</p><p class="calibre9">The <code class="literal">StringDecorator</code> class decorates the input with an exclamation symbol:</p><div class="informalexample"><pre class="programlisting">public class StringDecorator {
  public String decorate(String object) {
    return object+"!";
  }
}</pre></div><p class="calibre9">The <code class="literal">PrinterService</code> interface connects to a LAN printer and prints the input text as follows:</p><div class="informalexample"><pre class="programlisting">public interface PrinterService {
  void print(String text);
}</pre></div><p class="calibre9">The <code class="literal">Facade</code> class accepts an input, decorates the input, and sends it to <code class="literal">PrinterService</code> for printing. To unit test this <a id="id761" class="calibre1"/>behavior, we need to mock out <code class="literal">PrinterService</code> with a mock object using the following code:</p><div class="informalexample"><pre class="programlisting">public class Facade {
  private final Decorator decorator;
  private final PrinterService printerService;

  public Facade(Decorator decorator, PrinterService printerService) {
    this.decorator = decorator;
    this.printerService = printerService;
  }

  public void process(String object) {
    printerService.print(decorator.decorate(object));  
   }

}</pre></div><p class="calibre9">Generally, <code class="literal">PrintService</code> is stubbed with an <code class="literal">anyString()</code>generic matcher, and the <code class="literal">PrintService</code> call is<a id="id762" class="calibre1"/> verified using <code class="literal">verify(mockService).print(anyString());</code>, as follows:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class FacadeTest {

  @Mock PrinterService mockService;
  Facade facade;
  
  @Before
  public void setUp() throws Exception {
    facade = new Facade(new StringDecorator(), mockService);
  }

  @Test
  public void test() {
    String input = "hello";
    doNothing().when(mockService).print(anyString());
    facade.process(input);
    <span class="strong"><strong class="calibre10">verify(mockService).print(anyString());</strong></span>
  }

}</pre></div><p class="calibre9">We can use <code class="literal">eq("hello!")</code> instead of <code class="literal">anyString()</code>, as we know the <code class="literal">StringDecorator</code> method appends an exclamation to the <code class="literal">String</code> input; the test will fail if the <code class="literal">StringDecorator</code> method doesn't append the<a id="id763" class="calibre1"/> exclamation symbol. So, the side effects of <code class="literal">StringDecorator</code> can be identified immediately.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Keeping away from @ignore"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch10lvl2sec60" class="calibre1"/>Keeping away from @ignore</h2></div></div></div><p class="calibre9">Do not skip unit tests using the <code class="literal">@ignore</code> or <code class="literal">@exclude</code> annotations. As we know dead code removal is a refactoring technique, dead codes are never used. However, they create confusion. Similarly, when we ignore tests<a id="id764" class="calibre1"/> using the <code class="literal">@ignore</code> annotations, the tests are skipped, but the code<a id="id765" class="calibre1"/> remains in the file as dead code and creates confusion. Unit tests that are skipped provide no benefit. Instead of skipping unit tests, remove them from source control. If you need the test, you can get it from the source control history. Sometimes<a id="id766" class="calibre1"/> people create tests to easily understand some sort of APIs, but they don't want the tests to be executed when the test suite runs, or it may not be possible to run some tests on all platforms. With Maven (and Gradle), you can have different profiles with different test suites. For utility tests, it's always helpful to create a specific module for this.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Best Practices">
<div class="book" title="Writing meaningful tests">
<div class="book" title="Eluding debug messages"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_10"><a id="ch10lvl2sec61" class="calibre1"/>Eluding debug messages</h2></div></div></div><p class="calibre9">In early days, we used print (<code class="literal">System.out</code> or <code class="literal">System.err</code>) messages to console for debugging or unit testing code. Unit tests are system documentation, and a print statement does not fit in there. If you<a id="id767" class="calibre1"/> need to print something, just write a test and assert the expected value. Also, you can add a logging utility such as Log4J and log the debug messages. If a problem occurs in production, you just turn on these logs and see what's going on there to be able to reproduce the issue with tests better. So, tests and logs should rather complement each other.</p></div></div></div>
<div class="book" title="Automating JUnit tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec53" class="calibre1"/>Automating JUnit tests</h1></div></div></div><p class="calibre9">
<a class="calibre1" title="Chapter 2. Automating JUnit Tests" href="part0018_split_000.html#page">Chapter 2</a>, <span class="strong"><em class="calibre11">Automating JUnit Tests</em></span>, covered the importance of test automation, CI, and test automation with Gradle, Maven, and Ant. This section reiterates the benefits of test automation.</p><p class="calibre9">The following are the benefits of test automation:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Assumptions are continually verified. We refactor the code (change the internal structure of the <a id="id768" class="calibre1"/>code without affecting the output of the system) to improve code quality such as maintainability, readability, or extensibility. We can refactor the code with confidence if automated unit tests are running and providing feedback.</li><li class="listitem">Side effects are detected immediately. This is useful for fragile, tightly coupled systems when a change in one module breaks another module.</li><li class="listitem">Test automation saves time and there is no need of immediate regression testing. Suppose you are adding a scientific computation behavior to an existing calculator program and modifying the code. After every piece of change, you perform regression testing to verify the integrity of the system. Regression testing is tedious and time consuming, but if you have an automated unit test suite, then you can delay the regression testing until the functionality is done. This is because the automated suite will inform you at every stage if you disrupt an existing feature.</li></ul></div><p class="calibre9">Always integrate your JUnits with build script and configure CI.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Configuring tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec54" class="calibre1"/>Configuring tests</h1></div></div></div><p class="calibre9">This section deals with the test configuration. Unit tests are not testing the system. In TDD, unit tests are written to<a id="id769" class="calibre1"/> obtain the following benefits:</p><div class="book"><ul class="itemizedlist"><li class="listitem">They drive your design. You write a test, add code to fix the test, refactor code with confidence, and apply the design. This results in a simple, clean, maintainable, loosely coupled, and cohesive design. You write code to satisfy a failing test, so it limits the code you write to only what is needed.</li><li class="listitem">The tests provide fast, automated regression for refactoring and enhancing the code.</li></ul></div><p class="calibre9">You should configure your tests to follow the following principles:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unit tests should be<a id="id770" class="calibre1"/> executed extremely fast so that they can provide quick feedback. Would you withdraw money from an ATM that takes 10 minutes to dispense money?</li><li class="listitem">Tests should be reliable. Tests should fail if the production code is broken. Your tests will be considered unreliable in situations where you break the production logic but the tests pass, or you don't touch the production code but still your tests fail.</li></ul></div><p class="calibre9">The following section covers the test configuration.</p></div>

<div class="book" title="Configuring tests">
<div class="book" title="Running in-memory tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec62" class="calibre1"/>Running in-memory tests</h2></div></div></div><p class="calibre9">Do not write unit tests that make HTTP requests, look up JNDI resources, access a database, call SOAP-based web services, or read from the filesystem. These actions are slow and unreliable, so they<a id="id771" class="calibre1"/> should not be considered as unit tests; rather, they are integration tests. You can mock out such external dependencies using Mockito. <a class="calibre1" title="Chapter 4. Progressive Mockito" href="part0027_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre11">Progressive Mockito</em></span>, explains the mocking external dependencies.</p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Staying away from Thread.sleep"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec63" class="calibre1"/>Staying away from Thread.sleep</h2></div></div></div><p class="calibre9">
<code class="literal">Thread.sleep</code> is used in the production code to halt the current execution for some time so that the current execution can sync up with the system, such that the current thread waits for a resource used by another thread. Why do we need <code class="literal">Thread.sleep</code> in a unit test? Unit tests are meant to get executed faster.</p><p class="calibre9">
<code class="literal">Thread.sleep</code> can be <a id="id772" class="calibre1"/>used to wait for a long running process (this is usually used to test concurrency), but what if the process takes time in a slow machine? The test will fail though the code is not broken, and this defeats the test reliability principle. Avoid using <code class="literal">Thread.sleep</code> in unit tests; rather, simulate the long running process using a mock object.</p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Keeping unit tests away from the production code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec64" class="calibre1"/>Keeping unit tests away from the production code</h2></div></div></div><p class="calibre9">Don't deliver unit tests to customers; they are not going to execute the tests. The test code should be separated<a id="id773" class="calibre1"/> from the production code. Keep them in their respective source directory tree with the same package naming structure. This will keep them separate during a build.</p><p class="calibre9">The following Eclipse screenshot shows the separate source folder structure. Source files are located under the <code class="literal">src</code> folder, and the tests are placed under the <code class="literal">test</code> source folder. Note that the <code class="literal">Adder.java</code> and <code class="literal">AdderTest.java</code> files are placed in the same package named <code class="literal">com.packt.bestpractices.invalidinput</code>:</p><div class="mediaobject"><img src="../images/00131.jpeg" alt="Keeping unit tests away from the production code" class="calibre12"/></div><p class="calibre13"> </p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Avoiding static variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec65" class="calibre1"/>Avoiding static variables</h2></div></div></div><p class="calibre9">Static variables hold state. When you use a static variable in your test, it signifies that you want to save<a id="id774" class="calibre1"/> the state of something. So, you are creating inter-test dependency. If the execution order changes, the test will fail though the code is not broken, and this defeats the test reliability principle. Do not use static variables in unit tests to store global state.</p><p class="calibre9">Don't initialize the class to be tested as static and use the <code class="literal">setUp</code> method (annotated with <code class="literal">@Before</code>) to initialize objects. These will protect you from accidental modification problems. The following example demonstrates the accidental modification side effects.</p><p class="calibre9">The <code class="literal">Employee</code> class stores employee names:</p><div class="informalexample"><pre class="programlisting">public class Employee {
  private String lastName;
  private String name;

  public Employee(String lastName , String name) {
    this.lastName = lastName;
    this.name = name;
  }

  public String getLastName() {
    return lastName;
  }


  public String getName() {
    return name;
  }

}</pre></div><p class="calibre9">The <code class="literal">HRService</code> class has a <code class="literal">generateUniqueIdFor(Employee emp)</code> method. It returns a unique employee ID based on the surname. Two employees with the surname Smith will have the IDs <code class="literal">smith01</code> and <code class="literal">smith02</code>, respectively. Consider the following code:</p><div class="informalexample"><pre class="programlisting">public class HRService {

  private Hashtable&lt;String, Integer&gt; employeeCountMap = new Hashtable&lt;String, Integer&gt;();

  public String generateUniqueIdFor(Employee emp) {
    Integer count = employeeCountMap.get(emp.getLastName());
    if (count == null) {
      count = 1;
    } else {
      count++;
    }
    employeeCountMap.put(emp.getLastName(), count);
    return emp.getLastName()+(count &lt; 9 ? "0"+count:""+count);
  }
}</pre></div><p class="calibre9">The unit test class<a id="id775" class="calibre1"/> initializes the service as static. The service stores the input of the first test and fails the second test, as follows:</p><div class="informalexample"><pre class="programlisting">public class HRServiceTest {
  String familyName = "Smith";
  static HRService service = new HRService();

  @Test
  public void when_one_employee_RETURNS_familyName01() throws Exception {
    Employee johnSmith = new Employee(familyName, "John");
    String id = service.generateUniqueIdFor(johnSmith);
    assertEquals(familyName + "01", id);
  }

  //This test will fail, to fix this problem remove the static modifier
  @Test
  public void when_many_employees_RETURNS_familyName_and_count() {
    Employee johnSmith = new Employee(familyName, "John");
    Employee bobSmith = new Employee(familyName, "Bob");

    String id = service.generateUniqueIdFor(johnSmith);
    id = service.generateUniqueIdFor(bobSmith);
    assertEquals(familyName + "02", id);
  }

}</pre></div><p class="calibre9">The following JUnit output shows the error details:</p><div class="mediaobject"><img src="../images/00132.jpeg" alt="Avoiding static variables" class="calibre12"/></div><p class="calibre13"> </p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Assuming the test execution order"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch10lvl2sec66" class="calibre1"/>Assuming the test execution order</h2></div></div></div><p class="calibre9">JUnit was designed to execute the tests in random order. It depends on the Java reflection API to execute the tests. So, the execution<a id="id776" class="calibre1"/> of one test should not depend on another. Suppose you are testing the database integration of <code class="literal">EmployeeService</code>, where the <code class="literal">createEmployee()</code> test creates a new <code class="literal">Employee</code>, <code class="literal">updateEmployee()</code> method and updates the new employee created in <code class="literal">createEmployee()</code>, and <code class="literal">deleteEmployee()</code> deletes the employee. So, we are dependent on the test execution order; if <code class="literal">deleteEmployee()</code> or <code class="literal">updateEmployee()</code> is executed before <code class="literal">createEmployee()</code>, the test will fail as the employee is not created yet.</p><p class="calibre9">To fix this problem, just merge the tests into a single test named <code class="literal">verifyEmployeePersistence()</code>.</p><p class="calibre9">So, don't believe in the test execution order; if you have to change one test case, then you need to make changes in multiple test cases unnecessarily.</p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Loading data from files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch10lvl2sec67" class="calibre1"/>Loading data from files</h2></div></div></div><p class="calibre9">The JUnit <code class="literal">Theory</code> framework offers an <code class="literal">abstract</code> class <code class="literal">ParameterSupplier</code> for supplying test data for test cases. The <code class="literal">ParameterSupplier</code> implementation can read from a filesystem, such as a CSV or an Excel file. However, it is not recommended that you read from the filesystem. This is because reading a file is an I/O (input/output) process, and it is <a id="id777" class="calibre1"/>unpredictable and slow. We don't want our tests to create a delay. Also, reading from a hardcoded file path may fail in different machines. Instead of reading from a file, create a test data supplier class and return the hardcoded data.</p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Invoking super.setUp() and super.tearDown()"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch10lvl2sec68" class="calibre1"/>Invoking super.setUp() and super.tearDown()</h2></div></div></div><p class="calibre9">Sometimes the data setup for unit testing is monotonous and ugly. Often, we create a base test class, set up the data, and <a id="id778" class="calibre1"/>create subclasses to use the data. From subclasses, always invoke the setup of the super classes and teardown methods. The following<a id="id779" class="calibre1"/> example shows the fault of not invoking the super class.</p><p class="calibre9">We have <code class="literal">EmployeeService</code> and <code class="literal">EmployeeServiceImpl</code> to perform some business logic:</p><div class="informalexample"><pre class="programlisting">public interface EmployeeService {
  public void doSomething(Employee emp);
}</pre></div><p class="calibre9">The <code class="literal">BaseEmployeeTest</code> class is an <code class="literal">abstract</code> class, and it sets up the data for subclasses, as follows:</p><div class="informalexample"><pre class="programlisting">public abstract class BaseEmployeeTest {

  protected HashMap&lt;String, Employee&gt; employee ;
  
  @Before
  public void setUp() {
    employee = new HashMap&lt;String, Employee&gt;();
    employee.put("1", new Employee("English", "Will"));
    employee.put("2", new Employee("Cushing", "Robert"));
  }
}</pre></div><p class="calibre9">The <code class="literal">EmployeeServiceTest</code> class extends the <code class="literal">BaseEmployeeTest</code> class and uses the <code class="literal">employee</code> map, as follows:</p><div class="informalexample"><pre class="programlisting">public class EmployeeServiceTest extends BaseEmployeeTest {
     
  EmployeeService service;
  @Before
  public void setUp() {
    service = new EmployeeServiceImpl();
  }
  @Test
  public void someTest() throws Exception {
    for(Employee emp:employee.values()) {
      service.doSomething(emp);
    }
  }
}</pre></div><p class="calibre9">The test execution fails with a <code class="literal">NullPointerException</code>. The following is the JUnit output:</p><div class="mediaobject"><img src="../images/00133.jpeg" alt="Invoking super.setUp() and super.tearDown()" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">To fix this, call <code class="literal">super.setUp()</code> from<a id="id780" class="calibre1"/> the <code class="literal">setUp()</code> method. The following<a id="id781" class="calibre1"/> is the modified <code class="literal">setUp()</code> method in <code class="literal">EmployeeServiceTest</code>:</p><div class="informalexample"><pre class="programlisting">  @Before
  public void setUp() {
    <span class="strong"><strong class="calibre10">super.setUp();</strong></span>
    service = new EmployeeServiceImpl();
  }</pre></div></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Staying away from side effects"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch10lvl2sec69" class="calibre1"/>Staying away from side effects</h2></div></div></div><p class="calibre9">Do not write test cases that affect the data of other test cases, for example, you are examining the JDBC API call using an in-memory <code class="literal">HashMap</code> and a test case clears the map, or you are<a id="id782" class="calibre1"/> testing the database integration and a test case deletes the data from the database. It may affect the other test cases or external systems. When a test case removes data from a database, any application using the data can fail. It's important to roll back the changes in the final block and not just at the end of the test.</p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Working with locales"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch10lvl2sec70" class="calibre1"/>Working with locales</h2></div></div></div><p class="calibre9">Be aware<a id="id783" class="calibre1"/> of internationalization while working with <code class="literal">NumberFormat</code>, <code class="literal">DateFormat</code>, <code class="literal">DecimalFormat</code>, and <code class="literal">TimeZones</code>. Unit tests can fail if they are run on a machine with a different locale.</p><p class="calibre9">The following example demonstrates the internationalization context.</p><p class="calibre9">Suppose you have a class that formats money. When you pass 100.99, it rounds up the amount to 101.00. The following formatter class uses <code class="literal">NumberFormat</code> to add a currency symbol and format the amount:</p><div class="informalexample"><pre class="programlisting">class CurrencyFormatter{
  
  public static String format(double amount) {
    NumberFormat format =<span class="strong"><strong class="calibre10">NumberFormat.getCurrencyInstance();</strong></span>
    return format.format(amount);
  }
}</pre></div><p class="calibre9">The following JUnit test verifies the formatting:</p><div class="informalexample"><pre class="programlisting">public class LocaleTest {
  
  @Test
  public void currencyRoundsOff() throws Exception {
    assertEquals("$101.00", CurrencyFormatter.format(100.999));
  }
}</pre></div><p class="calibre9">If you run this test in a different locale, the test will fail. We can simulate this by changing the locale and restoring back to the default locale, as follows:</p><div class="informalexample"><pre class="programlisting">public class LocaleTest {
  private Locale defaultLocale;
  @Before
  public void setUp() {
    defaultLocale = <span class="strong"><strong class="calibre10">Locale.getDefault()</strong></span>;
    <span class="strong"><strong class="calibre10">Locale.setDefault(Locale.GERMANY);</strong></span>
  }
  @After
  public void restore() {
    Locale.setDefault(defaultLocale);
  }
  @Test
  public void currencyRoundsOff() throws Exception {
    assertEquals("$101.00", CurrencyFormatter.format(100.999));
  }
}</pre></div><p class="calibre9">Before test execution, the default locale value is stored to <code class="literal">defaultLocale</code>, the default locale is changed to <code class="literal">GERMANY</code>, and after test execution, the default locale is restored. The following is the JUnit execution failure output. In <code class="literal">GERMANY</code>, the currency will be formatted to <span class="strong"><strong class="calibre10">101,00 €</strong></span> but our test expects <span class="strong"><strong class="calibre10">$101.00</strong></span>:</p><div class="mediaobject"><img src="../images/00134.jpeg" alt="Working with locales" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">You can change <a id="id784" class="calibre1"/>your code to always return the USD format, or you can change your test to run in the US locale by changing the default locale to US, and after test execution, restore it back to the default one. Similarly, be careful while working with date and decimal formatters.</p></div></div>

<div class="book" title="Configuring tests">
<div class="book" title="Working with dates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_10"><a id="ch10lvl2sec71" class="calibre1"/>Working with dates</h2></div></div></div><p class="calibre9">If not used carefully, dates may act bizarrely in tests. Be careful when using hardcoded dates in unit tests. You are<a id="id785" class="calibre1"/> working with dates and checking business logic with a future date. On January 1, 2014, you set a future date as April 10, 2014. The test works fine till April 9 and starts failing thereafter.</p><p class="calibre9">Do not use hardcoded dates. Instead use <code class="literal">Calendar</code> to get the current date and time and add <code class="literal">MONTH</code>, <code class="literal">DATE</code>, <code class="literal">YEAR</code>, <code class="literal">HOUR</code>, <code class="literal">MINUTE</code>, or <code class="literal">SECOND</code> to it to get a future date time. The following self explanatory code snippet demonstrates how to create a dynamic future date:</p><div class="informalexample"><pre class="programlisting">Calendar cal = Calendar.getInstance ();
Date now = cal.getTime();

//Next month
cal.add(Calendar.MONTH,1);
Date futureMonth = cal.getTime();


//Adding two days
cal.add(Calendar.DATE,2);
Date futureDate = cal.getTime();

//Adding a year
cal.add(Calendar.YEAR,1);
Date futureYear = cal.getTime();

//Adding 6 hours
cal.add(Calendar.HOUR,6);
Date futureHour = cal.getTime();

//Adding 10 minutes
cal.add(Calendar.MINUTE,10);
Date futureMinutes = cal.getTime();

//Adding 19 minutes
cal.add(Calendar.SECOND,19);
Date futureSec = cal.getTime();</pre></div><p class="calibre9">The following<a id="id786" class="calibre1"/> are the future dates when the program was run on April 16, 2014:</p><div class="mediaobject"><img src="../images/00135.jpeg" alt="Working with dates" class="calibre12"/></div><p class="calibre13"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with assertions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec55" class="calibre1"/>Working with assertions</h1></div></div></div><p class="calibre9">An assertion is a predicate<a id="id787" class="calibre1"/> used to verify a programmer assumption (expectation) with an actual outcome of a program implementation. For example, a programmer can expect that the addition of two positive numbers will result in a positive number. So, the programmer can write a program to add two numbers and assert the expected result with the actual result.</p><p class="calibre9">The <code class="literal">org.junit.Assert</code> package provides static overloaded methods for asserting expected and actual values for all primitive types, objects, and arrays.</p><p class="calibre9">This section covers the proper usage of the <code class="literal">Assertion</code> APIs. The following<a id="id788" class="calibre1"/> are the best practices.</p></div>

<div class="book" title="Working with assertions">
<div class="book" title="Using the correct assertion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec72" class="calibre1"/>Using the correct assertion</h2></div></div></div><p class="calibre9">Use the correct assertion method. JUnit supports many assertion options, such as <code class="literal">assertEquals</code>, <code class="literal">assertTrue</code>, <code class="literal">assertFalse</code>, <code class="literal">assertNull</code>, <code class="literal">assertNotNull</code>, <code class="literal">assertSame</code>, and <code class="literal">assertThat</code>. Use<a id="id789" class="calibre1"/> the most appropriate one. The following are the examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Use <code class="literal">assertTrue(yourClass.someMethod())</code> instead of using <code class="literal">assertEquals(true, yourClass.someMethod())</code></li><li class="listitem">Use <code class="literal">assertFalse(yourClass.someMethod())</code> instead of calling <code class="literal">assertTrue(!yourClass.someMethod())</code></li><li class="listitem">Use <code class="literal">assertNull(yourClass.someMethod())</code> rather than <code class="literal">assertEquals(null, yourClass.someMethod())</code></li><li class="listitem">Use <code class="literal">assertEquals(expected, yourClass.someMethod())</code> instead of using <code class="literal">assertTrue(expected.equals(yourClass.someMethod()))</code></li><li class="listitem">The <code class="literal">assertThat(age, is(30))</code> method is more readable than <code class="literal">assertEquals(30, age)</code></li><li class="listitem">Similarly, <code class="literal">assertThat(age, is(not(33)))</code> is more readable than <code class="literal">assertTrue(age != 33)</code></li></ul></div></div></div>

<div class="book" title="Working with assertions">
<div class="book" title="Maintaining the assertEquals parameter order"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec73" class="calibre1"/>Maintaining the assertEquals parameter order</h2></div></div></div><p class="calibre9">The <a id="id790" class="calibre1"/>
<code class="literal">assertEquals</code> method is a very useful method to verify the expectation. The <code class="literal">assertEquals</code> method<a id="id791" class="calibre1"/> has the  <code class="literal">assertEquals(Object expected, Object actual)</code> signature.</p><p class="calibre9">Maintain the parameter order: first the expected <a id="id792" class="calibre1"/>value and then the actual result. The following JUnit snippet reverses the order, passes the actual value first, and then the expected result:</p><div class="informalexample"><pre class="programlisting">@Test
public void currencyRoundsOff() throws Exception {
  assertEquals(CurrencyFormatter.format(100.999), "$101.00");
}</pre></div><p class="calibre9">When the test fails, the error message says that the expected value is <span class="strong"><strong class="calibre10">101,00 €</strong></span> but actually the expected value is <span class="strong"><strong class="calibre10">$101.00</strong></span>.</p><p class="calibre9">So, <code class="literal">assertEquals</code> shows misleading error messages when the parameter order changes.</p><p class="calibre9">The following screenshot shows the error message. It says the test expects euros (€) but receives dollars ($):</p><div class="mediaobject"><img src="../images/00136.jpeg" alt="Maintaining the assertEquals parameter order" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">Optionally, you can pass a meaningful message to <code class="literal">assertEquals</code> to describe the cause. The <code class="literal">assertEquals(String message, Object expected, Object actual)</code> signature takes a <code class="literal">String</code> message to display a meaningful error message when the actual value doesn't match the expected value.</p><p class="calibre9">The<a id="id793" class="calibre1"/> following JUnit snippet<a id="id794" class="calibre1"/> passes a meaningful error message:</p><div class="informalexample"><pre class="programlisting">@Test
public void currencyRoundsOff() throws Exception {
  assertEquals("Currency formatting failed", $101.00", CurrencyFormatter.format(100.999));
}</pre></div><p class="calibre9">The following is the <code class="literal">Assertion</code> failure output with an informative message:</p><div class="mediaobject"><img src="../images/00137.jpeg" alt="Maintaining the assertEquals parameter order" class="calibre12"/></div><p class="calibre13"> </p></div></div>

<div class="book" title="Working with assertions">
<div class="book" title="Striving for one assertion per test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec74" class="calibre1"/>Striving for one assertion per test</h2></div></div></div><p class="calibre9">Strive for one assertion per test method. When you check one assertion per test and a unit test fails, it is much easier to determine what went wrong. When a unit test has more than one assertion, and one <a id="id795" class="calibre1"/>assertion fails, extra effort is required to determine which one failed; for one assertion per test, no extra effort is required.</p><p class="calibre9">When a unit test performs more than one assertion, and a runtime exception is thrown, the assertions after the exception do not get verified; the JUnit framework marks the unit test as erroneous and proceeds to the next test method.</p><p class="calibre9">The following JUnit test asserts three conditions—the formatted amount is not null, the formatted amount contains a $ symbol, and the exact formatting:</p><div class="informalexample"><pre class="programlisting">@Test
public void currencyRoundsOff() throws Exception {
  assertNotNull(CurrencyFormatter.format(100.999));
  assertTrue(CurrencyFormatter.format(100.999).contains("$"));
  assertEquals("$101.00", CurrencyFormatter.format(100.999));
}</pre></div><p class="calibre9">When any assertion<a id="id796" class="calibre1"/> fails, the output doesn't tell you what is wrong (you get the line number in the<a id="id797" class="calibre1"/> source code file, though, it is not very convenient to work with). The following is the JUnit output:</p><div class="mediaobject"><img src="../images/00138.jpeg" alt="Striving for one assertion per test" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">Instead of using three assertions, you can create three tests, or you can pass meaningful error messages to the assertion methods. The following JUnit test is modified to pass error messages:</p><div class="informalexample"><pre class="programlisting">@Test
public void currencyRoundsOff() throws Exception {
  assertNotNull("Currency is NULL", CurrencyFormatter.format(100.999));
  assertTrue("Currency is not USD($)", CurrencyFormatter.format(100.999).contains("$"));
  assertEquals("Wrong formatting", "$101.00", CurrencyFormatter.format(100.999));
}</pre></div><p class="calibre9">Now, the failing test gives you additional information about the failure. The following is the test output. It reads <span class="strong"><strong class="calibre10">Currency is not USD($)</strong></span>, which means the second assertion failed:</p><div class="mediaobject"><img src="../images/00139.jpeg" alt="Striving for one assertion per test" class="calibre12"/></div><p class="calibre13"> </p></div></div>
<div class="book" title="Handling exceptions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec56" class="calibre1"/>Handling exceptions</h1></div></div></div><p class="calibre9">Exception handling is an important part of Java coding. The Java community follows a set of best practices about exception handling. The following <a id="id798" class="calibre1"/>are the exception<a id="id799" class="calibre1"/> handling best practices for unit testing:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Do not write catch blocks to pass a unit test. Consider the following example where a <code class="literal">Calculator</code> program has a <code class="literal">divide</code> method. It takes two integers, divides, and returns a result. When <code class="literal">divide</code> encounters a divide by zero, the program should throw an exception. The following is the code:<div class="informalexample"><pre class="programlisting">public class Calculator {

  public int divide(int op1, int op2)  {
    return op1/op2;
  }
}</pre></div><p class="calibre15">The following is the test:</p><div class="informalexample"><pre class="programlisting">@Test
public void divideByZero_throws_exception() throws Exception {
  try {
    calc.divide(1, 0);
    fail("Should not reach here");
  } catch (ArithmeticException e) {

  }
}</pre></div><p class="calibre15">Instead of catching <code class="literal">ArithmeticException</code>, we can apply the JUnit 4 pattern as follows:</p><div class="informalexample"><pre class="programlisting">  @Test(expected = ArithmeticException.class)
  public void divideByZero_throws_exception() throws Exception {
    calc.divide(1, 0);
  }</pre></div><p class="calibre15">A more elegant way is  to check the <code class="literal">ExpectedException</code> rule. The following is the modified test with <code class="literal">ExpectedException</code>:</p><div class="informalexample"><pre class="programlisting">public class CalculatorTest {

  @Rule
  public <span class="strong"><strong class="calibre10">ExpectedException expectedException= ExpectedException.none();</strong></span>

  Calculator calc = new Calculator();

  @Test
  public void divideByZero_throws_exception(){
    <span class="strong"><strong class="calibre10">expectedException.expect(ArithmeticException.class);</strong></span>
    <span class="strong"><strong class="calibre10">expectedException.expectMessage("/ by zero");</strong></span>
    calc.divide(1, 0);
  }
}</pre></div><p class="calibre15">
<code class="literal">ExpectedException</code> expects an exception and an error message. If the exception is not thrown, or the message doesn't match, the test fails.</p></li><li class="listitem">Do not write catch blocks to<a id="id800" class="calibre1"/> fail a test; the JUnit framework takes care of runtime exceptions. The following is an example of <a id="id801" class="calibre1"/>an unnecessary catch block:<div class="informalexample"><pre class="programlisting">  @Test
  public void fails_when_an_exception_is_thrown()  {
    try {
      calc.divide(1, 0);
    }<span class="strong"><strong class="calibre10">catch(Exception ex) {</strong></span>
      <span class="strong"><strong class="calibre10">fail("Should not throw an exception");</strong></span>
    }
  }</pre></div><p class="calibre15">Instead, just write the following lines. The test will fail automatically if any exception is thrown:</p><div class="informalexample"><pre class="programlisting">  @Test
  public void fails_when_an_exception_is_thrown()  {
    calc.divide(1, 0);
  }</pre></div></li><li class="listitem">Do not catch an exception and assert the failure to pass a test. The following test code catches <code class="literal">ArithmeticException</code> and sets a Boolean flag, and finally asserts the flag. If no exception is<a id="id802" class="calibre1"/> thrown, the flag<a id="id803" class="calibre1"/> remains false and the test fails:<div class="informalexample"><pre class="programlisting">  @Test
  public void fails_when_an_exception_is_thrown()  {
    boolean isFailed = false;
    try {
      calc.divide(1, 0);
    }catch(Exception ex) {
      isFailed = true;
    }
   
    assertTrue(isFailed);
  }</pre></div><p class="calibre15">Use the JUnit 4 patterns explained in the preceding example.</p></li><li class="listitem">Do not add catch blocks to test a method that throws<a id="id804" class="calibre1"/> <span class="strong"><strong class="calibre10">checked</strong></span> exceptions. The following example explains the problem. The <code class="literal">sum(int… arg)</code> method throws a <code class="literal">NumberOverflowException</code> checked exception when the integer overflows:<div class="informalexample"><pre class="programlisting">public int sum(int... args) throws NumberOverflowException{
  int sum = 0;
  for(int val:args) {
    if(Integer.MAX_VALUE - sum &lt; val) {
      throw new NumberOverflowException("Number overflow");
    }
    sum+=val;
  }
    
  return sum;
    
}</pre></div><p class="calibre15">A catch block is used to catch a checked exception and compile the test, as follows:</p><div class="informalexample"><pre class="programlisting">  @Test
  public void fails_when_an_exception_is_thrown()  {
    try {
      int sum = calc.sum(1,2,3);
      assertEquals(6, sum);
    } catch (NumberOverflowException e) {
      
    }
  }</pre></div><p class="calibre15">Do not follow this pattern; instead, use <code class="literal">throws Exception</code>. The following JUnit test uses the <code class="literal">throws Exception</code> clause:</p><div class="informalexample"><pre class="programlisting">  @Test
  public void fails_when_an_exception_is_thrown() <span class="strong"><strong class="calibre10">throws </strong></span>
<span class="strong"><strong class="calibre10">Exception</strong></span> {
    int sum = calc.sum(1,2,3);
    assertEquals(6, sum);
  }</pre></div></li><li class="listitem">Do not throw specific <code class="literal">Exceptions</code> from <a id="id805" class="calibre1"/>your tests. Instead, use<a id="id806" class="calibre1"/> the generic <code class="literal">throws Exception</code>.<p class="calibre15">The following example throws a specific <code class="literal">NumberOverflowException</code> exception:</p><div class="informalexample"><pre class="programlisting">public void fails_when_an_exception_is_thrown() <span class="strong"><strong class="calibre10">throws NumberOverflowException</strong></span>{
  
}</pre></div><p class="calibre15">Suppose the code is changed such that it could throw either <code class="literal">NumberOverflowException</code> or a <code class="literal">ParseException</code>. In that case, we have to change the test method to throw both the exceptions to compile the test. If we use the generic <code class="literal">throws Exception</code> clause, then this problem won't arise.</p></li></ul></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with test smells"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec57" class="calibre1"/>Working with test smells</h1></div></div></div><p class="calibre9">Code smell is a technical debt<a id="id807" class="calibre1"/> or symptom that indicates a deeper problem. Smells are not bugs, or they don't fail tests. Instead, they indicate a problem in design or code such that a rigid code cannot be enhanced or can create a maintenance issue. This section covers the test smells that should be refactored for maintenance and readability. The following topics are covered:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Test code duplication</li><li class="listitem">Conditions in test code</li><li class="listitem">Test logic in the production code</li><li class="listitem">Over engineering</li></ul></div></div>

<div class="book" title="Working with test smells">
<div class="book" title="Refactoring duplicates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec75" class="calibre1"/>Refactoring duplicates</h2></div></div></div><p class="calibre9">Code duplication is the simplest code smell. It creates maintainability problems. The same code is written in many places; if any bug is found, then you need to modify all other places. This subsection elaborates on the duplicate code in test cases.</p><p class="calibre9">Suppose you are designing a <a id="id808" class="calibre1"/>hospital management system and writing a test for checking a patient in. The following objects are needed for the patient check-in process: a person, a guarantor, reason for hospitalization, the attending physician, and the check-in date. A person should have an address. A guarantor can be a person or an organization, such as a jail authority, a government authority, or a corporate sponsor. A guarantor should have an address.</p><p class="calibre9">The following test snippet creates two <code class="literal">Person</code> objects for check in, a patient <code class="literal">johnPeterson</code>, and his guarantor <code class="literal">johnsDad</code>:</p><div class="informalexample"><pre class="programlisting">Person johnsDad = new Person();
   Address newYorkBayArea = new Address();
   newYorkBayArea.setAddressType(AddressType.Residential);
   newYorkBayArea.setCountry("US");
   newYorkBayArea.setState("NY");
   newYorkBayArea.setZip("49355");
   newYorkBayArea.setStreet("12/e xyz Avenue");
   johnsDad.addAddress(newYorkBayArea);
   johnsDad.setEmail("dontDisturb@my.org");
   johnsDad.setFirstName("Freddy");
   johnsDad.setLastName("Peterson");
   daddy.setPerson(johnsDad);
    
   Person johnPeterson = new Person();
   Address mavernPhilly = new Address();
   mavernPhilly.setAddressType(AddressType.Residential);
   mavernPhilly.setCountry("US");
   mavernPhilly.setState("PA");
   mavernPhilly.setZip("19355");
   mavernPhilly.setStreet("123 Frazer");
   johnPeterson.addAddress(mavernPhilly);
   johnPeterson.setEmail("johnYou12345@gmail.com");
   johnPeterson.setFirstName("John");
   johnPeterson.setLastName("Peterson");</pre></div><p class="calibre9">Two <code class="literal">Person</code> objects and two <code class="literal">Address</code> objects are created and initialized. They are logically duplicate statements. Many other tests can write similar duplicate statements. Extract the method to<a id="id809" class="calibre1"/> refactor the duplicate smell. Extract the builder methods for the <code class="literal">Person</code> and <code class="literal">Address</code> objects as follows:</p><div class="informalexample"><pre class="programlisting">protected Person newPerson(Address newYorkBayArea, StringlastName, String email, String firstName) {
  Person person = new Person();
  person.addAddress(newYorkBayArea);
  person.setEmail(email);
  person.setFirstName(firstName);
  person.setLastName(lastName);
  return person;
}

protected Address newAddress(String street, String country, String state, String zip, AddressType residential) {
  Address address = new Address();
  address.setAddressType(residential);
  address.setCountry(country);
  address.setState(state);
  address.setZip(zip);
  address.setStreet(street);
  return address;
}</pre></div><p class="calibre9">From the test code, just pass the required values and call the build methods as follows:</p><div class="informalexample"><pre class="programlisting">Address newYorkBayArea = newAddress("12/e xyz Avenue", "US", "NY","49355", AddressType.Residential);

Person johnsDad = newPerson(newYorkBayArea, "Peterson","dontDisturb@my.org", "Freddy");
    
Address mavernPhilly = newAddress("123 Frazer", "US", "PA", "19355", AddressType.Residential);
    
Person johnPeterson = newPerson(mavernPhilly, "Peterson", "johnYou12345@gmail.com", "John");</pre></div><p class="calibre9">We can refactor the duplicate code in many test classes by moving the common code to a base test class or a helper class.</p></div></div>

<div class="book" title="Working with test smells">
<div class="book" title="Refactoring the test control logic"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec76" class="calibre1"/>Refactoring the test control logic</h2></div></div></div><p class="calibre9">Unit test code <a id="id810" class="calibre1"/>verifies the behavior of the code under test, and usually, no conditional logic is written to verify the code. However, when a test contains code that is executed based on some condition, it gets complicated for the reader. The test executes fine but creates a maintainability problem.</p><p class="calibre9">When we post JMS messages to a destination (such as the TIBCO Enterprise Messaging Service), internally, the JMS provider posts administrative messages such as message received, message sent, and message acknowledged. However, each message contains the same JMS message ID. If we<a id="id811" class="calibre1"/> create a message logger program to listen to the JMS events (including administrative events), and log all events to a database for an audit trail, then the logger will save many messages with the same JMS<a id="id812" class="calibre1"/> message ID.</p><p class="calibre9">The following is an example of the test control logic. The message is defined as follows:</p><div class="informalexample"><pre class="programlisting">public class Message {
  private String jmsMessageID;
  private String header;
  private Object payload;
  private int eventType;
}</pre></div><p class="calibre9">The <code class="literal">eventType</code> variable indicates the administrative message type (received is 1, sent is 2, and acknowledged is 3).</p><p class="calibre9">The <code class="literal">MessagingService</code> interface is defined as follows:</p><div class="informalexample"><pre class="programlisting">public interface MessagingService {
  String publish(Object message);
  List&lt;Message&gt; retrieveByMessageId(String jmsMessageId);
}</pre></div><p class="calibre9">We'll verify the logging capability as follows:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class MessagingServiceTest {
  MessagingService service = new MessagingServiceImpl();
  
  @Test
  public void logs_messages() throws Exception {
    String msgId = service.publish(new String("hello world"));
    for(Message msg:service.retrieveByMessageId(msgId)) {
      <span class="strong"><strong class="calibre10">if(msg.getEventType() == 2) {</strong></span>
        <span class="strong"><strong class="calibre10">assertEquals("hello world", msg.getPayload());</strong></span>
        break;
      }
    }
  }
}</pre></div><p class="calibre9">The <code class="literal">Test</code> method loops<a id="id813" class="calibre1"/> through the messages, finds a message, and then verifies the payload. The test contains logic. Do we need another test for this test? This is confusing.</p><p class="calibre9">To refactor our test, you<a id="id814" class="calibre1"/> can move the logic to the code under test. The API should have a method to return a specific type of message. That way, we can check<a id="id815" class="calibre1"/> the message object directly instead of looping and checking.</p></div></div>

<div class="book" title="Working with test smells">
<div class="book" title="Removing the test logic from the production code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec77" class="calibre1"/>Removing the test logic from the production code</h2></div></div></div><p class="calibre9">Writing code for testability is a quality. Often, we put testing logic into the production code for unit testing, such as a new constructor or new method. To make the code testable, the tests require extra logic in production code to gain access to the code's internal state for testing configuration or<a id="id816" class="calibre1"/> result verification. Testing logic in production code is a smell, though it doesn't break the code under test but increases the complexity of the code, and this can create severe maintainability problems or system failure if anything gets misconfigured.</p><p class="calibre9">The testing logic is inserted into<a id="id817" class="calibre1"/> the production code under the following conditions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Adding conditional logic to return a hardcoded value during testing. The code under test acts as a dynamic stub as shown in the following example:<div class="informalexample"><pre class="programlisting">public final class EncounterManager {
  public boolean isHack = false;
  
  public boolean save(Map data) {
    if(isHack) {
      return true;
    }
    Encounter enc = new EncounterServiceImpl().checkIn(buildCheckinRqst(data));
    return enc != null;
  }
}</pre></div><p class="calibre15">
<code class="literal">EncounterManager</code> cannot be overridden as the class is declared as <code class="literal">final</code>; so, you cannot create a mock or fake object of this class. If your code under test needs to stub the <code class="literal">save()</code> behavior, then somehow you need to bypass the database call made in the <code class="literal">EncounterServiceImpl</code> method to persist the check-in data into a database. So, the <code class="literal">save()</code> method has an <code class="literal">isHack</code> conditional logic. This Boolean variable is added for testing purposes. From test, the Boolean variable <code class="literal">isHack</code> is set to <code class="literal">true</code>. If accidentally this variable is set to <code class="literal">true</code>, then encounters will not be created in production.</p></li><li class="listitem">Additional code is<a id="id818" class="calibre1"/> written only for test execution, or private variables are exposed as public. The following is an example:<div class="informalexample"><pre class="programlisting">public final class EncounterManager {
  private List&lt;Encounter&gt; retrieveEncounters() {
    if (encounters == null) {
      Patient patient = new Patient();
      patient.setPatientId(patientId);
      new EncounterServiceImpl().retreiveBy(patient);
    }
    return encounters;
  }
  
  public List&lt;Encounter&gt; encounters;
  public void setEncounters(List&lt;Encounter&gt; encounters) {
    this.encounters = encounters;
  }
}</pre></div><p class="calibre15">The <code class="literal">retrieveEncounters()</code> method<a id="id819" class="calibre1"/> is a private method used for lazy instantiation of <code class="literal">encounters List</code>. However, for testing purposes, <code class="literal">encounters List</code> is exposed as <code class="literal">public</code> and a <code class="literal">public</code> setter method is used. From test, either the setter method is called with a hardcoded <code class="literal">List</code> or directly the <code class="literal">encounters List</code> is set. If <code class="literal">encounters List</code> is accidentally set in production, users will see the wrong data in the UI.</p></li><li class="listitem">Mockito doesn't allow stubbing the <code class="literal">equals()</code> and <code class="literal">hashcode()</code> methods, as they should not be overridden unless the logic is comprehensible. Yet, often for testing, we override the <code class="literal">equals()</code> and <code class="literal">hashcode()</code> methods and perform testing<a id="id820" class="calibre1"/> logic or return the hardcoded value. This is very dangerous. In production, if we need to put the objects in a collection or need to perform an equality check, then the system behaves in a bizarre fashion. The following code snippet overrides the <code class="literal">hashcode()</code> and <code class="literal">equals()</code> methods:<div class="informalexample"><pre class="programlisting">@Override
public int hashCode() {
  return isHack ? HACKED_NUMBER : 0;
}

@Override
public boolean equals(Object obj) {
  if (obj instanceof EncounterManager) {
    return isHack &amp;&amp; ((EncounterManager) obj).isHack;
  }
  return false;
}</pre></div></li></ul></div><p class="calibre9">The <code class="literal">equals()</code> method returns <code class="literal">false</code> in the production code and <code class="literal">hashcode()</code> returns <code class="literal">0</code>. The <code class="literal">EncounterManager</code> class cannot be used in conjunction with the Java collection framework.</p><p class="calibre9">To refactor the production<a id="id821" class="calibre1"/> code, remove the<a id="id822" class="calibre1"/> final keyword, override the class in the test context, and return the hardcoded values. However, never ever touch the <code class="literal">equals()</code> and <code class="literal">hashcode()</code> methods for testing.</p></div></div>

<div class="book" title="Working with test smells">
<div class="book" title="Refactoring over engineered tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec78" class="calibre1"/>Refactoring over engineered tests</h2></div></div></div><p class="calibre9">Tests are system documentation. They should tell the reader what is being executed. Often, we put too much documentation and make it more complex for the reader to understand the intention. Sometimes, we refactor <a id="id823" class="calibre1"/>the test and extract clean, meaningful methods, pass variables to the extracted methods, and from test just invoke the methods. Now the reader fails to understand the utility of the test case, and everything is carried out elsewhere.</p><p class="calibre9">The following test example demonstrates <code class="literal">Test</code> with less or no information:</p><div class="informalexample"><pre class="programlisting">@Test
public void checks_in_patient() throws Exception {
  createCheckInRequestForAPatientWithAGuarantor();
  checkInaPatient();
  assertResult();
}</pre></div><p class="calibre9">The unit test calls three methods: <code class="literal">createCheckInRequestForAPatientWithAGuarantor</code>, <code class="literal">checkInaPatient</code>, and <code class="literal">assertResult</code>. From the test body, it is not possible to understand what is being tested, what data is created, and what is asserted. A<a id="id824" class="calibre1"/> test should configure data, call the actual method, and assert results.</p><p class="calibre9">The following is an example of a test with overly verbose documentation:</p><div class="informalexample"><pre class="programlisting">public void checks_in_patient() throws Exception {
  CheckInRequest request = new CheckInRequest();
  request.setCheckInDate(new Date());
  request.setDisease("Vomiting");
  request.setDoctor("Dr. Mike Hussey");

  String country = "US";
  String johnsStreetAddress = "123 Frazer";
  String johnsState = "PA";
  String johnsZipCode = "19355";
  Address johnsAddressMavernPhilly = buildAddress(johnsStreetAddress, country, johnsState, johnsZipCode,  AddressType.Residential);

  String johnsEmailId = "johnYou12345@gmail.com";
  String johnsFirstName = "John";
  String familyName = "Peterson";
  
  Person johnPeterson = buildPerson(johnsAddressMavernPhilly, familyName,johnsEmailId, johnsFirstName);

  request.setPerson(johnPeterson);
  
  Guarantor daddy = new Guarantor();
  daddy.setGuarantorType(GuarantorType.Person);
  String dadsStreetAddress = "12/e xyz Avenue";
  String dadsState = "NY";
  String dadsZipCode = "49355";
  Address dadsAddressNYBayArea =buildAddress(dadsStreetAddress, country, dadsState,dadsZipCode, AddressType.Residential);
  String dadsEmail = "dontDisturb@my.org";
  String dadsFirstName = "Freddy";
  Person johnsDad = buildPerson(dadsAddressNYBayArea, familyName,  dadsEmail, dadsFirstName);
  daddy.setPerson(johnsDad);
  request.setGuarantor(daddy);
}</pre></div><p class="calibre9">The test builds two <code class="literal">Person</code> objects and two <code class="literal">Address</code> objects. Two builder methods are extracted for code reuse. For better documentation, variables are created and the hardcoded values are set and passed to the builder methods. These hardcoded variables make it tough to understand <a id="id825" class="calibre1"/>what is going on.</p><p class="calibre9">Instead of creating a custom builder method in test class, you can modify the main data class to follow the builder pattern and build the object in multiple steps. That way, we don't have to create hardcoded variables such as <code class="literal">johnsStreetAddress</code>, we can directly call the methods we need.</p><p class="calibre9">The <code class="literal">Person</code> class is modified; the setter methods return an instance of <code class="literal">this</code> as follows:</p><div class="informalexample"><pre class="programlisting">public Person setFirstName(String firstName) {
  this.firstName = firstName;
  return this;
}
  
public Person setLastName(String lastName) {
  this.lastName = lastName;
  return this;
}</pre></div><p class="calibre9">From test, we can build the object easily. The following test example needs only an e-mail ID, first name, and phone number <a id="id826" class="calibre1"/>for testing, so it should not populate other values.</p><p class="calibre9">We can build the object in three steps, and we no longer need the hardcoded strings to document the behavior:</p><div class="informalexample"><pre class="programlisting">Person mark = new Person().setEmail("mark@gmail.com").setFirstName("Mark").setPhoneNumber1("444-999-0090");</pre></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec58" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This chapter covered the JUnit best practices and explained the underlying principles. The best practices are writing meaningful tests, automating unit tests, test configuration, working with assertions, exception handling in test cases, identifying test smells, and refactoring test smells.</p><p class="calibre9">Now you will be able to write clean and maintainable test cases.</p></div></body></html>