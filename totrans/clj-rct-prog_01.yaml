- en: Chapter 1. What is Reactive Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Programming is both an overloaded term and a broad topic. As such,
    this book will focus on a specific formulation of Reactive Programming called
    **Compositional Event Systems** (**CES**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before covering some history and background behind Reactive Programming and
    CES, I would like to open with a working and hopefully compelling example: an
    animation in which we draw a sine wave onto a web page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sine wave is simply the graph representation of the sine function. It is
    a smooth, repetitive oscillation, and at the end of our animation it will look
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Reactive Programming?](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This example will highlight how CES:'
  prefs: []
  type: TYPE_NORMAL
- en: Urges us to think about *what* we would like to do as opposed to *how*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encourages small, specific abstractions that can be composed together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produces terse and maintainable code that is easy to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The core of this program boils down to four lines of ClojureScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Simply by looking at this code it is impossible to determine precisely what
    it does. However, do take the time to read and imagine what it *could* do.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have a variable called `sine-wave`, which represents the 2D coordinates
    we will draw onto the web page. The next line gives us the intuition that `sine-wave`
    is some sort of collection-like abstraction: we use `.take` to retrieve 600 coordinates
    from it.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we `.subscribe` to this "collection" by passing it a callback. This
    callback will be called for each item in the sine-wave, finally drawing at the
    given *x* and *y* coordinates using the `fill-rect` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is quite a bit to take in for now as we haven''t seen any other code yet—but
    that was the point of this little exercise: even though we know nothing about
    the specifics of this example, we are able to develop an intuition of how it might
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what else is necessary to make this snippet animate a sine wave on
    our screen.
  prefs: []
  type: TYPE_NORMAL
- en: A taste of Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example is built in ClojureScript and uses HTML 5 Canvas for rendering
    and RxJS (see [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS))—a
    framework for Reactive Programming in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, keep in mind that we will not go into the details of these
    frameworks yet—that will happen later in this book. This means I'll be asking
    you to take quite a few things at face value, so don't worry if you don't immediately
    grasp how things work. The purpose of this example is to simply get us started
    in the world of Reactive Programming.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we will be using Chestnut (see [https://github.com/plexus/chestnut](https://github.com/plexus/chestnut))—a
    leiningen template for ClojureScript that gives us a sample working application
    we can use as a skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our new project, head over to the command line and invoke leiningen
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to modify a couple of things in the generated project. Open up
    `sin-wave/resources/index.html` and update it to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This simply ensures that we import both our application code and RxJS. We haven't
    downloaded RxJS yet so let's do this now. Browse to [https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js](https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js)
    and save this file to `sin-wave/resources/public`. The previous snippets also
    add an HTML 5 Canvas element onto which we will be drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `/src/cljs/sin_wave/core.cljs`. This is where our application code
    will live. You can ignore what is currently there. Make sure you have a clean
    slate like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, go back to the command line—under the `sin-wave` folder—and start
    up the following application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the previous command finishes, the application will be available at `http://localhost:10555`,
    where you will find a blank, rectangular canvas. We are now ready to begin.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason we are using the Chestnut template for this example is that
    it performs hot-reloading of our application code via websockets. This means we
    can have the browser and the editor side by side, and as we update our code, we
    will see the results immediately in the browser without having to reload the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate that this is working, open your web browser''s console so that
    you can see the output of the scripts in the page. Then add this to `/src/cljs/sin_wave/core.cljs`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should have seen the `hello clojurescript` message printed to your browser's
    console. Make sure you have a working environment up to this point as we will
    be relying on this workflow to interactively build our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also a good idea to make sure we clear the canvas every time Chestnut
    reloads our file. This is simple enough to do by adding the following snippet
    to our core namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a working environment, we can progress with our animation.
    It is probably a good idea to specify how often we would like to have a new animation
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'This effectively means adding the concept of *time* to our application. You''re
    free to play with different values, but let''s start with a new frame every 10
    milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As RxJS is a JavaScript library, we need to use ClojureScript's interoperability
    to call its functions. For convenience, we bind the `interval` function of RxJS
    to a local var. We will use this approach throughout this book when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create an infinite stream of numbers—starting at 0—that will have
    a new element every 10 milliseconds. Let''s make sure this is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I use the term *stream* very loosely here. It will be defined more precisely
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Remember time is infinite, so we use `.take` in order to avoid indefinitely
    printing out numbers to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to calculate the 2D coordinate representing a segment of the
    sine wave we can draw. This will be given by the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sine-coord` function takes an `x` point of our 2D Canvas and calculates
    the `y` point based on the sine of `x`. The constants `100` and `90` simply control
    how tall and sharp the slope should be. As an example, try calculating the sine
    coordinate when `x` is 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using `time` as the source for the values of `x`. Creating the sine
    wave now is only a matter of combining both `time` and `sine-coord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `time`, `sine-wave` is an infinite stream. The difference is that
    instead of just integers, we will now have the `x` and `y` coordinates of our
    sine wave, as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings us to the original code snippet which piqued our interest, alongside
    a function to perform the actual drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As this point, we can save the file again and watch as the sine wave we have
    just created gracefully appears on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: More colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the points this example sets out to illustrate is how thinking in terms
    of very simple abstractions and then building more complex ones on top of them
    make for code that is simpler to maintain and easier to modify.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we will now update our animation to draw the sine wave in different
    colors. In this case, we would like to draw the wave in red if the sine of `x`
    is negative and blue otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the sine value coming through the `sine-wave` stream, so all
    we need to do is to transform this stream into one that will give us the colors
    according to the preceding criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the new stream into the main drawing loop—remember
    to comment the previous one so that we don''t end up with multiple waves being
    drawn at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once we save the file, we should see a new sine wave alternating between red
    and blue as the sine of `x` oscillates from –1 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Making it reactive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As fun as this has been so far, the animation we have created isn't really reactive.
    Sure, it does react to time itself, but that is the very nature of animation.
    As we will later see, Reactive Programming is so called because programs react
    to external inputs such as mouse or network events.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will, therefore, update the animation so that the user is in control of
    when the color switch occurs: the wave will start red and switch to blue when
    the user clicks anywhere within the canvas area. Further clicks will simply alternate
    between red and blue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating infinite—as per the definition of `time`—streams for our
    color primitives as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On their own, `red` and `blue` aren''t that interesting as their values don''t
    change. We can think of them as *constant* streams. They become a lot more interesting
    when combined with another infinite stream that cycles between them based on user
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is our most complex update so far. If you look closely, you will also notice
    that `cycle-colour` is a recursive stream; that is, it is defined in terms of
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first saw code of this nature, we took a leap of faith in trying to
    understand what it does. After a quick read, however, we realized that `cycle-colour`
    follows closely how we might have *talked* about the problem: we will use red
    until a mouse click occurs, after which we will use blue until another mouse click
    occurs. Then, we start the recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The change to our animation loop is minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this book is to help you develop the instinct required to model
    problems in the way demonstrated here. After each chapter, more and more of this
    example will make sense. Additionally, a number of frameworks will be used both
    in ClojureScript and Clojure to give you a wide range of tools to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to that, we must take a little detour and understand how we
    got here.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the previous example in such a way that the sine wave is drawn using
    all rainbow colors. The drawing loop should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Your task is to implement the `rainbow-colours` stream. As everything up until
    now has been very light on explanations, you might choose to come back to this
    exercise later, once we have covered more about CES.
  prefs: []
  type: TYPE_NORMAL
- en: The `repeat`, `scan`, and `flatMap` functions may be useful in solving this
    exercise. Be sure to consult RxJs' API at [https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md).
  prefs: []
  type: TYPE_NORMAL
- en: A bit of history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk about what Reactive Programming is, it is important to understand
    how other relevant programming paradigms influenced how we develop software. This
    will also help us understand the motivations behind reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: With few exceptions most of us have been taught—either self-taught or at school/university—imperative
    programming languages such as C and Pascal or object-oriented languages such as
    Java and C++.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the imperative programming paradigm—of which object-oriented
    languages are part—dictates we write programs as a series of statements that modify
    program state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand what this means, let''s look at a short program written
    in pseudo-code that calculates the sum and the mean value of a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mean value is the average of the numbers in the list, obtained by dividing
    the sum by the number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new array of integers, called `numbers`, with numbers from
    1 to 6, inclusive. Then, we initialize `sum` to zero. Next, we iterate over the
    array of integers, one at a time, adding to `sum` the value of each number.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we calculate and assign the average of the numbers in the list to the
    `mean` local variable. This concludes the program logic.
  prefs: []
  type: TYPE_NORMAL
- en: This program would print 21 for the sum and 3 for the mean, if executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though a simple example, it highlights its imperative style: we set up an application
    state—`sum`—and then explicitly tell the computer how to modify that state in
    order to calculate the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Dataflow programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous example has an interesting property: the value of `mean` clearly
    has a dependency on the contents of `sum`.'
  prefs: []
  type: TYPE_NORMAL
- en: Dataflow programming makes this relationship explicit. It models applications
    as a dependency graph through which data flows—from operation to operation—and
    as values change, these changes are propagated to its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, dataflow programming has been supported by custom-built languages
    such as Lucid and BLODI, as such, leaving other general purpose programming languages
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this new insight would impact our previous example. We know that
    once the last line gets executed, the value of `mean` is assigned and won't change
    unless we explicitly reassign the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s imagine for a second that the pseudo-language we used earlier
    does support dataflow programming. In that case, assigning `mean` to an expression
    that refers to both `sum` and `count`, such as `sum / count(numbers)`, would be
    enough to create the directed dependency graph in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataflow programming](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that a direct side effect of this relationship is that an implicit dependency
    from `sum` to `numbers` is also created. This means that if `numbers` change,
    the change is propagated through the graph, first updating `sum` and then finally
    updating `mean`.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Reactive Programming comes in. This paradigm builds on dataflow
    programming and change propagation to bring this style of programming to languages
    that don't have native support for it.
  prefs: []
  type: TYPE_NORMAL
- en: For imperative programming languages, Reactive Programming can be made available
    via libraries or language extensions. We don't cover this approach in this book,
    but should the reader want more information on the subject, please refer to *dc-lib*
    (see [https://code.google.com/p/dc-lib/](https://code.google.com/p/dc-lib/)) for
    an example. It is a framework that adds Reactive Programming support to C++ via
    dataflow constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented Reactive Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing interactive applications such as desktop **Graphical User Interfaces**
    (**GUIs**), we are essentially using an object-oriented approach to Reactive Programming.
    We will build a simple calculator application to demonstrate this style.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clojure isn't an object-oriented language, but we will be interacting with parts
    of the Java API to build user interfaces that were developed in an OO paradigm,
    hence the title of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new leiningen project from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a directory called `calculator` in the current folder. Next,
    open the `project.clj` file in your favorite text editor and add a dependency
    on Seesaw, a Clojure library for working with Java Swing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: At the time of this writing, the latest Seesaw version available is 1.4.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `src/calculator/core.clj` file, we''ll start by requiring the
    Seesaw library and creating the visual components we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like the label to be updated automatically as soon as a user types
    a new number in any of the input fields. The following code does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `update-sum`, is our event handler. It sets the text of
    `result-label` to the sum of the values in `field-x` and `field-y`. We use try/catch
    here as a really basic way to handle errors since the key pressed might not have
    been a number. We then add the event handler to the `:key-released` event of both
    input fields.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real applications, we never want a catch block such as the previous one.
    This is considered bad style, and the catch block should do something more useful
    such as logging the exception, firing a notification, or resuming the application
    if possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost done. All we need to do now is add the components we have created
    so far to our `main-frame` and finally display it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can save the file and run the program from the command line in the project''s
    root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object-oriented Reactive Programming](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Experiment by typing some numbers in either or both text input fields and watch
    how the value of the label changes automatically, displaying the sum of both numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just created your first reactive application!
  prefs: []
  type: TYPE_NORMAL
- en: As alluded to previously, this application is reactive because the value of
    the result label *reacts* to user input and is updated automatically. However,
    this isn't the whole story—it lacks in composability and requires us to specify
    the how, not the what of what we're trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: As familiar as this style of programming may be, making applications reactive
    this way isn't always ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Given previous discussions, we notice we still had to be fairly explicit in
    setting up the relationships between the various components as evidenced by having
    to write a custom handler and bind it to both input fields.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see throughout the rest of this book, there is a much better way
    to handle similar scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The most widely used reactive program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both examples in the previous section will feel familiar to some readers. If
    we call the input text fields "cells" and the result label's handler a "formula",
    we now have the nomenclature used in modern spreadsheet applications such as Microsoft
    Excel.
  prefs: []
  type: TYPE_NORMAL
- en: The term Reactive Programming has only been in use in recent years, but the
    idea of a reactive application isn't new. The first electronic spreadsheet dates
    back to 1969 when Rene Pardo and Remy Landau, then recent graduates from Harvard
    University, created **LANPAR** (**LANguage for Programming Arrays at Random**)
    [1].
  prefs: []
  type: TYPE_NORMAL
- en: 'It was invented to solve a problem that Bell Canada and AT&T had at the time:
    their budgeting forms had 2000 cells that, when modified, forced a software re-write
    taking anywhere from six months to two years.'
  prefs: []
  type: TYPE_NORMAL
- en: To this day, electronic spreadsheets remain a powerful and useful tool for professionals
    of various fields.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another similarity the keen reader may have noticed is with the Observer design
    pattern. It is mainly used in object-oriented applications as a way for objects
    to communicate with each other without having any knowledge of who depends on
    its changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, a simple version of the Observer pattern can be implemented using
    *watches*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating our program state, in this case an atom holding an empty
    vector. Next, we create a watch function that knows how to sum all numbers in
    `numbers`. Finally, we add our watch function to the numbers atom under the `:adder`
    key (useful for removing watches).
  prefs: []
  type: TYPE_NORMAL
- en: The `adder` key conforms with the API contract required by `add-watch` and receives
    four arguments. In this example, we only care about `new-state`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, whenever we update the value of `numbers`, its watch will be executed,
    as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines above indicate the result that is printed on the screen
    each time we update the atom.
  prefs: []
  type: TYPE_NORMAL
- en: Though useful, the Observer pattern still requires some amount of work in setting
    up the dependencies and the required program state in addition to being hard to
    compose.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, this pattern has been extended and is at the core of one of
    the Reactive Programming frameworks we will look at later in this book, Microsoft's
    **Reactive Extensions** (**Rx**).
  prefs: []
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like Reactive Programming, **Functional Reactive Programming**—**FRP**
    for short—has unfortunately become an overloaded term.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks such as RxJava (see [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)),
    ReactiveCocoa (see [https://github.com/ReactiveCocoa/ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)),
    and Bacon.js (see [https://baconjs.github.io/](https://baconjs.github.io/)) became
    extremely popular in recent years and had positioned themselves incorrectly as
    FRP libraries. This led to the confusion surrounding the terminology.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, these frameworks do not implement FRP but rather are inspired
    by it.
  prefs: []
  type: TYPE_NORMAL
- en: In the interest of using the correct terminology as well as understanding what
    "inspired by FRP" means, we will have a brief look at the different formulations
    of FRP.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order FRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Higher-order FRP refers to the original research on FRP developed by Conal Elliott
    and Paul Hudak in their paper *Functional Reactive Animation* [2] from 1997\.
    This paper presents *Fran*, a domain-specific language embedded in Haskell for
    creating reactive animations. It has since been implemented in several languages
    as a library as well as purpose built reactive languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall the calculator example we created a few pages ago, we can see
    how that style of Reactive Programming requires us to manage state explicitly
    by directly reading and writing from/to the input fields. As Clojure developers,
    we know that avoiding state and mutable data is a good principle to keep in mind
    when building software. This principle is at the core of Functional Programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This short program increments by one all elements in the original list, filters
    all even numbers, and adds them up using `reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: Note how we didn't have to explicitly manage local state through at each step
    of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Differently from imperative programming, we focus on what we want to do, for
    example iteration, and not how we want it to be done, for example using a `for`
    loop. This is why the implementation matches our description of the program closely.
    This is known as declarative programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'FRP brings the same philosophy to Reactive Programming. As the Haskell programming
    language wiki on the subject has wisely put it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FRP is about handling time-varying values like they were regular values.*'
  prefs: []
  type: TYPE_NORMAL
- en: Put another way, FRP is a declarative way of modeling systems that respond to
    input over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both statements touch on the concept of time. We''ll be exploring that in the
    next section, where we introduce the key abstractions provided by FRP: signals
    (or behaviors) and events.'
  prefs: []
  type: TYPE_NORMAL
- en: Signals and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have been dealing with the idea of programs that react to user input.
    This is of course only a small subset of reactive systems but is enough for the
    purposes of this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'User input happens several times through the execution of a program: key presses,
    mouse drags, and clicks are but a few examples of how a user might interact with
    our system. All these interactions happen over a period of time. FRP recognizes
    that time is an important aspect of reactive programs and makes it a first-class
    citizen through its abstractions.'
  prefs: []
  type: TYPE_NORMAL
- en: Both signals (also called behaviors) and events are related to time. Signals
    represent continuous, time-varying values. Events, on the other hand, represent
    discrete occurrences at a given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, time is itself a signal. It varies continuously and indefinitely.
    On the other hand, a key press by a user is an event, a discrete occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note, however, that the semantics of how a signal changes
    need not be continuous. Imagine a signal that represents the current (x,y) coordinates
    of your mouse pointer.
  prefs: []
  type: TYPE_NORMAL
- en: This signal is said to change discretely as it depends on the user moving the
    mouse pointer—an event—which isn't a continuous action.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most defining characteristic of classical FRP is the use of continuous
    time.
  prefs: []
  type: TYPE_NORMAL
- en: This means FRP assumes that signals are changing all the time, even if their
    value is still the same, leading to needless recomputation. For example, the mouse
    position signal will trigger updates to the application dependency graph—like
    the one we saw previously for the mean program—even when the mouse is stationary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem is that classical FRP is synchronous by default: events are
    processed in order, one at a time. Harmless at first, this can cause delays, which
    would render an application unresponsive should an event take substantially longer
    to process.'
  prefs: []
  type: TYPE_NORMAL
- en: Paul Hudak and others furthered research on higher-order FRP [7] [8] to address
    these issues, but that came at the cost of expressivity.
  prefs: []
  type: TYPE_NORMAL
- en: The other formulations of FRP aim to overcome these implementation challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of the chapter, I'll be using signals and behaviors interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: First-order FRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most well-known reactive language in this category is Elm (see [http://elm-lang.org/](http://elm-lang.org/)),
    an FRP language that compiles to JavaScript. It was created by Evan Czaplicki
    and presented in his paper *Elm: Concurrent FRP for Functional GUIs* [3].'
  prefs: []
  type: TYPE_NORMAL
- en: Elm makes some significant changes to higher-order FRP.
  prefs: []
  type: TYPE_NORMAL
- en: It abandons the idea of continuous time and is entirely event-driven. As a result,
    it solves the problem of needless recomputation highlighted earlier. First-order
    FRP combines both behaviors and events into signals which, in contrast to higher-order
    FRP, are discrete.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, first-order FRP allows the programmer to specify when synchronous
    processing of events isn't necessary, preventing unnecessary processing delays.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Elm is a strict programming language—meaning arguments to functions
    are evaluated eagerly—and that is a conscious decision as it prevents space and
    time leaks, which are possible in a lazy language such as Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an FRP library such as Fran, implemented in a lazy language, memory usage
    can grow unwieldy as computations are deferred to the absolutely last possible
    moment, therefore causing a space leak. These larger computations, accumulated
    over time due to laziness, can then cause unexpected delays when finally executed,
    causing time leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous data flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous Data Flow generally refers to frameworks such as **Reactive Extensions**
    (**Rx**), **ReactiveCocoa**, and **Bacon.js**. It is called as such as it completely
    eliminates synchronous updates.
  prefs: []
  type: TYPE_NORMAL
- en: These frameworks introduce the concept of **Observable Sequences** [4], sometimes
    called Event Streams.
  prefs: []
  type: TYPE_NORMAL
- en: This formulation of FRP has the advantage of not being confined to functional
    languages. Therefore, even imperative languages like Java can take advantage of
    this style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, these frameworks were responsible for the confusion around FRP terminology.
    Conal Elliott at some point suggested the term CES (see [https://twitter.com/conal/status/468875014461468677](https://twitter.com/conal/status/468875014461468677)).
  prefs: []
  type: TYPE_NORMAL
- en: 'I have since adopted this terminology (see [http://vimeo.com/100688924](http://vimeo.com/100688924))
    as I believe it highlights two important factors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A fundamental difference between CES and FRP: CES is entirely event-driven'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CES is highly composable via combinators, taking inspiration from FRP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CES is the main focus of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Arrowized FRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the last formulation we will look at. Arrowized FRP [5] introduces
    two main differences over higher-order FRP: it uses signal functions instead of
    signals and is built on top of John Hughes'' Arrow combinators [6].'
  prefs: []
  type: TYPE_NORMAL
- en: It is mostly about a different way of structuring code and can be implemented
    as a library. As an example, Elm supports Arrowized FRP via its Automaton (see
    [https://github.com/evancz/automaton](https://github.com/evancz/automaton)) library.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first draft of this chapter grouped the different formulations of FRP under
    the broad categories of *Continuous and Discrete* FRP. Thanks to Evan Czaplicki''s
    excellent talk *Controlling Time and Space: understanding the many formulations
    of FRP* (see [https://www.youtube.com/watch?v=Agu6jipKfYw](https://www.youtube.com/watch?v=Agu6jipKfYw)),
    I was able to borrow the more specific categories used here. These come in handy
    when discussing the different approaches to FRP.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications of FRP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The different FRP formulations are being used today in several problem spaces
    by professionals and big organizations alike. Throughout this book, we'll look
    at several examples of how CES can be applied. Some of these are interrelated
    as most modern programs have several cross-cutting concerns, but we will highlight
    two main areas.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming and networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GUIs are a great example of asynchronous programming. Once you open a web or
    a desktop application, it simply sits there, idle, waiting for user input.
  prefs: []
  type: TYPE_NORMAL
- en: This state is often called the event or main event loop. It is simply waiting
    for external stimuli, such as a key press, a mouse button click, new data from
    the network, or even a simple timer.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these stimuli is associated with an event handler that gets called when
    one of these events happen, hence the asynchronous nature of GUI systems.
  prefs: []
  type: TYPE_NORMAL
- en: This is a style of programming we have been used to for many years, but as business
    and user needs grow, these applications grow in complexity as well, and better
    abstractions are needed to handle the dependencies between all the components
    of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Another great example that deals with managing complexity around network traffic
    is Netflix, which uses CES to provide a reactive API to their backend services.
  prefs: []
  type: TYPE_NORMAL
- en: Complex GUIs and animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Games are, perhaps, the best example of complex user interfaces as they have
    intricate requirements around user input and animations.
  prefs: []
  type: TYPE_NORMAL
- en: The Elm language we mentioned before is one of the most exciting efforts in
    building complex GUIs. Another example is Flapjax, also targeted at web applications,
    but is provided as a JavaScript library that can be integrated with existing JavaScript
    code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactive Programming is all about building responsive applications. There are
    several ways in which we can make our applications reactive. Some are old ideas:
    dataflow programming, electronic spreadsheets, and the Observer pattern are all
    examples. But CES in particular has become popular in recent years.'
  prefs: []
  type: TYPE_NORMAL
- en: CES aims to bring to Reactive Programming the declarative way of modeling problems
    that is at the core of Functional Programming. We should worry about what and
    not about how.
  prefs: []
  type: TYPE_NORMAL
- en: In next chapters, we will learn how we can apply CES to our own programs.
  prefs: []
  type: TYPE_NORMAL
