<html><head></head><body>
<div id="_idContainer080">
<h1 class="chapter-number" id="_idParaDest-200"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-201"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.2.1">FIRST Tests and the Test Pyramid</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far in this book, we’ve seen the value of writing unit tests that run quickly and give repeatable results. </span><span class="koboSpan" id="kobo.3.2">Called FIRST tests, these provide rapid feedback on our design. </span><span class="koboSpan" id="kobo.3.3">They are the gold standard of unit tests. </span><span class="koboSpan" id="kobo.3.4">We’ve also seen how the hexagonal architecture helps us design our code in a way that gets the maximum amount covered by FIRST unit tests. </span><span class="koboSpan" id="kobo.3.5">But we’ve also limited ourselves to testing only our domain model – the core of our application logic. </span><span class="koboSpan" id="kobo.3.6">We simply have no tests covering how our domain model behaves once it connects to the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">outside world.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover all the other kinds of tests that we need. </span><span class="koboSpan" id="kobo.5.2">We will introduce the test pyramid, which is a way of thinking about the different kinds of tests needed, and how many of each we should have. </span><span class="koboSpan" id="kobo.5.3">We’ll discuss what each kind of test covers and useful techniques and tools to help. </span><span class="koboSpan" id="kobo.5.4">We’ll also bring the whole system together by introducing CI/CD pipelines and test environments, outlining the critical role they play in combining code components to create a system for our </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">end users.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">test pyramid</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Unit tests – </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">FIRST tests</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Integration tests</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">End-to-end and user </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">acceptance tests</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">CI/CD pipelines and </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">test environments</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Wordz – integration test for </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">our database</span></span></li>
</ul>
<h1 id="_idParaDest-202"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter10"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">To run this code, we will need to install the open source Postgres </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">database locally.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">To install Postgres, do </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.29.1">Go to </span><a href="https://www.postgresql.org/download/"><span class="koboSpan" id="kobo.30.1">https://www.postgresql.org/download/</span></a><span class="koboSpan" id="kobo.31.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">your browser.</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Click on the correct installer for your </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">operating system:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.35.1"><img alt="Figure 10.1 – Postgres installer selection" src="image/Figure_10.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.36.1">Figure 10.1 – Postgres installer selection</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.37.1">Follow the instructions for your </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">operating system.</span></span></li>
</ol>
<h1 id="_idParaDest-203"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.39.1">The test pyramid</span></h1>
<p><span class="koboSpan" id="kobo.40.1">A very useful way of thinking</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.41.1"> about different kinds of tests is by using the </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">test pyramid</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">It is a simple graphical representation of the different kinds of tests we need around our code and the relative numbers of each. </span><span class="koboSpan" id="kobo.43.3">This section introduces the key ideas behind the </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">test pyramid.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">The test pyramid in graphic form looks </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.47.1"><img alt="Figure 10.2 – The test pyramid" src="image/Figure_10.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.48.1">Figure 10.2 – The test pyramid</span></p>
<p><span class="koboSpan" id="kobo.49.1">We can see from the previous</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.50.1"> graphic that tests are divided into four layers. </span><span class="koboSpan" id="kobo.50.2">We have unit tests at the bottom. </span><span class="koboSpan" id="kobo.50.3">Integration tests are layered on top of those. </span><span class="koboSpan" id="kobo.50.4">The pyramid is completed by end-to-end and user acceptance tests at the top. </span><span class="koboSpan" id="kobo.50.5">The graphic shows unit tests in our system are the highest in number, with fewer integration tests and the least number of </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">acceptance tests.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Some of these kinds of tests are new to this book. </span><span class="koboSpan" id="kobo.52.2">Let’s define what </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">they are:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.54.1">Unit tests</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.55.1">These are familiar. </span><span class="koboSpan" id="kobo.55.2">They are the FIRST tests we have</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.56.1"> been using up until now. </span><span class="koboSpan" id="kobo.56.2">One defining feature of these tests is that they do not require the presence of any external systems, such as databases or </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">payment processors.</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.58.1">Integration tests</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.59.1">These tests verify that a software component</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.60.1"> is correctly integrated with an external system, such as a database. </span><span class="koboSpan" id="kobo.60.2">These tests are slow and critically dependent on the external environment being available and correctly set up for </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">our test.</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">End-to-end tests</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.63.1">These are the broadest</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.64.1"> of all tests. </span><span class="koboSpan" id="kobo.64.2">An end-to-end test represents something very close to the end user experience. </span><span class="koboSpan" id="kobo.64.3">This test is performed against all the real components of the system – possibly in test environments with test data – using the same commands as a real user </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">would use.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">User </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.67.1">acceptance tests</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.68.1">This is where the real system</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.69.1"> is tested as a user would use it. </span><span class="koboSpan" id="kobo.69.2">Here, we can confirm that the final system is fit for purpose, according to the requirements the user has </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">given us.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">It’s not obvious</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.72.1"> at first why having fewer tests of any kind would be an advantage. </span><span class="koboSpan" id="kobo.72.2">After all, everything up until now in this book has positively praised the value of testing. </span><span class="koboSpan" id="kobo.72.3">Why do we not simply have </span><em class="italic"><span class="koboSpan" id="kobo.73.1">all the tests</span></em><span class="koboSpan" id="kobo.74.1">? </span><span class="koboSpan" id="kobo.74.2">The answer is a pragmatic one: not all tests are created equal. </span><span class="koboSpan" id="kobo.74.3">They don’t all offer equal value to us </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">as developers.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">The reason for the shape of this pyramid is to reflect the practical value of each layer of testing. </span><span class="koboSpan" id="kobo.76.2">Unit tests written as FIRST tests are </span><em class="italic"><span class="koboSpan" id="kobo.77.1">fast</span></em><span class="koboSpan" id="kobo.78.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.79.1">repeatable</span></em><span class="koboSpan" id="kobo.80.1">. </span><span class="koboSpan" id="kobo.80.2">If we could build a system out of only these unit tests, we surely would. </span><span class="koboSpan" id="kobo.80.3">But unit tests do not exercise every part of our code base. </span><span class="koboSpan" id="kobo.80.4">Specifically, they do not exercise connections from our code to the outside world. </span><span class="koboSpan" id="kobo.80.5">Nor do they exercise our application in the same way as a user would use it. </span><span class="koboSpan" id="kobo.80.6">As we progress up through the layers of testing, we move away from testing the </span><em class="italic"><span class="koboSpan" id="kobo.81.1">internal</span></em><span class="koboSpan" id="kobo.82.1"> components of our software and move toward testing how it interacts with </span><em class="italic"><span class="koboSpan" id="kobo.83.1">external</span></em><span class="koboSpan" id="kobo.84.1"> systems and, ultimately, the end user of </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">The test pyramid is about </span><em class="italic"><span class="koboSpan" id="kobo.87.1">balance</span></em><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">It aims to create layers of tests that achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.90.1">Run as quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">as possible</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">Cover as much code </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">as possible</span></span></li>
<li><span class="koboSpan" id="kobo.94.1">Prevent as many defects </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">as possible</span></span></li>
<li><span class="koboSpan" id="kobo.96.1">Minimize duplication of the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">test effort</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.98.1">In the following sections, we will look at a breakdown of the tests involved at each layer of the test</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.99.1"> pyramid. </span><span class="koboSpan" id="kobo.99.2">We’ll consider the strengths and weaknesses of each kind of test, allowing us to understand what the test pyramid is guiding </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">us toward.</span></span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.101.1">Unit tests – FIRST tests</span></h1>
<p><span class="koboSpan" id="kobo.102.1">In this section, we’re going to look at the base</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.103.1"> of the test pyramid, which consists of unit tests. </span><span class="koboSpan" id="kobo.103.2">We’ll examine why this layer is critical </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">to success.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">By now, we’re very familiar with FIRST unit tests. </span><span class="koboSpan" id="kobo.105.2">The preceding chapters have covered these in detail. </span><span class="koboSpan" id="kobo.105.3">They are the gold standard of unit tests. </span><span class="koboSpan" id="kobo.105.4">They are fast to run. </span><span class="koboSpan" id="kobo.105.5">They are repeatable and reliable. </span><span class="koboSpan" id="kobo.105.6">They run isolated from each other, so we can run one, or run many and run them in any order we choose. </span><span class="koboSpan" id="kobo.105.7">FIRST tests are the powerhouses of TDD, enabling us to work with a rapid feedback loop as we code. </span><span class="koboSpan" id="kobo.105.8">Ideally, all our code would fall under this feedback loop. </span><span class="koboSpan" id="kobo.105.9">It provides a fast, efficient way to work. </span><span class="koboSpan" id="kobo.105.10">At every step, we can execute code and prove to ourselves that it is working as we intended. </span><span class="koboSpan" id="kobo.105.11">As a helpful byproduct, by writing tests that exercise each possible desirable behavior in our code, we will end up exercising every possible code path. </span><span class="koboSpan" id="kobo.105.12">We will get 100% </span><em class="italic"><span class="koboSpan" id="kobo.106.1">meaningful</span></em><span class="koboSpan" id="kobo.107.1"> test coverage of code under unit tests when we work in </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">this way.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Because of their advantages, unit tests form the bedrock of our testing strategy. </span><span class="koboSpan" id="kobo.109.2">They are represented as the base of the </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">test pyramid.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Unit tests have advantages</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.112.1"> and limitations, as summarized</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.113.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">following table:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.115.1">Advantages</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.116.1">Limitations</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.117.1">These are the fastest-running tests and provide the fastest possible feedback loop for </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">our code.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.119.1">The smaller scope of these tests means that having all unit tests pass is no guarantee that the system as a whole is </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">working correctly.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.121.1">Stable and repeatable, having no dependencies on things outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">our control.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.123.1">They can be written with too strong a tie to implementation details, making future additions and </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">refactoring difficult.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.125.1">Can provide very detailed coverage of a specific set of logic. </span><span class="koboSpan" id="kobo.125.2">Locate </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">defects accurately.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.127.1">Not helpful for testing interactions with </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">external systems.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.129.1">Table 10.1 – Unit test advantages and disadvantages</span></p>
<p><span class="koboSpan" id="kobo.130.1">In any system, we expect</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.131.1"> to have the largest number of tests at the unit level. </span><span class="koboSpan" id="kobo.131.2">The test pyramid represents </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">this graphically.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">We can’t achieve full coverage by using unit tests alone in the real world but we can improve our situation. </span><span class="koboSpan" id="kobo.133.2">By applying the hexagonal architecture to our application, we can get the majority of code under unit tests. </span><span class="koboSpan" id="kobo.133.3">Our fast-running unit tests can cover a lot of ground like this and provide a lot of confidence in our application logic. </span><span class="koboSpan" id="kobo.133.4">We can get as far as knowing that if the external systems behave as we expect them to, our domain layer code will be able to correctly handle every use case we have </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">thought about.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">The test position when using unit tests alone is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.137.1"><img alt="Figure 10.3 – Unit tests cover the domain model" src="image/Figure_10.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.138.1">Figure 10.3 – Unit tests cover the domain model</span></p>
<p><span class="koboSpan" id="kobo.139.1">Unit tests only test</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.140.1"> components of our domain model. </span><span class="koboSpan" id="kobo.140.2">They do not test external systems, nor do they use external systems. </span><span class="koboSpan" id="kobo.140.3">They rely on test doubles to simulate our external systems for us. </span><span class="koboSpan" id="kobo.140.4">This gives us advantages in development cycle speed but has the drawback that our connections to those external systems remain untested. </span><span class="koboSpan" id="kobo.140.5">If we have a piece of unit-tested code that accesses a repository interface, we know that its logic works with a stub repository. </span><span class="koboSpan" id="kobo.140.6">Its internal logic will even have 100% test coverage and this will be valid. </span><span class="koboSpan" id="kobo.140.7">But we won’t know if it will work with the real </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">repository yet.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">The adapter layer code</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.143.1"> is responsible for those connections, and it is not tested at the unit test level. </span><span class="koboSpan" id="kobo.143.2">To test this layer, we’re going to need a different approach to testing. </span><span class="koboSpan" id="kobo.143.3">We will need to test what happens when our domain layer code is integrated with actual </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">external systems.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">The next section looks at how we test these external systems adapters using a kind of testing known as </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">integration tests.</span></span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.147.1">Integration tests</span></h1>
<p><span class="koboSpan" id="kobo.148.1">In this section, we’re going to look at the next</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.149.1"> layer up in the test pyramid: integration testing. </span><span class="koboSpan" id="kobo.149.2">We’ll see why it’s important, review helpful tools, and understand the role of integration testing in the overall scheme </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">of things.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.151.1">Integration tests</span></strong><span class="koboSpan" id="kobo.152.1"> exist to test that our code will successfully integrate with external systems. </span><span class="koboSpan" id="kobo.152.2">Our core application logic is tested by unit tests, which, by design, do not interact with external systems. </span><span class="koboSpan" id="kobo.152.3">This means that we need to test behavior with those external systems at </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">some point.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">Integration tests are the second layer up in the test pyramid. </span><span class="koboSpan" id="kobo.154.2">They have advantages</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.155.1"> and limitations, as summarized</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.156.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">following table:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.158.1">Advantages</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.159.1">Limitations</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.160.1">Test that software components interact correctly </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">when connected</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.162.1">Require test environments to be set up </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">and maintained</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.164.1">Provide a closer simulation of the software system as it will be </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">used live</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.166.1">Tests run more slowly than </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">unit tests</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.168.1">Susceptible to problems in the test environment, such as incorrect data or network </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">connection failures</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Table 10.2 – Integration test advantages and disadvantages</span></p>
<p><span class="koboSpan" id="kobo.171.1">There should be fewer integration </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.172.1">tests than unit tests. </span><span class="koboSpan" id="kobo.172.2">Ideally, far fewer. </span><span class="koboSpan" id="kobo.172.3">While unit tests avoided many problems of testing external systems by using test doubles, integration tests must now face those challenges. </span><span class="koboSpan" id="kobo.172.4">By nature, they are more difficult to set up. </span><span class="koboSpan" id="kobo.172.5">They </span><em class="italic"><span class="koboSpan" id="kobo.173.1">can</span></em><span class="koboSpan" id="kobo.174.1"> be less repeatable. </span><span class="koboSpan" id="kobo.174.2">They generally run more slowly than unit tests do, as they wait for responses from </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">external systems.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">To give a sense of this, a typical system might have thousands of unit tests and hundreds of acceptance tests. </span><span class="koboSpan" id="kobo.176.2">In between, we have several integration tests. </span><span class="koboSpan" id="kobo.176.3">Many integration tests point to a design opportunity. </span><span class="koboSpan" id="kobo.176.4">We can refactor the code so that our integration test is pushed down to being a unit test or promoted to being an </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">acceptance test.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Another reason</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.179.1"> to have fewer integration tests is due to </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">flaky tests</span></strong><span class="koboSpan" id="kobo.181.1">.  </span><span class="koboSpan" id="kobo.181.2">A flaky test is a nickname given to a test that sometimes passes and sometimes fails. </span><span class="koboSpan" id="kobo.181.3">When it fails, it is due to some problem interacting with the external system and not a defect in the code</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.182.1"> we are testing. </span><span class="koboSpan" id="kobo.182.2">Such a failure is called a </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">false negative</span></strong><span class="koboSpan" id="kobo.184.1"> test result – a result that can </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">mislead us.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Flaky tests are a nuisance precisely because we cannot immediately tell the root cause of the failure. </span><span class="koboSpan" id="kobo.186.2">Without diving into error logs, we only know that the test failed. </span><span class="koboSpan" id="kobo.186.3">This leads to developers learning to ignore these failed tests, often choosing to re-run the test suite several times until the flaky test passes. </span><span class="koboSpan" id="kobo.186.4">The problem here is that we are training developers to have less faith in their tests. </span><span class="koboSpan" id="kobo.186.5">We are training them to ignore test failures. </span><span class="koboSpan" id="kobo.186.6">This is not a good place </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">to be.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.188.1">What should an integration test cover?</span></h2>
<p><span class="koboSpan" id="kobo.189.1">In our design so far, we have decoupled</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.190.1"> external systems from our domain code using the </span><em class="italic"><span class="koboSpan" id="kobo.191.1">Dependency Inversion Principle</span></em><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">We have created an interface defining how we use that external system. </span><span class="koboSpan" id="kobo.192.3">There will be some implementation of this interface, which is what our</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.193.1"> integration test will be covering. </span><span class="koboSpan" id="kobo.193.2">In hexagonal architecture terms, this is </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">an </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">adapter</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">This adapter</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.198.1"> should only contain the minimum amount of code necessary to interact with the external system in a way that satisfies our interface. </span><span class="koboSpan" id="kobo.198.2">It should have no application logic in it at all. </span><span class="koboSpan" id="kobo.198.3">That should</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.199.1"> be inside the domain layer and covered by unit tests. </span><span class="koboSpan" id="kobo.199.2">We call this a </span><em class="italic"><span class="koboSpan" id="kobo.200.1">thin adapter</span></em><span class="koboSpan" id="kobo.201.1">, doing only enough work to adapt to the external system. </span><span class="koboSpan" id="kobo.201.2">This means our integration test is nicely limited </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">in scope.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">We can represent the scope of an integration test </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">like so:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.205.1"><img alt="Figure 10.4 – Integration tests cover the adapter layer" src="image/Figure_10.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.206.1">Figure 10.4 – Integration tests cover the adapter layer</span></p>
<p><span class="koboSpan" id="kobo.207.1">Integration tests only test the adapter layer components, those pieces of code that directly interact with external systems, such as databases and web endpoints. </span><span class="koboSpan" id="kobo.207.2">The integration test will create an instance of the adapter under test and arrange for it to connect to </span><em class="italic"><span class="koboSpan" id="kobo.208.1">a version</span></em><span class="koboSpan" id="kobo.209.1"> of the external service. </span><span class="koboSpan" id="kobo.209.2">This is important. </span><span class="koboSpan" id="kobo.209.3">We’re still not connecting to the production services yet. </span><span class="koboSpan" id="kobo.209.4">Until the integration test passes, we’re not sure that our adapter code works correctly. </span><span class="koboSpan" id="kobo.209.5">So, we don’t want to access real services just yet. </span><span class="koboSpan" id="kobo.209.6">We also want to have that extra level of control over these services. </span><span class="koboSpan" id="kobo.209.7">We want to be able to safely and easily create test accounts and fake data to use with our adapter. </span><span class="koboSpan" id="kobo.209.8">That means we need a collection of live-like services and databases to use. </span><span class="koboSpan" id="kobo.209.9">That means they have to live and </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">run somewhere.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.211.1">Test environments</span></strong><span class="koboSpan" id="kobo.212.1"> are the name given to the arrangement of external</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.213.1"> systems we use in integration tests. </span><span class="koboSpan" id="kobo.213.2">It is an environment for running web services and data sources, specifically </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">for testing.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">A test environment</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.216.1"> enables our code to connect to test versions of real external systems. </span><span class="koboSpan" id="kobo.216.2">It’s one step closer to production readiness, compared to the unit test level. </span><span class="koboSpan" id="kobo.216.3">There are some challenges involved in using test environments, however. </span><span class="koboSpan" id="kobo.216.4">Let’s look into the good practices for testing integrations with databases and </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">web services.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.218.1">Testing database adapters</span></h2>
<p><span class="koboSpan" id="kobo.219.1">The basic approach to testing</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.220.1"> a database adapter</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.221.1"> is to set up a database server in the test environment and get the code under test to connect to it. </span><span class="koboSpan" id="kobo.221.2">The integration test will preload a known dataset into the database as part of its Arrange step. </span><span class="koboSpan" id="kobo.221.3">The test then runs the code that interacts with the database in the Act step. </span><span class="koboSpan" id="kobo.221.4">The Assert step can inspect the database to see if expected database </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">changes happened.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">The biggest challenge in testing a database is that it remembers data. </span><span class="koboSpan" id="kobo.223.2">Now, this might seem a little obvious, as that is the entire point of using a database in the first place. </span><span class="koboSpan" id="kobo.223.3">But it conflicts with one of the goals of testing: to have isolated, repeatable tests. </span><span class="koboSpan" id="kobo.223.4">As an example, if our test created a new user account for user </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">testuser1</span></strong><span class="koboSpan" id="kobo.225.1"> and that was stored in the database, we would have a problem running that test again. </span><span class="koboSpan" id="kobo.225.2">It would not be able to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">testuser1</span></strong><span class="koboSpan" id="kobo.227.1"> and instead would receive a </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">user already </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.229.1">exists</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1"> error.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">There are different approaches to overcoming this problem, each </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">with trade-offs:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.233.1">Delete all data from the database before and after each </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.234.1">test case</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.235.1">This approach preserves the isolation of our tests, but it is slow. </span><span class="koboSpan" id="kobo.235.2">We have to recreate the test database schema before </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">every test.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.237.1">Delete all data before and after the full set of adapter </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.238.1">tests run</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.239.1">We delete data less often, allowing several related tests to run against the same database. </span><span class="koboSpan" id="kobo.239.2">This loses test isolation due to the stored data, as the database will not be in the state expected at the start of the next test. </span><span class="koboSpan" id="kobo.239.3">We have to run tests in a particular order, and they must all pass, to avoid spoiling the database state for the next test. </span><span class="koboSpan" id="kobo.239.4">This is not a </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">good approach.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.241.1">Use </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.242.1">randomized data</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.243.1">Instead of creating </span><em class="italic"><span class="koboSpan" id="kobo.244.1">testuser1</span></em><span class="koboSpan" id="kobo.245.1"> in our test, we randomize names. </span><span class="koboSpan" id="kobo.245.2">So, on one run, we might get </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">testuser-cfee-0a9b-931f</span></strong><span class="koboSpan" id="kobo.247.1">. </span><span class="koboSpan" id="kobo.247.2">On the next run, the randomly chosen username would be something else. </span><span class="koboSpan" id="kobo.247.3">The state stored in the database will not conflict with another run of the same test. </span><span class="koboSpan" id="kobo.247.4">This is another way to preserve test isolation. </span><span class="koboSpan" id="kobo.247.5">However, it does mean that tests can be harder to read. </span><span class="koboSpan" id="kobo.247.6">It requires periodic cleanup of the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">test database.</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.249.1">Rollback transactions</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.250.1">We can add data required by our tests inside a database transaction. </span><span class="koboSpan" id="kobo.250.2">We can roll back the transaction at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">the test.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.252.1">Ignore </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.253.1">the problem</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.254.1">Sometimes, if we work with read-only databases, we can add test data that will never be accessed by the production code and leave it there. </span><span class="koboSpan" id="kobo.254.2">If this works, it is an attractive option requiring no </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">extra effort.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">Tools such as </span><em class="italic"><span class="koboSpan" id="kobo.257.1">database-rider</span></em><span class="koboSpan" id="kobo.258.1">, available from </span><a href="https://database-rider.github.io/getting-started/"><span class="koboSpan" id="kobo.259.1">https://database-rider.github.io/getting-started/</span></a><span class="koboSpan" id="kobo.260.1">, assist by providing library</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.261.1"> code to connect to databases and initialize</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.262.1"> them with </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">test data.</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.264.1">Testing web services</span></h2>
<p><span class="koboSpan" id="kobo.265.1">A similar approach is used to test</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.266.1"> the integration with web services. </span><span class="koboSpan" id="kobo.266.2">A test</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.267.1"> version of the web service is set to run in the test environment. </span><span class="koboSpan" id="kobo.267.2">The adapter code is set to connect to this test version of the web service, instead of the real version. </span><span class="koboSpan" id="kobo.267.3">Our integration test can then examine how the adapter code behaves. </span><span class="koboSpan" id="kobo.267.4">There might be additional web APIs on the test service to allow inspection by the assertions in </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">our test.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Again, the disadvantages are a slower running test and the risk of flaky tests due to issues as trivial as </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">network congestion.</span></span></p>
<h3><span class="koboSpan" id="kobo.271.1">Sandbox APIs</span></h3>
<p><span class="koboSpan" id="kobo.272.1">Sometimes, hosting our own local service might be impossible, or at least undesirable. </span><span class="koboSpan" id="kobo.272.2">Third-party vendors are usually</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.273.1"> unwilling to release test versions of their service for us to use in our test environment. </span><span class="koboSpan" id="kobo.273.2">Instead, they typically offer a </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">sandbox API</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">This is a version of their service that the third party hosts, not us. </span><span class="koboSpan" id="kobo.275.3">It is disconnected from their production systems. </span><span class="koboSpan" id="kobo.275.4">This sandbox allows us to create test accounts and test data, safe from affecting anything real in production. </span><span class="koboSpan" id="kobo.275.5">It will respond to our requests as their production versions will respond, but without taking any action such as taking payment. </span><span class="koboSpan" id="kobo.275.6">Consider them test simulators for </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">real services.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.277.1">Consumer-driven contract testing</span></h2>
<p><span class="koboSpan" id="kobo.278.1">A useful approach</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.279.1"> to testing interactions with web services is called </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">consumer-driven contract testing</span></strong><span class="koboSpan" id="kobo.281.1">. </span><span class="koboSpan" id="kobo.281.2">We consider our code</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.282.1"> as having a contract with the external service. </span><span class="koboSpan" id="kobo.282.2">We agree to call certain API functions on the external service, supplying data in the form required. </span><span class="koboSpan" id="kobo.282.3">We need the external service to respond to us predictably, with data in a known format and well-understood status codes. </span><span class="koboSpan" id="kobo.282.4">This forms a </span><em class="italic"><span class="koboSpan" id="kobo.283.1">contract</span></em><span class="koboSpan" id="kobo.284.1"> between the two parties – our code and the external </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">service API.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Consumer-driven contract testing involves two components, based on that contract, often using code generated by tools. </span><span class="koboSpan" id="kobo.286.2">This is represented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.288.1"><img alt="Figure 10.5 – Consumer-driven contract testing" src="image/Figure_10.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.289.1">Figure 10.5 – Consumer-driven contract testing</span></p>
<p><span class="koboSpan" id="kobo.290.1">The preceding diagram shows that we’ve captured the expected interactions with an external service</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.291.1"> as an API contract. </span><span class="koboSpan" id="kobo.291.2">Our adapter for that service</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.292.1"> will be coded to implement that API contract. </span><span class="koboSpan" id="kobo.292.2">When using consumer-driven contract testing, we end up with two tests, which test either side of that contract. </span><span class="koboSpan" id="kobo.292.3">If we consider a service to be a black box, we have a public interface presented by the black box, and an implementation, whose details are hidden inside that black box. </span><span class="koboSpan" id="kobo.292.4">A contract test is two tests. </span><span class="koboSpan" id="kobo.292.5">One test confirms that the outside interface is compatible with our code. </span><span class="koboSpan" id="kobo.292.6">The other test confirms that the implementation of that interface works and gives the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">expected results.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">A typical contract test will need two pieces </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">of code:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.296.1">A stub of the external service</span></strong><span class="koboSpan" id="kobo.297.1">: A stub of the external service is generated. </span><span class="koboSpan" id="kobo.297.2">If we are calling a payment processor, this stub simulates the payment processor locally. </span><span class="koboSpan" id="kobo.297.3">This allows us to use it as a test double for the payment processor service as we write our adapter code. </span><span class="koboSpan" id="kobo.297.4">We can write an integration test against our adapter, configuring it to call this stub. </span><span class="koboSpan" id="kobo.297.5">This allows us to test our adapter code logic without accessing the external system. </span><span class="koboSpan" id="kobo.297.6">We can verify that the adapter sends the correct API calls to that external service and handles the expected </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">responses correctly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.299.1">A replay of a set of calls to the real external service</span></strong><span class="koboSpan" id="kobo.300.1">: The contract also allows us to run tests against the real external service – possibly in sandbox mode. </span><span class="koboSpan" id="kobo.300.2">We’re not testing the functionality of the external service here – we assume that the service provider has done that. </span><span class="koboSpan" id="kobo.300.3">Instead, we are verifying that what we believe about its API is true. </span><span class="koboSpan" id="kobo.300.4">Our adapter has been coded to make certain API calls in certain orders. </span><span class="koboSpan" id="kobo.300.5">This test verifies that this assumption is correct. </span><span class="koboSpan" id="kobo.300.6">If the test passes, we know that our understanding of the external service API was correct and also that it has not changed. </span><span class="koboSpan" id="kobo.300.7">If this test was previously working but now fails, that would be an early indication that the external service has changed its API. </span><span class="koboSpan" id="kobo.300.8">We would then need to update our adapter code to </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">follow that.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.302.1">One recommended</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.303.1"> tool for doing</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.304.1"> this is called Pact, available at </span><a href="https://docs.pact.io"><span class="koboSpan" id="kobo.305.1">https://docs.pact.io</span></a><span class="koboSpan" id="kobo.306.1">. </span><span class="koboSpan" id="kobo.306.2">Read the guides</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.307.1"> there for more details on this </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">interesting</span></span><span class="No-Break"><a id="_idIndexMarker548"/></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> technique.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">We’ve seen that integration tests get us one step nearer to production. </span><span class="koboSpan" id="kobo.310.2">In the next section, we look at the final level of testing in the test pyramid, which is the most live-like so far: user </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">acceptance tests.</span></span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.312.1">End-to-end and user acceptance tests</span></h1>
<p><span class="koboSpan" id="kobo.313.1">In this section, we will progress</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.314.1"> to the top of the test</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.315.1"> pyramid. </span><span class="koboSpan" id="kobo.315.2">We’ll review what end-to-end and user acceptance tests are and what they add to unit and </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">integration testing.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">At the top of the test pyramid lies two similar kinds of tests called </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">end-to-end tests</span></strong><span class="koboSpan" id="kobo.319.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">user acceptance tests</span></strong><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">Technically, they are the same kind of test. </span><span class="koboSpan" id="kobo.321.3">In each case, we start up the software fully configured to run in its most live-like test environment, or possibly in production. </span><span class="koboSpan" id="kobo.321.4">The idea is that the system is tested as a whole from one end to </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">One specific use of an end-to-end test is for </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">user acceptance testing</span></strong><span class="koboSpan" id="kobo.325.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.326.1">UAT</span></strong><span class="koboSpan" id="kobo.327.1">). </span><span class="koboSpan" id="kobo.327.2">Here, several key end-to-end test scenarios are run. </span><span class="koboSpan" id="kobo.327.3">If they all pass, the software is declared fit for purpose and accepted by the users. </span><span class="koboSpan" id="kobo.327.4">This is often a contractual stage in commercial development, where the buyer of the software formally agrees that the development contract has been satisfied. </span><span class="koboSpan" id="kobo.327.5">It’s still end-to-end testing that is being used to determine that, with cherry-picked </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">test cases.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">These tests have advantages</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.330.1"> and limitations, as summarized</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.331.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">following table:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.333.1">Advantages</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.334.1">Limitations</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.335.1">Most comprehensive testing of functionality available. </span><span class="koboSpan" id="kobo.335.2">We are testing at the same level that a user of our system – either person or machine – would experience </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">our system.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.337.1">Slowest tests </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">to run.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.339.1">Tests at this level are concerned with pure behavior as observed from outside the system. </span><span class="koboSpan" id="kobo.339.2">We could refactor and rearchitect large parts of the system and still have these tests </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">protect us.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.341.1">Reliability issues – many problems in the setup and environment of our system can cause false negative test failures. </span><span class="koboSpan" id="kobo.341.2">This is termed “brittleness” – our tests are highly dependent on their environment working correctly. </span><span class="koboSpan" id="kobo.341.3">Environments can be broken due to circumstances beyond </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">our control.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.343.1">Contractually important – these tests are the essence of what the end user </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">cares about.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.345.1">These are the most challenging of all the tests to write, due to the extensive environment </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">setup requirements.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.347.1">Table 10.3 – End-to-end test advantages and disadvantages</span></p>
<p><span class="koboSpan" id="kobo.348.1">Acceptance tests having</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.349.1"> a spot at the top of the pyramid is a reflection that we don’t need</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.350.1"> many of them. </span><span class="koboSpan" id="kobo.350.2">The majority of our code should now be covered by unit and integration tests, assuring us that our application logic works, as well as our connections to </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">external systems.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">The obvious question is </span><em class="italic"><span class="koboSpan" id="kobo.353.1">what’s left to test</span></em><span class="koboSpan" id="kobo.354.1">? </span><span class="koboSpan" id="kobo.354.2">We don’t want to duplicate testing that has already been done at the unit and integration levels. </span><span class="koboSpan" id="kobo.354.3">But we do need some way to validate that the software </span><em class="italic"><span class="koboSpan" id="kobo.355.1">as a whole</span></em><span class="koboSpan" id="kobo.356.1"> is going to work as expected. </span><span class="koboSpan" id="kobo.356.2">This is the job of end-to-end testing. </span><span class="koboSpan" id="kobo.356.3">This is where we configure our software so that it connects to real databases and real external services. </span><span class="koboSpan" id="kobo.356.4">Our production code has passed all the unit tests with test doubles. </span><span class="koboSpan" id="kobo.356.5">These test passes suggest our code </span><em class="italic"><span class="koboSpan" id="kobo.357.1">should</span></em><span class="koboSpan" id="kobo.358.1"> work when we connect these real external services. </span><span class="koboSpan" id="kobo.358.2">But </span><em class="italic"><span class="koboSpan" id="kobo.359.1">should</span></em><span class="koboSpan" id="kobo.360.1"> is a wonderful weasel word in software development. </span><span class="koboSpan" id="kobo.360.2">Now, is the time to verify that it does, using an end-to-end test. </span><span class="koboSpan" id="kobo.360.3">We can represent the coverage of these tests using the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.362.1"><img alt="Figure 10.6 – End-to-end/user acceptance tests cover the entire code base" src="image/Figure_10.6_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">Figure 10.6 – End-to-end/user acceptance tests cover the entire code base</span></p>
<p><span class="koboSpan" id="kobo.364.1">End-to-end tests cover the entire</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.365.1"> code base, both the domain model and the adapter </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.366.1">layer. </span><span class="koboSpan" id="kobo.366.2">As such, it repeats testing work already done by unit and integration tests. </span><span class="koboSpan" id="kobo.366.3">The main technical aspect we want to test in end-to-end testing is that our software is configured and wired up correctly. </span><span class="koboSpan" id="kobo.366.4">Throughout this book, we have used </span><em class="italic"><span class="koboSpan" id="kobo.367.1">dependency inversion and injection</span></em><span class="koboSpan" id="kobo.368.1"> to isolate us from external systems. </span><span class="koboSpan" id="kobo.368.2">We’ve created test doubles and injected those. </span><span class="koboSpan" id="kobo.368.3">Now, we must create actual production code, the real adapter layer components that connect to the production systems. </span><span class="koboSpan" id="kobo.368.4">We inject those into our system during its initialization and configuration. </span><span class="koboSpan" id="kobo.368.5">This sets the code up to work </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">for real.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">End-to-end tests will then duplicate a </span><em class="italic"><span class="koboSpan" id="kobo.371.1">small amount</span></em><span class="koboSpan" id="kobo.372.1"> of happy path testing already covered by unit and integration tests. </span><span class="koboSpan" id="kobo.372.2">The purpose here is </span><em class="italic"><span class="koboSpan" id="kobo.373.1">not</span></em><span class="koboSpan" id="kobo.374.1"> to verify the behaviors that we have already tested. </span><span class="koboSpan" id="kobo.374.2">Instead, these tests verify that we have injected the correct production objects, by confirming that the system as a whole behaves correctly when connected to </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">production services.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">A user acceptance test builds on this idea by running through key test scenarios considered critical to accepting the software as complete. </span><span class="koboSpan" id="kobo.376.2">These will be end-to-end tests at a technical level. </span><span class="koboSpan" id="kobo.376.3">But their purpose is broader than the technical goal of ensuring our system is correctly configured. </span><span class="koboSpan" id="kobo.376.4">They are more of a legal contractual nature: </span><em class="italic"><span class="koboSpan" id="kobo.377.1">Have we built what was asked of us?</span></em><span class="koboSpan" id="kobo.378.1"> By using the iterative approach in this book together with its technical practices, there’s a higher</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.379.1"> chance that we will have</span><a id="_idIndexMarker558"/> <span class="No-Break"><span class="koboSpan" id="kobo.380.1">done so.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.381.1">Acceptance testing tools</span></h2>
<p><span class="koboSpan" id="kobo.382.1">Various testing libraries exist to help</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.383.1"> us write automated acceptance and end-to-end tests. </span><span class="koboSpan" id="kobo.383.2">Tasks such as connecting to a database or calling an HTTP web API are common to this kind of testing. </span><span class="koboSpan" id="kobo.383.3">We can leverage libraries for these tasks, instead of writing </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">code ourselves.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">The main differentiator among these tools is the way they interact with our software. </span><span class="koboSpan" id="kobo.385.2">Some are intended to simulate a user clicking a desktop GUI, or a browser-based web UI. </span><span class="koboSpan" id="kobo.385.3">Others will make HTTP calls to our software, exercising a </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">web endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">Here are a few popular acceptance testing tools </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">to consider:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.389.1">RestEasy</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.390.1">A popular</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.391.1"> tool for testing</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.392.1"> REST </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">APIs: </span></span><a href="https://resteasy.dev/"><span class="No-Break"><span class="koboSpan" id="kobo.394.1">https://resteasy.dev/</span></span></a></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.395.1">RestAssured</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.396.1">Another popular</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.397.1"> tool for testing REST APIs that takes a fluent approach</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.398.1"> to inspecting JSON </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">responses: </span></span><a href="https://rest-assured.io/"><span class="No-Break"><span class="koboSpan" id="kobo.400.1">https://rest-assured.io/</span></span></a></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.401.1">Selenium</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.402.1">A popular tool</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.403.1"> for testing web UIs through</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.404.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">browser: </span></span><a href="https://www.selenium.dev/"><span class="No-Break"><span class="koboSpan" id="kobo.406.1">https://www.selenium.dev/</span></span></a></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.407.1">Cucumber</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.408.1">Available from </span><a href="https://cucumber.io/"><span class="koboSpan" id="kobo.409.1">https://cucumber.io/</span></a><span class="koboSpan" id="kobo.410.1">. </span><span class="koboSpan" id="kobo.410.2">Cucumber allows English</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.411.1"> language-like descriptions</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.412.1"> of tests to be written by domain experts. </span><span class="koboSpan" id="kobo.412.2">At least, that’s the theory. </span><span class="koboSpan" id="kobo.412.3">I’ve never seen anybody other than a developer write Cucumber tests in any project I’ve been </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">part of.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">Acceptance tests form the final piece of the test pyramid and allow our application to be tested under conditions that resemble the production environment. </span><span class="koboSpan" id="kobo.414.2">All that is needed is a way to automate</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.415.1"> running all those layers of testing. </span><span class="koboSpan" id="kobo.415.2">That’s where CI/CD pipelines come in, and they are the subject of the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">next section.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.417.1">CI/CD pipelines and test environments</span></h1>
<p><span class="koboSpan" id="kobo.418.1">CI/CD pipelines and test environments</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.419.1"> are an important</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.420.1"> part of software engineering. </span><span class="koboSpan" id="kobo.420.2">They are a part of the development workflow that takes us from writing code to having systems in the hands of users. </span><span class="koboSpan" id="kobo.420.3">In this section, we’re going to look at what the terms mean and how we can use these ideas in </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">our projects.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.422.1">What is a CI/CD pipeline?</span></h2>
<p><span class="koboSpan" id="kobo.423.1">Let’s start with defining </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">the terms:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.425.1">CI stands for </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.426.1">continuous integration</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.427.1">Integration</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.428.1"> is where we take individual software components and join them together to make a whole. </span><span class="koboSpan" id="kobo.428.2">CI means we do this all the time as we write </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">new code.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.430.1">CD stands for either </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">continuous delivery</span></strong><span class="koboSpan" id="kobo.432.1"> or </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.433.1">continuous deployment</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.434.1">We’ll cover the difference</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.435.1"> later, but in both cases, the idea is that</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.436.1"> we are taking the latest and greatest version of our integrated software and delivering it to a stakeholder. </span><span class="koboSpan" id="kobo.436.2">The goal of continuous delivery is that we could – if we wanted to – deploy every single code change to production with a single click of </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">a button.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">It’s important to note that CI/CD is an engineering </span><em class="italic"><span class="koboSpan" id="kobo.439.1">discipline</span></em><span class="koboSpan" id="kobo.440.1"> – not a set of tools. </span><span class="koboSpan" id="kobo.440.2">However we achieve it, CI/CD has the goal of growing a single system that is always in a </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">usable state.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.442.1">Why do we need continuous integration?</span></h2>
<p><span class="koboSpan" id="kobo.443.1">In terms of the test pyramid, the reason</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.444.1"> we need CI/CD is to pull all the testing together. </span><span class="koboSpan" id="kobo.444.2">We need a mechanism to build the whole of our software, using the latest code. </span><span class="koboSpan" id="kobo.444.3">We need to run all the tests and ensure they all pass before we can package and deploy the code. </span><span class="koboSpan" id="kobo.444.4">If any tests fail, we know the code is not suitable for deployment. </span><span class="koboSpan" id="kobo.444.5">To ensure we get fast feedback, we must run the tests in order of fastest to slowest. </span><span class="koboSpan" id="kobo.444.6">Our CI pipeline will run unit tests first, followed by integration tests, followed by end-to-end and acceptance tests. </span><span class="koboSpan" id="kobo.444.7">If any tests fail, the build will produce a report of test failures for that stage, then stop the build. </span><span class="koboSpan" id="kobo.444.8">If all the tests pass, we package our code up ready </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">for deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">More generally, the idea of </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">integration</span></strong><span class="koboSpan" id="kobo.448.1"> is fundamental to building software, whether we work alone or in a development team. </span><span class="koboSpan" id="kobo.448.2">When working alone, following the practices in this book, we’re building software out of several building blocks. </span><span class="koboSpan" id="kobo.448.3">Some we have made ourselves, while for others, we’ve selected a suitable library component and used that. </span><span class="koboSpan" id="kobo.448.4">We’ve also written adapters – components that allow us to access external systems. </span><span class="koboSpan" id="kobo.448.5">All of that needs integrating – bringing together as a whole – to turn our lines of code into a </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">working system.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">When working in a team, integration is even more important. </span><span class="koboSpan" id="kobo.450.2">We need to not only bring together the pieces we have written but also all the other pieces written by the rest of our team. </span><span class="koboSpan" id="kobo.450.3">Integrating work in progress from colleagues is urgent. </span><span class="koboSpan" id="kobo.450.4">We end up building on what others have already written. </span><span class="koboSpan" id="kobo.450.5">As we work outside of the main integrated code base, there is a risk of not including the latest design decisions and pieces of </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">reusable code.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">The following figure</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.453.1"> shows the goal </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">of CI:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.455.1"><img alt="Figure 10.7 – Continuous integration" src="image/Figure_10.7_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.456.1">Figure 10.7 – Continuous integration</span></p>
<p><span class="koboSpan" id="kobo.457.1">The motivation behind CI was to avoid the classic waterfall development trap, where a team wrote code as isolated individuals while following a plan and only integrated it at the end. </span><span class="koboSpan" id="kobo.457.2">Many times, that integration failed to produce working software. </span><span class="koboSpan" id="kobo.457.3">There was often some misunderstanding or missing piece that meant components did not fit together. </span><span class="koboSpan" id="kobo.457.4">At this late stage of a waterfall project, mistakes are expensive </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">to fix.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">It’s not just big teams</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.460.1"> and big projects that suffer from this. </span><span class="koboSpan" id="kobo.460.2">My turning point was while writing a flight simulator game for Britain’s RAF Red Arrows display team. </span><span class="koboSpan" id="kobo.460.3">Two of us worked on that game to a common API we had agreed on. </span><span class="koboSpan" id="kobo.460.4">When we first attempted to integrate our parts – at 03:00 A.M., in front of the company managing director, of course – the game ran for about three frames and then crashed. </span><span class="koboSpan" id="kobo.460.5">Oops! </span><span class="koboSpan" id="kobo.460.6">Our lack of CI provided an embarrassing lesson. </span><span class="koboSpan" id="kobo.460.7">It would have been good to know that was going to happen a lot earlier, especially without the managing </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">director watching.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.462.1">Why do we need continuous delivery?</span></h2>
<p><span class="koboSpan" id="kobo.463.1">If CI is all about keeping our software</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.464.1"> components together as an ever-growing whole, then CD is about getting that whole into the hands of people who care about it. </span><span class="koboSpan" id="kobo.464.2">The following figure </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">illustrates CD:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.466.1"><img alt="Figure 10.8 – Continuous delivery" src="image/Figure_10.8_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.467.1">Figure 10.8 – Continuous delivery</span></p>
<p><span class="koboSpan" id="kobo.468.1">Delivering a stream of value to end users is a core tenet of agile development. </span><span class="koboSpan" id="kobo.468.2">No matter which flavor</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.469.1"> of agile methodology you use, getting features into the hands of users has always been the goal. </span><span class="koboSpan" id="kobo.469.2">We want to deliver usable features at regular, short intervals. </span><span class="koboSpan" id="kobo.469.3">Doing</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.470.1"> this provides </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">three benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.472.1">Users get the value </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.473.1">they want</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.474.1">End users don’t care about our development process. </span><span class="koboSpan" id="kobo.474.2">They only care about getting solutions to their problems. </span><span class="koboSpan" id="kobo.474.3">Whether that’s the problem of being entertained while waiting for an Uber ride, or the problem of paying everyone’s wages in a multinational business, our user just wants their problem gone. </span><span class="koboSpan" id="kobo.474.4">Getting valuable features to our users becomes a </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">competitive advantage.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.476.1">We gain valuable </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.477.1">user feedback</span></strong></span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.478.1">Yes, that’s what I asked for – but it isn’t what I meant!</span></em><span class="koboSpan" id="kobo.479.1"> That is extremely valuable user feedback that agile approaches deliver. </span><span class="koboSpan" id="kobo.479.2">Once an end user sees the feature as we have implemented it, sometimes, it becomes clear that it isn’t quite solving their problem. </span><span class="koboSpan" id="kobo.479.3">We can correct </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">this quickly.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.481.1">Aligns the code base and </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.482.1">development team</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.483.1">To pull off this feat, you do need to have your team and workflows together. </span><span class="koboSpan" id="kobo.483.2">You can’t effectively do this unless your workflow results in known working software being</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.484.1"> continuously available as a </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">single whole.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.486.1">Continuous delivery or continuous deployment?</span></h2>
<p><span class="koboSpan" id="kobo.487.1">Exact definitions of these terms seem to vary, but we can think of them </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">like this:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.489.1">Continuous delivery</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.490.1">We deliver software</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.491.1"> to internal stakeholders, such as product owners and </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">QA engineers</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.493.1">Continuous deployment</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.494.1">We deliver software</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.495.1"> into production and to </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">end users</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">Out of the two, continuous </span><em class="italic"><span class="koboSpan" id="kobo.498.1">deployment</span></em><span class="koboSpan" id="kobo.499.1"> sets a much higher bar. </span><span class="koboSpan" id="kobo.499.2">It requires that once we integrate code into our pipeline, that code is ready to go live – into production, to real users. </span><span class="koboSpan" id="kobo.499.3">This is, of course, hard. </span><span class="koboSpan" id="kobo.499.4">It needs top-class test automation to give us confidence that our code is ready to deploy. </span><span class="koboSpan" id="kobo.499.5">It also benefits from having a fast rollback system in production – some means of quickly reverting a deployment if we discover a defect not covered by our tests. </span><span class="koboSpan" id="kobo.499.6">Continuous deployment is the ultimate workflow. </span><span class="koboSpan" id="kobo.499.7">For all who achieve it, deploying new code last thing on Friday simply holds no fear. </span><span class="koboSpan" id="kobo.499.8">Well, maybe a little </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">less fear.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.501.1">Practical CI/CD pipelines</span></h2>
<p><span class="koboSpan" id="kobo.502.1">Most projects use a CI tool to handle</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.503.1"> the sequencing chores. </span><span class="koboSpan" id="kobo.503.2">Popular tools are provided by Jenkins, GitLab, CircleCI, Travis CI, and Azure DevOps. </span><span class="koboSpan" id="kobo.503.3">They all work similarly, executing separate build stages sequentially. </span><span class="koboSpan" id="kobo.503.4">That’s where the name pipeline comes from – it resembles a pipe being loaded at one end with the next build stage and coming out of the other end of the pipe, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.505.1"><img alt="Figure 10.9 – Stages in a CI pipeline" src="image/Figure_10.9_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.506.1">Figure 10.9 – Stages in a CI pipeline</span></p>
<p><span class="koboSpan" id="kobo.507.1">A CI pipeline comprises</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.508.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">following steps:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.510.1">Source control</span></strong><span class="koboSpan" id="kobo.511.1">: Having a common location in which to store the code is essential to CI/CD. </span><span class="koboSpan" id="kobo.511.2">It is the place where code gets integrated. </span><span class="koboSpan" id="kobo.511.3">The pipeline starts here, by pulling down the latest version of the source code and performing a clean build. </span><span class="koboSpan" id="kobo.511.4">This prevents errors caused by older versions of code being present on </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">the computer.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.513.1">Build</span></strong><span class="koboSpan" id="kobo.514.1">: In this step, we run a build script to download all the required libraries, compile all the code, and link it together. </span><span class="koboSpan" id="kobo.514.2">The output is something that can be executed, typically a single Java archive </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">.jar</span></strong><span class="koboSpan" id="kobo.516.1"> file, to run on </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">the JVM.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.518.1">Static code analysis</span></strong><span class="koboSpan" id="kobo.519.1">: Linters and other analysis tools check the source code for stylistic violations, such as variable length and naming conventions. </span><span class="koboSpan" id="kobo.519.2">The development team can choose to fail the build when specific code issues are detected by </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">static analysis.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.521.1">Unit tests</span></strong><span class="koboSpan" id="kobo.522.1">: All the unit tests are run against the built code. </span><span class="koboSpan" id="kobo.522.2">If any fail, the pipeline stops. </span><span class="koboSpan" id="kobo.522.3">Test failure messages </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">are reported.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.524.1">Integration tests</span></strong><span class="koboSpan" id="kobo.525.1">: All integration tests are run against the built code. </span><span class="koboSpan" id="kobo.525.2">If any fail, the pipeline is stopped and error messages </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">are reported.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.527.1">Acceptance tests</span></strong><span class="koboSpan" id="kobo.528.1">: All acceptance tests are run against the built code. </span><span class="koboSpan" id="kobo.528.2">If all tests pass, the code is considered to be working and ready </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">for delivery/deployment.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.530.1">Delivery packaging</span></strong><span class="koboSpan" id="kobo.531.1">: The code is packaged up into a suitable form for delivery. </span><span class="koboSpan" id="kobo.531.2">For Java web</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.532.1"> services, this may well be a single Java archive </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">.jar</span></strong><span class="koboSpan" id="kobo.534.1"> file containing an embedded </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">web server.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.536.1">What happens next depends on the needs of the project. </span><span class="koboSpan" id="kobo.536.2">The packaged code may be deployed to production automatically or it may simply be placed in some internal repository, for access by product owners and QA engineers. </span><span class="koboSpan" id="kobo.536.3">Formal deployment would then happen later, after </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">quality gatekeeping.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.538.1">Test environments</span></h2>
<p><span class="koboSpan" id="kobo.539.1">One obvious problem</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.540.1"> caused by needing a CI pipeline to run integration tests is having a place to run those tests. </span><span class="koboSpan" id="kobo.540.2">Ordinarily, in production, our application integrates with external systems such as databases and payment providers. </span><span class="koboSpan" id="kobo.540.3">When we run our CI pipeline, we do not want our code to process payments or write to production databases. </span><span class="koboSpan" id="kobo.540.4">Yet we </span><em class="italic"><span class="koboSpan" id="kobo.541.1">do</span></em><span class="koboSpan" id="kobo.542.1"> want to test that the code </span><em class="italic"><span class="koboSpan" id="kobo.543.1">could</span></em><span class="koboSpan" id="kobo.544.1"> integrate with those things, once we configure it to connect to those </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">real systems.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">The solution is to create a </span><strong class="bold"><span class="koboSpan" id="kobo.547.1">test environment</span></strong><span class="koboSpan" id="kobo.548.1">. </span><span class="koboSpan" id="kobo.548.2">These are collections of databases and simulated external systems that lie under our control. </span><span class="koboSpan" id="kobo.548.3">If our code needs to integrate with a database of user details, we can create a copy of that user database and run it locally. </span><span class="koboSpan" id="kobo.548.4">During testing, we can arrange for our code to connect to this local database, instead of the production version. </span><span class="koboSpan" id="kobo.548.5">External payment providers often provide a sandbox API. </span><span class="koboSpan" id="kobo.548.6">This is a version of their service that, again, does not connect to any of their real customers. </span><span class="koboSpan" id="kobo.548.7">It features simulated behavior for their service. </span><span class="koboSpan" id="kobo.548.8">In effect, it is an external </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">test double.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">This kind of setup is called a </span><strong class="bold"><span class="koboSpan" id="kobo.551.1">live-like</span></strong><span class="koboSpan" id="kobo.552.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">staging</span></strong><span class="koboSpan" id="kobo.554.1"> environment. </span><span class="koboSpan" id="kobo.554.2">It allows our code to be tested</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.555.1"> with more realistic</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.556.1"> integration. </span><span class="koboSpan" id="kobo.556.2">Our unit tests use stubs and mocks. </span><span class="koboSpan" id="kobo.556.3">Our integration tests can now use these richer </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">test environments.</span></span></p>
<h3><span class="koboSpan" id="kobo.558.1">Advantages and challenges of using test environments</span></h3>
<p><span class="koboSpan" id="kobo.559.1">Test environments offer both</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.560.1"> advantages and</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.561.1"> disadvantages, as summarized in the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">following table:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.563.1">Advantages</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.564.1">Challenges</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.565.1">The environment </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.566.1">is self-contained</span></strong></span></p>
<p><span class="koboSpan" id="kobo.567.1">We can create it and destroy it at will. </span><span class="koboSpan" id="kobo.567.2">It will not affect </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">production systems.</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.569.1">Not </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.570.1">production environments</span></strong></span></p>
<p><span class="koboSpan" id="kobo.571.1">No matter how live-like we make them, these environments are simulations. </span><span class="koboSpan" id="kobo.571.2">The risk is that our fake environments give us false positives – tests that pass only because they are using fake data. </span><span class="koboSpan" id="kobo.571.3">This can give us false confidence, leading us to deploy code that will fail </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">The real test happens when we set our code </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">live. </span><span class="koboSpan" id="kobo.574.2">Always.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.575.1">More realistic </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.576.1">than stubs</span></strong></span></p>
<p><span class="koboSpan" id="kobo.577.1">The environment gets us one step closer to testing under production loads </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">and conditions.</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.579.1">Extra effort to create </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.580.1">and maintain</span></strong></span></p>
<p><span class="koboSpan" id="kobo.581.1">More development work is needed to set these environments up and keep them in step with the </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">test code.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.583.1">Check assumptions about </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.584.1">external systems</span></strong></span></p>
<p><span class="koboSpan" id="kobo.585.1">Third-party sandbox environments allow us to confirm that our code uses the latest, correct API, as published by </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">the supplier.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.587.1">Privacy concerns</span></strong></span></p>
<p><span class="koboSpan" id="kobo.588.1">Simply copying over a chunk of production data isn’t good enough for a test environment. </span><span class="koboSpan" id="kobo.588.2">If that data contains </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">personally identifiable information</span></strong><span class="koboSpan" id="kobo.590.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.591.1">PII</span></strong><span class="koboSpan" id="kobo.592.1">) as defined by GDPR or HIPAA, then we can’t legally use it directly. </span><span class="koboSpan" id="kobo.592.2">We have to create an extra step to anonymize that data or generate pseudo-realistic random test data. </span><span class="koboSpan" id="kobo.592.3">Neither </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">is trivial.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.594.1">Table 10.4 – Test environments advantages and challenges</span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.595.1">Testing in production</span></h2>
<p><span class="koboSpan" id="kobo.596.1">I can hear the gasps already! </span><span class="koboSpan" id="kobo.596.2">Running</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.597.1"> our tests in production is generally a terrible idea. </span><span class="koboSpan" id="kobo.597.2">Our tests might introduce fake orders that our production system treats as real ones. </span><span class="koboSpan" id="kobo.597.3">We may have to add test user accounts, which can present a security risk. </span><span class="koboSpan" id="kobo.597.4">Worse still, because we are in a testing phase, there is a very good chance that our code does not work yet. </span><span class="koboSpan" id="kobo.597.5">This can cause all sorts of problems – all while connected to </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">production systems.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">Despite these concerns, sometimes, things must be tested in production. </span><span class="koboSpan" id="kobo.599.2">Big data companies such as Google and Meta both have things that can only be tested live due to the sheer scale of their data. </span><span class="koboSpan" id="kobo.599.3">There is no way a meaningful live-like test environment can be created; it will simply be too small. </span><span class="koboSpan" id="kobo.599.4">What can we do in cases </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">like this?</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">The approach is to mitigate the risks. </span><span class="koboSpan" id="kobo.601.2">Two techniques are valuable here: blue-green deployment and </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">traffic partitioning.</span></span></p>
<h3><span class="koboSpan" id="kobo.603.1">Blue-green deployment</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.604.1">Blue-green deployment</span></strong><span class="koboSpan" id="kobo.605.1"> is a deployment technique designed</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.606.1"> for the rapid rollback of failed deployments. </span><span class="koboSpan" id="kobo.606.2">It works by dividing the production servers into two groups. </span><span class="koboSpan" id="kobo.606.3">They are referred to as </span><em class="italic"><span class="koboSpan" id="kobo.607.1">blue</span></em><span class="koboSpan" id="kobo.608.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.609.1">green</span></em><span class="koboSpan" id="kobo.610.1">, chosen as they are neutral colors that both denote success. </span><span class="koboSpan" id="kobo.610.2">Our production code will be running on one group of servers at any one time. </span><span class="koboSpan" id="kobo.610.3">Let’s say we are currently running on the blue group. </span><span class="koboSpan" id="kobo.610.4">Our next deployment will then be to the green group. </span><span class="koboSpan" id="kobo.610.5">This is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.612.1"><img alt="Figure 10.10 – Blue-green deployment" src="image/Figure_10.10_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.613.1">Figure 10.10 – Blue-green deployment</span></p>
<p><span class="koboSpan" id="kobo.614.1">Once the code has been</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.615.1"> deployed to the green group, we switch over the production configuration to connect to green group servers. </span><span class="koboSpan" id="kobo.615.2">We retain the previous working production code on the blue servers. </span><span class="koboSpan" id="kobo.615.3">If our testing goes well against the green group, then we’re done. </span><span class="koboSpan" id="kobo.615.4">Production is now working with the latest green group code. </span><span class="koboSpan" id="kobo.615.5">If the testing fails, we revert that configuration to connect to the blue servers once again. </span><span class="koboSpan" id="kobo.615.6">It’s a fast rollback system that enables </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">our experimentation.</span></span></p>
<h3><span class="koboSpan" id="kobo.617.1">Traffic partitioning</span></h3>
<p><span class="koboSpan" id="kobo.618.1">In addition to blue-green</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.619.1"> deployment, we can limit the amount of traffic that we send to our test servers. </span><span class="koboSpan" id="kobo.619.2">Instead of flipping production to wholly use the new code under test, we can simply send a small percentage of user traffic there. </span><span class="koboSpan" id="kobo.619.3">So, 99% of users might be routed to our blue servers, which we know to work. </span><span class="koboSpan" id="kobo.619.4">1% can be routed to our new code under test in the green servers, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.621.1"><img alt="Figure 10.11 – Traffic partitioning" src="image/Figure_10.11_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.622.1">Figure 10.11 – Traffic partitioning</span></p>
<p><span class="koboSpan" id="kobo.623.1">If defects are discovered, only 1% of users will be affected before we revert to 100% blue servers. </span><span class="koboSpan" id="kobo.623.2">This gives us a rapid rollback, mitigating problems in production caused by a </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">failed deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.625.1">We’ve now covered the roles</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.626.1"> of different kinds of tests and seen how they fit into a coherent system known as the test pyramid. </span><span class="koboSpan" id="kobo.626.2">In the next section, we’ll apply some of this knowledge to our Wordz application by writing an </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">integration test.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.628.1">Wordz – integration test for our database</span></h1>
<p><span class="koboSpan" id="kobo.629.1">In this section, we’ll review an integration test</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.630.1"> for our Wordz application to get a feel for what they look like. </span><span class="koboSpan" id="kobo.630.2">We’ll cover the details of writing these tests and setting up the test tools in </span><a href="B18384_14.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.631.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.632.1">, </span><em class="italic"><span class="koboSpan" id="kobo.633.1">Driving the Database Layer</span></em><span class="koboSpan" id="kobo.634.1">, and </span><a href="B18384_15.xhtml#_idTextAnchor306"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.635.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.636.1">, </span><em class="italic"><span class="koboSpan" id="kobo.637.1">Driving the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.638.1">Web Layer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.640.1">Fetching a word from the database</span></h2>
<p><span class="koboSpan" id="kobo.641.1">As part of our earlier</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.642.1"> design work, we identified that Wordz</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.643.1"> would need a place to store the candidate words to be guessed. </span><span class="koboSpan" id="kobo.643.2">We defined an interface called </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">WordRepository</span></strong><span class="koboSpan" id="kobo.645.1"> to isolate us from the details of storage. </span><span class="koboSpan" id="kobo.645.2">At that iteration, we had only got as far as defining one method on </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">the interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.647.1">
public interface WordRepository {
String fetchWordByNumber( int wordNumber );
}</span></pre>
<p><span class="koboSpan" id="kobo.648.1">The implementation</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.649.1"> of this WordRepository interface</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.650.1"> will access the database and return a word given its </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">wordNumber</span></strong><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">We will defer implementing this to </span><a href="B18384_14.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.654.1">, </span><em class="italic"><span class="koboSpan" id="kobo.655.1">Driving the Database Layer</span></em><span class="koboSpan" id="kobo.656.1">. </span><span class="koboSpan" id="kobo.656.2">For now, let’s take an early look at what the integration test will look like, at a high level. </span><span class="koboSpan" id="kobo.656.3">The test uses open source libraries to help write the test, and to provide the database. </span><span class="koboSpan" id="kobo.656.4">We’ve chosen </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.658.1">An open source</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.659.1"> library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">database-rider</span></strong><span class="koboSpan" id="kobo.661.1"> (available from </span><a href="https://database-rider.github.io/getting-started/"><span class="koboSpan" id="kobo.662.1">https://database-rider.github.io/getting-started/</span></a><span class="koboSpan" id="kobo.663.1">) as a </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">test tool</span></span></li>
<li><span class="koboSpan" id="kobo.665.1">Postgres, a popular open source relational database, to store </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">our data</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.667.1">Here is the </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">test code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.669.1">
package com.wordz.adapters.db;
import com.github.database.rider.core.api.connection.ConnectionHolder;
import com.github.database.rider.core.api.dataset.DataSet;
import com.github.database.rider.junit5.api.DBRider;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.postgresql.ds.PGSimpleDataSource;
import javax.sql.DataSource;
import static org.assertj.core.api.Assertions.assertThat;
</span><strong class="bold"><span class="koboSpan" id="kobo.670.1">@DBRider</span></strong><span class="koboSpan" id="kobo.671.1">
public class WordRepositoryPostgresTest {
    private </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">DataSource</span></strong><span class="koboSpan" id="kobo.673.1"> dataSource;
    @BeforeEach
    void beforeEachTest() {
        var ds = new PGSimpleDataSource();
        ds.setServerNames(new String[]{"localhost"});
        ds.setDatabaseName("wordzdb");
        ds.setUser("ciuser");
        ds.setPassword("cipassword");
        this.dataSource = ds;
    }
    private final ConnectionHolder connectionHolder = () -&gt;
        dataSource.getConnection();
    @Test
    </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">@DataSet</span></strong><span class="koboSpan" id="kobo.675.1">("adapters/data/wordTable.json")
    public void fetchesWord()  {
        var adapter = new WordRepositoryPostgres(dataSource);
        String actual = adapter.fetchWordByNumber(27);
        assertThat(actual).isEqualTo("ARISE");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.676.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">fetchesWord()</span></strong><span class="koboSpan" id="kobo.678.1"> test method is marked</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.679.1"> by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">@DataSet</span></strong><span class="koboSpan" id="kobo.681.1"> annotation. </span><span class="koboSpan" id="kobo.681.2">This annotation</span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.682.1"> is provided by the </span><em class="italic"><span class="koboSpan" id="kobo.683.1">database-rider</span></em><span class="koboSpan" id="kobo.684.1"> test framework and it forms the Arrange step of our test. </span><span class="koboSpan" id="kobo.684.2">It specifies a file of known test data that the framework will load into the database before the test runs. </span><span class="koboSpan" id="kobo.684.3">The data file is located underneath the root folder of </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">src/test/resources</span></strong><span class="koboSpan" id="kobo.686.1">. </span><span class="koboSpan" id="kobo.686.2">The parameter in the annotation gives the rest of the path. </span><span class="koboSpan" id="kobo.686.3">In our case, the file will be located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">src/test/resources/adapters/data/wordTable.json</span></strong><span class="koboSpan" id="kobo.688.1">. </span><span class="koboSpan" id="kobo.688.2">Its content looks </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
{
  "WORD": [
    {
      "id": 1,
      "number": 27,
      "text": "ARISE"
    }
  ]
}</span></pre>
<p><span class="koboSpan" id="kobo.691.1">This JSON file tells the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">database-rider</span></strong><span class="koboSpan" id="kobo.693.1"> framework that we would like to insert a single row into a database table named </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">WORD</span></strong><span class="koboSpan" id="kobo.695.1">, with column values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">1</span></strong><span class="koboSpan" id="kobo.697.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">27</span></strong><span class="koboSpan" id="kobo.699.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">ARISE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">We’re not going to write the adapter code to make this test pass just yet. </span><span class="koboSpan" id="kobo.703.2">There are several steps we would need to take to get this test to compile, including downloading various libraries and getting the Postgres database up and running. </span><span class="koboSpan" id="kobo.703.3">We’ll cover these steps in detail in </span><a href="B18384_14.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.704.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.705.1">, </span><em class="italic"><span class="koboSpan" id="kobo.706.1">Driving the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.707.1">Database Layer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">The overview of this integration test code is that it is testing a new class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">WordRepositoryPostgres</span></strong><span class="koboSpan" id="kobo.711.1"> that we will write. </span><span class="koboSpan" id="kobo.711.2">That class will contain the database access code. </span><span class="koboSpan" id="kobo.711.3">We can see the tell-tale JDBC object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">javax.sql.DataSource</span></strong><span class="koboSpan" id="kobo.713.1">, which represents a database instance. </span><span class="koboSpan" id="kobo.713.2">This is the clue that we are testing integration with a database. </span><span class="koboSpan" id="kobo.713.3">We can see new annotations from the database testing library: </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">@DBRider</span></strong><span class="koboSpan" id="kobo.715.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">@DataSet</span></strong><span class="koboSpan" id="kobo.717.1">. </span><span class="koboSpan" id="kobo.717.2">Finally, we can see something instantly recognizable – the Arrange, Act, and Assert steps of </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">a test:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.719.1">The Arrange step creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">WordRepositoryPostgres</span></strong><span class="koboSpan" id="kobo.721.1"> object, which will contain our database code. </span><span class="koboSpan" id="kobo.721.2">It works with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">database-rider</span></strong><span class="koboSpan" id="kobo.723.1"> library’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">@DataSet</span></strong><span class="koboSpan" id="kobo.725.1"> annotation to put some known data into the database before the </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">test runs.</span></span></li>
<li><span class="koboSpan" id="kobo.727.1">The Act step calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">fetchWordByNumber()</span></strong><span class="koboSpan" id="kobo.729.1"> method, passing in the numeric </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">wordNumber</span></strong><span class="koboSpan" id="kobo.731.1"> we want to test. </span><span class="koboSpan" id="kobo.731.2">This number aligns with the contents of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">wordTable.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.733.1"> file.</span></span></li>
<li><span class="koboSpan" id="kobo.734.1">The Assert step confirms the expected word, </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">ARISE</span></strong><span class="koboSpan" id="kobo.736.1">, is returned from </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">the database.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.738.1">As we can see, integration</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.739.1"> tests aren’t so different</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.740.1"> from unit tests </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">in essence.</span></span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.742.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.743.1">In this chapter, we’ve seen how the test pyramid is a system that organizes our testing efforts, keeping FIRST unit tests firmly as the foundation for all we do, but not neglecting other testing concerns. </span><span class="koboSpan" id="kobo.743.2">First, we introduced the ideas of integration and acceptance testing as ways of testing more of our system. </span><span class="koboSpan" id="kobo.743.3">Then, we looked at how the techniques of CI and CD keep our software components brought together and ready to release at frequent intervals. </span><span class="koboSpan" id="kobo.743.4">We’ve seen how to bring the whole build process together using CI pipelines, possibly going on to CD. </span><span class="koboSpan" id="kobo.743.5">We’ve made a little progress on Wordz by writing an integration test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">WordRepositoryPostgres</span></strong><span class="koboSpan" id="kobo.745.1"> adapter, setting us up to write the database </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">code itself.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">In the next chapter, we’ll take a look at the role of manual testing in our projects. </span><span class="koboSpan" id="kobo.747.2">It’s clear by now that we automate as much testing as we can, meaning that the role of manual testing no longer means following huge test plans. </span><span class="koboSpan" id="kobo.747.3">Yet, manual testing is still very valuable. </span><span class="koboSpan" id="kobo.747.4">How has the role changed? </span><span class="koboSpan" id="kobo.747.5">We’ll review </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">that next.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.749.1">Questions and answers</span></h1>
<p><span class="koboSpan" id="kobo.750.1">The following are some questions and their answers regarding this </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">chapter’s material:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.752.1">Why is the test pyramid represented as a </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">pyramid shape?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.754.1">The shape depicts a broad foundation of many unit tests. </span><span class="koboSpan" id="kobo.754.2">It shows layers of testing above that exercise a closer approximation to the final, integrated system. </span><span class="koboSpan" id="kobo.754.3">It also shows that we expect fewer tests at those higher levels </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">of integration.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.756.1">What are the trade-offs between unit, integration, and </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">acceptance tests?</span></span><ul><li><span class="koboSpan" id="kobo.758.1">Unit tests: Fast, repeatable. </span><span class="koboSpan" id="kobo.758.2">Don’t test connections to </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">external systems.</span></span></li><li><span class="koboSpan" id="kobo.760.1">Integration tests: Slower, sometimes unrepeatable. </span><span class="koboSpan" id="kobo.760.2">They test the connection to the </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">external system.</span></span></li><li><span class="koboSpan" id="kobo.762.1">Acceptance tests: Slowest of all. </span><span class="koboSpan" id="kobo.762.2">They can be flaky but offer the most comprehensive tests of the </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">whole system.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.764.1">Does the test pyramid </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">guarantee correctness?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.766.1">No. </span><span class="koboSpan" id="kobo.766.2">Testing can only ever reveal the presence of a defect, </span><em class="italic"><span class="koboSpan" id="kobo.767.1">never</span></em><span class="koboSpan" id="kobo.768.1"> the absence of one. </span><span class="koboSpan" id="kobo.768.2">The value of extensive testing is in how many defects we avoid putting </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">into production.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.770.1">Does the test pyramid only apply to </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">object-oriented programming?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.772.1">No. </span><span class="koboSpan" id="kobo.772.2">This strategy of test coverage applies to any programming paradigm. </span><span class="koboSpan" id="kobo.772.3">We can write code using any paradigm - object-oriented, functional, procedural, or declarative. </span><span class="koboSpan" id="kobo.772.4">The various kinds of tests only depend on whether our code accesses external systems or makes up purely </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">internal components.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.774.1">Why don’t we prefer end-to-end tests, given they test the </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">whole system?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.776.1">End-to-end tests run slowly. </span><span class="koboSpan" id="kobo.776.2">They depend directly on having either production databases and web services running, or a test environment running containing test versions of those things. </span><span class="koboSpan" id="kobo.776.3">The network connections required, and things such as database setup, can result in tests giving us false negative results. </span><span class="koboSpan" id="kobo.776.4">They fail because of the environment, not because the code was incorrect. </span><span class="koboSpan" id="kobo.776.5">Because of these reasons, we engineer our system to make maximum use of fast, repeatable </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">unit tests.</span></span></p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.778.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.779.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">following resources:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.781.1">Introduction to consumer-driven </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.782.1">contract testing</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.783.1">Pact.io produce a popular open source contract testing tool that’s available on their website, </span><a href="https://docs.pact.io"><span class="koboSpan" id="kobo.784.1">https://docs.pact.io</span></a><span class="koboSpan" id="kobo.785.1">. </span><span class="koboSpan" id="kobo.785.2">The website features an explanatory video and a useful introduction to the benefits of </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">contract-driven testing.</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.787.1">Database-rider database </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.788.1">testing library</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.789.1">An open source database integration testing library that works with JUnit5. </span><span class="koboSpan" id="kobo.789.2">It is available </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">from </span></span><a href="https://database-rider.github.io/getting-started/"><span class="No-Break"><span class="koboSpan" id="kobo.791.1">https://database-rider.github.io/getting-started/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.792.1">.</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.793.1">Modern Software Engineering, Dave Farley, </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.794.1">ISBN 978-0137314911</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.795.1">This book explains in detail the reasons behind CD and various technical practices such as trunk-based development to help us achieve that. </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">Highly recommended.</span></span></p>
<ul>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.797.1">Minimum CD</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.798.1">Details on what is needed for </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">CD: </span></span><a href="https://minimumcd.org/minimumcd/"><span class="No-Break"><span class="koboSpan" id="kobo.800.1">https://minimumcd.org/minimumcd/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.801.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer081">
</div>
</div>
</body></html>