- en: Chapter 6. Reactive Data Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 反应式数据流
- en: In particular circumstances, our application may be required to handle huge
    file uploads. This can be done by putting all of these in the memory, by creating
    a temporary file, or by acting directly on the stream. Out of these three, the
    last option works the best for us, as it removes I/O stream limitations (such
    as blocking, memory, and threads) and also eliminates the need to buffer (that
    is, acting on input at the rate needed).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定情况下，我们的应用程序可能需要处理大量文件上传。这可以通过将这些全部放入内存中、创建一个临时文件或直接在流上操作来实现。在这三种方法中，最后一种对我们来说效果最好，因为它消除了I/O流限制（如阻塞、内存和线程），并且消除了缓冲的需要（即在所需的速率上对输入进行操作）。
- en: 'Handling huge file uploads belongs to the set of unavoidable operations that
    can be heavy on resources. Some other tasks that belong to the same category are
    processing real-time data for monitoring, analysis, bulk data transfers, and processing
    large datasets. In this chapter, we will discuss the Iteratee approach used to
    handle such situations. This chapter covers the basics of handling data streams
    with a brief explanation of the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大量文件上传属于不可避免的操作集合，这些操作可能会对资源造成很大压力。属于同一类别的其他任务包括处理实时数据以进行监控、分析、批量数据传输以及处理大型数据集。在本章中，我们将讨论用于处理此类情况的Iteratee方法。本章涵盖了使用以下主题的简要说明来处理数据流的基础：
- en: Iteratees
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iteratees
- en: Enumerators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举器
- en: Enumeratees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enumeratees
- en: This chapter may seem intense at times but the topics discussed here will be
    helpful for some of the following chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在某些时候可能看起来很紧张，但这里讨论的主题将对以下章节有所帮助。
- en: Basics of handling data streams
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流处理基础
- en: 'Consider that we connected a mobile device (such as a tablet, phone, MP3 player,
    and so on) to its charger and plugged it in. The consequences of this can be as
    follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将一个移动设备（如平板电脑、手机、MP3播放器等）连接到其充电器并插入。这可能导致以下后果：
- en: The device's battery starts charging and continues to do so until the occurrence
    of one of the other options
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备的电池开始充电，并持续充电，直到发生其他选项之一
- en: The device's battery is completely charged and minimal power is drawn by the
    device to continue running
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备的电池完全充电，并且设备为了继续运行而消耗的最小电力
- en: The device's battery can not be charged due to malfunctioning of the device
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于设备故障，设备的电池无法充电
- en: Here, the power supply is the source, the device is the sink, while the charger
    is the channel that enables transfer of energy from the source to the sink. The
    processing or task performed by the device is that of charging its battery.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，电源是源，设备是汇，而充电器是使能量从源传输到汇的通道。设备执行的处理或任务是为其电池充电。
- en: Well, this covers most of the Iteratee approach without any of the usual jargon.
    Simply put, the power supply represents a data source, the charger acts as the
    Enumerator, and the device as the Iteratee.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这涵盖了Iteratee方法的大部分内容，没有使用任何通常的术语。简单来说，电源代表数据源，充电器充当Enumerator，而设备充当Iteratee。
- en: Oops, we missed the Enumeratee! Suppose that the energy from a regular power
    supply is not compatible with the device; then, in this case, the charger generally
    has an internal component that performs this transformation. For example, converting
    from A.C. (alternating current) to D.C. (direct current). In such cases, the charger
    can be considered a combination of the Enumerator and the Enumeratee. The component
    that collects energy from the power supply acts like the Enumerator, and the other
    component that transforms the energy is similar to an Enumeratee.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们错过了Enumeratee！假设常规电源的能量与设备不兼容；在这种情况下，充电器通常有一个内部组件执行这种转换。例如，将交流电（A.C.）转换为直流电（D.C.）。在这种情况下，充电器可以被认为是Enumerator和Enumeratee的组合。从电源收集能量的组件类似于Enumerator，而转换能量的另一个组件类似于Enumeratee。
- en: '![Basics of handling data streams](img/3803OS_06_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![数据流处理基础](img/3803OS_06_01.jpg)'
- en: The concept of Iteratee, Enumerator, and Enumeratee originated from the Haskell
    library Iteratee I/O, which was developed by Oleg Kiselyov to overcome the problems
    faced with lazy I/O.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Iteratee、Enumerator和Enumeratee的概念起源于Haskell库Iteratee I/O，该库由Oleg Kiselyov开发，旨在克服懒I/O所面临的问题。
- en: 'In Oleg''s words, as seen on [http://okmij.org/ftp/Streams.html](http://okmij.org/ftp/Streams.html):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如Oleg在其[http://okmij.org/ftp/Streams.html](http://okmij.org/ftp/Streams.html)上的话所说：
- en: '*Enumerator is an encapsulation of a data source, a stream producer—what folds
    an iteratee over the stream. An enumerator takes an iteratee and applies it to
    the stream data as they are being produced, until the source is depleted or the
    iteratee said it had enough. After disposing of buffers and other source-draining
    resources, enumerator returns the final value of the iteratee. Enumerator thus
    is an iteratee transformer.*'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Enumerator 是数据源的一个封装，一个流生产者——它将 iteratee 应用于流。Enumerator 接收一个 iteratee 并将其应用于正在产生的流数据，直到源耗尽或
    iteratee 表示它已经足够。在处理完缓冲区和其他源排空资源后，enumerator 返回 iteratee 的最终值。因此，Enumerator 是一个
    iteratee 转换器。*'
- en: 'Iteratees are stream consumers and an Iteratee can be in one of the following
    states:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Iteratees 是流消费者，一个 Iteratee 可以处于以下状态之一：
- en: '*Completed or done*: The Iteratee has completed processing'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完成或完成*：Iteratee 已完成处理'
- en: '*Continuing*: The current element has been processed but the Iteratee is not
    done yet and can accept the next element'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*继续*：当前元素已被处理，但 Iteratee 还未完成，可以接受下一个元素'
- en: '*Error*: The Iteratee has encountered an error'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*：Iteratee 遇到了错误'
- en: '*Enumeratee is both a consumer and a producer, incrementally decoding the outer
    stream and producing the nested stream of decoded data.*'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Enumeratee 既是消费者又是生产者，它逐步解码外部流并产生解码数据的嵌套流。*'
- en: Although the enumerator knows how to get to the next element, it is completely
    unaware of the processing the Iteratee will perform on this element and vice versa.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然枚举器知道如何获取下一个元素，但它对 Iteratee 将要对该元素执行的处理一无所知，反之亦然。
- en: Different libraries implement the Iteratee, Enumerator, and Enumeratee differently,
    based on these definitions. In the following sections, we will see how these are
    implemented in Play Framework and how we can use them in our application. Let's
    start with the Iteratee, as the Enumerator requires a one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的库根据这些定义以不同的方式实现 Iteratee、Enumerator 和 Enumeratee。在接下来的章节中，我们将看到它们在 Play Framework
    中的实现方式以及如何在我们的应用程序中使用它们。让我们从 Iteratee 开始，因为 Enumerator 需要一个 Iteratee。
- en: Iteratees
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iteratees
- en: 'Iteratee is defined as a trait, `Iteratee[E, +A]`, where E is the input type
    and A is the result type. The state of an Iteratee is represented by an instance
    of `Step`, which is defined as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Iteratee 被定义为 trait，`Iteratee[E, +A]`，其中 E 是输入类型，A 是结果类型。Iteratee 的状态由 `Step`
    的一个实例表示，它被定义为如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The input used here represents an element of the data stream, which can be
    empty, an element, or an end of file indicator. Therefore, `Input` is defined
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的输入代表数据流中的一个元素，它可以是一个空元素、一个元素或文件结束指示符。因此，`Input` 被定义为如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An Iteratee is an immutable data type and each result of processing an input
    is a new Iteratee with a new state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Iteratee 是一个不可变的数据类型，处理输入的每个结果都是一个具有新状态的新的 Iteratee。
- en: 'To handle the possible states of an Iteratee, there is a predefined helper
    object for each state. They are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 Iteratee 的可能状态时，为每个状态都有一个预定义的辅助对象。它们是：
- en: Cont
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cont
- en: Done
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成
- en: Error
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Let''s see the definition of the `readLine` method, which utilizes these objects:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `readLine` 方法的定义，它利用了这些对象：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `readLine` method is responsible for reading a line and returning an Iteratee.
    As long as there are more bytes to be read, the `readLine` method is called recursively.
    On completing the process, an Iteratee with a completed state (Done) is returned,
    else an Iteratee with state continuous (Cont) is returned. In case the method
    encounters EOF, an Iteratee with state Error is returned.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`readLine` 方法负责读取一行并返回一个 Iteratee。只要还有更多字节要读取，就会递归调用 `readLine` 方法。在完成处理后，返回一个具有完成状态（Done）的
    Iteratee，否则返回一个具有连续状态（Cont）的 Iteratee。如果方法遇到 EOF，则返回一个具有错误状态（Error）的 Iteratee。'
- en: In addition to these, Play Framework exposes a companion Iteratee object, which
    has helper methods to deal with Iteratees. The API exposed through the Iteratee
    object is documented at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Iteratee$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Iteratee$).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Play Framework 还公开了一个配套的 Iteratee 对象，它提供了处理 Iteratee 的辅助方法。通过 Iteratee 对象公开的
    API 在 [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Iteratee$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Iteratee$)
    中进行了文档说明。
- en: 'The Iteratee object is also used internally within the framework to provide
    some key features. For example, consider the request body parsers. The `apply`
    method of the `BodyParser` object is defined as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Iteratee对象也在框架内部使用，以提供一些关键特性。例如，考虑请求体解析器。`BodyParser`对象的`apply`方法定义如下：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, to define `BodyParser[T]`, we need to define a method that accepts `RequestHeader`
    and returns an `Iteratee` whose input is an `Array[Byte]` and results in Either`[Result,T]`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了定义`BodyParser[T]`，我们需要定义一个接受`RequestHeader`并返回一个输入为`Array[Byte]`、结果为`Either[Result,T]`的`Iteratee`的方法。
- en: Let's look at some of the existing implementations to understand how this works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些现有的实现，以了解它是如何工作的。
- en: 'The `RawBuffer` parser is defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`RawBuffer`解析器定义如下：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `RawBuffer` parser uses `Iteratee.forEach` method and pushes the input received
    into a buffer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`RawBuffer`解析器使用`Iteratee.forEach`方法并将接收到的输入推送到缓冲区。'
- en: 'The file parser is defined as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件解析器定义如下：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The file parser uses the `Iteratee.fold` method to create `FileOutputStream`
    of the incoming data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 文件解析器使用`Iteratee.fold`方法创建接收数据的`FileOutputStream`。
- en: Now, let's see the implementation of Enumerator and how these two pieces fit
    together.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Enumerator的实现以及这两部分是如何结合在一起的。
- en: Enumerator
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Enumerator
- en: 'Similar to the Iteratee, an **Enumerator** is also defined through a trait
    and backed by an object of the same name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与Iteratee类似，**Enumerator**也是通过特性和同名的对象定义的：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Observe that the `apply` method of the trait and its companion object are different.
    The `apply` method of the trait accepts `Iteratee[E, A]` and returns `Future[Iteratee[E,
    A]]`, while that of the companion object accepts a sequence of type `E` and returns
    an `Enumerator[E]`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到特性和其伴生对象的`apply`方法不同。特质的`apply`方法接受`Iteratee[E, A]`并返回`Future[Iteratee[E,
    A]]`，而伴生对象的`apply`方法接受类型为`E`的序列并返回`Enumerator[E]`。
- en: 'Now, let''s define a simple data flow using the companion object''s `apply`
    method; first, get the character count in a given `(Seq[String])` line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用伴生对象的`apply`方法定义一个简单的数据流；首先，获取给定`(Seq[String])`行中的字符计数：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The variable result has the `Future[Int]` type. We can now process this to get
    the actual count.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`result`具有`Future[Int]`类型。我们现在可以处理它以获取实际计数。
- en: 'In the preceding code snippet, we got the result by following these steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们通过以下步骤获取结果：
- en: 'Building an Enumerator using the companion object''s `apply` method:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用伴生对象的`apply`方法构建Enumerator：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Getting `Future[Iteratee[String, Int]]` by binding the Enumerator to an Iteratee:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将枚举器绑定到Iteratee获取`Future[Iteratee[String, Int]]`：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Flattening `Future[Iteratee[String,Int]]` and processing it:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展平`Future[Iteratee[String,Int]]`并处理它：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Fetching the result from `Future[Int]`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Future[Int]`获取结果：
- en: 'Thankfully, Play provides a shortcut method by merging steps 2 and 3 so that
    we don''t have to repeat the same process every time. The method is represented
    by the |`>>>` symbol. Using the shortcut method, our code is reduced to this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Play提供了一个快捷方法，通过合并步骤2和3，这样我们就不必每次都重复相同的过程。该方法由|`>>>`符号表示。使用快捷方法，我们的代码简化为如下：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why use this when we can simply use the methods of the data type? In this case,
    do we use the `length` method of `String` to get the same value (by ignoring whitespaces)?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们可以直接使用数据类型的方法时，为什么还要使用这个方法？在这种情况下，我们是否使用`String`的`length`方法来获取相同的值（通过忽略空白字符）？
- en: In this example, we are getting the data as a single `String` but this will
    not be the only scenario. We need ways to process continuous data, such as a file
    upload, or feed data from various networking sites, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们获取数据作为一个单独的`String`，但这不会是唯一的情况。我们需要处理连续数据的方法，例如文件上传，或从各种网络站点获取数据，等等。
- en: 'For example, suppose our application receives heartbeats at a fixed interval
    from all the devices (such as cameras, thermometers, and so on) connected to it.
    We can simulate a data stream using the `Enumerator.generateM` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的应用程序从连接到它的所有设备（如摄像头、温度计等）以固定间隔接收心跳。我们可以使用`Enumerator.generateM`方法模拟数据流：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding snippet, the `"alive"` String is produced every 100 milliseconds.
    The function passed to the `generateM` method is called whenever the Iteratee
    bound to the Enumerator is in the `Cont` state. This method is used internally
    to build enumerators and can come in handy when we want to analyze the processing
    for an expected data stream.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，每 100 毫秒产生一次 `"alive"` 字符串。传递给 `generateM` 方法的函数在 Iteratee 绑定到 Enumerator
    时处于 `Cont` 状态时被调用。此方法用于内部构建枚举器，并在我们想要分析预期数据流的处理时很有用。
- en: An Enumerator can be created from a file, `InputStream`, or `OutputStream`.
    Enumerators can be concatenated or interleaved. The Enumerator API is documented
    at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumerator$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumerator$).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从文件、`InputStream` 或 `OutputStream` 创建 Enumerator。Enumerators 可以连接或交错。Enumerator
    API 在 [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumerator$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumerator$)
    中进行了文档说明。
- en: Using the Concurrent object
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Concurrent 对象
- en: 'The `Concurrent` object is a helper that provides utilities for using Iteratees,
    enumerators, and Enumeratees concurrently. Two of its important methods are:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concurrent` 对象是一个辅助工具，它提供了使用 Iteratees、枚举器和 Enumeratees 并发的实用工具。它的重要方法有两个：'
- en: '**Unicast**: It is useful when sending data to a single iterate.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单播**：当需要向单个 iterate 发送数据时很有用。'
- en: '**Broadcast**: It facilitates sending the same data to multiple Iteratees concurrently.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播**：它便于将相同的数据并发发送到多个 Iteratee。'
- en: Unicast
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单播
- en: 'For example, the character count example in the previous section can be implemented
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上一节中的字符计数示例可以如下实现：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `unicast` method accepts the `onStart`, `onError`, and `onComplete` handlers.
    In the preceding code snippet, we have provided the `onStart` method, which is
    mandatory. The signature of unicast is this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicast` 方法接受 `onStart`、`onError` 和 `onComplete` 处理器。在前面的代码片段中，我们提供了强制性的 `onStart`
    方法。unicast 的签名如下：'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So, to add a log for errors, we can define the `onError` handler as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了添加错误日志，我们可以定义 `onError` 处理器如下：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's see how broadcast works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看广播是如何工作的。
- en: Broadcast
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播
- en: 'The `broadcast[E]` method creates an enumerator and a channel and returns a
    `(Enumerator[E], Channel[E])` tuple. The enumerator and channel thus obtained
    can be used to broadcast data to multiple Iteratees:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`broadcast[E]` 方法创建一个枚举器和通道，并返回一个 `(Enumerator[E], Channel[E])` 元组。因此获得的枚举器和通道可以用来向多个
    Iteratee 广播数据：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Enumeratees
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Enumeratees
- en: '**Enumeratee** is also defined using a trait and its companion object with
    the same `Enumeratee` name.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Enumeratee** 也使用具有相同 `Enumeratee` 名称的特性和伴随对象来定义。'
- en: 'It is defined as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它的定义如下：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An Enumeratee transforms the Iteratee given to it as input and returns a new
    Iteratee. Let''s look at a method that defines an Enumeratee by implementing the
    `applyOn` method. An Enumeratee''s `flatten` method accepts `Future[Enumeratee]`
    and returns an another Enumeratee, which is defined as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Enumeratee 将其作为输入给出的 Iteratee 进行转换，并返回一个新的 Iteratee。让我们看看通过实现 `applyOn` 方法定义
    Enumeratee 的方法。Enumeratee 的 `flatten` 方法接受 `Future[Enumeratee]` 并返回另一个 Enumeratee，其定义如下：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding snippet, `applyOn` is called on the Enumeratee whose future
    is passed and `dec` is `defaultExecutionContext`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`applyOn` 方法被调用在传递了其未来的 Enumeratee 上，而 `dec` 是 `defaultExecutionContext`。
- en: Defining an Enumeratee using the companion object is a lot simpler. The companion
    object has a lot of methods to deal with Enumeratees, such as map, transform,
    collect, take, filter, and so on. The API is documented at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumeratee$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumeratee$).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伴随对象定义 Enumeratee 要简单得多。伴随对象有许多处理 Enumeratees 的方法，例如 map、transform、collect、take、filter
    等。API 在 [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumeratee$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumeratee$)
    中进行了文档说明。
- en: 'Let''s define an Enumeratee by working through a problem. The example we used
    in the previous section to find the count of vowels and consonants will not work
    correctly if a vowel is capitalized in a sentence, that is, the result of `src
    |>>> vowelCount` will be incorrect when the `line` variable is defined as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过解决一个问题来定义一个`Enumeratee`。我们在上一节中使用的示例，用于查找元音和辅音的数量，如果句子中的元音被大写，则不会正确工作，即当`line`变量定义为以下内容时，`src
    |>>> vowelCount`的结果将是错误的：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To fix this, let's alter the case of all the characters in the data stream to
    lowercase. We can use an Enumeratee to update the input provided to the Iteratee.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们将数据流中所有字符的大小写更改为小写。我们可以使用`Enumeratee`来更新提供给`Iteratee`的输入。
- en: 'Now, let''s define an Enumeratee to return a given string in lowercase:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`Enumeratee`，它返回给定的小写字符串：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are two ways to add an Enumeratee to the dataflow. It can be bound to
    the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将`Enumeratee`添加到数据流中。它可以绑定到以下内容：
- en: Enumerators
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举器
- en: Iteratees
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iteratee`'
- en: Binding an Enumeratee to an Enumerator
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一个`Enumeratee`绑定到一个枚举器上
- en: An Enumeratee can be bound to an enumerator by using the enumerator's `through`
    method, which returns a new Enumerator and is composed using the given enumeratee.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过枚举器的`through`方法将`Enumeratee`绑定到枚举器上，该方法返回一个新的枚举器，并使用给定的`Enumeratee`进行组合。
- en: 'Updating the example to include an Enumeratee, we get this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更新示例以包括`Enumeratee`，我们得到以下内容：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `through` method is an alias for the `&>` method and is defined for an
    enumerator, so the last statement can also be rewritten as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`through`方法是对`&>`方法的别名，它是为枚举器定义的，因此最后的语句也可以重写为以下内容：'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Binding an Enumeratee to an Iteratee
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一个`Enumeratee`绑定到一个`Iteratee`上
- en: 'Now, let''s implement the same flow by binding the enumeratee to the Iteratee.
    This can be done using the enumeratee''s `transform` method. The t`ransform` method
    transforms the given Iteratee and results in a new Iteratee. Modifying the flow
    according to this, we get the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过将`Enumeratee`绑定到`Iteratee`上来实现相同的流程。这可以通过使用`Enumeratee`的`transform`方法来完成。`transform`方法将给定的`Iteratee`转换，并产生一个新的`Iteratee`。根据这一点修改流程，我们得到以下内容：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The enumeratee''s `transform` method has a `&>>` symbolic alias. Using this,
    we can rewrite the flow as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumeratee`的`transform`方法有一个`&>>`符号别名。使用这个别名，我们可以将流程重写如下：'
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In addition to the fact that enumeratees can be bound to either Enumerators
    or Iteratees, different Enumeratees can be also be combined if the output type
    of one is the same as the input type of the other. For example, assume we have
    a `filterVowel` Enumeratee that filters out the vowels, as demonstrated in the
    following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Enumeratee`可以绑定到枚举器或`Iteratee`之外，如果其中一个的输出类型与另一个的输入类型相同，不同的`Enumeratee`也可以组合。例如，假设我们有一个`filterVowel`
    `Enumeratee`，它过滤掉元音，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Combining `toSmallCase` and `filterVowel` is possible since the output type
    of `toSmallCase` is a `String` and the input type of `filterVowel` is also a `String`.
    To do this, we use the Enumeratee''s `compose` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`toSmallCase`和`filterVowel`的组合是可能的，因为`toSmallCase`的输出类型是`String`，而`filterVowel`的输入类型也是`String`。为此，我们使用`Enumeratee`的`compose`方法：'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s rewrite the flow by using this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下方式重写流程：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, `sink` is defined as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sink`被定义为以下内容：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Like the `transform` and `compose` methods, this also has a `><>` symbolic
    alias. Let''s define the flow using all the symbols instead of method names in
    the following way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与`transform`和`compose`方法一样，这也具有`><>`符号别名。让我们使用所有符号而不是方法名来定义以下流程：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can add another enumeratee that computes the length of `String` and uses
    `Iteratee`, which simply sums up the lengths:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加另一个`Enumeratee`，它计算`String`的长度并使用`Iteratee`，它简单地求和长度：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Binding an Enumeratee to an Iteratee](img/3803OS_06_02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![将一个`Enumeratee`绑定到一个`Iteratee`上](img/3803OS_06_02.jpg)'
- en: In the preceding snippet, we had to use a different iterator that accepts data
    of the `Int` type, since our `toInt` enumeratee transforms the `String` input
    to `Int`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们必须使用一个接受`Int`类型数据的不同迭代器，因为我们的`toInt` `Enumeratee`将`String`输入转换为`Int`。
- en: This concludes the chapter. Define a few data flows to get familiar with the
    API. Start with simpler data flows, such as extracting all the numbers or words
    in a given paragraph, and then complicate them gradually.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束。定义几个数据流以熟悉API。从简单的数据流开始，例如提取给定段落中的所有数字或单词，然后逐步复杂化。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the concept of Iteratees, Enumerators, and Enumeratees.
    We also saw how they were implemented in Play Framework and used internally. This
    chapter also walked you through a simple example to illustrate how data flow can
    be defined using the API exposed by Play Framework.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了迭代器（Iteratees）、枚举器（Enumerators）和枚举者（Enumeratees）的概念。我们还看到了它们如何在 Play
    框架中实现并被内部使用。本章还通过一个简单的示例向您展示了如何使用 Play 框架公开的 API 定义数据流。
- en: In the next chapter, we will explore the features provided in a Play application
    through a global plugin.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一个全局插件来探索 Play 应用程序提供的功能。
