- en: Chapter 6. Reactive Data Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In particular circumstances, our application may be required to handle huge
    file uploads. This can be done by putting all of these in the memory, by creating
    a temporary file, or by acting directly on the stream. Out of these three, the
    last option works the best for us, as it removes I/O stream limitations (such
    as blocking, memory, and threads) and also eliminates the need to buffer (that
    is, acting on input at the rate needed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling huge file uploads belongs to the set of unavoidable operations that
    can be heavy on resources. Some other tasks that belong to the same category are
    processing real-time data for monitoring, analysis, bulk data transfers, and processing
    large datasets. In this chapter, we will discuss the Iteratee approach used to
    handle such situations. This chapter covers the basics of handling data streams
    with a brief explanation of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Iteratees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumeratees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter may seem intense at times but the topics discussed here will be
    helpful for some of the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of handling data streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider that we connected a mobile device (such as a tablet, phone, MP3 player,
    and so on) to its charger and plugged it in. The consequences of this can be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The device's battery starts charging and continues to do so until the occurrence
    of one of the other options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The device's battery is completely charged and minimal power is drawn by the
    device to continue running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The device's battery can not be charged due to malfunctioning of the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the power supply is the source, the device is the sink, while the charger
    is the channel that enables transfer of energy from the source to the sink. The
    processing or task performed by the device is that of charging its battery.
  prefs: []
  type: TYPE_NORMAL
- en: Well, this covers most of the Iteratee approach without any of the usual jargon.
    Simply put, the power supply represents a data source, the charger acts as the
    Enumerator, and the device as the Iteratee.
  prefs: []
  type: TYPE_NORMAL
- en: Oops, we missed the Enumeratee! Suppose that the energy from a regular power
    supply is not compatible with the device; then, in this case, the charger generally
    has an internal component that performs this transformation. For example, converting
    from A.C. (alternating current) to D.C. (direct current). In such cases, the charger
    can be considered a combination of the Enumerator and the Enumeratee. The component
    that collects energy from the power supply acts like the Enumerator, and the other
    component that transforms the energy is similar to an Enumeratee.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basics of handling data streams](img/3803OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The concept of Iteratee, Enumerator, and Enumeratee originated from the Haskell
    library Iteratee I/O, which was developed by Oleg Kiselyov to overcome the problems
    faced with lazy I/O.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Oleg''s words, as seen on [http://okmij.org/ftp/Streams.html](http://okmij.org/ftp/Streams.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Enumerator is an encapsulation of a data source, a stream producer—what folds
    an iteratee over the stream. An enumerator takes an iteratee and applies it to
    the stream data as they are being produced, until the source is depleted or the
    iteratee said it had enough. After disposing of buffers and other source-draining
    resources, enumerator returns the final value of the iteratee. Enumerator thus
    is an iteratee transformer.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Iteratees are stream consumers and an Iteratee can be in one of the following
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Completed or done*: The Iteratee has completed processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuing*: The current element has been processed but the Iteratee is not
    done yet and can accept the next element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Error*: The Iteratee has encountered an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enumeratee is both a consumer and a producer, incrementally decoding the outer
    stream and producing the nested stream of decoded data.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although the enumerator knows how to get to the next element, it is completely
    unaware of the processing the Iteratee will perform on this element and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Different libraries implement the Iteratee, Enumerator, and Enumeratee differently,
    based on these definitions. In the following sections, we will see how these are
    implemented in Play Framework and how we can use them in our application. Let's
    start with the Iteratee, as the Enumerator requires a one.
  prefs: []
  type: TYPE_NORMAL
- en: Iteratees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iteratee is defined as a trait, `Iteratee[E, +A]`, where E is the input type
    and A is the result type. The state of an Iteratee is represented by an instance
    of `Step`, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The input used here represents an element of the data stream, which can be
    empty, an element, or an end of file indicator. Therefore, `Input` is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An Iteratee is an immutable data type and each result of processing an input
    is a new Iteratee with a new state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the possible states of an Iteratee, there is a predefined helper
    object for each state. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Cont
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the definition of the `readLine` method, which utilizes these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `readLine` method is responsible for reading a line and returning an Iteratee.
    As long as there are more bytes to be read, the `readLine` method is called recursively.
    On completing the process, an Iteratee with a completed state (Done) is returned,
    else an Iteratee with state continuous (Cont) is returned. In case the method
    encounters EOF, an Iteratee with state Error is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these, Play Framework exposes a companion Iteratee object, which
    has helper methods to deal with Iteratees. The API exposed through the Iteratee
    object is documented at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Iteratee$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Iteratee$).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Iteratee object is also used internally within the framework to provide
    some key features. For example, consider the request body parsers. The `apply`
    method of the `BodyParser` object is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, to define `BodyParser[T]`, we need to define a method that accepts `RequestHeader`
    and returns an `Iteratee` whose input is an `Array[Byte]` and results in Either`[Result,T]`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the existing implementations to understand how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RawBuffer` parser is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `RawBuffer` parser uses `Iteratee.forEach` method and pushes the input received
    into a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file parser is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The file parser uses the `Iteratee.fold` method to create `FileOutputStream`
    of the incoming data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see the implementation of Enumerator and how these two pieces fit
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the Iteratee, an **Enumerator** is also defined through a trait
    and backed by an object of the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the `apply` method of the trait and its companion object are different.
    The `apply` method of the trait accepts `Iteratee[E, A]` and returns `Future[Iteratee[E,
    A]]`, while that of the companion object accepts a sequence of type `E` and returns
    an `Enumerator[E]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a simple data flow using the companion object''s `apply`
    method; first, get the character count in a given `(Seq[String])` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The variable result has the `Future[Int]` type. We can now process this to get
    the actual count.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, we got the result by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Building an Enumerator using the companion object''s `apply` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Getting `Future[Iteratee[String, Int]]` by binding the Enumerator to an Iteratee:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Flattening `Future[Iteratee[String,Int]]` and processing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetching the result from `Future[Int]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thankfully, Play provides a shortcut method by merging steps 2 and 3 so that
    we don''t have to repeat the same process every time. The method is represented
    by the |`>>>` symbol. Using the shortcut method, our code is reduced to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Why use this when we can simply use the methods of the data type? In this case,
    do we use the `length` method of `String` to get the same value (by ignoring whitespaces)?
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are getting the data as a single `String` but this will
    not be the only scenario. We need ways to process continuous data, such as a file
    upload, or feed data from various networking sites, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose our application receives heartbeats at a fixed interval
    from all the devices (such as cameras, thermometers, and so on) connected to it.
    We can simulate a data stream using the `Enumerator.generateM` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `"alive"` String is produced every 100 milliseconds.
    The function passed to the `generateM` method is called whenever the Iteratee
    bound to the Enumerator is in the `Cont` state. This method is used internally
    to build enumerators and can come in handy when we want to analyze the processing
    for an expected data stream.
  prefs: []
  type: TYPE_NORMAL
- en: An Enumerator can be created from a file, `InputStream`, or `OutputStream`.
    Enumerators can be concatenated or interleaved. The Enumerator API is documented
    at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumerator$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumerator$).
  prefs: []
  type: TYPE_NORMAL
- en: Using the Concurrent object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Concurrent` object is a helper that provides utilities for using Iteratees,
    enumerators, and Enumeratees concurrently. Two of its important methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicast**: It is useful when sending data to a single iterate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast**: It facilitates sending the same data to multiple Iteratees concurrently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example, the character count example in the previous section can be implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unicast` method accepts the `onStart`, `onError`, and `onComplete` handlers.
    In the preceding code snippet, we have provided the `onStart` method, which is
    mandatory. The signature of unicast is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to add a log for errors, we can define the `onError` handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how broadcast works.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `broadcast[E]` method creates an enumerator and a channel and returns a
    `(Enumerator[E], Channel[E])` tuple. The enumerator and channel thus obtained
    can be used to broadcast data to multiple Iteratees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Enumeratees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enumeratee** is also defined using a trait and its companion object with
    the same `Enumeratee` name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An Enumeratee transforms the Iteratee given to it as input and returns a new
    Iteratee. Let''s look at a method that defines an Enumeratee by implementing the
    `applyOn` method. An Enumeratee''s `flatten` method accepts `Future[Enumeratee]`
    and returns an another Enumeratee, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, `applyOn` is called on the Enumeratee whose future
    is passed and `dec` is `defaultExecutionContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an Enumeratee using the companion object is a lot simpler. The companion
    object has a lot of methods to deal with Enumeratees, such as map, transform,
    collect, take, filter, and so on. The API is documented at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumeratee$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.iteratee.Enumeratee$).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define an Enumeratee by working through a problem. The example we used
    in the previous section to find the count of vowels and consonants will not work
    correctly if a vowel is capitalized in a sentence, that is, the result of `src
    |>>> vowelCount` will be incorrect when the `line` variable is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To fix this, let's alter the case of all the characters in the data stream to
    lowercase. We can use an Enumeratee to update the input provided to the Iteratee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define an Enumeratee to return a given string in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to add an Enumeratee to the dataflow. It can be bound to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteratees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding an Enumeratee to an Enumerator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Enumeratee can be bound to an enumerator by using the enumerator's `through`
    method, which returns a new Enumerator and is composed using the given enumeratee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the example to include an Enumeratee, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `through` method is an alias for the `&>` method and is defined for an
    enumerator, so the last statement can also be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Binding an Enumeratee to an Iteratee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s implement the same flow by binding the enumeratee to the Iteratee.
    This can be done using the enumeratee''s `transform` method. The t`ransform` method
    transforms the given Iteratee and results in a new Iteratee. Modifying the flow
    according to this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The enumeratee''s `transform` method has a `&>>` symbolic alias. Using this,
    we can rewrite the flow as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the fact that enumeratees can be bound to either Enumerators
    or Iteratees, different Enumeratees can be also be combined if the output type
    of one is the same as the input type of the other. For example, assume we have
    a `filterVowel` Enumeratee that filters out the vowels, as demonstrated in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining `toSmallCase` and `filterVowel` is possible since the output type
    of `toSmallCase` is a `String` and the input type of `filterVowel` is also a `String`.
    To do this, we use the Enumeratee''s `compose` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rewrite the flow by using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `sink` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `transform` and `compose` methods, this also has a `><>` symbolic
    alias. Let''s define the flow using all the symbols instead of method names in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add another enumeratee that computes the length of `String` and uses
    `Iteratee`, which simply sums up the lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Binding an Enumeratee to an Iteratee](img/3803OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding snippet, we had to use a different iterator that accepts data
    of the `Int` type, since our `toInt` enumeratee transforms the `String` input
    to `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. Define a few data flows to get familiar with the
    API. Start with simpler data flows, such as extracting all the numbers or words
    in a given paragraph, and then complicate them gradually.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the concept of Iteratees, Enumerators, and Enumeratees.
    We also saw how they were implemented in Play Framework and used internally. This
    chapter also walked you through a simple example to illustrate how data flow can
    be defined using the API exposed by Play Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the features provided in a Play application
    through a global plugin.
  prefs: []
  type: TYPE_NORMAL
