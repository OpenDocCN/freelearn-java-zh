- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter shows how to unit test your APIs before they are integrated with
    other components. Sometimes, we would have to stub dependencies with some dummy
    data, and this can be done by mocking the dependencies. We will show you how to
    do this using a mocking library. We will also show you how to write fixtures to
    populate test data and then how you can test the behavior of your application
    by integrating different APIs and testing them together. We will cover the following
    recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of an API using JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing by mocking dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fixtures to populate data for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well-tested code provides a peace of mind to the developer. If you get a feeling
    that writing a test for the new method you are developing is too much of an overhead,
    then you usually don't get it right the first time.. This is because you have
    to test your method anyway. Doing this in the context of the application only
    requires time to set things up (especially if you are trying to test all the possible
    input and conditions). Then, if the method changes, you need to redo the setup
    again. And you do it manually. You can avoid this by creating an automated test
    at the same time you were developing the new method (we assume not-too complex
    code, of course; setters and getters do not count). This would save you time in
    the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we get this feeling of overhead sometimes? It's probably because we are
    not prepared psychologically. When we think about how long it would take to add
    the new functionality, we often forget to include the time needed for writing
    the test. It is even worse when we forget this while providing an estimate to
    a manager. Often, we shy away from giving a higher estimate because we do not
    want to look not perception we have of not being very knowledgeable or skilled
    enough. Whatever the reason, it happens. Only after years of experience, we learn
    to include tests in our estimates and earn enough respect and clout to be able
    to assert publicly that doing things right requires more time up front, but saves
    much more time in the long run. Besides, doing it right leads to a better quality
    of the result with far less stress, which means a better quality of life overall.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still not convinced, make note of the date when you read this and
    check back every year until this advice becomes obvious to you. Then, please share
    your experiences with others. This is how humanity makes progress, by passing
    knowledge from one generation to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you would like to learn how to write tests that will help you produce
    good quality Java code, this chapter is for you. Methodologically, this is applicable
    to other languages and professions too. This chapter is written primarily for
    Java developers and assumes the authorship of tested code. Another assumption
    is that testing happens during the early stages of code writing so that code weaknesses
    discovered during the testing can be fixed immediately. Writing automated tests
    early is the best time to do it for two other reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily restructure your code to make it more testable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It saves you time by eliminating guesswork, which in turn makes your development
    process more productive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another good moment to write a test (or enhance the existing one) is when a
    defect is discovered in production. It helps your investigation of the root cause
    if you recreate the problem and demonstrate it in a failed test and then show
    how the issue disappears (and the test does not fail anymore) in the new version
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of an API using JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Wikipedia, *A research survey performed in 2013 across 10,000 Java
    projects hosted on GitHub found that JUnit, (in a tie with slf4j-api), was the
    most commonly included external library. Each library was used by 30.7% of projects.* JUnit
    is a testing framework--one of a family of unit testing frameworks collectively
    known as xUnit that originated with SUnit. It is linked as a JAR at compile time
    and resides (since JUnit 4) in the `org.junit` package.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an excerpt from another article on Wikipedia, *In object-oriented programming,
    a unit is often an entire interface, such as a class, but could be an individual
    method.* We've found the last part--a unit as an individual method--the most useful
    in practice. It will be the basis for the examples of the recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of this writing, the latest stable version of JUnit is 4.12, which
    can be used by adding the following Maven dependency to the `pom.xml` project
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can write your first JUnit test. Let''s assume you have the `Vehicle` class
    created in the `src/main/java/com/packt/cookbook.ch02_oop.a_classes` folder (this
    is exactly the code we discussed in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast
    Track to OOP - Classes and Interfaces*, of this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create the `src/test/java/com/packt/cookbook.ch02_oop.a_classes` folder
    (notice the new folder tree that starts with `test`, created in parallel to the
    tree of `main`) and create a new file in it called `VehicleTest.java` that contains
    the `VehicleTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it using your favorite IDE or just with the `mvn test` command. You will
    see an output that will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44d4630b-d846-41c3-b270-c9ed50889d93.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have created your first test class. It does not test anything
    yet, but it is an important setup--the overhead that is necessary for doing things
    the right way. In the next section, we will start with the actual testing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the `Vehicle` class closer. Testing the getters would be of
    little value, but we can still do it, making sure that the value passed to the
    constructor is returned by the corresponding getter. The exception in the constructor
    belongs to the must-test features as well as the `getSpeedMph()` method. There
    is also an object of the `Engine` class that has the `getHorsePower()` method.
    Can it return `null`? We should look in the `Engine` class too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is not much behavior in this class to test and it cannot return `null`.
    But returning a negative value is a definite possibility, which in turn can cause
    problems for the `Math.sqrt()` function of the `getSpeedMph()` method. Should
    we make sure that the horsepower value will never be negative? It depends on how
    limited is the method's usage and the source of the input data for it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar considerations are applicable to the value of the `weightPounds` property of
    the `Vehicle` class. It can stop the application with `ArithmeticException` caused
    by the division by zero in the `getSpeedMph()` method.
  prefs: []
  type: TYPE_NORMAL
- en: However, in practice, there is little chance that the values of an engine's
    horsepower and vehicle weight will be negative or close to zero, so we will assume
    this and will not add these checks to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Such analysis is the daily routine and the background thoughts of every developer,
    and that is the first step in the right direction. The second step is to capture
    all these thoughts and doubts in the unit tests and verify the assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the test class we have created and enhance it. As you may
    have probably noticed, the `@Test` annotation makes a certain method a test method.
    This means it will be run by your IDE or Maven every time you issue a command
    to run tests. The method can be named any way you like, but a best practice advises
    to indicate which method (of the `Vehicle` class, in this case) you are testing.
    So, the format usually looks like `test<methodname><scenario>`, where  `scenario`
    indicates a particular test case: a happy path, a failure, or some other condition
    you would like to test. In our example, we do not use suffix as an indication
    that we are going to test the main functionality that is working successfully
    (without any errors or edge cases). Later, we will show examples of methods that
    test other scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a test method, you can call the application method you are testing,
    provide it with the data, and assert the result. You can create your own assertions
    (methods to compare the actual results with the expected ones) or you can use
    assertions provided by JUnit. To do the latter, just add `static` import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use a modern IDE, you can type `import static org.junit.Assert` and
    see how many different assertions are available (or go to JUnit''s API documentation
    and see it there). There is a dozen or more overloaded methods available: `assertArrayEquals()`,
    `assertEquals()`, `assertNotEquals()`, `assertNull()`, `assertNotNull()`, `assertSame()`,
    `assertNotSame()`, `assertFalse()`, `assertTrue()`, `assertThat()`, and `fail()`.
    It would be helpful if you spend a few minutes reading what these methods do.
    You can also guess their purpose by name. Here is an example of the usage of the `assertEquals()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We compare the actual length of the word `Hello` and the expected length, that
    is, `4`. We know that the correct number would be `5`, but we would like the test to
    fail to demonstrate the failing behavior and advise how to read the failing test
    results (you don''t need to read happy results, do you?). If you run this test,
    you''ll get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d13c64e-732d-456c-a2a5-c25dd93a2b83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that the expected value was `4`, while the actual is `5`. Say,
    you switch the order like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63be96a0-04c4-4610-9117-d330ea82b6e5.png)'
  prefs: []
  type: TYPE_IMG
- en: This is incorrect because `5` is the actual result, while `4` is the expected
    (although erroneous, for demonstration purposes only).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that in each of the asserting methods, the parameter
    with the expected value is located (in the signature of an assertion) ***before***
    the actual one.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the test is written, you will do something else, and months later, you
    will probably forget what each assertion actually evaluated. But it may well be
    that one day the test will fail (because you or somebody will change the application
    code). You will see the test method name, expected value, and the actual value,
    but you will have to dig through the code to figure which of the assertion failed
    (there are often several of them in each test method). You will probably be forced
    to add a debug statement and run the test several times in order to figure it
    out. To help you avoid this extra digging, each of the JUnit assertions allows
    you to add a message that describes the particular assertion. For example, run
    this version of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do this, the result will be much more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c3dda9b-be51-4f34-9f36-ad39c2a0410d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To complete this demonstration, we change the expected value to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be your test output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e1d30c5-ecf8-41da-9c7f-e1f117d5e3cc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Equipped with some knowledge of the JUnit framework, we can now write a real
    test method for the main case: the calculation of the speed of a vehicle of certain
    weight with an engine of certain horsepower to determine where it can reach in
    a certain period of time. We take the formula we used for writing the code (provided
    originally by the domain expert) and calculate the expected value. For example,
    if the vehicle has an engine of 246 hp and weight of 4,000 lb, then in 10 sec,
    its speed can reach 117 mph. Since the speed is of the type `double`, we will
    use this assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `delta` is allowable precision (we decided that 1 percent is good enough).
    The resulting implementation of the `test` method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this test, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f19a21ab-44cb-4b1f-be96-07db70a1c7dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make sure the test is working, we set the expected value to 119 mph (more
    than 1 percent different) and run the test again. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56312767-34f4-4dc3-b1ee-9f4111bd91e5.png)'
  prefs: []
  type: TYPE_IMG
- en: We change the expected value back to 117 and continue writing other test cases
    we discussed while analyzing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure that the exception is thrown when expected. Let''s add another
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This test runs successfully too. To make sure that the test works correctly,
    we temporarily assign it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6f0d5e3-84b1-4d0c-852f-16e0091e5a1a.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, we get a level of confidence that we did not code something that is
    going to be correct always, no matter the code changes.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the best way to write these tests is in the process of writing
    application code, so you can test the code as it grows in complexity. Otherwise,
    especially in more complex code, you might have problems debugging it after all
    of the code is written already.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few other annotations and JUnit features that can be helpful
    to you, so please refer to the JUnit documentation for more in-depth understanding
    of all the framework capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing by mocking dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fixtures to populate data for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing by mocking dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a unit test requires unit isolation. In case a method uses several other
    methods from different objects, there arises a need to limit the depth of testing so
    that each layer can be tested in isolation as a unit. This is when the need for
    mocking the lower level comes into focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocking can not only be done vertically, but also horizontally: at the same
    level, but already isolated from the underlying functionality. If a method is
    long and complicated, you might consider breaking it into several smaller methods
    so you can test only one of them while mocking the others. This is another advantage
    of unit testing code along with its development; it is easier to redesign code
    for better testability before it is hardened.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking other methods and classes is straightforward. Coding to an interface
    (as described in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast
    Track to OOP - Classes and Interfaces*) makes it much easier, although there are
    mocking frameworks that allow you to mock classes that do not implement any interface
    (we will see examples of such framework usage in the next section of this recipe).
    Also, using object and method factories helps you create test-specific implementations
    of such factories so they can generate objects with methods that return the expected
    hardcoded values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in [Chapter 4](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml), *Going
    Functional*, we introduced `FactoryTraffic`, which produced one or many objects
    of `TrafficUnit`. In a real system, this factory would draw data from some external
    system that has data about traffic for a certain geographic location and time
    of the day. Using the real system as the source would complicate the code setup
    for you when you run the examples. To get around this problem, we have mocked
    the data by generating them according to the distribution that somewhat resembles
    the real one: a bit more cars than trucks, the weight of the vehicle depending
    on the type of the car, the number of passengers and weight of the payload, and
    similar. What is important for such a simulation is that the range of values (min
    and max) should reflect those coming from the real system, so the application
    would be tested on the full range of possible real data.'
  prefs: []
  type: TYPE_NORMAL
- en: The important constraint for mocking code is that it should not be too complicated.
    Otherwise, its maintenance would require an overhead that would either decrease
    the team productivity or decrease (if not abandon completely) the test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how the mock of `FactoryTraffic` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It assembles a collection of `TrafficUnit` objects. In a real system, these
    objects would be created from the rows of the result of some database query, for
    example. But in our case, we just mock the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used a random number generator to pick up the value from
    a range for each of the parameters. The range is in line with the ranges of the
    real data. This code is very simple and it does not require much maintenance,
    but it provides the application with the flow of data similar to the real one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use another technique for testing the method that has some dependencies
    that you would like to isolate in order to get the predictable result. For example,
    let''s revisit the `VechicleTest` class. Instead of creating a real `Engine` object,
    we can mock it using one of the mocking frameworks. In this case, we use Mockito.
    Here is the Maven dependency for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method now looks like this (the two lines that were changed are highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we instruct the `mock` object to return a fixed value when
    the `getHorsePower()` method is called. We can even go as far as creating a mock
    object for the method we want to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it always returns the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc805877-a5bd-42db-bd36-cbf6908cbb6d.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this would defeat the purpose of testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use another technique while testing a stream''s pipeline methods. Let''s
    assume we need to test the `trafficByLane()` method in the `TrafficDensity1` class (we
    are going to have  `TrafficDensity2` and `TrafficDensity3`, too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses two support classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It also uses the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We demonstrated the use of such support classes in [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml), *Modular*
    *Programming*, while talking about streams. Now we realize that testing this class
    might not be easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `SpeedModel` object is an input parameter for the `trafficByLane()` method,
    we could test its `getSpeedMph()` method in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, unfortunately, the current implementation of `FactorySpeedModel` requires
    the `TrafficUnit` object (in order to get the traction value). We need to modify
    it to extract `SpeedModel` without any dependency in `TrafficUnit` because we
    will now apply traction in the `calcSpeed()` method. The new version of `FactorySpeedModel` will
    now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method could now be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, the `calcSpeed()` method in `TrafficUnitWrapper` remains untested.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could test the `trafficByLane()` method as a whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this would require you to create a stream of objects of `TrafficUnit`
    with fixed data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is not clear how the data in the `TrafficUnit` object resulted in a different
    speed value. Besides, we would need to add a variety of test data--for different
    vehicle types and other parameters--and that is a lot of code to write and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: This means we need to revisit the design of the `trafficByLane()` method. To
    get confidence that the method will work correctly, we need to test each step
    of the calculations inside the method in isolation so that each test would require
    little input data and allow you to have a clear understanding of the expected
    results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look closely at the `trafficByLane()` method, you will notice that the
    problem is caused by the location of the calculation--inside the private class `TrafficUnitWrapper`.
    We can move it from there and create a new method of the `TrafficDensity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can change its signature to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these two methods to the `TrafficUnitWrapper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now rewrite the stream pipeline like this (the line changed is in bold
    font):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By making the `calcSpeed()` method protected and assuming that the `Vehicle`
    class is tested in its own test class `VehicleTest`, we can now write `testCalcSpeed()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining functionality can now be tested by mocking the `calcSpeed()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This experience has made us aware that using an inner private class can make
    the functionality untestable in isolation. Let''s try and get rid of the `private`
    class `CountByLane`. This leads us to the third version of the `TrafficDensity3`
    class (we have shown the code that has changed in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This change allows us to extend the class in the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It also allows us to change the test method `calcLaneNumber()` in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using fixtures to populate data for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fixtures to populate data for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In more complex applications (which use a database, for example), there is often
    a need to set up the same data before each test and clean it up after each test
    is run. Some parts of the data need to be set before each test method and cleaned afterwards.
    You'd also need to have another setup configured before you run the test class,
    and it should be cleaned up afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To accomplish this, you can dedicate a method that does the setup by writing
    a `@Before` annotation in front of it. The corresponding cleaning method is identified
    by the `@After` annotation. Similar class-level methods are annotated by `@BeforeClass`
    and `@AfterClass`. Here is a quick demo of this. Add the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the tests now, you''ll get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fca629ca-04df-4c56-a42d-40b00d388119.png)'
  prefs: []
  type: TYPE_IMG
- en: Such methods that "fix" the test context are called **fixtures**. Notice that
    they have to be public, and the class-level setup/cleanup fixtures have to be
    static. The upcoming JUnit 5 plans to lift these constraints, though.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical example of such a usage would be creating necessary tables before
    the first test method is run and removing them after the last method of the test
    class is finished. The setup/cleanup methods can also be used to create/close
    a database connection unless your code does it in the try-with-resources construct
    (refer to [Chapter 12](01ba0219-7bd3-4ad9-a856-ac2f81e98057.xhtml), *Memory Management
    and Debugging*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the usage of fixtures (refer to [Chapter 6](41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml),
    *Database Programming* on how to set up a database for running it). Let''s assume
    we need to test the `DbRelatedMethods` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to make sure that this method always updates all the records
    of the `text` table with the provided value. Our first test is to update all the
    existing records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This means that the table has to exist in the test database and should have
    a record in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second test makes sure that all the records are updated even if there is
    more than one record, and each record contains a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the tests use the same table, that is, `text`. Therefore, there is no
    need to drop it after each test. This is why we create and drop it at the class
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that all we need to do is populate the table before each test and
    clean it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since we can use the same object for all the tests, let''s create it
    on the class level too (as the test class''s property):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run all the tests of the `test` class now, the output would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85cfcf20-c1a0-4a23-af85-6161b5635397.png)'
  prefs: []
  type: TYPE_IMG
- en: The printed messages allow you to trace the sequence of all the method calls
    and see that they are executed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have read all the chapters and have looked at the code examples, you
    may have probably noticed that by now, we have discussed and built all the components
    necessary for a typical distributed application. Now is the time to put all the
    components together and see whether they cooperate as expected. This process is
    called integration.
  prefs: []
  type: TYPE_NORMAL
- en: While doing this, we will look closely at assessing whether the application
    behaves according to the requirements. In cases where functional requirements
    are presented in an executable form (using the Cucumber framework, for example),
    we can run them and check whether all the checks pass. Many software companies
    follow a behavior-driven development process and perform testing very early, sometimes
    even before any substantial amount of code is written (such tests fail, of course,
    but succeed as soon as the expected functionality is implemented). As mentioned
    already, early testing can be very helpful for writing focused, clear, and well-testable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: However, even without strict adherence to the *test-first* process, the integration
    phase naturally includes some kind of behavioral testing. In this recipe, we will
    see several possible approaches and specific examples related to this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed that in the course of this book, we have built several
    classes that compose an application that analyzes and models traffic. For your
    convenience, we have included all of them in the `com.packt.cookbook.ch15_testing` package.
    You''re already familiar with (from Chapters 2, 4, 5, and 7) the five interfaces
    in the `api` folder: `Car`, `SpeedModel`, `TrafficUnit`, `Truck`, and `Vehicle`.
    Their implementations are encapsulated inside classes called *factories* in the
    folder with the same name (used in Chapters 2, 4, 5, and 7): `FactorySpeedModel`,
    `FactoryTraffic`, and `FactoryVehicle`. These factories produced input for the
    functionality of the `AverageSpeed` classes ([Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml),
    *Concurrent and Multithreaded Programming*) and `TrafficDensity` (based on [Chapter
    5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream Operations and Pipelines*
    but created and discussed in the current chapter)--the core classes of our demo
    application. They produce the values that motivated the development of this particular
    application in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: The main functionality of the application is straightforward. For a given number
    of lanes and speed limit for each lane, `AverageSpeed` calculates (estimates)
    the actual speed of each lane (assuming all the drivers are behaving rationally,
    taking the lane according to their speed), while `TrafficDensity` calculates the number
    of vehicles in each lane after 10 sec (assuming all the cars start at the same
    time after the traffic light). The calculations are done based on the data from
    `numberOfTrafficUnits` vehicles collected at a certain location and time of the
    year. It does not mean that all the thousand vehicles were racing at the same
    time. These 1,000 measuring points have been collected over 50 years for approximately
    20 vehicles that drove at the specified intersection during the specified hour
    (which means one vehicle every three minutes on average).
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall infrastructure of the application is supported by the classes in
    the `process` folder: `Dispatcher`, `Processor`, and `Subscription` (we discussed
    their functionality and demonstrated them in [Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml),
    *Concurrent and Multithreaded Programming* ). These classes allow distributed
    processing. The `Dispatcher` class sends a request for processing to the population
    of `Processors` in a pool, using the `Subscription` class. Each `Processor` class
    performs the task according to the request (using the `AverageSpeed` and `TraffciDensity` classes)
    and stores the results in the database (using the `DbUtil` class in the `utils`
    folder, based on the functionality discussed in [Chapter 6](41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml),
    *Database Programming*).'
  prefs: []
  type: TYPE_NORMAL
- en: We have tested most of these classes as units. Now we are going to integrate
    them and test the application as a whole for correct behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements were made up just for demo purposes. The goal was to have something
    well motivated (resembling real data) and at the same time simple enough to understand
    without special knowledge of traffic analysis and modeling.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several levels of integration. We need to integrate the classes and
    subsystems of the application and also integrate our application with the external
    system (the source of the traffic data developed and maintained by a third party).
    Here is an example of class-level integration (see the `demo1_class_level_integration()`
    method in the `Chapter15Testing` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we integrated each of the two main classes, namely `AverageSpeed`
    and `TrafficDensity`, with factories and implementation of their API interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da2c3168-be61-45cc-83e9-990473e412e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the results are slightly different from one run to another. This
    is because the data produced by `FactoryTraffic` varies from one request to another.
    But, at this stage, we just have to make sure that everything works together and
    produce some more or less accurate-looking results. We have tested the code by
    units and have a level of confidence that it is doing what it is supposed to do.
    We will get back to the results' validation during the actual integration *testing* process,
    not during integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'After finishing the integration at the class level, see how the subsystems
    work together (see the `demo1_subsystem_level_integration()` method in the `Chapter15Testing`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you can see that we used `DBUtil` to create the necessary table
    that holds the input data and the results (produced and recorded by `Processor`).
    The `Dispatcher` class sends a request and inputs data to the objects of the `Processor` class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Subscription` class is used to send/get the message (refer to [Chapter
    7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml), *Concurrent and Multithreaded
    Programming* for a description of this functionality):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The processors are doing their job; we just need to wait for a few seconds
    (you might adjust this time if the computer you are using requires more time to
    finish the job) before we get the results (using DBUtil for reading the recorded
    results from the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/065b3686-1952-49c0-a757-b0684adf772f.png)'
  prefs: []
  type: TYPE_IMG
- en: The names of the `Process` enum class point to the corresponding records in
    the `result` table in the database. Again, at this stage, we are primarily looking
    for getting any results at all, not at how correct the values are.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the successful integration between the subsystems of our application
    (based on the generated data from `FactoryTraffic`), we can try and connect to
    the external system that provides real traffic data. Inside `FactoryTraffic`,
    we would now switch from generating `TrafficUnit` objects to getting data from
    a real system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The switch can be implemented as a Boolean property in the class (as seen in
    the preceding code) or the project configuration property. We leave out the details
    of the connection to a particular source of real traffic data as this is not relevant
    to the purpose of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The main focus at this stage has to be the performance and having a smooth data
    flow between the external source of real data and our application. After we have
    made sure that everything works and produces results (that look realistic) with
    satisfactory performance, we can turn to integration *testing* (with the actual
    results' assertion).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For testing, we need to set the expected values, which we can then can compare
    with the (actual) values, produced by the application that processes real data.
    But real data change slightly from run to run, and an attempt to predict the resulting
    values either makes the test fragile or forces the introduction of a huge margin
    of error, which may effectively defeat the purpose of testing.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot even mock the generated data (as we did in the case of unit testing)
    because we are at the integration stage and have to use the real data.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution would be to store the incoming real data and the result
    our application produced along with them in the database. Then, a domain specialist
    can walk through each record and assert whether the results are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we introduced a boolean switch in the `TrafficDensity` class,
    so it records the input along with each unit of the calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We have also introduced a static property to keep the same database connection
    across all the class instances. Otherwise, the connection pool should be very
    big because, as you may recall from [Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml), *Concurrent
    and Multithreaded Programming*, the number of workers that execute the task in
    parallel grows with the growth of the amount of work to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at `DbUtils`, you will see a new method that creates the `data` table
    (designed to hold `TrafficUnits` coming from `FactoryTraffic`) and the `data_common` table
    that keeps the main parameters used for data requests and calculations: requested
    traffic units'' number, the date and geolocation of the traffic data, time in
    seconds (the point when the speed is calculated), and the speed limit for each
    lane (its size defines how many lanes we plan to use while modeling the traffic).
    Here is the code that we configure to do the recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After the recording is completed, we can turn the data over to a domain specialist
    who can assert the correctness of the application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verified data can now be used for integration testing. We can add another
    switch to `FactoryTrafficUnit` and force it to read the recorded data instead
    of the unpredictable real or generated ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed, we have also added method `isEnoughData()` that checks
    whether there is enough recorded data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will help avoid the unnecessary frustration of debugging the test problem,
    especially in the case of testing a more complex system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can predict not only the input data, but also the expected results that
    we can use to assert the application behavior. Both are now included in the `TrafficUnit`
    object. To be able to do this, we took advantage of the new Java interface feature
    discussed in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast Track
    to OOP - Classes and Interfaces*, which is the default method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can attach the result to the input data. See the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can attach the result to the `DbUtil` class and the `TrafficUnitImpl` class inside `DbUtil`
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We can attach it inside the `DbUtil` class too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write an integration test. First, we will test the speed model using
    the recorded data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: A similar test can be written for testing the speed calculation of the `AverageSpeed`
    class with real data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can write an integration test for the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar code can be written for the class level testing of class `TrafficDensity` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write the integration test for the subsystem level as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: All of them can be run successfully now and may be used for application regression
    testing any time later.
  prefs: []
  type: TYPE_NORMAL
- en: An automated integration test between our application and the source of the
    real traffic data can be created only if the latter has a test mode from where
    the same flow of data can be sent our way so we can use them in the same manner
    we use recorded data (which is essentially the same thing).
  prefs: []
  type: TYPE_NORMAL
- en: One parting thought. All of this integration testing is possible when the amount
    of processing data is statistically significant. This is because we do not have
    full control over the number of workers and how the JVM decides to split the load.
    It is quite possible that on a particular occasion, the provided code would not
    work. In such a case, try to increase the number of requested traffic units. This
    will ensure more space for the load-distributing logic.
  prefs: []
  type: TYPE_NORMAL
