- en: Sunago - A Social Media Aggregator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sunago - 社交媒体聚合器
- en: For our next project, we'll try something a bit more ambitious; we'll build
    a desktop application that aggregates data from various social media networks
    and displays it in one seamless interaction. We're also going to try something
    new, and we're going to give this project a name, something that might be a bit
    more appealing than the dry, albeit accurate, `description-turned-name` that we've
    used to date. This application, then, we'll call Sunago, which is the phonetic
    spelling of the (Koine) Greek word συνάγω, which means **I gather together**,
    **collect**, **assemble**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个项目，我们将尝试做一些更具雄心的事情；我们将构建一个桌面应用程序，该程序从各种社交媒体网络中聚合数据，并在一次无缝交互中显示。我们还将尝试一些新事物，并给这个项目起一个名字，这个名字可能比我们迄今为止使用的干燥、尽管准确、但略显无趣的`描述转变为名称`更具吸引力。因此，这个应用程序，我们将称之为Sunago，这是古希腊词（Koine）συνάγω的音译，其意为**我聚集在一起**、**收集**、**集合**。
- en: 'Building the app will cover several different topics, some familiar, some new.
    That list includes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序将涵盖几个不同的主题，有些熟悉，有些新颖。该列表包括以下内容：
- en: JavaFX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: Internationalization and localization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: '**Service Provider Interfaces** (**SPI**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务提供者接口**（**SPI**）'
- en: REST API consumption
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费REST API
- en: '`ClassLoader` manipulation'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassLoader`操作'
- en: Lambdas, lambdas, and more lambdas
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda，Lambda，还有更多的Lambda
- en: As usual, those are the just the highlights with a number of interesting items
    sprinkled throughout.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，这些只是亮点，其中穿插着许多有趣的项目。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'As with every application, before we get started, we need to think about what
    we want the application to do. That is, what are the functional requirements?
    At a high level, the description tells us what we want to achieve in broad terms,
    but, more specifically, we want the user to be able to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个应用程序一样，在我们开始之前，我们需要考虑我们希望应用程序做什么。也就是说，功能需求是什么？从高层次上讲，描述告诉我们我们希望以广泛的方式实现什么，但更具体地说，我们希望用户能够做到以下事情：
- en: Connect to several different social media networks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到几个不同的社交媒体网络
- en: Determine, on a network-by-network basis, which group of data (users, lists,
    and more) to retrieve
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络层面上确定要检索哪组数据（用户、列表等）
- en: See list of items from each network in a consolidated display
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在综合显示中查看每个网络的项目列表
- en: Be able to determine from which network an item came
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够确定项目来自哪个网络
- en: Click on an item and have it loaded in the user's default browser
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击一个项目，并在用户的默认浏览器中加载它
- en: 'In addition to this list of things the application **should** do, the things
    it **shouldn''t** do include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个应用程序**应该**做的事情的列表之外，它**不应该**做的事情包括以下内容：
- en: Respond/reply to items
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对项目进行回应/回复
- en: Comment on items
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对项目进行评论
- en: Manage friends/following lists
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理朋友/关注列表
- en: These features would be great additions to the application, but they don't offer
    much that would be architecturally interesting beyond the basic application detailed
    previously, so, to keep things simple--and moving along--we'll limit the scope
    to the given basic set of requirements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能将是应用程序的绝佳补充，但它们在基本应用程序的架构上并没有提供太多有趣的东西，所以为了保持简单——并且继续前进——我们将范围限制在给定的基本需求集。
- en: 'So where to start on the application? As in the previous chapters, we''re going
    to make this a desktop application, so let''s start there, with a JavaFX application.
    I''m going to tip my hand a little bit here to make things easier later on: this
    will be a multi-module project, so we first need to create the parent project.
    In NetBeans, click on File | New Project..., and select the `Maven` category,
    as seen in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在应用程序中从哪里开始呢？就像前面的章节一样，我们将将其制作为一个桌面应用程序，所以让我们从这里开始，从JavaFX应用程序开始。我将在这里透露一点，以便稍后更容易：这将是一个多模块项目，因此我们首先需要创建父项目。在NetBeans中，点击文件
    | 新建项目...，然后选择`Maven`类别，如下面的截图所示：
- en: '![](img/56038160-c5e4-4c2f-8385-9ba0b50630bc.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56038160-c5e4-4c2f-8385-9ba0b50630bc.png）'
- en: 'Click on the Next button, and fill in the project details, as shown next:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮，填写项目详细信息，如下所示：
- en: '![](img/6cca6c4d-c2cc-4735-bfed-a885dbeaff0f.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cca6c4d-c2cc-4735-bfed-a885dbeaff0f.png)'
- en: 'When you click on Finish, you will be presented with an empty project. Once
    we add modules to this project, differentiating them might become difficult, so
    something I do as a matter of practice is to give each module a distinct, "namespaced"
    name. That is to say, each module has its own name, of course, but I prefix that
    with the name of the project. For example, since this is the base POM of the project,
    I call it `Master`. To reflect that, I modify the generated POM to look something
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“完成”时，你会看到一个空项目。一旦我们向这个项目添加模块，区分它们可能会变得困难，所以我作为一个习惯的做法是给每个模块一个独特、具有“命名空间”的名称。也就是说，每个模块都有自己的名称，当然，但我会在其前面加上项目的名称。例如，由于这是项目的基
    POM，我称之为 `Master`。为了反映这一点，我修改了生成的 POM，使其看起来像这样：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There''s really not much to this yet. The advantage that a parent POM like
    this gives us is that we can build all the projects with one command if we so
    desire, and we can move any shared configuration to this shared parent POM to
    reduce duplication. What we need to add now, though, is a module, which NetBeans
    helps us do, as seen in this screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这还没有什么。像这样的父 POM 给我们的优势是，如果我们愿意，我们可以用一个命令构建所有项目，并且我们可以将任何共享配置移动到这个共享父 POM
    中以减少重复。不过，我们现在需要添加一个模块，NetBeans 会帮助我们做到这一点，如截图所示：
- en: '![](img/84fdf68c-0c59-4b1c-804b-535a4242ccaa.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84fdf68c-0c59-4b1c-804b-535a4242ccaa.png)'
- en: After clicking on Create New Module..., you will be presented with the familiar
    New Project window, from which you'll want to select Maven | JavaFX Application,
    and click on Next. In the New Java Application screen, enter `app` for the project
    name, and click on Finish (all of the other defaults are acceptable as-is).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击“创建新模块...”后，你会看到一个熟悉的“新建项目”窗口，从那里你需要选择 Maven | JavaFX 应用程序，然后点击“下一步”。在“新建
    Java 应用程序”屏幕中，输入 `app` 作为项目名称，然后点击“完成”（所有其他默认值都可以接受）。
- en: 'Again, we want to give this module a meaningful name, so let''s modify the
    generated `pom.xml` as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们希望给这个模块一个有意义的名称，所以让我们按照以下方式修改生成的 `pom.xml`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When NetBeans creates the project, it will generate several artifacts for us--two
    classes, `FXMLController` and `MainApp`, as well as the resources, `fxml/Scene.xml`
    and `styles/Styles.css`. While this may be stating the obvious, artifacts should
    have names that clearly communicate their purpose, so let's rename these.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当 NetBeans 创建项目时，它会为我们生成几个工件——两个类，`FXMLController` 和 `MainApp`，以及资源，`fxml/Scene.xml`
    和 `styles/Styles.css`。虽然这可能是显而易见的，但工件应该有能够清楚地传达其目的的名称，所以让我们重命名这些。
- en: The class `FxmlContoller` should be renamed to `SunagoController`. Perhaps the
    quickest and easiest way to do this is to open the class by double-clicking on
    it in Project View, then, in the source editor, click on the name of the class
    in the class declaration, and press *Ctrl* + *R*. The Rename Class dialog should
    appear, in which you need to enter the new name, and press *Enter*. This will
    rename the class and the file for you. Now repeat that process for `MainApp`,
    renaming it to `Sunago`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `FxmlContoller` 应该重命名为 `SunagoController`。可能最快、最简单的方法是在项目视图中双击打开它，然后在源编辑器中点击类声明中的类名，并按
    *Ctrl* + *R*。应该会出现重命名类的对话框，在那里你需要输入新名称，然后按 *Enter*。这将为你重命名类和文件。现在重复这个过程，将 `MainApp`
    重命名为 `Sunago`。
- en: We also want to rename the generated FXML file, `Scene.xml`, to `sunago.fxml`.
    To do that, right-click on the file in Project View and select Rename... from
    the context menu. Enter the new name (without the extension) in the Rename dialog,
    and press *Enter*. While we're at it, let's also rename `Styles.css` to `styles.css`
    so that the case is consistent. It's a minor thing, but consistency in the code
    can help produce confidence in you in whoever might take over your code in the
    future.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将生成的 FXML 文件，`Scene.xml`，重命名为 `sunago.fxml`。要做到这一点，请在项目视图中右键单击文件，并在上下文菜单中选择“重命名...”。在重命名对话框中输入新名称（不带扩展名），然后按
    *Enter*。在此期间，我们还可以将 `Styles.css` 重命名为 `styles.css`，以确保大小写一致。这是一件小事，但代码的一致性可以帮助你在未来有人接管你的代码时增强信心。
- en: 'Unfortunately, renaming these files doesn''t adjust the references to them
    in the Java sources, so we need to edit `Sunago.java` to point to these new names,
    which is done as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，重命名这些文件并不会调整 Java 源中对它们的引用，所以我们需要编辑 `Sunago.java` 来指向这些新名称，操作方法如下：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note also that we changed the title to something more appropriate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还把标题改成了更合适的内容。
- en: Setting up the user interface
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户界面
- en: If we wanted to, we could now run our application. It would be very boring,
    but it would run. Let's try to fix the boring part.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，现在就可以运行我们的应用程序。这会很无聊，但它会运行。让我们试着解决无聊的部分。
- en: 'The default FXML created is just an AnchorPane with two children, a Button
    and a Label. We don''t need any of those, so let''s get rid of them. Our main
    user interface will be pretty simple--basically, just a vertical stack of components--so
    we can use a VBox as our root component. Perhaps, the easiest way to change the
    root component from the AnchorPane that''s there to a VBox is to use Scene Builder
    to wrap that component in a VBox, and then delete the AnchorPane:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认创建的FXML只是一个带有两个子组件的AnchorPane，一个按钮（Button）和一个标签（Label）。我们不需要这些，所以让我们去掉它们。我们的主要用户界面将会非常简单——基本上，只是一个组件的垂直堆叠——因此我们可以使用VBox作为我们的根组件。也许，将根组件从现有的AnchorPane更改为VBox的最简单方法就是使用Scene
    Builder将此组件包裹在VBox中，然后删除AnchorPane：
- en: '![](img/e5b12b35-a9e4-4b92-a7df-597c36cda218.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5b12b35-a9e4-4b92-a7df-597c36cda218.png)'
- en: To do that, open the FXML file in Scene Builder by double-clicking on the file
    (assuming you've configured NetBeans correctly so that it knows where to find
    Scene Builder. If not, refer back to [Chapter 17](ef175826-d02f-448f-b68e-5e3d03402bd0.xhtml),
    *Introduction*). In Scene Builder, right-click on AnchorPane in the Document section
    of the accordion on the left, select Wrap in, and then VBox, as shown in the preceding
    screenshot. Scene Builder will then modify the FXML file, making AnchorPane a
    child of VBox as expected. Once that's done, you can right-click on AnchorPane,
    and click on Delete to remove it and its children. This leaves us with an empty
    user interface that's more boring than it was when we began. We can fix that now
    by adding a couple of controls--a MenuBar and a ListView. We do that by clicking
    on each component in the Controls section of the accordion and dragging them to
    VBox. If you drop the components on VBox, they will be appended to its list of
    children. Make sure that MenuBar comes before ListView, or you'll have a very
    strange user interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，通过双击文件（假设您已正确配置NetBeans，使其知道Scene Builder的位置）在Scene Builder中打开FXML文件。在Scene
    Builder中，在左侧折叠面板的文档部分右键单击AnchorPane，选择“包裹”（Wrap in），然后选择VBox，如前面的截图所示。然后Scene
    Builder将修改FXML文件，使AnchorPane成为VBox的子组件，正如预期的那样。完成之后，您可以在AnchorPane上右键单击，然后点击“删除”以删除它及其子组件。这将给我们留下一个比我们开始时更无聊的空用户界面。现在我们可以通过添加一些控件——一个菜单栏（MenuBar）和一个列表视图（ListView）——来修复它。通过在折叠面板的控件部分单击每个组件并将它们拖动到VBox中来实现这一点。如果您将组件放在VBox上，它们将被添加到其子组件列表中。确保菜单栏（MenuBar）在列表视图（ListView）之前，否则您将得到一个非常奇怪的界面。
- en: Let's configure these components a bit now before we return to the code. Selecting
    VBox from the Document section on the left, we then need to select the Layout
    section in the accordion on the right. For Min Width and Min Height, enter `640`
    and `480` respectively. This will make the window's default size larger and more
    user-friendly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们返回代码之前，现在让我们先配置这些组件。在左侧的文档部分选择VBox，然后我们需要在右侧的折叠面板中选择布局部分。对于最小宽度（Min Width）和最小高度（Min
    Height），分别输入`640`和`480`。这将使窗口的默认尺寸更大，更用户友好。
- en: For MenuBar, we need to expand its entry under Document, then expand each of
    its Menu children, which should reveal one MenuItem per Menu. Click on the first
    Menu, then, on the right, set `Text` to `_File`, and check Mnemonic Parsing. This
    will allow the user to press *Alt* + *F* to activate (or show) this menu. Next,
    click on its `MenuItem` child, setting `Text` to `_Exit`, and check Mnemonic Parsing.
    (If the text for a `Menu`, `MenuItem`, `Button`, and more has an underscore in
    it, make sure that Mnemonic Parsing is checked. For brevity's sake, I won't flag
    this explicitly again.) Open the Code section, and set the On Action value to
    `closeApplication`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于菜单栏（MenuBar），我们需要展开其“文档”（Document）下的条目，然后展开其每个菜单子项（Menu children），这样每个菜单（Menu）都应该显示一个菜单项（MenuItem）。点击第一个菜单，然后在右侧，将“文本”（Text）设置为`_File`，并勾选“快捷键解析”。这将允许用户按下*Alt*
    + *F*来激活（或显示）此菜单。接下来，点击其`MenuItem`子项，将“文本”（Text）设置为`_Exit`，并勾选“快捷键解析”。（如果`Menu`、`MenuItem`、`Button`等文本中包含下划线，请确保已勾选“快捷键解析”。为了简洁起见，我不会再次明确指出这一点。）打开代码部分，并将“动作”（On
    Action）值设置为`closeApplication`。
- en: The second `Menu` should have its Text value set to `_Edit`. Its `MenuItem`
    should be labeled `_Settings`, and have an On Action value of `showPreferences`.
    Finally, the third `Menu` should be labeled `_Help`, and its `MenuItem` labeled
    `About` with an On Action of `showAbout`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Menu`应该将其文本值设置为`_Edit`。其`MenuItem`应标记为`_Settings`，并具有`showPreferences`的操作值。最后，第三个`Menu`应标记为`_Help`，其`MenuItem`标记为`About`，操作值为`showAbout`。
- en: Next, we want to give `ListView` an ID, so select that on the left, make sure
    the Code section is expanded on the right, and enter `entriesListView` for fx:id.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要给`ListView`一个ID，所以选择左侧的它，确保右侧的代码部分已展开，并输入`entriesListView`作为fx:id。
- en: The last edit we need to make is to set the controller. We do that in the accordion
    on the left, in the Controller section at the very bottom. Expand that, and make
    sure that the Controller class value matches the Java class and package we just
    created in NetBeans, then save the file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的编辑是将控制器设置好。我们在左侧的折页中这样做，在底部的控制器部分，然后展开它，确保控制器类值与我们在NetBeans中刚刚创建的Java类和包相匹配，然后保存文件。
- en: Setting up the controller
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置控制器
- en: 'Back in NetBeans, we need to fix up our controller to reflect the changes we
    just made in our FXML. In `SunagoController`, we need to add the `entriesListView`
    property as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回到NetBeans，我们需要调整我们的控制器以反映我们在FXML中刚刚做出的更改。在`SunagoController`中，我们需要添加`entriesListView`属性，如下所示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that the parameterized type is `SocialMediaItem`. That''s a custom model
    we''ll create in just a few moments. Before we tackle that, though, we need to
    finish wiring together our user interface. We defined three `onAction` handlers
    in the FXML. The corresponding code is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数化类型是`SocialMediaItem`。这是我们将在接下来的几分钟内创建的自定义模型。在我们着手处理之前，我们需要完成用户界面的连接。我们在FXML中定义了三个`onAction`处理程序。相应的代码如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Closing the application is as simple as calling the `exit` method on the `Platform`
    class. Showing the "about" box is also fairly simple, as we see in the `showAbout`
    method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭应用程序就像在`Platform`类上调用`exit`方法一样简单。显示“关于”框也相当简单，正如我们在`showAbout`方法中看到的：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the built-in `Alert` class, we construct an instance, and set the values
    appropriate for an About screen, then display it modally via `showAndWait()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`Alert`类，我们构建一个实例，并设置适合关于屏幕的值，然后通过`showAndWait()`以模态方式显示它。
- en: The preferences window is a much more complicated piece of logic, so we wrap
    that up in a new controller class, and call its `showAndWait()` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 预设窗口的逻辑要复杂得多，因此我们将其封装在一个新的控制器类中，并调用其`showAndWait()`方法。
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Writing the model class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模型类
- en: 'Before we look at that, though, there are a few more items in the main controller
    that we need to take care of. The first is the model class mentioned earlier,
    `SocialMediaItem`. As you can probably imagine, the structure of the data returned
    from a social network can be quite complex, and certainly, varied. The data requirements
    for a tweet, for example, are likely to be quite different from those for an Instagram
    post. What we''d like to be able to do, then, is to hide those complexities and
    differences behind a simple, reusable interface. In the real world, such a simple
    abstraction is not always possible, but, for our purposes here, we have such an
    interface in `SocialMediaItem`, as you can see in this piece of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看它之前，主控制器中还有一些其他的项目需要我们处理。首先是之前提到的模型类，`SocialMediaItem`。正如你可能想象的那样，从社交网络返回的数据结构可能相当复杂，并且肯定多种多样。例如，推文的资料需求可能与Instagram帖子的需求大不相同。因此，我们希望能够在简单、可重用的接口后面隐藏这些复杂性和差异。在现实世界中，这样的简单抽象并不总是可能的，但在这里，我们有一个这样的接口在`SocialMediaItem`中，正如你在这段代码中可以看到的：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One of the problems with abstractions is that, to make them reusable, you, occasionally,
    have to structure them in such a way that they expose properties that may not
    be used by every implementation. It's not obvious yet, but that is certainly the
    case here. It's a scenario that some consider to be unacceptable, and they may
    have a point, but it's really a question of trade-offs. Our options include a
    slightly bloated interface or a complex system in which each network support module
    (which we'll get to shortly) provides its own renderer, and the application has
    to interrogate each module, looking for the renderer that can handle each item
    while drawing `ListView`. There are likely others, of course, but faced with (at
    least) those two, for the sake of simplicity and performance, we'll take the first
    option. When faced with similar situations while designing your own systems, though,
    you'll need to evaluate the various requirements of your project, and make an
    appropriate choice. For our needs here, the simple approach is more than adequate.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的一个问题是，为了使它们可重用，你偶尔必须以某种方式结构化它们，以便它们暴露出可能不被每个实现使用的属性。这还不明显，但这里确实是这样。这是有些人认为不可接受的情况，他们可能是有道理的，但这实际上是一个权衡的问题。我们的选择包括一个略微膨胀的接口或一个复杂的系统，其中每个网络支持模块（我们将在稍后讨论）提供自己的渲染器，并且应用程序必须查询每个模块，寻找可以处理每个项目的渲染器，同时在绘制`ListView`。当然，可能还有其他选择，但面对（至少）那两个，为了简单和性能，我们将选择第一个选项。然而，在设计你自己的系统时遇到类似情况时，你需要评估你项目的各种要求，并做出适当的选择。对于我们的需求，简单的方法已经足够了。
- en: 'At any rate, each social media network module will implement that interface
    to wrap its data. This will give a common interface for the application to consume
    without needing to know exactly where it came from. We do, though, now need to
    tell the `ListView` how to draw a cell containing a `SocialMediaItem`. We can
    do that with this line of code in the `initialize()` method of our controller,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，每个社交媒体网络模块都将实现该接口来封装其数据。这将给应用程序提供一个通用的接口，以便消费，而无需确切知道它来自何处。然而，我们现在需要告诉`ListView`如何绘制包含`SocialMediaItem`的单元格。我们可以通过在控制器的`initialize()`方法中添加以下代码行来实现这一点，如下所示：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Obviously, that''s a lambda. For the curious, the pre-lambda version of the
    preceding method would look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，那是一个lambda表达式。对于好奇的人，前面方法的lambda版本看起来像这样：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finishing up the controller
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成控制器
- en: 'Before we look at `SocialMediaItemViewCell`, there are two more controller
    items. The first is the list that holds the `ListView` data. Remember that `ListView`
    operates from an `ObservableList`. This lets us make changes to the data in the
    list, and have it automatically reflected in the user interface. To create that
    list, we''ll use a JavaFX helper method when we define the class property as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`SocialMediaItemViewCell`之前，还有两个控制器项目。第一个是包含`ListView`数据的列表。记住，`ListView`从`ObservableList`操作。这使得我们可以更改列表中的数据，并且它将自动反映在用户界面中。为了创建该列表，我们将在定义类属性时使用JavaFX辅助方法，如下所示：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we need to connect that `List` to our `ListView`. Back in `intialize()`,
    we have the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将那个`List`连接到我们的`ListView`。回到`initialize()`，我们有以下内容：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To finish off the rendering of `SocialMediaItem` interfaces, let''s define
    `SocialMediaItemViewCell` like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成`SocialMediaItem`接口的渲染，让我们这样定义`SocialMediaItemViewCell`：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's a fair amount happening here, but `updateItem()` is our first point
    of interest. This is the method that is called every time the row is updated on
    the screen. Notice that we check to see if `item` is null. We do that because
    `ListView` calls this method not for every item in its `List`, but for every row
    in `ListView` that's visible, whether there's data for it or not. That means that,
    if `List` has five items but `ListView` is tall enough to show ten rows, this
    method will be called ten times, with the last five calls being made with a null
    `item`. In those cases, we call `setGraphic(null)` to clear out any item that
    may have been previously rendered.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，但`updateItem()`是我们关注的第一个点。这是每次屏幕上行的更新都会调用的方法。注意，我们检查`item`是否为null。我们这样做是因为`ListView`调用此方法不是针对其`List`中的每个项目，而是针对`ListView`中每个可见的行，无论是否有数据。这意味着，如果`List`有五个项目，但`ListView`足够高以显示十行，则此方法将被调用十次，最后五次调用将使用null的`item`。在这些情况下，我们调用`setGraphic(null)`来清除可能之前已渲染的任何项目。
- en: If `item` is not null, though, we need to build the `Node` to display the item,
    which is done in `buildItemCell()`. For each item, we want to render three items--the
    social media network icon (so users can tell at a glance where the item is from),
    any image embedded in the item, and, finally, any text/caption from the item.
    To help arrange that, we start with an `HBox`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `item` 不为空，我们需要构建用于显示项目的 `Node`，这通过 `buildItemCell()` 完成。对于每个项目，我们希望渲染三个项目——社交媒体网络图标（这样用户可以一眼看出项目来自哪里），项目内嵌入的任何图像，以及最后，项目中的任何文本/标题。为了帮助安排这些，我们从一个
    `HBox` 开始。
- en: Next, we try to find an icon for the network. If we had a formal contract written
    up, we would include language in it that would stipulate that the module include
    a file called `icon.png`, which is in the same package as the module's `SocialMediaItem`
    implementation. Using the `ClassLoader` for the implementation, then, we try to
    get an `InputStream` for the resource. We check for null, just to make sure the
    image was actually found; if so, we create an `ImageView`, set some properties,
    then wrap the resource in an `Image`, hand that to `ImageView`, then add `ImageView`
    to `HBox`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试找到一个网络图标。如果我们有一个正式的合同，我们会在其中包含一些语言，规定模块应包含一个名为 `icon.png` 的文件，该文件与模块的
    `SocialMediaItem` 实现位于同一包中。然后，使用实现用的 `ClassLoader`，我们尝试获取资源的 `InputStream`。我们检查
    null，只是为了确保实际上找到了图像；如果是这样，我们创建一个 `ImageView`，设置一些属性，然后将资源包裹在一个 `Image` 中，将其交给
    `ImageView`，然后将 `ImageView` 添加到 `HBox`。
- en: Adding an image for the item
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目添加图像
- en: If the item has an image, we handle it in the same way that we did with the
    network icon image. This time, though, we actually wrap the `ImageView` in another
    `HBox` before adding it to the outer `HBox`. We do that so that we can add padding
    around the image (via `picture.setPadding(new Insets()`) to give this image some
    space between it and the network icon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目有一个图像，我们以与网络图标图像相同的方式处理它。不过，这次我们在将其添加到外部的 `HBox` 之前，实际上是将 `ImageView` 包裹在一个另一个
    `HBox` 中。我们这样做是为了可以在图像周围添加填充（通过 `picture.setPadding(new Insets()`)），给这个图像和网络图标之间留出一些空间。
- en: Finally, we create a `Label` to hold the item's body. We set the font size of
    the text to `20` points via `label.setFont(Font.font(null, 20))`, and add it to
    our `HBox`, which we then return to the caller, `updateItem()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 `Label` 来持有项目的主体。我们通过 `label.setFont(Font.font(null, 20))` 将文本的字体大小设置为
    `20` 点，并将其添加到我们的 `HBox` 中，然后将其返回给调用者 `updateItem()`。
- en: Any time you have a `ListView`, you are likely going to want a custom `ListCell`
    implementation like we have here. In some cases, calling `toString()` on the `List`
    contents might be appropriate, but that's not always the case, and you certainly
    can't have a complex `ListCell` structure like we have here without implementing
    `ListCell` yourself. If you're planning on doing much JavaFX development, you
    would be well advised to get comfortable with this technique.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每次当你有一个 `ListView` 时，你很可能会想要一个自定义的 `ListCell` 实现，就像我们这里所做的那样。在某些情况下，在 `List`
    内容上调用 `toString()` 可能是合适的，但并不总是如此，而且你当然不能像我们这里这样拥有一个复杂的 `ListCell` 结构，而不自己实现 `ListCell`。如果你计划进行大量的
    JavaFX 开发，那么熟悉这项技术是非常明智的。
- en: Building the preferences user interface
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建首选项用户界面
- en: 'We''re finally **finished** with the main controller, and we can turn our attention
    to the next big piece, `PreferencesController`. Our preferences dialog will be,
    as is usually expected, a modal dialog. It will offer a tabbed interface with
    one tab for general settings, then a tab for each supported social network. We
    start that work by adding a new FXML file and controller to our project, and NetBeans
    has a great wizard for that. Right-click on the desired package, and click on
    New | Other. From the Categories list, select `JavaFX`, and then, from the File
    Types lists, select `Empty FXML` as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终完成了主要控制器，现在我们可以将注意力转向下一个大块，`PreferencesController`。我们的首选项对话框将像通常预期的那样是一个模态对话框。它将提供一个带有标签页的界面，其中一个标签页用于常规设置，然后为每个受支持的社会网络提供一个标签页。我们通过向我们的项目中添加一个新的
    FXML 文件和控制器来开始这项工作，NetBeans 有一个很好的向导来完成这个任务。在所需的包上右键单击，然后点击新建 | 其他。从类别列表中，选择 `JavaFX`，然后从文件类型列表中选择
    `Empty FXML`，如以下截图所示：
- en: '![](img/d02c92bc-117c-466b-be35-293fbe47bdd3.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d02c92bc-117c-466b-be35-293fbe47bdd3.png)'
- en: 'After clicking on Next, you should see the FXML Name and Location step. This
    will allow us to specify the name of our new file and the package in which it
    is created, as seen in this screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步后，你应该会看到 FXML 名称和位置步骤。这将允许我们指定新文件的名字和创建它的包，如以下截图所示：
- en: '![](img/a4da3802-8d3c-4b9e-98d8-cf745ab59519.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4da3802-8d3c-4b9e-98d8-cf745ab59519.png)'
- en: 'Clicking on Next brings us to the Controller Class step. Here we can either
    create a new controller class, or attach our file to an existing one. Since this
    is a new dialog/window for our app, we need to create a new controller as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”将带我们进入控制器类步骤。在这里，我们可以创建一个新的控制器类，或者将我们的文件附加到现有的一个上。由于这是一个我们应用的新对话框/窗口，我们需要创建一个新的控制器，如下所示：
- en: '![](img/fdfc4f37-25ae-4350-bcf3-452f3f512432.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdfc4f37-25ae-4350-bcf3-452f3f512432.png)'
- en: Check the Use Java Controller checkbox, enter `PreferencesController` for the
    name, and select the desired package. We could click on Next, which would take
    us to the Cascading Style Sheet step, but we're not interested in specifying that
    for this controller, so, we end the wizard by clicking on Finish, which will take
    us to the source of our newly created controller class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“使用Java控制器”复选框，输入“PreferencesController”作为名称，并选择所需的包。我们可以点击“下一步”，这将带我们进入层叠样式表步骤，但我们对此控制器不感兴趣，所以，我们通过点击“完成”结束向导，这将带我们到我们新创建的控制器类的源代码。
- en: Let's start by laying out the user interface. Double-click on the new `prefs.fxml`
    file to open it in Scene Builder. Like our last FXML file, the default root element
    is AnchorPane. For this window, we'd like to use a BorderPane, so we use the same
    technique that we did last time to replace AnchorPane--right-click on the component,
    and click on Wrap in | BorderPane. The AnchorPane is now nested in BorderPane,
    so we right-click on it again and select Delete.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从布局用户界面开始。双击新的`prefs.fxml`文件，在Scene Builder中打开它。像我们上一个FXML文件一样，默认的根元素是AnchorPane。对于这个窗口，我们希望使用BorderPane，所以我们使用上次同样的技术来替换AnchorPane--右键单击组件，然后点击“包裹在
    | BorderPane”。AnchorPane现在嵌套在BorderPane中，所以我们再次右键单击它并选择删除。
- en: To build the user interface, we now drag a TabPane control from the accordion
    on the left, and drop it in the CENTER area of BorderPane. This will add a TabPane
    with two tabs to our user interface. We only want one right now, so delete the
    second one. We want to give our tab a meaningful label. We can do that by double-clicking
    on the tab in the preview window (or selecting the Text property in the Properties
    section of the Inspector) and typing `General`. Finally, expand the Inspector's
    Code section, and enter `tabPane` for fx:id.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建用户界面，我们现在从左侧的折叠面板中拖动一个TabPane控件，并将其放入BorderPane的中心区域。这将向我们的用户界面添加一个带有两个标签的TabPane。我们现在只需要一个，所以删除第二个。我们希望给标签一个有意义的名称。我们可以通过在预览窗口中双击标签（或在检查器的属性部分选择文本属性）并输入“通用”来实现。最后，展开检查器的代码部分，输入`tabPane`作为fx:id。
- en: Now we need to provide a means by which the user can close the window, and either
    save or discard changes. We implement that by dragging a ButtonBar component to
    our border pane's BOTTOM area. That will add a ButtonBar with one button, but
    we need two, so we drag another button on to the ButtonBar. The nice thing about
    this control is that it will handle button placement and padding for us, so, when
    we drop the new button, it's automatically added in the proper place on the right.
    (This behavior can be overridden, but it works exactly how we want it to, so we
    can just accept the defaults.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要提供一个用户可以关闭窗口并保存或丢弃更改的方法。我们通过将ButtonBar组件拖到我们的border pane的底部区域来实现这一点。这将添加一个带有单个按钮的ButtonBar，但我们需要两个，所以我们将另一个按钮拖到ButtonBar上。这个控件的好处是它会为我们处理按钮位置和填充，所以，当我们放下新按钮时，它将自动添加到正确的右侧位置。（这种行为可以被覆盖，但它工作得正好符合我们的要求，所以我们只需接受默认设置。）
- en: For each `Button`, we need to set three properties--`text`, `fx:id`, and `onAction`.
    The first property is in the Properties section of the inspector, and the last
    two in the Code section. The values for the first button are `Save`, `savePrefs`,
    and `savePreferences`. For the second button, the values are `Cancel`, `cancel`,
    and `closeDialog`. Select the Layout section for the `ButtonBar` in the inspector,
    and set the right padding to 10 to make sure `Button` is not pressed against the
    edge of the window.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个“按钮”，我们需要设置三个属性--`text`、`fx:id`和`onAction`。第一个属性在检查器的属性部分，最后两个在代码部分。第一个按钮的值是“保存”、“savePrefs”和“savePreferences”。对于第二个按钮，值是“取消”、“cancel”和“closeDialog”。在检查器中选择“ButtonBar”的布局部分，并将右填充设置为10，以确保“按钮”不会压在窗口的边缘上。
- en: Finally, we'll add our only preference at this point. We want to allow the user
    to specify the maximum number of items to retrieve from each social media network
    for a given request. We do that for those scenarios where the application hasn't
    been used in a while (or ever). In those cases, we don't want to try to download,
    for example, thousands of tweets. To add support for this, we add two controls,
    `Label` and `TextField`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加我们目前唯一的偏好设置。我们希望允许用户指定从每个社交媒体网络获取的请求的最大项目数。对于那些应用程序已经有一段时间（或从未）未被使用的情况，我们这样做。在这些情况下，我们不想尝试下载成千上万的推文。为了支持这一点，我们添加了两个控件，`Label`
    和 `TextField`。
- en: 'Getting the position of the Label control right is pretty simple, as it''s
    the first component. Scene Builder will provide red guidelines to help you position
    the component exactly where you want it, as shown in this screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 获取标签控件的位置相当简单，因为它是第一个组件。Scene Builder 将提供红色指南线来帮助你将组件精确地放置到你想要的位置，如图所示：
- en: '![](img/c774516b-5875-403b-8295-dd116fa47675.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c774516b-5875-403b-8295-dd116fa47675.png)'
- en: Making sure that `TextField` is lined up with the label can be trickier. By
    default, when you drop a component on TabPane, Scene Builder will add an AnchorPane
    to hold the new components. An HBox might be a better choice, but we'll go ahead
    and use AnchorPane to demonstrate this feature of Scene Builder. If you drag a
    TextField onto TabPane and try to position it, you should see more red lines show
    up. Positioned just right, you should see a red line running through the middle
    of the Label and the `TextField`, indicating that the two components are vertically
    aligned. This is what we want, so make sure there is a small space between `TextField`
    and the label and drop it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `TextField` 与标签对齐可能会有些棘手。默认情况下，当你将组件拖放到 TabPane 上时，Scene Builder 会添加一个 AnchorPane
    来容纳新组件。HBox 可能是一个更好的选择，但我们将继续使用 AnchorPane 来演示 Scene Builder 的这个功能。如果你将一个 `TextField`
    拖放到 TabPane 上并尝试定位它，你应该会看到更多的红色线条出现。定位正确时，你应该会看到一条红色线条穿过标签和 `TextField` 的中间，表明两个组件垂直对齐。这正是我们想要的，所以确保
    `TextField` 和标签之间有一个小空间，并将其放下。
- en: We need to give Label some meaningful text, so double-click on it in the preview
    window, and enter `Number of items to retrieve`. We also need to give `TextField`
    an ID so that we can interact with it, so click on the component, expand the Code
    section in the Inspector, and set fx:id to `itemCount`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要给标签一些有意义的文本，所以在预览窗口中双击它，并输入 `Number of items to retrieve`。我们还需要给 `TextField`
    一个 ID，以便我们可以与之交互，所以点击该组件，在检查器中展开代码部分，并将 fx:id 设置为 `itemCount`。
- en: Our user interface, while basic, is now as complete as we can make it here,
    so save the file, close Scene Builder, and return to NetBeans.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户界面虽然基础，但现在我们已经尽可能完善了，所以保存文件，关闭 Scene Builder，并返回到 NetBeans。
- en: Saving user preferences
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存用户偏好
- en: 'To allow our newly-defined user interface to be wired into our controller,
    we need to create instance variables to match the controls with the `fx:id` attributes
    set, so, we add these to `PreferencesController` as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的新定义的用户界面能够连接到我们的控制器，我们需要创建实例变量来匹配控件与设置的 `fx:id` 属性，因此，我们将这些添加到 `PreferencesController`
    中，如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `initialize()` method, we need to add support for loading the saved value
    for our `itemCount` field, so we need to talk a little bit about preferences.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initialize()` 方法中，我们需要为我们的 `itemCount` 字段添加支持加载已保存的值，因此我们需要稍微谈谈偏好设置。
- en: Java, being the general-purpose language that it is, makes it possible to write
    any preference storing strategy that you can image. Fortunately, though, it also
    offers a couple of different standard APIs that allow you to do so in a more easily
    portable manner, those being `Preferences` and `Properties`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Java 作为一种通用语言，使得编写任何你能够想象到的偏好存储策略成为可能。幸运的是，它还提供了一些不同的标准 API，允许你以更易于移植的方式实现，这些是
    `Preferences` 和 `Properties`。
- en: The `java.util.Properties` class has been in the JDK since version 1.0, and
    while its basic, no-frills API might make that obvious, it's still a very useful
    abstraction. At its heart, `Properties` is a `Hashtable` implementation to which
    methods have been added for loading its data from input streams and readers, and
    writing its data to output streams and writers (in addition to a handful of other
    related methods). All the properties are treated as `String` values with `String`
    keys. Since `Properties` is a `Hashtable`, you can still use `put()` and `putAll()`
    to store non-string data, but that will result in `ClassCastException` should
    you call `store()`, so, it's probably best to avoid doing that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Properties`类自JDK 1.0版本以来就存在了，尽管其基本、无装饰的API可能让人一目了然，但它仍然是一个非常有用的抽象。在本质上，`Properties`是一个`Hashtable`实现，其中添加了从输入流和读取器加载数据的方法，以及将数据写入输出流和写入器的方法（除了其他一些相关方法）。所有的属性都被视为带有`String`键的`String`值。由于`Properties`是一个`Hashtable`，您仍然可以使用`put()`和`putAll()`来存储非字符串数据，但如果你调用`store()`，这将导致`ClassCastException`，因此，最好避免这样做。'
- en: The `java.util.prefs.Preferences` class was added in Java 1.4, and it's a much
    more modern API. Whereas with properties we have to handle persistence separately,
    preferences handle that for us opaquely--we don't need to worry about how or when
    it's written. In fact, the call to set a preference may return immediately, while
    the actual persistence may not occur for quite some time. The contract of the
    `Preferences` API guarantees that preferences will be persisted even if the JVM
    shuts down, assuming it's a normal, ordered shutdown (by definition, there's not
    much that can be done if the JVM process suddenly dies).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.prefs.Preferences`类是在Java 1.4中添加的，它是一个更加现代的API。与属性不同，我们必须单独处理持久性，而偏好则为我们隐式地处理了这一点——我们不需要担心它是如何或何时被写入的。实际上，设置偏好的调用可能立即返回，而实际的持久化可能要过一段时间才会发生。`Preferences`
    API的契约保证，即使在JVM关闭的情况下，偏好也会被持久化，前提是这是一个正常、有序的关闭（根据定义，如果JVM进程突然死亡，能做的事情很少）。'
- en: Additionally, the user also need not worry about how preferences are saved.
    The actual backing store is an implementation-specific detail. It could be a flat
    file, an OS-specific registry, a database or some sort of directory server. For
    the curious, the actual implementation is chosen by using the class name, if specified,
    in the `java.util.prefs.PreferencesFactory` system property. If that's not defined,
    the system will look for the file `META-INF/services/java.util.prefs.PreferencesFactory`
    (a mechanism known as SPI, which we will look at in depth later), and use the
    first class defined there. Finally, failing that, the implementation for the underlying
    platform is loaded and used.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户也不必担心如何保存偏好设置。实际的底层存储是一个特定实现的细节。它可能是一个平面文件、特定于操作系统的注册表、数据库或某种目录服务器。对于好奇的人来说，实际的实现是通过在`java.util.prefs.PreferencesFactory`系统属性中指定类名来选择的。如果没有定义，系统将查找文件`META-INF/services/java.util.prefs.PreferencesFactory`（这是一种称为SPI的机制，我们将在稍后深入探讨），并使用那里定义的第一个类。最后，如果这些都失败了，将加载并使用底层平台的实现。
- en: So which to choose? Either will work as well as the other, but you have to decide
    if you want control of where the information is stored (`Properties`) or ease
    of implementation (`Preferences`). To a certain degree, portability might also
    be a concern. For example, if you have Java code running in some sort of a mobile
    or embedded device, you might not have permissions to write to the filesystem,
    and you might not have a filesystem at all. To show how similar the two implementations
    might be, though, we'll implement both.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，应该选择哪一个呢？两者都可以像另一个一样工作，但你必须决定你是否想要控制信息存储的位置（`Properties`）或者实现上的简便（`Preferences`）。在某种程度上，可移植性也可能是一个考虑因素。例如，如果你有在某种移动或嵌入式设备上运行的Java代码，你可能没有权限写入文件系统，甚至可能根本不存在文件系统。为了展示这两个实现可能有多么相似，我们将实现这两个。
- en: 'To put my cards on the table a little bit, I would like for as much of this
    code as possible to be reusable in an Android environment. To help facilitate
    that, we''ll create a very simple interface as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了把我的观点摆得更加清楚，我希望尽可能多的代码可以在Android环境中重用。为了帮助实现这一点，我们将创建一个非常简单的接口，如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We're only dealing with strings and integers, as the needs of the application
    are pretty basic. With the interface defined, how do we get a reference to an
    implementation? For that, we'll use a technique we've already seen mentioned briefly--the
    Service Provider Interface (SPI).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只处理字符串和整数，因为应用的需求相当基础。接口定义好了，我们如何获取实现类的引用？为此，我们将使用我们已经简要提到过的技术——服务提供者接口（SPI）。
- en: Plugins and extensions with the Service Provider Interface
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务提供者接口的插件和扩展
- en: We've already seen SPI mentioned before when we looked at the `Preferences`
    class, and how the implementation is selected and loaded, but what exactly is
    it? The Service Provider Interface is a somewhat generic term for an interface
    that a third party can implement (or a class, abstract or not, that can be extended)
    to provide extra functionality, replace existing components, and more.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 `Preferences` 类以及实现的选择和加载方式时，我们已经提到了 SPI，但具体是什么呢？服务提供者接口是一个相对通用的术语，指的是第三方可以实现的接口（或者一个可以扩展的类，无论是否为抽象类），以提供额外功能、替换现有组件等。
- en: In a nutshell, the author of the target system (for example, the JDK itself
    in our previous example) defines and publishes an interface. Ideally, this system
    would provide a default implementation, but that's not necessary in all cases.
    Any interested third party could then implement this interface, register it, and
    the target system could then load and use it. One of the advantages of this approach
    is that the target system can be extended easily, with no coupling to the third
    party. That is to say, while the third party knows about the target system via
    the interface, the target system has no knowledge at all of the third party. It's
    merely operating off the interface it defined.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，目标系统（例如，在我们之前的例子中就是 JDK 本身）的作者定义并发布了一个接口。理想情况下，这个系统会提供一个默认实现，但在所有情况下这并非必需。任何感兴趣的第三方都可以实现这个接口，注册它，然后目标系统就可以加载并使用它。这种方法的优点之一是目标系统可以很容易地扩展，而不需要与第三方耦合。也就是说，虽然第三方通过接口了解目标系统，但目标系统对第三方一无所知。它只是在操作它定义的接口。
- en: How are these third-party plugins registered with the target system? The third-party
    developer would create a text file using a specific file in a specific directory.
    The file has the same name as the interface being implemented. For the `Preferences`
    class example, one would be implementing the `java.util.prefs.PreferencesFactory`
    interface, so that would be the name of the file, which would be in the `META-INF/services`
    directory in the root of the libraries classpath. In a Maven-based project, the
    file would be found in `src/main/resources/META-INF/services`. The file contains
    just the name of the class implementing the interface. It's also possible to have
    more than one class listed in the services file, each on a new line. It's up to
    the consuming system, though, as to whether or not each of those might be used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些第三方插件是如何在目标系统中注册的？第三方开发者会创建一个文本文件，使用特定目录中的特定文件。文件名与要实现的接口同名。以 `Preferences`
    类的例子来说，将实现 `java.util.prefs.PreferencesFactory` 接口，因此文件名将是这个，它将位于库类路径根目录下的 `META-INF/services`
    目录中。在一个基于 Maven 的项目中，该文件将在 `src/main/resources/META-INF/services` 中找到。文件只包含实现接口的类的名称。服务文件中也可以列出多个类，每个类占一行。但是否使用这些类取决于消费系统。
- en: So what does all of this look like for us? As noted earlier, we're going to
    take a rare opportunity to show multiple implementations for our `Preferences`
    support. Both classes are small enough that we can show the uses of both `Properties`
    and `Preferences`, and use SPI to pick one to use.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对我们来说意味着什么呢？如前所述，我们将难得地展示多个 `Preferences` 支持的实现。这两个类都足够小，我们可以展示 `Properties`
    和 `Preferences` 的用法，并使用 SPI 来选择一个使用。
- en: 'Let''s start with the `Properties`-based implementation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基于 `Properties` 的实现开始：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we start by implementing our `SunagoPreferences` interface.
    We then create an instance of the `Properties` class, and we also define a constant
    for the file name and location, which we put--in a system-independent manner--in
    the user's home directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先实现了我们的 `SunagoPreferences` 接口。然后我们创建了一个 `Properties` 类的实例，我们还定义了一个文件名和位置的常量，我们将它以系统无关的方式放在用户的家目录中。
- en: Resource handling with try-with-resources
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 try-with-resources 处理资源
- en: 'The constructor shows something interesting that we haven''t talked about--try-with-resources.
    Prior to Java 8, you might have written something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数显示了之前没有讨论的有趣之处--try-with-resources。在Java 8之前，你可能写成这样：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This preceding, incredibly verbose code declares an `InputStream` outside the
    try block, then does some work with it in the `try` block. In the `finally` block,
    we try to close the `InputStream`, but we first have to check to see if it's null.
    If, say, the file doesn't exist (as it won't be the first time this class is created),
    an `Exception` will be thrown, and `input` will be null. If it's not null, we
    can call `close()` on it, but that might throw `IOException`, so we have to wrap
    that in a `try/catch` block as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码非常冗长，它在外部声明了一个`InputStream`，然后在`try`块中对其进行一些操作。在`finally`块中，我们尝试关闭`InputStream`，但首先必须检查它是否为null。如果，比如说，文件不存在（这不会是第一次创建此类），将会抛出异常，并且`input`将为null。如果不是null，我们可以在它上面调用`close()`，但那可能会抛出`IOException`，因此我们必须将其包裹在一个`try/catch`块中。
- en: Java 8 introduced the try-with-resources construct that makes this much smaller.
    If an object is an instance of `AutoCloseable`, then it can be defined **inside**
    the `try` declaration, and it will be closed automatically when the `try` block
    scope terminates regardless of whether or not an `Exception` was thrown. That
    allows us to take what would normally be fourteen lines of code, and express the
    exact same functionality in four with much less noise.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了try-with-resources构造，这使得代码更加简洁。如果一个对象是`AutoCloseable`的实例，那么它可以在`try`声明中定义，并且当`try`块的作用域结束时，无论是否抛出`Exception`，它都会自动关闭。这允许我们将原本可能需要十四行代码的功能，用四行代码表达，并且噪音更少。
- en: Aside from `AutoCloseable`, note that we load any existing values in the file
    into our `Properties` instance via `Properties.load(InputStream)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`AutoCloseable`之外，请注意，我们通过`Properties.load(InputStream)`将文件中的任何现有值加载到我们的`Properties`实例中。
- en: 'Moving on, what we see next are pretty straightforward getters and setters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到的是相当直接的getter和setter方法：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final method is the one that writes our preferences back out, which is
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的方法是将我们的偏好写回的方法，具体如下：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This last method looks a lot like our constructor, but we create an `OutputStream`,
    and call `Properties.store(OutputStream)` to write our values out to a file. Note
    that we call this method from every put method to make sure, insofar as possible,
    that the user preferences are faithfully persisted to disk.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这种方法看起来很像我们的构造函数，但我们创建了一个`OutputStream`，并调用`Properties.store(OutputStream)`将我们的值写入文件。请注意，我们从每个put方法中调用此方法，以确保尽可能忠实地将用户偏好持久化到磁盘。
- en: What would a Preferences-based implementation look like? Not much different.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基于偏好的实现看起来会是什么样子？并没有太大的不同。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Two things to note. First, we don't need to handle persistence, as `Preferences`
    does that for us. Second, the instantiation of the `Preferences` instance needs
    some attention. Clearly, I think, we want these preferences to be scoped to the
    user, so we start with `Preferences.userRoot()` to get the root preference node.
    Then we ask for the node in which we want to store our preferences, which we have
    chosen to name after the package of our class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点需要注意。首先，我们不需要处理持久化，因为`Preferences`会为我们处理。其次，`Preferences`实例的创建需要一些注意。显然，我认为，我们希望这些偏好是针对用户的，所以我们从`Preferences.userRoot()`开始，以获取根偏好节点。然后我们请求存储我们偏好的节点，我们选择将其命名为我们的类的包名。
- en: Where does that put things? On Linux, the file might look something like ``~/.java/.userPrefs/_!':!bw"t!#4!cw"0!'`!~@"w!'w!~@"z!'8!~g"0!#4!ag!5!')!c!!u!(:!d@"u!'%!~w"v!#4!}@"w!(!=/prefs.xml``
    (yes, that's a directory name). On Windows, those preferences are saved in the
    Windows Registry under the key `HKEY_CURRENT_USERSOFTWAREJavaSoftPrefscom.steeplesoft.sunago.app`.
    Unless you want to interact directly with these files, though, their exact location
    and format are merely implementation details. Sometimes, though, it's a good thing
    to know.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将事情置于何处？在Linux上，文件可能看起来像这样 ``~/.java/.userPrefs/_!':!bw"t!#4!cw"0!'`!~@"w!'w!~@"z!'8!~g"0!#4!ag!5!')!c!!u!(:!d@"u!'%!~w"v!#4!}@"w!(!=/prefs.xml``（是的，这是一个目录名）。在Windows上，这些偏好被保存在Windows注册表的`HKEY_CURRENT_USERSOFTWAREJavaSoftPrefscom.steeplesoft.sunago.app`键下。不过，除非你想直接与这些文件交互，否则它们的精确位置和格式仅仅是实现细节。有时，了解这些也是一件好事。
- en: 'We have two implementations, so how do we pick which one to use? In the file
    (including the source root for clarity) `src/main/resources/META-INF/service/com.steeplesoft.sunago.api.SunagoPreferences`,
    we can put one of these two lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个实现，那么我们如何选择使用哪一个呢？在文件（包括为了清晰起见的源根）`src/main/resources/META-INF/service/com.steeplesoft.sunago.api.SunagoPreferences`中，我们可以放置以下两条中的一条：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can list both, but only the first will be chosen, which we''ll see now.
    To make things simple, we''ve wrapped this up in a utility method as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以列出两者，但只会选择第一个，我们现在就会看到这一点。为了简化问题，我们将其封装在一个实用方法中，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In what may be a bit of an overkill for our purposes here, we've implemented
    a singleton by declaring the instance of the `SunagoPreferences` interface as
    a private static, and made it available via a synchronized method, which checks
    for `null`, and creates the instance if needed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可能有点过度，我们通过将`SunagoPreferences`接口的实例声明为私有静态，并通过一个同步方法使其可用，该方法检查`null`并在需要时创建实例，来实现了一个单例。
- en: While that's interesting, don't let it distract you from the meat of the method.
    We use the `ServiceLoader.load()` method to ask the system for any implementations
    of the `SunagoPreferences` interface. It's worth noting again, just to be clear,
    that it won't pick up **any** implementation in the system, but **only** those
    listed in the services file we described earlier. Using the `ServiceLoader<SunagoPreferences>`
    instance, we grab an iterator, and if it has an entry (`iterator.hasNext()`),
    we return that instance (`iterator.next()`). If it does not, we return `null`.
    There is a chance here for a `NullPointerException` since we are returning `null`,
    but we're also providing an implementation, so we avoid that risk. However, in
    your own code, you need to either ensure you have an implementation as we've done
    here, or to make sure that the consuming code is `null`-ready.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很有趣，但不要让它分散你对方法核心的注意力。我们使用`ServiceLoader.load()`方法向系统请求`SunagoPreferences`接口的任何实现。再次强调，为了明确，它不会在系统中选择**任何**实现，而**只有**那些在我们之前描述的服务文件中列出的实现。使用`ServiceLoader<SunagoPreferences>`实例，我们获取一个迭代器，如果它有一个条目（`iterator.hasNext()`），我们就返回该实例（`iterator.next()`）。如果没有，我们返回`null`。这里有一个`NullPointerException`的风险，因为我们正在返回`null`，但我们也在提供一个实现，因此避免了这种风险。然而，在你的代码中，你需要确保你有实现，就像我们在这里所做的那样，或者确保消费代码已经准备好处理`null`。
- en: Adding a network - Twitter
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加网络 - Twitter
- en: So far, we have a pretty basic application, which can save and load its preferences,
    but let's get down to what we're here for and start connecting to social networks.
    What we hope to develop is a framework that makes it easy to add support for different
    social networks. Technically, as we'll soon see, the **network** need not even
    be social as the only thing that will imply a specific type of source is the name
    of the classes and interfaces involved. However, we will, in fact, focus on social
    networks, and we'll use a couple of different ones to show some variety. To that
    end, we'll start with Twitter, the massively popular microblogging platform, and
    Instagram, the increasingly photo-focused network that is now part of Facebook.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个相当基础的应用程序，它可以保存和加载其首选项，但让我们回到我们在这里的目的，开始连接到社交网络。我们希望开发一个框架，使其能够轻松地添加对不同社交网络的支持。技术上，正如我们很快就会看到的，**网络**甚至不需要是社交的，因为唯一表明特定类型源的是涉及的类和接口的名称。然而，实际上，我们将专注于社交网络，我们将使用几个不同的网络来展示一些多样性。为此，我们将从Twitter开始，这是一个广受欢迎的微博平台，以及Instagram，这是一个越来越以照片为中心的网络，现在它是Facebook的一部分。
- en: Speaking of Facebook, why are we not demonstrating integration with that social
    network? Two reasons--One, it's not significantly different from Twitter, so there
    would not be much that was new to cover; two, most importantly, the permissions
    that Facebook offers make it virtually impossible to integrate with it in a way
    that would be of interest here. For example, the permission to read a user's home
    timeline (or wall) is only granted to applications targeted at those platforms
    where Facebook is not currently available, and not at all to desktop applications,
    which is our target here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 说到Facebook，为什么我们不展示与该社交网络的集成呢？两个原因——一是它与Twitter没有显著的不同，所以没有太多新内容可以介绍；二是最重要的是，Facebook提供的权限使得以我们感兴趣的方式与之集成几乎是不可能的。例如，读取用户主页时间线（或墙）的权限仅授予针对那些Facebook目前不可用的平台的应用程序，而完全不授予桌面应用程序，这是我们在这里的目标。
- en: As noted previously, we'd like to expose a way to add more networks without
    having to change the core application, so we need to develop an API. What we'll
    cover here is that API in a more or less **finished** state (is any software every
    truly finished?). However, while you will see a reasonably complete API, a word
    of caution--attempts to create an abstraction that start with that abstraction--that
    is, writing the abstraction from scratch--rarely end well. It is usually best
    to write a specific implementation to get a better understanding of the details
    required, then extract an abstraction. What you will see here is the end result
    of that process, so that process will not be covered here in any depth.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望提供一个方法来添加更多网络，而无需更改核心应用程序，因此我们需要开发一个API。在这里我们将讨论这个API的大致**完成**状态（任何软件真的有完成的时候吗？）。然而，虽然你会看到一个相当完整的API，但有一个警告——试图从那个抽象开始创建抽象——也就是说，从头开始编写抽象——很少会有好结果。通常最好编写一个具体的实现来更好地理解所需的细节，然后提取抽象。你在这里看到的是这个过程的结果，因此这个过程不会在这里进行深入讨论。
- en: Registering as a Twitter developer
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册为Twitter开发者
- en: 'To create an application that integrates with Twitter, we need to create a
    Twitter developer account, and then create a Twitter application. To create the
    account, we need to visit [https://dev.twitter.com](https://dev.twitter.com/),
    and click on the Join button. Once you''ve created your developer account, you
    can click the My Apps link to go to [https://apps.twitter.com](https://apps.twitter.com/).
    Here, we need to click on the Create New App button, which will get us a form
    that looks a bit like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个与Twitter集成的应用程序，我们需要创建一个Twitter开发者账户，然后创建一个Twitter应用程序。为了创建账户，我们需要访问[https://dev.twitter.com](https://dev.twitter.com/)，并点击加入按钮。一旦你创建了你的开发者账户，你可以点击“我的应用”链接进入[https://apps.twitter.com](https://apps.twitter.com/)。在这里，我们需要点击创建新应用按钮，这将带我们到一个看起来有点像这样的表单：
- en: '![](img/42daa02b-d5ea-4112-9c95-14dfcb9c1727.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42daa02b-d5ea-4112-9c95-14dfcb9c1727.png)'
- en: While the application we're developing is called *Sunago*, you won't be able
    to use that name, as it's already taken; you'll have to create a unique name of
    your own, assuming you're planning to run the application yourself. Once you've
    created the application, you'll be taken to the Application Management page for
    your new app. From this page, you can manage your app's permissions and keys,
    and, if needed, you can delete your app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们正在开发的应用程序名为*Sunago*，但你无法使用这个名字，因为它已经被占用；你必须创建一个你自己的独特名称，假设你打算自己运行这个应用程序。一旦你创建了应用程序，你将被带到新应用的应用管理页面。从该页面，你可以管理你应用的权限和密钥，如果需要，你也可以删除你的应用。
- en: One thing to note on this page, as we'll need this soon, is where to find your
    application's Consumer Key and Secret. These are long, alphanumeric strings that
    your application will use to authenticate with Twitter's services. To interact
    with Twitter on behalf of a user--our ultimate goal--requires a different set
    of tokens, which we'll fetch shortly. Your Consumer Key and Secret--especially,
    Consumer Secret--should be kept, well, secret. If this combination is ever revealed
    publicly, other users will be able to masquerade as your app, potentially causing
    you serious headaches if they abuse the service. For that reason, you won't see
    the key/secret combination I generated anywhere in this book or the source code,
    which is why you will need to generate your own.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上需要注意的一件事，因为我们很快就会用到，就是如何找到你应用的消费者密钥和密钥。这些是长数字字母字符串，你的应用将使用它们来与Twitter的服务进行身份验证。为了代表用户与Twitter交互——我们的最终目标——需要另一组令牌，我们很快就会获取。你的消费者密钥和密钥——特别是消费者密钥——应该保密。如果这个组合被公开泄露，其他用户将能够冒充你的应用，如果他们滥用服务，可能会给你带来严重的麻烦。因此，你不会在任何地方看到我生成的密钥/密钥组合，无论是这本书还是源代码中，这就是为什么你需要生成自己的原因。
- en: Armed now with our Consumer Key and Secret, we need to decide how to talk to
    Twitter. Twitter offers a public REST API, which they document on their site.
    If we were so inclined, we could pick an HTTP client of some sort, and start making
    calls. In the interests of simplicity and clarity, though, not to mention robustness,
    fault tolerance, and so on, we might be better served using a higher-level library
    of some sort. As luck would have it, there is a such a library, Twitter4J, which
    will make our integration much simpler and cleaner (for the curious, Twitter4J
    has over 200 Java classes. While we won't need all of the functionality represented
    there and exposed via the REST API, it should give you an idea of the scope of
    the effort required to write a reasonable wrapper for Twitter's REST interface).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了消费者密钥和密钥，我们需要决定如何与Twitter进行通信。Twitter提供了一个公共REST API，他们在网站上进行了文档说明。如果我们愿意，我们可以选择某种HTTP客户端，并开始进行调用。然而，出于简单性、清晰性、健壮性、容错性等方面的考虑，我们可能更倾向于使用某种高级库。幸运的是，确实存在这样一个库，即Twitter4J，它将使我们的集成变得更加简单和干净（对于好奇的人来说，Twitter4J有200多个Java类。虽然我们不需要所有通过REST
    API表示并公开的功能，但它应该能给你一个编写Twitter REST接口合理包装所需工作范围的印象）。
- en: 'As mentioned earlier, we want to be able to add networks to Sunago without
    having to change the core application, so we will write our Twitter integration
    in a separate Maven module. This will require that some of the code we''ve already
    written for Sunago be extracted into yet another module. Both our Twitter module
    and the main application module will then add a dependency on this new module.
    Since we''ll have multiple modules at play here, we''ll be sure to indicate to
    which module each class belongs. When we''re finished, our project dependency
    graph will look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望在不需要更改核心应用程序的情况下将网络添加到Sunago中，因此我们将编写我们的Twitter集成到一个单独的Maven模块中。这将要求我们将为Sunago编写的部分代码提取到另一个模块中。然后，我们的Twitter模块和主要应用程序模块将添加对这个新模块的依赖。由于我们将有多个模块在运行，我们将确保指出每个类属于哪个模块。完成之后，我们的项目依赖关系图将如下所示：
- en: '![](img/beb9bc78-0b95-45e0-aad5-5834e235f1f5.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/beb9bc78-0b95-45e0-aad5-5834e235f1f5.png)'
- en: Technically, the only reason we show a dependency between the Application module
    and the Instagram and Twitter modules is because we're building them as part of
    the same project. A third-party developer, as we'll see, could easily develop
    an independent module, add it to the application's runtime classpath, and see
    the change in the application, all without this build-level dependency. Hopefully,
    though, this graph helps explain how the modules are related.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们之所以在应用程序模块和Instagram以及Twitter模块之间显示依赖关系，是因为我们将它们作为同一项目的一部分构建。正如我们将看到的，第三方开发者可以轻松地开发一个独立的模块，将其添加到应用程序的运行时类路径中，并看到应用程序中的变化，而无需这种构建级别的依赖。然而，希望这个图能帮助解释模块之间的关系。
- en: Adding Twitter preferences to Sunago
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Twitter偏好添加到Sunago
- en: 'Let''s start by adding Twitter to our preferences screen. Before we can do
    any integration, we need to be able to configure the application, or, more accurately,
    the Twitter module, so that it can connect as a specific user. To enable that,
    we''ll add a new interface to the API module as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的偏好屏幕添加Twitter开始。在我们能够进行任何集成之前，我们需要能够配置应用程序，或者更准确地说，Twitter模块，以便它可以以特定用户身份连接。为了实现这一点，我们将向API模块添加一个新接口，如下所示：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This interface will give Sunago two hooks into the module--one giving the module
    a chance to draw its own preferences user interface, and one to allow it to save
    those preferences. We can then implement that in our module. Before we do so,
    though, let''s see how the application will find these implementations so that
    they can be used. For that, we will again turn to SPI. In Sunago''s `PreferencesController`
    interface, we add this code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口将为Sunago提供两个钩子进入模块——一个让模块有机会绘制自己的偏好用户界面，另一个允许它保存这些偏好。然后我们可以在我们的模块中实现这一点。在我们这样做之前，让我们看看应用程序将如何找到这些实现，以便它们可以被使用。为此，我们再次转向SPI。在Sunago的`PreferencesController`接口中，我们添加以下代码：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have an instance variable to hold a list of any `SocialMediaPreferencesController`
    instances we find. Next, in `initialize()`, we call the now familiar `ServiceLoader.load()`
    method to find any implementations, which we then add to the `List` that we created
    previously. Once we have our list of controllers, we call `getTab()` on each of
    them, adding the returned `Tab` instance to the `PreferencesController` interface's
    `tabPane`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个实例变量来保存我们找到的任何`SocialMediaPreferencesController`实例。接下来，在`initialize()`中，我们调用熟悉的`ServiceLoader.load()`方法来查找任何实现，然后将它们添加到我们之前创建的`List`中。一旦我们有了控制器的列表，我们就对每个控制器调用`getTab()`，将返回的`Tab`实例添加到`PreferencesController`接口的`tabPane`中。
- en: 'With the loading part clarified, let''s now take a look at the Twitter preferences
    user interface implementation. We start by implementing the controller that will
    back this part of the user interface as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在澄清了加载部分之后，现在让我们看看Twitter首选项用户界面实现。我们首先实现将支持这个用户界面部分的控制器，如下所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll take a look at `TwitterClient` in a moment, but, first, a note on `getTab()`.
    Notice that we create the `Tab` instance, which we need to return, but we delegate
    the creation of its contents to the `getNode()` method. `Tab.setContent()` allows
    us to completely replace the contents of the tab with a single call, something
    we''ll make use of next. The `getNode()` method looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后查看`TwitterClient`，但首先，关于`getTab()`的一个说明。请注意，我们创建了需要返回的`Tab`实例，但我们将其内容的创建委托给`getNode()`方法。`Tab.setContent()`允许我们通过单个调用完全替换标签页的内容，这是我们将在下面使用的东西。`getNode()`方法看起来像这样：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the user has already authenticated, then we want to present some configuration
    options. If not, then we need to offer a means to connect to Twitter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经进行了身份验证，那么我们想要展示一些配置选项。如果没有，那么我们需要提供一种连接到Twitter的方法。
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this simple user interface, we create an `HBox` primarily so we can add some
    padding. Without the `new Insets(10)` instance we pass to `setPadding()`, our
    button would be pressed right up against the top and left edges of the window,
    which is not visually appealing. Next, we create the `Button`, and set the `onAction`
    handler (ignore that constructor parameter for now).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的用户界面中，我们创建一个`HBox`主要是为了添加一些填充。如果没有传递给`setPadding()`方法的`new Insets(10)`实例，我们的按钮就会紧贴窗口的顶部和左侧边缘，这从视觉上并不吸引人。接下来，我们创建`Button`，并设置`onAction`处理程序（现在忽略那个构造函数参数）。
- en: 'The interesting part is hidden away in `connectToTwitter`, as shown in this
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分隐藏在`connectToTwitter`中，如下代码所示：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: OAuth and logging on to Twitter
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth和登录到Twitter
- en: 'We''ll take a detour into `LoginController` in just a moment, but first, let''s
    make sure we understand what''s going on here. To log on to Twitter on behalf
    of a user, we need to generate an OAuth request token from which we get an authorization
    URL. The details of which are hidden nicely behind the Twitter4J API, but it is,
    basically, the OAuth authorization URL listed on the Application Management page
    with a request token passed as a query string. As we''ll see, this URL is opened
    in a `WebView`, which prompts the user to authenticate against Twitter, and then
    authorize the application (or decline to):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后绕道进入`LoginController`，但首先，让我们确保我们理解这里发生了什么。为了代表用户登录Twitter，我们需要生成一个OAuth请求令牌，从中我们可以获取一个授权URL。这些细节被Twitter4J
    API很好地隐藏起来，但基本上，这是在应用程序管理页面上列出的OAuth授权URL，请求令牌作为查询字符串传递。正如我们将看到的，这个URL将在`WebView`中打开，提示用户对Twitter进行身份验证并授权应用程序（或拒绝）：
- en: '![](img/de141ca9-ccda-489a-b1f5-8aa496d98983.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de141ca9-ccda-489a-b1f5-8aa496d98983.png)'
- en: 'If the user successfully authenticates and authorizes the application, the
    `WebView` is redirected to a success page, which displays a numeric code that
    we need to capture to finish gathering the authentication/authorization credentials
    needed. The success page might look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功身份验证并授权应用程序，`WebView`将被重定向到成功页面，该页面显示一个我们需要捕获的数字代码，以完成收集所需的身份验证/授权凭据。成功页面可能看起来像这样：
- en: '![](img/2104c10e-20b4-4313-ac1c-eb187fe49f8b.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2104c10e-20b4-4313-ac1c-eb187fe49f8b.png)'
- en: For those not familiar with OAuth, what this allows us to do is to authenticate
    as the user, now and at any arbitrary moment in the future, without needing to
    store the user's actual password. The end result of this handshake between our
    application and Twitter is a token and token secret, which we'll pass to Twitter
    for authentication. As long as this token is valid--the user can invalidate it
    at any time via Twitter's web interface--we can connect and act as that user.
    Should the key ever be compromised, the user can revoke the key, affecting only
    the intended app and anyone attempting to use the stolen key.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉 OAuth 的人来说，这允许我们作为用户进行认证，现在和未来的任意时刻，而无需存储用户的实际密码。我们应用程序与 Twitter 之间握手的结果是一个令牌和令牌密钥，我们将将其传递给
    Twitter 以进行认证。只要这个令牌有效（用户可以通过 Twitter 的网页界面随时使其无效），我们就可以连接并代表该用户进行操作。如果密钥遭到破坏，用户可以撤销密钥，这只会影响预期的应用程序和任何试图使用被盗密钥的人。
- en: '`LoginController`, which is part of the API module, handles all of the boilerplate
    code for us, as seen in this code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginController` 是 API 模块的一部分，为我们处理所有样板代码，如下代码所示：'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This preceding code is a basic FXML-backed JavaFX controller, but we do have
    a static helper method to handle the details of creating, configuring, and showing
    an instance. We load the scene using FXML, get the controller (which is an instance
    of the enclosing class), set the `loginSuccessTest` and `handler` properties,
    and then show the dialog.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个基本的 FXML 支持的 JavaFX 控制器，但我们确实有一个静态辅助方法来处理创建、配置和显示实例的细节。我们使用 FXML 加载场景，获取控制器（它是封装类的实例），设置
    `loginSuccessTest` 和 `handler` 属性，然后显示对话框。
- en: Do `loginSuccessTest` and `handler` look odd? They are instances of the Java
    8 functional interfaces `Predicate<T>` and `Consumer<T>`. `Predicate` is a functional
    interface that takes a type, `WebEngine` in our case, and returns a `boolean`.
    It is designed to check for a certain condition given a variable of the specified
    type. In this instance, we call `WebEngine.executeScript().contains()` to extract
    a piece of the document, and see if it contains a certain piece of text indicating
    that we've been redirected to the login success page.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`loginSuccessTest` 和 `handler` 看起来奇怪吗？它们是 Java 8 函数式接口 `Predicate<T>` 和 `Consumer<T>`
    的实例。`Predicate` 是一个函数式接口，它接受一个类型，在我们的例子中是 `WebEngine`，并返回一个 `boolean`。它旨在检查给定指定类型的变量是否满足某种条件。在这个例子中，我们调用
    `WebEngine.executeScript().contains()` 来提取文档的一部分，并查看它是否包含表示我们已被重定向到登录成功页面的特定文本。'
- en: '`Consumer<T>` is a functional interface (or, in our case, a lambda) that takes
    a single parameter of the specified type, and returns void. Our handler is a `Consumer`,
    which is called once our `Predicate` returns true. The lambda extracts the code
    from the HTML page, calls `saveTwitterAuthentication()` to finish authenticating
    the user, then `showConfigurationUI()` to change the user interface so that the
    user can configure Twitter-related settings.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>` 是一个函数式接口（或者在我们的情况下，是一个 lambda），它接受指定类型的单个参数，并返回 void。我们的处理器是一个
    `Consumer`，当 `Predicate` 返回 true 时被调用。lambda 从 HTML 页面提取代码，调用 `saveTwitterAuthentication()`
    以完成用户认证，然后调用 `showConfigurationUI()` 来更改用户界面，以便用户可以配置与 Twitter 相关的设置。'
- en: 'The method `saveTwitterAuthentication()` is very straightforward, and is given
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `saveTwitterAuthentication()` 非常直接，具体如下所示：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method `twitter.getAccessToken()` takes our request token and the code we
    extracted from the web page, and sends an HTTP `POST` to a Twitter REST endpoint,
    which generates the token secret we need. When that request returns, we store
    the token and token secret to our `Preferences` store (again, oblivious to where
    and how).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `twitter.getAccessToken()` 接收我们的请求令牌和从网页中提取的代码，并向 Twitter REST 端点发送一个 HTTP
    `POST` 请求，生成我们需要的令牌密钥。当这个请求返回时，我们将令牌和令牌密钥存储到我们的 `Preferences` 存储中（同样，对此一无所知）。
- en: The method `showConfigurationUI()` and the related method should also be familiar.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `showConfigurationUI()` 以及相关方法也应该很熟悉。
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One new item in this preceding method is the listener we add to the `selectedProperty`
    of the `CheckBox`. Any time the selected value changes, our listener is called,
    which sets the value of the `showHomeTimeline` boolean.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中新增的一项是添加到 `CheckBox` 的 `selectedProperty` 上的监听器。每次选中值改变时，我们的监听器都会被调用，这将设置
    `showHomeTimeline` 布尔值的值。
- en: 'The `ListView` also needs special attention. Notice the parameterized type,
    `SelectableItem<UserList>`. What is that? That''s an abstract class we''ve created
    to wrap items for use in `CheckBoxListCell`, which you can see in the call to
    `setCellFactory()`. That class looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`也需要特别注意。注意参数化类型，`SelectableItem<UserList>`。那是什么？那是一个我们创建的抽象类，用于包装用于`CheckBoxListCell`的条目，这在`setCellFactory()`调用中可以看到。这个类看起来是这样的：'
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class, which lives in the API module, is a simple wrapper around an arbitrary
    type that adds a `SimpleBooleanProperty`. We see how this property is manipulated
    when the cell factory is set up--`lv.setCellFactory(CheckBoxListCell .forListView(item
    -> item.getSelected()))`. We expose `SimpleBooleanProperty` via the `getSelected()`
    method, which the `CheckBoxListCell` uses to set and read the state of each line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类位于API模块中，它是一个简单的包装器，围绕任意类型添加一个`SimpleBooleanProperty`。我们看到当设置单元格工厂时如何操作这个属性--`lv.setCellFactory(CheckBoxListCell.forListView(item
    -> item.getSelected()))`。我们通过`getSelected()`方法公开`SimpleBooleanProperty`，这个方法由`CheckBoxListCell`用来设置和读取每一行的状态。
- en: 'Our final user interface-related method is this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的用户界面相关方法是这个：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the same `SelectableItem` class, we request from Twitter all of the lists
    the user might have created, which we wrap in `SelectableUserList`, a `SelectableItem`
    child that overrides the `toString()` method to provide user-friendly text in
    `ListView`. We load any checked lists from preferences, set their respective booleans/checkboxes,
    and update our `ObservableList` and, thus, the user interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的`SelectableItem`类，我们从Twitter请求用户可能创建的所有列表，我们将它们包装在`SelectableUserList`中，这是一个覆盖`toString()`方法的`SelectableItem`子类，以在`ListView`中提供用户友好的文本。我们加载首选项中的任何已检查的列表，设置它们各自的布尔值/复选框，并更新我们的`ObservableList`以及用户界面。
- en: 'The final method we need to implement to satisfy the `SocialMediaPreferencesController`
    contract is `savePreferences()`, which is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个方法来满足`SocialMediaPreferencesController`契约是`savePreferences()`，如下所示：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a mostly straightforward saving of the user's options to preferences,
    but the list handling is worth pointing out. Rather than manually iterating over
    each item in the list, we can use a stream and apply a couple of `filter()` operations
    to strip out entries that are of no interest to us, `map()` each `SelectableUserList`
    that makes it through to `Long` (which is the list's ID), then collect them in
    a `List<String>`. We join that `List` using `String.join()`, and write it out
    to our preferences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是将用户的选项保存到首选项中的直接操作，但列表处理值得指出。我们不是手动遍历列表中的每个项目，而是可以使用流并应用几个`filter()`操作来去除对我们无兴趣的条目，然后将每个通过筛选的`SelectableUserList`映射到`Long`（这是列表的ID），最后将它们收集到一个`List<String>`中。我们使用`String.join()`连接这个`List`，并将其写入我们的首选项。
- en: Adding a model for Twitter
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Twitter模型
- en: 'There are still a couple of other interfaces that we need to implement to finish
    our Twitter support. The first, and simpler, one is `SocialMediaItem`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现其他几个接口来完成我们的Twitter支持。第一个，也是更简单的一个是`SocialMediaItem`：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This preceding interface provides us with a nice abstraction over the various
    types of data that a social network might return without being too heavily burdened
    with fields that aren''t used by most (or many, at least) networks. The Twitter
    implementation of this `Tweet` class is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个先前的接口为我们提供了一个很好的抽象，可以覆盖社交网络可能返回的各种类型的数据，而不会因为大多数（或许多）网络未使用的字段而过于沉重。这个`Tweet`类的Twitter实现如下所示：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Taking the Twitter4J class `Status`, we extract information of interest to
    us, and store it in instance variables (whose getters are not shown, as they''re
    just simple getters). For the `getImage()` method, we make a reasonable effort
    to extract any image from the tweet, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从Twitter4J类`Status`中提取我们感兴趣的信息，并将其存储在实例变量中（它们的getter没有显示，因为它们只是简单的getter）。对于`getImage()`方法，我们尽力从推文中提取任何图像，如下所示：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implementing a Twitter client
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Twitter客户端
- en: 'The second interface is `SocialMediaClient`. This interface serves not only
    as an abstraction that Sunago can use to interact with an arbitrary social network
    integration, but also as a guideline for interested developers to show them the
    minimum requirements for the integration. It looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个接口是`SocialMediaClient`。这个接口不仅作为Sunago与任意社交网络集成交互的抽象，而且还作为对感兴趣的开发者的指南，向他们展示集成的最低要求。它看起来是这样的：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For Twitter support, this preceding interface is implemented by the class `TwitterClient`.
    Most of the class is pretty basic, so we won''t reproduce that here (you can peruse
    it in the source repository if you''d like details), but one implementation detail
    might be worth spending some time over. That method is `processList()`, which
    is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Twitter支持，这个前置接口是通过`TwitterClient`类实现的。类的大部分内容相当基础，所以我们在这里不会重复展示（如果您想了解详细信息，可以在源代码库中查看），但有一个实现细节可能值得花些时间研究。这个方法是`processList()`，如下所示：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are several things going on in this last method. First, we want to limit
    how many tweets we actually retrieve. If this is the first time the app is used,
    or the first time that it's used in a long time, there could be a significant
    number of tweets. Retrieving all of them would be quite expensive in terms of
    network usage, memory and, perhaps, processing time. We implement that limit using
    the `Paging` object from Twitter4J.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的方法中，有几件事情在进行。首先，我们希望限制实际检索的推文数量。如果这是第一次使用该应用，或者很长时间以来的第一次使用，可能会有大量的推文。检索所有这些推文在网络上、内存和可能处理时间上都会相当昂贵。我们使用Twitter4J的`Paging`对象来实现这个限制。
- en: We also don't want to retrieve tweets we already have, so, for each list, we
    keep a `sinceId`, which we can pass to the Twitter API. It will use this to find
    up to the specified number of tweets whose ID is greater than `sinceId`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不希望检索我们已经拥有的推文，因此，对于每个列表，我们保留一个`sinceId`，我们可以将其传递给Twitter API。它将使用这个ID来查找ID大于`sinceId`的指定数量的推文。
- en: Wrapping all of this up in the `Paging` object, we call either `twitter.getHomeTimeline()`
    if the list ID is `-1` (an internal ID we've used to identify the home timeline)
    or `twitter.getUserListStatus()` for a user-defined list. For each `Status` returned,
    we update `sinceId` (which we've modeled using an `AtomicLong`, as any method
    variable used inside a lambda must be final or effectively final), and add the
    tweet to our `List`. Before exiting, we store `sinceId` for the list in our in-memory
    store, and then return the tweets for the Twitter list.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些封装在`Paging`对象中，我们调用`twitter.getHomeTimeline()`，如果列表ID是`-1`（我们用来标识主时间线的内部ID），或者调用`twitter.getUserListStatus()`来获取用户定义的列表。对于返回的每个`Status`，我们更新`sinceId`（我们使用`AtomicLong`来建模，因为任何在lambda内部使用的变量都必须是final或实际上是final的），并将推文添加到我们的`List`中。在退出之前，我们将列表的`sinceId`存储在我们的内存存储中，然后返回Twitter列表的推文。
- en: A brief look at internationalization and localization
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要了解国际化与本地化
- en: 'While somewhat basic, our integration with Twitter is now complete, as it fulfills
    our functional requirements for the network. However, there is one more piece
    of code that we need to take a quick look at. Earlier, in some of the code samples,
    you might have noticed code that looks like this: `MessageBundle.getInstance().getString("homeTimelineCB")`.
    What is that, and what does it do?'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些基础，但我们的Twitter集成现在已经完成，因为它满足了我们对网络的函数需求。然而，我们还需要快速查看一段代码。在之前的代码示例中，您可能已经注意到类似这样的代码：`MessageBundle.getInstance().getString("homeTimelineCB")`。这是什么，它做什么？
- en: 'The `MessageBundle` class is a small wrapper around the internationalization
    and localization facilities (also known as i18n and l10n, where the numbers represent
    the number of letters dropped from the words to make the abbreviation) provided
    by the JDK. The code for this class is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBundle`类是对JDK提供的国际化本地化设施（也称为i18n和l10n，其中数字代表从单词中删除的字母数量）的一个小包装。这个类的代码如下：'
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There are two main items of interest here. We'll start at the end of the class
    with the `getInstance()` method. This is an example of what is known as the **initialize
    on demand holder** (**IODH**) pattern. There is a single, static instance of the
    class `MessageBundle` in the JVM. It is not initialized, however, until the `getInstance()`
    method is called. This is accomplished by taking advantage of how the JVM loads
    and initializes statics. As soon as a class is referenced in any way, it is loaded
    into `ClassLoader`, at which point any statics on the class will be initialized.
    The private static class `LazyHolder` is **not** initialized until the JVM is
    sure that something needs to access it. Once we call `getInstance()`, which references
    `LazyHolder.INSTANCE`, the class is initialized and the singleton instance created.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个主要的项目值得关注。我们将从类的末尾开始，即`getInstance()`方法。这是一个所谓的**按需初始化持有者**（**IODH**）模式的例子。在JVM中有一个`MessageBundle`类的单个、静态实例。然而，它不会初始化，直到`getInstance()`方法被调用。这是通过利用JVM加载和初始化静态的方式实现的。一旦以任何方式引用了一个类，它就会被加载到`ClassLoader`中，此时该类上的任何静态都会被初始化。私有的静态类`LazyHolder`**不会**在JVM确定需要访问它之前初始化。一旦我们调用`getInstance()`，它引用`LazyHolder.INSTANCE`，类就会被初始化，并创建单例实例。
- en: It should be noted that are ways around the singleton nature we're trying to
    implement (for example, via reflection), but our use case here does not warrant
    any worries over such an attack.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，有绕过我们试图实现的单例特性的方法（例如，通过反射），但我们的用例在这里不需要担心这种攻击。
- en: The actual functionality is implemented in the first line of the class, which
    is as follows
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际功能是在类的第一行实现的，如下所示
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `ResourceBundle` files, in the words of the Javadoc, *contain locale-specific
    objects*. Usually, this means Strings, as it does in our case. The `getBundle()`
    method will attempt to find and load a bundle with the name given for the specified
    locale. In our case, we're looking for a bundle named `Messages`. Technically,
    we're looking for a bundle in a family of bundles with the shared base name `Messages`.
    The system will use the `Locale` specified to find the correct file. This resolution
    will follow the same lookup logic that `Locale` uses, so the `getBundle()` method
    will return the bundle with the most specific matching name available.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Javadoc的描述，`ResourceBundle`文件*包含特定区域的对象*。通常，这意味着字符串，正如在我们的案例中一样。`getBundle()`方法将尝试查找并加载一个具有指定区域名称的包。在我们的案例中，我们正在寻找一个名为`Messages`的包。技术上，我们正在寻找一个具有共享基础名称`Messages`的包族中的包。系统将使用指定的`Locale`来查找正确的文件。这种解析将遵循`Locale`使用的相同查找逻辑，因此`getBundle()`方法将返回具有最具体匹配名称的包。
- en: 'Let''s say we''re running this application on my computer. I live in the United
    States, so my system''s default locale is `en_US`. Following the rules of the
    `Locale` lookup, then, `getBundle()` will try to locate files in this order:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在我的电脑上运行这个应用程序。我住在美国，所以我的系统默认的区域设置是`en_US`。根据`Locale`查找规则，那么`getBundle()`将尝试按以下顺序定位文件：
- en: '`Messages_en_US.properties`.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Messages_en_US.properties`.'
- en: '`Messages_en.properties`.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Messages_en.properties`.'
- en: '`Messages.properties`.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Messages.properties`.'
- en: 'The system will go from the most specific file to the least until it finds
    the key requested. If it''s not found in any file, `MissingResourceException`
    is thrown. Each file consists of key/value pairs. Our `Messages.properties` file
    looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将从最具体的文件开始，直到找到请求的键。如果任何文件中都没有找到，将抛出`MissingResourceException`。每个文件都由键/值对组成。我们的`Messages.properties`文件看起来如下：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is just a simple mapping of keys to localized text. We could have `Messages_es.properties`
    with this line:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是键到本地化文本的简单映射。我们可以有一个`Messages_es.properties`文件，包含以下行：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If that were the only entry in the file, that one label in the file would be
    in Spanish, with everything else being in the default from `Message.properties`,
    which, in our case, is English.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件中只有这个条目，那么文件中的这个标签将是西班牙语，其余的都将是来自`Message.properties`的默认值，在我们的案例中是英语。
- en: Making our JAR file fat
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的JAR文件变得庞大
- en: With that, our implementation is now complete. Before this can be used in the
    way we intend, though, we need to make a build change. If you recall the discussion
    of the requirements at the beginning of the chapter, we want to build a system
    that easily allows third-party developers to write modules that will add support
    for arbitrary social networks without the need to modify the core application.
    To deliver that functionality, these developers would need to offer a JAR that
    Sunago users could drop in a folder. When the application is started, the new
    functionality is now available.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的实现现在就完成了。然而，在我们可以按照预期的方式使用它之前，我们需要进行一些构建更改。如果您还记得章节开头对需求进行的讨论，我们希望构建一个系统，该系统可以轻松地允许第三方开发者编写模块，这些模块将为任意社交网络提供支持，而无需修改核心应用程序。为了提供这种功能，这些开发者需要提供一个Sunago用户可以放入文件夹中的JAR。当应用程序启动时，新的功能现在可用。
- en: 'That leaves us, then, with the task of bundling all of the required code. As
    the project stands now, a single JAR is created, which holds just our classes.
    That''s not entirely sufficient, though, as we depend on the Twitter4J jar. Other
    modules could have even more dependencies. Requiring users to drop in, say, half
    a dozen or more jars is probably asking a bit much. Fortunately, Maven has a mechanism
    that will allow us to avoid that problem altogether: the shade plugin.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的任务就是捆绑所有必需的代码。按照目前的项目状态，创建了一个单一的JAR文件，其中只包含我们的类。但这还不够，因为我们依赖于Twitter4J
    jar。其他模块可能有更多的依赖项。要求用户放入，比如说，六个或更多的jar文件可能有点过分。幸运的是，Maven有一个机制可以让我们完全避免这个问题：shade插件。
- en: 'By configuring this plugin in our build, we can generate a single jar that
    holds our classes and resources, plus those of every dependency declared in the
    project. This is often called a **fat jar**, and is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的构建中配置此插件，我们可以生成一个单一的jar文件，它包含我们的类和资源，以及项目中声明的每个依赖项。这通常被称为**fat jar**，如下所示：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is an official Maven plugin, so we can omit `groupId`, and we've defined
    a property, `plugin.shade`, somewhere up the POM's inheritance tree. When the
    package phase is run, the shade goal of this plugin will execute and build our
    fat jar.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个官方的Maven插件，因此我们可以省略`groupId`，并且我们在POM继承树的某个地方定义了一个属性，`plugin.shade`。当运行包阶段时，此插件的shade目标将执行并构建我们的fat
    jar。
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The original jar, which is considerably smaller, is renamed to `original-twitter-1.0-SNAPSHOT.jar`,
    and the fat jar receives the configured final name. It is this fat jar that is
    installed in the local maven repository, or deployed to an artifact manager, such
    as Artifactory.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的jar文件，体积相对较小，被重命名为`original-twitter-1.0-SNAPSHOT.jar`，而fat jar则使用配置的最终名称。正是这个fat
    jar被安装在本地的Maven仓库中，或者部署到如Artifactory这样的工件管理器。
- en: 'There is a small bug, though. Our twitter module depends on the API module
    so that it can see the interfaces and classes exposed by the application. Currently,
    even those are included in the fat jar, which we don''t want, as that can cause
    some `ClassLoader` issues down the road in some situations. To prevent that, we
    mark that dependency as `provided`, as shown next:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还存在一个小问题。我们的推特模块依赖于API模块，以便能够看到应用程序暴露的接口和类。目前，这些内容也被包含在fat jar中，而我们并不希望这样，因为这可能会在某些情况下导致一些`ClassLoader`问题。为了防止这种情况，我们将这个依赖项标记为`provided`，如下所示：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we issue a `mvn clean install` now, we'll have a nice fat jar with only the
    classes we need to bundle, and one that's ready for distribution.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在执行`mvn clean install`，我们将得到一个包含我们所需捆绑的类，并且已经准备好分发的fat jar。
- en: 'To make things as simple as possible, we''re just going to declare a dependency
    on this jar in Sunago''s app module, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能简化，我们只需在Sunago的应用模块中声明对这个jar的依赖，如下所示：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we run Sunago now, we'll see Twitter added to our settings screen, and, once
    connected and configured, we'll see tweets showing up on the main screen. We'll
    also notice that the main screen is a little plain, and, more importantly, doesn't
    provide any way of refreshing the contents, so let's fix that.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行Sunago，我们将看到推特被添加到我们的设置屏幕上，一旦连接并配置，我们将在主屏幕上看到推文。我们还会注意到主屏幕有点单调，更重要的是，它不提供刷新内容的方式，所以让我们来修复这个问题。
- en: Adding a refresh button
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加刷新按钮
- en: 'In the Projects window, find `sunago.fxml`, right-click on it, and select `Edit`.
    We''ll make this user interface change by hand, only for the sake of experience.
    Scroll down until you find the closing `Menubar` tag (`</Menubar>`). On the line
    right after that, insert these lines:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在“项目”窗口中，找到`sunago.fxml`，右键单击它，然后选择“编辑”。我们将手动进行这个用户界面更改，只是为了积累经验。向下滚动，直到找到关闭的`Menubar`标签（`</Menubar>`）。在其后的行中，插入以下这些行：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `SunagoController`, we need to add the instance variables as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SunagoController`中，我们需要添加以下实例变量：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, in `initialize()`, we need to set them up like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`initialize()`中，我们需要这样设置它们：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that we're doing a bit more than setting up an action handler. The first
    thing we do is call `setGraphic()`. Remember from our discussion of the Twitter
    preference tab, calling `setGraphic()` will replace the child nodes with the `Node`
    that you specify. In these two cases, that `Node` is an `ImageView`, and comes
    from the `getButtonImage()` method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们做的不仅仅是设置动作处理器。我们首先调用`setGraphic()`。记得在我们讨论Twitter首选项标签时，调用`setGraphic()`会替换掉你指定的`Node`子节点。在这两个例子中，`Node`是一个`ImageView`，它来自`getButtonImage()`方法。
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After we set the action handler, we also set a tooltip. This will give our
    graphical buttons a textual description when the user hovers over the button with
    the mouse, as seen in this screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置动作处理器之后，我们还设置了一个工具提示。当用户将鼠标悬停在按钮上时，这将给我们的图形按钮一个文本描述，就像在这个屏幕截图中所见：
- en: '![](img/89fcdd48-39c2-4ae8-9eb2-85641a96ab99.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89fcdd48-39c2-4ae8-9eb2-85641a96ab99.png)'
- en: 'The action handler for the refresh button is worth looking at, and is given
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的是刷新按钮的动作处理器，如下所示：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the same method that we call from `initialize()`. Using the Service
    Provider Interface that we discussed earlier, we iterate over each `SocialMediaClient`
    available in the system. If the client has authenticated against its network,
    we call the `getItems()` method, and add whatever it may return to a local variable,
    `items`. Once we've queried all of the networks configured in the system, we then
    sort our list. This will cause the entries of the various networks to be intermingled,
    as they're sorted by their timestamps in descending chronological order. This
    sorted list is then added to our `ObservableList` at the head, or the zeroth element,
    to cause them to appear at the top of the list in the user interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从`initialize()`中调用的相同方法。使用我们之前讨论的服务提供者接口，我们遍历系统中可用的每个`SocialMediaClient`。如果客户端已对其网络进行认证，我们调用`getItems()`方法，并将它可能返回的内容添加到本地变量`items`中。一旦我们查询了系统中配置的所有网络，我们就对列表进行排序。这将导致各种网络的条目相互交织，因为它们是按时间戳降序排列的。然后，我们将这个排序后的列表添加到我们的`ObservableList`的头部，即零元素，这样它们就会在用户界面中出现在列表的顶部。
- en: Adding another network - Instagram
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加另一个网络 - Instagram
- en: So that we can see another type of integration, as well as to demonstrate how
    the interfaces we've defined make adding new networks relatively quick and easy,
    let's add one more network to Sunago--Instagram. While Instagram is owned by Facebook,
    at the time of this writing, its APIs are much more permissive than the social-media
    giant's, so we'll be able to add an interesting integration relatively easily.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们可以看到另一种类型的集成，以及展示我们定义的接口如何使添加新网络相对快速和容易，让我们向Sunago添加一个额外的网络——Instagram。虽然Instagram属于Facebook，但在撰写本文时，其API比社交媒体巨头更为宽松，因此我们可以相对容易地添加一个有趣的集成。
- en: Much like with Twitter, we have a choice to make about how our interactions
    with the Instragram API will be handled. Just like Twitter, Instagram offers a
    public REST API that is secured using OAuth. Also, just like Twitter, though,
    manually implementing a client to consume those APIs is not an attractive proposition
    due to the level of effort required. Again, unless there's a compelling reason
    to write your own client library, I would suggest that using some sort of client
    wrapper should be the preferred route if one is available. Fortunately, there
    is--jInstagram.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与Twitter类似，我们在处理与Instagram API交互的方式上有选择权。就像Twitter一样，Instagram提供了一个使用OAuth进行安全保护的公共REST
    API。同样，就像Twitter一样，由于所需的努力水平，手动实现一个客户端来消费这些API并不是一个吸引人的提议。再次强调，除非有充分的理由编写自己的客户端库，否则如果可用，我建议使用某种客户端包装器应该是首选路线。幸运的是，有一个——jInstagram。
- en: Registering as an Instagram developer
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册为Instagram开发者
- en: 'Before starting to write our client, we need to register a new Instagram client
    with the service. We do that by first creating, if needed, an Instagram developer
    account at [https://www.instagram.com/developer](https://www.instagram.com/developer).
    Once we have an account, we need to register our application either by clicking
    the Register Your Application button on the page, or by visiting [https://www.instagram.com/developer/clients/manage/](https://www.instagram.com/developer/clients/manage/)
    directly. From here, we need to click on Register a New Client, which will present
    this form:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写我们的客户端之前，我们需要向服务注册一个新的Instagram客户端。我们通过首先创建（如果需要）一个Instagram开发者账户在[https://www.instagram.com/developer](https://www.instagram.com/developer)来完成这个操作。一旦我们有了账户，我们需要通过点击页面上的“注册您的应用程序”按钮或直接访问[https://www.instagram.com/developer/clients/manage/](https://www.instagram.com/developer/clients/manage/)来注册我们的应用程序。从这里，我们需要点击“注册新客户端”，这将显示此表单：
- en: '![](img/b7824295-77c9-46c5-bcc3-28f34366386b.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7824295-77c9-46c5-bcc3-28f34366386b.png)'
- en: Once you've registered your new client, you can click on the Manage button on
    the resulting web page to get your client ID and secret. Hold on to those, as
    you'll need them in a moment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你注册了新的客户端，你可以在生成的网页上点击“管理”按钮来获取你的客户端ID和密钥。请保留这些信息，因为你很快就会需要它们。
- en: 'Next, we''ll start the actual client by creating a new module just like we
    did for the Twitter module. This one, though, we''ll call `Sunago - Instagram`
    and the `artifactIdinstagram`. We''ll also go ahead and add the jInstagram dependency
    as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始实际的客户端创建，就像我们为Twitter模块所做的那样。不过，我们将称之为`Sunago - Instagram`和`artifactIdinstagram`。我们还将继续添加jInstagram依赖项，如下所示：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that we have the Sunago `api` dependency added as well already, scoped
    as provided. We also need to add the Shade plugin configuration, which looks just
    like it does in the Twitter module, so it's not shown here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已将Sunago `api`依赖项添加为已提供的作用域。我们还需要添加Shade插件配置，它看起来就像在Twitter模块中一样，所以这里没有展示。
- en: Implementing the Instagram client
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Instagram客户端
- en: With our new module created, we need to create three specific items to fulfill
    the contract provided by the Sunago API module. We need `SocialMediaPreferencesController`,
    `SocialMediaClient`, and `SocialMediaItem`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了新的模块之后，我们需要创建三个特定的项目来满足Sunago API模块提供的契约。我们需要`SocialMediaPreferencesController`、`SocialMediaClient`和`SocialMediaItem`。
- en: 'Our `SocialMediaPreferencesController` instance is `InstagramPreferencesController`.
    It has the same `getTab()` method required by the interface, which is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SocialMediaPreferencesController`实例是`InstagramPreferencesController`。它具有接口所需的相同`getTab()`方法，如下所示：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To save time and space, for this example, we''ve left the Instagram implementation
    much more basic than the one we created for Twitter, so the user interface definition
    does not hold much of interest. However, the authentication handling is interesting,
    as, while it has the same OAuth flow that Twitter uses, the data is returned in
    a manner that is much more easily consumed. The connect button calls this method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间和空间，在这个例子中，我们让Instagram的实现比为Twitter创建的实现要简单得多，所以用户界面定义没有太多兴趣。然而，身份验证处理很有趣，因为尽管它使用了与Twitter相同的OAuth流程，但数据返回的方式更容易消费。连接按钮调用此方法：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This uses the `LoginController` that we saw with Twitter, but our `Predicate`
    and `Consumer` are much more concise. The page to which the user is redirected
    has the code in the URL as a query parameter, so there''s no need to scrape the
    HTML. We can just pull it straight from the URL as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了我们在Twitter中看到的`LoginController`，但我们的`Predicate`和`Consumer`要简洁得多。用户被重定向到的页面将代码作为查询参数包含在URL中，因此不需要抓取HTML。我们可以直接从URL中提取，如下所示：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Once we have the code, we use an API on our `instagram` object to get the access
    token, which we then use to authenticate the user. So what does the `instagram`
    object look like? Like `TwitterClient`, `InstagramClient` is a `SocialMediaClient`
    that wraps the jInstagram API.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了代码，我们使用`instagram`对象上的API来获取访问令牌，然后我们使用它来验证用户。那么`instagram`对象看起来是什么样子呢？像`TwitterClient`一样，`InstagramClient`是一个`SocialMediaClient`，它封装了jInstagram
    API。
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The jInstagram API has two objects that we need to use. `InstagramService`
    encapsulates the OAuth logic. We get an instance of it using a builder as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: jInstagram API有两个我们需要使用的对象。`InstagramService`封装了OAuth逻辑。我们使用以下方式通过构建器获取其实例：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As discussed earlier, to run the application locally, you''ll need to provide
    your own API key and secret pair. The only use we have for the callback URL is
    to provide Instagram with a place to redirect our client to. Once it does that,
    we pull the code from the query parameters as we saw previously. Finally, we have
    to provide a list of scopes, which is what Instagram calls permissions, roughly.
    This list will allow us to get a list of the accounts that the authenticated user
    follows, which we''ll use to get images:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了在本地运行应用程序，你需要提供自己的API密钥和密钥对。我们唯一需要回调URL的地方是提供一个Instagram重定向我们客户端的地方。一旦它这样做，我们就从查询参数中提取代码，就像我们之前看到的那样。最后，我们必须提供一个作用域列表，这是Instagram所说的权限，大致上。这个列表将允许我们获取认证用户关注的账户列表，我们将使用它来获取图片：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you read the jInstagram documentation, you'll be tempted to use the method
    `instagram.getUserFeeds()`, and if you do, you'll get what I got--a `404` error
    page. Instagram has done some work on their API that jInstagram has not yet reflected.
    What we need to do, then, is implement our own wrapper for that, which jInstagram
    makes fairly simple. Here, we get a list of the people that the user follows.
    For each user, we call `processMediaForUser()` to fetch and store any pending
    images.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了jInstagram的文档，你可能会倾向于使用`instagram.getUserFeeds()`这个方法，如果你这样做，你会得到我得到的结果——一个`404`错误页面。Instagram在其API上做了一些工作，而jInstagram还没有反映出来。那么，我们需要做的是实现我们自己的包装器，这jInstagram做得相当简单。在这里，我们得到了用户关注的用户列表。对于每个用户，我们调用`processMediaForUser()`来获取和存储任何挂起的图片。
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using the same **since ID** and max count approach we used for the Twitter client,
    we request any recent media for the user. Each returned item is wrapped (via the
    lambda) in a `Photo` instance, which is our `SocialMediaItem` child for Instagram.
    Once we have our list, if it is not empty, we grab the first `Photo`, which we
    know is the oldest, because that's how the Instagram API returns its data, and
    we get the ID, which we store as the since ID for the next time this method is
    called. Finally, we return the `List` so that it can be added to the main `Photo`
    list given earlier.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与Twitter客户端相同的**since ID**和最大计数方法，我们请求用户的任何最近媒体。每个返回的项目都通过lambda包装在一个`Photo`实例中，这是我们的Instagram的`SocialMediaItem`子类。一旦我们有了我们的列表，如果它不为空，我们就获取第一个`Photo`，我们知道这是最老的，因为这是Instagram
    API返回数据的方式，我们获取ID，将其存储为下一次调用此方法时的since ID。最后，我们返回`List`，以便它可以添加到之前给出的主`Photo`列表中。
- en: Loading our plugins in Sunago
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Sunago中加载我们的插件
- en: 'With that, our new integration is done. To see it in action, we add the dependency
    to Sunago''s POM as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的新集成就完成了。要看到它的实际效果，我们将依赖项添加到Sunago的POM中，如下所示：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We then run the application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行应用程序。
- en: 'Clearly, adding a dependency for each new integration is not an ideal solution,
    if for no other reason than that the user won''t be running the application from
    an IDE or with Maven. What we need, then, is a way for the application to find
    any modules (or plugins, if you prefer that term) at runtime on the user''s machine.
    The simplest solution would be to launch the application via a shell script like
    this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为每个新的集成添加依赖并不是一个理想的解决方案，至少不是因为用户不会从IDE或使用Maven运行应用程序。那么，我们需要的是一种方法，让应用程序能够在用户的机器上运行时找到任何模块（或者如果你更喜欢这个术语，插件）。最简单的解决方案是通过如下这样的shell脚本启动应用程序：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This preceding shell script creates a classpath using the main Sunago jar, plus
    any JARs found in `~/.sunago`, and then runs the application. This is simple and
    effective, but does require per-operating system versions. Fortunately, that just
    means this shell script for Mac and Linux, plus a batch file for Windows. That's
    not hard to do or difficult to maintain, but it does require that you have access
    to those operating systems to test and verify your scripts.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个先前的shell脚本使用主Sunago jar创建了一个类路径，并加上在`~/.sunago`中找到的任何JAR文件，然后运行应用程序。这很简单且有效，但确实需要针对每个操作系统版本。幸运的是，这仅仅意味着为Mac和Linux编写这个shell脚本，以及为Windows编写一个批处理文件。这并不难做或难以维护，但确实需要你有权限访问这些操作系统来测试和验证你的脚本。
- en: Another option is to make use of classloaders. As simple as it may seem to say
    it out loud, a `ClassLoader` is simply an object that is responsible for loading
    classes (and other resources). There are several classloaders at work in any given
    JVM, all arranged in a hierarchical fashion, starting with the bootstrap `ClassLoader`,
    then the platform `ClassLoader`, and, finally, the system--or application--`ClassLoader`.
    It is possible that a given application or runtime environment, such as a **Java
    Enterprise Edition** (**Java EE**) application server, might add one or more `ClassLoader`
    instances as children of the application `ClassLoader`. These added `ClassLoader`
    instances may themselves be hierarchical or they may be **siblings**. Either way,
    they are almost certainly children of the application `ClassLoader`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是利用类加载器。虽然说出来可能听起来很简单，但`ClassLoader`实际上是一个负责加载类（以及其他资源）的对象。在任何给定的JVM中，都存在多个类加载器在工作，它们以分层的方式排列，从启动`ClassLoader`开始，然后是平台`ClassLoader`，最后是系统或应用`ClassLoader`。可能某个应用程序或运行时环境，例如**Java企业版**（**Java
    EE**）应用程序服务器，可能会将一个或多个`ClassLoader`实例作为应用程序`ClassLoader`的子类加载器添加。这些添加的`ClassLoader`实例本身可能是分层的，也可能是**兄弟**。无论如何，它们几乎肯定是应用程序`ClassLoader`的子类加载器。
- en: 'A full treatment of classloaders and all that they entail is well beyond the
    scope of this book, but suffice it to say that we can create a new `ClassLoader`
    to allow the application to find the classes and resources in our **plugin** jars.
    To do this, we need to add a few methods--three to be exact--to our application
    class, Sunago. We''ll start with the constructor:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对类加载器和所有相关内容的全面讨论超出了本书的范围，但可以简单地说，我们可以创建一个新的`ClassLoader`，以便应用程序能够找到我们**插件**jar文件中的类和资源。为此，我们需要向我们的应用程序类Sunago添加几个方法——确切地说，是三个方法——我们首先从构造函数开始：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Typically (though not always), when a JavaFX application starts, the `public
    static void main` method is run, which calls the `launch()` static method on the
    `Application` class, which we subclass. According to the Javadoc for `javafx.application.Application`,
    the JavaFX runtime performs the following steps when starting an application:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常（尽管并非总是如此），当JavaFX应用程序启动时，会运行`public static void main`方法，该方法在`Application`类上调用`launch()`静态方法，该类是我们子类化的。根据`javafx.application.Application`的Javadoc，JavaFX运行时在启动应用程序时执行以下步骤：
- en: Constructs an instance of the specified `Application` class.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造指定`Application`类的实例。
- en: Calls the `init()` method.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`init()`方法。
- en: Calls the `start(javafx.stage.Stage)` method.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`start(javafx.stage.Stage)`方法。
- en: 'Waits for the application to finish, which happens when any of the following
    occur:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待应用程序完成，这发生在以下任何一种情况发生时：
- en: The application calls `Platform.exit()`.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用`Platform.exit()`。
- en: The last window has been closed, and the `implicitExit` attribute on platform
    is true.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个窗口已关闭，平台上的`implicitExit`属性为true。
- en: Calls the `stop()` method.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`stop()`方法。
- en: 'We want to perform our `ClassLoader` work at step 1, in the constructor of
    our `Application`, to make sure that everything that follows has an up-to-date
    `ClassLoader`. That work is done in the second method that we need to add, which
    is this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在步骤1中执行我们的`ClassLoader`工作，在`Application`的构造函数中，以确保后续的所有内容都有一个最新的`ClassLoader`。这项工作是在我们需要添加的第二个方法中完成的，即：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We start by getting a list of the jar files (we'll see that code in a moment),
    then, if the array is non-null, we need to build an array of `URL`s, so, we iterate
    over the `File` array, and call `.toURI().toURL()` to do so. Once we have our
    `URL` array we create a new `ClassLoader` (`URLClassLoader.newInstance(urls)`),
    then set the `ClassLoader` for the current Thread via `Thread.currentThread().setContextClassLoader()`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取jar文件的列表（我们将在稍后看到这段代码），然后，如果数组非空，我们需要构建一个`URL`数组，因此，我们遍历`File`数组，并调用`.toURI().toURL()`来完成。一旦我们有了`URL`数组，我们创建一个新的`ClassLoader`（`URLClassLoader.newInstance(urls)`），然后通过`Thread.currentThread().setContextClassLoader()`设置当前线程的`ClassLoader`。
- en: 'This is our final additional method `getFiles()`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的最终附加方法`getFiles()`：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This last method simply scans the files in `$HOME/.sunago`, looking for a file
    that ends with `.jar`. A list of zero or more jar files is returned to our calling
    code for inclusion in the new `ClassLoader`, and our work is done.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的方法只是扫描`$HOME/.sunago`中的文件，寻找以`.jar`结尾的文件。返回一个包含零个或多个jar文件列表给我们的调用代码，以便包含在新的`ClassLoader`中，我们的工作就完成了。
- en: So there you have two ways of adding plugin jars to the runtime dynamically.
    Each has its strengths and weaknesses. The first requires multi-platform development
    and maintenance, while the second is a bit riskier, as classloaders can be tricky.
    I have tested the second approach on Windows and Linux and Java 8 and 9 with no
    errors detected. Which approach you use will, of course, depend on your unique
    environment and requirements, but you have at least two options with which to
    start your evaluation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你有两种方法可以将插件jar动态地添加到运行时。每种方法都有其优点和缺点。第一种方法需要跨平台开发和维护，而第二种方法风险略高，因为类加载器可能会很复杂。我已经在Windows和Linux上测试了第二种方法，在Java
    8和9上没有检测到错误。当然，你使用哪种方法将取决于你独特的环境和需求，但你至少有两个选项可以开始评估。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With all of that said, our application is complete. Of course, hardly any software
    is truly complete, and there's much more that could be done to Sunago. Twitter
    support could be expanded to include direct messages. The Instagram module needs
    some configuration options added. While the capabilities exposed via the Facebook
    API are limiting, some sort of meaningful Facebook integration could be added.
    Sunago itself could be modified to, say, add support for in-application viewing
    of social media content (as opposed to shelling out to the host operating system's
    default browser). There are a handful of minor user experience bugs that could
    be addressed. And the list can go on and on. What we do have, though, is a moderately
    complex, networked application, that demonstrates a number of features and capabilities
    of the Java platform. We've built an extensible, internationalized JavaFX application
    that demonstrates the use of the Service Provider Interface and `ClassLoader`
    magic, and offers many more examples of lambdas, stream operations, and functional
    interfaces.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，我们的应用程序已经完成。当然，几乎没有软件是完全完整的，Sunago还有很多可以改进的地方。Twitter支持可以扩展以包括直接消息。Instagram模块需要添加一些配置选项。虽然通过Facebook
    API暴露的功能有限，但可以添加某种有意义的Facebook集成。Sunago本身也可以修改，例如，添加支持在应用程序内查看社交媒体内容（而不是调用宿主操作系统的默认浏览器）。还有一些可以解决的轻微用户体验问题。而且这个列表可以一直继续下去。不过，我们确实拥有一个中等复杂度的网络应用程序，展示了Java平台的一些特性和功能。我们构建了一个可扩展的、国际化的JavaFX应用程序，展示了服务提供者接口和`ClassLoader`魔法的使用，并提供了许多关于lambda、流操作和函数式接口的示例。
- en: In the next chapter, we're going to build on the ideas presented here, and build
    an Android port of Sunago so that we can take our social media aggregation on-the-go
    with us.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于这里提出的思想，构建Sunago的Android端口，这样我们就可以随身携带我们的社交媒体聚合功能。
