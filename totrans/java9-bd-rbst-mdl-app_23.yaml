- en: Sunago - A Social Media Aggregator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our next project, we'll try something a bit more ambitious; we'll build
    a desktop application that aggregates data from various social media networks
    and displays it in one seamless interaction. We're also going to try something
    new, and we're going to give this project a name, something that might be a bit
    more appealing than the dry, albeit accurate, `description-turned-name` that we've
    used to date. This application, then, we'll call Sunago, which is the phonetic
    spelling of the (Koine) Greek word συνάγω, which means **I gather together**,
    **collect**, **assemble**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building the app will cover several different topics, some familiar, some new.
    That list includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Provider Interfaces** (**SPI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST API consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassLoader` manipulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas, lambdas, and more lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, those are the just the highlights with a number of interesting items
    sprinkled throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with every application, before we get started, we need to think about what
    we want the application to do. That is, what are the functional requirements?
    At a high level, the description tells us what we want to achieve in broad terms,
    but, more specifically, we want the user to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to several different social media networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine, on a network-by-network basis, which group of data (users, lists,
    and more) to retrieve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See list of items from each network in a consolidated display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to determine from which network an item came
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on an item and have it loaded in the user's default browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to this list of things the application **should** do, the things
    it **shouldn''t** do include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Respond/reply to items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment on items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage friends/following lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features would be great additions to the application, but they don't offer
    much that would be architecturally interesting beyond the basic application detailed
    previously, so, to keep things simple--and moving along--we'll limit the scope
    to the given basic set of requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So where to start on the application? As in the previous chapters, we''re going
    to make this a desktop application, so let''s start there, with a JavaFX application.
    I''m going to tip my hand a little bit here to make things easier later on: this
    will be a multi-module project, so we first need to create the parent project.
    In NetBeans, click on File | New Project..., and select the `Maven` category,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56038160-c5e4-4c2f-8385-9ba0b50630bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Next button, and fill in the project details, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cca6c4d-c2cc-4735-bfed-a885dbeaff0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on Finish, you will be presented with an empty project. Once
    we add modules to this project, differentiating them might become difficult, so
    something I do as a matter of practice is to give each module a distinct, "namespaced"
    name. That is to say, each module has its own name, of course, but I prefix that
    with the name of the project. For example, since this is the base POM of the project,
    I call it `Master`. To reflect that, I modify the generated POM to look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s really not much to this yet. The advantage that a parent POM like
    this gives us is that we can build all the projects with one command if we so
    desire, and we can move any shared configuration to this shared parent POM to
    reduce duplication. What we need to add now, though, is a module, which NetBeans
    helps us do, as seen in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84fdf68c-0c59-4b1c-804b-535a4242ccaa.png)'
  prefs: []
  type: TYPE_IMG
- en: After clicking on Create New Module..., you will be presented with the familiar
    New Project window, from which you'll want to select Maven | JavaFX Application,
    and click on Next. In the New Java Application screen, enter `app` for the project
    name, and click on Finish (all of the other defaults are acceptable as-is).
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we want to give this module a meaningful name, so let''s modify the
    generated `pom.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When NetBeans creates the project, it will generate several artifacts for us--two
    classes, `FXMLController` and `MainApp`, as well as the resources, `fxml/Scene.xml`
    and `styles/Styles.css`. While this may be stating the obvious, artifacts should
    have names that clearly communicate their purpose, so let's rename these.
  prefs: []
  type: TYPE_NORMAL
- en: The class `FxmlContoller` should be renamed to `SunagoController`. Perhaps the
    quickest and easiest way to do this is to open the class by double-clicking on
    it in Project View, then, in the source editor, click on the name of the class
    in the class declaration, and press *Ctrl* + *R*. The Rename Class dialog should
    appear, in which you need to enter the new name, and press *Enter*. This will
    rename the class and the file for you. Now repeat that process for `MainApp`,
    renaming it to `Sunago`.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to rename the generated FXML file, `Scene.xml`, to `sunago.fxml`.
    To do that, right-click on the file in Project View and select Rename... from
    the context menu. Enter the new name (without the extension) in the Rename dialog,
    and press *Enter*. While we're at it, let's also rename `Styles.css` to `styles.css`
    so that the case is consistent. It's a minor thing, but consistency in the code
    can help produce confidence in you in whoever might take over your code in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, renaming these files doesn''t adjust the references to them
    in the Java sources, so we need to edit `Sunago.java` to point to these new names,
    which is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note also that we changed the title to something more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we wanted to, we could now run our application. It would be very boring,
    but it would run. Let's try to fix the boring part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default FXML created is just an AnchorPane with two children, a Button
    and a Label. We don''t need any of those, so let''s get rid of them. Our main
    user interface will be pretty simple--basically, just a vertical stack of components--so
    we can use a VBox as our root component. Perhaps, the easiest way to change the
    root component from the AnchorPane that''s there to a VBox is to use Scene Builder
    to wrap that component in a VBox, and then delete the AnchorPane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5b12b35-a9e4-4b92-a7df-597c36cda218.png)'
  prefs: []
  type: TYPE_IMG
- en: To do that, open the FXML file in Scene Builder by double-clicking on the file
    (assuming you've configured NetBeans correctly so that it knows where to find
    Scene Builder. If not, refer back to [Chapter 17](ef175826-d02f-448f-b68e-5e3d03402bd0.xhtml),
    *Introduction*). In Scene Builder, right-click on AnchorPane in the Document section
    of the accordion on the left, select Wrap in, and then VBox, as shown in the preceding
    screenshot. Scene Builder will then modify the FXML file, making AnchorPane a
    child of VBox as expected. Once that's done, you can right-click on AnchorPane,
    and click on Delete to remove it and its children. This leaves us with an empty
    user interface that's more boring than it was when we began. We can fix that now
    by adding a couple of controls--a MenuBar and a ListView. We do that by clicking
    on each component in the Controls section of the accordion and dragging them to
    VBox. If you drop the components on VBox, they will be appended to its list of
    children. Make sure that MenuBar comes before ListView, or you'll have a very
    strange user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's configure these components a bit now before we return to the code. Selecting
    VBox from the Document section on the left, we then need to select the Layout
    section in the accordion on the right. For Min Width and Min Height, enter `640`
    and `480` respectively. This will make the window's default size larger and more
    user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: For MenuBar, we need to expand its entry under Document, then expand each of
    its Menu children, which should reveal one MenuItem per Menu. Click on the first
    Menu, then, on the right, set `Text` to `_File`, and check Mnemonic Parsing. This
    will allow the user to press *Alt* + *F* to activate (or show) this menu. Next,
    click on its `MenuItem` child, setting `Text` to `_Exit`, and check Mnemonic Parsing.
    (If the text for a `Menu`, `MenuItem`, `Button`, and more has an underscore in
    it, make sure that Mnemonic Parsing is checked. For brevity's sake, I won't flag
    this explicitly again.) Open the Code section, and set the On Action value to
    `closeApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: The second `Menu` should have its Text value set to `_Edit`. Its `MenuItem`
    should be labeled `_Settings`, and have an On Action value of `showPreferences`.
    Finally, the third `Menu` should be labeled `_Help`, and its `MenuItem` labeled
    `About` with an On Action of `showAbout`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to give `ListView` an ID, so select that on the left, make sure
    the Code section is expanded on the right, and enter `entriesListView` for fx:id.
  prefs: []
  type: TYPE_NORMAL
- en: The last edit we need to make is to set the controller. We do that in the accordion
    on the left, in the Controller section at the very bottom. Expand that, and make
    sure that the Controller class value matches the Java class and package we just
    created in NetBeans, then save the file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in NetBeans, we need to fix up our controller to reflect the changes we
    just made in our FXML. In `SunagoController`, we need to add the `entriesListView`
    property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the parameterized type is `SocialMediaItem`. That''s a custom model
    we''ll create in just a few moments. Before we tackle that, though, we need to
    finish wiring together our user interface. We defined three `onAction` handlers
    in the FXML. The corresponding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Closing the application is as simple as calling the `exit` method on the `Platform`
    class. Showing the "about" box is also fairly simple, as we see in the `showAbout`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the built-in `Alert` class, we construct an instance, and set the values
    appropriate for an About screen, then display it modally via `showAndWait()`.
  prefs: []
  type: TYPE_NORMAL
- en: The preferences window is a much more complicated piece of logic, so we wrap
    that up in a new controller class, and call its `showAndWait()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Writing the model class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at that, though, there are a few more items in the main controller
    that we need to take care of. The first is the model class mentioned earlier,
    `SocialMediaItem`. As you can probably imagine, the structure of the data returned
    from a social network can be quite complex, and certainly, varied. The data requirements
    for a tweet, for example, are likely to be quite different from those for an Instagram
    post. What we''d like to be able to do, then, is to hide those complexities and
    differences behind a simple, reusable interface. In the real world, such a simple
    abstraction is not always possible, but, for our purposes here, we have such an
    interface in `SocialMediaItem`, as you can see in this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One of the problems with abstractions is that, to make them reusable, you, occasionally,
    have to structure them in such a way that they expose properties that may not
    be used by every implementation. It's not obvious yet, but that is certainly the
    case here. It's a scenario that some consider to be unacceptable, and they may
    have a point, but it's really a question of trade-offs. Our options include a
    slightly bloated interface or a complex system in which each network support module
    (which we'll get to shortly) provides its own renderer, and the application has
    to interrogate each module, looking for the renderer that can handle each item
    while drawing `ListView`. There are likely others, of course, but faced with (at
    least) those two, for the sake of simplicity and performance, we'll take the first
    option. When faced with similar situations while designing your own systems, though,
    you'll need to evaluate the various requirements of your project, and make an
    appropriate choice. For our needs here, the simple approach is more than adequate.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any rate, each social media network module will implement that interface
    to wrap its data. This will give a common interface for the application to consume
    without needing to know exactly where it came from. We do, though, now need to
    tell the `ListView` how to draw a cell containing a `SocialMediaItem`. We can
    do that with this line of code in the `initialize()` method of our controller,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, that''s a lambda. For the curious, the pre-lambda version of the
    preceding method would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finishing up the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at `SocialMediaItemViewCell`, there are two more controller
    items. The first is the list that holds the `ListView` data. Remember that `ListView`
    operates from an `ObservableList`. This lets us make changes to the data in the
    list, and have it automatically reflected in the user interface. To create that
    list, we''ll use a JavaFX helper method when we define the class property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to connect that `List` to our `ListView`. Back in `intialize()`,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish off the rendering of `SocialMediaItem` interfaces, let''s define
    `SocialMediaItemViewCell` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's a fair amount happening here, but `updateItem()` is our first point
    of interest. This is the method that is called every time the row is updated on
    the screen. Notice that we check to see if `item` is null. We do that because
    `ListView` calls this method not for every item in its `List`, but for every row
    in `ListView` that's visible, whether there's data for it or not. That means that,
    if `List` has five items but `ListView` is tall enough to show ten rows, this
    method will be called ten times, with the last five calls being made with a null
    `item`. In those cases, we call `setGraphic(null)` to clear out any item that
    may have been previously rendered.
  prefs: []
  type: TYPE_NORMAL
- en: If `item` is not null, though, we need to build the `Node` to display the item,
    which is done in `buildItemCell()`. For each item, we want to render three items--the
    social media network icon (so users can tell at a glance where the item is from),
    any image embedded in the item, and, finally, any text/caption from the item.
    To help arrange that, we start with an `HBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we try to find an icon for the network. If we had a formal contract written
    up, we would include language in it that would stipulate that the module include
    a file called `icon.png`, which is in the same package as the module's `SocialMediaItem`
    implementation. Using the `ClassLoader` for the implementation, then, we try to
    get an `InputStream` for the resource. We check for null, just to make sure the
    image was actually found; if so, we create an `ImageView`, set some properties,
    then wrap the resource in an `Image`, hand that to `ImageView`, then add `ImageView`
    to `HBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an image for the item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the item has an image, we handle it in the same way that we did with the
    network icon image. This time, though, we actually wrap the `ImageView` in another
    `HBox` before adding it to the outer `HBox`. We do that so that we can add padding
    around the image (via `picture.setPadding(new Insets()`) to give this image some
    space between it and the network icon.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a `Label` to hold the item's body. We set the font size of
    the text to `20` points via `label.setFont(Font.font(null, 20))`, and add it to
    our `HBox`, which we then return to the caller, `updateItem()`.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you have a `ListView`, you are likely going to want a custom `ListCell`
    implementation like we have here. In some cases, calling `toString()` on the `List`
    contents might be appropriate, but that's not always the case, and you certainly
    can't have a complex `ListCell` structure like we have here without implementing
    `ListCell` yourself. If you're planning on doing much JavaFX development, you
    would be well advised to get comfortable with this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Building the preferences user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re finally **finished** with the main controller, and we can turn our attention
    to the next big piece, `PreferencesController`. Our preferences dialog will be,
    as is usually expected, a modal dialog. It will offer a tabbed interface with
    one tab for general settings, then a tab for each supported social network. We
    start that work by adding a new FXML file and controller to our project, and NetBeans
    has a great wizard for that. Right-click on the desired package, and click on
    New | Other. From the Categories list, select `JavaFX`, and then, from the File
    Types lists, select `Empty FXML` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d02c92bc-117c-466b-be35-293fbe47bdd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on Next, you should see the FXML Name and Location step. This
    will allow us to specify the name of our new file and the package in which it
    is created, as seen in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4da3802-8d3c-4b9e-98d8-cf745ab59519.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on Next brings us to the Controller Class step. Here we can either
    create a new controller class, or attach our file to an existing one. Since this
    is a new dialog/window for our app, we need to create a new controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdfc4f37-25ae-4350-bcf3-452f3f512432.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the Use Java Controller checkbox, enter `PreferencesController` for the
    name, and select the desired package. We could click on Next, which would take
    us to the Cascading Style Sheet step, but we're not interested in specifying that
    for this controller, so, we end the wizard by clicking on Finish, which will take
    us to the source of our newly created controller class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by laying out the user interface. Double-click on the new `prefs.fxml`
    file to open it in Scene Builder. Like our last FXML file, the default root element
    is AnchorPane. For this window, we'd like to use a BorderPane, so we use the same
    technique that we did last time to replace AnchorPane--right-click on the component,
    and click on Wrap in | BorderPane. The AnchorPane is now nested in BorderPane,
    so we right-click on it again and select Delete.
  prefs: []
  type: TYPE_NORMAL
- en: To build the user interface, we now drag a TabPane control from the accordion
    on the left, and drop it in the CENTER area of BorderPane. This will add a TabPane
    with two tabs to our user interface. We only want one right now, so delete the
    second one. We want to give our tab a meaningful label. We can do that by double-clicking
    on the tab in the preview window (or selecting the Text property in the Properties
    section of the Inspector) and typing `General`. Finally, expand the Inspector's
    Code section, and enter `tabPane` for fx:id.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to provide a means by which the user can close the window, and either
    save or discard changes. We implement that by dragging a ButtonBar component to
    our border pane's BOTTOM area. That will add a ButtonBar with one button, but
    we need two, so we drag another button on to the ButtonBar. The nice thing about
    this control is that it will handle button placement and padding for us, so, when
    we drop the new button, it's automatically added in the proper place on the right.
    (This behavior can be overridden, but it works exactly how we want it to, so we
    can just accept the defaults.)
  prefs: []
  type: TYPE_NORMAL
- en: For each `Button`, we need to set three properties--`text`, `fx:id`, and `onAction`.
    The first property is in the Properties section of the inspector, and the last
    two in the Code section. The values for the first button are `Save`, `savePrefs`,
    and `savePreferences`. For the second button, the values are `Cancel`, `cancel`,
    and `closeDialog`. Select the Layout section for the `ButtonBar` in the inspector,
    and set the right padding to 10 to make sure `Button` is not pressed against the
    edge of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll add our only preference at this point. We want to allow the user
    to specify the maximum number of items to retrieve from each social media network
    for a given request. We do that for those scenarios where the application hasn't
    been used in a while (or ever). In those cases, we don't want to try to download,
    for example, thousands of tweets. To add support for this, we add two controls,
    `Label` and `TextField`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the position of the Label control right is pretty simple, as it''s
    the first component. Scene Builder will provide red guidelines to help you position
    the component exactly where you want it, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c774516b-5875-403b-8295-dd116fa47675.png)'
  prefs: []
  type: TYPE_IMG
- en: Making sure that `TextField` is lined up with the label can be trickier. By
    default, when you drop a component on TabPane, Scene Builder will add an AnchorPane
    to hold the new components. An HBox might be a better choice, but we'll go ahead
    and use AnchorPane to demonstrate this feature of Scene Builder. If you drag a
    TextField onto TabPane and try to position it, you should see more red lines show
    up. Positioned just right, you should see a red line running through the middle
    of the Label and the `TextField`, indicating that the two components are vertically
    aligned. This is what we want, so make sure there is a small space between `TextField`
    and the label and drop it.
  prefs: []
  type: TYPE_NORMAL
- en: We need to give Label some meaningful text, so double-click on it in the preview
    window, and enter `Number of items to retrieve`. We also need to give `TextField`
    an ID so that we can interact with it, so click on the component, expand the Code
    section in the Inspector, and set fx:id to `itemCount`.
  prefs: []
  type: TYPE_NORMAL
- en: Our user interface, while basic, is now as complete as we can make it here,
    so save the file, close Scene Builder, and return to NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: Saving user preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow our newly-defined user interface to be wired into our controller,
    we need to create instance variables to match the controls with the `fx:id` attributes
    set, so, we add these to `PreferencesController` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `initialize()` method, we need to add support for loading the saved value
    for our `itemCount` field, so we need to talk a little bit about preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Java, being the general-purpose language that it is, makes it possible to write
    any preference storing strategy that you can image. Fortunately, though, it also
    offers a couple of different standard APIs that allow you to do so in a more easily
    portable manner, those being `Preferences` and `Properties`.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.Properties` class has been in the JDK since version 1.0, and
    while its basic, no-frills API might make that obvious, it's still a very useful
    abstraction. At its heart, `Properties` is a `Hashtable` implementation to which
    methods have been added for loading its data from input streams and readers, and
    writing its data to output streams and writers (in addition to a handful of other
    related methods). All the properties are treated as `String` values with `String`
    keys. Since `Properties` is a `Hashtable`, you can still use `put()` and `putAll()`
    to store non-string data, but that will result in `ClassCastException` should
    you call `store()`, so, it's probably best to avoid doing that.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.prefs.Preferences` class was added in Java 1.4, and it's a much
    more modern API. Whereas with properties we have to handle persistence separately,
    preferences handle that for us opaquely--we don't need to worry about how or when
    it's written. In fact, the call to set a preference may return immediately, while
    the actual persistence may not occur for quite some time. The contract of the
    `Preferences` API guarantees that preferences will be persisted even if the JVM
    shuts down, assuming it's a normal, ordered shutdown (by definition, there's not
    much that can be done if the JVM process suddenly dies).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the user also need not worry about how preferences are saved.
    The actual backing store is an implementation-specific detail. It could be a flat
    file, an OS-specific registry, a database or some sort of directory server. For
    the curious, the actual implementation is chosen by using the class name, if specified,
    in the `java.util.prefs.PreferencesFactory` system property. If that's not defined,
    the system will look for the file `META-INF/services/java.util.prefs.PreferencesFactory`
    (a mechanism known as SPI, which we will look at in depth later), and use the
    first class defined there. Finally, failing that, the implementation for the underlying
    platform is loaded and used.
  prefs: []
  type: TYPE_NORMAL
- en: So which to choose? Either will work as well as the other, but you have to decide
    if you want control of where the information is stored (`Properties`) or ease
    of implementation (`Preferences`). To a certain degree, portability might also
    be a concern. For example, if you have Java code running in some sort of a mobile
    or embedded device, you might not have permissions to write to the filesystem,
    and you might not have a filesystem at all. To show how similar the two implementations
    might be, though, we'll implement both.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put my cards on the table a little bit, I would like for as much of this
    code as possible to be reusable in an Android environment. To help facilitate
    that, we''ll create a very simple interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We're only dealing with strings and integers, as the needs of the application
    are pretty basic. With the interface defined, how do we get a reference to an
    implementation? For that, we'll use a technique we've already seen mentioned briefly--the
    Service Provider Interface (SPI).
  prefs: []
  type: TYPE_NORMAL
- en: Plugins and extensions with the Service Provider Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen SPI mentioned before when we looked at the `Preferences`
    class, and how the implementation is selected and loaded, but what exactly is
    it? The Service Provider Interface is a somewhat generic term for an interface
    that a third party can implement (or a class, abstract or not, that can be extended)
    to provide extra functionality, replace existing components, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the author of the target system (for example, the JDK itself
    in our previous example) defines and publishes an interface. Ideally, this system
    would provide a default implementation, but that's not necessary in all cases.
    Any interested third party could then implement this interface, register it, and
    the target system could then load and use it. One of the advantages of this approach
    is that the target system can be extended easily, with no coupling to the third
    party. That is to say, while the third party knows about the target system via
    the interface, the target system has no knowledge at all of the third party. It's
    merely operating off the interface it defined.
  prefs: []
  type: TYPE_NORMAL
- en: How are these third-party plugins registered with the target system? The third-party
    developer would create a text file using a specific file in a specific directory.
    The file has the same name as the interface being implemented. For the `Preferences`
    class example, one would be implementing the `java.util.prefs.PreferencesFactory`
    interface, so that would be the name of the file, which would be in the `META-INF/services`
    directory in the root of the libraries classpath. In a Maven-based project, the
    file would be found in `src/main/resources/META-INF/services`. The file contains
    just the name of the class implementing the interface. It's also possible to have
    more than one class listed in the services file, each on a new line. It's up to
    the consuming system, though, as to whether or not each of those might be used.
  prefs: []
  type: TYPE_NORMAL
- en: So what does all of this look like for us? As noted earlier, we're going to
    take a rare opportunity to show multiple implementations for our `Preferences`
    support. Both classes are small enough that we can show the uses of both `Properties`
    and `Preferences`, and use SPI to pick one to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `Properties`-based implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start by implementing our `SunagoPreferences` interface.
    We then create an instance of the `Properties` class, and we also define a constant
    for the file name and location, which we put--in a system-independent manner--in
    the user's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Resource handling with try-with-resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The constructor shows something interesting that we haven''t talked about--try-with-resources.
    Prior to Java 8, you might have written something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This preceding, incredibly verbose code declares an `InputStream` outside the
    try block, then does some work with it in the `try` block. In the `finally` block,
    we try to close the `InputStream`, but we first have to check to see if it's null.
    If, say, the file doesn't exist (as it won't be the first time this class is created),
    an `Exception` will be thrown, and `input` will be null. If it's not null, we
    can call `close()` on it, but that might throw `IOException`, so we have to wrap
    that in a `try/catch` block as well.
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 introduced the try-with-resources construct that makes this much smaller.
    If an object is an instance of `AutoCloseable`, then it can be defined **inside**
    the `try` declaration, and it will be closed automatically when the `try` block
    scope terminates regardless of whether or not an `Exception` was thrown. That
    allows us to take what would normally be fourteen lines of code, and express the
    exact same functionality in four with much less noise.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from `AutoCloseable`, note that we load any existing values in the file
    into our `Properties` instance via `Properties.load(InputStream)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, what we see next are pretty straightforward getters and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The final method is the one that writes our preferences back out, which is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This last method looks a lot like our constructor, but we create an `OutputStream`,
    and call `Properties.store(OutputStream)` to write our values out to a file. Note
    that we call this method from every put method to make sure, insofar as possible,
    that the user preferences are faithfully persisted to disk.
  prefs: []
  type: TYPE_NORMAL
- en: What would a Preferences-based implementation look like? Not much different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Two things to note. First, we don't need to handle persistence, as `Preferences`
    does that for us. Second, the instantiation of the `Preferences` instance needs
    some attention. Clearly, I think, we want these preferences to be scoped to the
    user, so we start with `Preferences.userRoot()` to get the root preference node.
    Then we ask for the node in which we want to store our preferences, which we have
    chosen to name after the package of our class.
  prefs: []
  type: TYPE_NORMAL
- en: Where does that put things? On Linux, the file might look something like ``~/.java/.userPrefs/_!':!bw"t!#4!cw"0!'`!~@"w!'w!~@"z!'8!~g"0!#4!ag!5!')!c!!u!(:!d@"u!'%!~w"v!#4!}@"w!(!=/prefs.xml``
    (yes, that's a directory name). On Windows, those preferences are saved in the
    Windows Registry under the key `HKEY_CURRENT_USERSOFTWAREJavaSoftPrefscom.steeplesoft.sunago.app`.
    Unless you want to interact directly with these files, though, their exact location
    and format are merely implementation details. Sometimes, though, it's a good thing
    to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two implementations, so how do we pick which one to use? In the file
    (including the source root for clarity) `src/main/resources/META-INF/service/com.steeplesoft.sunago.api.SunagoPreferences`,
    we can put one of these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list both, but only the first will be chosen, which we''ll see now.
    To make things simple, we''ve wrapped this up in a utility method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In what may be a bit of an overkill for our purposes here, we've implemented
    a singleton by declaring the instance of the `SunagoPreferences` interface as
    a private static, and made it available via a synchronized method, which checks
    for `null`, and creates the instance if needed.
  prefs: []
  type: TYPE_NORMAL
- en: While that's interesting, don't let it distract you from the meat of the method.
    We use the `ServiceLoader.load()` method to ask the system for any implementations
    of the `SunagoPreferences` interface. It's worth noting again, just to be clear,
    that it won't pick up **any** implementation in the system, but **only** those
    listed in the services file we described earlier. Using the `ServiceLoader<SunagoPreferences>`
    instance, we grab an iterator, and if it has an entry (`iterator.hasNext()`),
    we return that instance (`iterator.next()`). If it does not, we return `null`.
    There is a chance here for a `NullPointerException` since we are returning `null`,
    but we're also providing an implementation, so we avoid that risk. However, in
    your own code, you need to either ensure you have an implementation as we've done
    here, or to make sure that the consuming code is `null`-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a network - Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have a pretty basic application, which can save and load its preferences,
    but let's get down to what we're here for and start connecting to social networks.
    What we hope to develop is a framework that makes it easy to add support for different
    social networks. Technically, as we'll soon see, the **network** need not even
    be social as the only thing that will imply a specific type of source is the name
    of the classes and interfaces involved. However, we will, in fact, focus on social
    networks, and we'll use a couple of different ones to show some variety. To that
    end, we'll start with Twitter, the massively popular microblogging platform, and
    Instagram, the increasingly photo-focused network that is now part of Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of Facebook, why are we not demonstrating integration with that social
    network? Two reasons--One, it's not significantly different from Twitter, so there
    would not be much that was new to cover; two, most importantly, the permissions
    that Facebook offers make it virtually impossible to integrate with it in a way
    that would be of interest here. For example, the permission to read a user's home
    timeline (or wall) is only granted to applications targeted at those platforms
    where Facebook is not currently available, and not at all to desktop applications,
    which is our target here.
  prefs: []
  type: TYPE_NORMAL
- en: As noted previously, we'd like to expose a way to add more networks without
    having to change the core application, so we need to develop an API. What we'll
    cover here is that API in a more or less **finished** state (is any software every
    truly finished?). However, while you will see a reasonably complete API, a word
    of caution--attempts to create an abstraction that start with that abstraction--that
    is, writing the abstraction from scratch--rarely end well. It is usually best
    to write a specific implementation to get a better understanding of the details
    required, then extract an abstraction. What you will see here is the end result
    of that process, so that process will not be covered here in any depth.
  prefs: []
  type: TYPE_NORMAL
- en: Registering as a Twitter developer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an application that integrates with Twitter, we need to create a
    Twitter developer account, and then create a Twitter application. To create the
    account, we need to visit [https://dev.twitter.com](https://dev.twitter.com/),
    and click on the Join button. Once you''ve created your developer account, you
    can click the My Apps link to go to [https://apps.twitter.com](https://apps.twitter.com/).
    Here, we need to click on the Create New App button, which will get us a form
    that looks a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42daa02b-d5ea-4112-9c95-14dfcb9c1727.png)'
  prefs: []
  type: TYPE_IMG
- en: While the application we're developing is called *Sunago*, you won't be able
    to use that name, as it's already taken; you'll have to create a unique name of
    your own, assuming you're planning to run the application yourself. Once you've
    created the application, you'll be taken to the Application Management page for
    your new app. From this page, you can manage your app's permissions and keys,
    and, if needed, you can delete your app.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note on this page, as we'll need this soon, is where to find your
    application's Consumer Key and Secret. These are long, alphanumeric strings that
    your application will use to authenticate with Twitter's services. To interact
    with Twitter on behalf of a user--our ultimate goal--requires a different set
    of tokens, which we'll fetch shortly. Your Consumer Key and Secret--especially,
    Consumer Secret--should be kept, well, secret. If this combination is ever revealed
    publicly, other users will be able to masquerade as your app, potentially causing
    you serious headaches if they abuse the service. For that reason, you won't see
    the key/secret combination I generated anywhere in this book or the source code,
    which is why you will need to generate your own.
  prefs: []
  type: TYPE_NORMAL
- en: Armed now with our Consumer Key and Secret, we need to decide how to talk to
    Twitter. Twitter offers a public REST API, which they document on their site.
    If we were so inclined, we could pick an HTTP client of some sort, and start making
    calls. In the interests of simplicity and clarity, though, not to mention robustness,
    fault tolerance, and so on, we might be better served using a higher-level library
    of some sort. As luck would have it, there is a such a library, Twitter4J, which
    will make our integration much simpler and cleaner (for the curious, Twitter4J
    has over 200 Java classes. While we won't need all of the functionality represented
    there and exposed via the REST API, it should give you an idea of the scope of
    the effort required to write a reasonable wrapper for Twitter's REST interface).
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we want to be able to add networks to Sunago without
    having to change the core application, so we will write our Twitter integration
    in a separate Maven module. This will require that some of the code we''ve already
    written for Sunago be extracted into yet another module. Both our Twitter module
    and the main application module will then add a dependency on this new module.
    Since we''ll have multiple modules at play here, we''ll be sure to indicate to
    which module each class belongs. When we''re finished, our project dependency
    graph will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/beb9bc78-0b95-45e0-aad5-5834e235f1f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Technically, the only reason we show a dependency between the Application module
    and the Instagram and Twitter modules is because we're building them as part of
    the same project. A third-party developer, as we'll see, could easily develop
    an independent module, add it to the application's runtime classpath, and see
    the change in the application, all without this build-level dependency. Hopefully,
    though, this graph helps explain how the modules are related.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Twitter preferences to Sunago
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding Twitter to our preferences screen. Before we can do
    any integration, we need to be able to configure the application, or, more accurately,
    the Twitter module, so that it can connect as a specific user. To enable that,
    we''ll add a new interface to the API module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface will give Sunago two hooks into the module--one giving the module
    a chance to draw its own preferences user interface, and one to allow it to save
    those preferences. We can then implement that in our module. Before we do so,
    though, let''s see how the application will find these implementations so that
    they can be used. For that, we will again turn to SPI. In Sunago''s `PreferencesController`
    interface, we add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have an instance variable to hold a list of any `SocialMediaPreferencesController`
    instances we find. Next, in `initialize()`, we call the now familiar `ServiceLoader.load()`
    method to find any implementations, which we then add to the `List` that we created
    previously. Once we have our list of controllers, we call `getTab()` on each of
    them, adding the returned `Tab` instance to the `PreferencesController` interface's
    `tabPane`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the loading part clarified, let''s now take a look at the Twitter preferences
    user interface implementation. We start by implementing the controller that will
    back this part of the user interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll take a look at `TwitterClient` in a moment, but, first, a note on `getTab()`.
    Notice that we create the `Tab` instance, which we need to return, but we delegate
    the creation of its contents to the `getNode()` method. `Tab.setContent()` allows
    us to completely replace the contents of the tab with a single call, something
    we''ll make use of next. The `getNode()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the user has already authenticated, then we want to present some configuration
    options. If not, then we need to offer a means to connect to Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this simple user interface, we create an `HBox` primarily so we can add some
    padding. Without the `new Insets(10)` instance we pass to `setPadding()`, our
    button would be pressed right up against the top and left edges of the window,
    which is not visually appealing. Next, we create the `Button`, and set the `onAction`
    handler (ignore that constructor parameter for now).
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part is hidden away in `connectToTwitter`, as shown in this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: OAuth and logging on to Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll take a detour into `LoginController` in just a moment, but first, let''s
    make sure we understand what''s going on here. To log on to Twitter on behalf
    of a user, we need to generate an OAuth request token from which we get an authorization
    URL. The details of which are hidden nicely behind the Twitter4J API, but it is,
    basically, the OAuth authorization URL listed on the Application Management page
    with a request token passed as a query string. As we''ll see, this URL is opened
    in a `WebView`, which prompts the user to authenticate against Twitter, and then
    authorize the application (or decline to):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de141ca9-ccda-489a-b1f5-8aa496d98983.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the user successfully authenticates and authorizes the application, the
    `WebView` is redirected to a success page, which displays a numeric code that
    we need to capture to finish gathering the authentication/authorization credentials
    needed. The success page might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2104c10e-20b4-4313-ac1c-eb187fe49f8b.png)'
  prefs: []
  type: TYPE_IMG
- en: For those not familiar with OAuth, what this allows us to do is to authenticate
    as the user, now and at any arbitrary moment in the future, without needing to
    store the user's actual password. The end result of this handshake between our
    application and Twitter is a token and token secret, which we'll pass to Twitter
    for authentication. As long as this token is valid--the user can invalidate it
    at any time via Twitter's web interface--we can connect and act as that user.
    Should the key ever be compromised, the user can revoke the key, affecting only
    the intended app and anyone attempting to use the stolen key.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginController`, which is part of the API module, handles all of the boilerplate
    code for us, as seen in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This preceding code is a basic FXML-backed JavaFX controller, but we do have
    a static helper method to handle the details of creating, configuring, and showing
    an instance. We load the scene using FXML, get the controller (which is an instance
    of the enclosing class), set the `loginSuccessTest` and `handler` properties,
    and then show the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Do `loginSuccessTest` and `handler` look odd? They are instances of the Java
    8 functional interfaces `Predicate<T>` and `Consumer<T>`. `Predicate` is a functional
    interface that takes a type, `WebEngine` in our case, and returns a `boolean`.
    It is designed to check for a certain condition given a variable of the specified
    type. In this instance, we call `WebEngine.executeScript().contains()` to extract
    a piece of the document, and see if it contains a certain piece of text indicating
    that we've been redirected to the login success page.
  prefs: []
  type: TYPE_NORMAL
- en: '`Consumer<T>` is a functional interface (or, in our case, a lambda) that takes
    a single parameter of the specified type, and returns void. Our handler is a `Consumer`,
    which is called once our `Predicate` returns true. The lambda extracts the code
    from the HTML page, calls `saveTwitterAuthentication()` to finish authenticating
    the user, then `showConfigurationUI()` to change the user interface so that the
    user can configure Twitter-related settings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `saveTwitterAuthentication()` is very straightforward, and is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The method `twitter.getAccessToken()` takes our request token and the code we
    extracted from the web page, and sends an HTTP `POST` to a Twitter REST endpoint,
    which generates the token secret we need. When that request returns, we store
    the token and token secret to our `Preferences` store (again, oblivious to where
    and how).
  prefs: []
  type: TYPE_NORMAL
- en: The method `showConfigurationUI()` and the related method should also be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: One new item in this preceding method is the listener we add to the `selectedProperty`
    of the `CheckBox`. Any time the selected value changes, our listener is called,
    which sets the value of the `showHomeTimeline` boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ListView` also needs special attention. Notice the parameterized type,
    `SelectableItem<UserList>`. What is that? That''s an abstract class we''ve created
    to wrap items for use in `CheckBoxListCell`, which you can see in the call to
    `setCellFactory()`. That class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This class, which lives in the API module, is a simple wrapper around an arbitrary
    type that adds a `SimpleBooleanProperty`. We see how this property is manipulated
    when the cell factory is set up--`lv.setCellFactory(CheckBoxListCell .forListView(item
    -> item.getSelected()))`. We expose `SimpleBooleanProperty` via the `getSelected()`
    method, which the `CheckBoxListCell` uses to set and read the state of each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final user interface-related method is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using the same `SelectableItem` class, we request from Twitter all of the lists
    the user might have created, which we wrap in `SelectableUserList`, a `SelectableItem`
    child that overrides the `toString()` method to provide user-friendly text in
    `ListView`. We load any checked lists from preferences, set their respective booleans/checkboxes,
    and update our `ObservableList` and, thus, the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method we need to implement to satisfy the `SocialMediaPreferencesController`
    contract is `savePreferences()`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is a mostly straightforward saving of the user's options to preferences,
    but the list handling is worth pointing out. Rather than manually iterating over
    each item in the list, we can use a stream and apply a couple of `filter()` operations
    to strip out entries that are of no interest to us, `map()` each `SelectableUserList`
    that makes it through to `Long` (which is the list's ID), then collect them in
    a `List<String>`. We join that `List` using `String.join()`, and write it out
    to our preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a model for Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are still a couple of other interfaces that we need to implement to finish
    our Twitter support. The first, and simpler, one is `SocialMediaItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding interface provides us with a nice abstraction over the various
    types of data that a social network might return without being too heavily burdened
    with fields that aren''t used by most (or many, at least) networks. The Twitter
    implementation of this `Tweet` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking the Twitter4J class `Status`, we extract information of interest to
    us, and store it in instance variables (whose getters are not shown, as they''re
    just simple getters). For the `getImage()` method, we make a reasonable effort
    to extract any image from the tweet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a Twitter client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second interface is `SocialMediaClient`. This interface serves not only
    as an abstraction that Sunago can use to interact with an arbitrary social network
    integration, but also as a guideline for interested developers to show them the
    minimum requirements for the integration. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For Twitter support, this preceding interface is implemented by the class `TwitterClient`.
    Most of the class is pretty basic, so we won''t reproduce that here (you can peruse
    it in the source repository if you''d like details), but one implementation detail
    might be worth spending some time over. That method is `processList()`, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are several things going on in this last method. First, we want to limit
    how many tweets we actually retrieve. If this is the first time the app is used,
    or the first time that it's used in a long time, there could be a significant
    number of tweets. Retrieving all of them would be quite expensive in terms of
    network usage, memory and, perhaps, processing time. We implement that limit using
    the `Paging` object from Twitter4J.
  prefs: []
  type: TYPE_NORMAL
- en: We also don't want to retrieve tweets we already have, so, for each list, we
    keep a `sinceId`, which we can pass to the Twitter API. It will use this to find
    up to the specified number of tweets whose ID is greater than `sinceId`.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping all of this up in the `Paging` object, we call either `twitter.getHomeTimeline()`
    if the list ID is `-1` (an internal ID we've used to identify the home timeline)
    or `twitter.getUserListStatus()` for a user-defined list. For each `Status` returned,
    we update `sinceId` (which we've modeled using an `AtomicLong`, as any method
    variable used inside a lambda must be final or effectively final), and add the
    tweet to our `List`. Before exiting, we store `sinceId` for the list in our in-memory
    store, and then return the tweets for the Twitter list.
  prefs: []
  type: TYPE_NORMAL
- en: A brief look at internationalization and localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While somewhat basic, our integration with Twitter is now complete, as it fulfills
    our functional requirements for the network. However, there is one more piece
    of code that we need to take a quick look at. Earlier, in some of the code samples,
    you might have noticed code that looks like this: `MessageBundle.getInstance().getString("homeTimelineCB")`.
    What is that, and what does it do?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageBundle` class is a small wrapper around the internationalization
    and localization facilities (also known as i18n and l10n, where the numbers represent
    the number of letters dropped from the words to make the abbreviation) provided
    by the JDK. The code for this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There are two main items of interest here. We'll start at the end of the class
    with the `getInstance()` method. This is an example of what is known as the **initialize
    on demand holder** (**IODH**) pattern. There is a single, static instance of the
    class `MessageBundle` in the JVM. It is not initialized, however, until the `getInstance()`
    method is called. This is accomplished by taking advantage of how the JVM loads
    and initializes statics. As soon as a class is referenced in any way, it is loaded
    into `ClassLoader`, at which point any statics on the class will be initialized.
    The private static class `LazyHolder` is **not** initialized until the JVM is
    sure that something needs to access it. Once we call `getInstance()`, which references
    `LazyHolder.INSTANCE`, the class is initialized and the singleton instance created.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that are ways around the singleton nature we're trying to
    implement (for example, via reflection), but our use case here does not warrant
    any worries over such an attack.
  prefs: []
  type: TYPE_NORMAL
- en: The actual functionality is implemented in the first line of the class, which
    is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `ResourceBundle` files, in the words of the Javadoc, *contain locale-specific
    objects*. Usually, this means Strings, as it does in our case. The `getBundle()`
    method will attempt to find and load a bundle with the name given for the specified
    locale. In our case, we're looking for a bundle named `Messages`. Technically,
    we're looking for a bundle in a family of bundles with the shared base name `Messages`.
    The system will use the `Locale` specified to find the correct file. This resolution
    will follow the same lookup logic that `Locale` uses, so the `getBundle()` method
    will return the bundle with the most specific matching name available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we''re running this application on my computer. I live in the United
    States, so my system''s default locale is `en_US`. Following the rules of the
    `Locale` lookup, then, `getBundle()` will try to locate files in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Messages_en_US.properties`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Messages_en.properties`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Messages.properties`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The system will go from the most specific file to the least until it finds
    the key requested. If it''s not found in any file, `MissingResourceException`
    is thrown. Each file consists of key/value pairs. Our `Messages.properties` file
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It is just a simple mapping of keys to localized text. We could have `Messages_es.properties`
    with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If that were the only entry in the file, that one label in the file would be
    in Spanish, with everything else being in the default from `Message.properties`,
    which, in our case, is English.
  prefs: []
  type: TYPE_NORMAL
- en: Making our JAR file fat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, our implementation is now complete. Before this can be used in the
    way we intend, though, we need to make a build change. If you recall the discussion
    of the requirements at the beginning of the chapter, we want to build a system
    that easily allows third-party developers to write modules that will add support
    for arbitrary social networks without the need to modify the core application.
    To deliver that functionality, these developers would need to offer a JAR that
    Sunago users could drop in a folder. When the application is started, the new
    functionality is now available.
  prefs: []
  type: TYPE_NORMAL
- en: 'That leaves us, then, with the task of bundling all of the required code. As
    the project stands now, a single JAR is created, which holds just our classes.
    That''s not entirely sufficient, though, as we depend on the Twitter4J jar. Other
    modules could have even more dependencies. Requiring users to drop in, say, half
    a dozen or more jars is probably asking a bit much. Fortunately, Maven has a mechanism
    that will allow us to avoid that problem altogether: the shade plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By configuring this plugin in our build, we can generate a single jar that
    holds our classes and resources, plus those of every dependency declared in the
    project. This is often called a **fat jar**, and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is an official Maven plugin, so we can omit `groupId`, and we've defined
    a property, `plugin.shade`, somewhere up the POM's inheritance tree. When the
    package phase is run, the shade goal of this plugin will execute and build our
    fat jar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The original jar, which is considerably smaller, is renamed to `original-twitter-1.0-SNAPSHOT.jar`,
    and the fat jar receives the configured final name. It is this fat jar that is
    installed in the local maven repository, or deployed to an artifact manager, such
    as Artifactory.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a small bug, though. Our twitter module depends on the API module
    so that it can see the interfaces and classes exposed by the application. Currently,
    even those are included in the fat jar, which we don''t want, as that can cause
    some `ClassLoader` issues down the road in some situations. To prevent that, we
    mark that dependency as `provided`, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we issue a `mvn clean install` now, we'll have a nice fat jar with only the
    classes we need to bundle, and one that's ready for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things as simple as possible, we''re just going to declare a dependency
    on this jar in Sunago''s app module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If we run Sunago now, we'll see Twitter added to our settings screen, and, once
    connected and configured, we'll see tweets showing up on the main screen. We'll
    also notice that the main screen is a little plain, and, more importantly, doesn't
    provide any way of refreshing the contents, so let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a refresh button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Projects window, find `sunago.fxml`, right-click on it, and select `Edit`.
    We''ll make this user interface change by hand, only for the sake of experience.
    Scroll down until you find the closing `Menubar` tag (`</Menubar>`). On the line
    right after that, insert these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In `SunagoController`, we need to add the instance variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `initialize()`, we need to set them up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're doing a bit more than setting up an action handler. The first
    thing we do is call `setGraphic()`. Remember from our discussion of the Twitter
    preference tab, calling `setGraphic()` will replace the child nodes with the `Node`
    that you specify. In these two cases, that `Node` is an `ImageView`, and comes
    from the `getButtonImage()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After we set the action handler, we also set a tooltip. This will give our
    graphical buttons a textual description when the user hovers over the button with
    the mouse, as seen in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89fcdd48-39c2-4ae8-9eb2-85641a96ab99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The action handler for the refresh button is worth looking at, and is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is the same method that we call from `initialize()`. Using the Service
    Provider Interface that we discussed earlier, we iterate over each `SocialMediaClient`
    available in the system. If the client has authenticated against its network,
    we call the `getItems()` method, and add whatever it may return to a local variable,
    `items`. Once we've queried all of the networks configured in the system, we then
    sort our list. This will cause the entries of the various networks to be intermingled,
    as they're sorted by their timestamps in descending chronological order. This
    sorted list is then added to our `ObservableList` at the head, or the zeroth element,
    to cause them to appear at the top of the list in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another network - Instagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So that we can see another type of integration, as well as to demonstrate how
    the interfaces we've defined make adding new networks relatively quick and easy,
    let's add one more network to Sunago--Instagram. While Instagram is owned by Facebook,
    at the time of this writing, its APIs are much more permissive than the social-media
    giant's, so we'll be able to add an interesting integration relatively easily.
  prefs: []
  type: TYPE_NORMAL
- en: Much like with Twitter, we have a choice to make about how our interactions
    with the Instragram API will be handled. Just like Twitter, Instagram offers a
    public REST API that is secured using OAuth. Also, just like Twitter, though,
    manually implementing a client to consume those APIs is not an attractive proposition
    due to the level of effort required. Again, unless there's a compelling reason
    to write your own client library, I would suggest that using some sort of client
    wrapper should be the preferred route if one is available. Fortunately, there
    is--jInstagram.
  prefs: []
  type: TYPE_NORMAL
- en: Registering as an Instagram developer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting to write our client, we need to register a new Instagram client
    with the service. We do that by first creating, if needed, an Instagram developer
    account at [https://www.instagram.com/developer](https://www.instagram.com/developer).
    Once we have an account, we need to register our application either by clicking
    the Register Your Application button on the page, or by visiting [https://www.instagram.com/developer/clients/manage/](https://www.instagram.com/developer/clients/manage/)
    directly. From here, we need to click on Register a New Client, which will present
    this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7824295-77c9-46c5-bcc3-28f34366386b.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you've registered your new client, you can click on the Manage button on
    the resulting web page to get your client ID and secret. Hold on to those, as
    you'll need them in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll start the actual client by creating a new module just like we
    did for the Twitter module. This one, though, we''ll call `Sunago - Instagram`
    and the `artifactIdinstagram`. We''ll also go ahead and add the jInstagram dependency
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have the Sunago `api` dependency added as well already, scoped
    as provided. We also need to add the Shade plugin configuration, which looks just
    like it does in the Twitter module, so it's not shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Instagram client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our new module created, we need to create three specific items to fulfill
    the contract provided by the Sunago API module. We need `SocialMediaPreferencesController`,
    `SocialMediaClient`, and `SocialMediaItem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `SocialMediaPreferencesController` instance is `InstagramPreferencesController`.
    It has the same `getTab()` method required by the interface, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To save time and space, for this example, we''ve left the Instagram implementation
    much more basic than the one we created for Twitter, so the user interface definition
    does not hold much of interest. However, the authentication handling is interesting,
    as, while it has the same OAuth flow that Twitter uses, the data is returned in
    a manner that is much more easily consumed. The connect button calls this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `LoginController` that we saw with Twitter, but our `Predicate`
    and `Consumer` are much more concise. The page to which the user is redirected
    has the code in the URL as a query parameter, so there''s no need to scrape the
    HTML. We can just pull it straight from the URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the code, we use an API on our `instagram` object to get the access
    token, which we then use to authenticate the user. So what does the `instagram`
    object look like? Like `TwitterClient`, `InstagramClient` is a `SocialMediaClient`
    that wraps the jInstagram API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The jInstagram API has two objects that we need to use. `InstagramService`
    encapsulates the OAuth logic. We get an instance of it using a builder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed earlier, to run the application locally, you''ll need to provide
    your own API key and secret pair. The only use we have for the callback URL is
    to provide Instagram with a place to redirect our client to. Once it does that,
    we pull the code from the query parameters as we saw previously. Finally, we have
    to provide a list of scopes, which is what Instagram calls permissions, roughly.
    This list will allow us to get a list of the accounts that the authenticated user
    follows, which we''ll use to get images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you read the jInstagram documentation, you'll be tempted to use the method
    `instagram.getUserFeeds()`, and if you do, you'll get what I got--a `404` error
    page. Instagram has done some work on their API that jInstagram has not yet reflected.
    What we need to do, then, is implement our own wrapper for that, which jInstagram
    makes fairly simple. Here, we get a list of the people that the user follows.
    For each user, we call `processMediaForUser()` to fetch and store any pending
    images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Using the same **since ID** and max count approach we used for the Twitter client,
    we request any recent media for the user. Each returned item is wrapped (via the
    lambda) in a `Photo` instance, which is our `SocialMediaItem` child for Instagram.
    Once we have our list, if it is not empty, we grab the first `Photo`, which we
    know is the oldest, because that's how the Instagram API returns its data, and
    we get the ID, which we store as the since ID for the next time this method is
    called. Finally, we return the `List` so that it can be added to the main `Photo`
    list given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Loading our plugins in Sunago
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With that, our new integration is done. To see it in action, we add the dependency
    to Sunago''s POM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We then run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, adding a dependency for each new integration is not an ideal solution,
    if for no other reason than that the user won''t be running the application from
    an IDE or with Maven. What we need, then, is a way for the application to find
    any modules (or plugins, if you prefer that term) at runtime on the user''s machine.
    The simplest solution would be to launch the application via a shell script like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This preceding shell script creates a classpath using the main Sunago jar, plus
    any JARs found in `~/.sunago`, and then runs the application. This is simple and
    effective, but does require per-operating system versions. Fortunately, that just
    means this shell script for Mac and Linux, plus a batch file for Windows. That's
    not hard to do or difficult to maintain, but it does require that you have access
    to those operating systems to test and verify your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to make use of classloaders. As simple as it may seem to say
    it out loud, a `ClassLoader` is simply an object that is responsible for loading
    classes (and other resources). There are several classloaders at work in any given
    JVM, all arranged in a hierarchical fashion, starting with the bootstrap `ClassLoader`,
    then the platform `ClassLoader`, and, finally, the system--or application--`ClassLoader`.
    It is possible that a given application or runtime environment, such as a **Java
    Enterprise Edition** (**Java EE**) application server, might add one or more `ClassLoader`
    instances as children of the application `ClassLoader`. These added `ClassLoader`
    instances may themselves be hierarchical or they may be **siblings**. Either way,
    they are almost certainly children of the application `ClassLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full treatment of classloaders and all that they entail is well beyond the
    scope of this book, but suffice it to say that we can create a new `ClassLoader`
    to allow the application to find the classes and resources in our **plugin** jars.
    To do this, we need to add a few methods--three to be exact--to our application
    class, Sunago. We''ll start with the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically (though not always), when a JavaFX application starts, the `public
    static void main` method is run, which calls the `launch()` static method on the
    `Application` class, which we subclass. According to the Javadoc for `javafx.application.Application`,
    the JavaFX runtime performs the following steps when starting an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructs an instance of the specified `Application` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls the `init()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls the `start(javafx.stage.Stage)` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Waits for the application to finish, which happens when any of the following
    occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application calls `Platform.exit()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The last window has been closed, and the `implicitExit` attribute on platform
    is true.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls the `stop()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to perform our `ClassLoader` work at step 1, in the constructor of
    our `Application`, to make sure that everything that follows has an up-to-date
    `ClassLoader`. That work is done in the second method that we need to add, which
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We start by getting a list of the jar files (we'll see that code in a moment),
    then, if the array is non-null, we need to build an array of `URL`s, so, we iterate
    over the `File` array, and call `.toURI().toURL()` to do so. Once we have our
    `URL` array we create a new `ClassLoader` (`URLClassLoader.newInstance(urls)`),
    then set the `ClassLoader` for the current Thread via `Thread.currentThread().setContextClassLoader()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our final additional method `getFiles()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This last method simply scans the files in `$HOME/.sunago`, looking for a file
    that ends with `.jar`. A list of zero or more jar files is returned to our calling
    code for inclusion in the new `ClassLoader`, and our work is done.
  prefs: []
  type: TYPE_NORMAL
- en: So there you have two ways of adding plugin jars to the runtime dynamically.
    Each has its strengths and weaknesses. The first requires multi-platform development
    and maintenance, while the second is a bit riskier, as classloaders can be tricky.
    I have tested the second approach on Windows and Linux and Java 8 and 9 with no
    errors detected. Which approach you use will, of course, depend on your unique
    environment and requirements, but you have at least two options with which to
    start your evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of that said, our application is complete. Of course, hardly any software
    is truly complete, and there's much more that could be done to Sunago. Twitter
    support could be expanded to include direct messages. The Instagram module needs
    some configuration options added. While the capabilities exposed via the Facebook
    API are limiting, some sort of meaningful Facebook integration could be added.
    Sunago itself could be modified to, say, add support for in-application viewing
    of social media content (as opposed to shelling out to the host operating system's
    default browser). There are a handful of minor user experience bugs that could
    be addressed. And the list can go on and on. What we do have, though, is a moderately
    complex, networked application, that demonstrates a number of features and capabilities
    of the Java platform. We've built an extensible, internationalized JavaFX application
    that demonstrates the use of the Service Provider Interface and `ClassLoader`
    magic, and offers many more examples of lambdas, stream operations, and functional
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to build on the ideas presented here, and build
    an Android port of Sunago so that we can take our social media aggregation on-the-go
    with us.
  prefs: []
  type: TYPE_NORMAL
