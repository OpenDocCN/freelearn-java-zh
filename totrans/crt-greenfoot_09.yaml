- en: Chapter 9. Gamepads in Greenfoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Only you can control your future."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Dr. Seuss* |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, we will cover how to connect and use gamepad controllers in
    your Greenfoot scenarios. The set of controls you provide to your user really
    has an impact on their experience. Imagine playing our version of Avoider Game,
    which we created in the first two chapters of this book, if you had to hit *U*
    to move up, *D* to move down, *L* to move left, and *R* to move right. In the
    same way that a bad layout can frustrate a user, a good layout can feel very natural.
  prefs: []
  type: TYPE_NORMAL
- en: Gamepads are designed to heighten the experience of playing games. They provide
    a natural and expedient way for players to express their decisions to the game
    without detracting from game play. Early in gaming history, gamepads took the
    form of simple joysticks with a single button to fire with. Today, typical controllers
    have over 10 buttons, analog sticks, analog triggers, and a digital D-pad. Many
    controllers often allow the user to build custom macros as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect a gamepad to your Greenfoot scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listen and respond to various gamepad events using the Greenfoot GamePad API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect unsupported gamepads to OS X using controller-mapping software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding gamepad support to your scenarios is a great way to add to the playability
    of the games you create. It also adds a feel of professionalism to your work.
    After learning about connecting gamepads, we will augment Avoider Game, which
    we created in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…*, and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*,
    to allow the user to choose between controlling the game with a mouse or a gamepad.
  prefs: []
  type: TYPE_NORMAL
- en: Gamepad overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types of gamepads currently on the market for both PCs and Macs.
    Some resemble game controllers made for popular console gaming systems, such as
    Xbox, PlayStation, and Nintendo, while others have their own unique design and
    capabilities. *Figure 1* shows a typical gamepad. These gamepads are designed
    to put a lot of control options within easy reach.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1* identifies several common groupings of gamepad controls. A D-pad
    is a control often used to allow players to indicate direction (hence, the **D**
    in the name). It is fairly flat and designed for thumb use. The analog sticks
    serve as mini joysticks on the controller and allow fast and accurate positional
    control. For example, some games may use them to allow the player to look around
    a 3D world or aim a weapon. In a controller designed for an Xbox (and other popular
    consoles), the analog sticks can also be pushed down, providing two additional
    action buttons. The action buttons provide the user a way to specify an action
    in a game (see *Figure 1*). These buttons often control things such as jumping,
    shooting, ducking, and blocking. Last, we have auxiliary buttons that may be used
    to do things such as start a game, pause a game, reset a game, or simply provide
    more action buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gamepad overview](img/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: This is a typical layout for a gamepad controller'
  prefs: []
  type: TYPE_NORMAL
- en: For many games, a gamepad will provide the best interface (and user experience)
    for players. In this chapter, we will discuss connecting a controller like the
    one shown in *Figure 1* to your Greenfoot scenario. You will be able to assign
    the D-Pad, analog sticks, and action buttons to user-allowed abilities of your
    choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Windows setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are hundreds of gamepads you can choose from, to purchase for your PC
    or Mac. In this section, we will cover setting up an *Xbox 360 controller for
    Windows*. If you have purchased a different controller, make sure to install the
    associated drivers according to the instructions provided with your gamepad. If
    you have a Mac and a gamepad officially supported by OS X, then the instructions
    here should work for you as well. At the end of this chapter, we will look at
    ways you can still use poorly supported gamepads on your Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting Greenfoot, plug your Xbox 360 controller for Windows into your
    PC and allow Microsoft Update time to search for, download, and install the required
    drivers for the gamepad. This should take 5–15 minutes depending on your network
    connectivity. If you have any problems, try following the instructions given at
    [http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup](http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup).
  prefs: []
  type: TYPE_NORMAL
- en: Greenfoot gamepad software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the Greenfoot website, you can download a template to build Greenfoot scenarios
    with gamepad support. The template is basically a blank Greenfoot scenario that
    contains added libraries you can use to access and control gamepads. You can download
    the gamepad project template at [http://www.greenfoot.org/doc/gamepad](http://www.greenfoot.org/doc/gamepad).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you wish to create a scenario with gamepad support, you need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the `GamePadTemplate.zip` file downloaded from the previous URL, to a directory
    of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip `GamePadTemplate.zip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `GamePadTemplate` folder created in the previous step, to a name
    you want your new scenario to have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the scenario and add your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 2* shows what your new Greenfoot scenario will look like after completing
    the preceding steps. As you can see, you will subclass the `World` and `Actor`
    classes as you normally would to add content to your scenario. You are also provided
    with two additional classes, seen in the **Other classes** section, that you will
    use to connect to and manage gamepads.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Greenfoot gamepad software](img/image00331.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: This is a new Greenfoot scenario built from the gamepad template.
    The scenario pictured was renamed to "Fun"'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the `GamePad` and `Direction` classes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Greenfoot Gamepad API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Greenfoot Gamepad API supports all of the controls shown in *Figure 1* except
    that there are only two auxiliary buttons at the top (colored orange). First,
    we will discuss the API at a conceptual level and then look at the specific classes
    that implement the API.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In theory, receiving user input from a gamepad is a lot like receiving input
    from the keyboard. We are going to poll the buttons and analog sticks on the gamepad
    to see whether they are presently being pressed. The analog sticks are a bit more
    complicated as they have more states than being pressed or not. For them, you
    need to know both the direction they are being pushed in and the strength of the
    push.
  prefs: []
  type: TYPE_NORMAL
- en: With gamepads, you might have multiple gamepads connected to your computer,
    so the API also provides methods to access all of the gamepads and connect to
    only the ones you specify.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the gamepad template scenario, the Gamepad API is implemented in
    two classes. The first is the `GamePad` class and the second is the `Direction`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The static keyword**'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, you have a keyword that you can use to change how variables and methods
    are accessed and how memory is managed for them. This keyword is known as `static`.
    Adding this keyword to the declaration of a class variable or method ensures that
    this variable or method is stored only once regardless of the number of objects
    of the class created. So, for example, if you declared a variable named `counter`
    and assigned it an initial value of `1`, then all objects of the class would see
    the value of that variable as `1`. If one of the objects increments `counter`,
    then all objects created would now see the value of this variable as `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used on methods, the methods can be invoked without needing an instance
    of that class created. For example, many methods contained in the Greenfoot class
    are `static`, such as `getRandomNumber()` and `setWorld()`. Note that when we
    call these methods, we do not create an instance of the class. We just add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The GamePad and Direction classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GamePad` class is a special type of class known as *singleton*. For a singleton
    class, the constructor is declared as `private`; therefore, no code external to
    the class can create a new instance of the class. All other attempts to create
    a new object will fail with an error stating that the constructor has private
    access. It is a singleton class because you want to ensure that only one object
    represents a gamepad controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods you will commonly use from this class are `getGamePad()`, `isDown()`,
    `getAxis()`, and `runConfigurePad()`. The first thing you need to do to use a
    gamepad in your scenario is call `getGamePad()`. This method will return a `GamePad`
    object that represents the gamepad controller connected to your computer. Here
    is an example of its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the `GamePad` object for your controller, you can check whether
    the user is pressing an action button (shown in *Figure 1*) by calling `isDown()`.
    The `isDown()`method is used exactly like the `isKeyDown()` Greenfoot method we
    used to detect keyboard input. To detect keyboard input, we supply the name of
    the key we are interested in. For gamepads, you specify which button you are interested
    in using the `GamePad.Button` enumeration, which provides the following labels
    that correspond to gamepad buttons: `ACTION_DOWN`, `ACTION_LEFT`, `ACTION_RIGHT`,
    `ACTION_UP`, `L1`, `L2`, `L3`, `R1`, `R2`, `R3`, `SELECT`, and `START`. So, to
    determine whether the user was pressing the blue action button shown in *Figure
    1*, you would use the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting user input from the analog sticks is a two-step process. First, you
    get the direction information from the analog stick in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Axis` enumeration provides labels you can use to specify the D-pad, the
    left analog stick, or the right analog stick. The labels are `DPAD`, `LEFT`, and
    `RIGHT`, respectively. Secondly, once you have a `Direction` object, you can determine
    the angle at which the analog stick is being pushed and how far it is being pushed.
    Here are two lines of code that demonstrate how to extract this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last method you will often use is the `runConfigurePad()` method. This method
    will present a GUI interface the user can use to specify how the controls on their
    gamepad should map to the labels provided in the `GamePad.Button` enumeration
    and the `GamePad.Axis` enumeration. This is needed because not all gamepads have
    the same layout.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, refer to the official documentation of this class at [http://www.greenfoot.org/files/gamepad/GamePad.html](http://www.greenfoot.org/files/gamepad/GamePad.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Singleton classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are solutions to well-known or common problems. They provide
    a blueprint that programmers can easily follow. One of the most used design patterns
    in Java is the singleton pattern. You use this design pattern when you want to
    ensure that one and only one object of a class is instantiated. Why would this
    be useful? Well, imagine you wanted to manage and share a resource such as a printer
    or network connection within your application. It is much simpler and more efficient
    to only allow the creation of one object that represents that single resource.
    A class that follows the singleton design pattern enforces this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Avoider Game with Gamepad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We went over how to connect a gamepad to your Greenfoot scenario and how to
    use the Gamepad API. Now, it is time to code. We are going to add gamepad support
    to our version of Avoider Game, which we finished creating in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*. You can access a copy of that scenario at
    [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two main changes to make to Avoider Game. First, we need to add a reference
    to a `GamePad` object associated with our controller and pass that reference between
    all three worlds in that scenario: `AvoiderGameIntroScreen`, `AvoiderWorld`, and
    `AvoiderGameOverWorld`. Second, we need to change the `Avatar` class to be controlled
    by a gamepad, if present. Otherwise, we default to mouse control.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire `AvoiderWorld` class is not shown in the following code; only the
    methods that need changing are shown. Here are the changes for `AvoiderWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need an instance variable named `pad` to hold a reference to our
    gamepad. Change the constructor function to accept a reference to a `GamePad`
    object and then use that value to initialize our `pad` variable. This value will
    be passed to us from `AvoiderGameIntroScreen`. We will also need to pass the value
    of `pad` to `AvoiderGameOverWorld`, so we need to modify the `endgame()` method
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to change in `AvoiderWorld` is pass the `pad` instance
    variable to the single `Avatar` object we create in this game. Thus, we need to
    change one line of code in the `prepare()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`AvoiderGameIntroScreen` has the responsibility of detecting and configuring
    the gamepad. Here are the changes to make that happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we add an instance variable, `pad`, to the class and then initialize
    that variable using the `GamePad.getGamePad()` method of the Gamepad API. We have
    to surround the call to `GamePad.getGamePad()` in a try-catch block because the
    `getGamePad()` method will throw an exception if there is no gamepad plugged into
    the computer. The type of exception thrown is `IllegalArgumentException`, so that
    is what we have to catch. You will notice that we added another import statement
    at the top to define the `IllegalArgumentException` class. If we do not have a
    gamepad, then we set `pad` to `null`. We also call the `runConfigurePad()`method
    in the try block. This will bring up a dialogue box that will prompt the user
    as to whether they want to redefine the buttons for their controller. Last, we
    pass `pad` to `AvoiderWorld` in the `act()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exceptions**'
  prefs: []
  type: TYPE_NORMAL
- en: Java exceptions provide an organized and flexible way to handle runtime errors.
    They allow you to detangle your code from error detection code, making your code
    more readable and maintainable. The main keywords associated with exception handling
    in Java are `throw`, `try`, and `catch`. To learn more about Java exceptions,
    refer to [http://docs.oracle.com/javase/tutorial/essential/exceptions/](http://docs.oracle.com/javase/tutorial/essential/exceptions/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes needed to the `AvoiderGameOverScreen` class are simple. It only
    needs to pass the reference to the gamepad it got from the prior instance of `AvoiderWorld`
    and pass it back to a new instance of `AvoiderWorld` if the player clicks on the
    screen to play again. Here are the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The class that deals directly with receiving events from the gamepad is the
    `Avatar` class. We need to modify this class to use the gamepad to accept user
    input or default to the mouse if no gamepad is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes to the `Avatar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the `Avatar` class, we define a few additional variables
    that we will need to allow instances of the class to be controlled by a gamepad.
    We declare `pad` to hold a reference to the gamepad and some integers to specify
    how fast to move the `Avatar` object. We also declare the Boolean `useGamePad`
    variable that we will check later in class methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we initialize `pad` and set `useGamePad`. You will remember
    that we set `pad` to `null` in `AvoiderGameIntroScreen` if no gamepad was detected.
  prefs: []
  type: TYPE_NORMAL
- en: We have refactored the `userControls()` method. Both lag and stun delays work
    the same, but now we call a method to actually move the object. If `useGamePad`
    is `true` then we call `moveViaGamepad()`; otherwise, we call `moveViaMouse()`.
    The `moveViaMouse()`method contains the same logic we had previously to move the
    object. The `moveViaGamepad()`method is completely new and contains the logic
    to move the `Avatar` object by detecting input from the user's gamepad.
  prefs: []
  type: TYPE_NORMAL
- en: In `moveViaGamepad()`, we first set the speed to move. If we are lagging, we
    will go slower. The implementation of lagging for the gamepad is a little different
    than the implementation of lagging using the mouse. However, the effect in either
    case is to slow the user movement. Next, we check to see whether the user is presently
    pressing the D-pad by checking the strength of the push. If it equals 0, then
    we assume the user is using the left analog stick. We then detect the angle at
    which the user is pushing the D-pad (or analog stick) and translate that angle
    to the direction—up, down, left, or right.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have added all the code we need to use a gamepad controller with our version
    of Avoider Game. Compile all the changes you typed in previously, fix any errors
    you have, and play the game. I really feel that playing the game with a gamepad
    is more natural and satisfying.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we still have a lot of unused buttons on the gamepad. What
    could you add to the game to take advantage of those?
  prefs: []
  type: TYPE_NORMAL
- en: OS X setup/workarounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OS X does not directly support many gamepads. If you have a gamepad that is
    not directly supported, you can still use that gamepad to control your Greenfoot
    games.
  prefs: []
  type: TYPE_NORMAL
- en: Gamepad mapper software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several OS X applications available that will map a gamepad controller
    to keyboard keys and mouse actions. For example, you could map the D-Pad up, down,
    left, and right actions to the *W*, *S*, *A*, and *D* keys. Typically, these applications
    have better gamepad support than `JInput`, which is at the heart of gamepad support
    in Greenfoot and, therefore, will permit a wider variety of controllers to connect
    to your game. Another advantage is that you can program your scenarios without
    any thought to gamepad support. You assume standard keyboard and mouse controls,
    and the gamepad mapping software handles the rest. Here are some popular programs
    that do this mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Joystick Mapper: [http://joystickmapper.com](http://joystickmapper.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enjoy: [https://yukkurigames.com/enjoyable/](https://yukkurigames.com/enjoyable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ControllerMate for Mac: [http://www.macupdate.com/app/mac/17779/controllermate](http://www.macupdate.com/app/mac/17779/controllermate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting games with gamepads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one thing you need to keep in mind when you add gamepad support to
    your Greenfoot scenarios. If you have it, then your game will not be able to be
    played on the Greenfoot site. This is due to the fact that there is no Java support
    to connect to a gamepad via a web application. However, you will still be able
    to export your scenario as a desktop application if you follow the simple steps
    at [http://www.greenfoot.org/doc/gamepad_export](http://www.greenfoot.org/doc/gamepad_export).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Greenfoot Gamepad API is simple to set up and use and allows you to provide
    a well-designed control interface to your users. By giving your users the option
    to use mouse, keyboard, or gamepad controls, you allow them to interact with your
    Greenfoot creations in a way that is natural and comfortable to them. In previous
    chapters, you learned how to work with both the keyboard and mouse and, in this
    chapter, you learned how to use gamepads.
  prefs: []
  type: TYPE_NORMAL
