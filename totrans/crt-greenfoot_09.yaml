- en: Chapter 9. Gamepads in Greenfoot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Greenfoot中的游戏手柄
- en: '|   | *"Only you can control your future."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"只有你能掌控你的未来。" |   |'
- en: '|   | --*Dr. Seuss* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*苏斯博士* |'
- en: In this chapter, we will cover how to connect and use gamepad controllers in
    your Greenfoot scenarios. The set of controls you provide to your user really
    has an impact on their experience. Imagine playing our version of Avoider Game,
    which we created in the first two chapters of this book, if you had to hit *U*
    to move up, *D* to move down, *L* to move left, and *R* to move right. In the
    same way that a bad layout can frustrate a user, a good layout can feel very natural.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何在Greenfoot场景中连接和使用游戏手柄控制器。您提供给用户的控制方案对其体验有着真正的影响。想象一下，如果您必须按*U*向上移动，*D*向下移动，*L*向左移动，*R*向右移动，您将如何玩我们在这本书的前两章中创建的Avoider游戏版本。就像一个糟糕的布局会令用户沮丧一样，一个好的布局会感觉非常自然。
- en: Gamepads are designed to heighten the experience of playing games. They provide
    a natural and expedient way for players to express their decisions to the game
    without detracting from game play. Early in gaming history, gamepads took the
    form of simple joysticks with a single button to fire with. Today, typical controllers
    have over 10 buttons, analog sticks, analog triggers, and a digital D-pad. Many
    controllers often allow the user to build custom macros as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏手柄旨在提升游戏体验。它们为玩家提供了一种自然且便捷的方式，来表达他们的决策给游戏，而不会影响游戏本身。在游戏历史的早期，游戏手柄以简单的摇杆形式出现，只有一个按钮用于射击。如今，典型的控制器拥有超过10个按钮、模拟摇杆、模拟扳机和数字D-pad。许多控制器还允许用户构建自定义宏。
- en: 'In this chapter, you will learn how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Connect a gamepad to your Greenfoot scenario
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将游戏手柄连接到您的Greenfoot场景
- en: Listen and respond to various gamepad events using the Greenfoot GamePad API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Greenfoot GamePad API监听和响应各种游戏手柄事件
- en: Connect unsupported gamepads to OS X using controller-mapping software
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制器映射软件将不兼容的游戏手柄连接到OS X
- en: Adding gamepad support to your scenarios is a great way to add to the playability
    of the games you create. It also adds a feel of professionalism to your work.
    After learning about connecting gamepads, we will augment Avoider Game, which
    we created in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…*, and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*,
    to allow the user to choose between controlling the game with a mouse or a gamepad.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏手柄支持添加到您的场景中是增加您创建的游戏可玩性的好方法。它还为您的工作增添了一种专业性。在了解如何连接游戏手柄之后，我们将增强我们在[第1章](part0014.xhtml
    "第1章。让我们直接进入…")，“让我们直接进入…”，和[第2章](part0017.xhtml "第2章。动画")，“动画”中创建的Avoider游戏，使用户能够在使用鼠标或游戏手柄控制游戏之间进行选择。
- en: Gamepad overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏手柄概述
- en: There are many types of gamepads currently on the market for both PCs and Macs.
    Some resemble game controllers made for popular console gaming systems, such as
    Xbox, PlayStation, and Nintendo, while others have their own unique design and
    capabilities. *Figure 1* shows a typical gamepad. These gamepads are designed
    to put a lot of control options within easy reach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市场上针对PC和Mac都有许多种类的游戏手柄。有些类似于为流行的游戏机系统（如Xbox、PlayStation和Nintendo）制作的控制器，而有些则拥有自己独特的设计和能力。*图1*
    展示了一个典型的游戏手柄。这些游戏手柄的设计是为了将许多控制选项置于触手可及之处。
- en: '*Figure 1* identifies several common groupings of gamepad controls. A D-pad
    is a control often used to allow players to indicate direction (hence, the **D**
    in the name). It is fairly flat and designed for thumb use. The analog sticks
    serve as mini joysticks on the controller and allow fast and accurate positional
    control. For example, some games may use them to allow the player to look around
    a 3D world or aim a weapon. In a controller designed for an Xbox (and other popular
    consoles), the analog sticks can also be pushed down, providing two additional
    action buttons. The action buttons provide the user a way to specify an action
    in a game (see *Figure 1*). These buttons often control things such as jumping,
    shooting, ducking, and blocking. Last, we have auxiliary buttons that may be used
    to do things such as start a game, pause a game, reset a game, or simply provide
    more action buttons.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1* 识别了游戏手柄控制器的几个常见分组。D-pad 是一种常用于允许玩家指示方向的控件（因此，名字中的 **D**）。它相当平坦，专为拇指使用设计。模拟摇杆作为控制器上的小型摇杆，允许快速和精确的位置控制。例如，一些游戏可能使用它们允许玩家在
    3D 世界中环顾四周或瞄准武器。在为 Xbox（以及其他流行游戏机）设计的控制器中，模拟摇杆也可以按下，提供两个额外的动作按钮。动作按钮为用户提供了一种在游戏中指定动作的方法（见
    *图 1*）。这些按钮通常控制跳跃、射击、蹲下和阻挡等动作。最后，我们有辅助按钮，可能用于启动游戏、暂停游戏、重置游戏或简单地提供更多动作按钮。'
- en: '![Gamepad overview](img/image00330.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![游戏手柄概述](img/image00330.jpeg)'
- en: 'Figure 1: This is a typical layout for a gamepad controller'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：这是游戏手柄控制器的典型布局
- en: For many games, a gamepad will provide the best interface (and user experience)
    for players. In this chapter, we will discuss connecting a controller like the
    one shown in *Figure 1* to your Greenfoot scenario. You will be able to assign
    the D-Pad, analog sticks, and action buttons to user-allowed abilities of your
    choosing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多游戏来说，游戏手柄将为玩家提供最佳的用户界面（和用户体验）。在本章中，我们将讨论如何将如图 1 所示的控制器连接到您的 Greenfoot 场景。您将能够将
    D-Pad、模拟摇杆和动作按钮分配给您选择的用户允许的能力。
- en: Windows setup
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 设置
- en: There are hundreds of gamepads you can choose from, to purchase for your PC
    or Mac. In this section, we will cover setting up an *Xbox 360 controller for
    Windows*. If you have purchased a different controller, make sure to install the
    associated drivers according to the instructions provided with your gamepad. If
    you have a Mac and a gamepad officially supported by OS X, then the instructions
    here should work for you as well. At the end of this chapter, we will look at
    ways you can still use poorly supported gamepads on your Mac.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择数百种游戏手柄，用于购买您的 PC 或 Mac。在本节中，我们将介绍如何设置 Windows 的 *Xbox 360 控制器*。如果您购买了不同的控制器，请确保根据游戏手柄提供的说明安装相应的驱动程序。如果您有
    Mac 并且拥有官方支持 OS X 的游戏手柄，那么这里的说明也应该适用于您。在本章末尾，我们将探讨您如何在 Mac 上使用支持不佳的游戏手柄。
- en: Connecting your controller
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接您的控制器
- en: Before starting Greenfoot, plug your Xbox 360 controller for Windows into your
    PC and allow Microsoft Update time to search for, download, and install the required
    drivers for the gamepad. This should take 5–15 minutes depending on your network
    connectivity. If you have any problems, try following the instructions given at
    [http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup](http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 Greenfoot 之前，将您的 Windows Xbox 360 控制器连接到您的 PC，并允许微软更新搜索、下载和安装游戏手柄所需的驱动程序。这需要
    5-15 分钟，具体取决于您的网络连接速度。如果您有任何问题，请尝试遵循 [http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup](http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup)
    提供的说明。
- en: Greenfoot gamepad software
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Greenfoot 游戏手柄软件
- en: From the Greenfoot website, you can download a template to build Greenfoot scenarios
    with gamepad support. The template is basically a blank Greenfoot scenario that
    contains added libraries you can use to access and control gamepads. You can download
    the gamepad project template at [http://www.greenfoot.org/doc/gamepad](http://www.greenfoot.org/doc/gamepad).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Greenfoot 网站上，您可以下载一个模板来构建带有游戏手柄支持的 Greenfoot 场景。这个模板基本上是一个空白 Greenfoot 场景，其中包含了您可以用来访问和控制游戏手柄的附加库。您可以在
    [http://www.greenfoot.org/doc/gamepad](http://www.greenfoot.org/doc/gamepad) 下载游戏手柄项目模板。
- en: 'When you wish to create a scenario with gamepad support, you need to perform
    the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望创建一个带有游戏手柄支持的场景时，您需要执行以下步骤：
- en: Move the `GamePadTemplate.zip` file downloaded from the previous URL, to a directory
    of your choice.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从上一个URL下载的`GamePadTemplate.zip`文件移动到您选择的目录。
- en: Unzip `GamePadTemplate.zip`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压`GamePadTemplate.zip`。
- en: Rename the `GamePadTemplate` folder created in the previous step, to a name
    you want your new scenario to have.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前步骤中创建的`GamePadTemplate`文件夹重命名为您希望新场景拥有的名称。
- en: Open the scenario and add your changes.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开场景并添加您的更改。
- en: '*Figure 2* shows what your new Greenfoot scenario will look like after completing
    the preceding steps. As you can see, you will subclass the `World` and `Actor`
    classes as you normally would to add content to your scenario. You are also provided
    with two additional classes, seen in the **Other classes** section, that you will
    use to connect to and manage gamepads.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2*显示了完成前面的步骤后您的新Greenfoot场景将看起来是什么样子。正如您所看到的，您将像通常一样子类化`World`和`Actor`类以向场景添加内容。您还提供了两个额外的类，在**其他类**部分中可以看到，您将使用这些类来连接和管理游戏手柄。'
- en: '![Greenfoot gamepad software](img/image00331.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Greenfoot游戏手柄软件](img/image00331.jpeg)'
- en: 'Figure 2: This is a new Greenfoot scenario built from the gamepad template.
    The scenario pictured was renamed to "Fun"'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这是一个由游戏手柄模板构建的新Greenfoot场景。图中所示的场景被重命名为"Fun"
- en: We will discuss the `GamePad` and `Direction` classes in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论`GamePad`和`Direction`类。
- en: The Greenfoot Gamepad API
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Greenfoot游戏手柄API
- en: The Greenfoot Gamepad API supports all of the controls shown in *Figure 1* except
    that there are only two auxiliary buttons at the top (colored orange). First,
    we will discuss the API at a conceptual level and then look at the specific classes
    that implement the API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot游戏手柄API支持*图1*中显示的所有控制，除了顶部只有两个辅助按钮（橙色）。首先，我们将从概念层面讨论API，然后查看实现API的具体类。
- en: Overview
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In theory, receiving user input from a gamepad is a lot like receiving input
    from the keyboard. We are going to poll the buttons and analog sticks on the gamepad
    to see whether they are presently being pressed. The analog sticks are a bit more
    complicated as they have more states than being pressed or not. For them, you
    need to know both the direction they are being pushed in and the strength of the
    push.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，从游戏手柄接收用户输入与从键盘接收输入非常相似。我们将轮询游戏手柄上的按钮和模拟摇杆，以查看它们是否当前被按下。模拟摇杆稍微复杂一些，因为它们的状态不仅限于被按下或未被按下。对于它们，你需要知道它们被推的方向和推力的大小。
- en: With gamepads, you might have multiple gamepads connected to your computer,
    so the API also provides methods to access all of the gamepads and connect to
    only the ones you specify.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能有多个游戏手柄连接到您的计算机，因此API还提供了访问所有游戏手柄以及仅连接到您指定的游戏手柄的方法。
- en: As we saw in the gamepad template scenario, the Gamepad API is implemented in
    two classes. The first is the `GamePad` class and the second is the `Direction`
    class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在游戏手柄模板场景中看到的，游戏手柄API在两个类中实现。第一个是`GamePad`类，第二个是`Direction`类。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The static keyword**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态关键字**'
- en: In Java, you have a keyword that you can use to change how variables and methods
    are accessed and how memory is managed for them. This keyword is known as `static`.
    Adding this keyword to the declaration of a class variable or method ensures that
    this variable or method is stored only once regardless of the number of objects
    of the class created. So, for example, if you declared a variable named `counter`
    and assigned it an initial value of `1`, then all objects of the class would see
    the value of that variable as `1`. If one of the objects increments `counter`,
    then all objects created would now see the value of this variable as `2`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你可以使用一个关键字来改变变量和方法如何被访问以及如何管理它们的内存。这个关键字被称为`static`。将此关键字添加到类变量或方法的声明中，确保无论创建了该类的多少个对象，该变量或方法都只存储一次。例如，如果你声明了一个名为`counter`的变量并将其初始值设置为`1`，那么类的所有对象都会看到该变量的值为`1`。如果一个对象增加了`counter`，那么所有创建的对象现在都会看到该变量的值为`2`。
- en: 'When used on methods, the methods can be invoked without needing an instance
    of that class created. For example, many methods contained in the Greenfoot class
    are `static`, such as `getRandomNumber()` and `setWorld()`. Note that when we
    call these methods, we do not create an instance of the class. We just add the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于方法时，可以在不创建该类实例的情况下调用这些方法。例如，Greenfoot类中包含的许多方法都是`static`的，例如`getRandomNumber()`和`setWorld()`。请注意，当我们调用这些方法时，我们并没有创建类的实例。我们只需添加以下代码：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The GamePad and Direction classes
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏手柄和方向类
- en: The `GamePad` class is a special type of class known as *singleton*. For a singleton
    class, the constructor is declared as `private`; therefore, no code external to
    the class can create a new instance of the class. All other attempts to create
    a new object will fail with an error stating that the constructor has private
    access. It is a singleton class because you want to ensure that only one object
    represents a gamepad controller.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamePad` 类是一种称为 *单例* 的特殊类型的类。对于单例类，构造函数被声明为 `private`；因此，类外部的代码不能创建该类的新实例。所有其他尝试创建新对象的尝试都将失败，并显示一个错误信息，指出构造函数具有私有访问权限。这是一个单例类，因为你想要确保只有一个对象代表游戏手柄控制器。'
- en: 'The methods you will commonly use from this class are `getGamePad()`, `isDown()`,
    `getAxis()`, and `runConfigurePad()`. The first thing you need to do to use a
    gamepad in your scenario is call `getGamePad()`. This method will return a `GamePad`
    object that represents the gamepad controller connected to your computer. Here
    is an example of its use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从这个类中常用到的几个方法是 `getGamePad()`、`isDown()`、`getAxis()` 和 `runConfigurePad()`。要在你的场景中使用游戏手柄，你需要首先调用
    `getGamePad()` 方法。此方法将返回一个 `GamePad` 对象，它代表连接到你的计算机的游戏手柄控制器。以下是其使用示例：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you have the `GamePad` object for your controller, you can check whether
    the user is pressing an action button (shown in *Figure 1*) by calling `isDown()`.
    The `isDown()`method is used exactly like the `isKeyDown()` Greenfoot method we
    used to detect keyboard input. To detect keyboard input, we supply the name of
    the key we are interested in. For gamepads, you specify which button you are interested
    in using the `GamePad.Button` enumeration, which provides the following labels
    that correspond to gamepad buttons: `ACTION_DOWN`, `ACTION_LEFT`, `ACTION_RIGHT`,
    `ACTION_UP`, `L1`, `L2`, `L3`, `R1`, `R2`, `R3`, `SELECT`, and `START`. So, to
    determine whether the user was pressing the blue action button shown in *Figure
    1*, you would use the following lines of code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了控制器的 `GamePad` 对象，你可以通过调用 `isDown()` 方法来检查用户是否按下了动作按钮（如图 *1* 所示）。`isDown()`
    方法的使用方式与我们在检测键盘输入时使用的 `isKeyDown()` Greenfoot 方法完全相同。为了检测键盘输入，我们提供我们感兴趣的键的名称。对于游戏手柄，你使用
    `GamePad.Button` 枚举来指定你感兴趣的按钮，该枚举提供了以下与游戏手柄按钮对应的标签：`ACTION_DOWN`、`ACTION_LEFT`、`ACTION_RIGHT`、`ACTION_UP`、`L1`、`L2`、`L3`、`R1`、`R2`、`R3`、`SELECT`
    和 `START`。因此，为了确定用户是否按下了图 *1* 中显示的蓝色动作按钮，你会使用以下代码行：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Getting user input from the analog sticks is a two-step process. First, you
    get the direction information from the analog stick in the following way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从模拟摇杆获取用户输入是一个两步的过程。首先，你以以下方式从模拟摇杆获取方向信息：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Axis` enumeration provides labels you can use to specify the D-pad, the
    left analog stick, or the right analog stick. The labels are `DPAD`, `LEFT`, and
    `RIGHT`, respectively. Secondly, once you have a `Direction` object, you can determine
    the angle at which the analog stick is being pushed and how far it is being pushed.
    Here are two lines of code that demonstrate how to extract this information:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Axis` 枚举提供了你可以用来指定方向键、左模拟摇杆或右模拟摇杆的标签。标签分别是 `DPAD`、`LEFT` 和 `RIGHT`。其次，一旦你有了
    `Direction` 对象，你可以确定模拟摇杆被推的方向和推的程度。以下两行代码演示了如何提取这些信息：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last method you will often use is the `runConfigurePad()` method. This method
    will present a GUI interface the user can use to specify how the controls on their
    gamepad should map to the labels provided in the `GamePad.Button` enumeration
    and the `GamePad.Axis` enumeration. This is needed because not all gamepads have
    the same layout.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你将经常使用的最后一个方法是 `runConfigurePad()` 方法。此方法将提供一个用户界面，用户可以使用它来指定他们的游戏手柄上的控制如何映射到
    `GamePad.Button` 枚举和 `GamePad.Axis` 枚举中提供的标签。这是必需的，因为并非所有游戏手柄都有相同的布局。
- en: For more information, refer to the official documentation of this class at [http://www.greenfoot.org/files/gamepad/GamePad.html](http://www.greenfoot.org/files/gamepad/GamePad.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅此类的官方文档：[http://www.greenfoot.org/files/gamepad/GamePad.html](http://www.greenfoot.org/files/gamepad/GamePad.html)。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Singleton classes**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例类**'
- en: Design patterns are solutions to well-known or common problems. They provide
    a blueprint that programmers can easily follow. One of the most used design patterns
    in Java is the singleton pattern. You use this design pattern when you want to
    ensure that one and only one object of a class is instantiated. Why would this
    be useful? Well, imagine you wanted to manage and share a resource such as a printer
    or network connection within your application. It is much simpler and more efficient
    to only allow the creation of one object that represents that single resource.
    A class that follows the singleton design pattern enforces this behavior.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是针对已知或常见问题的解决方案。它们提供了一个程序员可以轻松遵循的蓝图。Java中最常用的设计模式之一是单例模式。当您想要确保一个类只有一个实例时，您会使用这个设计模式。这有什么用呢？好吧，想象一下，您想在应用程序中管理和共享资源，比如打印机或网络连接。只允许创建一个代表该单一资源的对象要简单得多，也高效得多。遵循单例设计模式的类强制执行此行为。
- en: Avoider Game with Gamepad
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用游戏手柄的避免者游戏
- en: We went over how to connect a gamepad to your Greenfoot scenario and how to
    use the Gamepad API. Now, it is time to code. We are going to add gamepad support
    to our version of Avoider Game, which we finished creating in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*. You can access a copy of that scenario at
    [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了如何将游戏手柄连接到Greenfoot场景以及如何使用Gamepad API。现在，是时候编写代码了。我们将为我们在[第2章](part0017.xhtml
    "第2章。动画")中创建的避免者游戏版本添加游戏手柄支持，该版本在*动画*中完成。您可以在[http://www.packtpub.com/support](http://www.packtpub.com/support)获取该场景的副本。
- en: 'We have two main changes to make to Avoider Game. First, we need to add a reference
    to a `GamePad` object associated with our controller and pass that reference between
    all three worlds in that scenario: `AvoiderGameIntroScreen`, `AvoiderWorld`, and
    `AvoiderGameOverWorld`. Second, we need to change the `Avatar` class to be controlled
    by a gamepad, if present. Otherwise, we default to mouse control.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对避免者游戏进行两项主要更改。首先，我们需要添加一个与我们的控制器关联的`GamePad`对象的引用，并在该场景中的三个世界之间传递该引用：`AvoiderGameIntroScreen`、`AvoiderWorld`和`AvoiderGameOverWorld`。其次，如果存在，我们需要将`Avatar`类更改为由游戏手柄控制；否则，我们默认使用鼠标控制。
- en: 'The entire `AvoiderWorld` class is not shown in the following code; only the
    methods that need changing are shown. Here are the changes for `AvoiderWorld`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中没有显示整个`AvoiderWorld`类；只显示了需要更改的方法。以下是`AvoiderWorld`的更改：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, we need an instance variable named `pad` to hold a reference to our
    gamepad. Change the constructor function to accept a reference to a `GamePad`
    object and then use that value to initialize our `pad` variable. This value will
    be passed to us from `AvoiderGameIntroScreen`. We will also need to pass the value
    of `pad` to `AvoiderGameOverWorld`, so we need to modify the `endgame()` method
    as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个名为`pad`的实例变量来保存对游戏手柄的引用。将构造函数更改为接受一个`GamePad`对象的引用，然后使用该值初始化我们的`pad`变量。此值将从`AvoiderGameIntroScreen`传递给我们。我们还需要将`pad`的值传递给`AvoiderGameOverWorld`，因此我们需要修改以下代码中的`endgame()`方法：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last thing we need to change in `AvoiderWorld` is pass the `pad` instance
    variable to the single `Avatar` object we create in this game. Thus, we need to
    change one line of code in the `prepare()` method, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AvoiderWorld`中需要更改的最后一件事是将`pad`实例变量传递到我们在游戏中创建的单个`Avatar`对象。因此，我们需要在`prepare()`方法中更改一行代码，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`AvoiderGameIntroScreen` has the responsibility of detecting and configuring
    the gamepad. Here are the changes to make that happen:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`AvoiderGameIntroScreen`负责检测和配置游戏手柄。以下是实现此功能的更改：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we add an instance variable, `pad`, to the class and then initialize
    that variable using the `GamePad.getGamePad()` method of the Gamepad API. We have
    to surround the call to `GamePad.getGamePad()` in a try-catch block because the
    `getGamePad()` method will throw an exception if there is no gamepad plugged into
    the computer. The type of exception thrown is `IllegalArgumentException`, so that
    is what we have to catch. You will notice that we added another import statement
    at the top to define the `IllegalArgumentException` class. If we do not have a
    gamepad, then we set `pad` to `null`. We also call the `runConfigurePad()`method
    in the try block. This will bring up a dialogue box that will prompt the user
    as to whether they want to redefine the buttons for their controller. Last, we
    pass `pad` to `AvoiderWorld` in the `act()` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在类中添加一个实例变量`pad`，然后使用游戏手柄API的`GamePad.getGamePad()`方法初始化该变量。我们必须在`GamePad.getGamePad()`调用周围使用try-catch块，因为如果没有将游戏手柄插入到计算机中，`getGamePad()`方法将抛出异常。抛出的异常类型是`IllegalArgumentException`，因此我们必须捕获它。您会注意到我们在顶部添加了另一个导入语句来定义`IllegalArgumentException`类。如果没有游戏手柄，我们将`pad`设置为`null`。我们还在try块中调用了`runConfigurePad()`方法。这将弹出一个对话框，提示用户是否想要重新定义控制器的按钮。最后，我们在`act()`方法中将`pad`传递给`AvoiderWorld`。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Exceptions**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常**'
- en: Java exceptions provide an organized and flexible way to handle runtime errors.
    They allow you to detangle your code from error detection code, making your code
    more readable and maintainable. The main keywords associated with exception handling
    in Java are `throw`, `try`, and `catch`. To learn more about Java exceptions,
    refer to [http://docs.oracle.com/javase/tutorial/essential/exceptions/](http://docs.oracle.com/javase/tutorial/essential/exceptions/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Java异常提供了一种有组织和灵活的方式来处理运行时错误。它们允许您将代码从错误检测代码中解耦，使代码更易于阅读和维护。与Java中的异常处理相关的主要关键字是`throw`、`try`和`catch`。要了解更多关于Java异常的信息，请参阅[http://docs.oracle.com/javase/tutorial/essential/exceptions/](http://docs.oracle.com/javase/tutorial/essential/exceptions/).
- en: 'The changes needed to the `AvoiderGameOverScreen` class are simple. It only
    needs to pass the reference to the gamepad it got from the prior instance of `AvoiderWorld`
    and pass it back to a new instance of `AvoiderWorld` if the player clicks on the
    screen to play again. Here are the changes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对`AvoiderGameOverScreen`类所需的更改很简单。它只需要传递从先前的`AvoiderWorld`实例获得的游戏手柄引用，并在玩家点击屏幕再次玩游戏时将其传递给新的`AvoiderWorld`实例。以下是更改内容：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The class that deals directly with receiving events from the gamepad is the
    `Avatar` class. We need to modify this class to use the gamepad to accept user
    input or default to the mouse if no gamepad is present.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 直接处理从游戏手柄接收事件的类是`Avatar`类。我们需要修改这个类，以便使用游戏手柄来接受用户输入，如果没有游戏手柄，则默认使用鼠标。
- en: 'Here are the changes to the `Avatar` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Avatar`类的更改：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the beginning of the `Avatar` class, we define a few additional variables
    that we will need to allow instances of the class to be controlled by a gamepad.
    We declare `pad` to hold a reference to the gamepad and some integers to specify
    how fast to move the `Avatar` object. We also declare the Boolean `useGamePad`
    variable that we will check later in class methods.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Avatar`类的开头，我们定义了一些额外的变量，这些变量将允许类的实例通过游戏手柄进行控制。我们声明`pad`来保存游戏手柄的引用和一些整数来指定如何快速移动`Avatar`对象。我们还声明了将在类方法中稍后检查的布尔变量`useGamePad`。
- en: In the constructor, we initialize `pad` and set `useGamePad`. You will remember
    that we set `pad` to `null` in `AvoiderGameIntroScreen` if no gamepad was detected.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们初始化`pad`并设置`useGamePad`。您会记得，如果没有检测到游戏手柄，我们在`AvoiderGameIntroScreen`中将`pad`设置为`null`。
- en: We have refactored the `userControls()` method. Both lag and stun delays work
    the same, but now we call a method to actually move the object. If `useGamePad`
    is `true` then we call `moveViaGamepad()`; otherwise, we call `moveViaMouse()`.
    The `moveViaMouse()`method contains the same logic we had previously to move the
    object. The `moveViaGamepad()`method is completely new and contains the logic
    to move the `Avatar` object by detecting input from the user's gamepad.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构了`userControls()`方法。延迟和眩晕延迟的工作方式相同，但现在我们调用一个方法来实际移动对象。如果`useGamePad`为`true`，则调用`moveViaGamepad()`；否则，调用`moveViaMouse()`。`moveViaMouse()`方法包含我们之前用来移动对象的相同逻辑。`moveViaGamepad()`方法完全是新的，并包含通过检测用户游戏手柄的输入来移动`Avatar`对象的逻辑。
- en: In `moveViaGamepad()`, we first set the speed to move. If we are lagging, we
    will go slower. The implementation of lagging for the gamepad is a little different
    than the implementation of lagging using the mouse. However, the effect in either
    case is to slow the user movement. Next, we check to see whether the user is presently
    pressing the D-pad by checking the strength of the push. If it equals 0, then
    we assume the user is using the left analog stick. We then detect the angle at
    which the user is pushing the D-pad (or analog stick) and translate that angle
    to the direction—up, down, left, or right.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`moveViaGamepad()`函数中，我们首先设置移动速度。如果我们有延迟，我们会走得更慢。游戏手柄的延迟实现与使用鼠标的延迟实现略有不同。然而，在两种情况下，效果都是减缓用户移动。接下来，我们检查用户是否正在按下D-pad，通过检查推力的强度。如果等于0，那么我们假设用户正在使用左侧模拟摇杆。然后我们检测用户推D-pad（或模拟摇杆）的角度，并将该角度转换为方向——上、下、左或右。
- en: Try it out
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: We have added all the code we need to use a gamepad controller with our version
    of Avoider Game. Compile all the changes you typed in previously, fix any errors
    you have, and play the game. I really feel that playing the game with a gamepad
    is more natural and satisfying.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了所有必要的代码，以便使用我们的Avoider Game版本与游戏手柄控制器。编译你之前输入的所有更改，修复任何错误，然后玩游戏。我真的觉得用游戏手柄玩游戏更自然、更令人满意。
- en: You will notice that we still have a lot of unused buttons on the gamepad. What
    could you add to the game to take advantage of those?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到游戏手柄上还有很多未使用的按钮。你能为游戏添加什么功能来利用这些按钮呢？
- en: OS X setup/workarounds
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OS X设置/解决方案
- en: OS X does not directly support many gamepads. If you have a gamepad that is
    not directly supported, you can still use that gamepad to control your Greenfoot
    games.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: OS X不直接支持许多游戏手柄。如果你的游戏手柄不支持，你仍然可以使用该游戏手柄来控制你的Greenfoot游戏。
- en: Gamepad mapper software
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏手柄映射软件
- en: 'There are several OS X applications available that will map a gamepad controller
    to keyboard keys and mouse actions. For example, you could map the D-Pad up, down,
    left, and right actions to the *W*, *S*, *A*, and *D* keys. Typically, these applications
    have better gamepad support than `JInput`, which is at the heart of gamepad support
    in Greenfoot and, therefore, will permit a wider variety of controllers to connect
    to your game. Another advantage is that you can program your scenarios without
    any thought to gamepad support. You assume standard keyboard and mouse controls,
    and the gamepad mapping software handles the rest. Here are some popular programs
    that do this mapping:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个OS X应用程序可以将游戏手柄控制器映射到键盘键和鼠标动作。例如，你可以将D-pad的上、下、左、右动作映射到*W*、*S*、*A*和*D*键。通常，这些应用程序比Greenfoot游戏手柄支持核心的`JInput`有更好的游戏手柄支持。因此，它将允许更广泛的控制器连接到你的游戏。另一个优点是，你可以无需考虑游戏手柄支持来编程你的场景。你假设标准键盘和鼠标控制，游戏手柄映射软件处理其余部分。以下是一些执行此映射的流行程序：
- en: 'Joystick Mapper: [http://joystickmapper.com](http://joystickmapper.com)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Joystick Mapper: [http://joystickmapper.com](http://joystickmapper.com)'
- en: 'Enjoy: [https://yukkurigames.com/enjoyable/](https://yukkurigames.com/enjoyable/)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Enjoy: [https://yukkurigames.com/enjoyable/](https://yukkurigames.com/enjoyable/)'
- en: 'ControllerMate for Mac: [http://www.macupdate.com/app/mac/17779/controllermate](http://www.macupdate.com/app/mac/17779/controllermate)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ControllerMate for Mac: [http://www.macupdate.com/app/mac/17779/controllermate](http://www.macupdate.com/app/mac/17779/controllermate)'
- en: Exporting games with gamepads
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用游戏手柄导出游戏
- en: There is one thing you need to keep in mind when you add gamepad support to
    your Greenfoot scenarios. If you have it, then your game will not be able to be
    played on the Greenfoot site. This is due to the fact that there is no Java support
    to connect to a gamepad via a web application. However, you will still be able
    to export your scenario as a desktop application if you follow the simple steps
    at [http://www.greenfoot.org/doc/gamepad_export](http://www.greenfoot.org/doc/gamepad_export).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将游戏手柄支持添加到你的Greenfoot场景时，你需要记住一件事。如果你有它，那么你的游戏将无法在Greenfoot网站上玩。这是因为没有Java支持通过Web应用程序连接到游戏手柄。然而，如果你遵循[http://www.greenfoot.org/doc/gamepad_export](http://www.greenfoot.org/doc/gamepad_export)中的简单步骤，你仍然可以将你的场景导出为桌面应用程序。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Greenfoot Gamepad API is simple to set up and use and allows you to provide
    a well-designed control interface to your users. By giving your users the option
    to use mouse, keyboard, or gamepad controls, you allow them to interact with your
    Greenfoot creations in a way that is natural and comfortable to them. In previous
    chapters, you learned how to work with both the keyboard and mouse and, in this
    chapter, you learned how to use gamepads.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot 游戏手柄 API 设置和使用简单，并允许您为用户提供一个精心设计的控制界面。通过为用户提供使用鼠标、键盘或游戏手柄控制的选择，您让他们能够以对他们来说自然和舒适的方式与您的
    Greenfoot 创作互动。在前几章中，您学习了如何使用键盘和鼠标，而在本章中，您学习了如何使用游戏手柄。
