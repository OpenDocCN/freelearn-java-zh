<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer088" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-103" lang="en-GB"><a id="_idTextAnchor102" class="pcalibre pcalibre2 pcalibre1 calibre6"/>7</h1>
<h1 id="_idParaDest-104" lang="en-GB" class="calibre5"><a id="_idTextAnchor103" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Avoiding Memory Leaks</h1>
<p lang="en-GB" class="calibre4">In the previous chapter, we examined how to configure and monitor memory management in the JVM. This involved knowledge of the metrics relevant to the tuning of the JVM. We discussed how to obtain these metrics and, consequently, how to tune the JVM. We also examined how to use profiling to obtain insights into the effects <span lang="">of tuning.</span></p>
<p lang="en-GB" class="calibre4">This chapter focuses on memory leaks. We will examine memory leaks under the <span lang="">following headings:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Understanding <span lang="">memory leaks</span></li>
<li lang="en-GB" class="calibre11">Spotting <span lang="">memory leaks</span></li>
<li lang="en-GB" class="calibre11">Avoiding <span lang="">memory leaks</span></li>
</ul>
<p lang="en-GB" class="calibre4">Let us start with understanding memory leaks. After that, we will learn how to spot them in our code and see how to avoid and <span lang="">solve them.</span></p>
<h1 id="_idParaDest-105" lang="en-GB" class="calibre5"><a id="_idTextAnchor104" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Technical requirements</h1>
<p lang="en-GB" class="calibre4">The code for this chapter can be found on GitHub <span lang="">at </span><a href="https://github.com/PacktPublishing/B18762_Java-Memory-Management" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://github.com/PacktPublishing/B18762_Java-Memory-Management</span></a><span lang="">.</span></p>
<h1 id="_idParaDest-106" lang="en-GB" class="calibre5"><a id="_idTextAnchor105" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Understanding memory leaks</h1>
<p lang="en-GB" class="calibre4">A memory leak <a id="_idIndexMarker287" class="pcalibre pcalibre2 pcalibre1 calibre6"/>occurs when objects that are no longer needed are not freed up. This causes these objects to accumulate in memory. Given that memory is a finite resource, this can eventually <a id="_idIndexMarker288" class="pcalibre pcalibre2 pcalibre1 calibre6"/>result in your application slowing down or even crashing (with an <strong class="bold" lang="">out-of-memory</strong> (<span lang=""><strong class="bold" lang="">OOM</strong></span><span lang="">) error).</span></p>
<p lang="en-GB" class="calibre4">Having fast servers or hosting your application in the cloud does not abstract you from the effects of poor memory management (memory leaks). As stated earlier, memory is a finite resource and even fast servers can run out of memory. If deploying on the cloud, it is tempting to simply scale up to address the issue of memory leaks; however, this results in higher costs for deploying an instance that is larger than it needs to be. It can even lead to hefty cloud <span lang="">service bills.</span></p>
<p lang="en-GB" class="calibre4">How fast you run out of memory depends on where in your code the memory leak occurs. If this is a piece of code that seldom runs, it will take a long time for the memory to get full. However, if this is a piece of code that runs frequently, it might go a <span lang="">lot faster.</span></p>
<p lang="en-GB" class="calibre4">While the reasons for<a id="_idIndexMarker289" class="pcalibre pcalibre2 pcalibre1 calibre6"/> memory leaks may vary, one likely culprit is a bug in your code. This leads us to our next topic: spotting <span lang="">memory leaks.</span></p>
<h1 id="_idParaDest-107" lang="en-GB" class="calibre5"><a id="_idTextAnchor106" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Spotting memory leaks</h1>
<p lang="en-GB" class="calibre4">So, you may <a id="_idIndexMarker290" class="pcalibre pcalibre2 pcalibre1 calibre6"/>wonder what typically when your application starts to respond somewhat slower after running for some time. The system administrator might just restart the application now and then to free the unnecessarily accumulated memory. This need for a restart is a typical symptom of a <span lang="">memory leak.</span></p>
<p lang="en-GB" class="calibre4">As memory fills up due to a memory leak, applications will slow down and even crash. While an application slowing down is not necessarily due to a memory leak, this often is the case. When faced with code that you suspect contains a memory leak, the following metrics are very helpful in diagnosing <span lang="">the application:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Heap <span lang="">memory footprint</span></li>
<li lang="en-GB" class="calibre11">Garbage <span lang="">collection activity</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Heap dump</span></li>
</ul>
<p lang="en-GB" class="calibre4">In order to demonstrate how to monitor these metrics, we will need an application that contains a memory leak. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.1</em> shows such <span lang="">a program:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer080">
<img alt="Figure 7.1 – Program with a memory leak" src="image/Figure_7.1_B18762.jpg" class="calibre80"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Program with a memory leak</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.1</em>, we are <a id="_idIndexMarker291" class="pcalibre pcalibre2 pcalibre1 calibre6"/>in an infinite loop starting on <em class="italic" lang="">line 15</em>, creating <strong class="source-inline" lang="">Person</strong> objects and adding them to an <strong class="source-inline" lang="">ArrayList</strong> object. As each <strong class="source-inline" lang="">Person</strong> reference (<strong class="source-inline" lang="">p</strong>) is re-initialized, it is easy to think that each <strong class="source-inline" lang="">Person</strong> object that the reference previously referred to is now eligible for garbage collection. However, this is not the case, as those <strong class="source-inline" lang="">Person</strong> objects are being referred to from the <strong class="source-inline" lang="">ArrayList</strong> object and consequently cannot be reclaimed by the garbage collector. Therefore, while the infinite loop results in the program eventually running out of memory, the memory leak itself is because the garbage collector is unable to reclaim the <strong class="source-inline" lang="">Person</strong> objects. Let us examine how we can diagnose the running code to help us arrive at <span lang="">this conclusion.</span></p>
<p lang="en-GB" class="calibre4">We will run this program using the command line as we can easily specify that we want the heap dumped to a file if the heap runs out of memory. The current directory <span lang="">is this:</span></p>
<pre class="source-code" lang="en-GB">C:\Users\skennedy\eclipse-workspace\MemoryMgtBook\src\</pre>
<p lang="en-GB" class="calibre4">The following command in the command line (written over several lines for clarity) <span lang="">achieves this:</span></p>
<pre class="source-code" lang="en-GB">java</pre>
<pre class="source-code" lang="en-GB">-XX:+HeapDumpOnOutOfMemoryError</pre>
<pre class="source-code" lang="en-GB">-XX:HeapDumpPath=C:\Users\skennedy\eclipse-workspace\MemoryMgtBook\src\ch7</pre>
<pre class="source-code" lang="en-GB">ch7.OutOfMemoryExample</pre>
<p lang="en-GB" class="calibre4">The interesting parts here are the <strong class="source-inline" lang="">–XX</strong> options specified. In the first instance, we are turning on the <strong class="source-inline" lang="">HeapDumpOnOutOfMemoryError</strong> option. This means that if the heap runs out of memory, the JVM will dump the heap into a file. All we need to do now is specify the location and name of that file. This is what the second <strong class="source-inline" lang="">–XX</strong> option does, using the <span lang=""><strong class="source-inline" lang="">HeapDumpPath</strong></span><span lang=""> flag.</span></p>
<p lang="en-GB" class="calibre4">Now that we have <a id="_idIndexMarker292" class="pcalibre pcalibre2 pcalibre1 calibre6"/>started our memory leak-affected application, we will use the <strong class="bold" lang="">VisualVM</strong> application to monitor the metrics of interest. VisualVM is an application that used to come with your Java SDK, but now you’ll have to download it separately from <a href="https://visualvm.github.io/download.xhtml" class="pcalibre pcalibre2 pcalibre1 calibre6">https://visualvm.github.io/download.xhtml</a> (note that this is the active link at the time of writing). Let us start with our diagnosis using the heap <span lang="">memory footprint.</span></p>
<h2 id="_idParaDest-108" lang="en-GB" class="calibre7"><a id="_idTextAnchor107" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Heap memory footprint</h2>
<p lang="en-GB" class="calibre4">What we are looking for here is <a id="_idIndexMarker293" class="pcalibre pcalibre2 pcalibre1 calibre6"/>not the <a id="_idIndexMarker294" class="pcalibre pcalibre2 pcalibre1 calibre6"/>size of the heap itself, but the amount of heap <em class="italic" lang="">used</em>. We are also very interested in whether or not the garbage collector reclaims the used heap. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.2</em> shows the heap footprint for the application outlined in <span lang=""><em class="italic" lang="">Figure 7</em></span><span lang=""><em class="italic" lang="">.1</em></span><span lang="">:</span></p>
<p class="calibre4" lang="en-GB"> </p>
<div class="calibre2">
<div class="img---figure" id="_idContainer081">
<img alt="Figure 7.2 – Heap memory footprint" src="image/Figure_7.2_B18762.jpg" class="calibre81"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Heap memory footprint</p>
<p lang="en-GB" class="calibre4">As can be seen <a id="_idIndexMarker295" class="pcalibre pcalibre2 pcalibre1 calibre6"/>from the preceding screenshot, the used heap (the area between the <em class="italic" lang="">x</em> axis and the graph line) quickly occupies all the heap space available. The garbage collector does manage to reclaim some memory (the dip on the left), but this is not memory allocated by our <a id="_idIndexMarker296" class="pcalibre pcalibre2 pcalibre1 calibre6"/>application. The program runs out of memory and crashes due to an <strong class="source-inline" lang="">OutOfMemoryError</strong> error. This is why the used heap goes back <span lang="">to </span><span lang=""><strong class="source-inline" lang="">0</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Let us examine the garbage collector activity during <span lang="">this period.</span></p>
<h2 id="_idParaDest-109" lang="en-GB" class="calibre7"><a id="_idTextAnchor108" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Garbage collector activity</h2>
<p lang="en-GB" class="calibre4">In the previous <a id="_idIndexMarker297" class="pcalibre pcalibre2 pcalibre1 calibre6"/>section, we <a id="_idIndexMarker298" class="pcalibre pcalibre2 pcalibre1 calibre6"/>saw the effect an application containing a memory leak has on the heap footprint. It is interesting to examine the activity of the garbage collector during that period. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.3</em> <span lang="">reflects this:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer082">
<img alt="Figure 7.3 – Garbage collector activity" src="image/Figure_7.3_B18762.jpg" class="calibre82"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Garbage collector activity</p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.3</em> shows that the garbage collector is very busy during the run of the program. However, as per <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.2</em>, we know this had no effect on freeing up space (allocated by our application) on the heap. Thus, in spite of having a busy garbage collector, the heap remains full. This is a classic sign of a <span lang="">memory leak.</span></p>
<p lang="en-GB" class="calibre4">So now, we have validated that we have a memory leak in our program. The next step is to figure out what is causing the leak. In our case, it’s rather obvious, but to help us understand better, let’s investigate further. The next step would be to look at the heap dump created by the JVM when our <span lang="">program crashed.</span></p>
<h2 id="_idParaDest-110" lang="en-GB" class="calibre7"><a id="_idTextAnchor109" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Heap dump</h2>
<p lang="en-GB" class="calibre4">When we ran our <a id="_idIndexMarker299" class="pcalibre pcalibre2 pcalibre1 calibre6"/>application, we<a id="_idIndexMarker300" class="pcalibre pcalibre2 pcalibre1 calibre6"/> specified that we wanted to create a heap dump if the application ran out of memory. This will enable us to further debug why we ran out of memory in the first place. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.4</em> represents the heap dump <span lang="">summary generated:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer083">
<img alt="Figure 7.4 – Heap dump summary" src="image/Figure_7.4_B18762.jpg" class="calibre83"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Heap dump summary</p>
<p lang="en-GB" class="calibre4">Two values in <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.4</em> jump out straight away. The first is the number of <em class="italic" lang="">instances</em> (first arrow). At <em class="italic" lang="">205,591,192</em>, this is far too many. Now, we need to know what type of instance is causing the memory leak. The second red arrow highlights <strong class="source-inline" lang="">ch7.Person</strong> as the offending type, given that there are <em class="italic" lang="">205,544,625</em> instances of that <span lang="">type alone.</span></p>
<p lang="en-GB" class="calibre4">The heap dump also enables us to drill down further. In this case, we will do just that, as we want to see what is <em class="italic" lang="">preventing</em> the garbage collection of these <strong class="source-inline" lang="">Person</strong> objects. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.5</em> will help us <span lang="">discuss that:</span></p>
<p class="calibre4" lang="en-GB"> </p>
<div class="calibre2">
<div class="img---figure" id="_idContainer084">
<img alt="Figure 7.5 – Heap dump drilldown" src="image/Figure_7.5_B18762.jpg" class="calibre84"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Heap dump drilldown</p>
<p lang="en-GB" class="calibre4">In the<a id="_idIndexMarker301" class="pcalibre pcalibre2 pcalibre1 calibre6"/> preceding <a id="_idIndexMarker302" class="pcalibre pcalibre2 pcalibre1 calibre6"/>screenshot, we have drilled down from the summary level to the object level. As we know, there are a lot of <strong class="source-inline" lang="">Person</strong> objects. By drilling down into any one of the <strong class="source-inline" lang="">Person</strong> objects, we can see the type that is referring to it. As highlighted in one of the <strong class="source-inline" lang="">Person</strong> objects (in blue), we can see that it is an <span lang=""><strong class="source-inline" lang="">ArrayList</strong></span><span lang=""> object.</span></p>
<p lang="en-GB" class="calibre4">Now, we have a much clearer idea of what is happening. We are adding <strong class="source-inline" lang="">Person</strong> objects to an <strong class="source-inline" lang="">ArrayList</strong> object whose reference never goes out of scope. As a result, the garbage collector cannot remove<a id="_idIndexMarker303" class="pcalibre pcalibre2 pcalibre1 calibre6"/> any of these <strong class="source-inline" lang="">Person</strong> objects from the heap, and we end up with <a id="_idIndexMarker304" class="pcalibre pcalibre2 pcalibre1 calibre6"/>an <span lang=""><strong class="source-inline" lang="">OutOfMemoryError</strong></span><span lang=""> error.</span></p>
<p lang="en-GB" class="calibre4">To summarize, in this section, we diagnosed a program that contained a memory leak. Using the heap memory footprint and garbage collection activity, we confirmed the presence of a memory leak. We then analyzed the heap dump to ascertain the offending collection (<strong class="source-inline" lang="">ArrayList</strong>) and type (<strong class="source-inline" lang="">Person</strong>). The next section will deal with how to avoid memory leaks in the <span lang="">first place.</span></p>
<h1 id="_idParaDest-111" lang="en-GB" class="calibre5"><a id="_idTextAnchor110" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Avoiding memory leaks</h1>
<p lang="en-GB" class="calibre4">The best way of<a id="_idIndexMarker305" class="pcalibre pcalibre2 pcalibre1 calibre6"/> avoiding a memory leak is to write code that does not contain any leaks in the first place. In other words, objects that we no longer need should <em class="italic" lang="">not</em> have connections back to the stack, as that prevents the garbage collector from reclaiming them. Before we get into techniques that help you avoid leaks in your code, let us first fix the leak presented in <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.1</em>. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.6</em> presents the <span lang="">leak-free code:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer085">
<img alt="Figure 7.6 – Leak-free program" src="image/Figure_7.6_B18762.jpg" class="calibre85"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Leak-free program</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.6</em>, the infinite loop remains. However, <em class="italic" lang="">lines 19</em> to <em class="italic" lang="">23</em> are new. In this new section, we increment an <strong class="source-inline" lang="">i</strong> local variable every time we add a <strong class="source-inline" lang="">Person</strong> reference to the <strong class="source-inline" lang="">ArrayList</strong> object. Once we have done this 1,000 times, we re-initialize our <strong class="source-inline" lang="">list</strong> reference. This is <a id="_idIndexMarker306" class="pcalibre pcalibre2 pcalibre1 calibre6"/>crucial as it enables the garbage collector to reclaim the old <strong class="source-inline" lang="">ArrayList</strong> object and the 1,000 <strong class="source-inline" lang="">Person</strong> objects referred to from the <strong class="source-inline" lang="">ArrayList</strong> object. In addition, we reset <strong class="source-inline" lang="">i</strong> back to <strong class="source-inline" lang="">0</strong>. This will solve the leak. (Please send us an email if you find a use case for this specific example, and we’ll add it to the next edition of the book. It does, however, illustrate the example <span lang="">graphs well.)</span></p>
<p lang="en-GB" class="calibre4">We will now run the program using the same command-line arguments as before. The program does not generate an <strong class="source-inline" lang="">OutOfMemoryError</strong> error. We will now examine the code’s performance using VisualVM. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.6</em> reflects the heap memory footprint of the new memory <span lang="">leak-free code:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer086">
<img alt="Figure 7.7 – Heap memory footprint (leak-free code)" src="image/Figure_7.7_B18762.jpg" class="calibre86"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Heap memory footprint (leak-free code)</p>
<p lang="en-GB" class="calibre4">As we can see in <a id="_idIndexMarker307" class="pcalibre pcalibre2 pcalibre1 calibre6"/>the preceding screenshot, the used heap space (area between the <em class="italic" lang="">x</em> axis and the graph) goes up and down. The down areas reflect where the garbage collector reclaims memory. This pattern resembles the teeth of a saw and is a sign of a healthy program. Toward the end, we stopped running <span lang="">the program.</span></p>
<p lang="en-GB" class="calibre4">Next, we will look at the garbage collector activity during that time. <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.8</em> <span lang="">reflects this:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer087">
<img alt="Figure 7.8 – Garbage collector activity (leak-free code)" src="image/Figure_7.8_B18762.jpg" class="calibre87"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Garbage collector activity (leak-free code)</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.3</em> (the graph representing the code with the memory leak), the garbage collector was running at over 5%. Here, in <span lang=""><em class="italic" lang="">Figure 7</em></span><em class="italic" lang="">.8</em>, however, the garbage collector is barely noticeable at all and almost the<a id="_idIndexMarker308" class="pcalibre pcalibre2 pcalibre1 calibre6"/> same as the <em class="italic" lang="">x</em> axis. Again, a sign of a healthy program. As this program does not run out of heap space, there is no need for a <span lang="">heap dump.</span></p>
<h2 id="_idParaDest-112" lang="en-GB" class="calibre7"><a id="_idTextAnchor111" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Common pitfalls and how to avoid them</h2>
<p lang="en-GB" class="calibre4">Now that we have <a id="_idIndexMarker309" class="pcalibre pcalibre2 pcalibre1 calibre6"/>addressed the memory leak issue, we will review some common problems in code and how to avoid them. We will discuss techniques that will enable us to write leak-free code and code that uses memory in an optimal way without wasting resources that we actually did not need <span lang="">to use.</span></p>
<p lang="en-GB" class="calibre4">Some of the tips are a bit more obvious and don’t require a lot of examples, such as assigning a decent amount of heap space to your program if this is possible for the system, as well as not creating objects that you don’t need and reusing objects when you can. Some of them require a little more explanation, and we’ll elaborate on <span lang="">them next.</span></p>
<h3 lang="en-GB" class="calibre8">Unnecessary references on the stack and setting the reference to null</h3>
<p lang="en-GB" class="calibre4">It is possible that there are references on the stack that are actually no longer needed. In our preceding example, this was <span lang="">the case.</span></p>
<p lang="en-GB" class="calibre4">Re-initializing the reference (or setting it to <strong class="source-inline" lang="">null</strong>) is the approach used in this section to fix the memory leak. Both approaches break the link back to the stack, enabling the garbage collector to reclaim the heap memory. Be careful, though, that you only do this when your application is finished with the objects; otherwise, you’ll get <strong class="source-inline" lang="">NullPointerException</strong> exceptions. You can see the <span lang="">following example:</span></p>
<pre class="source-code" lang="en-GB">Person personObj = new Person();</pre>
<pre class="source-code" lang="en-GB">// use personObj</pre>
<pre class="source-code" lang="en-GB">personObj = null;</pre>
<p lang="en-GB" class="calibre4">In this example, we’re having an object reference stored in <strong class="source-inline" lang="">personObj</strong>; when we no longer need it, we set it to <strong class="source-inline" lang="">null</strong>. This way, the <strong class="source-inline" lang="">Person</strong> object on the heap becomes eligible for garbage collection after the line where we set it to <strong class="source-inline" lang="">null</strong> (assuming that we didn’t assign the reference to <span lang="">other variables).</span></p>
<p lang="en-GB" class="calibre4">Whether or not this <a id="_idIndexMarker310" class="pcalibre pcalibre2 pcalibre1 calibre6"/>approach is still relevant for today’s software is questionable; for most modern applications, this approach is less favorable, but of course, there could be sensible <span lang="">use cases.</span></p>
<h3 lang="en-GB" class="calibre8">Resource leaks and closing resources</h3>
<p lang="en-GB" class="calibre4">When you open resources such as files, databases, streams, and so on, they take up memory. If these resources are not closed, this could lead to resource leaks. In some scenarios, it could even lead to a serious depletion of the available resources and affect the performance of your application—for example, the buffers could get full. If you are producing output—for example, writing to a file or committing to a database—not closing the resource might actually lead to incorrect persistence or writing of the data, and the data might not reach its intended destination such as an output file or <span lang="">a database.</span></p>
<p lang="en-GB" class="calibre4">Closing resources (such as file and database connections) when finished is a method to prevent this from happening. Using the <strong class="source-inline" lang="">finally</strong> block or <strong class="source-inline" lang="">try-with-resources</strong> is of great help here. The <strong class="source-inline" lang="">finally</strong> block is always executed, regardless of whether or not an exception occurs. <strong class="source-inline" lang="">try-with-resources</strong> has an in-built <strong class="source-inline" lang="">finally</strong> block to close any resources opened in the <strong class="source-inline" lang="">try</strong> section. Using the <strong class="source-inline" lang="">finally</strong> block or <strong class="source-inline" lang="">try-with-resources</strong> ensures that the resources will <span lang="">be closed.</span></p>
<p lang="en-GB" class="calibre4">Consider the following code of a regular <span lang=""><strong class="source-inline" lang="">try</strong></span><span lang="">-</span><span lang=""><strong class="source-inline" lang="">catch</strong></span><span lang=""> block:</span></p>
<pre class="source-code" lang="en-GB">String path = "some path";</pre>
<pre class="source-code" lang="en-GB">FileReader fr = null;</pre>
<pre class="source-code" lang="en-GB">BufferedReader br = null;</pre>
<pre class="source-code" lang="en-GB">try {</pre>
<pre class="source-code" lang="en-GB">    fr = new FileReader(path);</pre>
<pre class="source-code" lang="en-GB">    br = new BufferedReader(fr);</pre>
<pre class="source-code" lang="en-GB">    System.out.println(br.readLine());</pre>
<pre class="source-code" lang="en-GB">} catch(IOException e) {</pre>
<pre class="source-code" lang="en-GB">    e.printStackTrace();</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">In this code snippet, we <a id="_idIndexMarker311" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are opening a <strong class="source-inline" lang="">FileReader</strong> and a <strong class="source-inline" lang="">BufferedReader</strong> class and dealing with the checked exceptions in the <strong class="source-inline" lang="">catch</strong> block. However, we never close them. This way, they don’t become eligible for garbage collection. Make sure to close them. This can be done in the <strong class="source-inline" lang="">finally</strong> block, <span lang="">like so:</span></p>
<pre class="source-code" lang="en-GB">String path = "some path";</pre>
<pre class="source-code" lang="en-GB">FileReader fr = null;</pre>
<pre class="source-code" lang="en-GB">BufferedReader br = null;</pre>
<pre class="source-code" lang="en-GB">try {</pre>
<pre class="source-code" lang="en-GB">    fr = new FileReader(path);</pre>
<pre class="source-code" lang="en-GB">    br = new BufferedReader(fr);</pre>
<pre class="source-code" lang="en-GB">    System.out.println(br.readLine());</pre>
<pre class="source-code" lang="en-GB">} catch(IOException e) {</pre>
<pre class="source-code" lang="en-GB">    e.printStackTrace();</pre>
<pre class="source-code" lang="en-GB">}</pre>
<pre class="source-code" lang="en-GB">finally {</pre>
<pre class="source-code" lang="en-GB">    if(br != null) {</pre>
<pre class="source-code" lang="en-GB">        br.close();</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">    if(fr != null) {</pre>
<pre class="source-code" lang="en-GB">        fr.close();</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">The <strong class="source-inline" lang="">finally</strong> block executes, whether an exception occurred or not. This way, we can be sure that the resources <span lang="">are closed.</span></p>
<p lang="en-GB" class="calibre4">Since Java 7, it is more <a id="_idIndexMarker312" class="pcalibre pcalibre2 pcalibre1 calibre6"/>common to use the <strong class="source-inline" lang="">try-with-resources</strong>. At the end of the <strong class="source-inline" lang="">try</strong> block, it is going to call the <strong class="source-inline" lang="">close()</strong> method on the objects initialized in the <strong class="source-inline" lang="">try</strong> statement (these objects must be implementing the <strong class="source-inline" lang="">AutoCloseable</strong> interface). This is what the previous example would <span lang="">look like:</span></p>
<pre class="source-code" lang="en-GB">String path = "some path";</pre>
<pre class="source-code" lang="en-GB">try (FileReader fr = new FileReader(path);</pre>
<pre class="source-code" lang="en-GB">    BufferedReader br = new BufferedReader(fr)) {</pre>
<pre class="source-code" lang="en-GB">                        System.out.println(br.readLine());</pre>
<pre class="source-code" lang="en-GB">} catch(IOException e) {</pre>
<pre class="source-code" lang="en-GB">    e.printStackTrace();</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">As you can see, this is much cleaner, and it prevents you from forgetting to close the resources. Therefore, using <strong class="source-inline" lang="">try-with-resources</strong> whenever possible <span lang="">is recommended.</span></p>
<h3 lang="en-GB" class="calibre8">Avoiding unnecessary String objects using StringBuilder</h3>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">String</strong> objects are immutable and therefore cannot be changed after creation. In the background, your requested changes result in a new <strong class="source-inline" lang="">String</strong> object being created (which reflects your changes) while the original <strong class="source-inline" lang="">String</strong> object <span lang="">remains untouched.</span></p>
<p lang="en-GB" class="calibre4">For example, when you concatenate one <strong class="source-inline" lang="">String</strong> object onto another <strong class="source-inline" lang="">String</strong> object, you actually end up with three different objects in memory: the original <strong class="source-inline" lang="">String</strong> object, the <strong class="source-inline" lang="">String</strong> object you want to concatenate, and the new, resultant <strong class="source-inline" lang="">String</strong> object reflecting the result of <span lang="">the concatenation.</span></p>
<p lang="en-GB" class="calibre4">Put the <strong class="source-inline" lang="">String</strong> concatenation code into a loop, and many unnecessary objects are created in the background. Consider the <span lang="">following example:</span></p>
<pre class="source-code" lang="en-GB">String strIntToChar = "";</pre>
<pre class="source-code" lang="en-GB">for(int i = 97; i &lt; 123; i++) {</pre>
<pre class="source-code" lang="en-GB">    strIntToChar += i + ": " + (char)i + "\n";</pre>
<pre class="source-code" lang="en-GB">}</pre>
<pre class="source-code" lang="en-GB">System.out.println(strIntToChar);</pre>
<p lang="en-GB" class="calibre4">This is what the <a id="_idIndexMarker313" class="pcalibre pcalibre2 pcalibre1 calibre6"/>outputted <strong class="source-inline" lang="">String</strong> object will look like after the loop. We’ve omitted the middle section to not make this snippet <span lang="">unnecessarily lengthy:</span></p>
<pre class="source-code" lang="en-GB">97: a</pre>
<pre class="source-code" lang="en-GB">98: b</pre>
<pre class="source-code" lang="en-GB">99: c</pre>
<pre class="source-code" lang="en-GB">... omitted middle ...</pre>
<pre class="source-code" lang="en-GB">120: x</pre>
<pre class="source-code" lang="en-GB">121: y</pre>
<pre class="source-code" lang="en-GB">122: z</pre>
<p lang="en-GB" class="calibre4">In this example, we are creating a lot of objects, and every intermediate <strong class="source-inline" lang="">concat</strong> step creates a new object. For example, after the first two iterations, the value of <strong class="source-inline" lang="">strIntToChar</strong> <span lang="">is this:</span></p>
<pre class="source-code" lang="en-GB">97: a</pre>
<pre class="source-code" lang="en-GB">98: b</pre>
<p lang="en-GB" class="calibre4">And after three iterations, it <span lang="">is this:</span></p>
<pre class="source-code" lang="en-GB">97: a</pre>
<pre class="source-code" lang="en-GB">98: b</pre>
<pre class="source-code" lang="en-GB">99: c</pre>
<p lang="en-GB" class="calibre4">All these intermediate values are stored in a <em class="italic" lang="">String pool</em>. This is because <strong class="source-inline" lang="">String</strong> objects are <em class="italic" lang="">immutable</em>, and the String pool is used as an optimization that is working against <span lang="">us here.</span></p>
<p lang="en-GB" class="calibre4">The solution to this problem would be to use <strong class="source-inline" lang="">StringBuilder</strong>. <strong class="source-inline" lang="">StringBuilder</strong> objects are mutable. If we rewrite the previous code using <strong class="source-inline" lang="">StringBuilder</strong>, a lot fewer objects are created, since we are not creating a separate <strong class="source-inline" lang="">String</strong> object for every intermediate value. This<a id="_idIndexMarker314" class="pcalibre pcalibre2 pcalibre1 calibre6"/> is what the code would look like with <span lang=""><strong class="source-inline" lang="">StringBuilder</strong></span><span lang=""> instead:</span></p>
<pre class="source-code" lang="en-GB">StringBuilder sbIntToChar  = new StringBuilder("");</pre>
<pre class="source-code" lang="en-GB">for(int i = 97; i &lt; 123; i++) {</pre>
<pre class="source-code" lang="en-GB">    sbIntToChar.append(i + ": " + (char)i + "\n");</pre>
<pre class="source-code" lang="en-GB">}</pre>
<pre class="source-code" lang="en-GB">System.out.println(sbIntToChar);</pre>
<p lang="en-GB" class="calibre4">When concatenating, there won’t be a new <strong class="source-inline" lang="">StringBuilder</strong> object created as the JVM manipulates the original <strong class="source-inline" lang="">StringBuilder</strong> object. As you can see, it doesn’t require drastic changes to the code, but it does improve memory management a lot. Thus, when concatenating a <strong class="source-inline" lang="">String</strong> object a lot, <span lang="">use </span><span lang=""><strong class="source-inline" lang="">StringBuilder</strong></span><span lang="">.</span></p>
<h3 lang="en-GB" class="calibre8">Managing memory usage by using primitives instead of wrapper classes</h3>
<p lang="en-GB" class="calibre4">Wrapper classes require a lot more memory than primitives. Sometimes, you must use wrapper classes—it is not optional. In other cases, using primitives instead of wrapper types is an option. So, for example, create a local variable of type <strong class="source-inline" lang="">int</strong> instead <span lang="">of </span><span lang=""><strong class="source-inline" lang="">Integer</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Primitive variables occupy a small amount of memory, and if the primitive is local to a method, it is stored on the stack (which is faster to access than the heap). Wrappers, on the other hand, are class types and always result in the creation of an object on the heap. In addition, if it’s possible, you should use the <strong class="source-inline" lang="">long</strong> and <strong class="source-inline" lang="">double</strong> primitives instead of <strong class="source-inline" lang="">BigInteger</strong> and <strong class="source-inline" lang="">BigDecimal</strong>. <strong class="source-inline" lang="">BigDecimal</strong>, in particular, is popular due to its precision in calculations. However, this precision comes at the price of requiring a lot more memory and slower calculations, so only use this class when you really need <span lang="">the precision.</span></p>
<p lang="en-GB" class="calibre4">Please note that this is not an actual memory leak that you’re preventing, but rather optimizing the usage of memory by not requiring more memory than you need to achieve the goals of <span lang="">your application.</span></p>
<h3 lang="en-GB" class="calibre8">The problem with static collections and why to avoid this</h3>
<p lang="en-GB" class="calibre4">In some situations, it <a id="_idIndexMarker315" class="pcalibre pcalibre2 pcalibre1 calibre6"/>can be tempting to use a static collection in a class to keep the objects in an application, especially when you are working with a Java SE-only environment and you’d like to store objects. This is something that is quite a danger to a healthy memory footprint. This is what such an example could <span lang="">look like:</span></p>
<pre class="source-code" lang="en-GB">public class AvoidingStaticCollections {</pre>
<pre class="source-code" lang="en-GB">    public static List&lt;Person&gt; personList = new</pre>
<pre class="source-code" lang="en-GB">        ArrayList&lt;&gt;();</pre>
<pre class="source-code" lang="en-GB">    public static void addPerson(Person p) {</pre>
<pre class="source-code" lang="en-GB">        personList.add(p);</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">    // other code omitted</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">This could get quickly out of hand. The objects created cannot be garbage-collected because the static collection keeps them alive. There are a few better ways to go about this. If this is something you really feel you need, chances are you might be able to use a <span lang="">database instead.</span></p>
<p lang="en-GB" class="calibre4">If you are using a <strong class="source-inline" lang="">HashMap</strong> class as a static collection, chances are you can use a <strong class="source-inline" lang="">WeakHashMap</strong> (Java 8 onward) instead. This will have weak references for the keys (so please note this; not the values—these are held by strong references). These key references are stored as weak references in the <strong class="source-inline" lang="">WeakHashMap</strong>, but this will not prevent the garbage collector from removing the object from the heap. The entries in the <strong class="source-inline" lang="">WeakHashMap</strong> will be removed if the key is no longer used by the rest of the application. This means that it should be all right to lose information that is not referenced anywhere else. So, if your intention is to maintain the information in a <strong class="source-inline" lang="">HashMap</strong>, you <em class="italic" lang="">should not</em> be using a <strong class="source-inline" lang="">WeakHashMap</strong> instead. However, if you don’t require the keys of your <strong class="source-inline" lang="">HashMap</strong> to be maintained on the heap if that’s the only reference, it’s possible<a id="_idIndexMarker316" class="pcalibre pcalibre2 pcalibre1 calibre6"/> that a <strong class="source-inline" lang="">WeakHashMap</strong> is an optimization for your heap usage. As always, research carefully whether this fits your requirements before <span lang="">implementing it.</span></p>
<h1 id="_idParaDest-113" lang="en-GB" class="calibre5"><a id="_idTextAnchor112" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Summary</h1>
<p lang="en-GB" class="calibre4">In this chapter, we learned how to avoid memory leaks in our code. The first step was to understand that memory leaks occur when objects, when no longer needed, maintain links to the stack. This prevents the garbage collector from reclaiming them. Given that memory is a finite resource, this is never desirable. As these objects accumulate, your application slows down and <span lang="">eventually crashes.</span></p>
<p lang="en-GB" class="calibre4">One common source of memory leaks is bugs in our code. However, there are ways to debug memory leaks. In order to demonstrate how to debug leaky code, we presented a program containing a memory leak. VisualVM is a tool that enables us to monitor the metrics of interest—the heap memory footprint, garbage collection activity, and the heap dump (when we run out of <span lang="">heap space).</span></p>
<p lang="en-GB" class="calibre4">The heap footprint validated the presence of a memory leak as it showed the <em class="italic" lang="">used</em> heap space totally occupying the available heap space. In other words, objects on the heap were not reclaimed. Meanwhile, the garbage collector was, in vain, extremely busy trying to free up heap space. To figure out which type was causing the issue, we examined the heap dump. This led us to an <strong class="source-inline" lang="">ArrayList</strong> object referring to a massive number of <span lang=""><strong class="source-inline" lang="">Person</strong></span><span lang=""> instances.</span></p>
<p lang="en-GB" class="calibre4">We addressed the leaky code and, using VisualVM again, checked the heap footprint and garbage collector activity metrics. Both metrics were <span lang="">much healthier.</span></p>
<p lang="en-GB" class="calibre4">However, the best way to avoid memory leaks is not to code them in the first place. This is similar to the <em class="italic" lang="">prevention is better than cure</em> principle. With this in mind, we discussed a few common techniques used to avoid memory leaks in the <span lang="">first place.</span></p>
<p lang="en-GB" class="calibre4">That concludes the chapter. In short, we started by covering why and how memory leaks occur. We then diagnosed and fixed the code containing a memory leak. We finished by discussing what to keep in mind to prevent writing leaky code and how to optimize memory usage in the <span lang="">first place.</span></p>
<p lang="en-GB" class="calibre4">This doesn’t just conclude the chapter but also the book. We started with an overview of the memory and zoomed in on the different aspects. After that, we dived into garbage collection. The last chapters of the book focused on how to improve performance: how to tune the JVM and how to avoid <span lang="">memory leaks.</span></p>
<p lang="en-GB" class="calibre4">If you’d like to know even more about how the JVM manages memory, the official documentation of the JVM is out there waiting for you. You can find the latest version <span lang="">here: </span><a href="https://docs.oracle.com/javase/specs/index.xhtml" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://docs.oracle.com/javase/specs/index.xhtml</span></a><span lang="">.</span></p>
</div>
<div class="calibre2">
<div id="_idContainer089" class="calibre2">
</div>
</div>
</div></body></html>