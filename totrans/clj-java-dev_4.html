<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Collections and Functional Programming" id="10DJ41-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Collections and Functional Programming</h1></div></div></div><p class="calibre7">We are now comfortable with using Java code from our Clojure programs, and we also know how to expose our Clojure programs with a Java API. However, we need to take a deeper look at Clojure and its true nature, which is functional programming.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Basics of functional programming</li><li class="listitem">Persistent collections</li><li class="listitem">Sequential and associative collections</li><li class="listitem">The sequence abstraction</li><li class="listitem">Collection types</li><li class="listitem">Applying functional programming to collections</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Collections and Functional Programming" id="10DJ41-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Basics of functional programming"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec28" class="calibre1"/>Basics of functional programming</h1></div></div></div><p class="calibre7">This is a<a id="id116" class="calibre1"/> topic that you can read about in lots of different places, and it seems that everyone has their own opinion of what functional programming is. There is however, some common ground that you will find in almost every definition, which relates to the benefits you gain from functional programming, such as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Easier code reuse</li><li class="listitem">Functions are easier to test</li><li class="listitem">Functions are easier to reason about</li></ul></div><p class="calibre7">In order to get these benefits, you need to take into account the following things:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You should think of functions as first class citizens</li><li class="listitem">Functions should minimize side effects (they shouldn't change any state)</li><li class="listitem">Functions should only depend on their parameters (this is called referential transparency)</li></ul></div><p class="calibre7">Lets take a <a id="id117" class="calibre1"/>look at two examples of functions (or methods) in Java to illustrate how, even in Java, you can get benefits from writing functions without side effects and context dependency.</p><div class="informalexample"><pre class="programlisting">public void payRent(BigDecimal amount) {
  User user = getCurrentUser();
  if(user.payAmount != amount) {
    System.out.println("Cannot pay");
  } else {
    user.money -= amount;
  }
}</pre></div><p class="calibre7">Imagine you had to test the preceding function; you might have a number of problems:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">You need to know how to get the current user; you might need to mock a database, or session storage. Or in the worst case scenario, you might need a real session storage service.</li><li class="listitem" value="2">How can you know if something was paid for or not?</li></ol><div class="calibre22"/></div><p class="calibre7">Now, look at this other example:</p><div class="informalexample"><pre class="programlisting">public boolean payRent(User user, BigDecimal amount, ValidateStrategy strategy) {
  if(strategy.validatePayment(user, amount)) {
    user.money -= amount;
    return true;
  } else {
    return false;
  }
}</pre></div><p class="calibre7">The preceding code is easier to test; you can create a user instance any way you want and with the <code class="email">ValidateStrategy</code> class (or interface) you could do whatever you need.</p><p class="calibre7">In the end, instead of a side-effect you get a return value stating if the action was possible or not. This way you don't need to mock and you can reuse it in different contexts.</p><p class="calibre7">Now that we have seen some common ground for functional programming, let's take a look at Clojure's value proposition for functional programming:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Functions are first class citizens or values. The same as with integers or strings, you can create them in runtime, pass them around, and receive them in other functions.</li><li class="listitem">The same way that functions are values, the data structures are also values; they can't be modified in the sense that they can be modified in Java but they are a fixed value, just as an integer is a fixed value.</li><li class="listitem">Immutable data structures are very important, they allow for safe and simple multithreaded code.</li><li class="listitem">Laziness (of data structures) allows deferring evaluation until needed, to execute just what you must.</li></ul></div></div></div>
<div class="book" title="Persistent collections" id="11C3M1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec29" class="calibre1"/>Persistent collections</h1></div></div></div><p class="calibre7">One of the<a id="id118" class="calibre1"/> most important features in Clojure is that collections are persistent. That does not mean that they are persistent to disk, it means that you can have several historical versions of a collection with the guarantee that updating or looking for something in any of those versions is going to have the same effort (complexity). You get all this with very little extra memory.</p><p class="calibre7">How? It is actually pretty simple. Clojure shares a common structure between several different data structures. If you add a single element to a data structure, Clojure shares the common part between the two structures and keeps track of the differences.</p><p class="calibre7">Let's see what we mean with an example:</p><div class="informalexample"><pre class="programlisting">(def sample-coll [:one :two :three])
(def second-sample-coll (conj sample-coll :four))
(def third-sample-coll (replace {:one 1} sample-coll))

sample-coll ;; [:one :two :three]
second-sample-coll ;; [:one :two :three :four]
third-sample-coll ;; [1 :two :three :four]</pre></div><p class="calibre7">As you can see, when you <code class="email">conj</code> a new item into a collection, or even when you replace some elements from it, you aren't changing the original collection, you are just generating a new version of it.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre7">In Clojure, you can use <code class="email">conj(conjoin)</code> as a verb. It means adding new elements into a collection in an efficient manner.</p></div><p class="calibre7">This new version doesn't modify the previous collections you had in any way.</p><p class="calibre7">This is a big difference from how common imperative languages work and at the first glance it might seem like a bad idea, but Clojure uses efficient algorithms that give us a couple of advantages, specifically:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Different versions of the same collection share common parts, allowing us to use little memory</li><li class="listitem">When some part of the collection is not visible it gets garbage collected</li></ul></div><p class="calibre7">What you get out of this is similar memory usage to what you would have with a mutable collection. Remember that there is a cost in space and time but it is negligible for most use cases.</p><p class="calibre7">Why would you <a id="id119" class="calibre1"/>want to have an immutable data collection? The main advantage is that it is simple to reason about them; passing them around to functions does not change them and when you are writing concurrent code, there is no chance that some other thread has modified your collection and you don't need to worry about explicitly handling locks.</p></div>
<div class="book" title="Types of collections in Clojure" id="12AK81-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Types of collections in Clojure</h1></div></div></div><p class="calibre7">There are<a id="id120" class="calibre1"/> three types of collections in Clojure: counted, sequential, and associative. They <a id="id121" class="calibre1"/>are not mutually exclusive, meaning one collection might be any.</p><p class="calibre7">Let's look at each type:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Counted collection</strong></span>: A counted<a id="id122" class="calibre1"/> collection is a collection which knows its size in constant time. It doesn't need to traverse its elements to get a count.</li><li class="listitem"><span class="strong"><strong class="calibre8">Sequential collection</strong></span>: A sequential <a id="id123" class="calibre1"/>collection can be traversed sequentially; it's the most common approach that you would use for a list. The easiest way to think about this is similar to Java's list, which you can traverse with a for-loop or an iterator. In Clojure vectors, lists and lazy sequences are sequential collections.</li><li class="listitem"><span class="strong"><strong class="calibre8">Associative collections</strong></span>: Associative <a id="id124" class="calibre1"/>collections can be accessed by keys; maps are the natural choice here. We said that one collection can be of any type; Clojure's vectors can also be used as associative collections, and each element index can be used as a key. You can think of it as a map where the keys are 0, 1, 2, 3, and so on.</li></ul></div><p class="calibre7">Clojure has some functions that tell us if a given collection is of each type, sequential or associative. As you can guess, vectors return true for both. The following are those functions:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Function name</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">List</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Vector</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Map</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Lazy sequence</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Set</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">counted?</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">false </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">sequential?</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">false</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">false </p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">associative?</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">false </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">true </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">false </p>
</td><td valign="top" class="calibre21">
<p class="calibre19">false </p>
</td></tr></tbody></table></div><div class="mediaobject"><img src="../images/00013.jpeg" alt="Types of collections in Clojure" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In the previous<a id="id125" class="calibre1"/> table and diagram, you can see that we take <span class="strong"><strong class="calibre8">Set</strong></span> into account and as you can see, it's neither sequential nor associative.</p><p class="calibre7">We should look at another property; whether a collection is counted or not. It means that a collection knows how many elements it has. Lists, vectors, maps, and sets are all counted; lazy sequences are not counted, since they are generated on the fly and they could even be infinite sequences.</p><p class="calibre7">We will learn more about all of these sequences in the later sections of this chapter.</p></div>
<div class="book" title="The sequence abstraction" id="1394Q1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>The sequence abstraction</h1></div></div></div><p class="calibre7">Clojure has <a id="id126" class="calibre1"/>some unique features that make it different from <a id="id127" class="calibre1"/>other Lisps; one of them is the sequence abstraction. You can think of it as an interface that collections comply with. Clojure has a standard API of functions that you can use with sequences. Here are some examples of those functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">distinct</code> function: This<a id="id128" class="calibre1"/> function returns a sequence that includes each element of the original sequence just once:<div class="informalexample"><pre class="programlisting">(def c [1 1 2 2 3 3 4 4 1 1])
(distinct c) ;; (1 2 3 4)</pre></div></li><li class="listitem">The <code class="email">take</code> function: This <a id="id129" class="calibre1"/>function takes a number of elements from the original sequence:<div class="informalexample"><pre class="programlisting">(take 5 c) ;; (1 1 2 2 3)</pre></div></li><li class="listitem">The <code class="email">map</code> function: This <a id="id130" class="calibre1"/>function applies a function to each element of a sequence and creates a new sequence with these elements:<div class="informalexample"><pre class="programlisting">(map #(+ % 1) c) ;; (2 2 3 3 4 4 5 5 2 2)</pre></div></li></ul></div><p class="calibre7">The interesting part here is that these functions receive and return sequences and you can compose them together. It can be seen in the following code:</p><div class="informalexample"><pre class="programlisting"> (-&gt;&gt; c
  (distinct)
  (take 5)
  (reverse)) ;; (4 3 2 1)

;; This is known as a threading macro, it applies distinct, then take 5 then reverse to the
;; collection c so this is the same as writing:
;; (reverse (take 5 (distinct c))) but much more readable</pre></div><p class="calibre7">These are just some functions that accept and return sequences, but there are a lot more that you can use out of the box. The only assumption is that your sequence argument can respond to three functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">first</code>: This function<a id="id131" class="calibre1"/> returns the first of a sequence</li><li class="listitem"><code class="email">rest</code>: This <a id="id132" class="calibre1"/>function returns another sequence, containing everything but the first element</li><li class="listitem"><code class="email">cons</code>: This <a id="id133" class="calibre1"/>function receives two parameters, an item and another <code class="email">seq</code> and returns a new <code class="email">seq</code> containing the item followed by all the items in the second parameter</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre7">One of the functions that you'll find yourself using more is the <code class="email">seq</code> function, it can convert any collection to a seq, even Java native arrays and objects that implement the <code class="email">java.util.Iterable</code> interface. One of its main uses is to test a collection for emptiness.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Specific collection types in Clojure"><div class="book" id="147LC2-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Specific collection types in Clojure</h1></div></div></div><p class="calibre7">Now<a id="id134" class="calibre1"/> that you know about Clojure's general collection<a id="id135" class="calibre1"/> properties and the sequence abstraction, it is a good time to get to know about Clojure's specific collection implementations.</p></div>

<div class="book" title="Specific collection types in Clojure">
<div class="book" title="Vectors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec31" class="calibre1"/>Vectors</h2></div></div></div><p class="calibre7">Vectors<a id="id136" class="calibre1"/> are Clojure's workhorse; together with map, it is the <a id="id137" class="calibre1"/>most used collection. Don't be afraid of them; they have nothing to do with Java's <code class="email">java.util.Vector</code>. They are just a series of ordered values, such as a list or an array.</p><p class="calibre7">They have the<a id="id138" class="calibre1"/> following properties:</p><div class="book"><ul class="itemizedlist"><li class="listitem">They are immutable</li><li class="listitem">They can be accessed sequentially</li><li class="listitem">They are associative (they are maps of their indices, meaning that their keys are 0, 1, 2, and so on)</li><li class="listitem">They are counted, meaning they have a finite size</li><li class="listitem">They have random access, so you can access any element with almost constant time (with the nth function)</li><li class="listitem">The <code class="email">conj</code> function appends a given element to them</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip12" class="calibre1"/>Tip</h3><p class="calibre7">The nth function allows us to get the nth element of any <code class="email">seq</code>, but you shouldn't use it without care. It has no problem handling vectors and it returns in constant time, but it takes linear time when used with a list, since it has to traverse all the collections looking for the element you asked. Try to use it just with vectors.</p></div><p class="calibre7">They have a literal syntax; you can define a vector with square brackets, as shown:</p><div class="informalexample"><pre class="programlisting">[42 4 2 3 4 4 5 5]</pre></div><p class="calibre7">Besides the literal syntax, there's another function that you can use to build a vector. The <code class="email">vec</code> function can build a vector out of any sequence passed to it:</p><div class="informalexample"><pre class="programlisting">(vec (range 4)) ;; [0 1 2 3]</pre></div><p class="calibre7">Another<a id="id139" class="calibre1"/> important benefit of vectors is that they are used for function arguments for declarations and for <code class="email">let</code> bindings.</p><p class="calibre7">Take a look at the following example:</p><div class="informalexample"><pre class="programlisting">(def f [some-param &amp; some-other-params] …)

(let [one 1 two (f p p-2 p-3)] …)</pre></div><p class="calibre7">As you can see, the parameters in the function are defined as a vector, same as the <code class="email">let</code> binding.</p><p class="calibre7">One of the main complaints about Lisps is that they use too many parentheses, Clojure's decision to use vectors instead in these structures is welcomed and makes the code much easier to read.</p><p class="calibre7">There are several ways to access a certain element of a vector:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Using the vector as a function</strong></span>: Vectors <a id="id140" class="calibre1"/>can be used as functions of their keys; we haven't discussed maps yet but you will see that this is because they are associative:<div class="informalexample"><pre class="programlisting">(def v [42 24 13 2 11 "a"])
(v 0) ;; 42
(v 99) ;; java.lang.IndexOutOfBoundsException</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre8">The nth function</strong></span>: The <code class="email">nth</code> function <a id="id141" class="calibre1"/>can receive an extra parameter for signaling when an index is not found and can be used, as shown:<div class="informalexample"><pre class="programlisting">(nth v 0) ;; 42
(nth v 99 :not-found) ;; :not-found
(nth v 99) ;; java.lang.IndexOutOfBoundsException</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre8">The get function</strong></span>: The <code class="email">get</code> function<a id="id142" class="calibre1"/> can receive an extra parameter for signaling when an index is not found, it is used as shown. An important thing to keep in mind is that unlike nth, <code class="email">get</code> cannot be used in sequences:<div class="informalexample"><pre class="programlisting">(get v 0) ;; 42
(get v 99 :not-found) ;; :not-found
(get v 99) ;; nil</pre></div></li></ul></div><p class="calibre7">You should use vectors almost always; in particular, if you want to do any of the following there is no other way to go:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You need random access to a collection (either modifying or accessing it)</li><li class="listitem">You need to add elements at the tail of the collection</li></ul></div></div></div>

<div class="book" title="Specific collection types in Clojure">
<div class="book" title="Lists"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec32" class="calibre1"/>Lists</h2></div></div></div><p class="calibre7">Lists <a id="id143" class="calibre1"/>are the most important collection type in other Lisps. In Clojure, they are used to represent code, but their functionality is almost limited to that.</p><p class="calibre7">Lists in<a id="id144" class="calibre1"/> Clojure are single linked lists; as you can imagine, this means that they are not good for random access (you need to iterate the list until you get to the wanted index). That said, you can still use lists as sequences with every function of the API.</p><p class="calibre7">Let's list their <a id="id145" class="calibre1"/>properties:</p><div class="book"><ul class="itemizedlist"><li class="listitem">They are immutable</li><li class="listitem">They can be accessed sequentially</li><li class="listitem">They are not associative</li><li class="listitem">They are counted, meaning they have a finite size</li><li class="listitem">They shouldn't be accessed in random order. If you want the 99th element, then Clojure will have to visit all the first 98 elements to get the 99th.</li><li class="listitem">The <code class="email">conj</code> function prepends a given element to it</li></ul></div><p class="calibre7">You can use destructuring with lists, as seen in the previous chapter. You shouldn't be afraid to use the first function (or even nth with a small index).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre7">Lists have their use cases and as you learn more you'll probably be comfortable using them in some places (such as macros), but as a rule of thumb, try to use vectors instead.</p></div></div></div>

<div class="book" title="Specific collection types in Clojure">
<div class="book" title="Maps"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec33" class="calibre1"/>Maps</h2></div></div></div><p class="calibre7">Maps<a id="id146" class="calibre1"/> are probably the most important collection type across all languages. They are also very important in Clojure.</p><p class="calibre7">Maps<a id="id147" class="calibre1"/> are collections of key value pairs, which mean that you can access or store an element by a key. We have been calling this type of collection an associative collection. Keys can be of any type of value in Clojure, even functions, lists, sets, vectors, or other maps.</p><div class="book" title="Sorted maps and hash maps"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec02" class="calibre1"/>Sorted maps and hash maps</h3></div></div></div><p class="calibre7">There are two types of maps in Clojure, each one of them with its own advantages.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Hash maps</strong></span>: They <a id="id148" class="calibre1"/>are the most <a id="id149" class="calibre1"/>used form of map in Clojure; the literal syntax of maps creates this type of maps. They have a nearly constant lookup time, which makes them extremely fast and usable in most scenarios. Their down-side is that you can't access them in an ordered fashion. You can create them, as shown:<div class="informalexample"><pre class="programlisting">{:one 1 :two 2}
(hash-map :one 1 :two 2)</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre8">Sorted maps</strong></span>: If <a id="id150" class="calibre1"/>you need to be <a id="id151" class="calibre1"/>able to access a map's key-value pairs in a certain order, then you have to use a sorted map. The downside of sorted maps is that the lookup time is <span class="strong"><em class="calibre9">not</em></span> constant, which means that they are a little slower to access by key. However, when you need to traverse a map in the order of the keys, then this is the only way to go. A strong constraint here is that the keys must be comparable between them. Sorted maps can be created, as shown:<div class="informalexample"><pre class="programlisting">(sorted-map :sample 5 :map :6) ;; {:sample 5, :map 6}
(sorted-map-by &gt; 1 :one 5 :five 3 :three) ;; {5 :five, 3 :three, 1 :one}</pre></div></li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre7">Comparable objects are the ones that implement the <code class="email">compareTo</code> interface.</p></div></div><div class="book" title="Common properties"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec03" class="calibre1"/>Common properties</h3></div></div></div><p class="calibre7">Associative objects, including<a id="id152" class="calibre1"/> maps have the following properties:</p><div class="book"><ul class="itemizedlist"><li class="listitem">They are functions of their keys:<div class="informalexample"><pre class="programlisting">(def m #{:one 1 :two 2 :three 3})
(m :one) ;; 1
(m 1) ;; nil</pre></div></li><li class="listitem">They can be used with associative destructuring:<div class="informalexample"><pre class="programlisting">(let [{:keys [a b c d]} #{:a 5}]
  [a b]) ;
; [:a nil]</pre></div></li><li class="listitem">They can be accessed with the <code class="email">get</code> function:<div class="informalexample"><pre class="programlisting">(get m :one) ;; 1
(get m 1) ;; nil
(get m 1 :not-found) ;; :not-found</pre></div></li></ul></div><p class="calibre7">You can convert a map to a <code class="email">seq</code> with the <code class="email">seq</code> function; you will get a sequence where each element is a vector representing a key-value pair in the map:</p><div class="informalexample"><pre class="programlisting">(seq {:one 1 42 :forty-two :6 6}) ;; ([:one 1] [:6 6] [42 :forty-two])
(doseq [[k v] (seq {:one 1 42 :forty-two :6 6})]
  (println k v))
;; :one 1
;; :6 6
;; 42 :forty-two</pre></div><p class="calibre7">
<code class="email">Doseq</code> is similar to Java's for-each loop. It executes the body for each element in a sequence.</p><p class="calibre7">It works as<a id="id153" class="calibre1"/> shown: <code class="email">(doseq [x sequence] ;;</code>. This works the same way as the let statement, you can use destructuring if needed:</p><div class="informalexample"><pre class="programlisting">    (body-that-uses x))</pre></div></div></div></div>

<div class="book" title="Specific collection types in Clojure">
<div class="book" title="Sets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec34" class="calibre1"/>Sets</h2></div></div></div><p class="calibre7">Clojure sets <a id="id154" class="calibre1"/>are a collection of unique elements. You<a id="id155" class="calibre1"/> can think of them as mathematical sets and as such, Clojure has operations, such as union intersection and difference.</p><p class="calibre7">Let's look at the properties of sets:</p><div class="book"><ul class="itemizedlist"><li class="listitem">They are immutable</li><li class="listitem">They are associative (their keys are their elements)</li><li class="listitem">They are counted, meaning they have a finite size</li><li class="listitem">Their elements are unique (contained at most once)</li></ul></div><div class="book" title="Sorted sets and hash sets"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec04" class="calibre1"/>Sorted sets and hash sets</h3></div></div></div><p class="calibre7">There are two kinds of sets: hash-sets and sorted-sets.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Hash-set</strong></span>: Besides <a id="id156" class="calibre1"/>the properties that we already saw, hash-sets are unordered. They are implemented using a hash map as a backing implementation.</li><li class="listitem"><span class="strong"><strong class="calibre8">Sorted-set</strong></span>: Besides <a id="id157" class="calibre1"/>the properties that we already saw, sorted-sets are sorted. They can be used as a parameter to all the functions that expect a sorted <code class="email">seq</code>. They can be accessed sequentially in sorted order:<div class="informalexample"><pre class="programlisting">(doseq [x (-&gt;&gt; (sorted-set :b :c :d)
                        (map name))]
    (println x))
;; b
;; c
;; d</pre></div></li></ul></div><p class="calibre7">You can also reverse them without problems, filter them, or map them similarly to a vector or list.</p></div><div class="book" title="Common properties"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec05" class="calibre1"/>Common properties</h3></div></div></div><p class="calibre7">Sets<a id="id158" class="calibre1"/> are associative, which gives them some properties of maps:</p><div class="book"><ul class="itemizedlist"><li class="listitem">They are functions of their elements:<div class="informalexample"><pre class="programlisting">(#{:a :b :c :d} :a);; :a
(#{:a :b :c :d} :e);; nil</pre></div></li><li class="listitem">They can be used with map destructuring:<div class="informalexample"><pre class="programlisting">(let [{:keys [b]} #{:b}] b);; :b
(let [{:keys [c]} #{:b}] b);; nil
(let [{:keys [c]} (sorted-set :b)] c);; nil
(let [{:keys [b]} (sorted-set :b)] b);; :b</pre></div></li><li class="listitem">The <code class="email">get</code> function can be used to access their elements:<div class="informalexample"><pre class="programlisting">(get #{:a :b :c :d} :e :not-found) ;; :not-found
(get #{:a :b :c :d} :a) ;; :a
(get #{:a :b :c :d} :e) ;; nil</pre></div></li></ul></div></div><div class="book" title="Union, difference, and intersection"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec06" class="calibre1"/>Union, difference, and intersection</h3></div></div></div><p class="calibre7">If you <a id="id159" class="calibre1"/>remember<a id="id160" class="calibre1"/> mathematical sets, you'll know that the three main operations you can execute on them are the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Union</strong></span> (<code class="email">union a b</code>): The union includes all of the elements both in <code class="email">a</code> and <code class="email">b</code></li><li class="listitem"><span class="strong"><strong class="calibre8">Difference</strong></span> (<code class="email">difference a b</code>): The difference is all the elements that are in <code class="email">a</code> except for the elements that are also in <code class="email">b</code></li><li class="listitem"><span class="strong"><strong class="calibre8">Intersection</strong></span> (<code class="email">intersection a b</code>): It<a id="id161" class="calibre1"/> includes only the elements that are both in <code class="email">a</code> and <code class="email">b</code></li></ul></div><p class="calibre7">Here are some examples:</p><div class="informalexample"><pre class="programlisting">(def a #{:a :b :c :d :e})
(def b #{:a :d :h :i :j :k})

(require '[clojure.set :as s])

(s/union a b) ;; #{:e :k :c :j :h :b :d :i :a}
(s/difference a b) ;; #{:e :c :b}
(s/intersection a b) ;; #{:d :a}</pre></div></div></div></div>

<div class="book" title="Specific collection types in Clojure">
<div class="book" title="Applying functional programming to collections"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec35" class="calibre1"/>Applying functional programming to collections</h2></div></div></div><p class="calibre7">Now that we <a id="id162" class="calibre1"/>have a better understanding of how collections work, we have a better foundation to understand functional programming and how to make the most out of it.</p><p class="calibre7">This<a id="id163" class="calibre1"/> requires a different way of thinking about how to solve problems and you should keep your mind open.</p><p class="calibre7">Something that you might have found really strange about all of the collections is this feature: <span class="strong"><em class="calibre9">They are immutable</em></span>.</p><p class="calibre7">This is indeed something quite strange; if you are used to Java, how can you possibly write programs without adding or removing elements from a list or set?</p><p class="calibre7">How is that even possible? In Java, we are used to writing <code class="email">for</code> and <code class="email">while</code> loops. We are used to mutating variables every step of the way.</p><p class="calibre7">How can we cope with immutable data structures? Let's find out in the subsequent sections.</p><div class="book" title="The imperative programming model"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec07" class="calibre1"/>The imperative programming model</h3></div></div></div><p class="calibre7">The <a id="id164" class="calibre1"/>software industry has been using a single software paradigm for a long time; this paradigm is an imperative programming model.</p><p class="calibre7">In the imperative paradigm, you have to tell the computer what to do at every single step. You are responsible for how the memory works, for whether it is running in a single core or multi core and, if you want to use multi core, you need to make sure that you change the program state correctly and avoid concurrency problems.</p><p class="calibre7">Let's see how you would calculate the factorial in an imperative style:</p><div class="informalexample"><pre class="programlisting">int factorial(int n) {
    int result = 1;
    for (int i = 1; i &lt;= n; i++) {
        result *= i;
    }
    return result;
}</pre></div><p class="calibre7">You are creating a variable result and a variable <code class="email">i</code>. You change the variable <code class="email">i</code> each time by assigning it the value <code class="email">i + 1</code>. You can change the result by multiplying by <code class="email">i</code>. The computer just executes your orders, comparing, adding, and multiplying. This is what we call the imperative programming model, because you need to tell the computer the exact commands it needs to execute.</p><p class="calibre7">This has worked fine in the past for various reasons, such as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The tight constraints of memory size forced programmers to make use of the memory as efficient as possible</li><li class="listitem">It was easier to think about a single thread of execution and how the computer executes it step-by-step</li></ul></div><p class="calibre7">Of course, there <a id="id165" class="calibre1"/>were some drawbacks. A code can get complicated easily and the world has changed; the constraints that existed many years ago are gone. In addition, most of today's computers have more than one CPU. Multi-threading with shared mutable states is burdensome.</p><p class="calibre7">This makes thinking about this complicated. We get in trouble even in single threaded programs; just think, what would be the outcome of the following code?</p><div class="informalexample"><pre class="programlisting">List l = new ArrayList();
doSomething(l);
System.out.println(l.size());</pre></div><p class="calibre7">Is it <code class="email">0</code>? You can't possibly know because the <code class="email">doSomething</code> method gets the list by reference and it can add or remove things without you knowing.</p><p class="calibre7">Now, imagine that you have a multithreaded program and a single <code class="email">List</code> that can be modified by any of the threads. In the Java world, you have to know about <code class="email">java.util.concurrent.CopyOnWriteArrayList</code> and you need to know about its implementation details to know when it's a good idea to use it and when not to use it.</p><p class="calibre7">Even with these structures, it is difficult to think about multithreaded code. You still need to think about semaphores, locks, synchronizers, and so on.</p><p class="calibre7">The imperative world might be easy for the easy case, but it is not simple. The whole industry has realized this and there are many new languages and technologies that take ideas from other places. Java 8 has the streaming API and it includes lambda blocks, which are essentially functions. All these ideas are taken from the functional world.</p></div><div class="book" title="The functional paradigm"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec08" class="calibre1"/>The functional paradigm</h3></div></div></div><p class="calibre7">There <a id="id166" class="calibre1"/>are other ways of thinking about how to solve a problem; in particular, the functional paradigm has become important lately. It is nothing new; Lisp has supported this kind of programming since it was conceived in 1958. It has probably not been strong until recently, as it requires a more abstract way of thinking.</p><p class="calibre7">For you to get a better idea, let's see a couple of examples of how functional programming looks similar to the following code:</p><div class="informalexample"><pre class="programlisting">(map str [1 2 3 4 5 6]) ;; ("1" "2" "3" "4" "5" "6")

(defn factorial [n]
  (reduce * (range 1 (inc n))))

(factorial 5) ;; 120</pre></div><p class="calibre7">As you <a id="id167" class="calibre1"/>can see, it looks quite different; in the first case, we are passing the <code class="email">str</code> function to another function called map.</p><p class="calibre7">In the second case, we are passing the <code class="email">*</code> function to another function called reduce. In both cases, we are using functions as you <a id="id168" class="calibre1"/>would pass a list or a number, they are <span class="strong"><strong class="calibre8">first level citizens</strong></span>.</p><p class="calibre7">One important difference in functional programming is that you don't need to tell the machine how to do things. In the first case, the map traverses the vector and applies the <code class="email">str</code> function to each element, converting it to a <code class="email">seq</code> of strings. You don't have to increment the index, you just need to tell the map what function you want to be applied to each element.</p><p class="calibre7">In the factorial case, there is a reduce function that receives the <code class="email">*</code> and a <code class="email">seq</code> from <code class="email">1</code> to <code class="email">n</code>.</p><p class="calibre7">It just works, you don't need to tell it how to do anything, just what you want done.</p><p class="calibre7">Both <code class="email">map</code> and <code class="email">reduce</code> are <a id="id169" class="calibre1"/>
<span class="strong"><strong class="calibre8">higher order functions</strong></span> because they accept functions such as parameters; they are also higher level abstractions.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre7">Higher order functions are functions that either accept a function as an argument, return a function as result, or both.</p></div><p class="calibre7">You need to think on another level of abstraction and you don't care how things are really done, just that it gets the work done.</p><p class="calibre7">This comes with some benefit, if the implementation of a map someday changes to become multithreaded, you would just need to update the versions and you would be ready to go!</p></div><div class="book" title="Functional programming and immutability"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec09" class="calibre1"/>Functional programming and immutability</h3></div></div></div><p class="calibre7">You may <a id="id170" class="calibre1"/>have also noticed that functional programming makes working with immutable structures necessary, because you can't mutate some or the other state in every step; you can just describe how you want to create a new collection based on some other collection and then get it. Clojure's efficient collections make it possible to share pieces of collections to keep memory usage at a minimum.</p><p class="calibre7">There are some other benefits to<a id="id171" class="calibre1"/> immutability:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You can share your data structures with anyone you want because you are certain that nobody can change your copy.</li><li class="listitem">Debugging is simpler because you can test the program with some immutable value instead of some mutating state. When you get a value, you can find out which function returned the value that you got; there are not multiple places where a collection was mutated for you to check.</li><li class="listitem">Concurrent programming is simpler; again being certain that nobody can change your copy, even in other concurrently running threads, makes reasoning about your program simpler.</li></ul></div></div><div class="book" title="Laziness"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec10" class="calibre1"/>Laziness</h3></div></div></div><p class="calibre7">Clojure also<a id="id172" class="calibre1"/> supports lazy evaluation of transformations of sequences. Let's take a look at the <code class="email">range</code> function:</p><div class="informalexample"><pre class="programlisting">(def r (range))</pre></div><p class="calibre7">When running this function without parameters, you are creating an infinite sequence starting from <code class="email">0</code>.</p><p class="calibre7">It is an infinite sequence; so why does the Clojure REPL return automatically?</p><p class="calibre7">Clojure doesn't compute a collection value until needed, so in order to get a value you would have to do something, such as this:</p><div class="informalexample"><pre class="programlisting">(take 1 r);; (0)
(take 5 r);; (0 1 2 3 4)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre7">If you try to print an infinite sequence at the REPL, it will freeze.</p></div><p class="calibre7">Here, Clojure is resolving first one element and then five of the collection <code class="email">r</code> because it needs to print them in the REPL.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre7">Lazy evaluation just works for collections and for sequence processing. Other operations (such as additions, method calls, and so on), are executed eagerly.</p></div><p class="calibre7">The interesting part is that you can define a new lazy collection by applying functions like filter and map to a certain collection.</p><p class="calibre7">For instance, let's get a new collection that contains all odd numbers:</p><div class="informalexample"><pre class="programlisting">(def odd-numbers (filter odd? r))
(take 1 odd-numbers)  ;; (1)
(take 2 odd-numbers)  ;; (1 3)
(take 3 odd-numbers)  ;; (1 3 5)</pre></div><p class="calibre7">Now, <code class="email">odd-numbers</code> is an <a id="id173" class="calibre1"/>infinite sequence of odd numbers and we have just asked for three of them. Whenever a number is already computed, it is not computed again. Let's change our collection a little bit in order to understand how this works:</p><div class="informalexample"><pre class="programlisting">(defn logging-odd? [number]
    (println number) ;; This is terrible, it is a side effect and a source for problems
                     ;; Clojure encourages you to avoid side effects, but it is pragmatic
                     ;; and relies on you knowing what you are doing
    (odd? number))

(def odd-numbers (filter logging-odd? r))

(take 1 odd-numbers)
;; 0
;; 1
;; 2
;; 3
;; 4
;; 5
;; 6
;; 7
;; 8
;; 9
;; 10
;; 11
;; 12
;; 13
;; 14
;; 15
;; 16
;; 17
;; 18
;; 19
;; 20
;; 21
;; 22
;; 23
;; 24
;; 25
;; 26
;; 27
;; 28
;; 29
;; 30
;; 31
;; =&gt; (1)

(take 1 odd-numbers)
;; =&gt; (1)

(take 2 odd-numbers)
;; =&gt; (1 3)

(take 3 odd-numbers)
;; =&gt; (1 3 5)

(take 4 odd-numbers)
;; =&gt; (1 3 5 7)

(take 10 odd-numbers)
;; =&gt; (1 3 5 7 9 11 13 15 17 19)</pre></div><p class="calibre7">As you can see, some<a id="id174" class="calibre1"/> numbers get calculated first; you shouldn't expect or rely on a particular number of elements to be precomputed at a certain time.</p><p class="calibre7">Also, keep in mind that the computation isn't executed again when we ask for the same number of elements, since it has been already cached.</p></div></div></div>
<div class="book" title="Summary" id="1565U1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">Collections and functional programming in Clojure are extremely powerful tools that allow us to use a completely different paradigm of programming.</p><p class="calibre7">Here's what we have learned so far:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The mechanics of immutable collections and what each collection type in Clojure is best for</li><li class="listitem">How sequence abstraction and how a lot of Clojure functions are available to work on collections, using this abstraction</li><li class="listitem">How functional programming enables us to write simpler programs that work better in parallel environments and help us save resources using laziness</li></ul></div><p class="calibre7">In the subsequent chapters, we will learn about other new Clojure features that give us a new and much more powerful way to implement polymorphism than what Java offers.</p></div></body></html>