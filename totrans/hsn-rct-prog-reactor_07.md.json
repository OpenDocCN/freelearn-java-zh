["```java\n    @Test\n    public  void testGrouping(){\n        Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                Long>of(0L, 1L), (state, sink) -> {\n            if (state.getT1() < 0)\n                sink.complete();\n            else\n                sink.next(state.getT1());\n            return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n        });\n        fibonacciGenerator.take(20)\n                .groupBy(i -> {\n                    List<Integer> divisors= Arrays.asList(2,3,5,7);\n                    Optional<Integer> divisor = divisors.stream().filter(d -> i % d == 0).findFirst();\n                    return divisor.map(x -> \"Divisible by \"+x).orElse(\"Others\");\n\n                })\n                 .concatMap(x -> {\n                     System.out.println(\"\\n\"+x.key());\n                     return x;\n                 })\n                .subscribe(x -> System.out.print(\" \"+x));\n    }\n```", "```java\n    @Test\n    public  void testBufferWithDefinateSize(){\n        Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                Long>of(0L, 1L), (state, sink) -> {\n            if (state.getT1() < 0)\n                sink.complete();\n            else\n                sink.next(state.getT1());\n            return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n        });\n        fibonacciGenerator.take(100)\n                .buffer(10)\n                .subscribe(x -> System.out.println(x));\n    }\n```", "```java\n    @Test\n    public  void testBufferSizes(){\n        Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                Long>of(0L, 1L), (state, sink) -> {\n            if (state.getT1() < 0)\n                sink.complete();\n            else\n                sink.next(state.getT1());\n            return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n        });\n        fibonacciGenerator.take(100)\n                .buffer(2,5)\n                .subscribe(x -> System.out.println(x));\n    }\n```", "```java\n    @Test\n    public  void testBufferTimePerid(){\n        Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                Long>of(0L, 1L), (state, sink) -> {\n            if (state.getT1() < 0)\n                sink.complete();\n            else\n                sink.next(state.getT1());\n            return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n        });\n        fibonacciGenerator\n                .buffer(Duration.ofNanos(10))\n                .subscribe(x -> System.out.println(x));\n    }\n```", "```java\n    @Test\n    public  void testBufferSupplier(){\n        Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                Long>of(0L, 1L), (state, sink) -> {\n            if (state.getT1() < 0)\n                sink.complete();\n            else\n                sink.next(state.getT1());\n            return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n        });\n        fibonacciGenerator.take(100)\n                .buffer(5,HashSet::new)\n                .subscribe(x -> System.out.println(x));\n    }\n```", "```java\n    @Test\n     public  void testWindowsFixedSize(){\n         Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                 Long>of(0L, 1L), (state, sink) -> {\n             if (state.getT1() < 0)\n                 sink.complete();\n             else\n                 sink.next(state.getT1());\n             return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n         });\n         fibonacciGenerator\n                 .window(10)\n                 .concatMap(x -> x)\n                 .subscribe(x -> System.out.print(x+\" \"));\n     }\n```", "```java\n   @Test\n    public  void testWindowsPredicate(){\n        Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                Long>of(0L, 1L), (state, sink) -> {\n            if (state.getT1() < 0)\n                sink.complete();\n            else\n                sink.next(state.getT1());\n            return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n        });\n        fibonacciGenerator\n                .windowWhile(x -> x < 500)\n                .concatMap(x -> x)\n                .subscribe(x -> System.out.println(x));\n    }\n```", "```java\n    @Test\n    public  void testSample() throws Exception{\n        Flux<Long> fibonacciGenerator = Flux.generate(() -> Tuples.<Long,\n                Long>of(0L, 1L), (state, sink) -> {\n            if (state.getT1() < 0)\n                sink.complete();\n            else\n                sink.next(state.getT1());\n            return Tuples.of(state.getT2(), state.getT1() + state.getT2());\n        });\n        CountDownLatch latch = new CountDownLatch(1);\n        fibonacciGenerator\n                .delayElements(Duration.ofMillis(100L))\n                .sample(Duration.ofSeconds(1))\n                .subscribe(x -> System.out.println(x), e -> latch.countDown() , () -> latch.countDown());\n        latch.await();\n    }\n```", "```java\n    @Test\n    public void testBackPressure() throws  Exception{\n        Flux<Integer> numberGenerator = Flux.create(x -> {\n            System.out.println(\"Requested Events :\"+x.requestedFromDownstream());\n            int number = 1;\n            while(number < 100) {\n                x.next(number);\n                number++;\n            }\n            x.complete();\n        });\n\n        CountDownLatch latch = new CountDownLatch(1);\n        numberGenerator.subscribe(new BaseSubscriber<Integer>() {\n            @Override\n            protected void hookOnSubscribe(Subscription subscription) {\n                request(1);\n            }\n\n            @Override\n            protected void hookOnNext(Integer value) {\n                System.out.println(value);\n            }\n\n            @Override\n            protected void hookOnError(Throwable throwable) {\n                throwable.printStackTrace();\n                latch.countDown();\n            }\n\n            @Override\n            protected void hookOnComplete() {\n                latch.countDown();\n            }\n        });\n        assertTrue(latch.await(1L, TimeUnit.SECONDS));\n    }\n```", "```java\n@Test\n    public  void testBackPressure() throws  Exception{\n        Flux<Integer> numberGenerator = Flux.create(x -> {\n            System.out.println(\"Requested Events :\"+x.requestedFromDownstream());\n            int number = 1;\n            while(number < 100) {\n                x.next(number);\n                number++;\n            }\n            x.complete();\n        }, OverflowStrategy.ERROR);\n\n      // Removed for Brevity\n    }\n```", "```java\nreactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue...)\n    at reactor.core.Exceptions.failWithOverflow(Exceptions.java:202)\n    at reactor.core.publisher.FluxCreate$ErrorAsyncSink.onOverflow(FluxCreate.java:632)\n    at reactor.core.publisher.FluxCreate$NoOverflowBaseAsyncSink.next(FluxCreate.java:603)\n    at reactor.core.publisher.FluxCreate$SerializedSink.next(FluxCreate.java:151)\n```", "```java\n@Test\n    public  void testBackPressureOps() throws  Exception{\n        Flux<Integer> numberGenerator = Flux.create(x -> {\n            System.out.println(\"Requested Events :\"+x.requestedFromDownstream());\n            int number = 1;\n            while(number < 100) {\n                x.next(number);\n                number++;\n            }\n            x.complete();\n        });\n\n        CountDownLatch latch = new CountDownLatch(1);\n        numberGenerator\n                .onBackpressureDrop(x -> System.out.println(\"Dropped :\"+x))\n                .subscribe(new BaseSubscriber<Integer>() {\n            // Removed for Brevity\n        });\n        assertTrue(latch.await(1L, TimeUnit.SECONDS));\n    }\n```", "```java\n    @Test\n    public  void testBackPressureOps() throws  Exception{\n        Flux<Integer> numberGenerator = Flux.create(x -> {\n            System.out.println(\"Requested Events :\"+x.requestedFromDownstream());\n            int number = 1;\n            while(number < 100) {\n                x.next(number);\n                number++;\n            }\n            x.complete();\n        });\n\n        CountDownLatch latch = new CountDownLatch(1);\n        numberGenerator\n                .onBackpressureBuffer(2,x -> System.out.println(\"Dropped :\"+x),BufferOverflowStrategy.DROP_LATEST)\n                .subscribe(new BaseSubscriber<Integer>() {\n        // Removed for brevity\n        });\n        assertTrue(latch.await(1L, TimeUnit.SECONDS));\n    }\n```"]