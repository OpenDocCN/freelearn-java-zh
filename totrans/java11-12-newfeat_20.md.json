["```java\nBiFunction<Integer, String, Boolean> calc = (age, _) -> age > 10;\n```", "```java\n// Approach 1\n// Pass null to the unused parameter\nBiFunction<Boolean, Integer, String> calc = (age, null) -> age > 10;\n\n// Approach 2\n// Pass empty string to the unused parameter\nBiFunction<Boolean, Integer, String> calc = (age, \"\") -> age > 10;\n\n// Approach 3\n// Pass ANY String value to the unused parameter -\n// - doesn't matter, since it is not used\nBiFunction<Boolean, Integer, String> calc = \n                       (age, \"Ban plastic straws\") -> age > 10;\n\n// Approach 4\n// Pass any variable (of the same type) to the unused parameter -\n// - doesn't matter, since it is not used\nBiFunction<Boolean, Integer, String> calc = (age, name) -> age > 10;\n```", "```java\nkey -> key.uppercase();           // single lambda parameter\n\n(int x, int y) -> x > y? x : y;   // two lambda parameters\n\n(a, b, c, d) -> a + b + c + d;    // four lambda parameters\n\n```", "```java\nList<String> talks = List.of(\"Kubernetes\", \"Docker\", \"Java 11\");\ntalks.stream()\n        .map(key -> key.toUpperCase())\n        .forEach(System.out::prinltn);\n```", "```java\n1\\. void process() {\n2\\.     List<String> talks = List.of(\"Kubernetes\", \"Docker\", \"Java 11\");\n3\\.     String key = \"Docker\"; // local variable key\n4\\.     talks.stream()\n5\\.         .map(key -> key.toUpperCase())       // WON'T compile: 'key' \n            redefined\n6\\.         .forEach(System.out::prinltn);\n7\\. }\n```", "```java\n1\\. String key = \"Docker\"; // local variable key\n2\\. talks.stream()\n3\\.     .map(key -> key.toUpperCase())         // WON'T compile : 'key' \n                                              // redefined\n4\\.     .forEach(System.out::println);\n```", "```java\n1\\. String key = \"Docker\"; // local variable key\n2\\. talks.stream()\n3\\.     .map(key -> key.concat(key))            \n4\\.     .forEach(System.out::prinltn);\n```", "```java\ninterface Swimmer {\n    boolean test(String lap);\n}\ninterface Diver {\n    String dive(int height);\n}\n```", "```java\nclass SwimmingMeet {\n    static void evaluate(Swimmer swimmer) {   // code compiles\n\n        System.out.println(\"evaluate swimmer\");\n    }\n    static void evaluate(Diver diver) {      // code compiles\n\n        System.out.println(\"evaluate diver\");\n    }\n}\n```", "```java\nclass FunctionalDisambiguation {\n    public static void main(String args[]) {\n        SwimmingMeet.evaluate(a -> false); // This code WON'T compile\n    }\n}\n```", "```java\na -> false                               // this is an implicit lambda\n```", "```java\nSwimmingMeet.evaluate((String a) -> false);         // This compiles!!\n```", "```java\ninterface Swimmer {                            // test METHOD IS \n                                               // MODIFIED\n    boolean test(int lap);      // String lap changed to int lap\n\n}\ninterface Diver {\n    String dive(int height);\n}\nclass SwimmingMeet {\n    static void evaluate(Swimmer swimmer) {          // code compiles\n\n        System.out.println(\"evaluate swimmer\");\n    }\n    static void evaluate(Diver diver) {               // code compiles\n        System.out.println(\"evaluate diver\");\n    }\n}\n```", "```java\n1\\. SwimmingMeet.evaluate(a -> false);\n2\\. SwimmingMeet.evaluate((int a) -> false);\n```", "```java\nclass Championship {\n    static boolean reward(Integer lapTime) {\n        return(lapTime < 60);\n    }\n    static boolean reward(String lap) {\n        return(lap.equalsIgnoreCase(\"final \");\n    }\n}\n```", "```java\nsomeMethod(Chamionship::reward);                     // ambiguous call\n```"]