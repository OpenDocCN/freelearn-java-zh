- en: The Read-Evaluate-Print Loop (REPL) Using JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating JShell and its commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating code snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming in JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and restoring the JShell command history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JShell Java API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REPL** stands for the **Read-Evaluate-Print Loop** and, as the name states,
    it reads the command entered on the command line, evaluates it, prints the result
    of evaluation, and continues this process on any command entered.'
  prefs: []
  type: TYPE_NORMAL
- en: All the major languages, such as Ruby, Scala, Python, JavaScript, and Groovy,
    among others, have REPL tools. Java was missing the much-needed REPL. If we had
    to try out some sample code, say using `SimpleDateFormat` to parse a string, we
    had to write a complete program with all the ceremonies, including creating a
    class, adding a main method, and then the single line of code we want to experiment.
    Then, we have to compile and run the code. These ceremonies make it harder to
    experiment and learn the features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: With a REPL, you can type only the line of code that you are interested in experimenting
    with and you would have immediate feedback on whether the expression is syntactically
    correct and gives the desired results. REPL is a very powerful tool, especially
    for people coming to the language for the first time. Suppose you want to show
    how to print *Hello World* in Java; for this, you'd have to start writing the
    class definition, then the `public static void main(String [] args)` method, and
    by the end of it, you would have explained or tried to explain a lot of concepts
    that would otherwise be difficult for a newbie to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: Anyways, with Java 9, Java developers can now stop cribbing about the absence
    of a REPL tool. A new REPL called JShell is being bundled with the JDK installation.
    So, we can now proudly write *Hello World* as our first *Hello World* code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the features of JShell and write code that
    will truly amaze us and appreciate the power of REPL. We will also see how we
    can create our own REPLs using the JShell Java API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at a few basic operations to help us get familiarize
    us with the JShell tool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have the latest JDK 9 version installed, which has JShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should have `%JAVA_HOME%/bin` (on Windows) or `$JAVA_HOME/bin` (on
    Linux) added to your `PATH` variable. If not, then please visit the recipe, *Installing
    JDK 9 on Windows and setting up the PATH variable* and *Installing JDK 9 on Linux
    (Ubuntu, x64) and configuring the PATH variable* in [Chapter 1](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml),
    *Installation and a Sneak Peek into Java 9*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your command prompt, type `jshell` and press enter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a message and then a `jshell>` prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cc3a1d23-a727-417e-a8b2-aefca185d2f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Forward slash(`/`)**,** followed by the JShell-supported commands, help you
    in interacting with JShell. Just like we try `/help intro` to get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd485fd1-e0a1-4960-a09f-ac1af706f7c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s print a `Hello World` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/273d1001-c971-4b6e-9633-5783bfc91063.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s print a customized `Hello World` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/debc42a8-b265-4d9b-b85d-ac668fe4c662.png)'
  prefs: []
  type: TYPE_IMG
- en: You can navigate through the executed commands using the up and down arrow keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code snippets entered at the `jshell` prompt are wrapped with just enough
    code to execute them. So, variable, method and class declarations get wrapped
    within a class and expressions get wrapped within a method which is in turn wrapped
    within the class. Other things such as imports and class definitions remain as
    is because they are top-level entities that is, wrapping a class definition within
    another class is not required as a class definition is a top level entity and
    can exist by itself. Similarly, in Java, import statements can occur by themselves
    and they occur outside of a class declaration and hence need not be wrapped inside
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent recipes, we will see how to define a method, import additional
    packages, define classes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipe, we saw `$1 ==> "Hello World"`. If we have some value
    without any variable associated with it, then `jshell` gives it a variable name,
    such as `$1`, `$2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating JShell and its commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to leverage a tool, we need to be familiar with how to use it, the
    commands it provides, and the various shortcut keys that we can use to be productive.
    In this recipe, we will look at the different ways we can navigate through JShell
    and also at the different keyboard shortcuts it provides to be productive while
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spawn the JShell by typing `jshell` in the command prompt, and you will be greeted
    with a welcome message containing the instructions to get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `/help intro` to get a brief introduction to JShell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4668e7b-a5d3-47e4-907e-638d7e06c3e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type `/help` to get a list of the supported commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f5e02b24-9f26-4c14-8e43-6c097e9042fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get more information about a command, type `/help <command>`. For example,
    to get information about `/edit`, type `/help /edit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/363a77a7-4b4b-4646-8e0d-aca0ba82888c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is autocompletion support in JShell. This makes Java developers feel
    at home. You can invoke autocompletion using the *Tab* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8b2030c3-d41d-4221-9754-f7bbcef3ca11.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use `/!` to execute a previously executed command and `/line_number`
    to re-execute an expression at the line number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To navigate the cursor through the command line, use *Ctrl* + *A* to reach the
    beginning of the line and *Ctrl* + *E* to reach the end of the line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluating code snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at executing the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: Import statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the command prompt and launch JShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, JShell imports a few libraries. We can check that by issuing the `/imports`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5bf0109e-27f8-464a-9f52-b1a3953dbaac.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's import `java.text.SimpleDateForm` by issuing the `import java.text.SimpleDateFormat`
    command. This imports the `SimpleDateFormat` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s declare an `Employee` class. We will issue one statement in each line
    so that it''s an incomplete statement, and we''ll proceed in the same way as we
    do in any ordinary editor. The following illustration will clarify this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5fbba3f1-7cff-4244-9d67-088ab47122fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s declare an `Employability` interface, which defines a method, `employable()`,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding interface when created via the `jshell` is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5b02234-5755-4dc9-bae9-0408b426d4e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s declare a `newEmployee(String empId)` method, which constructs an `Employee`
    object with the given `empId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method defined in JShell is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e480a9-dc9b-45c2-a229-baaf6286a1a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the method defined in the previous step to create a statement declaring
    an `Employee` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The above statement and its output when executed from within JShell are shown
    below. The snippet `e.get + Tab` key generates auto-completion as supported by
    the IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7fa1073-34f1-41bf-ab4a-82c1d59188f2.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can invoke an undefined method. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/556ab767-952d-4ac1-b43b-c25a036c583e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the method cannot be invoked before the method being used has been
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e4b66e3f-6e06-41da-8873-0dc2013be06b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can invoke `newMethod()` only after we have defined `undefinedMethod()`.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming in JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will make use of predefined Java class definition files and
    import them into JShell. Then, we will play around with those classes in the JShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class definition files we will use in this recipe are available at the location, `chp13/4_oo_programming`,
    in the code downloads for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three class definition files: `Engine.java`, `Dimensions.java`, and
    `Car.java`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory where these three class definition files are available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `/open` command allows loading the code from within a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will load the `Engine` class definition and create an `Engine` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a66a4725-1fd9-4d3f-87f7-5b2dd87c70cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will load the `Dimensions` class definition and create a `Dimensions`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/700d6bd9-7540-4dcf-a742-3fa3a211421d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we will load the `Car` class definition and create a `Car` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/472eb927-a529-4017-9a11-37a051b3d48a.png)'
  prefs: []
  type: TYPE_IMG
- en: Saving and restoring the JShell command history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will want to try out some code snippets in `jshell` as a means to explain
    Java programming to someone who is new to it. Moreover, some form of record of
    what code snippets were executed will be useful for the person who is learning
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will execute a few code snippets and save them into a file.
    We will then load the code snippets from the saved file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s execute a series of code snippets, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/eb5891bd-fa29-478e-afef-6d46e85fc22c.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the code snippets executed into a file called `history` using the `/save
    history` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the shell using `/exit` and list the files in the directory by using `dir`
    or `ls`, depending on the OS. There will be a `history` file in the listing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `jshell` and check for the history of code snippets executed using `/list`.
    You will see that there are no code snippets executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the `history` file using `/open history` and then check for the history
    of the code snippets executed using `/list`. You will see all the previous code
    snippets being executed and added to the history:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94763af0-658f-4657-8a2f-423ad1538e03.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the JShell Java API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 9 provides the Java API for creating tools such as `jshell` for evaluating
    Java code snippets. This Java API is present in the `jdk.jshell` module ([http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html](http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html)).
    So, if you want to use the API in your application, then you need to declare a
    dependency on the `jdk.jshell` module.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the JShell JDK API to evaluate simple code snippets,
    and you'll also see different APIs to get the state of JShell. The idea is not
    to recreate JShell but to show how to make use of its JDK API.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will not be using JShell; instead, we will follow the usual
    way of compiling using `javac` and running using `java`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our module will depend on the `jdk.jshell` module. So, the module definition
    will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an instance of the `jdk.jshell.JShell` class by using its `create()`
    method or the builder API in `jdk.jshell.JShell.Builder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s read the code snippet from `System.in` using `java.util.Scanner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `jdk.jshell.JShell#eval(String snippet)` method to evaluate
    the input. Evaluation will result in a list of `jdk.jshell.SnippetEvent`, which
    contains the status and output of evaluation. The TODO in the preceding code snippet
    will be replaced by the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After the evaluation is completed, we will print the snippets processed by using
    the `jdk.jshell.JShell.snippets()` method, which will return `Stream` of `Snippet`
    processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can print the active method and variables as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the application exits, we close the `JShell` instance by invoking its
    `close()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this recipe can be found at the location, `chp13/6_jshell_api`.
    You can run the sample by using the `run.bat` or `run.sh` scripts available in
    the same directory. The sample execution and output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec75236a-c45f-471a-b7ca-18de3ba63d98.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The central class in the API is the `jdk.jshell.JShell` class. This class is
    the evaluation state engine, whose state is modified with every evaluation of
    the snippet. As we saw earlier, the snippets are evaluated using the `eval(String
    snippet)` method. We can even drop the previously evaluated snippet using the
    `drop(Snippet snippet)` method. Both these methods result in a change of the internal
    state maintained by `jdk.jshell.JShell`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippets passed to the `JShell` evaluation engine are categorized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Erroneous**: Syntactically incorrect input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expressions**: An input which might or might not result in some output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Import**: An import statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: A method declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statement**: A statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type declaration**: A type, that is, class/interface declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable declaration**: A variable declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these categories are captured in the `jdk.jshell.Snippet.Kind` enum.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw different APIs to get the evaluated snippets, created methods, variable
    declarations, and other specific snippet types executed. Each snippet type is
    backed by a class extending the `jdk.jshell.Snippet` class.
  prefs: []
  type: TYPE_NORMAL
