<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Programming with Reactive Extensions</h1>
                
            
            <article>
                
<div class="packt_quote">"We cannot solve our problems with the same thinking we used when we created them."</div>
<div class="packt_quote1">- Albert Einstein</div>
<p class="calibre2">It's beautiful when we give a new dimension to thinking while solving a problem. In programming, our approaches to solving problems may differ from each other. Most of the time, there's an interaction between the user and programs. GUI-based and web applications are a few examples of these applications. We can think of ways in which our application gets notified whenever the user tries to interact with it. It may be possible that our program awaits user's interactions or vice versa. In the opposite case, the user's interaction, at times, notifies the application of some kind of event. Let's say we write our programs to react to a user's interactions. This is the essence of being reactive as an application program. We write a program that acts as a system to the surrounding environment, and the environment itself pushes events to our programs. These events drive the whole system, hence they become the core of a reactive programming model. And that's just the beginning of being reactive, there are more concepts that emerge from this kind of model.</p>
<p class="calibre2">From the previous chapter, we have got the essence of asynchronous computations. Async computations include some kind of computation that will be performed in the near future and its callback, which gets executed when the computation gets completed.</p>
<p class="calibre2">Well, in this chapter, we'll continue with our understanding of asynchronous computations to understand reactive extensions, which are nothing but an API created while keeping the reactive programming model in mind. Here's what we'll be discussing:</p>
<ul class="calibre7">
<li class="calibre8">Reactive programming</li>
<li class="calibre8">Reactive extensions</li>
<li class="calibre8">Reacting to RxScala</li>
</ul>
<p class="calibre2">Reactive programming, in one line, is the process of programming with asynchronous data streams. If that's not the definition you expect, let's try to get an idea about it. Let's think of it as a journey. We'll start from zero, with no understanding of what being reactive in programming terminologies is. As we proceed, we'll have interactions with a few concepts and mechanisms that form the reactive ecosystem. The final goal is to be able to think in Reactive. So let's start it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reactive programming</h1>
                
            
            <article>
                
<p class="calibre2">The best way to understand any new paradigm or concept is to reason about its existence. For this let's think of a very common and simple scenario, as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00065.jpeg" class="calibre71"/></div>
<p class="calibre2">You might have come across the form behavior shown in the preceding figure. There's an agreement to read and then we click on the checkbox to agree to it so that we can proceed further. On the left-hand side, the checkbox is unchecked. Hence, based on its value, we have set the visibility of the <strong class="calibre1">Continue</strong> button (currently for the unchecked box) to false. Once we click and set the checkbox value to true, the visibility of the <strong class="calibre1">Continue</strong> button also becomes true. What is happening is when we click on checkbox, it emits an event with its value, that is, true/false. Now, based on its value, we can set the button's visibility to true/false. This is an example of observing events of a simple checkbox and making use of the event's value. If you picture this, it might look as follows:</p>
<div class="cdpaligncenter"><img src="../images/00066.jpeg" class="calibre72"/></div>
<p class="calibre2">The following diagram shows the <strong class="calibre1">Checkbox</strong> state and button's visibility. We need not care about the code syntax because we're not talking about any language or frameworks for now. In this example, we only cared about a single event getting triggered by the checkbox. It was simple to understand. Now let's think of a computation that's reactive. Think of the following computation:</p>
<pre class="calibre19">A := 5 
B := A 
C := A 
D := B + C </pre>
<p class="calibre2">The computation says <strong class="calibre1">A</strong> is going to have a value, <strong class="calibre1">B</strong> and <strong class="calibre1">C</strong> are going to have the same value as A, and, finally, <strong class="calibre1">D</strong> is going to be the result of the addition of <strong class="calibre1">B</strong> and <strong class="calibre1">C</strong>. So in normal programs, once you execute the statement, you get the values for <strong class="calibre1">A</strong>, <strong class="calibre1">B</strong>, <strong class="calibre1">C</strong>, and <strong class="calibre1">D</strong>. Now, let's think what happens when we consider time and also let the value flow in our system. What do we mean by that? Take a look at the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00067.jpeg" class="calibre73"/></div>
<p class="calibre2">On the left-hand side, we have pictured the scenario which states the same as we mentioned previously. On the right-hand side, we have a table that consists of values of our variables at some instants of time. So let's say we update the value of <strong class="calibre1">A</strong> to 6:</p>
<pre class="calibre19">A := 6 </pre>
<p class="calibre2">Now, this statement should increment the value of <strong class="calibre1">B</strong> and <strong class="calibre1">C</strong> because it's now in the reactive world. So when data is changes, it flows and changes all the dependent variables. Hence, <strong class="calibre1">B</strong> and <strong class="calibre1">C</strong> get updated to <strong class="calibre1">6</strong>, and finally because of the change in its dependents, the value of D also changes and becomes 12. Taking a look at the table, we can see that the values of B, C, and D get updated each time they observe a change in the value of <strong class="calibre1">A</strong>. Till now, we have not dealt with any particular terminology. But we've seen two examples: the first one gave the essence of <em class="calibre18">emitting events</em> and the second one gave the essence of <em class="calibre18">data flow</em> in the system containing variables. These are two important concepts of <em class="calibre18">reactive</em> programming. But wait, we also mentioned <em class="calibre18">reactive programming</em> is programming with asynchronous data streams. To understand this notion, think of the values of the <strong class="calibre1">A</strong> variable as values in a data stream. Now, at a particular instant in time, if we try to access the values of <strong class="calibre1">A</strong>, there are three possibilities:</p>
<ul class="calibre7">
<li class="calibre8">You get a value back</li>
<li class="calibre8">You get an error when you try to fetch a value</li>
<li class="calibre8">You get a message that the stream is completed and contains no more values</li>
</ul>
<p class="calibre2">Picturing this, we'll get something similar to the following:</p>
<div class="cdpaligncenter"><img src="../images/00068.jpeg" class="calibre74"/></div>
<p class="calibre2">The previous diagram demonstrates the possible outcomes of a data stream. The following are a few important points to take away from the preceding diagram:</p>
<ul class="calibre7">
<li class="calibre8">All values are events occurring in time. So the order of these values will be maintained. After the stream completes, there's no possibility of any value getting emitted from the stream.</li>
<li class="calibre8">Time plays an important role; that's to preserve event order.</li>
<li class="calibre8">There might be a possibility of an error occurring while accessing the values from the stream.</li>
<li class="calibre8">Also, as these events are occurring with respect to time, we can make these computations asynchronous in nature and bind a few callbacks to some particular event. We can also filter out a few events based on the values.</li>
</ul>
<p class="calibre2">These kinds of reactive systems react with respect to time and events. And we can also compare these streams to promises, which we discussed in the previous chapter. Promises are responsible for one value that's going to be available in future. Whereas, streams contain multiple returned values evaluated asynchronously. These are the building blocks of <em class="calibre18">reactive programming.</em> The paradigm has its own terminologies for such streams and these are called <strong class="calibre1">Observables</strong><em class="calibre18">.</em> There are various APIs <span>available </span>that let you create such <em class="calibre18">observable streams</em> and allow us to transform, filter, and merge these observable streams to create a reactive system in which data flows.</p>
<p class="calibre2">These APIs are a part of ReactiveX and called reactive extensions. There are asynchronous stream APIs available for a number of languages, some of which are as follows:</p>
<ul class="calibre7">
<li class="calibre8">RxJava</li>
<li class="calibre8">RxJS</li>
<li class="calibre8">Rx.NET</li>
<li class="calibre8">RxScala</li>
<li class="calibre8">RxLua</li>
<li class="calibre8">RxGo</li>
<li class="calibre8">RxDart</li>
</ul>
<p class="calibre2">All these APIs serve the same purpose, that is to provide asynchronous Observable streams in their respective platforms. These APIs revolve around the principle of events and streams. Let's check out what these reactive extensions provide.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reactive extensions</h1>
                
            
            <article>
                
<p class="calibre2">All these APIs serve the same purpose, that is, to provide asynchronous Observable streams in their respective platforms. These APIs revolve around the principle of events and streams. Let's check out what these reactive extensions provide. It's time to see the term we just introduced ourselves to, that is, Observables<em class="calibre18">.</em></p>
<p class="calibre2">Observables are the entities that emit a stream of events. Events can be a button click or checking a checkbox, or some other event like providing input to some device via the interface exposed. There has to be an <em class="calibre18">observer</em> that reacts to whatever value or sequence of values the Observable is emitting. The way <em class="calibre18">observers</em> react to events is by <em class="calibre18">subscribing</em> to the Observable<em class="calibre18">.</em> So these <em class="calibre18">observers</em> subscribing to Observables to react to events is the main theme of ReactiveX. The process in any of the libraries available for different platforms is somewhat similar to the following:</p>
<ul class="calibre7">
<li class="calibre8">We define the Observable, which does the job of emitting events. This will be in an asynchronous fashion, as events can be dependent on some environment/surrounding, for example, user's interaction or some condition being successful.</li>
<li class="calibre8">We define a method, which does some manipulation with the return value from an asynchronous computation. This method is part of <em class="calibre18">observers.</em></li>
<li class="calibre8">We attach the <em class="calibre18">observer</em> to the <em class="calibre18">Observable</em> by <em class="calibre18">subscribing</em> to it.</li>
</ul>
<p class="calibre2">By subscribing the <kbd class="calibre11">Observer</kbd> to Observable, we specify that now the mechanism is in place and our observers are ready to react to events. Based on this phenomena, Observables are categorized as hot and cold Observables.</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Hot Observables</strong>: These start emitting events as soon as they are created, hence if in a later point in time we attach/subscribe an observer to it, the observer continues to react to events from the current point of time.</li>
<li class="calibre8"><strong class="calibre1">Cold Observables</strong>: These, on the other hand start emitting events when they're subscribed by an observer. In this way, our observers react to events from the beginning.</li>
</ul>
<p class="calibre2">Also, we have seen while observing events from a stream that there are possibilities of an error or the stream to be completed. So for Observer[T], we provide following methods:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">onNext(T)</kbd></li>
<li class="calibre8"><kbd class="calibre11">onError(Exception)</kbd></li>
<li class="calibre8"><kbd class="calibre11">onComplete()</kbd></li>
</ul>
<p class="calibre2">Each call to the observer's <kbd class="calibre11">onNext</kbd> method comes with a value from an event. In case you create an observer of the <kbd class="calibre11">String</kbd> type, then the <kbd class="calibre11">onNext</kbd> method will give you a string value. In a typical reactive programming scenario, a call to the <kbd class="calibre11">onNext</kbd> method is made until the event stream gets completed or some error occurs; in these cases, <kbd class="calibre11">onComplete</kbd> or <kbd class="calibre11">onError</kbd> gets called. After these methods, we don't get any values from that subscription.</p>
<p class="calibre2">If you remember, the iterables we discussed while taking about collections, these iterables work in a somewhat similar fashion, with the only difference being that the Observables are asynchronous in nature. Iterables contain data in sequence, from which we can obtain a value at a time and perform some operation on them. To obtain data from such iterables, we create an iterator. Calling <kbd class="calibre11">iterator.next()</kbd> lets us access the value in an iterable. An iterable lets you access a sequence of values in a synchronous fashion:</p>
<div class="cdpaligncenter"><img src="../images/00069.jpeg" class="calibre75"/></div>
<p class="calibre2">The difference lies in the nature of these two: Observables are asynchronous in nature, while Iterables are not. Taking a look at these two interfaces, we can see the following:</p>
<div class="cdpaligncenter"><img src="../images/00070.jpeg" class="calibre76"/></div>
<p class="calibre2">We know about <em class="calibre18">Observables,</em> but what makes them powerful is a set of <em class="calibre18">utility</em> methods, described as <em class="calibre18">operators.</em> These operators allow us to <em class="calibre18">create, combine, transform, filter</em>, and <em class="calibre18">convert</em> Observable<em class="calibre18">s.</em> We can chain these operators to perform these operations in a specific order.</p>
<p class="calibre2">Now that we're sure about the theoretical stuff, it's time to try out what you learned using Scala's offering in the reactive world, that is, <em class="calibre18">RxScala.</em> Let's look at the RxScala API to represent the Observables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">React to RxScala</h1>
                
            
            <article>
                
<p class="calibre2">RxScala is a reactive asynchronous streams API provided in Scala. It lets us perform all those concepts we talked about, such as creating <em class="calibre18">Observables, observers,</em> and <em class="calibre18">subscribing</em> to them. There's a variety of operators available for us to manipulate these <em class="calibre18">Observables.</em> Most of the operators return <em class="calibre18">Observables,</em> hence chaining of <em class="calibre18">Observables</em> is also possible.</p>
<p class="calibre2">To start writing some <em class="calibre18">Observables,</em> we'll start by setting up space so that the library becomes available to us. For that, let's follow some steps:</p>
<ol class="calibre13">
<li value="1" class="calibre8">On your favorite internet browser, open <a href="https://developer.lightbend.com" class="calibre10">https://developer.lightbend.com</a> and click on the <span>START A PROJECT</span> button.</li>
<li value="2" class="calibre8">You'll get a few options; just choose Scala and click on <span>CREATE A PROJECT FOR ME!</span>. It'll download the source in a compressed format:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00071.jpeg" class="calibre77"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">We can extract that and open it in IntelliJ IDE.</li>
<li value="4" class="calibre8">Once it's opened in IntelliJ, we can add the library dependency for RxScala in the build file. This can be done by specifying the following:</li>
</ol>
<pre class="calibre19">     libraryDependencies += "io.reactivex" %% "rxscala" % "0.26.5" </pre>
<ol start="5" class="calibre13">
<li value="5" class="calibre8">After specifying dependency, we can perform the <kbd class="calibre11">sbt update</kbd> command from the command line<em class="calibre18">,</em> which will download the dependency files. We should do this update from the directory where <kbd class="calibre11">build.sbt</kbd> is specified.</li>
</ol>
<p class="calibre2">Now, we are ready to write Observables. So why wait? Let's write some.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating Observables</h1>
                
            
            <article>
                
<p class="calibre2">For creating Observables, there are a bunch of operators such as <kbd class="calibre11">just</kbd>, <kbd class="calibre11">empty</kbd>, <kbd class="calibre11">interval</kbd>, <kbd class="calibre11">from</kbd>, and <kbd class="calibre11">defer</kbd>. Let's first write some code to create Observables in some of the ways:</p>
<pre class="calibre19">package example 
 
import rx.lang.scala.Observable 
import scala.concurrent.Future 
import scala.concurrent.ExecutionContext.Implicits.global 
<span>import scala.concurrent.duration._ </span>
 
 
object FirstRxApp extends App { 
 
  //Creates an empty Observable. 
  val emptyObservable = Observable.empty 
 
  //Creates an Observable that only emits 1. 
  val numObservable = Observable.just(1) 
 
  val sequence = List(1, 3, 5, 7, 9) 
 
  //Creates an Observable, which emits values from the sequence mentioned. 
  val sequenceObservable = Observable.from(sequence) 
 
  val someAsyncComputation = Future { 1 } 
  //Creates an Observable, from an async computation 
  val fromAsyncObservable = Observable.from(someAsyncComputation) 
 
  //Creates an Observable, which emits items at a duration gap specified. 
val intervalObservables = Observable.interval(200 millis) 
 
 
  //Creates an Observable, which starts emitting, once some observer subscribe to it. 
  val deferObservable = Observable.defer(fromAsyncObservable) 
   
  //Creates an Observable, which never emits any value. 
  val neverObservable = Observable.never 
 
} </pre>
<p class="calibre2">In the preceding code snippet, we have only created Observables and there's no subscription to them. Hence, even if they emit some values, we have no mechanism to react to those values. First let's check out the code written:</p>
<ol class="calibre13">
<li value="1" class="calibre8">The first statement creates an empty Observable, which means it has no values in it.</li>
<li value="2" class="calibre8">The second statement calls an operator named <kbd class="calibre11">just</kbd><em class="calibre18">,</em> which takes a value and wraps that in the Observable context. Hence, when this observable emits, it'll emit only the value we specified.</li>
<li value="3" class="calibre8">Next, we provided a sequence of values to our observable with the method named <kbd class="calibre11">from</kbd><em class="calibre18">.</em></li>
<li value="4" class="calibre8">The <kbd class="calibre11"><span>from</span></kbd><span> </span>method can also take a future value and create an Observable. This Observable emits values that result from async computations specified in Future.</li>
</ol>
<pre class="calibre19">    def from[T](f: Future[T])(implicit execContext: ExecutionContext): Observable[T] </pre>
<ol start="5" class="calibre13">
<li value="5" class="calibre8">Then there's the <kbd class="calibre11">interval</kbd> method, which expects us to provide the interval in which we emit values.</li>
<li value="6" class="calibre8">Finally, there are two more ways we specified. First, we used the operator named <kbd class="calibre11">defer</kbd><em class="calibre18">,</em> which takes the <kbd class="calibre11">byname</kbd> parameter as another Observable and only starts the emission of events once an observer subscribes to it:</li>
</ol>
<pre class="calibre19">    def defer[T](observable: =&gt; Observable[T]): Observable[T] </pre>
<p class="calibre2">With these operators, we were able to create Observables<em class="calibre18">.</em> Now let's attach subscriptions to these Observables by calling the <kbd class="calibre11">subscribe</kbd> method. For that, we can add the following snippet to our Scala file. First, let's add some imports:</p>
<pre class="calibre19">import rx.Subscription 
import rx.observers.TestSubscriber </pre>
<p class="calibre2">Next, we add this snippet following the Observables creation:</p>
<pre class="calibre19">//Subscribing to Observables 
emptyObservable 
  .subscribe(value =&gt; println(s"From emptyObservable: $value")) 
 
numObservable 
  .subscribe(value =&gt; println(s"From numObservable: $value")) 
 
sequenceObservable 
  .subscribe(value =&gt; println(s"From sequenceObservable: $value")) 
 
fromAsyncObservable 
  .subscribe(value =&gt; println(s"From fromAsyncObservable: $value")) 
 
intervalObservables 
  .subscribe(value =&gt; println(value)) 
Thread.sleep(1000) 
 
 
new TestSubscriber[Subscription].awaitTerminalEvent(1000, MILLISECONDS) 
 
 
deferObservable 
  .subscribe(value =&gt; println(s"From deferObservable: $value")) </pre>
<p class="calibre2">In the previous snippet, in most cases, we call a <kbd class="calibre11">subscribe</kbd> method by passing what to do with the value. Take a look at the <kbd class="calibre11">subscribe</kbd> method's signature:</p>
<pre class="calibre19">def subscribe(onNext: T =&gt; Unit): Subscription </pre>
<p class="calibre2">The method takes the value and performs, or let's say reacts, to the value. It returns a <kbd class="calibre11">Subscription</kbd> instance. The advantage of this <kbd class="calibre11">Subscription</kbd> parameter is that we can cancel the subscription by calling a method named <kbd class="calibre11">unsubscribe</kbd><em class="calibre18">.</em></p>
<p class="calibre2">In the case of <kbd class="calibre11">intervalObservables</kbd><em class="calibre18">,</em> we had to provide <kbd class="calibre11">Thread.sleep(1000)</kbd> too so that our <kbd class="calibre11">intervalObservables</kbd> type gets some time to emit values. If we don't use some mechanism to wait for these emissions, the thread will be killed and we won't get to see the emitted values.</p>
<p class="calibre2">These are a few ways in which we can create Observables and subscribe to them. But that's more of getting used to APIs. We may want to see some examples which can demonstrate the use of this reactive pattern.</p>
<p class="calibre2">Let's think of a scenario. Suppose a user has to fill a form with information about a football player. He has to provide the player's name, age, nationality, and the league. After filling the information, the user will press <strong class="calibre1">Submit</strong> and that form data comes to us for processing:</p>
<div class="cdpaligncenter"><img src="../images/00072.jpeg" class="calibre78"/></div>
<p class="calibre2">Now it's up to us to provide a data flow for the player's information. By this, we mean that with the specific information, we can create a player's instance, validate the information, show the information in some particular format, or any other thing you can come up with. The flow is going to be the same for every form submission. In that case, we can create an Observable to the event, let's call it, the form submit event. Subscribed observer for the same will get data from each form submission. And then we can define <kbd class="calibre11">onNext</kbd> to manipulate the form data whichever way we want. Regardless of the user's speed of entering information and pressing the <strong class="calibre1">Submit</strong> button, we have the system in place with the Observable, which gets notified by the event's occurrence. And the process starts.</p>
<p class="calibre2">Now, to see this in practice, let's think that the data source is our favorite CSV file, instead of someone filling out the form for us, and see how the code might look:</p>
<pre class="calibre19">package example 
 
import rx.lang.scala.Observable 
 
object SmartApp extends App { 
 
  val src = 
   "/Users/vika/Documents/LSProg/LSPWorkspace/First_Proj_Rx/src/main/scala/example/football_stats.csv" 
 
 
  val playerObservable = 
    Observable.from(PlayerService.readPlayerDataFromSource(src)) 
 
  playerObservable 
    .map(playerString =&gt; 
    PlayerService.parseToPlayer(playerString)) 
    .subscribe(player =&gt; PlayerService.showPlayerInformation(player), 
    error =&gt; println(s"Error Occurred: ${error.getMessage}")) 
 
 
  Thread.sleep(10000) 
} </pre>
<p class="calibre2">In the preceding code, think of the <kbd class="calibre11">playerObservable</kbd> type being created from some event source. It's type is <kbd class="calibre11">String</kbd>, in our case it's supposed to contain the player information in string format. Now what we are supposed to do with the string is to parse this string information to a Player instance. The methods <kbd class="calibre11">readPlayerDateFromSource</kbd><em class="calibre18">,</em> <kbd class="calibre11">parseToPlayer</kbd>, and <kbd class="calibre11">showPlayerInformation</kbd> are part of another object named <kbd class="calibre11">PlayerService</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">package example 
 
import scala.io.BufferedSource 
import scala.util.{Failure, Success, Try} 
 
object PlayerService { 
 
  def readPlayerDataFromSource(src: String): List[String] = { 
    val source: BufferedSource = io.Source.fromFile(src) 
    val list: List[String] = source.getLines().toList 
 
    source.close() 
    list 
  } 
 
  def parseToPlayer(string: String): Option[Player] = { 
    Try { 
      val columns = string.split((",")).map(_.trim) 
      Player(columns(5), columns(6), columns(9).toInt, columns(7)) 
    } match { 
      case Success(value) =&gt; Some(value) 
      case Failure(excep) =&gt; None 
    } 
  } 
 
  def showPlayerInformation(playerOp: Option[Player]): Unit = { 
    playerOp.map { player =&gt; 
      println("------------ Here's our Player Information ----------- ") 
      println(s"Name: ${player.name}") 
      println(s"Age: ${player.age} | Nationality: ${player.nationality} | League: ${player.league}") 
      println 
    } 
  } 
 
  case class Player(name: String, nationality: String, age: Int, league: String) 
 
} </pre>
<p class="calibre2">Let's see the magic of operators in our case. The first one is the map itself, which takes a player string as expected and makes a call to <kbd class="calibre11">parseToPlayer</kbd>:</p>
<pre class="calibre19">playerObservable 
    .map(playerString =&gt; 
      PlayerService.parseToPlayer(playerString)) </pre>
<p class="calibre2">If you try to infer its result type, it's nothing but <kbd class="calibre11">Observable[Option[Player]]</kbd>, so nothing has changed; it's still an Observable. We've just made a transformation in the Observable world and got a result. After that, we subscribed to the Observables and called our desired <kbd class="calibre11">showPlayerInformation(player)</kbd> method:</p>
<pre class="calibre19">.subscribe(player =&gt; PlayerService.showPlayerInformation(player), 
    error =&gt; println(s"Error Occurred: ${error.getMessage}")) </pre>
<p class="calibre2">This itself is pretty amazing because the system is set up for a particular event, in our case the <em class="calibre18">form submit</em> event that gives us <kbd class="calibre11">Observable[String]</kbd><em class="calibre18">.</em> Thanks to our hypothetical user, who enters the information and submits it so that the system gets a String to operate upon.</p>
<p class="calibre2">Now to clear the picture again, we'll get the help of the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00073.jpeg" class="calibre79"/></div>
<p class="calibre2">As shown in the preceding diagram, currently, there's only one source of player information attached and the whole pipeline works well. Now think of another scenario where our hypothetical user can also select a player from some suggested input. What will that look like?</p>
<div class="cdpaligncenter"><img src="../images/00074.jpeg" class="calibre80"/></div>
<p class="calibre2">In this case, we might get the whole player information as <kbd class="calibre11">Option[Player]</kbd> instead of string. Hence, the observable working in this case will be of the type <kbd class="calibre11">Observable[Option[Player]]</kbd><em class="calibre18">.</em> Now if we want to execute the same logic as we did in the case of form submission, all we have to do is use the merge operator. This will combine the Observables, hence we'll be able to achieve what we desire. The important thing is to merge our new Observable at the right place. From the diagram, we get a hint that it'll be better if we merge Observable when we have <kbd class="calibre11">observable[Option[Player]]</kbd> as shown in following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00075.jpeg" class="calibre81"/></div>
<p class="calibre2">Take a look at the preceding diagram. As you can see on the left-most side, the suggestion input form gives us <kbd class="calibre11">Observable[Option[Player]]</kbd><em class="calibre18">,</em> which we merge with our transformed Observable of the same type. We can do the same in our code. Let's create an Observable from a custom optional player and then merge that.</p>
<p class="calibre2">We'll just refactor our code to the following:</p>
<pre class="calibre19">package example 
 
import rx.lang.scala.Observable 
 
object SmartApp extends App { 
 
  val src = 
    "/Users/vika/Documents/LSProg/LSPWorkspace/First_Proj_Rx/src/main/scala/example/football_stats.csv" 
 
  val playerObservable: Observable[String] = 
    Observable.from(PlayerService.readPlayerDataFromSource(src)) 
 
  val somePlayer = Some(PlayerService.Player("Random Player", "Random Nation", 31, "Random League")) 
 
  playerObservable 
    .map(playerString =&gt; 
      PlayerService.parseToPlayer(playerString)) 
    .merge(Observable.just(somePlayer)) 
    .subscribe(player =&gt; PlayerService.showPlayerInformation(player), 
      error =&gt; println(s"Error Occurred: ${error.getMessage}")) 
 
  Thread.sleep(10000) 
} </pre>
<p class="calibre2">We can see that we merged the <kbd class="calibre11">observable.just(somePlayer)</kbd> type with the Observable of the type <kbd class="calibre11">Observable[Option[Player]]</kbd><em class="calibre18">.</em> This call to merge combines these two Observables, and hence the values from these combined sources go through the pipeline. We can try this out by running the application. We'll get to see values from our CSV file as well as the <kbd class="calibre11">somePlayer</kbd> Observable we created if the CSV file is in the correct place. This way, we can use operators to make our system work with several event sources. This is just the tip of the iceberg. There's a lot we can achieve with these operators available. I strongly recommend that you go through the documentation (<a href="http://reactivex.io/documentation/operators.html" target="_blank" class="calibre10">http://reactivex.io/documentation/operators.html</a>) from ReactiveX<em class="calibre18">.</em> Their marble diagrams explain each of these operators, and you can use them according to your needs.</p>
<p class="calibre2">With this recommendation, we would want to summarize what we've covered in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter introduced us to the notion of reactive programming. We understood the concept of Observable events and reacting to them. This gave us an essence of what reactive programming is. After that, we went through reactive extensions and explored the API a bit. We saw how we can create Observables and subscribe to them. Finally, we looked at   an example that explained the way we can compose Observables using some operators available to us.</p>
<p class="calibre2">In next chapter, we'll cover one of the most important topics, that is, testing our programs. We'll go through the much talked about nowadays development model, that is, <strong class="calibre1">test-driven development</strong> (<strong class="calibre1">TDD</strong>). We'll start by answering the why and what of TDD and then understand the toolkits available in Scala for testing.</p>


            </article>

            
        </section>
    </body></html>