<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Load Balancing with mod_cluster"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Load Balancing with mod_cluster</h1></div></div></div><p>In this chapter, we will have a look at another load balancer solution. It is<a id="id214" class="indexterm"/> called <a id="id215" class="indexterm"/>
<span class="strong"><strong>mod_cluster</strong></span> (<a class="ulink" href="http://www.jboss.org/mod_cluster">http://www.jboss.org/mod_cluster</a>).</p><p>In comparison with JK, mod_cluster is more powerful and complex in design. Nevertheless, the added complexity in design doesn't mean it's harder to use; mod_cluster is designed to be scalable and can dynamically find the worker nodes so as to form a cluster.</p><p>Such kinds of flexibilities usually create confusion among newcomers and give them the impression that mod_cluster is harder to use. Thus, to appreciate the power of mod_cluster and its simplicity of usage, we must understand its design first.</p><div class="section" title="The design of mod_cluster"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>The design of mod_cluster</h1></div></div></div><p>From the previous chapter, <a id="id216" class="indexterm"/>we know that JK uses a TCP port to communicate with the JBoss EAP6 server via AJP13 protocols. When compared with JK, mod_cluster uses the following three channels to serve its functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>connector channel</strong></span><a id="id217" class="indexterm"/> supports the multiple protocols <a id="id218" class="indexterm"/>for the load balancer to proxy user requests to worker nodes. This part is almost synonymous with JK. The difference here is that besides the AJP13 protocol, mod_cluster also supports the HTTP/HTTPS protocols.</li><li class="listitem" style="list-style-type: disc">An <span class="strong"><strong>advertising channel</strong></span><a id="id219" class="indexterm"/> discovers worker nodes. This <a id="id220" class="indexterm"/>channel uses IP multicasting to transfer UDP datagrams. The load balancer will advertise itself in a multicast group, and the worker nodes will find it automatically by subscribing to this group.</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>management channel</strong></span><a id="id221" class="indexterm"/> is used to transfer<a id="id222" class="indexterm"/> status and management messages between the load balancer and the worker nodes. The protocol used by the management channel is an extension of the HTTP/1.1 protocol. The name of the protocol is <a id="id223" class="indexterm"/><span class="strong"><strong>MCMP</strong></span>.</li></ul></div><p>When compared with JK, mod_cluster can collect many runtime factors of a worker node to judge its "busy-ness", and it calculates a number that indicates the "busy-ness" of each worker node. This number is called a <a id="id224" class="indexterm"/>
<span class="strong"><strong>load factor</strong></span>, and the factors are called <a id="id225" class="indexterm"/>
<span class="strong"><strong>metrics</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>mod_cluster provides us with multiple metrics to use, such as <code class="literal">SystemMemoryUsageLoadMetric</code> and <code class="literal">AverageSystemLoadMetric</code>. A complete list of metrics can be found here: <a class="ulink" href="http://docs.jboss.org/mod_cluster/1.2.0/html/java.load.html">http://docs.jboss.org/mod_cluster/1.2.0/html/java.load.html</a>.</p></div></div><p>The deployment of mod_cluster is divided into two parts: the first part is the load balancer, and the other part is the worker node. In our scenario, the load balancer is <span class="strong"><strong>httpd</strong></span>, and mod_cluster provides a native component for it. On the worker node side, we are using JBoss EAP6, and mod_cluster provides a subsystem for it. To sum up, let's have an overview of its structure:</p><div class="mediaobject"><img src="graphics/2432OS_05_01.jpg" alt="The design of mod_cluster"/></div><p>As per the preceding diagram, mod_cluster is divided into two parts: the load balancer side and the worker node side. In addition, it has the following three channels that form its functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>advertise</strong></span> channel<a id="id226" class="indexterm"/> allows the load balancer <a id="id227" class="indexterm"/>to advertise itself, and the worker nodes can dynamically join or exit a cluster at runtime.</li><li class="listitem" style="list-style-type: disc">With the<a id="id228" class="indexterm"/> <span class="strong"><strong>mod_manager</strong></span> channel, the<a id="id229" class="indexterm"/> load balancer can get the load factor information from the worker node. The MCPM protocol is used in this channel, and the load factor, along with the rest of the information of the worker nodes, is sent at regular intervals.</li><li class="listitem" style="list-style-type: disc">The <a id="id230" class="indexterm"/><span class="strong"><strong>mod_proxy_cluster</strong></span> channel<a id="id231" class="indexterm"/> will forward user requests to the worker nodes from behind. It supports the AJP13 protocol similar to JK, and it supports HTTP/HTTPS additionally.</li></ul></div><p>After this overview of the design of mod_cluster, we will learn how to install mod_cluster in the following section.</p></div></div>
<div class="section" title="Installing mod_cluster"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Installing mod_cluster</h1></div></div></div><p>In this<a id="id232" class="indexterm"/> section, <a id="id233" class="indexterm"/>we will learn how to compile mod_cluster from the source code and install it on our load balancer machine. The machine I'm using to install mod_cluster and httpd is called <span class="emphasis"><em>lb</em></span>, which is the same machine used in the previous chapter.</p><p>We have learned how to compile and install httpd in the previous chapter, and we have put a lot of JK-related configurations in our httpd installation. To make the instructions in this chapter clearer, let's archive the following httpd installation from the previous chapter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mv httpd httpd-for-jk</strong></span>
</pre></div><p>We'll need to use it in the next chapter, so please back it up properly. Our next step is to repeat the httpd compiling and installing processes as we have done in the previous chapter. We actually just need to rerun <code class="literal">make install</code> in the httpd source directory because we have already configured and compiled it properly, and we will get a fresh httpd installation by running this command. Now let's move on with the mod_cluster installation.</p><div class="section" title="Downloading mod_cluster"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Downloading mod_cluster</h2></div></div></div><p>Now we need <a id="id234" class="indexterm"/>to download mod_cluster. The source code of mod_cluster is hosted at GitHub. We will use Version 1.2.6.Final in this book: <a class="ulink" href="https://github.com/modcluster/mod_cluster/archive/1.2.6.Final.zip">https://github.com/modcluster/mod_cluster/archive/1.2.6.Final.zip</a>.</p><p>Download it and extract the zip file, and you will get the source directory <code class="literal">mod_cluster-1.2.6.Final</code>. The following are its contents:</p><div class="mediaobject"><img src="graphics/2432OS_05_02.jpg" alt="Downloading mod_cluster"/></div><p>In the source directory, we can see that mod_cluster contains several components, but we only need to care about <a id="id235" class="indexterm"/>the components in the <code class="literal">native</code> directory. The other Java modules are for the worker node. Since EAP6 already contains the mod_cluster subsystem out of the box, we don't need to compile them. Now let's have a look at the <code class="literal">native</code> directory:</p><div class="mediaobject"><img src="graphics/2432OS_05_03.jpg" alt="Downloading mod_cluster"/></div><p>You may have guessed the purposes of some components by their names; let's still check them one by one:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
advertise
</p>
</td><td style="text-align: left" valign="top">
<p>The advertising module for the supporting autodiscovery worker node</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
mod_proxy_cluster
</p>
</td><td style="text-align: left" valign="top">
<p>The proxy module that supports the AJP/HTTP/HTTPS proxy requests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
mod_manager
</p>
</td><td style="text-align: left" valign="top">
<p>The mod_cluster manager module that controls the worker node and gets load factors from the worker node.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
mod_slotmem
</p>
</td><td style="text-align: left" valign="top">
<p>The shared memory module used by mod_cluster internally.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
selinux
</p>
</td><td style="text-align: left" valign="top">
<p>The SElinux policy files. We won't cover this topic in the book.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
include
</p>
</td><td style="text-align: left" valign="top">
<p>Common header files.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
scripts
</p>
</td><td style="text-align: left" valign="top">
<p>Some installation scripts we won't use.</p>
</td></tr></tbody></table></div><p>As we have understood the meaning of these components, it's now time to build them.</p></div><div class="section" title="Compiling and installing mod_cluster"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Compiling and installing mod_cluster</h2></div></div></div><p>The modules that<a id="id236" class="indexterm"/> we need to build are advertise, mod_proxy_cluster, mod_manager, and mod_slotmem. It doesn't matter which module you build first; let's start with <code class="literal">advertise</code>. We need to find a script called <code class="literal">buildconf</code> in the directory as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mod_cluster-1.2.6.Final/native/advertise$ ls buildconf</strong></span>
<span class="strong"><strong>buildconf</strong></span>
</pre></div><p>Now let's run this script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./buildconf</strong></span>
</pre></div><p>It will create<a id="id237" class="indexterm"/> a script called <code class="literal">configure</code>. Then we need to run the this script using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./configure  --with-apxs=/packt/httpd/bin/apxs</strong></span>
</pre></div><p>We've <a id="id238" class="indexterm"/>used the <code class="literal">--with-apxs</code> option to tell mod_cluster the position of httpd. After the configuring process is complete, please run the <code class="literal">make</code> command, and we will get the following shared library named <code class="literal">mod_advertise.so</code>:</p><div class="mediaobject"><img src="graphics/2432OS_05_19.jpg" alt="Compiling and installing mod_cluster"/></div><p>After the preceding library is built, let's move it to the httpd <code class="literal">modules</code> folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mv mod_advertise.so /packt/httpd/modules/</strong></span>
</pre></div><p>This is all that we need to do for compiling and installing <code class="literal">advertise</code>. Go to the directories of the other three modules, and use the same procedure to build them one by one. We'll get <code class="literal">mod_proxy_cluster.so</code>, <code class="literal">mod_manager.so</code>, and <code class="literal">mod_slotmem.so</code>. Please move all of them to the httpd <code class="literal">modules</code> directory.</p><p>These are all the mod_cluster components we need to install. In the following section, we will configure httpd to use these modules.</p></div></div>
<div class="section" title="Configuring mod_cluster"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Configuring mod_cluster</h1></div></div></div><p>After installing <a id="id239" class="indexterm"/>the necessary mod_cluster components in httpd, we will configure them properly in this section.</p><div class="section" title="Configuring httpd.conf"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Configuring httpd.conf</h2></div></div></div><p>Before <a id="id240" class="indexterm"/>we <a id="id241" class="indexterm"/>start to configure mod_cluster, we need to do some preparations in <code class="literal">httpd.conf</code>. The first thing to do is to change the <code class="literal">Listen</code> directive from <code class="literal">Listen 80</code> to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Listen 10.0.1.33:80</strong></span>
<span class="strong"><strong>Listen 10.0.1.33:6666</strong></span>
<span class="strong"><strong>Listen 172.16.123.1:80</strong></span>
</pre></div><p>As we know, <span class="emphasis"><em>lb</em></span> has two IP addresses: one is the public address 172.16.123.1, and the other is 10.0.1.33, which is the internal IP address of the load balancer used to communicate with the two EAP6 servers. Now let's learn the purpose of the configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">10.0.1.33:80</code> will be used for a mod_cluster management console. We don't want public access of this management console, so we just bind it to the local IP address.</li><li class="listitem" style="list-style-type: disc"><code class="literal">10.0.1.33:6666</code> will be used by mod_manager to communicate with the EAP6 servers, and the message encapsulated in the MCPM protocol will be transferred through this channel.</li><li class="listitem" style="list-style-type: disc"><code class="literal">172.16.123.1:80</code> is the public address that serves user requests. If you don't have a separate public IP address, you can just use your local IP address to serve all the requests.</li></ul></div><p>After configuring the listening addresses, the next step is to configure the <code class="literal">LogLevel</code>. We need to change the log level to <code class="literal">debug</code>; the following is the configuration for doing so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>LogLevel debug</strong></span>
</pre></div><p>We need the debug log output later. We will now go to the <code class="literal">ServerName</code> section and add the hostname of our load balancer. We are using <code class="literal">lb</code> as the hostname, so the configuration is as shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ServerName lb</strong></span>
</pre></div><p>And please don't forget to bind this server name to the public IP address in <code class="literal">/etc/hosts</code>. Next, we need to add an <code class="literal">Include</code> directive at the bottom of <code class="literal">httpd.conf</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Include conf.d/*.conf</strong></span>
</pre></div><p>This is all we<a id="id242" class="indexterm"/> need to do in <code class="literal">httpd.conf</code>. In the next section, we'll create a separate configuration file for mod_cluster in the <code class="literal">conf.d</code> directory</p></div><div class="section" title="Configuring mod_cluster"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Configuring mod_cluster</h2></div></div></div><p>Now let's <a id="id243" class="indexterm"/>create a directory named <code class="literal">conf.d</code> in httpd:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/packt/httpd$ mkdir conf.d</strong></span>
</pre></div><p>Then we need to create a file called <code class="literal">mod-cluster.conf</code> in the same directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/packt/httpd/conf.d$ touch mod-cluster.conf</strong></span>
</pre></div><p>Due to the <code class="literal">Include conf.d/*.conf</code> directive in <code class="literal">httpd.conf</code>, the created configuration file will be loaded during httpd startup.</p><p>Now let's add the contents to this file. First, we need to load the following modules of mod_cluster:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>LoadModule slotmem_module modules/mod_slotmem.so</strong></span>
<span class="strong"><strong>LoadModule manager_module modules/mod_manager.so</strong></span>
<span class="strong"><strong>LoadModule proxy_cluster_module modules/mod_proxy_cluster.so</strong></span>
<span class="strong"><strong>LoadModule advertise_module modules/mod_advertise.so</strong></span>
</pre></div><p>Note that mod_cluster relies on some of the already configured modules in <code class="literal">httpd.conf</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>LoadModule proxy_module modules/mod_proxy.so</strong></span>
<span class="strong"><strong>LoadModule proxy_ajp_module modules/mod_proxy_ajp.so</strong></span>
<span class="strong"><strong>LoadModule proxy_http_module modules/mod_proxy_http.so</strong></span>
<span class="strong"><strong>LoadModule ssl_module modules/mod_ssl.so</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The preceding modules have already been loaded in <code class="literal">httpd.conf</code>. Please note that the <code class="literal">proxy-balancer</code> module is disabled in httpd because it conflicts with mod_cluster.</p></div></div><p>Now we need to define two virtual hosts: one is for the web management console, and the other is for the management module to send/receive MCPM messages. Let's go through them one at a time. Here's the configuration for the first one:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;VirtualHost 10.0.1.32:80&gt;</strong></span>
<span class="strong"><strong>  &lt;Directory /&gt;</strong></span>
<span class="strong"><strong>    Order deny,allow</strong></span>
<span class="strong"><strong>    Deny from all</strong></span>
<span class="strong"><strong>    Allow from 10.0.1</strong></span>
<span class="strong"><strong>  &lt;/Directory&gt;</strong></span>
<span class="strong"><strong>  &lt;Location /mc&gt;</strong></span>
<span class="strong"><strong>    SetHandler mod_cluster-manager</strong></span>
<span class="strong"><strong>    Order deny,allow</strong></span>
<span class="strong"><strong>    Deny from all</strong></span>
<span class="strong"><strong>    Allow from 10.0.1</strong></span>
<span class="strong"><strong>  &lt;/Location&gt;</strong></span>
<span class="strong"><strong>&lt;/VirtualHost&gt;</strong></span>
</pre></div><p>In the previous virtual host definition, <a id="id244" class="indexterm"/>we have defined a location called <code class="literal">/mc</code> and bound it to <code class="literal">mod_cluster-manager</code>. This handler will provide us with a web-based management console, which we'll use in the later sections. Now let's check the second virtual host definition:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;VirtualHost 10.0.1.32:6666&gt;</strong></span>
<span class="strong"><strong>  &lt;Directory /&gt;</strong></span>
<span class="strong"><strong>    Order deny,allow</strong></span>
<span class="strong"><strong>    Deny from all</strong></span>
<span class="strong"><strong>    Allow from 10.0.1</strong></span>
<span class="strong"><strong>  &lt;/Directory&gt;</strong></span>
<span class="strong"><strong>  ServerAdvertise on http://10.0.1.32:6666</strong></span>
<span class="strong"><strong>  EnableMCPMReceive</strong></span>
<span class="strong"><strong>&lt;/VirtualHost&gt;</strong></span>
</pre></div><p>There are two important directives in the preceding settings. One is the <code class="literal">ServerAdvertise</code> directive. The address set in this directive will be advertised by mod_cluster in the multicast group. For example, our setting is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ServerAdvertise on http://10.0.1.32:6666</strong></span>
</pre></div><p>So, mod_cluster will broadcast it in a multicast group by saying something to this effect: "My MCPM management channel is located at http://10.0.1.32:6666, come and join me!". The worker nodes that are subscribed to the multicast group will receive this information and can then join the cluster.</p><p>Please note that we don't need to configure the multicast address for advertising. This is because the default address for advertising is 224.0.1.105:23364, which matches the default settings in EAP6. We'll see this in the next section. If you want to change this setting, you can use the <code class="literal">AdvertiseGroup</code> directive by placing it under the <code class="literal">ServerAdvertise</code> directive:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>AdvertiseGroup &lt;some_other_multicast_addr:some_other_port&gt;</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>You can always check the online document for mod_cluster to learn about these detail configurations: (<a class="ulink" href="http://docs.jboss.org/mod_cluster/1.2.0/html/native.config.html">http://docs.jboss.org/mod_cluster/1.2.0/html/native.config.html</a>).</p></div></div><p>Now let's see the following directive:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>EnableMCPMReceive</strong></span>
</pre></div><p>With the preceding directive, the virtual host 10.0.1.32:6666 is used as a management channel, and MCPM is used as the communication protocol for this channel. This is all we need to do in <code class="literal">mod-cluster.conf</code>.</p><div class="section" title="Configuring EAP6"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Configuring EAP6</h3></div></div></div><p>Until now, we <a id="id245" class="indexterm"/>haven't looked at the <code class="literal">modcluster</code> subsystem configuration in EAP6. Since the default configuration provided by the EAP6 domain mode is good to use, we don't need to change anything. Let's have a look at the configuration anyway.</p><p>From the configuration in <code class="literal">domain.xml</code>, we can see the following default settings of the <code class="literal">modcluster</code> subsystem:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
    &lt;mod-cluster-config advertise-socket="modcluster" connector="ajp"&gt;
        &lt;dynamic-load-provider&gt;
            &lt;load-metric type="busyness"/&gt;
        &lt;/dynamic-load-provider&gt;
    &lt;/mod-cluster-config&gt;
&lt;/subsystem&gt;</pre></div><p>We can see that the <code class="literal">modcluster </code>subsystem is bound to the advertising socket named <code class="literal">modcluster</code> by the <code class="literal">advertising-socket</code> directive. Then we see that the <code class="literal">modcluster</code> subsystem is using the <code class="literal">busyness</code> metric by default. It is a metric that judges the server "busy-ness" from the working threads. Now let's see the settings of the socket-binding <code class="literal">modcluster</code>:</p><div class="informalexample"><pre class="programlisting">&lt;socket-binding-group name="full-ha-sockets" default-interface="public"&gt;
  &lt;socket-binding name="modcluster" port="0" multicast-address="224.0.1.105" multicast-port="23364"/&gt;
&lt;/socket-binding-group&gt;</pre></div><p>From the preceding <a id="id246" class="indexterm"/>configuration, we can see that <code class="literal">224.0.1.1.105:23364</code> is the default multicast group address for advertising. This matches the settings on the httpd side.</p><p>These settings are of the <code class="literal">modcluster</code> subsystem in EAP6. As we have gone through the settings of mod_cluster from both sides, in the following section we will test the cluster.</p></div></div></div>
<div class="section" title="Testing the cluster"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Testing the cluster</h1></div></div></div><p>In this section<a id="id247" class="indexterm"/> we'll test our cluster, so we need to start our load balancer and EAP6 servers. Before we start httpd on <code class="literal">lb</code>, we need to start the two EAP6 servers. After the two EAP6 servers have been started, start httpd. In the following section, we'll examine the process of starting up httpd.</p><div class="section" title="Starting up httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Starting up httpd</h2></div></div></div><p>Now we <a id="id248" class="indexterm"/>need to start the httpd server. If everything goes fine, mod_cluster in httpd will begin to advertise itself in a multicast group, and the <code class="literal">modcluster</code> subsystem in the two EAP6 servers will be able to find mod_cluster in httpd by fetching its address in the advertising channel. We will investigate this process in the following sections; let's first start httpd. The command to start httpd on <code class="literal">lb</code> is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/packt/httpd/bin$ sudo ./httpd -f /packt/httpd/conf/httpd.conf -k start</strong></span>
</pre></div><p>After httpd has been started, mod_cluster will advertise itself to the multicast group 224.0.1.105:23364, and the <code class="literal">modcluster</code> subsystem on the two EAP6 servers will fetch the address of the management channel from the group, which is 10.0.1.32:6666. Then the load balancers and the two EAP6 worker nodes will form a cluster by communicating in the management channel with the MCPM protocol. This process is shown in the following diagram:</p><div class="mediaobject"><img src="graphics/2432OS_05_09.jpg" alt="Starting up httpd"/></div><p>To understand these steps, we need to analyze the packets sent across the network.</p></div><div class="section" title="The protocol analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>The protocol analysis</h2></div></div></div><p>We can <a id="id249" class="indexterm"/>use Wireshark to capture the IP datagrams from<a id="id250" class="indexterm"/> one of the worker nodes. In my example I'll run Wireshark on <code class="literal">master</code>. We can verify the advertising message sent by the load balancer on this machine.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>There is also a small Java program that allows us to join the multicast group and receive the httpd advertisement. See this program at <a class="ulink" href="https://github.com/mod_cluster/mod_cluster/blob/master/test/java/Advertize.java">https://github.com/mod_cluster/mod_cluster/blob/master/test/java/Advertize.java</a>.</p></div></div><div class="section" title="The advertising channel"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>The advertising channel</h3></div></div></div><p>I have started <a id="id251" class="indexterm"/>Wireshark on <code class="literal">master</code> to capture the IP datagrams. I set it to catch all the datagrams on 224.0.1.105:23364, and the following are my findings:</p><div class="mediaobject"><img src="graphics/2432OS_05_10.jpg" alt="The advertising channel"/></div><p>From the preceding screenshot, we can see that <code class="literal">master</code> is receiving the advertising messages periodically.<a id="id252" class="indexterm"/> From the <span class="strong"><strong>Time</strong></span> column, we can see that the advertising message is sent at 10-second intervals.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>You can change this by placing the <code class="literal">AdvertiseFrequency</code> directive into <code class="literal">conf.d/mod-cluster.conf</code>.</p></div></div><p>We can see that the advertising message is in HTTP format. The following are the details of the message:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 200 OK</strong></span>
<span class="strong"><strong>Date: Sat, 05 Oct 2013 16:50:49 GMT</strong></span>
<span class="strong"><strong>Sequence: 2387</strong></span>
<span class="strong"><strong>Server: 093651cf-0c7f-4fad-aae2-ea1c23c9c339</strong></span>
<span class="strong"><strong>X-Manager-Address: 10.0.1.32:6666</strong></span>
<span class="strong"><strong>X-Manager-Url: /093651cf-0c7f-4fad-aae2-ea1c23c9c339</strong></span>
<span class="strong"><strong>X-Manager-Protocol: http</strong></span>
<span class="strong"><strong>X-Manager-Host: cute</strong></span>
</pre></div><p>As shown in the<a id="id253" class="indexterm"/> previous code, the advertising message places the load balancer information in the HTTP headers. Among these headers, we should note the value of <code class="literal">X-Manager-Address</code>. It tells the worker nodes where to find the load balancer. The other headers provide additional information to the worker nodes; this information describes the load balancer.</p></div><div class="section" title="The management channel"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec17"/>The management channel</h3></div></div></div><p>After the <a id="id254" class="indexterm"/>worker node comes to know the management address of the load balancer, it will communicate with the load balancer and register itself on it. To see this process, we need to look into the httpd log. As we have set the <code class="literal">LogLevel</code> to <code class="literal">debug</code> in <code class="literal">httpd.conf</code>, we can get many useful details. mod_cluster has outputted a lot of useful log information in the debug level, so we can check <code class="literal">logs/error_log</code> to see the sequence clearly. Here is the log:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(1910): manager_trans INFO (/)</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2618): manager_handler INFO (/) processing: ""</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2667): manager_handler INFO  OK</strong></span>
</pre></div><p>
<code class="literal">INFO</code> is the first MCMP command we've seen till now. This is the command that the worker node uses to request more details of the load balancer. As mod_cluster forms the cluster dynamically, it doesn't know the details of the cluster in advance. The load balancer and worker node just discover each other in the multicast channel, so the worker node needs to know more detailed information about the load balancer. That's why the worker node will send the <code class="literal">INFO</code> request to the load balancer, and the load balancer will reply with an <code class="literal">INFO-RSP</code> response.</p><p>Now let's see the next step:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(1910): manager_trans CONFIG (/)</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2618): manager_handler CONFIG (/) processing: "JVMRoute=14a0af8b-59dd-33f9-8233-1f2584fefa67&amp;Host=10.0.1.19&amp;Maxattempts=1&amp;Port=8259&amp;StickySessionForce=No&amp;Type=ajp&amp;ping=10"</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2667): manager_handler CONFIG  OK</strong></span>
</pre></div><p>After the worker node gets the details of the load balancer, it will send to the load balancer a <code class="literal">CONFIG</code> message that tells the load balancer the previous worker node details. The <code class="literal">JVMRoute</code> is the worker node's name; this is automatically generated by the mod_cluster subsystem in EAP6. Now we know the server <code class="literal">14a0af8b-59dd-33f9-8233-1f2584fefa67</code> corresponds to the server <code class="literal">10.0.1.19</code>, which is our slave EAP6 server.</p><p>Let's check the next step:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(1910): manager_trans ENABLE-APP (/)</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2618): manager_handler ENABLE-APP (/) processing: "JVMRoute=14a0af8b-59dd-33f9-8233-1f2584fefa67&amp;Alias=default-host%2Clocalhost%2Cexample.com&amp;Context=%2Fcluster-demo1"</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2667): manager_handler ENABLE-APP  OK</strong></span>
</pre></div><p>The worker<a id="id255" class="indexterm"/> node sends <code class="literal">ENABLE-APP</code> to the load balancer. This is used by the worker node to ask the load balancer to route the request corresponding to the context and the <code class="literal">Alias</code> value to the node defined by <code class="literal">JVMRoute</code>. In addition, we see the enabled application is <code class="literal">cluster-demo1</code>. So if we access the load balancer URL with the route <code class="literal">/cluster-demo1</code>, the request will be forwarded to the EAP6 servers. Now let's see the next step:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(1910): manager_trans STATUS (/)</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2618): manager_handler STATUS (/) processing: "JVMRoute=14a0af8b-59dd-33f9-8233-1f2584fefa67&amp;Load=100"</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(1625): Processing STATUS</strong></span>
</pre></div><p>The worker node sends the <code class="literal">STATUS</code> message, which contains its current load factor. From line two of the previous log, we can see that the load factor of the slave EAP6 server is <code class="literal">100</code> (the smaller the factor number, the busier the server is). This message is sent periodically, and the load factor is refreshed to reflect the real-time status of the worker node. So the load balancer could know which server is busier and send this request to the worker nodes that have a lighter load.</p><p>With the previous process, the worker node and load balancer have gathered enough information about each other and established communication. Then the <code class="literal">mod_proxy_cluster.so</code> cluster will start to do the real proxy job. In the following section, we will check this part.</p></div></div><div class="section" title="The connector channel analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>The connector channel analysis</h2></div></div></div><p>In the <a id="id256" class="indexterm"/>previous section, we saw how the load balancer <a id="id257" class="indexterm"/>advertises itself and how the worker node discovers it and registers itself into the cluster. Now let's go on to check the <code class="literal">error_log</code> and see what's going on:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_proxy_cluster.c(655): add_balancer_node: Create balancer balancer://mycluster</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_proxy_cluster.c(426): Created: worker for ajp://10.0.1.19:8259</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] proxy_util.c(2018): proxy: ajp: has acquired connection for (10.0.1.19)</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] proxy_util.c(2074): proxy: connecting ajp://10.0.1.19:8259/ to 10.0.1.19:8259</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] proxy_util.c(2200): proxy: connected / to 10.0.1.19:8259</strong></span>
</pre></div><p>As per the<a id="id258" class="indexterm"/> preceding log, mod_cluster has established a<a id="id259" class="indexterm"/> connection with <code class="literal">ajp://10.0.1.19:8259</code>. This is the AJP connector of the EAP6 server on the slave host. We can see that mod_cluster has set a name for our cluster, which is <code class="literal">mycluster</code>. We can check the status of this cluster from the management console. Let's access the management console through its URL, <code class="literal">http://10.0.1.32/mc</code>.</p><p>This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_05_13.jpg" alt="The connector channel analysis"/></div><p>From the preceding screenshot, we can see that the two EAP6 servers form a cluster, and they all belong to <code class="literal">mycluster</code>. If you want to change the name of the balancer name, you can use the <code class="literal">ManagerBalancerName</code> directive in <code class="literal">mod-cluster.conf</code> <code class="literal">
</code>like this:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost 10.0.1.32:6666&gt;
  ...
  ServerAdvertise on http://10.0.1.32:6666
  EnableMCPMReceive
  ManagerBalancerName packtlb
&lt;/VirtualHost&gt;</pre></div><p>As per the<a id="id260" class="indexterm"/> previous configuration, the<a id="id261" class="indexterm"/> balancer name is set to <code class="literal">packtlb</code>. Now if we save the changes and restart httpd, we can see the balancer name change accordingly:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Node 14a0af8b-59dd-33f9-8233-1f2584fefa67 (ajp://10.0.1.19:8259):</strong></span>
<span class="strong"><strong>Balancer: packtlb, ...</strong></span>

<span class="strong"><strong>Node da1db862-4021-36f5-b3ad-b71b61b79c3b (ajp://10.0.1.13:8259):</strong></span>
<span class="strong"><strong>Balancer: packtlb, ...</strong></span>
</pre></div><p>This is useful when there are multiple load balancers running at the same time. With the balancer name, we can easily see which worker node belongs to which load balancer.</p><p>Now let's come back to the debug log; here is the last part we need to look at:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_proxy_cluster.c(1366): proxy_cluster_try_pingpong: connected to backend</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_proxy_cluster.c(1089): ajp_cping_cpong: Done</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] proxy_util.c(2036): proxy: ajp: has released connection for (10.0.1.19)</strong></span>
<span class="strong"><strong>[Sat Oct 05 18:09:15 2013] [debug] mod_manager.c(2667): manager_handler STATUS  OK</strong></span>
</pre></div><p>After the AJP channels are established, mod_cluster from the httpd side will send <code class="literal">ajp_cping_cpong</code> messages to the EAP6 worker nodes periodically to check whether the nodes are still alive.</p><p>As we have done the protocol analysis, in the following section we'll access the cluster to see if it works properly.</p></div><div class="section" title="Accessing the cluster"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Accessing the cluster</h2></div></div></div><p>We can <a id="id262" class="indexterm"/>access the load balancer using its URL: <code class="literal">http://lb/cluster-demo1/index.jsp</code>.</p><p>By checking the two EAP6 servers output, we can see that the request is dispatched to <code class="literal">master</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Server:master-server] 02:34:49,395 INFO  [stdout] (ajp-/10.0.1.13:8259-4) Hello! The time is now Mon Oct 07 02:34:49 CST 2013</strong></span>
</pre></div><p>Now when we <a id="id263" class="indexterm"/>check the mod_cluster management console, we can see that the master server has been elected once:</p><div class="mediaobject"><img src="graphics/2432OS_05_15.jpg" alt="Accessing the cluster"/></div><p>As we can see from the preceding screenshot, the <span class="strong"><strong>Elected</strong></span> count becomes <span class="strong"><strong>1</strong></span> for the master server.</p><div class="section" title="Failover"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec18"/>Failover</h3></div></div></div><p>Now <a id="id264" class="indexterm"/>let's kill the master server by pressing the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> keys:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>02:41:36,977 INFO  [org.jboss.as.process] (Shutdown thread) JBAS012015: All processes finished; exiting</strong></span>
</pre></div><p>From the slave server, we can see that it starts to throw the following exception because it cannot connect to the master server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Host Controller] 02:41:47,971 DEBUG [org.jboss.as.host.controller] (domain-connection-threads - 8) failed to reconnect to the remote host-controller: java.net.ConnectException: JBAS012144: Could not connect to remote://10.0.1.13:9999. The connection timed out</strong></span>
</pre></div><p>This is expected because we have killed the master server. But it can still function as a server. Now let's access the load balancer again; we can see that the following request is dispatched to the slave server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Server:slave-server] 02:44:45,285 INFO  [stdout] (ajp-/10.0.1.19:8259-2) Hello! The time is now Mon Oct 07 02:44:45 CST 2013</strong></span>
</pre></div><p>Now let's access the mod_cluster management console, and we can see that the master server is removed automatically. In addition, the <span class="strong"><strong>Elected</strong></span> count of the slave server becomes <span class="strong"><strong>1</strong></span>:</p><div class="mediaobject"><img src="graphics/2432OS_05_16.jpg" alt="Failover"/></div><p>Now let's <a id="id265" class="indexterm"/>restart the EAP6 server on the master server, and it will rejoin the cluster. From the httpd debug log output, we can confirm this as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Mon Oct 07 04:01:31 2013] [debug] proxy_util.c(2200): proxy: connected / to 10.0.1.13:8259</strong></span>
</pre></div><p>From the slave server output, we can see that it also restores the connection to the domain controller:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Host Controller] 04:01:05,379 INFO  [org.jboss.as.host.controller] (domain-connection-threads - 1) JBAS010916: Reconnected to master</strong></span>
</pre></div></div><div class="section" title="Stress testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Stress testing</h3></div></div></div><p>Now let's try<a id="id266" class="indexterm"/> to use the Apache HTTP server benchmarking tool (called <span class="strong"><strong>ab</strong></span>) to load test our cluster. Here is the command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ab -c 15 -n 1500 http://lb/cluster-demo1/index.jsp</strong></span>
</pre></div><p>We've used <code class="literal">15</code> threads to request our cluster <code class="literal">1500</code> times. Here are the results:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Benchmarking cute (be patient)</strong></span>
<span class="strong"><strong>Completed 150 requests</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Finished 1500 requests</strong></span>
</pre></div><p>You can see that ab created some load on mod_cluster. Here are the statuses of the two worker nodes during testing:</p><div class="mediaobject"><img src="graphics/2432OS_05_17.jpg" alt="Stress testing"/></div><p>The preceding<a id="id267" class="indexterm"/> screenshot depicts the status of the master server, and the status of the slave server is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_05_18.jpg" alt="Stress testing"/></div><p>We can see that both the worker nodes are elected (the elected counts are more than 1,500 because I've run the preceding tests many times). We can also see that the <span class="strong"><strong>Load</strong></span> factor on slave became <span class="strong"><strong>99</strong></span>. This means the slave server is busier than the master server, so the load balancer will dispatch more requests to the master server later.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, we have looked at the design of mod_cluster and its usages. This chapter is just an introductory text to mod_cluster. If you want to check the more advanced usage, please refer to its constantly improving online document: <a class="ulink" href="http://docs.jboss.org/mod_cluster/1.2.0/html_single/">http://docs.jboss.org/mod_cluster/1.2.0/html_single/</a>.</p><p>If you have any questions about using mod_cluster, you can always ask questions on the JBoss forum: <a class="ulink" href="https://community.jboss.org/en/mod_cluster/content">https://community.jboss.org/en/mod_cluster/content</a>.</p><p>In the next chapter, we'll see how to apply <span class="strong"><strong>Secure Sockets Layer</strong></span> (<span class="strong"><strong>SSL</strong></span>) in a clustering environment.</p></div></body></html>