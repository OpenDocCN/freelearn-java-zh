- en: Chapter 2. Namespaces, Packages, and Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a working installation of Clojure and IntelliJ.
  prefs: []
  type: TYPE_NORMAL
- en: As a Java developer, you are used to working with classes as the minimal unit
    of organization. Clojure has a very different sense and gives you different tools
    to organize your code.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, you should keep in mind that code and data are separate; you don't
    have a minimal unit with attributes and functions that work over those attributes.
    Your functions can work on any data structure that you wish, as long as you follow
    the rules of how the function works.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start writing some simple functions to illustrate how
    separation of functions and data works and we will have a look at the tools Clojure
    gives us to make the separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topic:'
  prefs: []
  type: TYPE_NORMAL
- en: How namespaces work compared to the classpath and Java packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More Clojure examples and syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure namespaces might be familiar to you, as a Java developer, and for a
    very good reason, they have a very deep relationship with Java's packages and
    the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's review what we already know from Java.
  prefs: []
  type: TYPE_NORMAL
- en: Packages in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java code is organized in packages, a package in Java is a namespace that
    allows you to group a set of similar classes and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a package as something very similar to a folder in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some common packages that you use a lot when programming
    in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang`: Everything that''s native to Java, including basic types (integer,
    long, byte, boolean, character, string, number, short, float, void, and class),
    the basic threading primitives (runnable, thread), the basic primitives for exceptions
    (throwable, error, exception), the basic exceptions and errors (`NoSuchMethodError`,
    `OutOfMemoryError`, `StackOverflowError`, and so on) and runtime access classes
    like runtime and system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io`: This package includes the primitives for input and output, such
    as console, file, readers, input streams, and writers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util`: This is one of the most heavily used packages besides `java.lang`.
    This includes the classic data structures (map, set, list) along with the most
    common implementations of such data structures. This package also includes utilities
    like properties tools, scanner for reading from various input resources, `ServiceLoader`
    to load custom services from the `classloader`, UUID generator, timers, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.logging`: The logging utilities, you normally use them to give you
    different levels of alert, from a debug to serious conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.text`: These are utilities to manage text, dates, and numbers in a language
    independent way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.servlet`: This includes the primitives to create web apps and deployment
    in standard web containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of these packages groups several related functionalities, the `java.lang`
    package is particularly important, since it has every Java core type, such as
    string, long, and integer. Everything inside the `java.lang` package is available
    automatically everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.lang` package provides a bit more than just code organization, it
    also provides access security. If you remember about Java, there are three security
    access levels:'
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of packages, we are concerned with the protected level of access.
    The classes in the same package allow every other class in the same package to
    access its protected attributes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: There are also ways to analyze a package in runtime but they are involved and
    allow for very little to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Packages are implemented at the top of Java's classpath and the classloader.
  prefs: []
  type: TYPE_NORMAL
- en: The classpath and the classloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java was designed to be modular and for that it needs some way to load your
    code easily. The answer to this was the classloader, the classloader allows you
    to read resources from every entry of the classpath; you can look at resources
    in the classpath as a hierarchical structure similar to the file system.
  prefs: []
  type: TYPE_NORMAL
- en: The classloader is just a list of entries; each entry can be a directory in
    the filesystem or a JAR file. At this point, you should also know that JAR files
    are just zip files.
  prefs: []
  type: TYPE_NORMAL
- en: The classloader will treat each entry as a directory (JAR files are just zipped
    directories) and it will look for files in each directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of concepts here to remember, let''s try to summarize them:'
  prefs: []
  type: TYPE_NORMAL
- en: JAR files are ZIP files; they might contain several classes, properties, files,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classpath is a list of entries; each entry is a JAR file or a system directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classloader looks for resources in each entry of the classpath, so you can
    think of classpath resources as a combination of all the directories in the classpath
    (repeated resources are not overwritten)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are not already familiar with how classloaders look for resources in
    classpath entries, this is the general process; let''s imagine that you want to
    load a class: `test.Test`, what happens next?'
  prefs: []
  type: TYPE_NORMAL
- en: You tell the JVM that you want to load `test.Test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM knows to look for the `test`/`Test.class` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It starts looking for it in each entry of the classpath.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the resource is a ZIP file, it "unzips" the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It looks for the resource in the directory which represents the entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you were to see the default classpath resources, you will probably see something,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that each entry in the classpath doesn't just store
    class files, it can actually store any type of resource, It is a commonplace to
    store configuration files, such as `.properties` or `.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing forbids you from storing anything else in the classpath resources, such
    as images, mp3 or even code! You can read and access anything from the classpath's
    resource like you can from the filesystem at runtime. The one thing that you can't
    do is modify the classpath's resource contents (at least not without some esoteric
    magic).
  prefs: []
  type: TYPE_NORMAL
- en: Back to Clojure namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have had our little review of how packages and the classpaths work
    in Java, it''s time to go back to Clojure. You should understand that Clojure
    attempts to make the hosting platform transparent; this means a couple of very
    important things:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything that you can do with the classpath from Java, you can also do with
    Clojure (you can read configuration files, images, etc).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces use the classpath just as Java does with packages, which makes them
    easy to understand. Nevertheless, don't underestimate them, Clojure namespace
    declarations can be more involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get practical and play a little with namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lets create a new Playground, in order to create it use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can open this project with IntelliJ, as we did in [Chapter 1](part0014_split_000.html#DB7S1-f3eee9b8c89a4c399520b72f8d890ddc
    "Chapter 1. Getting Started with Clojure"), *Getting Started with Clojure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look in detail at what was created for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with namespaces](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This project structure looks similar to Java projects, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources`: These are the non-source files that get added to the classpath'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: Our source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: Our testing code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code inside `src` and `test` is already structured into namespaces: by
    having a quick look, we could say that the name of the namespace is `ns_playground`.
    Let''s check the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`:gen-class` was added here in order to create a Java class and allow the Java
    interpreter to start a static main method. It is not needed if you don''t intend
    to create a standalone program.'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the (`ns ns-playground.core`) form has been used at the top,
    as you might have guessed, this is how we declare a namespace in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: If you are observant, you will notice something odd; the namespace has a dash
    instead of an underscore like the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some reasons that lead to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Clojure like most lisp variable names can have dashes in it (it is actually
    the preferred style to name the variables, as opposed to camel case in Java).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every namespace in Clojure is represented as a package containing several Java
    classes. The namespace is used as a name of the Java package and as you know,
    the dash is not acceptable in class or package names; so every filename and folder
    name must have low dashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the nature of Lisp, you can use dashes in variable names (they will get
    converted to underscores at compile time). In fact, this is the recommended way
    to name your variables. In Clojure, (and most Lisps) `some-variable-name` is a
    more idiomatic style than `someVariableName`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new namespace; in Cursive Clojure it is easy to do so, just right-click
    on the `ns_playground` package and go to **New** | **Clojure Namespace**, it asks
    for a name and we can call it `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a `hello.clj` file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, namespace creation is quite easy; you can do it by hand with
    two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file; it doesn't have to follow the package naming specification,
    but it helps to maintain your code order and it is a de facto practice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your namespace declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! It is true, even though a namespace definition can become quite complex,
    as it is the place where you define the Java packages that you wish to import,
    namespaces or functions from those namespaces that you intend to use. But you
    will normally just use a subset of those capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that a namespace in Clojure is normally represented by a single
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your initial namespaces, I will advice you to have two of those capabilities
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `:import` | Allows you to import the Java classes from a package that you
    wish to use |'
  prefs: []
  type: TYPE_TB
- en: '| `:require` | Allows you to bring in whatever Clojure namespace that you wish
    to use |'
  prefs: []
  type: TYPE_TB
- en: The syntax of both `require` and the `import` is simple, let's look at a couple
    of examples before we actually use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `import` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that this is similar to what you can do in Java, we are importing
    the `List` interface here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing with Clojure is that it allows you to do some more specific
    things. Let''s check how to import two classes at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can extend this to the number of classes you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `require` option uses a similar syntax and then builds some more on it.
    Let''s check requiring a single function from a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is familiar and the interesting part is when you start importing
    everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a custom name for everything inside your package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could even combine different keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try a bit of what we just learned, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You must have noticed the `&` operator in the arguments of the `<3` and `sum-something`
    functions; this allows those functions to receive any number of arguments and
    we can call them, as shown: (`sum-something 1 2 3 4 5 6 7 8`) or (`sum-something`)
    They are called **variadic** functions. In Java you will call this feature **varargs**.'
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks great, but we haven't yet seen how to require and use these
    functions from some other package. Let's write a test to see how this will be
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Working with namespaces on the REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great way of playing with namespaces is by using the REPL and we'll also get
    the benefit of getting to know it better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to play with namespace, we need to know of a few functions
    that will help us move between namespaces and require other namespaces. The functions
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description | Sample usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `in-ns` | Sets `*ns*` to the namespace named by the symbol, creating it if
    needed. | (`in-ns ''ns-playground.core`) |'
  prefs: []
  type: TYPE_TB
- en: '| `require` | Loads `libs`, skipping any that are already loaded. | (`require
    ''[clojure.java.io :as io]`) |'
  prefs: []
  type: TYPE_TB
- en: '| `import` | For each name in `class-name-symbols`, adds a mapping from name
    to the class named by `package.name` to the current namespace. | (`import java.util.Date`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `refer` | refers to all public `vars` of `ns`, subject to filters. | (`refer
    ''clojure.string :only ''[capitalize trim]`) |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s go into the REPL window of our IntelliJ. We can check what namespace
    we are in with the `*ns*` instruction. Let''s try now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we need to execute a code and test the code from within the `ns-playground.hello`
    namespace, we can do that with the `in-ns` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to know what `str` does, it seems to receive three strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the `for` form now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `for` macro takes a collection of items and returns a new lazy sequence
    applying the body of the `for` to each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, understanding the `<3` function is easy, let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've used the REPL to test some simple functions, but let's now try to test
    something else like reading a properties file from the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a `test.properties` file to the resources folder with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember to restart the REPL, as the changes to the contents that some piece
    of the classpath points to are not visible to a running REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try reading our properties file as an input stream, we can use the `clojure.java.io`
    namespace to do it, and we can check it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define our function for reading properties, we can input this into
    the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `let` form lets us create local 'variables', instead of using the (`io/resource
    path`) directly in the code. We can create a reference once and use it through
    the code. It allows us to use simpler code and to have a single reference to an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we can redefine the `hello` namespace to include everything we''ve
    checked, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remember to include the `Properties` class in the `import` and to define the
    `:require` keyword for `clojure.java.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure already comes with a unit testing support built-in, as a matter of fact
    Leiningen has already created a test for us; let's take a look at it right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `test/ns_playground/core_test.clj` file, you should be able to see
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, as you can see, we are using `:require` to include functions from the
    `clojure.test` and the `ns-playground.core` packages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the `:refer :all` works similar to how `char import static clojure.test.*`
    will work in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Testing from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first learn how to run these tests. From the command line, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We see that there is one test failing, we will go back to this in a bit; for
    now, let's see how to test in IntelliJ.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in IntelliJ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need a new REPL configuration. You can do it as you learned
    in the previous chapter. You just need to follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right click on the `project.clj` file and select **Create REPL for ns-playground,**
    as shown in the following screenshot:![Testing in IntelliJ](img/00006.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click on **OK** in the next dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, you should run the REPL again by right clicking the `project.clj`
    file and selecting **Run REPL for ns-playground**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that you can run any tests, just open your test file and go to **Tools**
    | **Run Tests** in the current NS in REPL. You should see something similar to
    the following screenshot:![Testing in IntelliJ](img/00007.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, it signals that your test is currently failing. Let's fix it
    and run our test again. Change the `(is (= 0 1))` line to `(is (= 1 1))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s try some real tests for our previously defined functions; don''t
    worry if you can''t understand all the code for now, you are not supposed to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can't use the Clojure contents function here because it has a different function.
    It looks for keys in a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests and you''ll see that everything passes correctly but there''s
    a lot going on over here, let''s go over it little by little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the namespace declaration, let''s list everything it does:'
  prefs: []
  type: TYPE_NORMAL
- en: It declares the `ns-playground.core-test` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It imports the `java.util.Date` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes everything in the `clojure.test` namespace available in the current
    namespace, if we were in Java we might have used `import static clojure.test.*`
    to get a similar effect. We can achieve this with the `:refer :all` keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes everything in the `ns-playground.hello` namespace available with the
    hello shortcut but we need to prefix every function or value defined in `ns-playground.hello`
    with hello and it also makes the `<3` function available without a prefix. To
    generate an alias and make everything available with the `hello` alias, we use
    the `:as` keyword and then pass a vector to `:refer` to include certain elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes everything in the `ns-playground.core` namespace available in the current
    namespace. We achieve this with the `:refer :all` keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the declaration of a function called `lazy-contains?`, it is a `boolean`
    function and it is customary in Clojure to call it a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of the function including the question mark might be something that
    looks awkward to you. In Clojure and Lisp, you can use question marks in the names
    of functions and it is common to do it for functions that return Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: 'It receives two parameters: `col` and `element`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual body of the function looks a bit complicated but it is actually
    very simple. Whenever you encounter a function that looks similar to the one mentioned
    in the preceding section, try to read it from the inside out. The innermost part
    is, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a shorter way of writing an anonymous function which has a single parameter.
    If we want to write another function that compares its argument against the `element`,
    without the syntactic sugar, we can do it in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is an anonymous function or in other words it is a function that has no
    name, but it works as every other function; we will read more about anonymous
    functions when we get back to functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our anonymous function is a parameter to the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This new form filters the collection `col` and returns a new collection with
    only the elements that pass the test. Let''s see an example where we have used
    the predefined Clojure function `even?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our filter function now returns every element in the collection that passes
    the `#(= element %)`test. So we get every element that is equal to the element
    passed to `lazy-contains?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then ask if none of the elements equal to `element` in `col` with the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'But we want to know if there is some element equal to element, so at last we
    negate the previous form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that if you had to write this in Java (and I asked to add every element
    that matches the element to a list), you will have something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There is a big difference, it is more verbose and to understand it we need to
    "run" the algorithm in our heads. This is called imperative programming, Clojure
    allows us to do imperative programming as well as functional programming, which
    is a type of declarative programming. When you get used to it, you'll see that
    it's easier to reason about than loops.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interactive programming means, telling every step of how something should be
    done to a computer. Declarative programming just asks for a result and doesn't
    give details of how to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual tests are simple to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This test checks the current date returns an instance of `java.util.Date`,
    the `is` form works as the Java assert instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This test checks the `<3` function, it checks that the returned collection contains
    `I love Clojure`, `I love doggies`, `I love chocolate` and `I love you` and it
    should not contain `I love Vogons`.
  prefs: []
  type: TYPE_NORMAL
- en: This test is simple to understand. What might be not so simple to understand
    is the `<3` function, we'll look into it with the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we got to know some utilities that we can use for better management
    of our code and we have some more examples of everyday Clojure code. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Working of namespace in Clojure and their relation to Java packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing out-of-the-box unit tests and executing them with Leiningen and Cursive
    Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into the Clojure Interactive development workflow and a bit of the Clojure
    mindset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing very simple functions and testing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Java interop, so we can start using
    the familiar classes and libraries we already know in our Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to use Clojure from Java, so you can start using it in
    your everyday Java projects.
  prefs: []
  type: TYPE_NORMAL
