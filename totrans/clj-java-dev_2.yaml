- en: Chapter 2. Namespaces, Packages, and Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a working installation of Clojure and IntelliJ.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: As a Java developer, you are used to working with classes as the minimal unit
    of organization. Clojure has a very different sense and gives you different tools
    to organize your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: For starters, you should keep in mind that code and data are separate; you don't
    have a minimal unit with attributes and functions that work over those attributes.
    Your functions can work on any data structure that you wish, as long as you follow
    the rules of how the function works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start writing some simple functions to illustrate how
    separation of functions and data works and we will have a look at the tools Clojure
    gives us to make the separation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topic:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: How namespaces work compared to the classpath and Java packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More Clojure examples and syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces in Clojure
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure namespaces might be familiar to you, as a Java developer, and for a
    very good reason, they have a very deep relationship with Java's packages and
    the classpath.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's review what we already know from Java.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Packages in Clojure
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java code is organized in packages, a package in Java is a namespace that
    allows you to group a set of similar classes and interfaces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a package as something very similar to a folder in your computer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some common packages that you use a lot when programming
    in Java:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang`: Everything that''s native to Java, including basic types (integer,
    long, byte, boolean, character, string, number, short, float, void, and class),
    the basic threading primitives (runnable, thread), the basic primitives for exceptions
    (throwable, error, exception), the basic exceptions and errors (`NoSuchMethodError`,
    `OutOfMemoryError`, `StackOverflowError`, and so on) and runtime access classes
    like runtime and system.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io`: This package includes the primitives for input and output, such
    as console, file, readers, input streams, and writers.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util`: This is one of the most heavily used packages besides `java.lang`.
    This includes the classic data structures (map, set, list) along with the most
    common implementations of such data structures. This package also includes utilities
    like properties tools, scanner for reading from various input resources, `ServiceLoader`
    to load custom services from the `classloader`, UUID generator, timers, and so
    on.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.logging`: The logging utilities, you normally use them to give you
    different levels of alert, from a debug to serious conditions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.text`: These are utilities to manage text, dates, and numbers in a language
    independent way.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.servlet`: This includes the primitives to create web apps and deployment
    in standard web containers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of these packages groups several related functionalities, the `java.lang`
    package is particularly important, since it has every Java core type, such as
    string, long, and integer. Everything inside the `java.lang` package is available
    automatically everywhere.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包中的每一个都包含几个相关的功能，特别是`java.lang`包尤为重要，因为它包含了所有的Java核心类型，如字符串、长整型和整型。`java.lang`包中的所有内容都可以在所有地方自动使用。
- en: 'The `java.lang` package provides a bit more than just code organization, it
    also provides access security. If you remember about Java, there are three security
    access levels:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang`包不仅提供了代码组织，还提供了访问安全。如果你还记得Java，有三个安全访问级别：'
- en: private
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有
- en: public
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共
- en: protected
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护
- en: In the case of packages, we are concerned with the protected level of access.
    The classes in the same package allow every other class in the same package to
    access its protected attributes and methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在包的情况下，我们关注的是受保护的访问级别。同一包中的类允许同一包中的其他类访问其受保护的属性和方法。
- en: There are also ways to analyze a package in runtime but they are involved and
    allow for very little to be done.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时分析包也有方法，但它们很复杂，并且允许做的很少。
- en: Packages are implemented at the top of Java's classpath and the classloader.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 包是在Java的类路径和类加载器顶部实现的。
- en: The classpath and the classloader
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类路径和类加载器
- en: Java was designed to be modular and for that it needs some way to load your
    code easily. The answer to this was the classloader, the classloader allows you
    to read resources from every entry of the classpath; you can look at resources
    in the classpath as a hierarchical structure similar to the file system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java被设计成模块化的，为此它需要一种轻松加载你的代码的方法。这个答案就是类加载器，类加载器允许你从类路径的每个条目中读取资源；你可以将类路径资源视为类似于文件系统的一个分层结构。
- en: The classloader is just a list of entries; each entry can be a directory in
    the filesystem or a JAR file. At this point, you should also know that JAR files
    are just zip files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器只是一个条目列表；每个条目可以是文件系统中的一个目录或一个JAR文件。此时，你应该也知道JAR文件只是ZIP文件。
- en: The classloader will treat each entry as a directory (JAR files are just zipped
    directories) and it will look for files in each directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器会将每个条目视为一个目录（JAR文件只是压缩的目录），并且它会在每个目录中查找文件。
- en: 'There are a lot of concepts here to remember, let''s try to summarize them:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多概念需要记住，让我们尝试总结一下：
- en: JAR files are ZIP files; they might contain several classes, properties, files,
    and so on.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR文件是ZIP文件；它们可能包含多个类、属性、文件等。
- en: The classpath is a list of entries; each entry is a JAR file or a system directory.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径是一个条目列表；每个条目是一个JAR文件或系统目录。
- en: The classloader looks for resources in each entry of the classpath, so you can
    think of classpath resources as a combination of all the directories in the classpath
    (repeated resources are not overwritten)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器会在类路径的每个条目中查找资源，所以你可以将类路径资源视为类路径中所有目录的组合（重复的资源不会被覆盖）
- en: 'If you are not already familiar with how classloaders look for resources in
    classpath entries, this is the general process; let''s imagine that you want to
    load a class: `test.Test`, what happens next?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉类加载器如何在类路径条目中查找资源，这是一个通用过程；让我们想象一下，你想加载一个类：`test.Test`，接下来会发生什么？
- en: You tell the JVM that you want to load `test.Test`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你告诉JVM你想加载`test.Test`。
- en: The JVM knows to look for the `test`/`Test.class` file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM知道要查找`test`/`Test.class`文件。
- en: It starts looking for it in each entry of the classpath.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从类路径的每个条目开始查找。
- en: If the resource is a ZIP file, it "unzips" the directory.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源是一个ZIP文件，它“解压”目录。
- en: It looks for the resource in the directory which represents the entry.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会在表示条目的目录中查找资源。
- en: 'If you were to see the default classpath resources, you will probably see something,
    such as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到默认的类路径资源，你可能会看到一些东西，例如：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is important to note that each entry in the classpath doesn't just store
    class files, it can actually store any type of resource, It is a commonplace to
    store configuration files, such as `.properties` or `.xml`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，类路径中的每个条目不仅仅存储类文件，实际上可以存储任何类型的资源，存储配置文件，如`.properties`或`.xml`是很常见的。
- en: Nothing forbids you from storing anything else in the classpath resources, such
    as images, mp3 or even code! You can read and access anything from the classpath's
    resource like you can from the filesystem at runtime. The one thing that you can't
    do is modify the classpath's resource contents (at least not without some esoteric
    magic).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Back to Clojure namespaces
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have had our little review of how packages and the classpaths work
    in Java, it''s time to go back to Clojure. You should understand that Clojure
    attempts to make the hosting platform transparent; this means a couple of very
    important things:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Anything that you can do with the classpath from Java, you can also do with
    Clojure (you can read configuration files, images, etc).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces use the classpath just as Java does with packages, which makes them
    easy to understand. Nevertheless, don't underestimate them, Clojure namespace
    declarations can be more involved.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get practical and play a little with namespaces.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Playing with namespaces
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lets create a new Playground, in order to create it use the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can open this project with IntelliJ, as we did in [Chapter 1](part0014_split_000.html#DB7S1-f3eee9b8c89a4c399520b72f8d890ddc
    "Chapter 1. Getting Started with Clojure"), *Getting Started with Clojure*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look in detail at what was created for us:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with namespaces](img/00005.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'This project structure looks similar to Java projects, we have:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '`resources`: These are the non-source files that get added to the classpath'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: Our source code'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: Our testing code'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code inside `src` and `test` is already structured into namespaces: by
    having a quick look, we could say that the name of the namespace is `ns_playground`.
    Let''s check the source code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`:gen-class` was added here in order to create a Java class and allow the Java
    interpreter to start a static main method. It is not needed if you don''t intend
    to create a standalone program.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the (`ns ns-playground.core`) form has been used at the top,
    as you might have guessed, this is how we declare a namespace in Clojure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: If you are observant, you will notice something odd; the namespace has a dash
    instead of an underscore like the folder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some reasons that lead to this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Clojure like most lisp variable names can have dashes in it (it is actually
    the preferred style to name the variables, as opposed to camel case in Java).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every namespace in Clojure is represented as a package containing several Java
    classes. The namespace is used as a name of the Java package and as you know,
    the dash is not acceptable in class or package names; so every filename and folder
    name must have low dashes.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the nature of Lisp, you can use dashes in variable names (they will get
    converted to underscores at compile time). In fact, this is the recommended way
    to name your variables. In Clojure, (and most Lisps) `some-variable-name` is a
    more idiomatic style than `someVariableName`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new namespace
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new namespace; in Cursive Clojure it is easy to do so, just right-click
    on the `ns_playground` package and go to **New** | **Clojure Namespace**, it asks
    for a name and we can call it `hello`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a `hello.clj` file with the following contents:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, namespace creation is quite easy; you can do it by hand with
    two simple steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file; it doesn't have to follow the package naming specification,
    but it helps to maintain your code order and it is a de facto practice.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your namespace declaration.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! It is true, even though a namespace definition can become quite complex,
    as it is the place where you define the Java packages that you wish to import,
    namespaces or functions from those namespaces that you intend to use. But you
    will normally just use a subset of those capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that a namespace in Clojure is normally represented by a single
    file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'For your initial namespaces, I will advice you to have two of those capabilities
    in mind:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '| `:import` | Allows you to import the Java classes from a package that you
    wish to use |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `:require` | Allows you to bring in whatever Clojure namespace that you wish
    to use |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: The syntax of both `require` and the `import` is simple, let's look at a couple
    of examples before we actually use it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `import` option:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You'll notice that this is similar to what you can do in Java, we are importing
    the `List` interface here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing with Clojure is that it allows you to do some more specific
    things. Let''s check how to import two classes at once:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can extend this to the number of classes you want to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The `require` option uses a similar syntax and then builds some more on it.
    Let''s check requiring a single function from a namespace:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, it is familiar and the interesting part is when you start importing
    everything:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use a custom name for everything inside your package:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or you could even combine different keywords:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s try a bit of what we just learned, using the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You must have noticed the `&` operator in the arguments of the `<3` and `sum-something`
    functions; this allows those functions to receive any number of arguments and
    we can call them, as shown: (`sum-something 1 2 3 4 5 6 7 8`) or (`sum-something`)
    They are called **variadic** functions. In Java you will call this feature **varargs**.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks great, but we haven't yet seen how to require and use these
    functions from some other package. Let's write a test to see how this will be
    done.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Working with namespaces on the REPL
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great way of playing with namespaces is by using the REPL and we'll also get
    the benefit of getting to know it better.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to play with namespace, we need to know of a few functions
    that will help us move between namespaces and require other namespaces. The functions
    are listed as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description | Sample usage |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `in-ns` | Sets `*ns*` to the namespace named by the symbol, creating it if
    needed. | (`in-ns ''ns-playground.core`) |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `require` | Loads `libs`, skipping any that are already loaded. | (`require
    ''[clojure.java.io :as io]`) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `import` | For each name in `class-name-symbols`, adds a mapping from name
    to the class named by `package.name` to the current namespace. | (`import java.util.Date`)
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `refer` | refers to all public `vars` of `ns`, subject to filters. | (`refer
    ''clojure.string :only ''[capitalize trim]`) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: 'Let''s go into the REPL window of our IntelliJ. We can check what namespace
    we are in with the `*ns*` instruction. Let''s try now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Imagine that we need to execute a code and test the code from within the `ns-playground.hello`
    namespace, we can do that with the `in-ns` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We want to know what `str` does, it seems to receive three strings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s try the `for` form now:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `for` macro takes a collection of items and returns a new lazy sequence
    applying the body of the `for` to each element.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, understanding the `<3` function is easy, let''s try it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've used the REPL to test some simple functions, but let's now try to test
    something else like reading a properties file from the classpath.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a `test.properties` file to the resources folder with the following
    contents:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember to restart the REPL, as the changes to the contents that some piece
    of the classpath points to are not visible to a running REPL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try reading our properties file as an input stream, we can use the `clojure.java.io`
    namespace to do it, and we can check it as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now define our function for reading properties, we can input this into
    the REPL:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `let` form lets us create local 'variables', instead of using the (`io/resource
    path`) directly in the code. We can create a reference once and use it through
    the code. It allows us to use simpler code and to have a single reference to an
    object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we can redefine the `hello` namespace to include everything we''ve
    checked, such as this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember to include the `Properties` class in the `import` and to define the
    `:require` keyword for `clojure.java.io`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Clojure
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure already comes with a unit testing support built-in, as a matter of fact
    Leiningen has already created a test for us; let's take a look at it right now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `test/ns_playground/core_test.clj` file, you should be able to see
    this code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, as you can see, we are using `:require` to include functions from the
    `clojure.test` and the `ns-playground.core` packages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the `:refer :all` works similar to how `char import static clojure.test.*`
    will work in Java.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Testing from the command line
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first learn how to run these tests. From the command line, you can run:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We see that there is one test failing, we will go back to this in a bit; for
    now, let's see how to test in IntelliJ.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Testing in IntelliJ
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need a new REPL configuration. You can do it as you learned
    in the previous chapter. You just need to follow the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的REPL配置。你可以像上一章中学到的那样做。你只需要遵循以下步骤：
- en: Right click on the `project.clj` file and select **Create REPL for ns-playground,**
    as shown in the following screenshot:![Testing in IntelliJ](img/00006.jpeg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`project.clj`文件，并选择**为ns-playground创建REPL**，如图所示：![在IntelliJ中进行测试](img/00006.jpeg)
- en: Then click on **OK** in the next dialog.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在下一个对话框中点击**确定**。
- en: After that, you should run the REPL again by right clicking the `project.clj`
    file and selecting **Run REPL for ns-playground**.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你应该通过右键点击`project.clj`文件并选择**运行ns-playground的REPL**来再次运行REPL。
- en: After that you can run any tests, just open your test file and go to **Tools**
    | **Run Tests** in the current NS in REPL. You should see something similar to
    the following screenshot:![Testing in IntelliJ](img/00007.jpeg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后你可以运行任何测试，只需打开你的测试文件，并在REPL中的当前NS中转到**工具** | **运行测试**。你应该会看到以下类似的截图：![在IntelliJ中进行测试](img/00007.jpeg)
- en: As you can see, it signals that your test is currently failing. Let's fix it
    and run our test again. Change the `(is (= 0 1))` line to `(is (= 1 1))`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，它表明你的测试目前正在失败。让我们修复它并再次运行我们的测试。将`(is (= 0 1))`行更改为`(is (= 1 1))`。
- en: 'Now, let''s try some real tests for our previously defined functions; don''t
    worry if you can''t understand all the code for now, you are not supposed to:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试对我们之前定义的函数进行一些实际的测试；如果你现在不能理解所有的代码，不要担心，你不需要这样做：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can't use the Clojure contents function here because it has a different function.
    It looks for keys in a map.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里使用Clojure的内容函数，因为它有一个不同的函数。它会在映射中查找键。
- en: 'Run the tests and you''ll see that everything passes correctly but there''s
    a lot going on over here, let''s go over it little by little:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，你会看到所有内容都正确通过，但这里发生了很多事情，让我们一点一点地来看：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is the namespace declaration, let''s list everything it does:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命名空间声明，让我们列出它所做的一切：
- en: It declares the `ns-playground.core-test` package.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它声明了`ns-playground.core-test`包。
- en: It imports the `java.util.Date` class.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导入了`java.util.Date`类。
- en: It makes everything in the `clojure.test` namespace available in the current
    namespace, if we were in Java we might have used `import static clojure.test.*`
    to get a similar effect. We can achieve this with the `:refer :all` keywords.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得`clojure.test`命名空间中的所有内容在当前命名空间中可用，如果我们处于Java中，我们可能会使用`import static clojure.test.*`来获得类似的效果。我们可以通过使用`:refer
    :all`关键字来实现这一点。
- en: It makes everything in the `ns-playground.hello` namespace available with the
    hello shortcut but we need to prefix every function or value defined in `ns-playground.hello`
    with hello and it also makes the `<3` function available without a prefix. To
    generate an alias and make everything available with the `hello` alias, we use
    the `:as` keyword and then pass a vector to `:refer` to include certain elements.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得`ns-playground.hello`命名空间中的所有内容都可以通过hello快捷键访问，但我们需要在`ns-playground.hello`中定义的每个函数或值前加上hello前缀，并且它还使得`<3`函数可以无前缀访问。为了生成别名并使所有内容都可以通过`hello`别名访问，我们使用`:as`关键字，然后传递一个向量给`:refer`以包含某些元素。
- en: It makes everything in the `ns-playground.core` namespace available in the current
    namespace. We achieve this with the `:refer :all` keywords.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得`ns-playground.core`命名空间中的所有内容在当前命名空间中可用。我们通过使用`:refer :all`关键字来实现这一点。
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the declaration of a function called `lazy-contains?`, it is a `boolean`
    function and it is customary in Clojure to call it a predicate.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是名为`lazy-contains?`的函数的声明，它是一个`boolean`函数，在Clojure中通常将其称为谓词。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the function including the question mark might be something that
    looks awkward to you. In Clojure and Lisp, you can use question marks in the names
    of functions and it is common to do it for functions that return Booleans.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 包含问号的函数名称可能对你来说看起来有些不自然。在Clojure和Lisp中，你可以在函数名称中使用问号，并且对于返回布尔值的函数来说，这样做是很常见的。
- en: 'It receives two parameters: `col` and `element`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收两个参数：`col`和`element`。
- en: 'The actual body of the function looks a bit complicated but it is actually
    very simple. Whenever you encounter a function that looks similar to the one mentioned
    in the preceding section, try to read it from the inside out. The innermost part
    is, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的实际主体看起来有点复杂，但实际上非常简单。每次你遇到一个看起来与上一节中提到的函数相似时，试着从内向外阅读。最内层部分如下：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is a shorter way of writing an anonymous function which has a single parameter.
    If we want to write another function that compares its argument against the `element`,
    without the syntactic sugar, we can do it in the following method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is an anonymous function or in other words it is a function that has no
    name, but it works as every other function; we will read more about anonymous
    functions when we get back to functional programming.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Our anonymous function is a parameter to the following form:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This new form filters the collection `col` and returns a new collection with
    only the elements that pass the test. Let''s see an example where we have used
    the predefined Clojure function `even?`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our filter function now returns every element in the collection that passes
    the `#(= element %)`test. So we get every element that is equal to the element
    passed to `lazy-contains?`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'We then ask if none of the elements equal to `element` in `col` with the following
    form:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But we want to know if there is some element equal to element, so at last we
    negate the previous form:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Imagine that if you had to write this in Java (and I asked to add every element
    that matches the element to a list), you will have something similar to this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is a big difference, it is more verbose and to understand it we need to
    "run" the algorithm in our heads. This is called imperative programming, Clojure
    allows us to do imperative programming as well as functional programming, which
    is a type of declarative programming. When you get used to it, you'll see that
    it's easier to reason about than loops.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interactive programming means, telling every step of how something should be
    done to a computer. Declarative programming just asks for a result and doesn't
    give details of how to achieve it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual tests are simple to understand:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This test checks the current date returns an instance of `java.util.Date`,
    the `is` form works as the Java assert instruction:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This test checks the `<3` function, it checks that the returned collection contains
    `I love Clojure`, `I love doggies`, `I love chocolate` and `I love you` and it
    should not contain `I love Vogons`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This test is simple to understand. What might be not so simple to understand
    is the `<3` function, we'll look into it with the REPL.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we got to know some utilities that we can use for better management
    of our code and we have some more examples of everyday Clojure code. In particular:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Working of namespace in Clojure and their relation to Java packages
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing out-of-the-box unit tests and executing them with Leiningen and Cursive
    Clojure
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into the Clojure Interactive development workflow and a bit of the Clojure
    mindset
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing very simple functions and testing them
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Java interop, so we can start using
    the familiar classes and libraries we already know in our Clojure code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to use Clojure from Java, so you can start using it in
    your everyday Java projects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何从Java使用Clojure，这样你就可以开始在日常Java项目中使用它了。
