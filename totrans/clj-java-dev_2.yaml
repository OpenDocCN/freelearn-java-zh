- en: Chapter 2. Namespaces, Packages, and Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：命名空间、包和测试
- en: We now have a working installation of Clojure and IntelliJ.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经安装了 Clojure 和 IntelliJ 的有效版本。
- en: As a Java developer, you are used to working with classes as the minimal unit
    of organization. Clojure has a very different sense and gives you different tools
    to organize your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Java 开发者，你习惯于以类作为组织的最小单元进行工作。Clojure 有一个非常不同的感觉，并为你提供了不同的工具来组织你的代码。
- en: For starters, you should keep in mind that code and data are separate; you don't
    have a minimal unit with attributes and functions that work over those attributes.
    Your functions can work on any data structure that you wish, as long as you follow
    the rules of how the function works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该记住代码和数据是分开的；你没有具有属性和函数的最小单元，这些函数在这些属性上工作。你的函数可以作用于你希望的所有数据结构，只要你遵循函数的工作规则。
- en: In this chapter, we will start writing some simple functions to illustrate how
    separation of functions and data works and we will have a look at the tools Clojure
    gives us to make the separation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一些简单的函数来展示函数和数据分离的工作方式，并查看 Clojure 提供的工具来实现这种分离。
- en: 'In this chapter, we will cover the following topic:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How namespaces work compared to the classpath and Java packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间与类路径和 Java 包相比是如何工作的
- en: Unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: More Clojure examples and syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多 Clojure 示例和语法
- en: Namespaces in Clojure
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 中的命名空间
- en: Clojure namespaces might be familiar to you, as a Java developer, and for a
    very good reason, they have a very deep relationship with Java's packages and
    the classpath.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java 开发者来说，Clojure 的命名空间可能很熟悉，原因很好，它们与 Java 的包和类路径有着非常深的关系。
- en: First of all, let's review what we already know from Java.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下我们从 Java 中已经了解到的内容。
- en: Packages in Clojure
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure 中的包
- en: The Java code is organized in packages, a package in Java is a namespace that
    allows you to group a set of similar classes and interfaces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 代码是有组织的包，Java 中的包是一个命名空间，允许你将一组相似的类和接口分组在一起。
- en: You can think of a package as something very similar to a folder in your computer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将包想象成你电脑中的一个文件夹。
- en: 'The following are some common packages that you use a lot when programming
    in Java:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Java 编程中经常使用的常见包：
- en: '`java.lang`: Everything that''s native to Java, including basic types (integer,
    long, byte, boolean, character, string, number, short, float, void, and class),
    the basic threading primitives (runnable, thread), the basic primitives for exceptions
    (throwable, error, exception), the basic exceptions and errors (`NoSuchMethodError`,
    `OutOfMemoryError`, `StackOverflowError`, and so on) and runtime access classes
    like runtime and system.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang`：Java 的所有本地内容，包括基本类型（整数、长整型、字节、布尔型、字符、字符串、数字、短整型、浮点型、void、类）、基本线程原语（可运行、线程）、异常的基本原语（可抛出、错误、异常）、基本异常和错误（`NoSuchMethodError`、`OutOfMemoryError`、`StackOverflowError`
    等）以及运行时访问类（运行时和系统）。'
- en: '`java.io`: This package includes the primitives for input and output, such
    as console, file, readers, input streams, and writers.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io`：这个包包括输入和输出的基本原语，例如控制台、文件、读取器、输入流和写入器。'
- en: '`java.util`: This is one of the most heavily used packages besides `java.lang`.
    This includes the classic data structures (map, set, list) along with the most
    common implementations of such data structures. This package also includes utilities
    like properties tools, scanner for reading from various input resources, `ServiceLoader`
    to load custom services from the `classloader`, UUID generator, timers, and so
    on.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util`：这是除了 `java.lang` 之外最常使用的包之一。这个包包括经典的数据结构（映射、集合、列表）以及这些数据结构的常见实现。此包还包括属性工具、从各种输入资源读取的扫描器、`ServiceLoader`
    从 `classloader` 加载自定义服务、UUID 生成器、计时器等等。'
- en: '`java.util.logging`: The logging utilities, you normally use them to give you
    different levels of alert, from a debug to serious conditions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.logging`：日志实用工具，你通常使用它们来提供不同级别的警报，从调试到严重情况。'
- en: '`java.text`: These are utilities to manage text, dates, and numbers in a language
    independent way.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text`：这些是管理文本、日期和数字的语言无关的实用工具。'
- en: '`javax.servlet`: This includes the primitives to create web apps and deployment
    in standard web containers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.servlet`：这包括创建网络应用和在标准网络容器中部署的基本原语。'
- en: Each one of these packages groups several related functionalities, the `java.lang`
    package is particularly important, since it has every Java core type, such as
    string, long, and integer. Everything inside the `java.lang` package is available
    automatically everywhere.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包中的每一个都包含几个相关的功能，特别是`java.lang`包尤为重要，因为它包含了所有的Java核心类型，如字符串、长整型和整型。`java.lang`包中的所有内容都可以在所有地方自动使用。
- en: 'The `java.lang` package provides a bit more than just code organization, it
    also provides access security. If you remember about Java, there are three security
    access levels:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang`包不仅提供了代码组织，还提供了访问安全。如果你还记得Java，有三个安全访问级别：'
- en: private
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有
- en: public
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共
- en: protected
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护
- en: In the case of packages, we are concerned with the protected level of access.
    The classes in the same package allow every other class in the same package to
    access its protected attributes and methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在包的情况下，我们关注的是受保护的访问级别。同一包中的类允许同一包中的其他类访问其受保护的属性和方法。
- en: There are also ways to analyze a package in runtime but they are involved and
    allow for very little to be done.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时分析包也有方法，但它们很复杂，并且允许做的很少。
- en: Packages are implemented at the top of Java's classpath and the classloader.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 包是在Java的类路径和类加载器顶部实现的。
- en: The classpath and the classloader
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类路径和类加载器
- en: Java was designed to be modular and for that it needs some way to load your
    code easily. The answer to this was the classloader, the classloader allows you
    to read resources from every entry of the classpath; you can look at resources
    in the classpath as a hierarchical structure similar to the file system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java被设计成模块化的，为此它需要一种轻松加载你的代码的方法。这个答案就是类加载器，类加载器允许你从类路径的每个条目中读取资源；你可以将类路径资源视为类似于文件系统的一个分层结构。
- en: The classloader is just a list of entries; each entry can be a directory in
    the filesystem or a JAR file. At this point, you should also know that JAR files
    are just zip files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器只是一个条目列表；每个条目可以是文件系统中的一个目录或一个JAR文件。此时，你应该也知道JAR文件只是ZIP文件。
- en: The classloader will treat each entry as a directory (JAR files are just zipped
    directories) and it will look for files in each directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器会将每个条目视为一个目录（JAR文件只是压缩的目录），并且它会在每个目录中查找文件。
- en: 'There are a lot of concepts here to remember, let''s try to summarize them:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多概念需要记住，让我们尝试总结一下：
- en: JAR files are ZIP files; they might contain several classes, properties, files,
    and so on.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR文件是ZIP文件；它们可能包含多个类、属性、文件等。
- en: The classpath is a list of entries; each entry is a JAR file or a system directory.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径是一个条目列表；每个条目是一个JAR文件或系统目录。
- en: The classloader looks for resources in each entry of the classpath, so you can
    think of classpath resources as a combination of all the directories in the classpath
    (repeated resources are not overwritten)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器会在类路径的每个条目中查找资源，所以你可以将类路径资源视为类路径中所有目录的组合（重复的资源不会被覆盖）
- en: 'If you are not already familiar with how classloaders look for resources in
    classpath entries, this is the general process; let''s imagine that you want to
    load a class: `test.Test`, what happens next?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉类加载器如何在类路径条目中查找资源，这是一个通用过程；让我们想象一下，你想加载一个类：`test.Test`，接下来会发生什么？
- en: You tell the JVM that you want to load `test.Test`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你告诉JVM你想加载`test.Test`。
- en: The JVM knows to look for the `test`/`Test.class` file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM知道要查找`test`/`Test.class`文件。
- en: It starts looking for it in each entry of the classpath.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从类路径的每个条目开始查找。
- en: If the resource is a ZIP file, it "unzips" the directory.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源是一个ZIP文件，它“解压”目录。
- en: It looks for the resource in the directory which represents the entry.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会在表示条目的目录中查找资源。
- en: 'If you were to see the default classpath resources, you will probably see something,
    such as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到默认的类路径资源，你可能会看到一些东西，例如：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is important to note that each entry in the classpath doesn't just store
    class files, it can actually store any type of resource, It is a commonplace to
    store configuration files, such as `.properties` or `.xml`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，类路径中的每个条目不仅仅存储类文件，实际上可以存储任何类型的资源，存储配置文件，如`.properties`或`.xml`是很常见的。
- en: Nothing forbids you from storing anything else in the classpath resources, such
    as images, mp3 or even code! You can read and access anything from the classpath's
    resource like you can from the filesystem at runtime. The one thing that you can't
    do is modify the classpath's resource contents (at least not without some esoteric
    magic).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何规定你不能在classpath资源中存储其他任何东西，比如图片、mp3甚至代码！你可以像在运行时从文件系统读取一样，从classpath的资源中读取和访问任何东西。唯一你不能做的是修改classpath资源的内容（至少不是没有一些神秘的魔法）。
- en: Back to Clojure namespaces
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到Clojure的namespaces
- en: 'Now that we have had our little review of how packages and the classpaths work
    in Java, it''s time to go back to Clojure. You should understand that Clojure
    attempts to make the hosting platform transparent; this means a couple of very
    important things:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要回顾了Java中包和classpath的工作方式，是时候回到Clojure了。你应该明白Clojure试图使托管平台透明；这意味着几件非常重要的事情：
- en: Anything that you can do with the classpath from Java, you can also do with
    Clojure (you can read configuration files, images, etc).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以用Java的classpath做任何事情，你也可以用Clojure做（你可以读取配置文件、图片等）。
- en: Namespaces use the classpath just as Java does with packages, which makes them
    easy to understand. Nevertheless, don't underestimate them, Clojure namespace
    declarations can be more involved.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Namespaces使用classpath的方式与Java使用packages的方式相同，这使得它们很容易理解。尽管如此，不要低估它们，Clojure的namespace声明可能更复杂。
- en: Let's get practical and play a little with namespaces.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际操作一下，稍微玩一下namespaces。
- en: Playing with namespaces
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩namespaces
- en: 'Lets create a new Playground, in order to create it use the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Playground，为了创建它，请使用以下命令：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can open this project with IntelliJ, as we did in [Chapter 1](part0014_split_000.html#DB7S1-f3eee9b8c89a4c399520b72f8d890ddc
    "Chapter 1. Getting Started with Clojure"), *Getting Started with Clojure*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用IntelliJ打开这个项目，就像我们在[第1章](part0014_split_000.html#DB7S1-f3eee9b8c89a4c399520b72f8d890ddc
    "第1章。Clojure入门")中做的那样，*Clojure入门*。
- en: 'Let''s look in detail at what was created for us:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看为我们创建的内容：
- en: '![Playing with namespaces](img/00005.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![玩namespaces](img/00005.jpeg)'
- en: 'This project structure looks similar to Java projects, we have:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目结构看起来与Java项目相似，我们有：
- en: '`resources`: These are the non-source files that get added to the classpath'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`: 这些是非源文件，它们会被添加到classpath中'
- en: '`src`: Our source code'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 我们的源代码'
- en: '`test`: Our testing code'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 我们的测试代码'
- en: 'The code inside `src` and `test` is already structured into namespaces: by
    having a quick look, we could say that the name of the namespace is `ns_playground`.
    Let''s check the source code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`和`test`内部的代码已经结构化为namespaces：通过快速查看，我们可以说namespaces的名称是`ns_playground`。让我们检查源代码：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`:gen-class` was added here in order to create a Java class and allow the Java
    interpreter to start a static main method. It is not needed if you don''t intend
    to create a standalone program.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`:gen-class`在这里被添加是为了创建一个Java类，并允许Java解释器启动静态main方法。如果你不打算创建一个独立程序，则不需要它。'
- en: We can see that the (`ns ns-playground.core`) form has been used at the top,
    as you might have guessed, this is how we declare a namespace in Clojure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在顶部使用了`ns ns-playground.core`形式，正如你可能猜到的，这就是我们在Clojure中声明namespace的方式。
- en: If you are observant, you will notice something odd; the namespace has a dash
    instead of an underscore like the folder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够细心，你会注意到一些奇怪的地方；namespace有一个破折号而不是文件夹中的下划线。
- en: 'There are some reasons that lead to this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些原因导致这种情况：
- en: Clojure like most lisp variable names can have dashes in it (it is actually
    the preferred style to name the variables, as opposed to camel case in Java).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure像大多数Lisp变量名可以包含破折号（实际上，这是命名变量的首选风格，与Java中的驼峰命名法相反）。
- en: Every namespace in Clojure is represented as a package containing several Java
    classes. The namespace is used as a name of the Java package and as you know,
    the dash is not acceptable in class or package names; so every filename and folder
    name must have low dashes.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure中的每个namespace都表示为一个包含多个Java类的包。namespace用作Java包的名称，正如你所知，破折号在类或包名称中是不被接受的；因此，每个文件名和文件夹名都必须使用低破折号。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Due to the nature of Lisp, you can use dashes in variable names (they will get
    converted to underscores at compile time). In fact, this is the recommended way
    to name your variables. In Clojure, (and most Lisps) `some-variable-name` is a
    more idiomatic style than `someVariableName`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lisp的特性，你可以在变量名中使用破折号（它们将在编译时转换为下划线）。实际上，这是命名变量的推荐方式。在Clojure中（以及大多数Lisps），`some-variable-name`比`someVariableName`更符合习惯用法。
- en: Creating a new namespace
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的命名空间
- en: Let's create a new namespace; in Cursive Clojure it is easy to do so, just right-click
    on the `ns_playground` package and go to **New** | **Clojure Namespace**, it asks
    for a name and we can call it `hello`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的命名空间；在 Cursive Clojure 中，这样做很容易，只需右键单击 `ns_playground` 包，然后转到 **新建**
    | **Clojure 命名空间**，它会要求你输入一个名称，我们可以将其命名为 `hello`。
- en: 'This creates a `hello.clj` file with the following contents:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含以下内容的 `hello.clj` 文件：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, namespace creation is quite easy; you can do it by hand with
    two simple steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命名空间创建相当简单；你可以通过两个简单的步骤手动完成：
- en: Create a new file; it doesn't have to follow the package naming specification,
    but it helps to maintain your code order and it is a de facto practice.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件；它不必遵循包命名规范，但这有助于保持你的代码顺序，并且是一种事实上的做法。
- en: Add your namespace declaration.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加你的命名空间声明。
- en: That's it! It is true, even though a namespace definition can become quite complex,
    as it is the place where you define the Java packages that you wish to import,
    namespaces or functions from those namespaces that you intend to use. But you
    will normally just use a subset of those capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！诚然，命名空间定义可能会变得相当复杂，因为它是你定义你希望导入的 Java 包、命名空间或你打算使用的那些命名空间中的函数的地方。但通常你只会使用这些功能的一个子集。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that a namespace in Clojure is normally represented by a single
    file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Clojure 中的命名空间通常由一个单独的文件表示。
- en: 'For your initial namespaces, I will advice you to have two of those capabilities
    in mind:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的初始命名空间，我建议你考虑以下两种能力：
- en: '| `:import` | Allows you to import the Java classes from a package that you
    wish to use |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `:import` | 允许你从你希望使用的包中导入 Java 类 |'
- en: '| `:require` | Allows you to bring in whatever Clojure namespace that you wish
    to use |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `:require` | 允许你引入你希望使用的任何 Clojure 命名空间 |'
- en: The syntax of both `require` and the `import` is simple, let's look at a couple
    of examples before we actually use it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 和 `import` 的语法都很简单，在我们实际使用之前，让我们看看几个例子。'
- en: 'Let''s start with the `import` option:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `import` 选项开始：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You'll notice that this is similar to what you can do in Java, we are importing
    the `List` interface here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这与你在 Java 中能做的事情很相似，我们在这里导入的是 `List` 接口。
- en: 'The good thing with Clojure is that it allows you to do some more specific
    things. Let''s check how to import two classes at once:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 的好处在于它允许你做一些更具体的事情。让我们看看如何一次性导入两个类：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can extend this to the number of classes you want to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个扩展到你想使用的类数量。
- en: 'The `require` option uses a similar syntax and then builds some more on it.
    Let''s check requiring a single function from a namespace:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 选项使用类似的语法，并在其基础上构建更多。让我们看看如何从一个命名空间中引入单个函数：'
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, it is familiar and the interesting part is when you start importing
    everything:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是熟悉的，有趣的部分在于当你开始导入所有内容时：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use a custom name for everything inside your package:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为你的包中的所有内容使用自定义名称：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or you could even combine different keywords:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你甚至可以组合不同的关键字：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s try a bit of what we just learned, using the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下我们刚刚学到的知识，使用以下代码：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You must have noticed the `&` operator in the arguments of the `<3` and `sum-something`
    functions; this allows those functions to receive any number of arguments and
    we can call them, as shown: (`sum-something 1 2 3 4 5 6 7 8`) or (`sum-something`)
    They are called **variadic** functions. In Java you will call this feature **varargs**.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了 `<3` 和 `sum-something` 函数的参数中的 `&` 操作符；这允许这些函数接收任意数量的参数，我们可以像这样调用它们：（`sum-something
    1 2 3 4 5 6 7 8`）或（`sum-something`）。它们被称为**可变参数**函数。在 Java 中，你会把这个特性称为**可变参数**。
- en: Everything looks great, but we haven't yet seen how to require and use these
    functions from some other package. Let's write a test to see how this will be
    done.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很不错，但我们还没有看到如何从其他包中引入和使用这些函数。让我们写一个测试来看看这是如何完成的。
- en: Working with namespaces on the REPL
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 REPL 上使用命名空间
- en: A great way of playing with namespaces is by using the REPL and we'll also get
    the benefit of getting to know it better.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 REPL 来玩转命名空间是一个很好的方法，我们也将从中获得更好地了解它的好处。
- en: 'Since we are going to play with namespace, we need to know of a few functions
    that will help us move between namespaces and require other namespaces. The functions
    are listed as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要玩转命名空间，我们需要了解一些函数，这些函数将帮助我们在不同命名空间之间移动并引入其他命名空间。这些函数如下列出：
- en: '| Function | Description | Sample usage |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 | 示例用法 |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `in-ns` | Sets `*ns*` to the namespace named by the symbol, creating it if
    needed. | (`in-ns ''ns-playground.core`) |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `in-ns` | 将`*ns*`设置为名为符号的命名空间，如果需要则创建它。 | (`in-ns ''ns-playground.core`)
    |'
- en: '| `require` | Loads `libs`, skipping any that are already loaded. | (`require
    ''[clojure.java.io :as io]`) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `require` | 加载`libs`，跳过任何已加载的库。 | (`require ''[clojure.java.io :as io]'')
    |'
- en: '| `import` | For each name in `class-name-symbols`, adds a mapping from name
    to the class named by `package.name` to the current namespace. | (`import java.util.Date`)
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `import` | 对于`class-name-symbols`中的每个名称，将名称到由`package.name`命名的类的映射添加到当前命名空间。
    | (`import java.util.Date`) |'
- en: '| `refer` | refers to all public `vars` of `ns`, subject to filters. | (`refer
    ''clojure.string :only ''[capitalize trim]`) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `refer` | 引用`ns`的所有公共`vars`，受过滤器约束。 | (`refer ''clojure.string :only ''[capitalize
    trim]`) |'
- en: 'Let''s go into the REPL window of our IntelliJ. We can check what namespace
    we are in with the `*ns*` instruction. Let''s try now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的IntelliJ的REPL窗口。我们可以使用`*ns*`指令来检查我们处于哪个命名空间。现在让我们试试：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Imagine that we need to execute a code and test the code from within the `ns-playground.hello`
    namespace, we can do that with the `in-ns` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在`ns-playground.hello`命名空间内执行代码并测试代码，我们可以使用`in-ns`函数来完成：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We want to know what `str` does, it seems to receive three strings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道`str`函数的作用，它似乎接收三个字符串：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s try the `for` form now:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来尝试`for`形式：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `for` macro takes a collection of items and returns a new lazy sequence
    applying the body of the `for` to each element.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`宏接受一个项目集合，并返回一个新的惰性序列，将`for`的主体应用于每个元素。'
- en: 'Knowing this, understanding the `<3` function is easy, let''s try it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，理解`<3`函数就很容易了，让我们试试：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've used the REPL to test some simple functions, but let's now try to test
    something else like reading a properties file from the classpath.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用REPL测试了一些简单的函数，但现在让我们尝试测试其他一些内容，比如从类路径中读取属性文件。
- en: 'We can add a `test.properties` file to the resources folder with the following
    contents:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在资源文件夹中添加一个`test.properties`文件，内容如下：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember to restart the REPL, as the changes to the contents that some piece
    of the classpath points to are not visible to a running REPL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记得重新启动REPL，因为对某些类路径中指向的内容的更改对正在运行的REPL是不可见的。
- en: 'Let''s try reading our properties file as an input stream, we can use the `clojure.java.io`
    namespace to do it, and we can check it as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将属性文件作为输入流读取，我们可以使用`clojure.java.io`命名空间来完成，我们可以像下面这样检查它：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now define our function for reading properties, we can input this into
    the REPL:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的读取属性函数，我们可以将其输入到REPL中：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `let` form lets us create local 'variables', instead of using the (`io/resource
    path`) directly in the code. We can create a reference once and use it through
    the code. It allows us to use simpler code and to have a single reference to an
    object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`形式允许我们创建局部''变量''，而不是直接在代码中使用(`io/resource path`)。我们可以创建一个引用一次并在代码中使用它。它允许我们使用更简单的代码，并有一个指向对象的单一引用。'
- en: 'In the end, we can redefine the `hello` namespace to include everything we''ve
    checked, such as this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重新定义`hello`命名空间以包含我们检查的所有内容，例如：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember to include the `Properties` class in the `import` and to define the
    `:require` keyword for `clojure.java.io`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`import`中包含`Properties`类，并为`clojure.java.io`定义`:require`关键字。
- en: Testing in Clojure
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的测试
- en: Clojure already comes with a unit testing support built-in, as a matter of fact
    Leiningen has already created a test for us; let's take a look at it right now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Clojure已经内置了单元测试支持，Leiningen已经为我们创建了一个测试；现在让我们看看它。
- en: 'Open the `test/ns_playground/core_test.clj` file, you should be able to see
    this code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`test/ns_playground/core_test.clj`文件，你应该能看到以下代码：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, as you can see, we are using `:require` to include functions from the
    `clojure.test` and the `ns-playground.core` packages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，正如你所见，我们正在使用`:require`来包含`clojure.test`和`ns-playground.core`包中的函数。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, the `:refer :all` works similar to how `char import static clojure.test.*`
    will work in Java.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`:refer :all`的作用类似于Java中的`char import static clojure.test.*`。
- en: Testing from the command line
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行测试
- en: 'Let''s first learn how to run these tests. From the command line, you can run:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先学习如何运行这些测试。从命令行，你可以运行：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We see that there is one test failing, we will go back to this in a bit; for
    now, let's see how to test in IntelliJ.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到有一个测试失败，我们稍后会回到这个问题；现在，让我们看看如何在IntelliJ中测试。
- en: Testing in IntelliJ
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntelliJ中的测试
- en: 'First of all, we need a new REPL configuration. You can do it as you learned
    in the previous chapter. You just need to follow the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的REPL配置。你可以像上一章中学到的那样做。你只需要遵循以下步骤：
- en: Right click on the `project.clj` file and select **Create REPL for ns-playground,**
    as shown in the following screenshot:![Testing in IntelliJ](img/00006.jpeg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`project.clj`文件，并选择**为ns-playground创建REPL**，如图所示：![在IntelliJ中进行测试](img/00006.jpeg)
- en: Then click on **OK** in the next dialog.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在下一个对话框中点击**确定**。
- en: After that, you should run the REPL again by right clicking the `project.clj`
    file and selecting **Run REPL for ns-playground**.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你应该通过右键点击`project.clj`文件并选择**运行ns-playground的REPL**来再次运行REPL。
- en: After that you can run any tests, just open your test file and go to **Tools**
    | **Run Tests** in the current NS in REPL. You should see something similar to
    the following screenshot:![Testing in IntelliJ](img/00007.jpeg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后你可以运行任何测试，只需打开你的测试文件，并在REPL中的当前NS中转到**工具** | **运行测试**。你应该会看到以下类似的截图：![在IntelliJ中进行测试](img/00007.jpeg)
- en: As you can see, it signals that your test is currently failing. Let's fix it
    and run our test again. Change the `(is (= 0 1))` line to `(is (= 1 1))`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，它表明你的测试目前正在失败。让我们修复它并再次运行我们的测试。将`(is (= 0 1))`行更改为`(is (= 1 1))`。
- en: 'Now, let''s try some real tests for our previously defined functions; don''t
    worry if you can''t understand all the code for now, you are not supposed to:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试对我们之前定义的函数进行一些实际的测试；如果你现在不能理解所有的代码，不要担心，你不需要这样做：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can't use the Clojure contents function here because it has a different function.
    It looks for keys in a map.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里使用Clojure的内容函数，因为它有一个不同的函数。它会在映射中查找键。
- en: 'Run the tests and you''ll see that everything passes correctly but there''s
    a lot going on over here, let''s go over it little by little:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，你会看到所有内容都正确通过，但这里发生了很多事情，让我们一点一点地来看：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is the namespace declaration, let''s list everything it does:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命名空间声明，让我们列出它所做的一切：
- en: It declares the `ns-playground.core-test` package.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它声明了`ns-playground.core-test`包。
- en: It imports the `java.util.Date` class.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导入了`java.util.Date`类。
- en: It makes everything in the `clojure.test` namespace available in the current
    namespace, if we were in Java we might have used `import static clojure.test.*`
    to get a similar effect. We can achieve this with the `:refer :all` keywords.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得`clojure.test`命名空间中的所有内容在当前命名空间中可用，如果我们处于Java中，我们可能会使用`import static clojure.test.*`来获得类似的效果。我们可以通过使用`:refer
    :all`关键字来实现这一点。
- en: It makes everything in the `ns-playground.hello` namespace available with the
    hello shortcut but we need to prefix every function or value defined in `ns-playground.hello`
    with hello and it also makes the `<3` function available without a prefix. To
    generate an alias and make everything available with the `hello` alias, we use
    the `:as` keyword and then pass a vector to `:refer` to include certain elements.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得`ns-playground.hello`命名空间中的所有内容都可以通过hello快捷键访问，但我们需要在`ns-playground.hello`中定义的每个函数或值前加上hello前缀，并且它还使得`<3`函数可以无前缀访问。为了生成别名并使所有内容都可以通过`hello`别名访问，我们使用`:as`关键字，然后传递一个向量给`:refer`以包含某些元素。
- en: It makes everything in the `ns-playground.core` namespace available in the current
    namespace. We achieve this with the `:refer :all` keywords.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得`ns-playground.core`命名空间中的所有内容在当前命名空间中可用。我们通过使用`:refer :all`关键字来实现这一点。
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the declaration of a function called `lazy-contains?`, it is a `boolean`
    function and it is customary in Clojure to call it a predicate.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是名为`lazy-contains?`的函数的声明，它是一个`boolean`函数，在Clojure中通常将其称为谓词。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the function including the question mark might be something that
    looks awkward to you. In Clojure and Lisp, you can use question marks in the names
    of functions and it is common to do it for functions that return Booleans.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 包含问号的函数名称可能对你来说看起来有些不自然。在Clojure和Lisp中，你可以在函数名称中使用问号，并且对于返回布尔值的函数来说，这样做是很常见的。
- en: 'It receives two parameters: `col` and `element`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收两个参数：`col`和`element`。
- en: 'The actual body of the function looks a bit complicated but it is actually
    very simple. Whenever you encounter a function that looks similar to the one mentioned
    in the preceding section, try to read it from the inside out. The innermost part
    is, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的实际主体看起来有点复杂，但实际上非常简单。每次你遇到一个看起来与上一节中提到的函数相似时，试着从内向外阅读。最内层部分如下：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is a shorter way of writing an anonymous function which has a single parameter.
    If we want to write another function that compares its argument against the `element`,
    without the syntactic sugar, we can do it in the following method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个编写只有一个参数的匿名函数的简短方式。如果我们想编写另一个函数，该函数将其参数与`element`进行比较，没有使用语法糖，我们可以用以下方法实现：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is an anonymous function or in other words it is a function that has no
    name, but it works as every other function; we will read more about anonymous
    functions when we get back to functional programming.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个匿名函数，换句话说，它是一个没有名字的函数，但它像其他任何函数一样工作；当我们回到函数式编程时，我们将了解更多关于匿名函数的内容。
- en: 'Our anonymous function is a parameter to the following form:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的匿名函数是以下形式的参数：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This new form filters the collection `col` and returns a new collection with
    only the elements that pass the test. Let''s see an example where we have used
    the predefined Clojure function `even?`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新形式过滤集合`col`，并返回一个只包含通过测试的元素的新集合。让我们看看一个例子，其中我们使用了预定义的Clojure函数`even?`：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our filter function now returns every element in the collection that passes
    the `#(= element %)`test. So we get every element that is equal to the element
    passed to `lazy-contains?`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的过滤器函数返回集合中通过`#(= element %)`测试的每个元素。因此，我们得到与传递给`lazy-contains?`的元素相等的每个元素。
- en: 'We then ask if none of the elements equal to `element` in `col` with the following
    form:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用以下形式询问`col`中是否有任何元素等于`element`：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But we want to know if there is some element equal to element, so at last we
    negate the previous form:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们想知道是否有某个元素等于元素，所以最后我们否定前面的形式：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Imagine that if you had to write this in Java (and I asked to add every element
    that matches the element to a list), you will have something similar to this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你必须用Java编写这个（并且我要求将匹配元素的每个元素添加到列表中），你将得到类似的东西：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is a big difference, it is more verbose and to understand it we need to
    "run" the algorithm in our heads. This is called imperative programming, Clojure
    allows us to do imperative programming as well as functional programming, which
    is a type of declarative programming. When you get used to it, you'll see that
    it's easier to reason about than loops.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很大的区别，它更冗长，要理解它我们需要“运行”算法在我们的脑海中。这被称为命令式编程，Clojure允许我们进行命令式编程以及函数式编程，这是一种声明式编程。当你习惯了，你会发现它比循环更容易推理。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interactive programming means, telling every step of how something should be
    done to a computer. Declarative programming just asks for a result and doesn't
    give details of how to achieve it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式编程意味着，向计算机说明如何完成的每一步。声明式编程只是要求一个结果，而不提供如何实现它的细节。
- en: 'The actual tests are simple to understand:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实际测试很容易理解：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This test checks the current date returns an instance of `java.util.Date`,
    the `is` form works as the Java assert instruction:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查当前日期返回一个`java.util.Date`实例，`is`形式与Java断言指令类似：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This test checks the `<3` function, it checks that the returned collection contains
    `I love Clojure`, `I love doggies`, `I love chocolate` and `I love you` and it
    should not contain `I love Vogons`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查`<3`函数，它检查返回的集合包含`I love Clojure`、`I love doggies`、`I love chocolate`和`I
    love you`，并且不应包含`I love Vogons`。
- en: This test is simple to understand. What might be not so simple to understand
    is the `<3` function, we'll look into it with the REPL.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很容易理解。可能不太容易理解的是`<3`函数，我们将使用REPL来探讨它。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we got to know some utilities that we can use for better management
    of our code and we have some more examples of everyday Clojure code. In particular:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一些可以用于更好地管理我们代码的实用工具，并且有一些Clojure日常代码的更多示例。特别是：
- en: Working of namespace in Clojure and their relation to Java packages
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure中的命名空间的工作原理及其与Java包的关系
- en: Writing out-of-the-box unit tests and executing them with Leiningen and Cursive
    Clojure
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写创新单元测试，并使用Leiningen和Cursive Clojure执行它们
- en: Delving into the Clojure Interactive development workflow and a bit of the Clojure
    mindset
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Clojure交互式开发工作流程以及Clojure思维模式
- en: Writing very simple functions and testing them
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写非常简单的函数并测试它们
- en: In the next chapter, we will learn about Java interop, so we can start using
    the familiar classes and libraries we already know in our Clojure code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Java互操作，这样我们就可以开始在Clojure代码中使用我们已知的熟悉类和库。
- en: We will also learn how to use Clojure from Java, so you can start using it in
    your everyday Java projects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何从Java使用Clojure，这样你就可以开始在日常Java项目中使用它了。
