<html><head></head><body>
<p class="calibre1"><a id="p1"/><img src="index-1_1.jpg" alt="Image 1" class="calibre2"/></p>
<p class="calibre1"><a id="p2"/><img src="index-2_1.jpg" alt="Image 2" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Java 9 Regular Expressions</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">Zero-length assertions, back-references, quantifiers, and more Anubhava Srivastava</p>
<p class="calibre1"><a id="p3"/><b class="calibre3">BIRMINGHAM - MUMBAI</b></p>
<p class="calibre1"><a id="p4"/>&lt; html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" </p>
<p class="calibre1">"http://www.w3.org/TR/REC-html40/loose.dtd"&gt; </p>
<p class="calibre1"><a id="p5"/><b class="calibre3">Java 9 Regular Expressions</b></p>
<p class="calibre1">Copyright Â© 2017 Packt Publishing</p>
<p class="calibre1"/>
<p class="calibre1">All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews. </p>
<p class="calibre1">Every effort has been made in the preparation of this book to ensure the accuracy of the information presented. However, the information contained in this book is sold without warranty, either express or implied. Neither the author, nor Packt Publishing, and its dealers and distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book. </p>
<p class="calibre1">Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned in this book by the appropriate use of capitals. </p>
<p class="calibre1">However, Packt Publishing cannot guarantee the accuracy of this information. </p>
<p class="calibre1">First published: July 2017</p>
<p class="calibre1">Production reference: 1210717</p>
<p class="calibre1">Published by Packt Publishing Ltd. </p>
<p class="calibre1">Livery Place</p>
<p class="calibre1">35 Livery Street</p>
<p class="calibre1">Birmingham</p>
<p class="calibre1">B3 2PB, UK. </p>
<p class="calibre1">ISBN 978-1-78728-870-6</p>
<p class="calibre1"/>
<p class="calibre1"><a href="http://www.packtpub.com">www.packtpub.com</a></p>
<p class="calibre1"><a id="p6"/><b class="calibre3">Credits</b></p>
<p class="calibre1"><b class="calibre3">Author</b></p>
<p class="calibre1"><b class="calibre3">Copy Editor</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">Anubhava Srivastava</p>
<p class="calibre1">Muktikant Garimella</p>
<p class="calibre1"><b class="calibre3">Reviewer</b></p>
<p class="calibre1"><b class="calibre3">Project Coordinator</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">Peter Verhas</p>
<p class="calibre1">Ulhas Kambali</p>
<p class="calibre1"><b class="calibre3">Commissioning Editor</b></p>
<p class="calibre1"><b class="calibre3">Proofreader</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">Merint Thomas Mathew</p>
<p class="calibre1">Safis Editing</p>
<p class="calibre1"><b class="calibre3">Acquisition Editor</b></p>
<p class="calibre1"><b class="calibre3">Indexer</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"><a id="p7"/>Nitin Dasan</p>
<p class="calibre1">Francy Puthiry</p>
<p class="calibre1"><b class="calibre3">Content Development Editor</b></p>
<p class="calibre1"><b class="calibre3">Graphics</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">Vikas Tiwari</p>
<p class="calibre1">Abhinash Sahu</p>
<p class="calibre1"><b class="calibre3">Technical Editor</b></p>
<p class="calibre1"><b class="calibre3">Production Coordinator</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">Jijo Maliyekal</p>
<p class="calibre1">Melwyn Dsa</p>
<p class="calibre1"><a id="p8"/><b class="calibre3">About the Author</b></p>
<p class="calibre1"><b class="calibre3">Anubhava Srivastava</b> has more than 22 years of professional experience in architecture, design, and software development. He specializes mainly in the J2EE</p>
<p class="calibre1">technology stack, web technologies, CICD, test-driven development, and AWS cloud-based development. </p>
<p class="calibre1">He is an active contributor to the Stack Overflow community. He currently stands in the top 35 users in terms of reputations out of the 7.5 million Stack Overflow users. </p>
<p class="calibre1">He is passionate about regular expressions and is always willing to sharpen his regex skills further. He has answered close to 10,000 regex questions on Stack Overflow. </p>
<p class="calibre1">He has authored and released a test-driven framework, called GenericFixture, for</p>
<p class="calibre1"><a href="http://anubhava.wordpress.com">FitNesse as an open source software. He maintains a technical blog at http://anubhava.wo</a></p>
<p class="calibre1"><a href="http://anubhava.wordpress.com">rdpress.com</a></p>
<p class="calibre1">Anubhava can be found on LinkedIn at<a href="https://www.linkedin.com/in/anubhava/"> https://www.linkedin.com/in/anubhava/</a></p>
<p class="calibre1">You can follow him on Twitter at @anubhava. </p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"> <i class="calibre4">First, I would like to express my gratitude toward the whole editing and publishing</i> <i class="calibre4">team at Packt Publishing for offering me an opportunity to write this book. Their</i> <i class="calibre4">support and guidance throughout this process encouraged me to explore more and dig</i> <i class="calibre4">deep. </i></p>
<p class="calibre1"> <i class="calibre4">This book would not have been possible without the support and encouragement of my</i> <i class="calibre4">wife and kids. I am really grateful to my family for trusting in my abilities and for</i> <i class="calibre4">understanding my long hours in front of the computer on weekends and holidays. </i></p>
<p class="calibre1"> <i class="calibre4">I want to acknowledge the immensely knowledgeable Stack Overflow contributors and</i> <i class="calibre4">open source community for teaching me advanced regex concepts. </i></p>
<p class="calibre1"> <i class="calibre4">Lastly, I want to say big thanks to my management team at AOL for allowing me to</i> <i class="calibre4">embark on this book writing journey in my off time. </i></p>
<p class="calibre1"><a id="p9"/><b class="calibre3">About the Reviewer</b></p>
<p class="calibre1"><b class="calibre3">Peter Verhas</b> is a senior software engineer and software architect with a background in electrical engineering and economics. He pursued his MSc from TU Budapest and MBA from PTE Hungary. He has also studied at TU Delft and TU Vienna. He created his first programs in 1979, and since then, he has been the author of several open source programs. He has worked in the telecommunication and finance industries in several positions and was the CIO of the Hungarian startup, index.hu, during its initial days. </p>
<p class="calibre1">Peter works for EPAM Systems in Switzerland, participating in software development projects at various customer sites. He also supports talent acquisition by interviewing candidates and designs internal mentoring programs and training programs for developers. </p>
<p class="calibre1">Peter is the author of  <i class="calibre4">Java 9 Programming by Example</i> and the co-author of <i class="calibre4">Mastering Java 9</i> by Packt. </p>
<p class="calibre1">You can follow Peter on Twitter at @verhas, LinkedIn, and GitHub. You can also read his technical blog, Java Deep, at<a href="http://javax0.wordpress.com"> http://javax0.wordpress.com</a>. </p>
<p class="calibre1"><a id="p10"/><img src="index-10_1.jpg" alt="Image 3" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">www.PacktPub.com</b></p>
<p class="calibre1">For support files and downloads related to your book, please visit<a href="http://www.PacktPub.com"> www.PacktPub.com. </a></p>
<p class="calibre1">Did you know that Packt offers eBook versions of every book published, with PDF</p>
<p class="calibre1">and ePub files available? You can upgrade to the eBook version at</p>
<p class="calibre1"><a href="http://www.PacktPub.com">www.PacktPub.coma</a>nd as a print book customer, you are entitled to a discount on the eBook copy. Get in touch with us at service@packtpub.com for more details. </p>
<p class="calibre1">At<a href="http://www.PacktPub.com"> www.PacktPub.com</a>, you can also read a collection of free technical articles, sign up for a range of free newsletters and receive exclusive discounts and offers on Packt books and eBooks. </p>
<p class="calibre1"><a href="https://www.packtpub.com/mapt">https://www.packtpub.com/mapt</a></p>
<p class="calibre1">Get the most in-demand software skills with Mapt. Mapt gives you full access to all Packt books and video courses, as well as industry-leading tools to help you plan your personal development and advance your career. </p>
<p class="calibre1"><a id="p11"/><b class="calibre3">Why subscribe? </b></p>
<p class="calibre1">Fully searchable across every book published by Packt</p>
<p class="calibre1">Copy and paste, print, and bookmark content</p>
<p class="calibre1">On demand and accessible via a web browser</p>
<p class="calibre1"><a id="p12"/><b class="calibre3">Customer Feedback</b></p>
<p class="calibre1">Thanks for purchasing this Packt book. At Packt, quality is at the heart of our editorial process. To help us improve, please leave us an honest review on this book's Amazon page at <a href="https://www.amazon.com/dp/1787288706">https://www.amazon.com/dp/1787288706. </a></p>
<p class="calibre1">If you'd like to join our team of regular reviewers, you can e-mail us at customerreviews@packtpub.com. We award our regular reviewers with free eBooks and videos in exchange for their valuable feedback. Help us be relentless in improving our products! </p>
<p class="calibre1"><a id="p13"/><b class="calibre3">Table of Contents</b></p>
<p class="calibre1"><a href="#p16">Preface</a></p>
<p class="calibre1"><a href="#p17">What this book covers</a></p>
<p class="calibre1"><a href="#p18">What you need for this book</a></p>
<p class="calibre1"><a href="#p19">Who this book is for</a></p>
<p class="calibre1"><a href="#p20">Conventions</a></p>
<p class="calibre1"><a href="#p21">Reader feedback</a></p>
<p class="calibre1"><a href="#p22">Customer support</a></p>
<p class="calibre1"><a href="#p23">Downloading the example code</a></p>
<p class="calibre1"><a href="#p24">Errata</a></p>
<p class="calibre1"><a href="#p25">Piracy</a></p>
<p class="calibre1"><a href="#p26">Questions</a></p>
<p class="calibre1">1. <a href="#p27">Getting Started with Regular Expressions</a></p>
<p class="calibre1"><a href="#p28">Introduction to regular expressions</a></p>
<p class="calibre1"><a href="#p29">A bit of history of regular expressions</a></p>
<p class="calibre1"><a href="#p30">Various flavors of regular expressions</a></p>
<p class="calibre1"><a href="#p31">What type of problems need regular expressions to solve</a></p>
<p class="calibre1"><a href="#p32">The basic rules of regular expressions</a></p>
<p class="calibre1"><a href="#p33">Constructs of the standard regular expression and meta characters</a></p>
<p class="calibre1"><a href="#p36">Some basic regular expression examples</a></p>
<p class="calibre1"><a href="#p38">Eager matching</a></p>
<p class="calibre1"><a href="#p39">The effect of eager matching on regular expression alternation</a></p>
<p class="calibre1"><a href="#p41">Summary</a></p>
<p class="calibre1">2. <a href="#p42">Understanding the Core Constructs of Java Regular Expressions</a></p>
<p class="calibre1"><a href="#p43">Understanding the core constructs of regular expressions</a></p>
<p class="calibre1"><a href="#p44">Quantifiers</a></p>
<p class="calibre1"><a href="#p45">Basic quantifiers</a></p>
<p class="calibre1"><a href="#p46">Examples using quantifiers</a></p>
<p class="calibre1"><a href="#p47">Greedy versus reluctant (lazy) matching using quantifiers</a></p>
<p class="calibre1"><a href="#p48">Possessive quantifiers</a></p>
<p class="calibre1"><a href="#p50">Boundary constructs</a></p>
<p class="calibre1"><a href="#p51">Examples using boundary constructs</a></p>
<p class="calibre1"><a href="#p52">Character classes</a></p>
<p class="calibre1"><a href="#p53">Examples of character classes</a></p>
<p class="calibre1"><a href="#p54">Range inside a character class</a></p>
<p class="calibre1"><a href="#p55">Examples of character range</a></p>
<p class="calibre1"><a href="#p56">Escaping special regex metacharacters and escaping rules inside the character class</a></p>
<p class="calibre1"><a href="#p56">es</a></p>
<p class="calibre1"><a href="#p57">Escaping inside a character class</a></p>
<p class="calibre1"><a href="#p58">Examples of escaping rules inside the character class</a></p>
<p class="calibre1"><a href="#p59">Literally matching a string that may contain special regex metacharacters</a></p>
<p class="calibre1"><a href="#p60">Negated character classes</a></p>
<p class="calibre1"><a href="#p61">Examples of negated character classes</a></p>
<p class="calibre1"><a href="#p62">Predefined shorthand character classes</a></p>
<p class="calibre1"><a href="#p63">POSIX character classes</a></p>
<p class="calibre1"><a href="#p64">Unicode support in Java regular expressions</a></p>
<p class="calibre1"><a href="#p65">Commonly used Unicode character properties</a></p>
<p class="calibre1"><a href="#p66">Negation of the preceding regex directives</a></p>
<p class="calibre1"><a href="#p67">Unicode scripts support</a></p>
<p class="calibre1"><a href="#p69">Examples of matching Unicode text in regular expressions</a></p>
<p class="calibre1"><a href="#p70">Double escaping in a Java String when defining regular expressions</a></p>
<p class="calibre1"><a href="#p71">Embedded regular expression mode modifiers</a></p>
<p class="calibre1"><a href="#p73">The placement of embedded modes in a Java regular expression</a></p>
<p class="calibre1"><a href="#p74">Disabling mode modifiers</a></p>
<p class="calibre1"><a href="#p75">Summary</a></p>
<p class="calibre1"><a id="p14"/>3. <a href="#p76">Working with Groups, Capturing, and References</a></p>
<p class="calibre1"><a href="#p77">Capturing groups</a></p>
<p class="calibre1"><a href="#p78">Group numbering</a></p>
<p class="calibre1"><a href="#p80">Named groups</a></p>
<p class="calibre1"><a href="#p81">Non-capturing groups</a></p>
<p class="calibre1"><a href="#p82">Advantages of non-capturing groups</a></p>
<p class="calibre1"><a href="#p83">Back references</a></p>
<p class="calibre1"><a href="#p85">Back reference of a named group</a></p>
<p class="calibre1"><a href="#p86">Replacement reference of a named group</a></p>
<p class="calibre1"><a href="#p87">Forward references</a></p>
<p class="calibre1"><a href="#p89">Invalid (non-existing) backward or forward references</a></p>
<p class="calibre1"><a href="#p90">Summary</a></p>
<p class="calibre1">4. <a href="#p91">Regular Expression Programming Using Java String and Scanner APIs</a></p>
<p class="calibre1"><a href="#p92">Introduction to the Java String API for regular expressions' evaluation</a></p>
<p class="calibre1"><a href="#p93">Method - boolean matches(String regex)</a></p>
<p class="calibre1"><a href="#p94">Example of the matches method</a></p>
<p class="calibre1"><a href="#p96">Method - String replaceAll(String regex, String replacement)</a></p>
<p class="calibre1"><a href="#p97">Examples of the replaceAll method</a></p>
<p class="calibre1"><a href="#p99">Method - String replaceFirst(String regex, String replacement)</a></p>
<p class="calibre1"><a href="#p100">Examples of the replaceFirst method</a></p>
<p class="calibre1"><a href="#p101">Methods - String split methods</a></p>
<p class="calibre1"><a href="#p102">The limit parameter rules</a></p>
<p class="calibre1"><a href="#p103">Examples of the split method</a></p>
<p class="calibre1"><a href="#p104">Example of the split method using the limit parameter</a></p>
<p class="calibre1"><a href="#p106">Using regular expressions in Java Scanner API</a></p>
<p class="calibre1"><a href="index_split_001.html#p110">Summary</a></p>
<p class="calibre1">5. <a href="index_split_001.html#p111">Introduction to Java Regular Expression APIs - Pattern and Matcher Classes</a></p>
<p class="calibre1"><a href="index_split_001.html#p112">The MatchResult interface</a></p>
<p class="calibre1"><a href="index_split_001.html#p114">The Pattern class</a></p>
<p class="calibre1"><a href="index_split_001.html#p116">Examples using the Pattern class</a></p>
<p class="calibre1"><a href="index_split_001.html#p119">Filtering a list of tokens using the asPredicate() method</a></p>
<p class="calibre1"><a href="index_split_001.html#p120">The Matcher class</a></p>
<p class="calibre1"><a href="index_split_001.html#p123">Examples using the Matcher class</a></p>
<p class="calibre1"><a href="index_split_001.html#p124">Method Boolean lookingAt()</a></p>
<p class="calibre1"><a href="index_split_001.html#p125">The matches() method</a></p>
<p class="calibre1"><a href="index_split_001.html#p126">The find() and find(int start) methods</a></p>
<p class="calibre1"><a href="index_split_001.html#p128">The appendReplacement(StringBuffer sb, String replacement) method</a></p>
<p class="calibre1"><a href="index_split_001.html#p129">The appendTail(StringBuffer sb) method</a></p>
<p class="calibre1"><a href="index_split_001.html#p130">Example of the appendReplacement and appendTail methods</a></p>
<p class="calibre1"><a href="index_split_001.html#p132">Summary</a></p>
<p class="calibre1">6. <a href="index_split_001.html#p133">Exploring Zero-Width Assertions, Lookarounds, and Atomic Groups</a></p>
<p class="calibre1"><a href="index_split_001.html#p134">Zero-width assertions</a></p>
<p class="calibre1"><a href="index_split_001.html#p135">Predefined zero-width assertions</a></p>
<p class="calibre1"><a href="index_split_001.html#p136">Regex defined zero-width assertions</a></p>
<p class="calibre1"><a href="index_split_001.html#p137">\G boundary assertion</a></p>
<p class="calibre1"><a href="index_split_001.html#p139">Atomic groups</a></p>
<p class="calibre1"><a href="index_split_001.html#p141">Lookahead assertions</a></p>
<p class="calibre1"><a href="index_split_001.html#p142">Positive lookahead</a></p>
<p class="calibre1"><a href="index_split_001.html#p143">Negative lookahead</a></p>
<p class="calibre1"><a href="index_split_001.html#p144">Lookbehind assertions</a></p>
<p class="calibre1"><a href="index_split_001.html#p145">Positive lookbehind</a></p>
<p class="calibre1"><a href="index_split_001.html#p146">Negative lookbehind</a></p>
<p class="calibre1"><a href="index_split_001.html#p151">Capturing text from overlapping matches</a></p>
<p class="calibre1"><a href="index_split_001.html#p153">Be careful with capturing groups inside a lookahead or lookbehind atomic group</a></p>
<p class="calibre1"><a href="index_split_001.html#p154">Lookbehind limitations in Java regular expressions</a></p>
<p class="calibre1"><a href="index_split_001.html#p155">Summary</a></p>
<p class="calibre1">7. <a href="index_split_001.html#p156">Understanding the Union, Intersection, and Subtraction of Character Classes</a></p>
<p class="calibre1"><a href="index_split_001.html#p157">The union of character classes</a></p>
<p class="calibre1"><a id="p15"/><a href="index_split_001.html#p159">The intersection of character classes</a></p>
<p class="calibre1"><a href="index_split_001.html#p162">The subtraction of character classes</a></p>
<p class="calibre1"><a href="index_split_001.html#p164">Why should you use composite character classes? </a></p>
<p class="calibre1"><a href="index_split_001.html#p165">Summary</a></p>
<p class="calibre1">8. <a href="index_split_001.html#p166">Regular Expression Pitfalls, Optimization, and Performance Improvements</a></p>
<p class="calibre1"><a href="index_split_001.html#p167">Common pitfalls and ways to avoid them while writing regular expressions</a></p>
<p class="calibre1"><a href="index_split_001.html#p168">Do not forget to escape regex metacharacters outside a character class</a></p>
<p class="calibre1"><a href="index_split_001.html#p169">Avoid escaping every non-word character</a></p>
<p class="calibre1"><a href="index_split_001.html#p170">Avoid unnecessary capturing groups to reduce memory consumption</a></p>
<p class="calibre1"><a href="index_split_001.html#p171">However, don't forget to use the required group around alternation</a></p>
<p class="calibre1"><a href="index_split_001.html#p172">Use predefined character classes instead of longer versions</a></p>
<p class="calibre1"><a href="index_split_001.html#p173">Use the limiting quantifier instead of repeating a character or pattern multiple times</a></p>
<p class="calibre1"><a href="index_split_001.html#p174">Do not use an unescaped hyphen in the middle of a character class</a></p>
<p class="calibre1"><a href="index_split_001.html#p175">The mistake of calling matcher.goup() without a prior call to matcher.find(), match</a></p>
<p class="calibre1"><a href="index_split_001.html#p175">er.matches(), or matcher.lookingAt()</a></p>
<p class="calibre1"><a href="index_split_001.html#p177">Do not use regular expressions to parse XML / HTML data</a></p>
<p class="calibre1"><a href="index_split_001.html#p178">How to test and benchmark your regular expression performance</a></p>
<p class="calibre1"><a href="index_split_001.html#p179">Catastrophic or exponential backtracking</a></p>
<p class="calibre1"><a href="index_split_001.html#p182">How to avoid catastrophic backtracking</a></p>
<p class="calibre1"><a href="index_split_001.html#p185">Optimization and performance enhancement tips</a></p>
<p class="calibre1"><a href="index_split_001.html#p186">Use a compiled form of regular expressions</a></p>
<p class="calibre1"><a href="index_split_001.html#p187">Use a negated character class instead of the greedy and slow .* or .+</a></p>
<p class="calibre1"><a href="index_split_001.html#p188">Avoid unnecessary grouping</a></p>
<p class="calibre1"><a href="index_split_001.html#p189">Use lazy quantifiers strategically instead of greedy quantifiers that cause excessive </a></p>
<p class="calibre1"><a href="index_split_001.html#p189">backtracking</a></p>
<p class="calibre1"><a href="index_split_001.html#p190">Make use of possessive quantifiers to avoid backtracking</a></p>
<p class="calibre1"><a href="index_split_001.html#p191">Extract common repeating substrings out of alternation</a></p>
<p class="calibre1"><a href="index_split_001.html#p192">Use atomic group to avoid backtracking and fail fast</a></p>
<p class="calibre1"><a href="index_split_001.html#p193">Summary</a></p>
<p class="calibre1"><a id="p16"/><b class="calibre3">Preface</b></p>
<p class="calibre1"/>
<p class="calibre1">In today's information technology world, the size of data is growing by leaps and bounds. IT organizations are processing and storing huge amounts of textual data collected from various sources, such as user actions, leads, searches, shopping data, page views, page hits, and various other forms of user interactions. Search algorithms are used for parsing large texts to extract meaningful pertinent information. Regular expressions are the backbone of many such search algorithms. </p>
<p class="calibre1">Regular expressions (or regex in short) are everywhere these days. All the modern programming languages are shipped with a regex module or library to allow programmers to write regex-based programs. Regular expressions are a powerful tool in the programmer's toolbox and allow pattern matching. They are also used for manipulating text and data. This book will provide you with the know-how (and practical examples) to solve real-world problems using regex in Java. </p>
<p class="calibre1">This easy-to-follow regex book is a great place for you to familiarize yourself with the core concepts of regular expressions and to master their implementation with the new features of Java 9. You will learn to match, extract, and transform text by matching specific words, characters, and patterns. Readers will learn how to write efficient regular expressions for solving day-to-day problems involving text-based data. </p>
<p class="calibre1"><a id="p17"/><b class="calibre3">What this book covers</b></p>
<p class="calibre1"><a href="#p27">Chapter 1</a>,  <i class="calibre4">Getting Started with Regular Expressions</i>, teaches what regular expressions are, what problems are best solved using regular expressions, and the rules to follow while writing them. </p>
<p class="calibre1"><a href="#p42">Chapter 2</a>,  <i class="calibre4">Understanding the Core Constructs of Java Regular Expressions</i>, covers quantifiers, anchors, boundary matchers, and all the available character classes and properties in Java. We will also learn Unicode text matching using regex in Java. </p>
<p class="calibre1"><a href="#p76">Chapter 3</a>,  <i class="calibre4">Working with Groups, Capturing, and References</i>, explores how to match and capture text in regex, the various types of groups available to us, the naming and numbering of a captured group, and how we should use back-reference for the captured groups. </p>
<p class="calibre1"><a href="#p91">Chapter 4</a>,  <i class="calibre4">Regular Expression Programming Using Java String and Scanner APIs</i>, introduces Java regex using Java String methods, and we will move on to regex capabilities in the Java Scanner API. </p>
<p class="calibre1"><a href="index_split_001.html#p111">Chapter 5</a>,  <i class="calibre4">Introduction to Java Regular Expression APIs - Pattern and Matcher</i> <i class="calibre4">Classes</i>, discusses the dedicated Java APIs, java.util.regex.Pattern and java.util.regex.Matcher, for complete regex capabilities. </p>
<p class="calibre1"><a href="index_split_001.html#p133">Chapter 6</a>,  <i class="calibre4">Exploring Zero-width Assertions, Lookarounds, and Atomic Groups</i>, focuses on zero-width assertions in regex. The chapter covers various zero-width assertions and their usages. We will then move on to learn the important topic of lookarounds in regex. </p>
<p class="calibre1"><a href="index_split_001.html#p156">Chapter 7</a>,  <i class="calibre4">Understanding the Union, Intersection, and Subtraction of Character</i> <i class="calibre4">Classes</i>, says that the Java language has added the features of using the intersection and union of character classes in regex. This chapter covers these features. </p>
<p class="calibre1"><a href="index_split_001.html#p166">Chapter 8</a>,  <i class="calibre4">Regular Expression Pitfalls, Optimization, and Performance Improvements</i>, explains how to test and optimize a poorly performing regex and various other performance tips. </p>
<p class="calibre1"><a id="p18"/><b class="calibre3">What you need for this book</b></p>
<p class="calibre1">The software in this book was tested on Java version 9 on Ubuntu version 16.10. </p>
<p class="calibre1">However, all the examples can also be run on the Windows and macOS X operating systems. </p>
<p class="calibre1"><a id="p19"/><b class="calibre3">Who this book is for</b></p>
<p class="calibre1">This book is for Java developers who would like to understand and use regular expressions. If you are dealing with text processing problems, such as text validation, searching, and text manipulation, then learning regex is very important for you to make your job easier. This book does not expect readers to have any prior regex knowledge, since the book will cover every aspect of regex, starting from the absolute basics of regex. However, a basic knowledge of Java is assumed in order to be able to write and execute the example programs provided in the book. </p>
<p class="calibre1"><a id="p20"/><img src="index-20_1.jpg" alt="Image 4" class="calibre2"/></p>
<p class="calibre1"><img src="index-20_2.jpg" alt="Image 5" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Conventions</b></p>
<p class="calibre1">In this book, you will find a number of text styles that distinguish between different kinds of information. Here are some examples of these styles and an explanation of their meaning. </p>
<p class="calibre1">Code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles are shown as follows: "The next lines of code read the link and assign it to the to the BeautifulSoup function." </p>
<p class="calibre1">A block of code is set as follows:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">public class StringMatches </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">}</p>
<p class="calibre1">When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:</p>
<p class="calibre1">[default]<b class="calibre3"> </b></p>
<p class="calibre1">exten =&gt; s,1,Dial(Zap/1|30)<b class="calibre3"> </b></p>
<p class="calibre1"><b class="calibre3">exten =&gt; s,2,Voicemail(u100) </b></p>
<p class="calibre1"><b class="calibre3">exten =&gt; s,102,Voicemail(b100) </b></p>
<p class="calibre1">exten =&gt; i,1,Voicemail(s0)<b class="calibre3"> </b></p>
<p class="calibre1">Any command-line input or output is written as follows:</p>
<p class="calibre1"><b class="calibre3">C:\Python34\Scripts&gt; pip install -upgrade pip</b></p>
<p class="calibre1"><b class="calibre3">C:\Python34\Scripts&gt; pip install pandas</b></p>
<p class="calibre1"><b class="calibre3">New terms</b> and <b class="calibre3">important words</b> are shown in bold. Words that you see on the screen, for example, in menus or dialog boxes, appear in the text like this: "In order to download new modules, we will go to Files | Settings | Project Name | Project Interpreter." </p>
<p class="calibre1"> <i class="calibre4">Warnings or important notes appear like this. </i></p>
<p class="calibre1"> <i class="calibre4">Tips and tricks appear like this. </i></p>
<p class="calibre1"><a id="p21"/><b class="calibre3">Reader feedback</b></p>
<p class="calibre1">Feedback from our readers is always welcome. Let us know what you think about this book-what you liked or disliked. Reader feedback is important for us as it helps us develop titles that you will really get the most out of. </p>
<p class="calibre1">To send us general feedback, simply e-mail feedback@packtpub.com, and mention the book's title in the subject of your message. If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, see our author guide at <a href="http://www.packtpub.com/authors">www.packtpub.com/authors. </a></p>
<p class="calibre1"><a id="p22"/><b class="calibre3">Customer support</b></p>
<p class="calibre1">Now that you are the proud owner of a Packt book, we have a number of things to help you to get the most from your purchase. </p>
<p class="calibre1"><a id="p23"/><b class="calibre3">Downloading the example</b></p>
<p class="calibre1"><b class="calibre3">code</b></p>
<p class="calibre1"><a href="http://www.packtpub.com">You can download the example code files for this book from your account at http://ww</a></p>
<p class="calibre1"><a href="http://www.packtpub.com">w.packtpub.com. If you purchased this book elsewhere, you can visit http://www.packtpub.c</a></p>
<p class="calibre1"><a href="http://www.packtpub.com/support">om/support and register to have the files e-mailed directly to you. </a></p>
<p class="calibre1">You can download the code files by following these steps: 1.  Log in or register to our website using your e-mail address and password. </p>
<p class="calibre1">2.  Hover the mouse pointer on the SUPPORT tab at the top. </p>
<p class="calibre1">3.  Click on Code Downloads &amp; Errata. </p>
<p class="calibre1">4.  Enter the name of the book in the Search box. </p>
<p class="calibre1">5.  Select the book for which you're looking to download the code files. </p>
<p class="calibre1">6.  Choose from the drop-down menu where you purchased this book from. </p>
<p class="calibre1">7.  Click on Code Download. </p>
<p class="calibre1">Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p>
<p class="calibre1">WinRAR / 7-Zip for Windows</p>
<p class="calibre1">Zipeg / iZip / UnRarX for Mac</p>
<p class="calibre1">7-Zip / PeaZip for Linux</p>
<p class="calibre1"><a href="https://github.com/PacktPublishing/Java-9-Regular-Expressions">The code bundle for the book is also hosted on GitHub at https://github.com/PacktPublishin</a></p>
<p class="calibre1"><a href="https://github.com/PacktPublishing/Java-9-Regular-Expressions">g/Java-9-Regular-Expressions. We also have other code bundles from our rich catalog of</a></p>
<p class="calibre1">books and videos available at<a href="https://github.com/PacktPublishing/"> https://github.com/PacktPublishing/. </a> Check them out! </p>
<p class="calibre1"><a id="p24"/><b class="calibre3">Errata</b></p>
<p class="calibre1">Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you find a mistake in one of our books-maybe a mistake in the text or the code-we would be grateful if you could report this to us. By doing so, you can save other readers from frustration and help us improve subsequent versions of this book. If you find any errata, please report them by visiting<a href="http://www.packtpub.com/submit-errata"> http://www.packtpub.com/submit-errata, </a></p>
<p class="calibre1">selecting your book, clicking on the Errata Submission Form link, and entering the details of your errata. Once your errata are verified, your submission will be accepted and the errata will be uploaded to our website or added to any list of existing errata under the Errata section of that title. </p>
<p class="calibre1"><a href="https://www.packtpub.com/books/content/support">To view the previously submitted errata, go to https://www.packtpub.com/books/content/supp</a></p>
<p class="calibre1"><a href="https://www.packtpub.com/books/content/support">ort and enter the name of the book in the search field. The required information will</a></p>
<p class="calibre1">appear under the Errata section. </p>
<p class="calibre1"><a id="p25"/><b class="calibre3">Piracy</b></p>
<p class="calibre1">Piracy of copyrighted material on the Internet is an ongoing problem across all media. </p>
<p class="calibre1">At Packt, we take the protection of our copyright and licenses very seriously. If you come across any illegal copies of our works in any form on the Internet, please provide us with the location address or website name immediately so that we can pursue a remedy. </p>
<p class="calibre1">Please contact us at copyright@packtpub.com with a link to the suspected pirated material. </p>
<p class="calibre1">We appreciate your help in protecting our authors and our ability to bring you valuable content. </p>
<p class="calibre1"><a id="p26"/><b class="calibre3">Questions</b></p>
<p class="calibre1">If you have a problem with any aspect of this book, you can contact us at questions@packtpub.com, and we will do our best to address the problem. </p>
<p class="calibre1"><a id="p27"/><b class="calibre3">Getting Started with Regular</b></p>
<p class="calibre1"><b class="calibre3">Expressions</b></p>
<p class="calibre1">In this chapter, you will be introduced to regular expressions (or regex in short). You will learn about some real-world problems that can be solved by using regular expressions and the basic building blocks of regular expressions. </p>
<p class="calibre1">We will be covering the following topics in this chapter: Introduction to regular expressions</p>
<p class="calibre1">A brief history of regular expressions</p>
<p class="calibre1">The various flavors of regular expressions</p>
<p class="calibre1">What type of problems need regular expressions to solve</p>
<p class="calibre1">The basic rules of writing regular expressions</p>
<p class="calibre1">Standard regular expression meta characters</p>
<p class="calibre1">Basic regular expression examples</p>
<p class="calibre1"><a id="p28"/><b class="calibre3">Introduction to regular</b></p>
<p class="calibre1"><b class="calibre3">expressions</b></p>
<p class="calibre1">Regular expression (or in short regex) is a very useful tool that is used to describe a search pattern for matching the text. Regex is nothing but a sequence of some characters that defines a search pattern. Regex is used for parsing, filtering, validating, and extracting meaningful information from large text, such as logs and output generated from other programs. </p>
<p class="calibre1">We find regular expressions in day-to-day use on many websites. For example, while searching for your favorite recipe on search engines, while filling up forms and entering data such as username and passwords, and so on. While setting up a password on many sites, we encounter password validation errors, such as password must contain one digit or at least one uppercase letter or at least one special character, and so on. All these checks can be done using regular expressions. A few more typical examples of regular expressions are validating phone numbers or validating postal/zip/pin codes. </p>
<p class="calibre1"><a id="p29"/><b class="calibre3">A bit of history of regular</b></p>
<p class="calibre1"><b class="calibre3">expressions</b></p>
<p class="calibre1">Renowned mathematician Stephen Kleene built a model in the year 1956 using finite automata for simple algebra. He described regular languages using his mathematical notation called  <i class="calibre4">regular sets</i>. Computer programmers started using regular expressions in the 1970s when the Unix operating system and some of its text editors and text processing utilities such as ed, sed, emacs, lex, vi, grep, awk, and so on were built. </p>
<p class="calibre1">Regular expressions gained more popularity with the arrival of Perl and Tcl scripting languages in the 1980s and 1990s. Since then, all the popular programming languages, such as Java, Python, Ruby, R, PHP, and .NET have built very good support of regular expressions. </p>
<p class="calibre1"><a id="p30"/><b class="calibre3">Various flavors of regular</b></p>
<p class="calibre1"><b class="calibre3">expressions</b></p>
<p class="calibre1">All the programming and scripting languages have built-in support for regular expressions these days. The basic rules to define and execute regular expressions are pretty much the same across all the languages. However, these regex implementations have their own flavors that differ from each other at the advanced level. We will cover regular expressions using Java in this book. </p>
<p class="calibre1">Some of the popular flavors of regular expressions are as follows:</p>
<p class="calibre1">.NET</p>
<p class="calibre1">Java</p>
<p class="calibre1">Perl</p>
<p class="calibre1">PCRE (PHP)</p>
<p class="calibre1">JavaScript</p>
<p class="calibre1">VBScript</p>
<p class="calibre1">Python</p>
<p class="calibre1">R</p>
<p class="calibre1">Ruby</p>
<p class="calibre1">std::regex</p>
<p class="calibre1">boost::regex</p>
<p class="calibre1"><b class="calibre3">Basic Regular Expressions</b> (<b class="calibre3">BRE</b>) - used by Unix utilities ed, vi, sed, grep, and so on</p>
<p class="calibre1"><b class="calibre3">Extended Regular Expressions</b> (<b class="calibre3">ERE</b>) - used by Unix utilities sed, grep, awk, and so on</p>
<p class="calibre1"><a id="p31"/><b class="calibre3">What type of problems need</b></p>
<p class="calibre1"><b class="calibre3">regular expressions to solve</b></p>
<p class="calibre1">Some programmers wonder why they even need to learn regular expressions. Here are some use cases:</p>
<p class="calibre1">While searching for some text at times, there are cases where we don't know the value of the text upfront. We just know some rules or patterns of the text. For example, searching for a MAC address in a log message, searching for IP</p>
<p class="calibre1">address in a web server access log, or searching for a 10-digit mobile number that may be optionally preceded by  <i class="calibre4">0</i> or  <i class="calibre4">+&lt;2 digit country code&gt;. </i></p>
<p class="calibre1">Sometimes, the length of the text we are trying to extract is unknown, for example, searching URLs that start with http:// or https:// in a CSV file. </p>
<p class="calibre1">Sometimes, we need to split a given text on delimiters of a variable type and length and generate tokens. </p>
<p class="calibre1">Sometimes, we need to extract text that falls between two or more search patterns. </p>
<p class="calibre1">Often, we need to validate the various forms of user inputs, such as bank account number, passwords, usernames, credit card info, phone number, date of birth, and so on. </p>
<p class="calibre1">There are situations where you only want to capture all the repeated words from a line. </p>
<p class="calibre1">To convert input text into certain predefined formats, such as inserting a comma after every three digits or removing commas inside parentheses only. </p>
<p class="calibre1">To do a global search replace while skipping all the escaped characters. </p>
<p class="calibre1"><a id="p32"/><b class="calibre3">The basic rules of regular</b></p>
<p class="calibre1"><b class="calibre3">expressions</b></p>
<p class="calibre1">Many of you are familiar with wild cards (in the Unix world, it is called <b class="calibre3">glob pattern</b>) matching of text. Here:</p>
<p class="calibre1"><b class="calibre3">? </b> matches any single character</p>
<p class="calibre1"><b class="calibre3">*</b> matches any sequence of characters</p>
<p class="calibre1"><b class="calibre3">[abc]</b> matches any one character inside square brackets, so it will match a, b, or c The regular expression pattern goes many steps farther than wild cards, where one can set many rules in a regex pattern, such as the following: Match a character or a group of characters optionally (0 or 1 times) Use quantifiers in regex patterns to match variable length text Use a character class to match one of the listed characters or match a range of characters</p>
<p class="calibre1">Use a negated character class to match any character except those matched by the character class</p>
<p class="calibre1">Match only certain character categories, such as match only digits, only upper case letters, or only punctuation characters</p>
<p class="calibre1">Match a character or a group of characters for a specific length. </p>
<p class="calibre1">Match a length range, such as allow only six to 10 digits in the input or match an input of a minimum of eight characters</p>
<p class="calibre1">Use Boolean "OR" in an alternation to match one of the few alternative options Use groups in regex patterns and capture substrings that we want to extract or replace from a given input</p>
<p class="calibre1">Alter the behavior of matching by keeping it greedy (eager), lazy (reluctant), or possessive</p>
<p class="calibre1">Use back references and forward references of groups that we capture Use zero-width assertions such as the following:</p>
<p class="calibre1">Start and end anchors</p>
<p class="calibre1">Word boundary</p>
<p class="calibre1">Lookahead and lookbehind assertions</p>
<p class="calibre1">Start a match from the end of a previous match</p>
<p class="calibre1">For example, in a regex to match a or b we can use the following alternation: a|b</p>
<p class="calibre1">To match one or more instances of the digit 5, we can use the following: 5+</p>
<p class="calibre1">To match any substring that starts with p and ends with w, we can use the following: p.*w</p>
<p class="calibre1"><a id="p33"/><b class="calibre3">Constructs of the standard</b></p>
<p class="calibre1"><b class="calibre3">regular expression and meta</b></p>
<p class="calibre1"><b class="calibre3">characters</b></p>
<p class="calibre1">Let's get familiar with core constructs of regular expressions and some reserve meta characters that have a special meaning in regular expressions. We shall cover these constructs in detail in the coming chapters:</p>
<p class="calibre1"><b class="calibre3">Symbol</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">Example</b></p>
<p class="calibre1"><b class="calibre3">. </b> (dot or</p>
<p class="calibre1">Matches any character other</p>
<p class="calibre1">Matches <b class="calibre3">#</b>, <b class="calibre3">@</b>, <b class="calibre3">A</b>, <b class="calibre3">f</b>, <b class="calibre3">5</b>, or <b class="calibre3">. </b></p>
<p class="calibre1">period)</p>
<p class="calibre1">than newline. </p>
<p class="calibre1"><b class="calibre3">*</b> matches zero or more</p>
<p class="calibre1">occurrences of the</p>
<p class="calibre1">m* matches 0 or more</p>
<p class="calibre1"><b class="calibre3">*</b> (asterisk)</p>
<p class="calibre1">preceding character or</p>
<p class="calibre1">occurrences of the letter <b class="calibre3">m. </b></p>
<p class="calibre1">group. </p>
<p class="calibre1"><b class="calibre3">+</b> matches one or more</p>
<p class="calibre1"><b class="calibre3">m+</b> matches one or more</p>
<p class="calibre1"><b class="calibre3">+</b> (plus)</p>
<p class="calibre1">occurrences of the</p>
<p class="calibre1">occurrences of the letter <b class="calibre3">m. </b></p>
<p class="calibre1">preceding element. </p>
<p class="calibre1"><b class="calibre3">? </b> means optional match. It</p>
<p class="calibre1">is used to match zero or one</p>
<p class="calibre1">occurrence of the preceding</p>
<p class="calibre1"><b class="calibre3">? </b> (question</p>
<p class="calibre1"><b class="calibre3">nm? </b> means match <b class="calibre3">n</b> or <b class="calibre3">nm</b>, as</p>
<p class="calibre1">element. It is also used for</p>
<p class="calibre1">mark)</p>
<p class="calibre1"><b class="calibre3">m</b> is an <b class="calibre3">optional</b> match here. </p>
<p class="calibre1">lazy matching (which will</p>
<p class="calibre1">be covered in the coming</p>
<p class="calibre1">chapters). </p>
<p class="calibre1"><b class="calibre3">|</b> means alternation. It is</p>
<p class="calibre1"><b class="calibre3">m|n|p</b> means match either the</p>
<p class="calibre1"><b class="calibre3">|</b> (pipe)</p>
<p class="calibre1">used to match one of the</p>
<p class="calibre1">letter <b class="calibre3">m</b> or the letter <b class="calibre3">n</b> or the</p>
<p class="calibre1">elements separated by |</p>
<p class="calibre1">letter p</p>
<p class="calibre1">^m matches m only when it is</p>
<p class="calibre1">the first character of the</p>
<p class="calibre1">string that we are testing</p>
<p class="calibre1"><b class="calibre3">^</b> is called anchor, that</p>
<p class="calibre1">against the regular</p>
<p class="calibre1"><b class="calibre3">^</b> (cap)</p>
<p class="calibre1">matches start of the line</p>
<p class="calibre1">expression. Also, note that</p>
<p class="calibre1">you do not use ^ in the</p>
<p class="calibre1">middle of a regular</p>
<p class="calibre1">expression. </p>
<p class="calibre1"><b class="calibre3">$</b> is called anchor that</p>
<p class="calibre1"><b class="calibre3">$</b> (dollar)</p>
<p class="calibre1"><b class="calibre3">m$</b> matches m only at line end. </p>
<p class="calibre1">matches line end. </p>
<p class="calibre1"><b class="calibre3">\b</b></p>
<p class="calibre1">Alphabets, numbers, and</p>
<p class="calibre1"><b class="calibre3">\bjava\b</b> matches the word, java . </p>
<p class="calibre1"><a id="p34"/>(backslash</p>
<p class="calibre1">underscore are considered</p>
<p class="calibre1">So, it will not match javascript</p>
<p class="calibre1">followed</p>
<p class="calibre1">word characters. <b class="calibre3">\b</b> asserts</p>
<p class="calibre1">since the word, javascript, will</p>
<p class="calibre1">by the</p>
<p class="calibre1">word boundary, which is the</p>
<p class="calibre1">fail to assert \b after java in the</p>
<p class="calibre1">letter b)</p>
<p class="calibre1">position just before and</p>
<p class="calibre1">regex. </p>
<p class="calibre1">after a word. </p>
<p class="calibre1"><b class="calibre3">\B</b></p>
<p class="calibre1">For the input text,  <i class="calibre4">abc</i>, </p>
<p class="calibre1">(backslash</p>
<p class="calibre1"><b class="calibre3">\B</b> asserts true where <b class="calibre3">\b</b></p>
<p class="calibre1">followed</p>
<p class="calibre1">doesn't, that is, between two</p>
<p class="calibre1"><b class="calibre3">\B</b> will be asserted at two places:</p>
<p class="calibre1">by</p>
<p class="calibre1">word characters. </p>
<p class="calibre1">uppercase</p>
<p class="calibre1">1.  Between  <i class="calibre4">a</i> and  <i class="calibre4">b</i>. </p>
<p class="calibre1">B)</p>
<p class="calibre1">2.  Between  <i class="calibre4">b</i> and  <i class="calibre4">c</i>. </p>
<p class="calibre1"><b class="calibre3">(...)</b> a sub-</p>
<p class="calibre1">This is for grouping a part</p>
<p class="calibre1"><b class="calibre3">m(ab)*t</b> matches m, followed</p>
<p class="calibre1">pattern</p>
<p class="calibre1">of text that can be used to</p>
<p class="calibre1">by zero or more occurrences</p>
<p class="calibre1">inside</p>
<p class="calibre1">capture a certain substring</p>
<p class="calibre1">of the substring, <b class="calibre3">ab</b>, followed</p>
<p class="calibre1">round</p>
<p class="calibre1">or for setting precedence. </p>
<p class="calibre1">by <b class="calibre3">t</b>. </p>
<p class="calibre1">parentheses</p>
<p class="calibre1">A quantifier range to match</p>
<p class="calibre1"><b class="calibre3">mp{2,4}</b> matches m followed <b class="calibre3">2</b></p>
<p class="calibre1">the preceding element</p>
<p class="calibre1">{min,max}</p>
<p class="calibre1">to <b class="calibre3">4</b> occurrences of the letter</p>
<p class="calibre1">between the minimum and</p>
<p class="calibre1">p. </p>
<p class="calibre1">the maximum number. </p>
<p class="calibre1">This is called a character</p>
<p class="calibre1"><b class="calibre3">[A-Z]</b> matches any uppercase</p>
<p class="calibre1"><b class="calibre3">[...]</b></p>
<p class="calibre1">class. </p>
<p class="calibre1">English alphabet. </p>
<p class="calibre1"><b class="calibre3">\d</b></p>
<p class="calibre1">(backslash</p>
<p class="calibre1"><b class="calibre3">\d</b> matches any digit in the 0-</p>
<p class="calibre1">followed</p>
<p class="calibre1">This will match any digit. </p>
<p class="calibre1">9 range. </p>
<p class="calibre1">by the</p>
<p class="calibre1">letter d)</p>
<p class="calibre1"><b class="calibre3">\D</b></p>
<p class="calibre1">(backslash</p>
<p class="calibre1">followed</p>
<p class="calibre1">This matches any character</p>
<p class="calibre1"><b class="calibre3">\D</b> matches a, $, or _. </p>
<p class="calibre1">by</p>
<p class="calibre1">that is not a digit. </p>
<p class="calibre1">uppercase</p>
<p class="calibre1">D)</p>
<p class="calibre1"><b class="calibre3">\s</b></p>
<p class="calibre1">(backslash</p>
<p class="calibre1">Matches any whitespace, </p>
<p class="calibre1">followed</p>
<p class="calibre1">including tab, space, or</p>
<p class="calibre1"><b class="calibre3">\s</b> matches <b class="calibre3">[ \t\n]</b>. </p>
<p class="calibre1">by the</p>
<p class="calibre1">newline. </p>
<p class="calibre1">letter s)</p>
<p class="calibre1"><b class="calibre3">\S</b></p>
<p class="calibre1">(backslash</p>
<p class="calibre1">followed</p>
<p class="calibre1">Matches any non-</p>
<p class="calibre1"><b class="calibre3">\S</b> matches the opposite of \s</p>
<p class="calibre1">by</p>
<p class="calibre1">whitespace. </p>
<p class="calibre1">uppercase</p>
<p class="calibre1">S)</p>
<p class="calibre1"><a id="p35"/><b class="calibre3">\w</b></p>
<p class="calibre1"><b class="calibre3">\w</b> will match [a-zA-Z0-9_], so</p>
<p class="calibre1">(backslash</p>
<p class="calibre1">Matches any word character</p>
<p class="calibre1">it will match any of these</p>
<p class="calibre1">followed</p>
<p class="calibre1">that means all alphanumeric</p>
<p class="calibre1">strings: "  <i class="calibre4">abc</i>", "  <i class="calibre4">a123</i>", or by the</p>
<p class="calibre1">characters or underscore. </p>
<p class="calibre1">"  <i class="calibre4">pq_12_ABC</i>" </p>
<p class="calibre1">letter w)</p>
<p class="calibre1">Matches any non-word</p>
<p class="calibre1"><b class="calibre3">\W</b></p>
<p class="calibre1">character, including</p>
<p class="calibre1">(backslash</p>
<p class="calibre1">whitespaces. In regex, any</p>
<p class="calibre1">It will match any of these</p>
<p class="calibre1">followed</p>
<p class="calibre1">character that is not</p>
<p class="calibre1">strings: "  <i class="calibre4">+/=</i>", "  <i class="calibre4">$</i>", or "  <i class="calibre4">!~</i>" </p>
<p class="calibre1">by the</p>
<p class="calibre1">matched by \w can be</p>
<p class="calibre1">letter W)</p>
<p class="calibre1">matched using \W. </p>
<p class="calibre1"><a id="p36"/><b class="calibre3">Some basic regular</b></p>
<p class="calibre1"><b class="calibre3">expression examples</b></p>
<p class="calibre1">Let's look at some basic examples of regular expressions: ab*c</p>
<p class="calibre1">This will match a, followed by zero or more b, followed by c. </p>
<p class="calibre1">ab+c</p>
<p class="calibre1">This will match a followed by one or more b, followed by c. </p>
<p class="calibre1">ab?c</p>
<p class="calibre1">This will match a followed by zero or one b, followed by c. Thus, it will match both abc or ac. </p>
<p class="calibre1">^abc$</p>
<p class="calibre1">This will match abc in a line, and the line must not have anything other than the string abc due to the use of the start and end anchors on either side of the regex. </p>
<p class="calibre1">a(bc)*z</p>
<p class="calibre1">This will match a, followed by zero or more occurrences of the string bc, followed by z. Thus, it will match the following strings: az, abcz, abcbcz, abcbcbcz, and so on. </p>
<p class="calibre1">ab{1,3}c</p>
<p class="calibre1">This will match a, followed by one to three occurrences of b, followed by c. Thus, it will match following strings: abc, abbc, and abbbc. </p>
<p class="calibre1">red|blue</p>
<p class="calibre1">This will match either the string red or the string blue. </p>
<p class="calibre1">\b(cat|dog)\b</p>
<p class="calibre1">This will match either the string cat or the string dog, ensuring both cat and dog must be complete words; thus, it will <b class="calibre3">fail</b> the match if the input is cats or dogs. </p>
<p class="calibre1">[0-9]</p>
<p class="calibre1">This is a character class with a character range. The preceding example will match a digit between 0 and 9. </p>
<p class="calibre1">[a-zA-Z0-9]</p>
<p class="calibre1">This is a character class with a character range. The preceding example will match any alpha-numeric character. </p>
<p class="calibre1">^\d+$</p>
<p class="calibre1">This regex will match an input containing only one or more digits. </p>
<p class="calibre1"><a id="p37"/><img src="index-37_1.jpg" alt="Image 6" class="calibre2"/></p>
<p class="calibre1">^\d{4,8}$</p>
<p class="calibre1">This regex will allow an input containing four to eight digits only. For example, 1234, 12345, 123456, and 12345678 are valid inputs. </p>
<p class="calibre1">^\d\D\d$</p>
<p class="calibre1">This regex not only allows only one digit at the start and end but also enforces that between these two digits there must be one non-digit character. For example, 1-5, 3:8, 8X2, and so on are valid inputs. </p>
<p class="calibre1">^\d+\.\d+$</p>
<p class="calibre1">This regex matches a floating point number. For example, 1.23, 1548.567, and 7876554.344 are valid inputs. </p>
<p class="calibre1">.+</p>
<p class="calibre1">This matches any character one or more times. For example, qwqewe, 12233, or f5^h_=!bg are all valid inputs:</p>
<p class="calibre1">^\w+\s+\w+$</p>
<p class="calibre1">This matches a word, followed by one or more whitespaces, followed by another word in an input. For example, hello word, John Smith, and United Kingdom will be matched using this regex. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Engine</b> is a term often used for an underlying module that evaluates</i> <i class="calibre4">the provided regular expression and matches the input string. </i></p>
<p class="calibre1"><a id="p38"/><b class="calibre3">Eager matching</b></p>
<p class="calibre1">At this point, it is important to understand one important behavior of regular expression engines, called eagerness. A regular expression engine performs a match operation from left to right in an input string. While matching a regex pattern against the input string, the regex engine moves from left to right and is always eager to complete a match, even though there are other alternative ways in the regular expression to complete the match. Once a substring is matched, it stops proceeding further and returns the match. Only when a character position fails to match all the possible permutations of the regular expression, then the regex engine moves character by character to attempt a match at the next position in the input string. While evaluating a regex pattern, the regex engine may move backwards (backtrack) one position at a time to attempt matching. </p>
<p class="calibre1"><a id="p39"/><b class="calibre3">The effect of eager matching</b></p>
<p class="calibre1"><b class="calibre3">on regular expression</b></p>
<p class="calibre1"><b class="calibre3">alternation</b></p>
<p class="calibre1">This regular expression engine behavior may return unexpected matches in alternation if alternations are not ordered carefully in the regex pattern. </p>
<p class="calibre1">Take an example of this regex pattern, which matches the strings white or whitewash: white|whitewash</p>
<p class="calibre1">While applying this regex against an input of  <i class="calibre4">whitewash</i>, the regex engine finds that the first alternative white matches the  <i class="calibre4">white</i> substring of the input string  <i class="calibre4">whitewash</i>, hence, the regex engine stops proceeding further and returns the match as white. </p>
<p class="calibre1">Note that our regex pattern has a better second alternative as whitewash, but due to the regex engine's eagerness to complete and return the match, the first alternative is returned as a match and the second alternative is ignored. </p>
<p class="calibre1">However, consider swapping the positions of the third and fourth alternatives in our regex pattern to make it as follows:</p>
<p class="calibre1">whitewash|white</p>
<p class="calibre1">If we apply this against the same input,  <i class="calibre4">whitewash</i>, then the regex engine correctly returns the match as whitewash. </p>
<p class="calibre1">We can also use anchors or boundary matchers in our regular expressions to make it match a complete word. Any of the following two patterns will match and return whitewash as a match:</p>
<p class="calibre1">^(white|whitewash)$</p>
<p class="calibre1">\b(white|whitewash)\b</p>
<p class="calibre1">Let's take a look at a more interesting example, which attempts to match a known literal string "  <i class="calibre4">cat &amp; rat" </i> or a complete word in the input, using the following pattern:</p>
<p class="calibre1">\b(\w+|cat &amp; rat)\b</p>
<p class="calibre1">If the input string is  <i class="calibre4">story of cat &amp; rat</i>, and we apply our regex pattern repeatedly, then the following four matched substrings will be returned:</p>
<p class="calibre1">1. story</p>
<p class="calibre1">2. of</p>
<p class="calibre1">3. cat</p>
<p class="calibre1">4. rat</p>
<p class="calibre1">It is because the regex engine is eagerly using the first alternative pattern \w+ to match a complete word and is returning all the matched words. The engine never attempts a second alternative of the literal string, cat &amp; rat, because a successful match is always found using the first alternative. However, let's change the regex pattern to the</p>
<p class="calibre1"><a id="p40"/>following:</p>
<p class="calibre1">\b(cat &amp; rat|\w+)\b</p>
<p class="calibre1">If we apply this regex on the same sting,  <i class="calibre4">story of cat &amp; rat</i>, and we apply our regex pattern repeatedly, then the following three matched substrings will be returned: 1. story</p>
<p class="calibre1">2. of</p>
<p class="calibre1">3. cat &amp; rat</p>
<p class="calibre1">This is because now cat &amp; rat is the first alternative and when the regex engine moves to a position before the letter c in the input, it is able to match and return a successful match using the first alternative. </p>
<p class="calibre1"><a id="p41"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, you were introduced to regular expressions with a bit of history and their flavors. You learnt some use cases where regex are needed. Finally, we covered the basic rules and building blocks of writing regex, with a few examples. You also learnt the eager-matching behavior of the regex engine and how it may impact matching in alternations. </p>
<p class="calibre1">In the next chapter, we will go a level deeper and cover the core concepts of regex in detail, such as quantifiers, lazy vs greedy matching, anchors, negated character classes, Unicode and predefined character classes, special escape sequences, and the rules of escaping inside a character class. </p>
<p class="calibre1"><a id="p42"/><b class="calibre3">Understanding the Core</b></p>
<p class="calibre1"><b class="calibre3">Constructs of Java Regular</b></p>
<p class="calibre1"><b class="calibre3">Expressions</b></p>
<p class="calibre1">Using Java as a regular expression flavor, in this chapter, we will go a bit deeper and learn in detail about anchors, quantifiers, boundary matchers, all the available character classes, negated character classes, predefined character classes, and character classes escaping rules, using Java as a reference point. You will also learn Unicode text matching, using  <i class="calibre4">regular expressions</i> in Java. We will also cover greedy versus non-greedy (lazy matching) and the change of regular expression behavior with lazy matching. </p>
<p class="calibre1">We will cover the following topics in this chapter:</p>
<p class="calibre1">Anchors and quantifiers</p>
<p class="calibre1">Boundary matchers</p>
<p class="calibre1">Character classes</p>
<p class="calibre1">Regex escaping rules</p>
<p class="calibre1">Escaping inside character classes</p>
<p class="calibre1">Negated character classes</p>
<p class="calibre1">Predefined character classes</p>
<p class="calibre1">Unicode characters matching</p>
<p class="calibre1">Greedy quantifiers</p>
<p class="calibre1">Lazy quantifiers</p>
<p class="calibre1">Possessive quantifiers</p>
<p class="calibre1">Various embedded modes in regular expressions and their meaning Enabling/disabling regular expression modes inside the regex</p>
<p class="calibre1"><a id="p43"/><b class="calibre3">Understanding the core</b></p>
<p class="calibre1"><b class="calibre3">constructs of regular</b></p>
<p class="calibre1"><b class="calibre3">expressions</b></p>
<p class="calibre1">Certain special character constructs are allowed literally in Java regular expressions. </p>
<p class="calibre1">Here they are:</p>
<p class="calibre1"><b class="calibre3">Special</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">Character</b></p>
<p class="calibre1"><b class="calibre3">\0c</b></p>
<p class="calibre1">A character with the octal value c</p>
<p class="calibre1"><b class="calibre3">\0cc</b></p>
<p class="calibre1">A character with the octal value cc</p>
<p class="calibre1">A character with the octal value ncc, where n cannot be</p>
<p class="calibre1"><b class="calibre3">\0ncc</b></p>
<p class="calibre1">more than 3</p>
<p class="calibre1"><b class="calibre3">\xhh</b></p>
<p class="calibre1">A character with the hexadecimal value 0xhh</p>
<p class="calibre1"><b class="calibre3">\uhhhh</b></p>
<p class="calibre1">A character with the hexadecimal value 0xhhhh</p>
<p class="calibre1">A character with the hexadecimal value 0xh...h, where h</p>
<p class="calibre1"><b class="calibre3">\x{h...h}</b></p>
<p class="calibre1">must be a valid CODE_POINT</p>
<p class="calibre1"><b class="calibre3">\n</b></p>
<p class="calibre1">Newline character or u000A</p>
<p class="calibre1"><b class="calibre3">\t</b></p>
<p class="calibre1">Tab character or u0009</p>
<p class="calibre1"><b class="calibre3">\r</b></p>
<p class="calibre1">Carriage return character or u000D</p>
<p class="calibre1"><b class="calibre3">\f</b></p>
<p class="calibre1">Form feed character or u000C</p>
<p class="calibre1"><b class="calibre3">\e</b></p>
<p class="calibre1">Escape character or u\u001B</p>
<p class="calibre1"><b class="calibre3">\a</b></p>
<p class="calibre1">Bell character or \u0007</p>
<p class="calibre1"><b class="calibre3">\cn</b></p>
<p class="calibre1">A control character represented by n</p>
<p class="calibre1"><a id="p44"/><b class="calibre3">Quantifiers</b></p>
<p class="calibre1">We briefly looked at quantifiers in the first chapter. Quantifiers allow us to quantify the occurrences of our matches. We can match the input in various ways, such as an optional match, an open-ended range, a closed range, and by using a fixed number. </p>
<p class="calibre1">Let's take a closer look at them, as quantifiers are integral to most of the regular expressions. </p>
<p class="calibre1"><a id="p45"/><img src="index-45_1.jpg" alt="Image 7" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Basic quantifiers</b></p>
<p class="calibre1">The following table lists all the quantifiers available in Java regular expressions: <b class="calibre3">Quantifier</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">m*</b></p>
<p class="calibre1">Match <b class="calibre3">m</b> zero or more times</p>
<p class="calibre1"><b class="calibre3">m+</b></p>
<p class="calibre1">Match <b class="calibre3">m</b> one or more times</p>
<p class="calibre1"><b class="calibre3">m? </b></p>
<p class="calibre1">Match <b class="calibre3">m</b> one or zero times (also called an optional match) <b class="calibre3">m{X}</b></p>
<p class="calibre1">Match <b class="calibre3">m</b> exactly  <i class="calibre4">X</i> times</p>
<p class="calibre1"><b class="calibre3">m{X,}</b></p>
<p class="calibre1">Match <b class="calibre3">m</b>  <i class="calibre4">X</i> or more times</p>
<p class="calibre1"><b class="calibre3">m{X,Y}</b></p>
<p class="calibre1">Match <b class="calibre3">m</b> at least  <i class="calibre4">X</i> and at most  <i class="calibre4">Y</i> times <i class="calibre4">In all the aforementioned cases, <b class="calibre3">m</b> can be a single character or a</i> <i class="calibre4">group of characters. We will discuss grouping in more detail later. </i></p>
<p class="calibre1"><a id="p46"/><img src="index-46_1.jpg" alt="Image 8" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Examples using quantifiers</b></p>
<p class="calibre1">Let's look at few examples to understand these basic quantifiers better. </p>
<p class="calibre1">Which regex pattern should be used to match a two-digit year or a four-digit year? </p>
<p class="calibre1">\d{2}|\d{4}</p>
<p class="calibre1">Which regex pattern should be used to match a signed decimal number? The pattern should also match a signed integer number:</p>
<p class="calibre1">^[+-]?\d*\.?\d+$</p>
<p class="calibre1">Here is the breakup of the preceding regex pattern:</p>
<p class="calibre1">The ^ and $ symbols are the start/end anchors</p>
<p class="calibre1">The [+-]? pattern makes either the + sign or the - sign (optional because of ?) at the start</p>
<p class="calibre1">The \d* pattern matches zero or more digits</p>
<p class="calibre1">The \.? pattern matches an optional dot (.) literally</p>
<p class="calibre1">The \d+ pattern matches one or more digits</p>
<p class="calibre1">The preceding regex will match all of these inputs:</p>
<p class="calibre1">.45</p>
<p class="calibre1">123789</p>
<p class="calibre1">5</p>
<p class="calibre1">123.45</p>
<p class="calibre1">+67.66</p>
<p class="calibre1">-987.34</p>
<p class="calibre1">What would be the regex to match a number that is at least 10 but not more than 9999? </p>
<p class="calibre1">^\d{2,4}$</p>
<p class="calibre1">Since we have a minimum of two digits, 10 is the smallest match, whereas the maximum number of digits allowed is four, and hence, 9999 is the highest match. </p>
<p class="calibre1">What is the regex for an input that has seven digits and that can have + or - at the start? </p>
<p class="calibre1">^[+-]?\d{7}$</p>
<p class="calibre1">The [+-]? pattern makes it an optional match at the start before we match the seven digits using \d{7}. </p>
<p class="calibre1"> <i class="calibre4">The preceding regex can also be written as ^[+-]?[0-9]{7}$, as \d is a</i> <i class="calibre4">shorthand property to match [0-9]</i></p>
<p class="calibre1"><a id="p47"/><b class="calibre3">Greedy versus reluctant</b></p>
<p class="calibre1"><b class="calibre3">(lazy) matching using</b></p>
<p class="calibre1"><b class="calibre3">quantifiers</b></p>
<p class="calibre1">So far, we have discussed all the quantifiers available to us in a regular expression to match fixed-size or variable-length text. These quantifiers are, by default, <b class="calibre3">greedy</b> in nature. Greediness is in terms of their matching. In a regex, quantifiers attempt to match the longest possible text, from left to right. Only when the regex engine fails to complete a match, it moves back in the input text one character at a time, as required, to complete the match. Sometimes, the regex engine moves back and forth multiple times in attempts to complete a match in a complex (nested) regular expression. </p>
<p class="calibre1">So, for example, if the input is pqrstmprt and our regular expression is p.+r, then our match will be from p at the start to the last r, that is, pqrstmpr<b class="calibre3">, </b> not pqr. It is due to the same greediness that was stated earlier, where the regex engine attempts to match the longest possible match when using quantifiers. </p>
<p class="calibre1">Regular expressions also provide a way to change this greedy behavior of the regex engine. If we place a ? ( <i class="calibre4">called the lazy or reluctant quantifier</i>) in front of any of the quantifiers, then the behavior of the regex engine changes from <b class="calibre3">greedy</b> to <b class="calibre3">lazy</b>. With the lazy quantifier in place, the regex engine attempts to match the shortest match, only expanding further as required to complete the match with the remainder of the regex pattern next to the lazy quantifier. </p>
<p class="calibre1">So, in the preceding example, if we use the regex as p.+?r, then our matched text will be pqr, because  <i class="calibre4">pqr</i> is the smallest possible match between p and r. </p>
<p class="calibre1">Here is a list of all the greedy quantifiers and their corresponding lazy quantifiers: <b class="calibre3">Greedy Quantifier</b></p>
<p class="calibre1"><b class="calibre3">Lazy Quantifier</b></p>
<p class="calibre1"><b class="calibre3">m*</b></p>
<p class="calibre1"><b class="calibre3">m*? </b></p>
<p class="calibre1"><b class="calibre3">m+</b></p>
<p class="calibre1"><b class="calibre3">m+? </b></p>
<p class="calibre1"><b class="calibre3">m? </b></p>
<p class="calibre1"><b class="calibre3">m?? </b></p>
<p class="calibre1"><b class="calibre3">m{X}</b></p>
<p class="calibre1"><b class="calibre3">m{X}? </b></p>
<p class="calibre1"><b class="calibre3">m{X,}</b></p>
<p class="calibre1"><b class="calibre3">m{X,}? </b></p>
<p class="calibre1"><b class="calibre3">m{X,Y}</b></p>
<p class="calibre1"><b class="calibre3">m{X,Y}? </b></p>
<p class="calibre1"><a id="p48"/><b class="calibre3">Possessive quantifiers</b></p>
<p class="calibre1">Possessive quantifiers are quantifiers that are greedy when matching text like greedy quantifiers do. Both greedy and possessive quantifiers try to match as many characters as possible. The important difference, however, is that the possessive quantifiers do not backtrack (go back) unlike greedy quantifiers; therefore, it is possible that the regex match fails if the possessive quantifiers go too far. </p>
<p class="calibre1">This table shows all the three types of quantifiers, side by side: <b class="calibre3">Greedy Quantifier</b></p>
<p class="calibre1"><b class="calibre3">Lazy Quantifier</b></p>
<p class="calibre1"><b class="calibre3">Possessive</b> <b class="calibre3">Quantifier</b></p>
<p class="calibre1"><b class="calibre3">m*</b></p>
<p class="calibre1"><b class="calibre3">m*? </b></p>
<p class="calibre1"><b class="calibre3">m*+</b></p>
<p class="calibre1"><b class="calibre3">m+</b></p>
<p class="calibre1"><b class="calibre3">m+? </b></p>
<p class="calibre1"><b class="calibre3">m++</b></p>
<p class="calibre1"><b class="calibre3">m? </b></p>
<p class="calibre1"><b class="calibre3">m?? </b></p>
<p class="calibre1"><b class="calibre3">m?+</b></p>
<p class="calibre1"><b class="calibre3">m{X}</b></p>
<p class="calibre1"><b class="calibre3">m{X}? </b></p>
<p class="calibre1"><b class="calibre3">m{X}+</b></p>
<p class="calibre1"><b class="calibre3">m{X,}</b></p>
<p class="calibre1"><b class="calibre3">m{X,}? </b></p>
<p class="calibre1"><b class="calibre3">m{X,}+</b></p>
<p class="calibre1"><b class="calibre3">m{X,Y}</b></p>
<p class="calibre1"><b class="calibre3">m{X,Y}? </b></p>
<p class="calibre1"><b class="calibre3">m{X,Y}+</b></p>
<p class="calibre1"/>
<p class="calibre1">Let's take an example input string, a1b5, and see the behavior of the greedy, lazy, and possessive quantifiers. </p>
<p class="calibre1">If we apply a regex using the greedy quantifier, \w+\d, then it will match a1b (the longest match before backtracking starts) using \w+, and 5 will be matched using \d; thus, the full match will be a1b5. </p>
<p class="calibre1">Now, if we apply a regex using the non-greedy quantifier, \w+?\d, then it will match a (the shortest match before expanding starts) using \w+?, and then the adjacent digit 1</p>
<p class="calibre1">will be matched using \d. Thus, the first full match will be a1. If we let the regex execute again, then it will find another match, b5. </p>
<p class="calibre1">Finally, if we apply a regex using the possessive quantifier, \w++\d, then it will match all the characters a1b5 (the longest possible match without giving back) using \w++ . </p>
<p class="calibre1">Due to this, \d remains unmatched, and hence the regex fails to find any match. </p>
<p class="calibre1">Let's take another example. The requirement is to match a string that starts with lowercase English alphabets or hyphen. The string can have any character after the alphabets/hyphens, except a colon. There can be any number of any characters of any length after the colon until the end. </p>
<p class="calibre1">An example of a valid input is as-df999 and that of an invalid input is asdf-:123. </p>
<p class="calibre1">Now, let's try solving this regex problem using a greedy quantifier regex:</p>
<p class="calibre1">^[a-z-]+[^:].*$</p>
<p class="calibre1">Unfortunately, this is not the right regex pattern because this regex will match both</p>
<p class="calibre1"><a id="p49"/>the aforementioned valid and invalid inputs. This is because of the backtracking behavior of the regex engine in greedy quantifiers. The [a-z-]+ pattern will find the longest possible match in the form of asdf-, but due to the negated character class pattern [^:] , the regex engine will backtrack one position to asdf and will match the next  <i class="calibre4">hyphen</i> for [^:]. All the remaining text, that is, :123, will be matched using .*. </p>
<p class="calibre1">Let's try to solve this regex problem using the following possessive quantifier regex:</p>
<p class="calibre1">^[a-z-]++[^:].*$</p>
<p class="calibre1">This regex pattern will still match our valid input, but it will fail to match an invalid input because there is no backtracking in possessive quantifiers; hence, the regex engine will not go back any position after matching asdf- in the second example string. Since the next character is a colon and our regex sub-pattern is [^:], the regex engine will stop matching and correctly declare our invalid input a failed match. </p>
<p class="calibre1">Possessive quantifiers are good for the performance of the underlying regex engine because the engine does not have to keep any backtracking information in memory. </p>
<p class="calibre1">The performance increase is even more when a regex fails to match because possessive quantifiers fail faster. So, remember that the benefit of possessive quantifiers is to improve the regex performance, especially when using nested quantifiers. </p>
<p class="calibre1"><a id="p50"/><img src="index-50_1.jpg" alt="Image 9" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Boundary constructs</b></p>
<p class="calibre1">Boundary constructs allow us to specify where our matches should start or stop by restricting our matches to certain boundaries. We avoid matching unwanted text by adding restrictions to the start and stop positions of the matching text using boundary matchers. Here are all the boundary constructs available in Java regular expressions: <b class="calibre3">Boundary</b></p>
<p class="calibre1"><b class="calibre3">Matcher</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">Name</b></p>
<p class="calibre1">Word boundary; position between a word and a non-word</p>
<p class="calibre1"><b class="calibre3">\b</b></p>
<p class="calibre1">character</p>
<p class="calibre1">Non-word boundary; it compliments <b class="calibre3">\b</b> and asserts true</p>
<p class="calibre1"><b class="calibre3">\B</b></p>
<p class="calibre1">wherever <b class="calibre3">\b</b> asserts false</p>
<p class="calibre1"><b class="calibre3">^</b></p>
<p class="calibre1">Line-start anchor, which matches the start of a line</p>
<p class="calibre1">Line-end anchor, which matches just before the optional line <b class="calibre3">$</b></p>
<p class="calibre1">break at the end of a line</p>
<p class="calibre1">Permanent start of input; in a multiline input using</p>
<p class="calibre1"><b class="calibre3">\A</b></p>
<p class="calibre1">MULTILINE mode, <b class="calibre3">\A</b> matches only at the very beginning, while <b class="calibre3">^</b> is matched at every line start position</p>
<p class="calibre1">Permanent end of input; in a multiline input using</p>
<p class="calibre1"><b class="calibre3">\z</b></p>
<p class="calibre1">MULTILINE mode, <b class="calibre3">\z</b> matches only at the very end while <b class="calibre3">$</b></p>
<p class="calibre1">is matched at every line end position</p>
<p class="calibre1">Similar to <b class="calibre3">\z</b> with the only difference being that it matches</p>
<p class="calibre1"><b class="calibre3">\Z</b></p>
<p class="calibre1">just before the optional line break at the very end of the input. </p>
<p class="calibre1">End of the previous match; we will discuss it in advanced</p>
<p class="calibre1"><b class="calibre3">\G</b></p>
<p class="calibre1">sections of the book in the next chapters. </p>
<p class="calibre1"> <i class="calibre4">Let's recall from the first chapter that [a-zA-Z0-9_] are called word</i> <i class="calibre4">characters. All other characters are considered non-word characters. </i></p>
<p class="calibre1"><a id="p51"/><img src="index-51_1.jpg" alt="Image 10" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Examples using boundary</b></p>
<p class="calibre1"><b class="calibre3">constructs</b></p>
<p class="calibre1">Which regex should be used to match "at" when the input is 'Hat at work"? </p>
<p class="calibre1">\bat\b</p>
<p class="calibre1">The preceding regex should be used because \b (word boundary) stops the regex engine to match at in Hat, because \bat\b can match full words only. </p>
<p class="calibre1">What should be regex if we only want to match at in Hat but not the one that was matched in the preceding regex? </p>
<p class="calibre1">\Bat\b</p>
<p class="calibre1">Now, this regex will match at that is a part of Hat because \B asserts a position that is between two word characters or a position between two non-word characters. Because of the presence of \B in the regex, it matches at only in Hat but not the word at. </p>
<p class="calibre1">If the input is suppress expression press depression, what will be the matches if the regex is \Bpress\B? </p>
<p class="calibre1">suppress ex<b class="calibre3">press</b>ion press de<b class="calibre3">press</b>ion</p>
<p class="calibre1">This is because \B matches the position between word characters, and the other instances, suppress and press, have non-word characters after press. </p>
<p class="calibre1">If the input is ppp\n555\n, then show the matched text using the following two regular expressions:</p>
<p class="calibre1">\Ap+\n5{3}\Z</p>
<p class="calibre1">\Ap+\n5{3}\z</p>
<p class="calibre1">Here are the matches:</p>
<p class="calibre1"><b class="calibre3">A)</b> ppp\n555</p>
<p class="calibre1"><b class="calibre3">B)</b> No match</p>
<p class="calibre1">The starting part, \Ap+\n5{3}, is common in both the regex patterns and matches ppp\n555 both the times. However, we are getting no match in the second case because of the subtle difference between the \Z and \z assertions. \Z asserts the position at the end or just before the last line terminator whereas \z always asserts the position at the very end. Due to the presence of \n at the end of the file, our second regex does not match. If we change the second regex to \Ap+\n5{3}\n\z, then it will match the entire input. </p>
<p class="calibre1"> <i class="calibre4">Note that the end anchor $ also behaves like \Z if the MULTILINE flag</i> <i class="calibre4">(will be discussed later) is not enabled in an input text with multiple</i> <i class="calibre4">lines. Thus, the preceding input string can also be matched using</i></p>
<p class="calibre1"> <i class="calibre4">^p+\n5{3}$. </i></p>
<p class="calibre1"><a id="p52"/><b class="calibre3">Character classes</b></p>
<p class="calibre1">We briefly looked at character classes in the first chapter. Character classes (or character sets) let us match one out of the many characters defined inside a class. </p>
<p class="calibre1">Character classes are enclosed inside a square bracket. The order of the characters inside a character class does not matter. </p>
<p class="calibre1"><a id="p53"/><b class="calibre3">Examples of character</b></p>
<p class="calibre1"><b class="calibre3">classes</b></p>
<p class="calibre1">Which regex will match the letters  <i class="calibre4">p</i>,  <i class="calibre4">m</i>, or  <i class="calibre4">z</i>? </p>
<p class="calibre1"><b class="calibre3">Solution 1:</b></p>
<p class="calibre1">[pmz]</p>
<p class="calibre1"><b class="calibre3">Solution 2:</b></p>
<p class="calibre1">[zmp]</p>
<p class="calibre1"><b class="calibre3">Solution 3:</b></p>
<p class="calibre1">[mzp]</p>
<p class="calibre1">All the preceding three regular expressions will behave in exactly the same manner because the order of the characters inside the character class does not matter. </p>
<p class="calibre1">Which regex will match English language vowels  <i class="calibre4">a</i>,  <i class="calibre4">e</i>,  <i class="calibre4">i</i>,  <i class="calibre4">o</i>, and  <i class="calibre4">u</i>? </p>
<p class="calibre1">[aeiou]</p>
<p class="calibre1">Which regex will match the field extensions .mp3 or .mp3? </p>
<p class="calibre1">\.mp[34]</p>
<p class="calibre1">Which regex will match the letters <b class="calibre3">@</b>, <b class="calibre3">#</b>, or <b class="calibre3">=</b>? </p>
<p class="calibre1">[@#=]</p>
<p class="calibre1"><a id="p54"/><b class="calibre3">Range inside a character</b></p>
<p class="calibre1"><b class="calibre3">class</b></p>
<p class="calibre1">We can also specify a <b class="calibre3">character range</b> inside a character class by using a hyphen ( - ) between two characters. You just have to make sure that the left-hand side character of a range is lower in the ASCII table than the right-hand side character. We can match all the digits using the regex patterns, [0123456789], or a shorter [0-9]. </p>
<p class="calibre1"><a id="p55"/><b class="calibre3">Examples of character range</b></p>
<p class="calibre1">The following is a regex that matches any uppercase or lowercase alphabet in the English language:</p>
<p class="calibre1">[a-zA-Z] </p>
<p class="calibre1">The a-z pattern is for the lowercase character range and A-Z is for the uppercase character range. </p>
<p class="calibre1">The following regex matches any alphanumeric characters:</p>
<p class="calibre1">[a-zA-Z0-9] </p>
<p class="calibre1">Alpha numeric characters consist of any English alphabets and digits. </p>
<p class="calibre1">The following regex matches any hexadecimal character:</p>
<p class="calibre1">[a-fA-F0-9] </p>
<p class="calibre1">We know that hexadecimal characters consist of digits, 0 to 9, and letters, A to F</p>
<p class="calibre1">(ignore casing). The preceding regex pattern shows a character class that includes these two character ranges. We use a-f and A-F ranges to make it match uppercase or lowercase letters. </p>
<p class="calibre1"><a id="p56"/><b class="calibre3">Escaping special regex</b></p>
<p class="calibre1"><b class="calibre3">metacharacters and escaping</b></p>
<p class="calibre1"><b class="calibre3">rules inside the character</b></p>
<p class="calibre1"><b class="calibre3">classes</b></p>
<p class="calibre1">We know that . matches any character, [ and ] are used for character classes, { and }</p>
<p class="calibre1">are used for limiting quantifiers, and ? , *, and + are used for various quantifiers. To match any of the metacharacters  <i class="calibre4">literally</i>, one needs to  <i class="calibre4">escape</i> these characters using a <i class="calibre4">backslash (</i>\ ) to suppress their special meaning. Similarly, ^ and $ are anchors that are also considered regex metacharacters. </p>
<p class="calibre1">Let's see some examples of escaping metacharacters in regular expressions. </p>
<p class="calibre1">The following regex matches the string, a.b?:</p>
<p class="calibre1">a\.b\? </p>
<p class="calibre1">The following regex matches the string, {food}:</p>
<p class="calibre1">\{food\} </p>
<p class="calibre1">The following regex matches the string, abc:][}{:</p>
<p class="calibre1">abc:\]\[\}\{ </p>
<p class="calibre1">The following regex matches the string, $25.50:</p>
<p class="calibre1">\$\d+\.\d+</p>
<p class="calibre1">The following regex matches the string, ^*+.:</p>
<p class="calibre1">\^\*\+\. </p>
<p class="calibre1"><a id="p57"/><img src="index-57_1.jpg" alt="Image 11" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Escaping inside a character</b></p>
<p class="calibre1"><b class="calibre3">class</b></p>
<p class="calibre1">In the Java regex engine, all the special regex metacharacters lose their special meaning inside a character class except the ^ (<b class="calibre3">carrot</b>), - (<b class="calibre3">hyphen</b>), ] (<b class="calibre3">right square</b> <b class="calibre3">bracket</b>), and \ (<b class="calibre3">backslash</b>) characters. </p>
<p class="calibre1"> <i class="calibre4">Inside a character class, the hyphen also does not need to be escaped</i> <i class="calibre4">when used as the first or last character, since a character range</i> <i class="calibre4">requires both the left-hand side and the right-hand side characters. </i></p>
<p class="calibre1"> <i class="calibre4">Similarly, ^ (carrot) needs to escaped only when used as the first</i> <i class="calibre4">character inside a character class. </i></p>
<p class="calibre1"><a id="p58"/><b class="calibre3">Examples of escaping rules</b></p>
<p class="calibre1"><b class="calibre3">inside the character class</b></p>
<p class="calibre1">The following regex matches a string containing one or more of the ap.9 characters:</p>
<p class="calibre1">^[ap9.]+$ </p>
<p class="calibre1">The dot (.) doesn't need to be escaped inside the character class. </p>
<p class="calibre1">The following regex matches a string containing one or more of the @#$%.* characters:</p>
<p class="calibre1">^[$#@%.*]+$</p>
<p class="calibre1">None of the preceding special characters require escaping inside the character class. </p>
<p class="calibre1">The following regex matches a string containing one or more of the ?*+. characters:</p>
<p class="calibre1">^[*+?.]+$ </p>
<p class="calibre1">The following regex matches an input that allows any digit, ], or ^ in the input:</p>
<p class="calibre1">^[\^\]0-9]+$ </p>
<p class="calibre1">We can also write our regex as ^[\]0-9^]+$ by moving ^ away from the first position and avoiding the escaping. </p>
<p class="calibre1">The following regex matches an input that allows any alphanumeric character, hyphen, dot, or backslash, such as xyzTR-4.5\00:</p>
<p class="calibre1">^[a-zA-Z0-9.\-\\]+$</p>
<p class="calibre1">We can also write our regex as follows by moving - to the last position inside the character class, thus avoiding the escaping:</p>
<p class="calibre1">^[a-zA-Z0-9.\\-]+$</p>
<p class="calibre1"><a id="p59"/><b class="calibre3">Literally matching a string</b></p>
<p class="calibre1"><b class="calibre3">that may contain special</b></p>
<p class="calibre1"><b class="calibre3">regex metacharacters</b></p>
<p class="calibre1">We have seen how we need to escape all the special regex metacharacters to be able to match them literally. </p>
<p class="calibre1">The Java regex engine provides special escape sequences, \Q and \E, for this purpose. </p>
<p class="calibre1">Any string that is wrapped between \Q and \E looses interpretation of all the regex metacharacters in the wrapped string. </p>
<p class="calibre1">For example, to write a regex that matches a string ^*+., we can avoid all escaping and use this regex:</p>
<p class="calibre1">\Q^*+.\E</p>
<p class="calibre1">Note that there must not be any character escaping between \Q and \E sequences. </p>
<p class="calibre1">To match an input string, "[a-z0-9]", we can write our regex as follows:</p>
<p class="calibre1">\Q[a-z0-9]\E</p>
<p class="calibre1">Java provides a convenient method to return a literal pattern sting for the given string called Pattern.quote(String). We will learn about this method in<a href="index_split_001.html#p111"> Chapter 5, </a>  <i class="calibre4">Introduction</i> <i class="calibre4">to Java Regular Expressions APIs - Pattern and Matcher Classes</i>, of the book. </p>
<p class="calibre1"><a id="p60"/><img src="index-60_1.jpg" alt="Image 12" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Negated character classes</b></p>
<p class="calibre1">By placing the carrot character (^) in the first position inside a character class (just next to [) <b class="calibre3">negates</b> the matching of the character class. A negated character class matches any character that is not included in the class. A negated character class also negates a character range by matching any character not matched by the character range. </p>
<p class="calibre1"> <i class="calibre4">You learned in<a href="#p27"> Chapter 1</a></i> <i class="calibre4">, Getting Started with Regular Expressions, that</i> <i class="calibre4">dot (.) matches any character except the newline character. However,</i> <i class="calibre4">note that the negated character class also matches newline characters</i> <i class="calibre4">such as \r, \n, and so on. </i></p>
<p class="calibre1"><a id="p61"/><b class="calibre3">Examples of negated</b></p>
<p class="calibre1"><b class="calibre3">character classes</b></p>
<p class="calibre1">The following regex matches any character except a forward slash:</p>
<p class="calibre1">[^/]</p>
<p class="calibre1">Also, remember the fact that a negated character such as [^/] must match a single character. It doesn't match zero-width assertions such as ^, $, \Z, \z, \b, \B, and so on. </p>
<p class="calibre1">The following regex matches any character but a and A:</p>
<p class="calibre1">[^aA]</p>
<p class="calibre1">The following regex matches all the  <i class="calibre4">consonants</i> of the English language:</p>
<p class="calibre1">[^aeiou]</p>
<p class="calibre1">All non-vowels are considered  <i class="calibre4">consonants</i><b class="calibre3">; </b> hence, we just need to negate the vowel character class. </p>
<p class="calibre1">The following regex matches all the characters except digits, dots, and line breaks:</p>
<p class="calibre1">[^0-9.\r\n]</p>
<p class="calibre1">In this regex, we could also use the predefined property \d for [0-9]:</p>
<p class="calibre1">[^\d.\r\n]</p>
<p class="calibre1">This regex matches http followed by any character except s: http[^s]</p>
<p class="calibre1"><a id="p62"/><b class="calibre3">Predefined shorthand</b></p>
<p class="calibre1"><b class="calibre3">character classes</b></p>
<p class="calibre1">As we have seen from the preceding examples, certain character classes, such as digits</p>
<p class="calibre1">[0-9] or word characters [0-9A-Za-z_], are used in most regex patterns. The Java language, like all regular expression flavors, provides convenient predefined character classes for these character classes. Here is the list:</p>
<p class="calibre1"><b class="calibre3">Shorthand</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">Character Class</b></p>
<p class="calibre1"><b class="calibre3">Class</b></p>
<p class="calibre1"><b class="calibre3">\d</b></p>
<p class="calibre1">A digit 0-9</p>
<p class="calibre1">[0-9]</p>
<p class="calibre1"><b class="calibre3">\D</b></p>
<p class="calibre1">A non-digit</p>
<p class="calibre1">[^\d]</p>
<p class="calibre1"><b class="calibre3">\w</b></p>
<p class="calibre1">A word character</p>
<p class="calibre1">[a-zA-Z0-9_]</p>
<p class="calibre1"><b class="calibre3">W</b></p>
<p class="calibre1">A non-word character</p>
<p class="calibre1">[^\w]</p>
<p class="calibre1">A whitespace character, </p>
<p class="calibre1"><b class="calibre3">\s</b></p>
<p class="calibre1">[ \t\r\n\f\x0B]</p>
<p class="calibre1">including line break</p>
<p class="calibre1">A non-whitespace</p>
<p class="calibre1"><b class="calibre3">\S</b></p>
<p class="calibre1">[^\s]</p>
<p class="calibre1">chacracter</p>
<p class="calibre1">A horizontal whitespace</p>
<p class="calibre1"><b class="calibre3">\h</b></p>
<p class="calibre1">[ \t\xA0\u1680\u180e\u2000-</p>
<p class="calibre1">character</p>
<p class="calibre1">\u200a\u202f\u205f\u3000]</p>
<p class="calibre1">A non-horizontal</p>
<p class="calibre1"><b class="calibre3">\H</b></p>
<p class="calibre1">[^\h]</p>
<p class="calibre1">whitespace character</p>
<p class="calibre1">A vertical whitespace</p>
<p class="calibre1"><b class="calibre3">\v</b></p>
<p class="calibre1">[\n\x0B\f\r\x85\u2028\u2029]</p>
<p class="calibre1">character</p>
<p class="calibre1">A non-vertical whitespace</p>
<p class="calibre1"><b class="calibre3">\V</b></p>
<p class="calibre1">[^\v]</p>
<p class="calibre1">character</p>
<p class="calibre1"><a id="p63"/><b class="calibre3">POSIX character classes</b></p>
<p class="calibre1">Java also supports many POSIX character classes for matching ASCII text. Here is the list:</p>
<p class="calibre1"><b class="calibre3">POSIX Character</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">Character Class</b></p>
<p class="calibre1"><b class="calibre3">Class</b></p>
<p class="calibre1"><b class="calibre3">\p{ASCII}</b></p>
<p class="calibre1">All ASCII characters</p>
<p class="calibre1">[\x00-\x7F]</p>
<p class="calibre1"><b class="calibre3">\p{Digit}</b></p>
<p class="calibre1">Any digit</p>
<p class="calibre1">[0-9]</p>
<p class="calibre1"><b class="calibre3">\p{Lower}</b></p>
<p class="calibre1">Lowercase alphabets</p>
<p class="calibre1">[a-z]</p>
<p class="calibre1"><b class="calibre3">\p{Upper}</b></p>
<p class="calibre1">Uppercase alphabets</p>
<p class="calibre1">[A-Z]</p>
<p class="calibre1"><b class="calibre3">\p{Alpha}</b></p>
<p class="calibre1">Any alphabet</p>
<p class="calibre1">[\p{Lower}\p{Upper}]</p>
<p class="calibre1">Any alpha-numeric</p>
<p class="calibre1"><b class="calibre3">\p{Alnum}</b></p>
<p class="calibre1">[\p{Lower}p{Upper}\p{Digit}]</p>
<p class="calibre1">character</p>
<p class="calibre1">A punctuation</p>
<p class="calibre1"><b class="calibre3">\p{Punct}</b></p>
<p class="calibre1">[!"\#$%&amp;'()*+,-./:;&lt;=&gt;?@\</p>
<p class="calibre1">character</p>
<p class="calibre1">[\\\]^_`{|}~]</p>
<p class="calibre1"><b class="calibre3">\p{Blank}</b></p>
<p class="calibre1">Space or tab</p>
<p class="calibre1">[ \t]</p>
<p class="calibre1">A whitespace</p>
<p class="calibre1"><b class="calibre3">\p{Space}</b></p>
<p class="calibre1">[ \t\n\x0B\f\r]</p>
<p class="calibre1">character</p>
<p class="calibre1">A visible ASCII</p>
<p class="calibre1"><b class="calibre3">\p{Graph}</b></p>
<p class="calibre1">[\p{Alnum}\p{Punct}]</p>
<p class="calibre1">character</p>
<p class="calibre1"><b class="calibre3">\p{Print}</b></p>
<p class="calibre1">A printable character</p>
<p class="calibre1">[\p{Graph}\x20]</p>
<p class="calibre1"><b class="calibre3">\p{Cntrl}</b></p>
<p class="calibre1">A control character</p>
<p class="calibre1">[\x00-\x1F\x7F]</p>
<p class="calibre1"><b class="calibre3">\p{XDigit}</b></p>
<p class="calibre1">A hexadecimal digit</p>
<p class="calibre1">[0-9a-fA-F]</p>
<p class="calibre1"/>
<p class="calibre1">Java also supports four additional predefined character classes based on the java.lang.Character methods:</p>
<p class="calibre1"><b class="calibre3">Class Name</b></p>
<p class="calibre1"><b class="calibre3">Implementing Method</b></p>
<p class="calibre1"><b class="calibre3">\p{javaLowerCase}</b></p>
<p class="calibre1">Equivalent to java.lang.Character.isLowerCase()</p>
<p class="calibre1"><b class="calibre3">\p{javaUpperCase}</b></p>
<p class="calibre1">Equivalent to java.lang.Character.isUpperCase()</p>
<p class="calibre1"><b class="calibre3">\p{javaWhitespace}</b></p>
<p class="calibre1">Equivalent to java.lang.Character.isWhitespace()</p>
<p class="calibre1"><b class="calibre3">\p{javaMirrored}</b></p>
<p class="calibre1">Equivalent to java.lang.Character.isMirrored()</p>
<p class="calibre1"><a id="p64"/><b class="calibre3">Unicode support in Java</b></p>
<p class="calibre1"><b class="calibre3">regular expressions</b></p>
<p class="calibre1">So far, all the examples that we have seen in the first two chapters are for the English language only. However, a regular expression needs to have full support for all the languages using Unicode characters. Java has a Unicode-based regex engine and has extensive support for various Unicode scripts, blocks, and categories. </p>
<p class="calibre1">A specific Unicode character can be matched in two different ways in Java: 1. <b class="calibre3">Unicode escape sequence</b> <b class="calibre3">or the</b> \u <b class="calibre3">notation</b>: This can be written as "\u1234" or</p>
<p class="calibre1">"\\u1234". </p>
<p class="calibre1">2. <b class="calibre3">Hex notation</b>: This can be written as "\x{1234}". </p>
<p class="calibre1"><a id="p65"/><b class="calibre3">Commonly used Unicode</b></p>
<p class="calibre1"><b class="calibre3">character properties</b></p>
<p class="calibre1">Here is the list of commonly used Unicode character properties in regular expressions that require to match Unicode texts:</p>
<p class="calibre1"><b class="calibre3">Unicode</b></p>
<p class="calibre1"><b class="calibre3">character</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">class</b></p>
<p class="calibre1"><b class="calibre3">\p{L}</b></p>
<p class="calibre1">Match any letter from any language</p>
<p class="calibre1"><b class="calibre3">\p{Lu}</b></p>
<p class="calibre1">Match any uppercase letter from any language</p>
<p class="calibre1"><b class="calibre3">\p{Ll}</b></p>
<p class="calibre1">Match any lowercase letter from any language</p>
<p class="calibre1"><b class="calibre3">\p{N}</b></p>
<p class="calibre1">Match any digit from any language</p>
<p class="calibre1"><b class="calibre3">\p{P}</b></p>
<p class="calibre1">Match any punctuation letter from any language</p>
<p class="calibre1"><b class="calibre3">\p{Z}</b></p>
<p class="calibre1">Match any kind of whitespace or invisible separator</p>
<p class="calibre1"><b class="calibre3">\p{C}</b></p>
<p class="calibre1">Match any invisible control letter</p>
<p class="calibre1"><b class="calibre3">\p{Sc}</b></p>
<p class="calibre1">Match any currency symbol</p>
<p class="calibre1">Any Unicode linebreak sequence; is equivalent to</p>
<p class="calibre1">\u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]</p>
<p class="calibre1"><b class="calibre3">\R</b></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">It is recommended to use </b>\R<b class="calibre3"> to match any newline character</b></i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">even if dealing with ASCII text. </b></i></p>
<p class="calibre1"><a id="p66"/><b class="calibre3">Negation of the preceding</b></p>
<p class="calibre1"><b class="calibre3">regex directives</b></p>
<p class="calibre1">To match a single character belonging to a particular  <i class="calibre4">category</i>, we use the</p>
<p class="calibre1">\p{propertyName} directive. </p>
<p class="calibre1">To match a single character <b class="calibre3">not</b> belonging to a particular  <i class="calibre4">category</i>, we use the</p>
<p class="calibre1">\P{propertyName} directive (note the uppercase <b class="calibre3">P</b> instead of the lowercase <b class="calibre3">p</b>). </p>
<p class="calibre1"><a id="p67"/><b class="calibre3">Unicode scripts support</b></p>
<p class="calibre1">Java supports all the Unicode scripts as defined by the Unicode standard. Here is a list of all the supported Unicode scripts:</p>
<p class="calibre1">\p{IsCommon}</p>
<p class="calibre1">\p{IsArabic}</p>
<p class="calibre1">\p{IsArmenian}</p>
<p class="calibre1">\p{IsBengali}</p>
<p class="calibre1">\p{IsBopomofo}</p>
<p class="calibre1">\p{IsBraille}</p>
<p class="calibre1">\p{IsBuhid}</p>
<p class="calibre1">\p{IsCanadian_Aboriginal}</p>
<p class="calibre1">\p{IsCherokee}</p>
<p class="calibre1">\p{IsCyrillic}</p>
<p class="calibre1">\p{IsDevanagari}</p>
<p class="calibre1">\p{IsEthiopic}</p>
<p class="calibre1">\p{IsGeorgian}</p>
<p class="calibre1">\p{IsGreek}</p>
<p class="calibre1">\p{IsGujarati}</p>
<p class="calibre1">\p{IsGurmukhi}</p>
<p class="calibre1">\p{IsHan}</p>
<p class="calibre1">\p{IsHangul}</p>
<p class="calibre1">\p{IsHanunoo}</p>
<p class="calibre1">\p{IsHebrew}</p>
<p class="calibre1">\p{IsHiragana}</p>
<p class="calibre1">\p{IsInherited}</p>
<p class="calibre1">\p{IsKannada}</p>
<p class="calibre1">\p{IsKatakana}</p>
<p class="calibre1">\p{IsKhmer}</p>
<p class="calibre1">\p{IsLao}</p>
<p class="calibre1">\p{IsLatin}</p>
<p class="calibre1">\p{IsLimbu}</p>
<p class="calibre1">\p{IsMalayalam}</p>
<p class="calibre1">\p{IsMongolian}</p>
<p class="calibre1">\p{IsMyanmar}</p>
<p class="calibre1">\p{IsOgham}</p>
<p class="calibre1">\p{IsOriya}</p>
<p class="calibre1">\p{IsRunic}</p>
<p class="calibre1">\p{IsSinhala}</p>
<p class="calibre1">\p{IsSyriac}</p>
<p class="calibre1">\p{IsTagalog}</p>
<p class="calibre1">\p{IsTagbanwa}</p>
<p class="calibre1">\p{IsTaiLe}</p>
<p class="calibre1">\p{IsTamil}</p>
<p class="calibre1">\p{IsTelugu}</p>
<p class="calibre1">\p{IsThaana}</p>
<p class="calibre1">\p{IsThai}</p>
<p class="calibre1">\p{IsTibetan}</p>
<p class="calibre1">\p{IsYi}</p>
<p class="calibre1"><a id="p68"/><b class="calibre3">Unicode blocks</b>: Java supports all the previously listed script for matching Unicode blocks. We just need to replace Is with In in the preceding expressions. For example, to check for a <b class="calibre3">Thai</b> code block, we can use:</p>
<p class="calibre1">\p{InThai}</p>
<p class="calibre1"><a id="p69"/><b class="calibre3">Examples of matching</b></p>
<p class="calibre1"><b class="calibre3">Unicode text in regular</b></p>
<p class="calibre1"><b class="calibre3">expressions</b></p>
<p class="calibre1">The following regex will match accented characters, such as " <b class="calibre3">Ã </b>":</p>
<p class="calibre1">^\p{L}+$</p>
<p class="calibre1">The following regex will match a text consisting of Latin characters and Unicode whitespaces:</p>
<p class="calibre1">^[\p{IsLatin}\p{Zs}]+$</p>
<p class="calibre1">The following regex should be used to detect the presence of a <b class="calibre3">Hebrew</b> character in input:</p>
<p class="calibre1">\p{InHebrew}</p>
<p class="calibre1">The following regex should be used to detect an input that contains only <b class="calibre3">Arabic</b> text:</p>
<p class="calibre1">^\p{InArabic}+$</p>
<p class="calibre1">How can we match Urdu text? Since Urdu is not a script, we will need to match certain Unicode code ranges. These are as follows:</p>
<p class="calibre1">U+0600 to U+06FF</p>
<p class="calibre1">U+0750 to U+077F</p>
<p class="calibre1">U+FB50 to U+FDFF</p>
<p class="calibre1">U+FE70 to U+FEFF</p>
<p class="calibre1">A Java regex to detect the presence of any Urdu character will be:</p>
<p class="calibre1">[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]</p>
<p class="calibre1"><a id="p70"/><b class="calibre3">Double escaping in a Java</b></p>
<p class="calibre1"><b class="calibre3">String when defining regular</b></p>
<p class="calibre1"><b class="calibre3">expressions</b></p>
<p class="calibre1">In Java, all the regular expressions are entered as a String type, where \ acts as an escape character and is used to interpret certain special characters such as \t, \n, and so on. So, it is necessary to double-escape all the predefined classes, such as \w, \d, \s, using two backslashes and while escaping metacharacters, such as \[, \(, \+, and so on, in string literals. </p>
<p class="calibre1">If we have to use the preceding regex for a dollar amount in Java, then it would be as follows:</p>
<p class="calibre1">final String re = "\\$\\d+\\.\\d+"; </p>
<p class="calibre1">The preceding example that matches a signed decimal number has to be written as follows in Java:</p>
<p class="calibre1">final String re = "^[+-]?\\d*\\.?\\d+$"; </p>
<p class="calibre1">For the same reasons, if we have to match a single backslash character, then it would be as follows:</p>
<p class="calibre1">\\\\</p>
<p class="calibre1">How can we write a regex string that matches an input that allows any alphanumeric character, hyphen, dot, or backslash, such as xyzTR-4.5\00? Here is how: final String re = "^[a-zA-Z0-9.\-\\\\]+$"; </p>
<p class="calibre1">How can we write a regular expression in Java that will accept any Latin character, Unicode whitespaces, or Unicode digits? Refer to the following regex: final String re = "^[\\p{IsLatin}\\p{Zs}\\p{N}]+$"; How to write a regular expression in Java that will accept any Unicde character, Unicode whitespaces, Unicode digits, or Unicode punctuation characters? Check out the following regex:</p>
<p class="calibre1">final String re = "^[\\p{L}\\p{Z}\\p{N}\\p{P}]+$"; The following Java regex matches the string, " <b class="calibre3">abc:][}[</b>": final String re = "abc:\\]\\[\\}\\{"; </p>
<p class="calibre1"><a id="p71"/><b class="calibre3">Embedded regular</b></p>
<p class="calibre1"><b class="calibre3">expression mode modifiers</b></p>
<p class="calibre1">Like all other regular expression flavors, Java also allows the <b class="calibre3">embedding</b> of some standard modes in the regular expression itself. These mode modifiers are used to change regular expression behavior in a certain manner. In the following table, we will list all these modes and their meaning:</p>
<p class="calibre1">Mode</p>
<p class="calibre1">Name</p>
<p class="calibre1">Meaning</p>
<p class="calibre1">Ignore case</p>
<p class="calibre1">Enables case-insensitive matching for US-ASCII</p>
<p class="calibre1"><b class="calibre3">(?i)</b></p>
<p class="calibre1">mode</p>
<p class="calibre1">text</p>
<p class="calibre1">DOTALL</p>
<p class="calibre1">Makes DOT match all the characters, including</p>
<p class="calibre1"><b class="calibre3">(?s)</b></p>
<p class="calibre1">mode</p>
<p class="calibre1">line breaks</p>
<p class="calibre1">Multiline</p>
<p class="calibre1">Makes the carrot and dollar match the start and</p>
<p class="calibre1"><b class="calibre3">(?m)</b></p>
<p class="calibre1">mode</p>
<p class="calibre1">end of each line in a multiline input</p>
<p class="calibre1">Unicode-</p>
<p class="calibre1"><b class="calibre3">(?u)</b></p>
<p class="calibre1">aware case</p>
<p class="calibre1">Enables Unicode-aware case folding</p>
<p class="calibre1">folding</p>
<p class="calibre1">Unicode</p>
<p class="calibre1">Enables the Unicode version of predefined</p>
<p class="calibre1"><b class="calibre3">(?U)</b></p>
<p class="calibre1">matching</p>
<p class="calibre1">character classes and POSIX character classes. </p>
<p class="calibre1">Unix line</p>
<p class="calibre1"><b class="calibre3">(?d)</b></p>
<p class="calibre1">Enables Unix lines mode</p>
<p class="calibre1">mode</p>
<p class="calibre1">Comment</p>
<p class="calibre1">Allows for the presence of whitespace and</p>
<p class="calibre1"><b class="calibre3">(?x)</b></p>
<p class="calibre1">mode</p>
<p class="calibre1">comments in the regex pattern</p>
<p class="calibre1"/>
<p class="calibre1">Let's check some examples to understand these modes better. </p>
<p class="calibre1">How to match an input in which the starting word is <b class="calibre3">Java</b> and the ending word is <b class="calibre3">Mode</b>, and we don't know what is in between these two words? Also, the input may contain line breaks as well. </p>
<p class="calibre1">Consider the following example input text, which is in two lines: Java regex</p>
<p class="calibre1">Embedded Mode</p>
<p class="calibre1">Let's use the following regex:</p>
<p class="calibre1">\AJava.*Mode\z</p>
<p class="calibre1">If we use the preceding regex, then the match will fail because we know that DOT</p>
<p class="calibre1">matches all the characters except line breaks by default. Hence, we need to enable the DOTALL mode here using the following:</p>
<p class="calibre1"><a id="p72"/>(?s)\AJava.*Mode\z</p>
<p class="calibre1">Our regex will match the input because (?s) will enable the <b class="calibre3">DOTALL</b> mode and then</p>
<p class="calibre1">.* will match the text between <b class="calibre3">Java</b> and <b class="calibre3">Mode</b>. </p>
<p class="calibre1">It is considered good practice to insert comments and line breaks in a complex and lengthy regular expression. In order to allow that, we will need to enable the comment mode using (?x). </p>
<p class="calibre1">Here is an example of a regex with comments and extra whitespaces using multiple modifiers, including (?x):</p>
<p class="calibre1">String regex = "(?ixs)\\A # assert start of the string\n" </p>
<p class="calibre1">+ "java\n" </p>
<p class="calibre1">+ "\\s\n" </p>
<p class="calibre1">+ "regex\n" </p>
<p class="calibre1">+ ".* # match 0 or more of any character including line breaks\n" </p>
<p class="calibre1">+ "Mode\n" </p>
<p class="calibre1">+ "\\z # assert end of the string"; </p>
<p class="calibre1">It is interesting to note that this regular expression will still match the input text that we used in the previous example. You can clearly see how the use of (?x) allows us to use arbitrary white-spaces and inline comments in our regex. </p>
<p class="calibre1">Let's examine the use of the <b class="calibre3">MULTILINE</b> mode. In the same input text, that is, Java regex\nEmbedded Mode, what would be the regular expression that validates the first line only, which contains the text,  <i class="calibre4">Java regex</i>? </p>
<p class="calibre1">Let's use anchors (caret and dollar) and write the regex as follows:</p>
<p class="calibre1">^Java regex$</p>
<p class="calibre1">This regex will <b class="calibre3">fail</b> to match our input because the input contains two lines and $ will not assert the position at the end of every line without enabling the <b class="calibre3">MULTILINE</b></p>
<p class="calibre1">mode. </p>
<p class="calibre1">Change your regex to the following:</p>
<p class="calibre1">(?m)^Java regex$</p>
<p class="calibre1">And bingo! Our regex works now because we enabled the <b class="calibre3">MULTILINE</b> mode using (?m) at the start of the regex. </p>
<p class="calibre1"><a id="p73"/><b class="calibre3">The placement of embedded</b></p>
<p class="calibre1"><b class="calibre3">modes in a Java regular</b></p>
<p class="calibre1"><b class="calibre3">expression</b></p>
<p class="calibre1">All the aforementioned embedded modes can be placed at the start of a regular expression to enable one or more modes for the complete regular expression. We can also place these modes in the middle of a regex to enable it for a specific group or a remainder of the regex pattern. </p>
<p class="calibre1">We can also <b class="calibre3">combine</b> multiple mode modifiers into a single expression like this: (?is)</p>
<p class="calibre1">This enables the DOTALL and ignore case modes. </p>
<p class="calibre1"><a id="p74"/><b class="calibre3">Disabling mode modifiers</b></p>
<p class="calibre1">To disable a previously enabled mode, we can place a hyphen (-) before the modifier symbol anywhere in your regular expression. </p>
<p class="calibre1">Let's look at some examples. </p>
<p class="calibre1">To disable DOTALL, we can use the following regex:</p>
<p class="calibre1">(?-s) </p>
<p class="calibre1">To disable ignore case matching, we can use the following regex: (?-i) </p>
<p class="calibre1">To disable the MULTILINE mode, we can use the following regex: (?-m)</p>
<p class="calibre1">To disable both ignore case and MULTILINE mode, we can use the following regex: (?-im)</p>
<p class="calibre1">To disable the ignore case, DOTALL, and MULTILINE modes, we can use the following regex:</p>
<p class="calibre1">(?-ism)</p>
<p class="calibre1"><a id="p75"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we covered the core constructs of regular expressions in depth. You learned anchors, quantifiers, boundary matchers, various character classes, negated character classes, and predefined character classes. We found out that escaped characters need to be escaped twice in the Java language. You also learned Unicode text matching using regular expressions in Java. We covered greedy, non-greedy, and possessive quantifiers. You learned embedded mode modifiers in Java regular expressions and how they can change the interpretation of a regular expression. </p>
<p class="calibre1">In the next chapter, we will cover another very important feature of regular expressions, called grouping. You will learn the various types of grouping available in Java regular expressions and how to use them. </p>
<p class="calibre1"><a id="p76"/><b class="calibre3">Working with Groups, </b></p>
<p class="calibre1"><b class="calibre3">Capturing, and References</b></p>
<p class="calibre1">In this chapter, you will learn how to match, capture, and reference substrings from a given input text using regular expressions. We will cover various types of groups available in Java, and the naming and numbering of captured groups. Readers will also learn how to use back reference or forward reference of the capturing groups. </p>
<p class="calibre1">We will be covering the following topics in this chapter: Grouping</p>
<p class="calibre1">Capturing groups</p>
<p class="calibre1">Group numbering</p>
<p class="calibre1">Non-capturing groups</p>
<p class="calibre1">Back references</p>
<p class="calibre1">Named groups</p>
<p class="calibre1">Forward references</p>
<p class="calibre1">Invalid references</p>
<p class="calibre1"><a id="p77"/><b class="calibre3">Capturing groups</b></p>
<p class="calibre1">Groups are a very useful feature of regular expressions, which are supported in all the flavors of regular expressions. Groups are used to combine multiple characters or multiple smaller components of regular expressions into a single unit. We create groups by placing a series of characters or subpatterns inside round brackets or parentheses, ( and ). For example, consider the following regex pattern: (blue|red) </p>
<p class="calibre1">It means a capturing group that uses alternation. It either matches the letters b, l, u, and e or it matches the letters r, e, and d. In other words, it matches the strings blue or red, and more importantly, it creates a capturing group with either of the two matched strings. Each group becomes a single unit that can be used to apply certain constructs to the entire group. For example, anchors, boundary assertion, quantifiers, or alternation can be restricted to a part of the regular expression represented by the group. For example, look at the following regex pattern:</p>
<p class="calibre1">^Regular(Expression)?$ </p>
<p class="calibre1">This regular expression will match the string, Regular, at the start. After that, there is one capturing group with the string, Expression; however, due to the placement of the ? </p>
<p class="calibre1">quantifier after the group, it will match the 0 or 1 occurrence of the preceding group, making it an <b class="calibre3">optional capturing group</b>. Hence, this regex will either match the string, Regular, with an <b class="calibre3">empty</b> first capturing group or it will match the string RegularExpression, with the substring, Expression, in the first capturing group. </p>
<p class="calibre1">If we are given a problem to write a regular expression that matches only an even number of digits in the input, then we can use this pattern:</p>
<p class="calibre1">^([0-9]{2})+$ </p>
<p class="calibre1">Since the + quantifier (one or more) is used next to the group that matches a pair of digits, this quantifier is applied to the entire group. Hence, this regular expression will match one or more pairs of digits (2, 4, 6, 8, 10, ...), or in simple words, it matches an even number of digits. </p>
<p class="calibre1">A regular expression can have multiple capturing groups, which can be nested inside each other as well. </p>
<p class="calibre1">For example, in the following regular expression, there are three capturing groups:</p>
<p class="calibre1">^((\d+)-([a-zA-Z]+))$ </p>
<p class="calibre1">The preceding expression will match the input string, that is, 1234-aBc with the following groups:</p>
<p class="calibre1">1.  Group 1: 1234-aBc</p>
<p class="calibre1">2.  Group 2: 1234</p>
<p class="calibre1">3.  Group 3: aBc</p>
<p class="calibre1"><a id="p78"/><b class="calibre3">Group numbering</b></p>
<p class="calibre1">Capturing groups are numbered in increasing numbers, starting with number one. Java regular expressions support up to 99 capturing groups. Group zero always stands for the entire matched text. </p>
<p class="calibre1">For nested capturing groups, group numbers are incremented with the appearance of the opening parenthesis from left to right. </p>
<p class="calibre1">To understand this better, let's consider the following regular expression with nested multiple capturing groups:</p>
<p class="calibre1">(((a|b)-(c|d))/(\d+)) </p>
<p class="calibre1">It will match the input string as follows:</p>
<p class="calibre1">a-c/15 </p>
<p class="calibre1">a-d/99 </p>
<p class="calibre1">b-c/567 </p>
<p class="calibre1">b-d/1000 </p>
<p class="calibre1">For the input string, a-c/15, we will get the following captured groups: <b class="calibre3">Group Num</b></p>
<p class="calibre1"><b class="calibre3">Captured Text</b></p>
<p class="calibre1"><b class="calibre3">Group 0</b></p>
<p class="calibre1">a-c/15</p>
<p class="calibre1"><b class="calibre3">Group 1</b></p>
<p class="calibre1">a-c/15</p>
<p class="calibre1"><b class="calibre3">Group 2</b></p>
<p class="calibre1">a-c</p>
<p class="calibre1"><b class="calibre3">Group 3</b></p>
<p class="calibre1">a</p>
<p class="calibre1"><b class="calibre3">Group 4</b></p>
<p class="calibre1">c</p>
<p class="calibre1"><b class="calibre3">Group 5</b></p>
<p class="calibre1">15</p>
<p class="calibre1">Also note that in the case of repeated matches in a capturing group using a quantifier, it will capture the last matched text in the given group. </p>
<p class="calibre1">For example, consider the following regex:</p>
<p class="calibre1">(\w+\s+){3} </p>
<p class="calibre1"><a id="p79"/>If the input text is around the word, then the captured group number one will contain word after the regex execution, even though it also matches around and the before completing the match with the last word. </p>
<p class="calibre1"><a id="p80"/><b class="calibre3">Named groups</b></p>
<p class="calibre1">In Java regular expressions, capturing groups can be defined in two ways: 1.  Using numbers that get incremented automatically (as we discussed earlier). </p>
<p class="calibre1">2.  Using names. </p>
<p class="calibre1">Starting from Java 7, the regular expressions API offers support for named capturing groups. Named capturing groups are especially useful where there are lots of capturing groups. If we have to insert a new group or remove an existing group, then the numerical order changes for every capturing group that comes after the new or removed group, thus requiring the updating of all those references. </p>
<p class="calibre1">The syntax for defining a capturing group is as follows:</p>
<p class="calibre1">(?&lt;name&gt;RE) </p>
<p class="calibre1">In the preceding line, RE is the pattern we are using for capturing a group. </p>
<p class="calibre1">There are certain rules to specify a named group in Java: 1.  Names are case sensitive, so these are four different named capturing groups: (?&lt;name&gt;RE)</p>
<p class="calibre1">(?&lt;Name&gt;RE)</p>
<p class="calibre1">(?&lt;NAME&gt;RE)</p>
<p class="calibre1">(?&lt;naME&gt;RE)</p>
<p class="calibre1">2.  A name must satisfy the following regular expression:</p>
<p class="calibre1">[a-zA-Z][a-zA-Z0-9]*</p>
<p class="calibre1">This means that the name must start with a letter and may contain letters or digits after the first position. </p>
<p class="calibre1">3.  Names cannot be duplicate in Java regex. </p>
<p class="calibre1">Keep in mind that even when we use a name to define groups, the groups are still numbered as \1, \2, \3, and so on, and that these numbers can also be used in references. </p>
<p class="calibre1">For example, in the following regular expression, we are specifying four named groups, id, subject, score, and term, all separated by a colon: (?&lt;id&gt;\d+):(?&lt;subject&gt;[a-zA-Z]+):(?&lt;score&gt;\d+):(?&lt;term&gt;[A-Z]+) If matched with 123456:Science:97:II, then the following groups will be captured: Group " <b class="calibre3">id</b>": "123456" </p>
<p class="calibre1">Group " <b class="calibre3">subject</b>": "Science" </p>
<p class="calibre1">Group " <b class="calibre3">score</b>": "97" </p>
<p class="calibre1">Group " <b class="calibre3">term</b>": "II" </p>
<p class="calibre1">Group <b class="calibre3">1</b>: "123456" </p>
<p class="calibre1">Group <b class="calibre3">2</b>: "Science" </p>
<p class="calibre1">Group <b class="calibre3">3</b>: "97" </p>
<p class="calibre1">Group <b class="calibre3">4</b>: "II" </p>
<p class="calibre1"><a id="p81"/><b class="calibre3">Non-capturing groups</b></p>
<p class="calibre1">There are cases while building regular expressions when we don't really want to capture any text but just want to group a subpattern to apply a boundary assertion or quantifier. This is the case for using non-capturing groups. We can mark a group as a non-capturing group by  <i class="calibre4">adding a question mark and a colon</i> right after the opening parenthesis. </p>
<p class="calibre1">Note that we can also place one or more mode modifiers between the question mark and the colon. The scope of the modifier used in this manner is only effective for that group. </p>
<p class="calibre1">For example, we can use a non-capturing group in our regex to match an even number of digits:</p>
<p class="calibre1">^(?:\d{2})+$ </p>
<p class="calibre1">Since we are not really interested in capturing any text from a matched string, it is a good choice to use a non-capturing group here. </p>
<p class="calibre1">An example of a non-capturing group with the ignore case modifier is as follows: (?i:red|green|blue|white) </p>
<p class="calibre1">Due to the presence of the i modifier, this capturing group will match all the alternations by ignoring the case. Thus, it may match red, RED, White, blue, Green, BluE, greeN, WHITE, and so on. </p>
<p class="calibre1">There are major differences between the following three regular expression patterns: (?:abc) </p>
<p class="calibre1">(?mi:abc) </p>
<p class="calibre1">((?:abc)?) </p>
<p class="calibre1">In the first case, we define a non-capturing group with a pattern as abc. </p>
<p class="calibre1">In the second case, we define a non-capturing group with the m ( <i class="calibre4">multiline</i>) and i ( <i class="calibre4">ignore case</i>) modifiers. This allows the regex to match abc, ABC, Abc, or aBC. </p>
<p class="calibre1">In the third case, we define an optional non-capturing group inside the capturing group that matches abc or an empty string in the captured group. </p>
<p class="calibre1"><a id="p82"/><b class="calibre3">Advantages of non-capturing</b></p>
<p class="calibre1"><b class="calibre3">groups</b></p>
<p class="calibre1">A non-capturing group lets us use the grouping inside a regular expression without changing the numbers assigned to the back references (explained in the next section). </p>
<p class="calibre1">This can be very useful in building large and complex regular expressions. </p>
<p class="calibre1">Non-capturing groups also give us the flexibility to add or remove groups from a long regular expression with multiple groups. If we have to insert a new group or remove an existing group, then the numerical order changes for every group on the right-hand side of the new or removed group. </p>
<p class="calibre1">Using a non-capturing group instead of a capturing group saves memory, as the regular expression engine doesn't need to store groups in buffers, thus optimizing the overall regex execution. It is recommended to mark each group as non-capturing when we do not want to extract a grouped substring or refer to them anywhere in the regular expression. </p>
<p class="calibre1"><a id="p83"/><b class="calibre3">Back references</b></p>
<p class="calibre1">Back references provide a convenient way of matching a repeated character or repeated tokens in the input text. By using back references, the regular expression engine can match the <b class="calibre3">exact same text</b> as previously matched by a capturing group. </p>
<p class="calibre1">The syntax of a back reference is a backslash followed by a capturing group number, as shown in the following example:</p>
<p class="calibre1">\3 </p>
<p class="calibre1">The preceding example is a back reference of the third capturing group. </p>
<p class="calibre1">In Java regular expressions, there can be up to 99 back references, each number referencing a captured group number. </p>
<p class="calibre1">For example, if we need to match a two-digit number with the restriction that both digits must be the same, then we need to capture the first digit and then use a back reference for the first captured group, as follows:</p>
<p class="calibre1">^(\d)\1$ </p>
<p class="calibre1">Now, this regex will match any of these strings: 11, 22, 55, and 88. </p>
<p class="calibre1">We can also use quantifiers after back references as we use them with capturing or non-capturing groups. </p>
<p class="calibre1">For example, if we have to match a five-digit number with all the same digits, then we can use the following regex:</p>
<p class="calibre1">^(\d)\1{4}$ </p>
<p class="calibre1">As an example, we want to create a regex that matches four pairs of digits, separated by the colon (:), dash (-), or slash (/) characters. We also require the digit pairs to be the same on the first and third positions, and likewise, they must also be the same on the second and fourth positions. For example, 12-45:12-45 and 56/00:56-00 will be a matching string, but 57-13-58:13 will not, because 57 in the first pair of digits is not the same as 58, which is the third pair of digits. We can write our regex as follows:</p>
<p class="calibre1">^(\d{2})[:/-](\d{2})[:/-]\1[:/-]\2$ </p>
<p class="calibre1">Let's look at some more useful regular expressions using capturing groups and back references. Suppose we need to write a regular expression for two repeated words, separated by one or more non-word characters in between. We can write our regular expression as follows:</p>
<p class="calibre1">^(\w+)\W+\1$ </p>
<p class="calibre1">The back reference, \1, will make sure we match the exact same word as matched by the first capturing group in this regular expression. </p>
<p class="calibre1">Next, we need to write a regular expression for quoted words. Words can be wrapped using single quotes or double quotes, but the mixing of quotes is not allowed. We can then write our regex as follows:</p>
<p class="calibre1"><a id="p84"/>    ^(['"])\w+\1$ </p>
<p class="calibre1">Here, this regex pattern matches and captures the opening single or double quote using a character class. On the other side of the word, we use the \1 back reference to ensure that the same quote is matched in the end. </p>
<p class="calibre1">Back references cannot be used inside a character class, as we learned earlier. There is no grouping inside a character class, and most of the special meta characters become just literals inside a character class. </p>
<p class="calibre1"><a id="p85"/><b class="calibre3">Back reference of a named</b></p>
<p class="calibre1"><b class="calibre3">group</b></p>
<p class="calibre1">The syntax for the back reference of a named group is as follows:</p>
<p class="calibre1">\k&lt;group1&gt; </p>
<p class="calibre1">Here, group1 is the name of the named capturing group. </p>
<p class="calibre1">For example, we can write our regular expression of repeating numbers, using a named group and named back reference, as follows:</p>
<p class="calibre1">^(?&lt;matchedDigits&gt;\d+)\s+\k&lt;matchedDigits&gt;$ </p>
<p class="calibre1">Here, we are defining a captured group called num to capture a number using the first, and then, we are using a back reference of the named group using \k&lt;num&gt;. </p>
<p class="calibre1">This will match inputs such as 1234 1234 or 989 989. </p>
<p class="calibre1">Since the named capturing groups are numbered automatically as well, we can write the same regular expression as follows:</p>
<p class="calibre1">^(?&lt;num&gt;\d+)\s+\1$ </p>
<p class="calibre1"><a id="p86"/><b class="calibre3">Replacement reference of a</b></p>
<p class="calibre1"><b class="calibre3">named group</b></p>
<p class="calibre1">We haven't yet discussed the Java API for regular expression replacement, but just for reference, it will be pertinent to discuss the syntax of a named group reference in a replacement string:</p>
<p class="calibre1">${group1}: This will be replaced in the resulting string by the matched content of the named captured group, group1</p>
<p class="calibre1">$1: This will be replaced in the resulting string by the matched content of the captured group number 1</p>
<p class="calibre1">Note that the double escaping of String while defining a Java regular expression should be applied here in defining named groups, named back references, and numbered back references. Thus, repeating the previous regular expressions used in Java code:</p>
<p class="calibre1">final String regex = "^(?&lt;num&gt;\\d+)\\s+\\k&lt;num&gt;$"; or using numbered back references:</p>
<p class="calibre1">final String regex = "^(\\d+)\\s+\\1$"; </p>
<p class="calibre1"><a id="p87"/><b class="calibre3">Forward references</b></p>
<p class="calibre1">Back reference is the term used when a capturing group is referenced after we capture it. Likewise, a forward reference is the term for referencing a group before capturing the text using a captured group. In other words, the forward reference refers to a capturing group that appears later in the regular expression pattern. Forward references are only useful if we use them inside a repeated group, since the regex engine will be able to resolve captured groups and populate the forward reference while repeating a match using quantifiers. </p>
<p class="calibre1">As with most modern languages, Java allows us to use the forward reference of the captured group. Forward reference is a fairly complex concept to understand in regex. </p>
<p class="calibre1">Let's consider an example regex to understand better:</p>
<p class="calibre1">^(\d+)-(?:\2[\dA-Fa-f]{4}|(\d*\.?\d+:))+$ </p>
<p class="calibre1">Here, in this pattern, you can see that we are using the group reference, \2, before defining the captured group number, 2, which comes later in the regex pattern as: (\d*\.?\d+:). For this reason, \2 is a forward reference instead of a backward reference. </p>
<p class="calibre1">With the preceding regex, the following string matches:</p>
<p class="calibre1">666-6.6:6.6:abcd3.3: </p>
<p class="calibre1">The string matches because in the first repetition of the non-captured group, the second captured group becomes 6.6: and this can be referenced later. </p>
<p class="calibre1">The following string also matches because the second captured group is overwritten each time it is matched:</p>
<p class="calibre1">666-3.3:5.5:5.5:abcd </p>
<p class="calibre1">The first value that the second captured group captures is 3.3:, but it is overwritten by 5.5: later, and this is matched the third time when the first part of the alternatives matches in the non-capturing group. </p>
<p class="calibre1">The following string, however, does not match, although the first capture of the second group will be the string, 3.3:, by the time it is required by the forward reference:</p>
<p class="calibre1">666-3.3:abcd3.3: </p>
<p class="calibre1">Thus, as it is undefined, it does not match anything, not even the empty string. </p>
<p class="calibre1">Therefore, the first part of the alternative group does not match, and at this point, the second half also does not match, thereby leading to a failed matching. This way, the captured group, in this case, never captures the string, 3.3:. </p>
<p class="calibre1">To summarize this behavior, the forward reference does reference something that is defined in the regular expression later, but only when the expression has already been matched at least once. </p>
<p class="calibre1">For this reason, there is no point in using a forward reference outside some repeated</p>
<p class="calibre1"><a id="p88"/>construct as a part of one member of an alternative matching. </p>
<p class="calibre1">Similarly, in the following example, the regex pattern uses a forward reference:</p>
<p class="calibre1">^(?:\1#color|(red|blue|white))+$ </p>
<p class="calibre1">This anchored regex uses the <b class="calibre3">forward reference</b>, \1, before matching the literal text, </p>
<p class="calibre1">#color, on the left-hand side of the alternation. On the right-hand side of the alternation, it matches one of the given colors and captures it in the first capturing group. The entire alternation has the + quantifier after to make repeated matches. </p>
<p class="calibre1">In the first attempt, \1 fails the match and forces the regex engine to attempt the right-hand side of the alternation and match a color to populate \1 with the matching color. </p>
<p class="calibre1">If there is any text left to be matched in the input, the regex engine, in the second attempt, matches the now populated reference, \1, followed by #color as the first alternation or an allowed color as the second alternation. This process is repeated until the regex engine either matches the complete string or fails the match. </p>
<p class="calibre1">This will match any of the following strings:</p>
<p class="calibre1">blue </p>
<p class="calibre1">redblue </p>
<p class="calibre1">blueblueblue </p>
<p class="calibre1">redbluewhite </p>
<p class="calibre1">redred#color </p>
<p class="calibre1">whitewhite#color </p>
<p class="calibre1">blueredred#color </p>
<p class="calibre1">However, it won't match the following strings:</p>
<p class="calibre1">#color </p>
<p class="calibre1">red#color </p>
<p class="calibre1">bluered#color </p>
<p class="calibre1">redbluefruit </p>
<p class="calibre1">redbluered#color </p>
<p class="calibre1"><a id="p89"/><b class="calibre3">Invalid (non-existing)</b></p>
<p class="calibre1"><b class="calibre3">backward or forward</b></p>
<p class="calibre1"><b class="calibre3">references</b></p>
<p class="calibre1">The Java regular expression engine handles back references to non-existing groups in the same manner as back references to existing groups. Invalid or non-existing back references do not participate in the match. This means that a regular expression with an invalid back reference always fails, although it does not cause any exception. </p>
<p class="calibre1">For example, consider the following regex example:</p>
<p class="calibre1">(apple|orange|banana)\2 </p>
<p class="calibre1">The \2 back reference will be invalid because there is only one capturing group in this regular expression. Hence, the back reference of \2 always makes it a failed match against any input. </p>
<p class="calibre1">The same happens even when we have a regex pattern as follows:</p>
<p class="calibre1">\1 </p>
<p class="calibre1">Due to a similar rule, it will fail to match an empty string as well. </p>
<p class="calibre1"><a id="p90"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, you learned how to capture and reference substrings from an input text using regular expressions. Using non-capturing groups, we discussed how to optimize our regex patterns. We discussed the various types of groups available in Java regular expressions, the numbering of captured groups, and named groups. You also learned how to use back reference and forward reference of the capturing groups using numbered and named references. In the next chapter, you will get to writing code in Java to evaluate regular expressions. You will also be introduced to Java regular expressions using the Java String API, and then, we will move on to regex capabilities in the Java Scanner API. </p>
<p class="calibre1"><a id="p91"/><b class="calibre3">Regular Expression</b></p>
<p class="calibre1"><b class="calibre3">Programming Using Java</b></p>
<p class="calibre1"><b class="calibre3">String and Scanner APIs</b></p>
<p class="calibre1">In this chapter, you will be introduced to Java regular expressions using Java String methods and we will move on to regular expression capabilities in Java Scanner API. </p>
<p class="calibre1">We will cover the following topics in this chapter:</p>
<p class="calibre1">Java String methods that use regular expressions</p>
<p class="calibre1">What these methods are used for and how to use them</p>
<p class="calibre1">The use of regular expressions in Java Scanner</p>
<p class="calibre1">So far, we have covered many theoretical concepts of writing regular expressions in depth. The time has now come to see some of these regular expressions in action. We are going to introduce you to Java programs evaluating these regular expressions using the java.lang.String and java.util.Scanner APIs. </p>
<p class="calibre1"><a id="p92"/><b class="calibre3">Introduction to the Java</b></p>
<p class="calibre1"><b class="calibre3">String API for regular</b></p>
<p class="calibre1"><b class="calibre3">expressions' evaluation</b></p>
<p class="calibre1">The Java String API provides some useful methods to evaluate regular expressions against a text represented by the String object. Let's list those methods from the String class:</p>
<p class="calibre1">Method Signature</p>
<p class="calibre1">Purpose</p>
<p class="calibre1">boolean</p>
<p class="calibre1">Matches the given regular expression against the string that matches(String</p>
<p class="calibre1">the method is invoked on and returns true/false, indicating regex)</p>
<p class="calibre1">whether the match is successful (true) or not (false). </p>
<p class="calibre1">String</p>
<p class="calibre1">Replaces each substring of the subject string that matches the replaceAll(String</p>
<p class="calibre1">given regular expression with the replacement string and</p>
<p class="calibre1">regex, String</p>
<p class="calibre1">returns the new string with the replaced content. </p>
<p class="calibre1">replacement)</p>
<p class="calibre1">This method does the same as the previous one with the</p>
<p class="calibre1">String</p>
<p class="calibre1">exception that it replaces only the first substring of the replaceFirst(String</p>
<p class="calibre1">subject string that matches the given regular expression with regex, String</p>
<p class="calibre1">the replacement string and returns the new string with the replacement)</p>
<p class="calibre1">replaced content. </p>
<p class="calibre1">String[]</p>
<p class="calibre1">Splits the subject string using the given regular expression split(String regex)</p>
<p class="calibre1">into an array of substrings (example given ahead). </p>
<p class="calibre1">This overloaded method does the same as the previous one</p>
<p class="calibre1">String[]</p>
<p class="calibre1">split(String regex, </p>
<p class="calibre1">but there is an additional second parameter. The limit</p>
<p class="calibre1">int limit)</p>
<p class="calibre1">parameter controls the number of times regular expressions are applied for splitting. </p>
<p class="calibre1"/>
<p class="calibre1"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">For the complete reference of the String class, refer to https://docs.oracle.com/javase/8/docs/</a></p>
<p class="calibre1"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">api/java/lang/String.html. </a></p>
<p class="calibre1"><a id="p93"/><b class="calibre3">Method - boolean</b></p>
<p class="calibre1"><b class="calibre3">matches(String regex)</b></p>
<p class="calibre1">This method attempts to match a given regular expression against the complete subject String and returns <b class="calibre3">true</b>/<b class="calibre3">false</b>, indicating whether the match is successful or not. The following are a few important points to note:</p>
<p class="calibre1">Regular expression is applied against the entire String; there is no partial matching</p>
<p class="calibre1">Regular expression does not need to be anchored using ^ and $, since it is matched against the entire input</p>
<p class="calibre1">The equivalent of Pattern.matches(<b class="calibre3">String regex</b>, CharSequence<b class="calibre3">input</b>) method (will be covered later)</p>
<p class="calibre1"><a id="p94"/><b class="calibre3">Example of the matches</b></p>
<p class="calibre1"><b class="calibre3">method</b></p>
<p class="calibre1">Let's look at a few examples to understand this method better. </p>
<p class="calibre1">The following code snippet using the matches method will return false:</p>
<p class="calibre1">"1234".matches("\\d"); </p>
<p class="calibre1">It is because the matches method attempts to apply a given regex against the entire input and effectively runs this code as:</p>
<p class="calibre1">"1234".matches("^\\d$"); </p>
<p class="calibre1">This will obviously fail as we have three digits in the input, not just one. </p>
<p class="calibre1">The code that matches the string "1234" and the call to the matches()method that returns true will use the quantifier + or * after \\d. Therefore, the following two method calls will return true:</p>
<p class="calibre1">"1234".matches("\\d+"); </p>
<p class="calibre1">"1234".matches("\\d+"); </p>
<p class="calibre1">To validate a given string that contains the colors <b class="calibre3">red</b>, <b class="calibre3">blue, </b> or <b class="calibre3">green</b>, we shall use this code listing:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">public class StringMatches </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">boolean result; </p>
<p class="calibre1">String regex; </p>
<p class="calibre1">String input = "Sky is blue";        // First regex regex = "\\b(red|blue|green)\\b"; </p>
<p class="calibre1">result = input.matches(regex); </p>
<p class="calibre1">System.out.printf("Match result: %s%n", result); </p>
<p class="calibre1">// prints false </p>
<p class="calibre1">// Second regex </p>
<p class="calibre1">regex = ".*\\b(red|blue|green)\\b.*"; </p>
<p class="calibre1">result = input.matches(regex); </p>
<p class="calibre1">System.out.printf("Match result: %s%n", result); </p>
<p class="calibre1">// prints true </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">A few points about this regex are as follows:</p>
<p class="calibre1">Alternation (<b class="calibre3">red</b>|<b class="calibre3">blue</b>|<b class="calibre3">green</b>) is being used to match any of the allowed colors The first regex fails to match because we are only matching the allowed colors using alternation but are not matching the text on either side of the alternation The second regex succeeds as we are using . <b class="calibre3">*</b> on both sides of the alternation to match any text before and after the allowed colors in the input text We are also using the word, <b class="calibre3">boundary assertions</b>, around our alternation expression to ensure that we match complete words only</p>
<p class="calibre1"><a id="p95"/>To verify that the given input starts and ends with an English letter while allowing digits, letters, underscores, and hyphens in the middle, we can use the following regular expression in the matches() method:</p>
<p class="calibre1">input.matches("[a-zA-Z][a-zA-Z0-9_-]*[a-zA-Z]"); Else, we can also use the predefined class, \w:</p>
<p class="calibre1">input.matches("[a-zA-Z][\w-]*[a-zA-Z]"); </p>
<p class="calibre1">In addition, we can use the modifier, (?i):</p>
<p class="calibre1">input.matches("(?i)[a-z][\w-]*[a-z]"); </p>
<p class="calibre1">To verify that the input contains six to nine digits, use the following: input.matches("\\d{6,9}"); </p>
<p class="calibre1"><a id="p96"/><img src="index-96_1.jpg" alt="Image 13" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Method - String</b></p>
<p class="calibre1"><b class="calibre3">replaceAll(String regex, </b></p>
<p class="calibre1"><b class="calibre3">String replacement)</b></p>
<p class="calibre1">This method replaces each substring of the subject string that matches the given regular expression with the replacement String. As the name implies, replaceAll replaces all the matching occurrences of the input String. Note that we can also supply a simple String containing no regex meta character in the first argument. </p>
<p class="calibre1">Calling this method is equivalent to a call to the following: Pattern.compile(regex).matcher(input).replaceAll(replacement); </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Note</b>: We will cover Pattern and Matcher APIs in<a href="index_split_001.html#p111"> Chapter 5</a></i> <i class="calibre4">,</i> <i class="calibre4">Introduction to Java Regular Expression APIs - Pattern and Matcher</i> <i class="calibre4">Classes. </i></p>
<p class="calibre1">The replacement string allows the use of references to substrings, represented by the captured groups used in the regular expression. These references can be of two types: <b class="calibre3">Numbered references</b>: These are written as $n, where n is a number, such as $1, $2, and $3, which represent a reference to each of the captured groups in the regular expression</p>
<p class="calibre1"><b class="calibre3">Named references</b>: These are written as ${groupName}, where groupName is the name of the captured group in the regular expression</p>
<p class="calibre1">To place a literal dollar or literal backslash in the replacement string, we need to escape these characters using double backslash (\\). </p>
<p class="calibre1">Here, at this point, you should understand the difference between back-reference and replacement reference. Back-reference is used in the regular expression pattern itself and is written as <b class="calibre3">\1,\2,\3</b>, and so on for a numbered group's back-reference and</p>
<p class="calibre1"><b class="calibre3">\k&lt;groupName&gt; </b> for a named group's back-reference. However, replacement reference is either written as <b class="calibre3">$1, $2, $3</b>, for a numbered group's reference or <b class="calibre3">${groupName}</b> for a named group's reference. </p>
<p class="calibre1"><a id="p97"/><b class="calibre3">Examples of the replaceAll</b></p>
<p class="calibre1"><b class="calibre3">method</b></p>
<p class="calibre1">To replace all the semi-colons with hyphens, we can use the following: input = input.replaceAll(";", "-"); </p>
<p class="calibre1">To remove all the non-digits from the input, we can use:</p>
<p class="calibre1">input = input.replace("\\D+", ""); </p>
<p class="calibre1">To replace all the leading and trailing commas from an input, we can use an alternation regex:</p>
<p class="calibre1">input = input.replaceAll("^,+|,+$", ""); To replace all the occurrences of two or more white spaces with a single space, we can use:</p>
<p class="calibre1">input = input.replaceAll("\\s{2,}, " "); </p>
<p class="calibre1">How can we escape all the dollar signs that are just before the % character? In other words, to replace all the occurrences of $% with \$%, we can use: input = input.replaceAll("\\$%", "\\\\\\$%"); Note that we are using \\\\ (four backslashes) to enter a single \, and we're using \\$</p>
<p class="calibre1">to enter a single $ in the replacement, whereas % will just be a literal. </p>
<p class="calibre1">Consider the following input:</p>
<p class="calibre1">$200 $%apple% $%banana% $%orange% </p>
<p class="calibre1">It will be converted into this:</p>
<p class="calibre1">$200 \$%apple% \$%banana} \${orange} </p>
<p class="calibre1">We can also leverage the group reference $0 here, which is populated with the entire matched text using a regex. So, our code can be simplified to this as $0 will refer to the matched text $% by our regex:</p>
<p class="calibre1">input = input.replaceAll("\\$%", "\\\\$0"); Another nice trick we can use here is to use the static method, Matcher.quoteReplacement that is in the Matcher API. This method handles all the special characters in a replacement string and escapes them appropriately. Now, our code can become this: input = input.replaceAll("\\$%", Matcher.quoteReplacement("\\") + "$0"); Let's solve an interesting problem. We need to replace all the multiple occurrences of non-word characters with a single instance of the same character. </p>
<p class="calibre1">Consider the following input text:</p>
<p class="calibre1"><a id="p98"/>Let''''''s learn::: how to    write cool regex... </p>
<p class="calibre1">The expected output is:</p>
<p class="calibre1">Let's learn: how to write cool regex. </p>
<p class="calibre1">Note that we are replacing multiple occurrences of non-word characters only and not replacing multiple occurrences of word characters. </p>
<p class="calibre1">Here is the code listing to solve this problem:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">public class StringReplaceAll </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">// our input string </p>
<p class="calibre1">String input = "Let''''''s learn::: how to    write cool regex..."; </p>
<p class="calibre1">// call replaceAll and assign replaced string to same variable input = input.replaceAll("(\\W)\\1+", "$1"); </p>
<p class="calibre1">// print the result </p>
<p class="calibre1">System.out.printf("Replaced result: %s%n", input); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">Here are a few points about this solution:</p>
<p class="calibre1">We are using the predefined class, \W, to match a non-word character We are using a capturing group around the non-word character to be able to use a back-reference later in the regex and in the replacement The pattern, (\\W)\\1+, is used to match two or more occurrences of the same non-word character</p>
<p class="calibre1">\1 represents the back-reference to the first captured group In the replacement, we are using the reference, $1, to place the captured non-word character back in the replaced string</p>
<p class="calibre1">$1 represents the reference to the first captured group</p>
<p class="calibre1">Using the named group directives that you learnt in the previous chapter, we can also write the replaceAll method call as follows:</p>
<p class="calibre1">input = input.replaceAll("(?&lt;nwchar&gt;\\W)\\k&lt;nwchar&gt;+", "${nwchar}"); </p>
<p class="calibre1"><a id="p99"/><img src="index-99_1.jpg" alt="Image 14" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Method - String</b></p>
<p class="calibre1"><b class="calibre3">replaceFirst(String regex, </b></p>
<p class="calibre1"><b class="calibre3">String replacement)</b></p>
<p class="calibre1">This method replaces the first substring of the subject string, which matches the given regular expression with the replacement String. As the name implies, replaceFirst replaces only the first matching occurrence of the input String. Note that we can also supply a simple String containing no regex meta character in the first argument as regex. </p>
<p class="calibre1">Calling this method is equivalent to the following call:</p>
<p class="calibre1">Pattern.compile(regex).matcher(input).replaceFirst(replacement); <i class="calibre4">Note: We will cover the Pattern and Matcher APIs in later chapters. </i></p>
<p class="calibre1">A replacement string allows the use of group references, such as $1, $2, $3, and so on, for numbered references or ${groupName} for named references, which represent each of the captured groups in the regular expressions. To place a literal dollar or a literal backslash in the replacement, we need to escape these characters using the double backslash. </p>
<p class="calibre1"><a id="p100"/><b class="calibre3">Examples of the replaceFirst</b></p>
<p class="calibre1"><b class="calibre3">method</b></p>
<p class="calibre1">To replace  <i class="calibre4">only the first</i> semi-colon with a hyphen, we can use the following: input = input.replaceFirst(";", "-"); What will be the output if we have to use the replaceFirst method instead of replaceAll in the input text of "$%apple% $%banana% $%orange%" for escaping the dollar signs? </p>
<p class="calibre1">The code will become as follows:</p>
<p class="calibre1">input = input.replaceFirst("\\$", "\\\\\\$"); It will replace only the first $ sign; hence, the output will only have the first $ escaped as follows:</p>
<p class="calibre1">\$%apple% $%banana% $%orange% </p>
<p class="calibre1">To replace the first dot of an IPV4 IP address with a colon, we can use the following code:</p>
<p class="calibre1">String newip = ipaddress.replaceFirst("\\.", ":"); Only the first dot will be replaced by a colon; hence, an IP value of 10.11.22.123 will become 10:11.22.123. </p>
<p class="calibre1"><a id="p101"/><b class="calibre3">Methods - String split</b></p>
<p class="calibre1"><b class="calibre3">methods</b></p>
<p class="calibre1">The String class has two split methods with the following signatures: String[] split(String regex, int limit)</p>
<p class="calibre1">String[] split(String regex)</p>
<p class="calibre1">These split methods split the subject string into an array around the matches of the given regular expression, also called delimiters. </p>
<p class="calibre1">When there is a  <i class="calibre4">positive width</i> match at the beginning of an input string, then an empty string is included at the beginning of the resulting array. However, a match of <i class="calibre4">zero width</i> by regular expression does not include any empty string at the beginning of the resulting array. </p>
<p class="calibre1">The array returned by this method contains a combination of the following elements: Token substrings that are split by the delimiter, matched using the given regular expression</p>
<p class="calibre1">Input substring beyond the last match of the delimiter, using the given regular expression</p>
<p class="calibre1">A leading empty string when there is a  <i class="calibre4">positive width</i> delimiter Trailing empty strings (see the next subsection on the limit parameter) When splitting regular a expression does not match any part of the input, the resulting array will just have a single element, that is, the complete input string. </p>
<p class="calibre1">split(String regex) is just an overloaded method with the same functionality that calls the two-argument split method with the limit parameter as zero, thus making a call as: split(regex, 0) </p>
<p class="calibre1"><a id="p102"/><b class="calibre3">The limit parameter rules</b></p>
<p class="calibre1">The limit parameter controls the number of times the regular expression pattern is applied for splitting the subject string. It affects the length of the resulting array with the following rules:</p>
<p class="calibre1">1.  If the limit is greater than 0, then the pattern will be applied at most one time, the resulting array's length will not be greater than the limit, and the array's last entry will contain all input substrings beyond the last matched delimiter. </p>
<p class="calibre1">2.  If the limit is negative, then the pattern will be applied as many times as possible, and the resulting array can have any length. </p>
<p class="calibre1">3.  If the limit is zero (as in the single parameter split method call), then the pattern will be applied as many times as possible, the array can have any length, and <b class="calibre3">trailing empty strings will be discarded</b>. </p>
<p class="calibre1"><a id="p103"/><b class="calibre3">Examples of the split method</b></p>
<p class="calibre1">Let's look at the following code listing, which splits the subject string on each occurrence of a hyphen:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">import java.util.*; </p>
<p class="calibre1">class StringSplit </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String input = "green-red-blue-yellow"; </p>
<p class="calibre1">Arrays.stream(input.split("-")) </p>
<p class="calibre1">.forEach(System.out::println); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This will generate the following output:</p>
<p class="calibre1">"green" </p>
<p class="calibre1">"red" </p>
<p class="calibre1">"blue" </p>
<p class="calibre1">"yellow" </p>
<p class="calibre1">Now, let's change our code to the following by splitting on each occurrence of the letter e:</p>
<p class="calibre1">Arrays.stream(input.split("e")) </p>
<p class="calibre1">.forEach(System.out::println); </p>
<p class="calibre1">The preceding code will generate the following output:</p>
<p class="calibre1">"gr" </p>
<p class="calibre1">"" </p>
<p class="calibre1">"n-r" </p>
<p class="calibre1">"d-blu" </p>
<p class="calibre1">"-y" </p>
<p class="calibre1">"llow" </p>
<p class="calibre1">We got one empty result because we split on each e and there are two e letters in green, thus giving us an empty string between the two e letters. </p>
<p class="calibre1">Now, let's change our code to the following by splitting on one or more occurrences of e:</p>
<p class="calibre1">Arrays.stream(input.split("e+")) </p>
<p class="calibre1">.forEach(System.out::println); </p>
<p class="calibre1">We will get the following output:</p>
<p class="calibre1">"gr" </p>
<p class="calibre1">"n-r" </p>
<p class="calibre1">"d-blu" </p>
<p class="calibre1">"-y" </p>
<p class="calibre1">"llow" </p>
<p class="calibre1">We did not get any empty results now because we split on each e+ and the two e letters in green are matched in a single match. </p>
<p class="calibre1"><a id="p104"/><b class="calibre3">Example of the split method</b></p>
<p class="calibre1"><b class="calibre3">using the limit parameter</b></p>
<p class="calibre1">To understand the impact of the limit parameter, let's take a comma-separated input string with two trailing commas:</p>
<p class="calibre1">fox,tiger,wolf,, </p>
<p class="calibre1">We can call the split method in two ways. We can call the split method with limit=0: String[] arr = input.split(",", 0); </p>
<p class="calibre1">We can also call the single parameter split method call as: String[] arr = input.split(","); </p>
<p class="calibre1">It splits the input string around a comma and the trailing empty strings are discarded, with the following values being returned by the split method:</p>
<p class="calibre1">"fox" </p>
<p class="calibre1">"tiger" </p>
<p class="calibre1">"wolf" </p>
<p class="calibre1">Now, let's call the split method with limit=1:</p>
<p class="calibre1">String[] arr = input.split(",", 1); </p>
<p class="calibre1">It splits the input string around a comma and then gets a single element in the resulting array, that is, the input string itself. The following value is returned by the split method:</p>
<p class="calibre1">"fox,tiger,wolf,," </p>
<p class="calibre1">Let's call the split method with limit=2:</p>
<p class="calibre1">String[] arr = input.split(",", 2); </p>
<p class="calibre1">It splits the input string around a comma and then gets exactly two elements in the resulting array. The following two values are returned by the split method:</p>
<p class="calibre1">"fox" </p>
<p class="calibre1">"tiger,wolf,," </p>
<p class="calibre1">Let's call the split method with limit=3:</p>
<p class="calibre1">String[] arr = input.split(",", 3); </p>
<p class="calibre1">It splits the input string around a comma, and then we get exactly three elements in the resulting array. The following three values are returned by the split method:</p>
<p class="calibre1">"fox" </p>
<p class="calibre1">"tiger" </p>
<p class="calibre1">"wolf,," </p>
<p class="calibre1">Let's call the split method with a negative limit:</p>
<p class="calibre1"><a id="p105"/>String[] arr = input.split(",", -1); It splits the input string around a comma <b class="calibre3">as many times as possible, with the trailing</b> <b class="calibre3">empty strings included in the split array</b>, and we get these elements in the resulting array. The following values are returned by the split method. Note the two empty strings at the end of the split array:</p>
<p class="calibre1">"fox" </p>
<p class="calibre1">"tiger" </p>
<p class="calibre1">"wolf" </p>
<p class="calibre1">"" </p>
<p class="calibre1">"" </p>
<p class="calibre1"><a id="p106"/><img src="index-106_1.jpg" alt="Image 15" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Using regular expressions in</b></p>
<p class="calibre1"><b class="calibre3">Java Scanner API</b></p>
<p class="calibre1">A scanner is a utility class used for parsing the input text and breaking the input into tokens of various types, such as Boolean, int, float, double, long, and so on. It generates tokens of various types using regular expression-based delimiters. The default delimiter is a whitespace. Using the Scanner API, we can generate tokens of all the primitive types in addition to string tokens. </p>
<p class="calibre1">The String, Pattern, and Matcher classes are able to parse the input and generate tokens of the String type only, but the Scanner class is very useful for checking and generating tokens of different types from the input source. The Scanner instance can be constructed using the File, InputStream, Path, Readable, ReadableByteChannel, and String arguments. </p>
<p class="calibre1"> <i class="calibre4">Pattern and Matcher will be covered in detail in<a href="index_split_001.html#p111"> Chapter 5</a></i> <i class="calibre4">, Introduction to</i> <i class="calibre4">Java Regular Expression APIs - Pattern and Matcher Classes. </i></p>
<p class="calibre1">There are many methods in the scanner that support regular expressions. Let's list those methods down and understand them better:</p>
<p class="calibre1"><b class="calibre3">Method Signature</b></p>
<p class="calibre1"><b class="calibre3">Purpose</b></p>
<p class="calibre1">Scanner</p>
<p class="calibre1">Sets this scanner's delimiter regex pattern to a String</p>
<p class="calibre1">useDelimiter(String</p>
<p class="calibre1">regex argument. </p>
<p class="calibre1">pattern)</p>
<p class="calibre1">This method is almost the same as the previous one</p>
<p class="calibre1">but gets a Pattern as an argument instead of a String. </p>
<p class="calibre1">This means that we can pass a regular expression</p>
<p class="calibre1">already compiled. If we are forced to use the version</p>
<p class="calibre1">Scanner</p>
<p class="calibre1">with the </p>
<p class="calibre1">useDelimiter(Pattern</p>
<p class="calibre1">String argument, the scanner would compile</p>
<p class="calibre1">the string to a </p>
<p class="calibre1">pattern)</p>
<p class="calibre1">Pattern object even if we have already</p>
<p class="calibre1">executed that compilation in other parts of the code. </p>
<p class="calibre1">We will discuss the Pattern and Matcher class in the</p>
<p class="calibre1">next chapter. </p>
<p class="calibre1">Returns the pattern being used by this scanner to</p>
<p class="calibre1">Pattern delimiter()</p>
<p class="calibre1">match delimiters. </p>
<p class="calibre1"><a id="p107"/>MatchResult match()</p>
<p class="calibre1">Returns the match result of the latest scan operation</p>
<p class="calibre1">performed by this scanner. </p>
<p class="calibre1">boolean hasNext(String</p>
<p class="calibre1">Returns true if the next token matches the pattern</p>
<p class="calibre1">pattern)</p>
<p class="calibre1">constructed from the specified string. </p>
<p class="calibre1">boolean hasNext(Pattern</p>
<p class="calibre1">This method is almost the same as the previous one</p>
<p class="calibre1">pattern)</p>
<p class="calibre1">but gets Pattern as an argument instead of String. </p>
<p class="calibre1">Returns the next token if it matches the pattern</p>
<p class="calibre1">String next(String pattern)</p>
<p class="calibre1">constructed from the specified string. </p>
<p class="calibre1">String</p>
<p class="calibre1">This method is almost the same as the previous one</p>
<p class="calibre1">next(Pattern pattern)</p>
<p class="calibre1">but gets Pattern as an argument instead of String. </p>
<p class="calibre1">Attempts to find the next occurrence of a pattern</p>
<p class="calibre1">String findInLine(String</p>
<p class="calibre1">constructed from the specified string, ignoring</p>
<p class="calibre1">pattern)</p>
<p class="calibre1">delimiters. </p>
<p class="calibre1">String findInLine(Pattern</p>
<p class="calibre1">This method is almost the same as the previous one</p>
<p class="calibre1">pattern)</p>
<p class="calibre1">but gets Pattern as an argument instead of String. </p>
<p class="calibre1">Scanner skip(String</p>
<p class="calibre1">Skips the input that matches a pattern constructed</p>
<p class="calibre1">pattern)</p>
</body></html>