<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introducing WebDriver and WebElements</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will look briefly into Selenium, its various components, such as Appium, and proceed to the basic components of a web page, including the various types of WebElements. We will learn different ways to locate WebElements on a web page and execute various user actions on them. We will cover the following topics in this chapter:</p>
<ul>
<li>Various components of Selenium Testing Tools</li>
<li>Setting up a project in Eclipse with Maven and TestNG</li>
<li>Locating WebElements on a Web Page</li>
<li>Actions that can be taken on the WebElements</li>
</ul>
<p>Selenium is a set of widely popular tools used to automate browsers. It is largely used to test applications, but its usages are not limited to testing. It can also be used to perform screen scraping and automate repetitive tasks in a browser window. Selenium supports automation on all the major browsers, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, Apple Safari, and Opera. Selenium 3.0 is now a part of W3C standards and is supported by major browser vendors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selenium Testing Tools</h1>
                </header>
            
            <article>
                
<p>Selenium 3.0 offers three important tools, Selenium WebDriver, Selenium Server, and Selenium IDE. Each of these tools provides features to create, debug, and run tests on supported browsers and operating systems. Let's explore each of them in detail.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selenium WebDriver </h1>
                </header>
            
            <article>
                
<p><span>Selenium WebDriver is the successor of Selenium RC (Remote Control), which has been officially deprecated</span>. Selenium WebDriver accepts commands using the JSON-Wire protocol (also called Client API) and sends them to a browser launched by the specific driver class (such as ChromeDriver, FirefoxDriver, or IEDriver). This is implemented through a browser-specific browser driver. It works with the following sequence:</p>
<ol>
<li>The driver listens to the commands from Selenium </li>
<li>It converts these commands into the browser's native API</li>
<li>The driver takes the result of native commands and sends the result back to Selenium:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bf64b2d5-cd1c-4c5a-a08d-a08dc873aa4d.jpg"/></div>
<p class="mce-root">We can use Selenium WebDriver to do the following:</p>
<ul>
<li>Create robust, browser-based regression automation</li>
<li>Scale and distribute scripts across many browsers and platforms</li>
<li>Create scripts in your favourite programming language</li>
</ul>
<p class="mce-root"/>
<p>Selenium WebDriver offers a collection of language-specific bindings (client libraries) to drive a browser. WebDriver comes with a better set of APIs that meet the expectations of most developers by being similar to object-oriented programming in its implementation. WebDriver is being actively developed over a period of time, and you can see many advanced interactions with the web as well as mobile applications.</p>
<div class="packt_infobox">The Selenium Client API is a language-specific Selenium library that provides a consistent Selenium API in programming languages such as Java, C#, Python, Ruby, and JavaScript. These languages bindings let tests to launch a WebDriver session and communicate with the browser or Selenium Server.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selenium Server</h1>
                </header>
            
            <article>
                
<p>Selenium Server allows us to run tests on browser instances running on remote machines and in parallel, thus spreading a load of testing across several machines. We can create a Selenium Grid, where one server runs as the <span>H</span><span>ub, managing a pool of Nodes</span><span>. We can configure our tests to connect to the Hub, which then obtains a node that is free and matches the browser we need to run the tests. The hub has a list of nodes that provide access to browser instances, and lets tests use these instances similarly to a load balancer. Selenium Grid enables us to execute tests in parallel on multiple machines by managing different types of browsers, their versions, and operating system configurations centrally.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selenium IDE</h1>
                </header>
            
            <article>
                
<p>Selenium IDE is a Firefox add-on that allows users to record, edit, debug, and play back tests captured in the <em>Selenese</em> format, which was introduced in the Selenium Core version. It also provides us with the ability to convert these tests into the Selenium RC or Selenium WebDriver format. <span>We can use Selenium IDE to do the following:</span></p>
<ul>
<li>Create quick and simple scripts using record and replay, or use them in exploratory testing</li>
<li>Create scripts to aid in automation-aided exploratory testing</li>
<li>Create macros to perform repetitive tasks on Web pages</li>
</ul>
<div class="packt_infobox">The Selenium IDE for Firefox stopped working after the Firefox 55 moved to the WebExtension format from XPI format and it is currently no longer maintained.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Differences between Selenium 2 and Selenium 3 </h1>
                </header>
            
            <article>
                
<p>Before we dive further into Selenium 3, let's understand the differences between Selenium 2 and Selenium.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling the browser  </h1>
                </header>
            
            <article>
                
<p class="mce-root">As the Selenium WebDriver has been accepted as the W3C Standard, Selenium 3 brings a number of changes to the browser implementations. All of the major browser vendors now support WebDriver specification and provide the necessary features along with the browser. For example, Microsoft came with EdgeDriver, and Apple supports the SafariDriver implementation. We will see some of these changes later in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> Having better APIs</h1>
                </header>
            
            <article>
                
<p>As W3C-standard WebDriver comes with a better set of APIs, which meet the expectations of most developers by being similar to the implementation of object-oriented programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Having developer support and advanced functionalities</h1>
                </header>
            
            <article>
                
<p>WebDriver is being actively developed and is now supported by Browser vendors per W3C specification; you can see many advanced interactions with the web as well as mobile applications, such as File-Handling and Touch APIs. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing Mobile Apps with Appium</h1>
                </header>
            
            <article>
                
<p>One of the major differences introduced in Selenium 3 was the introduction of the <kbd>Appium</kbd> project. The mobile-testing features that were part of Selenium 2 are now moved into a separate project named Appium. </p>
<p><kbd>Appium</kbd> is an open source mobile-automation framework for testing native, hybrid, and web mobile apps on iOS and Android platforms using the JSON-Wire protocol with Selenium WebDriver. <kbd>Appium</kbd> replaces the iPhoneDriver and AndroidDriver APIs in Selenium 2 that were used to test mobile web applications.</p>
<p class="mce-root"/>
<p class="mce-root"><kbd>Appium</kbd> enables the use and extension of the existing Selenium WebDriver framework to build mobile tests. As it uses Selenium WebDriver to drive the tests, we can use any programming language to create tests for a Selenium client library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a project in Eclipse with Maven and TestNG using Java</h1>
                </header>
            
            <article>
                
<p>Selenium WebDriver is a library that helps you automate browsers. However, much more is needed when using it for testing and building a test framework or automating browsers for non-testing purposes. You will need an Integrated Development Environment (<strong>IDE</strong>) or a code editor to create a new Java project and add Selenium WebDriver and other dependencies in order to build a testing framework.</p>
<p>In the Java development community, Eclipse is a widely-used IDE, as well as IntelliJ IDEA and NetBeans. Eclipse provides a feature-rich environment for Selenium WebDriver test-development.</p>
<p>Along with Eclipse, Apache Maven provides support for managing the life cycle of a test project. Maven is used to define the project structure, dependencies, build, and test-management.</p>
<p>We can use Eclipse and Maven to build our Selenium WebDriver test framework from a single window. Another important benefit of using Maven is that we can get all the Selenium library files and their dependencies by configuring the pom.xml file. Maven automatically downloads the necessary files from the repository while building the project.</p>
<p>In this section, we will learn how to configure Eclipse and Maven for the Selenium WebDriver test development. Most of the code in this book has been developed in Eclipse and Maven.</p>
<p>You will need Eclipse and Maven to set up the test-development environment. Download and set up Maven from <a href="http://maven.apache.org/download.html">http://maven.apache.org/download.html</a>. Follow the instructions on the Maven download page (see the Installation Instructions section of the page).</p>
<p>Download and set up Eclipse IDE for Java Developers from <a href="https://eclipse.org/downloads/">https://eclipse.org/downloads/</a></p>
<p>Along with Eclipse and Maven, we will also use TestNG as a testing framework for our project. The TestNG library will help us define test cases, test fixtures, and assertions. We need to install the TestNG plugin for Eclipse via Eclipse Marketplace.</p>
<p>Let's configure Eclipse with Maven to develop Selenium WebDriver tests using the following steps:</p>
<ol>
<li>Launch the <span class="packt_screen">Eclipse IDE</span>.</li>
<li>Create a new project by selecting <span class="packt_screen">File | New | Other</span> from the Eclipse <span class="packt_screen">Main Menu</span>.</li>
<li>On the <span class="packt_screen">New</span> dialog, select <span class="packt_screen">Maven | Maven Project</span>, as shown in the following screenshot, and click <span class="packt_screen">Next</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/84b40e3b-fe30-4866-a448-47dec065c1ef.png" style="width:39.25em;height:37.33em;"/></div>
<ol start="4">
<li>The <span class="packt_screen">New Maven Project</span><span> </span>dialog<span> </span>will be displayed. Select the <span class="packt_screen">Create a simple project (skip archetype selection) checkbox</span> and click on the <span class="packt_screen">Next</span> button, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8abd601e-4710-48fb-aa46-8bd4d9648eb6.png" style="width:42.25em;height:37.25em;"/></div>
<ol start="5">
<li>On the <span class="packt_screen">New Maven Project</span> dialog box, enter <strong><em>com.example</em></strong> in the <span class="packt_screen">Group Id:</span> textbox and <strong><em>chapter1</em></strong> in the <span class="packt_screen">Artifact Id:</span> textbox. You can also add a name and description. Click on the <span class="packt_screen">Finish</span> button, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/aaaed783-5ef5-4e1e-b32b-dd1a4c704d52.png" style="width:45.92em;height:40.50em;"/></div>
<ol start="6">
<li><span>Eclipse will create the <strong><em>chapter1</em></strong> project with a structure (in <span class="packt_screen">Package Explorer</span>) similar to the one shown in the following screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/59e3dbc7-75cc-4827-8cc6-8728ffe6551e.png"/></div>
<ol start="7">
<li><span>Select <span class="packt_screen">pom.xml</span> from <span class="packt_screen">Package Explorer</span>. This will open the <span class="packt_screen">pom.xml</span> file in the editor area with the <strong>Overview</strong> tab open. Select the <strong>pom.xml</strong> tab next to the <span class="packt_screen">Overview</span> tab, as shown in the following screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/febf79fa-3b4c-4f59-9314-393375c11bc8.png"/></div>
<ol start="8">
<li>Add the Selenium WebDriver and TestNG dependencies highlighted in the following code snippet to <span class="packt_screen">pom.xml</span> in the between <kbd>project</kbd> node:</li>
</ol>
<pre style="padding-left: 60px"><strong>&lt;properties&gt;<br/> &lt;java.version&gt;1.8&lt;/java.version&gt;<br/> &lt;selenium.version&gt;3.13.0&lt;/selenium.version&gt;<br/> &lt;testng.version&gt;6.13.1&lt;/testng.version&gt;<br/> &lt;maven.compiler.version&gt;3.7.0&lt;/maven.compiler.version&gt;<br/></strong><span><strong>&lt;/properties&gt;</strong><br/></span><span><br/></span><strong>&lt;dependencies&gt;<br/> &lt;dependency&gt;<br/> &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;<br/> &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;<br/> &lt;version&gt;${selenium.version}&lt;/version&gt;<br/> &lt;/dependency&gt;<br/> &lt;dependency&gt;<br/> &lt;groupId&gt;org.testng&lt;/groupId&gt;<br/> &lt;artifactId&gt;testng&lt;/artifactId&gt;<br/> &lt;version&gt;${testng.version}&lt;/version&gt;<br/> &lt;/dependency&gt;<br/>&lt;/dependencies&gt;<br/><br/>&lt;build&gt;<br/> &lt;plugins&gt;<br/> &lt;plugin&gt;<br/> &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/> &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br/> &lt;version&gt;${maven.compiler.version}&lt;/version&gt;<br/> &lt;configuration&gt;<br/> &lt;source&gt;${java.version}&lt;/source&gt;<br/> &lt;target&gt;${java.version}&lt;/target&gt;<br/> &lt;/configuration&gt;<br/> &lt;/plugin&gt;<br/> &lt;/plugins&gt;<br/>&lt;/build&gt;</strong></pre>
<ol start="9">
<li><span>Select <em><strong><span class="packt_screen">src/test/java</span></strong></em> in <span class="packt_screen">Package Explorer</span> and right-click on it to show the menu. Select <span class="packt_screen">New | Other</span>, as shown in the following screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4dfc74b9-5e7a-4bc8-9464-462c1f3ee2eb.png" style="width:35.75em;height:25.83em;"/></div>
<ol start="10">
<li>Select the <span class="packt_screen">TestNG | TestNG</span> class from the <span class="packt_screen">Select a wizard</span> dialog, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/686fa9e7-cbef-45ac-8626-24e569aac808.png" style="width:39.67em;height:37.75em;"/></div>
<ol start="11">
<li>On the <span class="packt_screen">New TestNG class</span> dialog box, enter <strong><em>/chapter1/src/test/java</em></strong> in the <span class="packt_screen">Source folder:</span> field. Enter <span class="packt_screen">com.example</span> in the <span class="packt_screen">Package name:</span> field. Enter <span class="packt_screen">NavigationTest</span> in the <span class="packt_screen">Class name:</span> field. Select the <span class="packt_screen">@BeforeMethod</span> and <span class="packt_screen">@AfterMethod</span> checkboxes and add <kbd>src/test/resources/suites/testng.xml</kbd> in the <span class="packt_screen">XML suite file:</span> field. Click on the <span class="packt_screen">Finish</span> button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5548a321-387e-4b67-8c87-9431b4c8b168.png" style="width:38.92em;height:33.00em;"/></div>
<ol start="12">
<li><span>This will create the <em><strong><span class="packt_screen">NavigationTest.java</span></strong></em> class in the <span class="packt_screen">com.example</span> package with TestNG annotations such as <kbd>@Test</kbd>, <kbd>@BeforeMethod</kbd>, and <kbd>@AfterMethod</kbd>, and the <kbd>beforeMethod</kbd> and <kbd>afterMethod</kbd> methods:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6c71fcdc-148a-494f-8f12-47723f3bd1fc.png"/></div>
<ol start="13">
<li><span> Modify the <kbd>NavigationTest</kbd> class with following code</span><span><span>:</span></span></li>
</ol>
<pre style="padding-left: 90px">package <span>com.example</span><span>;<br/></span><span>import </span>org.openqa.selenium.WebDriver<span>;<br/></span><span>import </span>org.openqa.selenium.chrome.ChromeDriver<span>;<br/></span><span>import </span>org.testng.Assert<span>;<br/></span><span>import </span>org.testng.annotations.*<span>;<br/></span><span><br/></span><span>public class </span>NavigationTest {<br/><br/>    WebDriver <span>driver</span><span>;<br/></span><span><br/></span><span>    </span><span>@BeforeMethod<br/></span><span>    </span><span>public void </span><span>beforeMethod</span>() {<br/><br/>        <span>// set path of Chromedriver executable<br/></span><span>        </span>System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span><br/></span><span>        </span><span>// initialize new WebDriver session<br/></span><span>        </span><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Test<br/></span><span>    </span><span>public void </span><span>navigateToAUrl</span>() {<br/>        <span>// navigate to the web site<br/></span><span>        </span><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com/"</span>)<span>;</span><span><br/></span><span>        </span><span>// Validate page title<br/></span><span>        </span>Assert.<span>assertEquals</span>(<span>driver</span>.getTitle()<span>, </span><span>"Madison Island"</span>)<span>;<br/></span><span>    </span>}<br/>    <span>@AfterMethod<br/></span><span>    </span><span>public void </span><span>afterMethod</span>() {<br/><br/>        <span>// close and quit the browser<br/></span><span>        </span><span>driver</span>.quit()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>In the preceding code, three methods are added as part of the <kbd>NavigationTest</kbd> class. We also declared a <kbd>WebDriver driver;</kbd> instance variable, which we will use later in the test to launch a browser and navigate to the site.</p>
<p><kbd>beforeMethod()</kbd>, which is annotated with the <kbd>@BeforeMethod</kbd> TestNG annotation, will execute before the test method. It will set the path of the <em>chromedriver</em> executable required by Google Chrome. It will then instantiate the driver variable using the <kbd>ChromeDriver()</kbd> class. This will launch a new Google Chrome window on the screen.</p>
<p>The next method, <kbd>navigateToAUrl()</kbd>, annotated with the <kbd>@Test</kbd> annotation is the test method. We will call the <kbd>get()</kbd> method of the WebDriver interface passing the URL of the application. This will navigate to the site in the browser. We will check the title of the page by calling TestNG's <kbd>Assert.assertEquals</kbd> method and the <kbd>getTitle()</kbd> method of the WebDriver interface.</p>
<p>Lastly, <kbd>afterMethod()</kbd> is annotated with the <kbd>@AfterMethod</kbd> TestNG annotation will close the browser window. </p>
<div class="packt_infobox">We need to download and copy the chromedriver executable from <a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">https://sites.google.com/a/chromium.org/chromedriver/downloads</a>. Download the appropriate version based on the Google Chrome browser version installed on your computer as well as the operating system. Copy the executable file in the <kbd>/src/test/resources/ drivers</kbd> folder.</div>
<p><span>To run the tests, right-click in the code editor and select <span class="packt_screen">Run As | TestNG Test</span>, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c6a4dc78-ebbf-4123-807b-4434c06a8991.png"/></div>
<p>This will launch a new Google Chrome browser window and navigate to the site. The test will validate the page title and the browser window will be closed at the end of the test. The TestNG Plugin will display results in Eclipse:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/32793ec0-2892-40f0-bd7e-4506701ddc11.png"/></div>
<div>
<div class="page">
<div class="layoutArea">
<div class="column packt_infobox"><span>You can download the example code files for all the Packt books you have</span> <span>purchased from your account at</span> <a href="http://www.packtpub.com"><span>http://www.packtpub.com</span></a><span>. If you have purchased this book elsewhere, you can visit</span> <span>http://www.packtpub. com/support</span> <span>and register to have the files emailed directly to you. </span><span>The example code is also hosted at <a href="https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition">https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition</a></span></div>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebElements</h1>
                </header>
            
            <article>
                
<p>A web page is composed of many different types of HTML elements, such as links, textboxes, dropdown buttons, a body, labels, and forms. These are called WebElements in the context of WebDriver. Together, these elements on a web page will achieve the user functionality. For example, let's look at the HTML code of the login page of a website:    </p>
<pre><span>&lt;html&gt;<br/></span><span>&lt;body&gt;<br/></span><span>    &lt;form </span><span>id</span><span>="loginForm"</span><span>&gt;<br/></span><span>        &lt;label&gt;</span>Enter Username: <span>&lt;/label&gt;<br/></span><span>        &lt;input </span><span>type</span><span>="text" </span><span>name</span><span>="Username"</span><span>/&gt;<br/></span><span>        &lt;label&gt;</span>Enter Password: <span>&lt;/label&gt;<br/></span><span>        &lt;input </span><span>type</span><span>="password" </span><span>name</span><span>="Password"</span><span>/&gt;<br/></span><span>        &lt;input </span><span>type</span><span>="submit"</span><span>/&gt;<br/></span><span>    &lt;/form&gt;<br/></span><span>    &lt;a </span><span>href</span><span>="forgotPassword.html"</span><span>&gt;</span>Forgot Password ?<span>&lt;/a&gt;<br/></span><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>
<p>In the preceding HTML code, there are different types of WebElements, such as <kbd><span>&lt;html&gt;</span></kbd>, <kbd><span>&lt;body&gt;</span></kbd>, <kbd><span>&lt;form&gt;</span></kbd>, <kbd><span>&lt;label&gt;</span></kbd>, <kbd><span>&lt;input&gt;</span></kbd>, and <kbd><span>&lt;a&gt;</span></kbd>, which together make a web page provide the Login feature for the user. Let's analyze the following WebElement:</p>
<pre><span>&lt;label&gt;</span>Enter Username: <span>&lt;/label&gt;</span></pre>
<p class="mce-root"/>
<p>Here, <kbd><span>&lt;label&gt;</span></kbd> is the start tag of the WebElement label. <kbd>Enter Username:</kbd> is the text present on the <kbd>label</kbd> element. Finally, <span><kbd>&lt;/label&gt;</kbd></span> is the end tag, which indicates the end of a WebElement.</p>
<p>Similarly, take another WebElement:                                                                 </p>
<pre><span>&lt;input</span> <span>type</span><span>="text"</span> <span>name</span><span>="Username"</span><span>/&gt;</span></pre>
<p>In the preceding code, <kbd>type</kbd> and <kbd>name</kbd> are the attributes of the WebElement <kbd>input</kbd> with the <kbd>text</kbd> and <kbd>Username</kbd> values, respectively.</p>
<p>UI-automation using Selenium is mostly about locating these WebElements on a web page and executing user actions on them. In the rest of the chapter, we will use various methods to locate WebElements and execute relevant user actions on them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Locating WebElements using WebDriver </h1>
                </header>
            
            <article>
                
<p>Let's start this section by automating the Search feature from the Homepage of the demo application, <a href="http://demo-store.seleniumacademy.com/">http://demo-store.seleniumacademy.com/</a>, which involves navigating to the homepage, typing the search text in the textbox, and executing the search. The code is as follows:</p>
<pre><span>im</span><span>port </span>org.openqa.selenium.By<span>;<br/></span><span>import </span>org.openqa.selenium.WebDriver<span>;<br/></span><span>import </span>org.openqa.selenium.WebElement<span>;<br/></span><span>import </span>org.openqa.selenium.chrome.ChromeDriver<span>;<br/></span><span>import </span>org.testng.annotations.<span>AfterMethod</span><span>;<br/></span><span>import </span>org.testng.annotations.<span>BeforeMethod</span><span>;<br/></span><span>import </span>org.testng.annotations.<span>Test</span><span>;<br/></span><span><br/></span><span>import static </span>org.assertj.core.api.AssertionsForClassTypes.<span>assertThat</span><span>;<br/></span><span><br/></span><span>public class </span>SearchTest {<br/><br/>    WebDriver <span>driver</span><span>;<br/></span><span><br/></span><span>    </span><span>@BeforeMethod<br/></span><span>    </span><span>public void </span><span>setup</span>() {<br/>        System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span>        </span><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>        </span><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com/"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Test<br/></span><span>    </span><span>public void </span><span>searchProduct</span>() {<br/>        <span>// find search box and enter search string<br/></span><span>        </span><strong>WebElement searchBox = driver.findElement(By.name("q"))</strong><span><strong>;</strong><br/></span><span>        </span>searchBox.sendKeys(<span>"Phones"</span>)<span>;<br/></span><span>        </span><strong>WebElement searchButton = </strong><br/><strong>                driver.findElement(By.className("search-button"))</strong><span><strong>;</strong><br/></span><span>        </span>searchButton.click()<span>;<br/></span><span>        </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>                .isEqualTo(<span>"Search results for: 'Phones'"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@AfterMethod<br/></span><span>    </span><span>public void </span><span>tearDown</span>() {<br/>        <span>driver</span>.quit()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>As you can see, there are three new things that are highlighted, as follows:</p>
<pre><strong>WebElement</strong> searchBox = driver.<strong>findElement(By.name("q"))</strong>;</pre>
<p>They are the <kbd>findElement()</kbd> method, the <kbd>By.name()</kbd> method, and the <kbd>WebElement</kbd> interface. The <kbd>findElement()</kbd> and <kbd>By()</kbd> methods instruct WebDriver to locate a <kbd>WebElement</kbd> on a web page, and once found, the <kbd>findElement()</kbd> method returns the <kbd>WebElement</kbd> instance of that element. Actions, such as click and type, are performed on a returned <kbd>WebElement</kbd> using the methods declared in the <kbd>WebElement</kbd> interface, which will be discussed in detail in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The findElement method</h1>
                </header>
            
            <article>
                
<p>In UI automation, locating an element is the first step before executing any user actions on it. WebDriver's <kbd>findElement()</kbd> method is a convenient way to locate an element on the web page. According to WebDriver's Javadoc (<a href="http://seleniumhq.github.io/selenium/docs/api/java/index.html">http://selenium.googlecode.com/git/docs/api/java/index.html</a>), the method declaration is as follows:</p>
<pre>WebElement findElement(By by)</pre>
<p>So, the input parameter for the <kbd>findElement()</kbd> method is the <kbd>By</kbd> instance. The <kbd>By</kbd> instance is a WebElement-locating mechanism. There are eight different ways to locate a WebElement on a web page. We will see each of these eight methods later in the chapter.</p>
<p class="mce-root"/>
<p>The return type of the <kbd>findElement()</kbd> method is the WebElement instance that represents the actual HTML element or component of the web page. The method returns the first WebElement that the driver comes across that satisfies the locating-mechanism condition. This WebElement instance will act as a handle to that component from then on. Appropriate actions can be taken on that component by the test-script developer using this returned WebElement instance.</p>
<p>If WebDriver doesn't find the element, it throws a runtime exception named <kbd>NoSuchElementException</kbd>, which the invoking class or method should handle. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The findElements method</h1>
                </header>
            
            <article>
                
<p>For finding multiple elements matching the same locator criteria on a web page, the <kbd>findElements()</kbd> method can be used. It returns a list of WebElements found for a given locating mechanism. The method declaration of the <kbd>findElements()</kbd> method is as follows:</p>
<pre>java.util.List findElements(By by)</pre>
<p>The input parameter is the same as the <kbd>findElement()</kbd> method, which is an instance of the <kbd>By</kbd> class. The difference lies in the return type. Here, if no element is found, an empty list is returned and if there are multiple WebElements present that satisfy the locating mechanism, all of them are returned to the caller in a list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inspecting Elements with Developer Tools</h1>
                </header>
            
            <article>
                
<p>Before we start exploring how to find elements on a page and what locator mechanism to use, we need to look at the HTML code of the page to understand the Document Object Model (<strong>DOM</strong>) tree, what properties or attributes are defined for the elements displayed on the page, and how JavaScript or AJAX calls are made from the application. browsers use the HTML code written for the page to render visual elements in the browser window. It uses other resources, including JavaScript, CSS, and images, to decide on the look, feel, and behavior of these elements.</p>
<p class="mce-root"/>
<p>Here is an example of a login page of the demo application and the HTML code written to render this page in a browser, as displayed in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/abf78c19-fab7-46a2-9ad3-51fe0ffa8758.png"/></div>
<p>We need tools that can display the HTML code of the page in a structured and easy-to-understand format. Almost all browsers now offer Developer tools to inspect the structure of the page and associated resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inspecting pages and elements with Mozilla Firefox</h1>
                </header>
            
            <article>
                
<p>The newer versions of Mozilla Firefox provide built-in ways to inspect the page and elements. To inspect an element from the page, move the mouse over the desired element and right-click to open the pop-up menu. Select the <strong><span class="packt_screen">Inspect Element</span></strong> option, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f81e2d68-fb90-4d4f-b186-2fa8594c3543.png" style="width:33.42em;height:27.08em;"/></div>
<p>This will display the <span class="packt_screen">Inspector</span> tab with the HTML code in a tree format with the selected element highlighted, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4058e793-e9b3-407f-8918-7a0b90aaf34b.png"/></div>
<p class="mce-root"/>
<p>Using <span class="packt_screen">Inspector</span>, we can also validate the XPath or CSS Selectors using the search box shown in the <span class="packt_screen">Inspector</span> section. Just enter the XPath or CSS Selector and <span class="packt_screen">Inspector</span> will highlight the elements that match the expression, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1a408ea7-82f2-4d2e-b169-75b78bc32142.png"/></div>
<p>The Developer tools provide various other debugging features. It also generates XPath and CSS selectors for elements. For this, select the desired element in the tree, right-click, and select the <span class="packt_screen">Copy &gt;</span> <span class="packt_screen">XPath</span> or <span class="packt_screen">Copy &gt; CSS Path</span> option from the pop-up menu, as shown in the following screenshot:  </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/71a679b3-2ce1-4546-9e1e-cf63a696088f.png" style="width:34.17em;height:26.08em;"/></div>
<p>This will paste the suggested XPath or CSS selector value to the clipboard to be used later with the <kbd>findElement()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inspecting pages and elements in Google Chrome with Developer Tools</h1>
                </header>
            
            <article>
                
<p>Similar to Mozilla Firefox, Google Chrome also provides a<span> </span>built-in<span> </span>feature to inspect pages and elements. We can move the mouse over a desired element on the page, right-click to open the pop-up menu, and then select the <span class="packt_screen">Inspect element</span> option. This will open Developer tools in the browser, which displays information similar to that of Firefox, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/da72f733-a2ee-4bff-a6b8-be04dcff9d01.png"/></div>
<p class="mce-root"/>
<p>Similar to Firefox, we can also test XPath and CSS Selectors in Google Chrome Developer tools. Press <em>Ctrl + F</em> (on Mac, use <em>Command + F</em>) in the <span class="packt_screen">Elements</span> tab. This will display a search box. Just enter <em>XPath</em> or <em>CSS Selector</em>, and matching elements will be highlighted in the tree, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/67ecbaf8-2338-47da-b959-8c993e44ecce.png"/></div>
<p>Chrome Developer Tools also provides a feature where you can get the XPath for an element by right-clicking on the desired element in the tree and selecting the <span class="packt_screen">Copy <span class="packt_screen">XPath</span></span> option from the pop-up menu.</p>
<div class="packt_infobox">Similar to Mozilla Firefox and Google Chrome, you will find similar Developer tools in any major browser, including Microsoft Internet Explorer and Edge.</div>
<p>Browser developer tools come in really handy during the test-script development. These tools will help you to find the locator details for the elements with which you need to interact as part of the test. These tools parse the code for a page and display the information in a hierarchal tree. </p>
<div class="packt_tip">WebElements on a web page may not have all the attributes declared. It is up to the developer of the test script to select the attribute that uniquely identifies the WebElement on the web page for the automation.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the By locating mechanism</h1>
                </header>
            
            <article>
                
<p>By is the locating mechanism passed to the <kbd>findElement()</kbd> method or the <kbd>findElements()</kbd> method to fetch the respective WebElement(s) on a web page. There are eight different locating mechanisms; that is, eight different ways to identify</p>
<p>an HTML element on a web page. They are located by <span class="packt_screen">ID</span>, <span class="packt_screen">Name</span>, <span class="packt_screen">ClassName</span>, <span class="packt_screen">TagName</span>, <span class="packt_screen">LinkText</span>, <span class="packt_screen">PartialLinkText</span>, <span class="packt_screen">XPath</span>, and <span class="packt_screen">CSS</span> Selector.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.id() method</h1>
                </header>
            
            <article>
                
<p>On a web page, each element is uniquely identified by an ID attribute, which is optionally provided. An ID can be assigned manually by the developer of the web application or left to be dynamically generated by the application. Dynamically-generated IDs can be changed on every page refresh or over a period of time. Now, consider the HTML code of the Search box:</p>
<pre><span>&lt;input <strong>id="search"</strong> type="search" </span>name="q"<span> value="" class="input-text r</span><span>equired-entry" maxlength="128" placeholder="Search entire store here..." autocomplete="off"&gt;</span></pre>
<p>In the preceding code, the<span> </span><kbd>id</kbd> attribute value of the search box is<span> </span><kbd>search</kbd>.</p>
<p>Let's see how to use the ID attribute as a locating mechanism to find the Search box:</p>
<pre><span>@Test<br/></span><span>public void </span><span>byIdLocatorExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(<strong>By.id("search")</strong>)<span>;<br/></span><span>    </span>searchBox.sendKeys(<span>"Bags"</span>)<span>;<br/></span><span>    </span>searchBox.submit()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'Bags'"</span>)<span>;<br/></span>}</pre>
<p>In preceding code, we used the<span> </span><kbd>By.id()</kbd><span> </span><span>method</span><span> </span><span>and the search box's</span><span> </span><kbd>id</kbd><span> attribute value to find the element.</span></p>
<p>Here, try to use the<span> </span><kbd>By.id</kbd><span> </span>identifier, and use the name value (that is,<span> </span><kbd>q</kbd>) instead of the<span> </span><kbd>id</kbd><span> </span>value (that is,<span> </span><kbd>search</kbd>). Modify line three as follows:</p>
<pre>WebElement searchBox = driver.findElement(<strong>By.id("q")</strong>); </pre>
<p>The test script will fail to throw an exception, as follows:</p>
<pre>Exception in thread "main"<span> </span>org.openqa.selenium.NoSuchElementException: Unable to locate element: {"method":"id","selector":"q"}</pre>
<p>WebDriver couldn't find an element by<span> </span><kbd>id</kbd><span> </span>whose value is<span> </span><kbd>q</kbd>. Thus, it throws an exception saying<span> </span><kbd>NoSuchElementException</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.name() method</h1>
                </header>
            
            <article>
                
<p>As seen earlier, every element on a web page has many attributes. Name is one of them. For instance, the HTML code for the Search box is:</p>
<pre>&lt;input id="search" type="search" name="q" value="" class="input-text required-entry" maxlength="128" placeholder="Search entire store here..." autocomplete="off"&gt;</pre>
<p>Here, <kbd>name</kbd> is one of the many attributes of the search box, and its value is <kbd>q</kbd>. If we want to identify this search box and set a value in it in your test script, the code will look as follows:</p>
<pre><span>@Test<br/></span><span>public void </span><span>searchProduct</span>() {<br/>    <span>// find search box and enter search string<br/></span><span>    </span>WebElement searchBox = <span>driver</span>.findElement(<strong>By.name("q")</strong>)<span>;<br/></span><span>    </span>searchBox.sendKeys(<span>"Phones"</span>)<span>;<br/></span><span>    </span>searchBox.submit()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'Phones'"</span>)<span>;<br/></span>}</pre>
<p>If you observe line four, the locating mechanism used here is <kbd>By.name</kbd> and the name is <kbd>q</kbd>. So, where did we get this name from? As discussed in the previous section, it is the browser developer tools that helped us get the name of the button. Launch Developer tools and use the inspect elements widget to get the attributes of an element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.className() method</h1>
                </header>
            
            <article>
                
<p>Before we discuss the <kbd>className()</kbd> method, we have to talk a little about style and CSS. Every HTML element on a web page, generally, is styled by the web page developer or designer. It is not mandatory that each element should be styled, but they generally are to make the page appealing to the end user.</p>
<p>So, in order to apply styles to an element, they can be declared directly in the element tag, or placed in a separate file called the CSS file and can be referenced in the element using the <kbd>class</kbd> attribute. For instance, a style attribute for a button can be declared in a CSS file as follows:</p>
<pre>.buttonStyle{<br/>    width: 50px;<br/>    height: 50px;<br/>    border-radius: 50%;<br/>    margin: 0% 2%;<br/>}</pre>
<p>Now, this style can be applied to the button element in a web page as follows:</p>
<pre class="mce-root">&lt;button name="sampleBtnName" id="sampleBtnId" <strong>class="buttonStyle"</strong>&gt;I'm Button&lt;/button&gt;</pre>
<p>So, <kbd>buttonStyle</kbd> is used as the value for the <kbd>class</kbd> attribute of the button element, and it inherits all the styles declared in the CSS file. Now, let's try this on our Homepage. We will try to make WebDriver identify the search button using its class name and click on it.</p>
<p>First, in order to get the class name of the search button, as we know, we will use Developers tools to fetch it. After getting it, change the location mechanism to <kbd>By.className</kbd> and specify the class attribute value in it. The code for that is as follows:</p>
<pre><span>@Test<br/></span><span>public void </span><span>byClassNameLocatorExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>id</span>(<span>"search"</span>))<span>;<br/></span><span>    </span>searchBox.sendKeys(<span>"Electronics"</span>)<span>;<br/></span><span>    </span>WebElement searchButton = <br/>            <span>driver</span>.findElement(<strong>By.className("search-button")</strong>)<span>;<br/></span><span>    </span>searchButton.click()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'Electronics'"</span>)<span>;<br/></span>}</pre>
<p>In the preceding code, we have used the <kbd>By.className</kbd> locating mechanism by passing the class attribute value to it.</p>
<p>Sometimes, an element might have multiple values given for the <kbd>class</kbd> attribute. For example, the Search button has <em>button</em> and <em>search-button</em> values specified in the <kbd>class</kbd> attribute in the following HTML snippet:</p>
<pre>&lt;button type="submit" title="Search" class="button search-button"&gt;&lt;span&gt;&lt;span&gt;Search&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;</pre>
<p>We have to use one of the values of the <kbd>class</kbd> attribute with the <kbd>By.className</kbd> method. In this case, we can either use <em>button</em> or <em>search-button</em>, whichever uniquely identifies the element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.linkText() method</h1>
                </header>
            
            <article>
                
<p>As the name suggests, the <kbd>By.linkText</kbd> locating mechanism can only be used to identify the HTML links. Before we start discussing how WebDriver can be commanded to identify a link element using link text, let's see what an HTML link element looks like. The HTML link elements are represented on a web page using the <kbd><span>&lt;a&gt;</span></kbd> tag, an abbreviation for the anchor tag. A typical anchor tag looks like this:</p>
<pre>&lt;a href="http://demo-store.seleniumacademy.com/customer/account/" title="My Account"&gt;My Account&lt;/a&gt;</pre>
<p>Here,<span> </span><kbd>href</kbd><span> </span>is the link to a different page where your web browser will take you when you click on the link. So, the preceding HTML code when rendered by the browser looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b54093b6-14c6-4354-b0b7-cd34a68d245e.png" style="width:23.92em;height:9.67em;"/></div>
<p>This <strong>MY ACCOUNT</strong> is the link text. So the <kbd>By.linkText</kbd> locating mechanism uses this text on an anchor tag to identify the WebElement. The code would look like this:</p>
<pre><span>@Test<br/></span><span>public void </span><span>byLinkTextLocatorExample</span>() {<br/>    WebElement myAccountLink = <br/>            <span>driver</span>.findElement(<strong>By.linkText("MY ACCOUNT")</strong>)<span>;<br/></span><span>    </span>myAccountLink.click()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Customer Login"</span>)<span>;<br/></span>}</pre>
<p><span>Here, the <kbd>By.linkText</kbd> locating mechanism is used to identify the <strong>MY ACCOUNT</strong> link.<br/></span></p>
<div class="packt_infobox">The <kbd>linkText</kbd> and <kbd>partialLinkText</kbd> methods are case-sensitive. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.partialLinkText() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>By.partialLinkText</kbd> locating mechanism is an extension of the <kbd>By.linkText</kbd> locator. If you are not sure of the entire link text or want to use only part of the link text, you can use this locator to identify the link element. So, let's modify the previous example to use only partial text on the link; in this case, we will use Privacy from the Privacy Policy link in the site footer:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1dcdff51-63dc-4c09-9b1c-4c85b3a9777a.png" style="width:12.33em;height:9.08em;"/></div>
<p><span>The code would look like this:</span></p>
<pre><span>@Test<br/></span><span>public void </span><span>byPartialLinkTextLocatorExample</span>() {<br/>    WebElement orderAndReturns = <br/>            <span>driver</span>.findElement(<strong>By.partialLinkText("PRIVACY")</strong>)<span>;<br/></span><span>    </span>orderAndReturns.click()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Privacy Policy"</span>)<span>;<br/></span>}</pre>
<p class="mce-root"/>
<p>What happens if there are multiple links whose text has <em>Privacy</em> in it? That is a question for the <kbd>findElement()</kbd> method rather than the locator. Remember when we discussed the <kbd>findElement()</kbd> method earlier, it will return only the first WebElement that it comes across. If you want all the WebElements that contain <em>Privacy</em> in its link text, use the <kbd>findElements()</kbd> method, which will return a list of all those elements.</p>
<div class="packt_tip">Use WebDriver's <kbd>findElements()</kbd> method if you think you need all the WebElements that satisfy a locating-mechanism condition.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.tagName() method</h1>
                </header>
            
            <article>
                
<div>
<p>Locating an element by tag name is slightly different from the locating mechanisms we saw earlier. For example, on a  Homepage, if you search for an element with the <kbd>button</kbd> tag name, it will result in multiple WebElements because there are nine buttons present on the Homepage. So, it is always advisable to use the <kbd>findElements()</kbd> method rather than the <kbd>findElement()</kbd> method when trying to locate elements using tag names.</p>
<p>Let's see how the code looks when a search for the number of links present on a  Homepage is made:</p>
<pre><span>@Test<br/></span><span>public void </span><span>byTagNameLocatorExample</span>() {<br/><br/>    <span>// get all links from the Home page<br/></span><span>    </span>List&lt;WebElement&gt; links = <span>driver</span>.findElements(<strong>By.tagName("a")</strong>)<span>;<br/></span><span><br/></span><span>    </span>System.<span>out</span>.println(<span>"Found links:" </span>+ links.size())<span>;<br/></span><span><br/></span><span>    </span><span>// print links which have text using Java 8 Streams API<br/></span><span>    </span>links.stream()<br/>            .filter(elem -&gt; elem.getText().length() &gt; <span>0</span>)<br/>            .forEach(elem -&gt; System.<span>out</span>.println(elem.getText()))<span>;<br/></span>}</pre>
<p>In the preceding code, we have used the <kbd>By.tagName</kbd> locating mechanism and the <kbd>findElements()</kbd> method, which return a list of all the links, that is, the <kbd>a</kbd> anchor tags defined on the page. On line five,  we printed the size of the list, and then printed text of only links where the text has been provided. We use the Java 8 Stream API to filter the element list and output the text value by calling the <kbd>getText()</kbd> method. This will generate the following output:</p>
<pre><span class="packt_screen">Found links:88<br/> ACCOUNT<br/> CART<br/> WOMEN<br/> ...</span></pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.xpath() method</h1>
                </header>
            
            <article>
                
<p>WebDriver uses <strong>XPath</strong> to identify a WebElement on the web page. Before we see how it does that, let's quickly look at the syntax for XPath. XPath is a short name for the XML path, the query language used for searching XML documents. The HTML for our web page is also one form of the XML document. So, in order to identify an element on an HTML page, we need to use a specific XPath syntax:</p>
<ul>
<li>The root element is identified as <kbd>//</kbd>.</li>
<li>To identify all the div elements, the syntax will be <kbd>//div</kbd>.</li>
<li>To identify the link tags that are within the div element, the syntax will be <kbd>//div/a</kbd>.</li>
<li>To identify all the elements with a tag, we use *. The syntax will be <kbd>//div/*</kbd>.</li>
<li>To identify all the div elements that are at three levels down from the root, we can use <kbd>//*/*/div</kbd>.</li>
<li>To identify specific elements, we use attribute values of those elements, such as <kbd>//*/div/a[@id='attrValue']</kbd>, which will return the anchor element. This element is at the third level from the root within a <kbd>div</kbd> element and has an <kbd>id</kbd> value of <kbd>attrValue</kbd>.</li>
</ul>
<p>So, we need to pass the XPath expression to the <kbd>By.xpath</kbd> locating mechanism to make it identify our target element. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, let's see the code example and how WebDriver uses this XPath to identify the element:</p>
<pre><span>@Test<br/></span><span>public void </span><span>byXPathLocatorExample</span>() {<br/>    WebElement searchBox = <br/>            <span>driver</span>.findElement(<strong>By.xpath("//*[@id='search']")</strong>)<span>;<br/></span><span>    </span>searchBox.sendKeys(<span>"Bags"</span>)<span>;<br/></span><span>    </span>searchBox.submit()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'Bags'"</span>)<span>;<br/></span>}</pre>
<p>In the preceding code, we are using the <kbd>By.xpath</kbd> locating mechanism and passing the XPath of the WebElement to it.</p>
<p>One disadvantage of using XPath is that it is costly in terms of time. For every element to be identified, WebDriver actually scans through the entire page, which is very time consuming, and too much usage of XPath in your test script will actually make it too slow to execute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The By.cssSelector() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>By.cssSelector()</kbd> method is similar to the <kbd>By.xpath()</kbd> method in its usage, but the difference is that it is slightly faster than the <kbd>By.xpath</kbd> locating mechanism. The following are the commonly used syntaxes to identify elements:</p>
<ul>
<li>To identify an element using the div element with the <kbd>#flrs</kbd> ID, we use the <kbd>#flrs</kbd> syntax</li>
<li>To identify the child anchor element, we use the <kbd>#flrs &gt; a</kbd> syntax, which will return the link element</li>
<li>To identify the anchor element with its attribute, we use the <kbd>#flrs &gt; a[a[href="/intl/en/about.html"]]</kbd> syntax</li>
</ul>
<p>Let's try to modify the previous code, which uses the XPath locating mechanism to use the <kbd>cssSelector</kbd> mechanism:</p>
<pre><span>@Test<br/></span><span>public void </span><span>byCssSelectorLocatorExample</span>() {<br/>    WebElement searchBox = <br/>            <span>driver</span>.findElement(<strong>By.cssSelector("#search")</strong>)<span>;<br/></span><span>    </span>searchBox.sendKeys(<span>"Bags"</span>)<span>;<br/></span><span>    </span>searchBox.submit()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'Bags'"</span>)<span>;<br/></span>}</pre>
<p>The preceding code uses the <kbd>By.cssSelector</kbd> locating mechanism, which uses the css selector <kbd>ID</kbd> of the Search box.</p>
<p>Let's look at a slightly complex example. We will try to identify the About Us on the Homepage:</p>
<pre><span>@Test<br/></span><span>public void </span><span>byCssSelectorLocatorComplexExample</span>() {<br/><br/>    WebElement aboutUs =<br/>            <span>driver</span>.findElement(By<br/>                    .<span>cssSelector</span>(<span>"a[href*='/about-magento-demo-store/']"</span>))<span>;<br/></span><span><br/></span><span>    </span>aboutUs.click()<span>;<br/></span><span><br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"About Us"</span>)<span>;<br/></span>}</pre>
<p>The preceding code uses the <kbd>cssSelector()</kbd> method to find the anchor element identified by its <kbd>href</kbd> attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with WebElements</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw how to locate WebElements on a web page by using different locator methods. Here, we will see all the different user actions that can be performed on a WebElement. Different WebElements will have different actions that can be taken on them. For example, in a textbox element, we can type in some text or clear the text that is already typed in it. Similarly, for a button, we can click on it, get the dimensions of it, and so on, but we cannot type into a button, and for a link, we cannot type into it. So, though all the actions are listed in one WebElement interface, it is the test script developer's responsibility to use the actions that are supported by the target element. In case we try to execute the wrong action on a WebElement, we don't see any exception or error thrown and we don't see any action get executed; WebDriver ignores such actions silently.</p>
<p>Now, let's get into each of the actions individually by looking at their Javadocs and a code example. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting element properties and attributes</h1>
                </header>
            
            <article>
                
<p>In this section, we will learn the various methods to retrieve value and properties from the WebElement interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The getAttribute() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>getAttribute</kbd> method can be executed on all the WebElements. Remember, we have seen attributes of WebElement in the WebElements section. The HTML attributes are modifiers of HTML elements. They are generally key-value pairs that appear in the start tag of an element. For example:</p>
<pre>  <span>&lt;label</span> <span>name</span><span>="Username"</span> <span>id</span><span>="uname"</span><span>&gt;</span>Enter Username: <span>&lt;/label&gt;</span></pre>
<p>In the preceding code, <kbd>name</kbd> and <kbd>id</kbd> are the attributes or attribute keys and <kbd>Username</kbd> and <kbd>uname</kbd> are the attribute values.</p>
<p>The API syntax of the <kbd>getAttribute()</kbd> method is as follows:</p>
<pre class="mce-root">java.lang.String getAttribute(java.lang.String name)</pre>
<p>In the preceding code, the input parameter is <kbd>String</kbd>, which is the name of the attribute. The return type is again <kbd>String</kbd>, which is the value of the attribute.</p>
<p>Now let's see how we can get all the attributes of a WebElement using WebDriver. Here, we will make use of the Search box from the example application. This is what the element looks like:</p>
<pre>&lt;input <strong>id="search"</strong> type="search" <strong>name="q"</strong> value="" class="input-text required-entry" maxlength="128" <strong>placeholder="Search entire store here..."</strong> autocomplete="off"&gt;</pre>
<p>We will list all the attributes of this WebElement using WebDriver. The code for that is as follows:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementGetAttributesExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Name of the box is: "<br/></span><span>            </span>+ <strong>searchBox.getAttribute("name")</strong>)<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Id of the box is: " </span>+ <strong>searchBox.getAttribute("id")</strong>)<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Class of the box is: "<br/></span><span>            </span>+ <strong>searchBox.getAttribute("class")</strong>)<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Placeholder of the box is: "<br/></span><span>            </span>+ <strong>searchBox.getAttribute("placeholder")</strong>)<span>;<br/></span>}</pre>
<p>In the preceding code, the last four lines of code use the <kbd>getAttribute()</kbd> method to fetch the attribute values of the <kbd>name</kbd>, <kbd>id</kbd>, <kbd>class</kbd>, and <kbd>placeholder</kbd> attributes of the WebElement search box. The output of the preceding code will be following:</p>
<pre> Name of the box is: q<br/> Id of the box is: search<br/> Class of the box is: input-text required-entry<br/> Placeholder of the box is: Search entire store here...</pre>
<p>Going back to the <kbd>By.tagName()</kbd> method of the previous section, if the search by a locating mechanism, <kbd>By.tagName</kbd>, results in more than one result, you can use the <kbd>getAttribute()</kbd> method to further filter the results and get to your exact intended element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The getText() method</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>getText</kbd><span> </span>method can be called from all the WebElements. It will return visible text if the element contains any text on it, otherwise it will return nothing.  The API syntax for the<span> </span><kbd>getText()</kbd><span> </span>method is as follows:</p>
<pre>java.lang.String getText()</pre>
<p>There is no input parameter for the preceding method, but it returns the visible<span> </span><kbd>innerText</kbd><span> </span>string of the WebElement if anything is available, otherwise it will return an empty string.</p>
<p>The following is the code to get the text present on the Site notice element present on the example application<span> </span>Homepage:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementGetTextExample</span>() {<br/>    WebElement siteNotice = <span>driver</span>.findElement(By<br/>            .<span>className</span>(<span>"global-site-notice"</span>))<span>;<br/></span><span>    <br/></span><span>    </span>System.<span>out</span>.println(<span>"Complete text is: "<br/></span><span>            </span>+ <strong>siteNotice.getText()</strong>)<span>;<br/></span>}</pre>
<p>The preceding code uses the<span> </span><kbd>getText()</kbd><span> </span>method to fetch the text present on the Site notice element, which returns the following:</p>
<pre><strong>Complete text is: This is a demo store. Any orders placed through this store will not be honored or fulfilled.</strong></pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The getCssValue() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>getCssValue</kbd> method can be called on all the WebElements. This method is used to fetch a CSS property value from a WebElement. CSS properties can be <kbd>font-family</kbd>,<span> </span><kbd>background-color</kbd>,<span> </span><kbd>color</kbd>, and so on. This is useful when you want to validate the CSS styles that are applied to your WebElements through your test scripts. The API syntax for the<span> </span><kbd>getCssValue()</kbd> method is as follows:</p>
<pre>java.lang.String<span> </span>getCssValue(java.lang.String propertyName)</pre>
<p>In the preceding code, the input parameter is the String value of the CSS property name, and the return type is the value assigned<span> </span>to<span> </span>that property name.</p>
<p>The following is the code example to retrieve <kbd>font-family</kbd> of the text from the Search box:    </p>
<pre><span>@Test<br/></span><span>public void </span><span>elementGetCssValueExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Font of the box is: "<br/></span><span>            </span>+ <strong>searchBox.getCssValue("font-family")</strong>)<span>;<br/></span>}</pre>
<p>The preceding code uses the<span> </span><kbd>getCssValue()</kbd> method to find <kbd>font-family</kbd> of the text visible in the Search box. The output of the method is shown here:</p>
<pre>Font of the box is: Raleway, "Helvetica Neue", Verdana, Arial, sans-serif</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The getLocation() method</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>getLocation</kbd><span> </span>method can be executed on all the WebElements. This is used to get the relative position of an element where it is rendered on the web page. This position is calculated relative to the top-left corner of the web page of which the (x, y) coordinates are assumed to be (0, 0). This method will be of use if your test script tries to validate the layout of your web page.</p>
<p>The API syntax of the<span> </span><kbd>getLocation()</kbd><span> </span>method is as follows:</p>
<pre>Point getLocation()</pre>
<p>The preceding method obviously doesn't take any input parameters, but the return type is a<span> </span><kbd>Point</kbd><span> </span>class that contains the (x, y) coordinates of the element.</p>
<p class="mce-root"/>
<p>The following is the code to retrieve the location of the Search <span>box:</span></p>
<pre>WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span>System.<span>out</span>.println(<span>"Location of the box is: "<br/></span><span>        </span>+ <strong>searchBox.getLocation()</strong>)<span>;</span></pre>
<p>The output for the preceding code is the (x, y) location of the Search box, as shown in the following screenshot:</p>
<pre>Location of the box is: (873, 136)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The getSize() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>getSize</kbd> method can also be called on<span> </span>all the visible components of HTML. It will return the width and height of the rendered WebElement. The API syntax of the<span> </span><kbd>getSize()</kbd><span> </span>method is as follows:</p>
<pre>Dimension getSize()</pre>
<p>The preceding method doesn't take any input parameters, and the return type is a class instance named<span> </span><kbd>Dimension</kbd>. This class contains the width and height of the target WebElement. The following is the code to get the width and height of the Search box:</p>
<pre>WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span>System.<span>out</span>.println(<span>"Size of the box is: "<br/></span><span>        </span>+ <strong>searchBox.getSize()</strong>)<span>;</span></pre>
<p class="mce-root">The output for the preceding code is the width and height of the Search box, as shown in the following screenshot:</p>
<pre>Size of the box is: (281, 40) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The getTagName() method</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>getTagName</kbd><span> </span>method can be called from all the WebElements. This will return the HTML tag name of the WebElement. For example, in the following HTML code, the button is the tag name of the HTML element:</p>
<pre><span>&lt;button</span><span> </span><span>id</span><span>="gbqfba"</span><span> </span><span>class</span><span>="gbqfba"</span><span> </span><span>name</span><span>="btnK"</span><span> </span><span>aria-label</span><span>="Google Search"</span><span>&gt;</span></pre>
<p>In the preceding code, the button is the tag name of the HTML element.</p>
<p class="mce-root"/>
<p>The API syntax for the<span> </span><kbd>getTagName()</kbd><span> </span>method is as follows:</p>
<pre>java.lang.String getTagName()</pre>
<p>The return type of the preceding method is <kbd>String</kbd>, and it returns the tag name of the target element.</p>
<p>The following is the code that returns the tag name of the Search button:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementGetTagNameExample</span>() {<br/>    WebElement searchButton = <span>driver</span>.findElement(By.<span>className</span>(<span>"search-button"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Html tag of the button is: "<br/></span><span>            </span>+ <strong>searchButton.getTagName()</strong>)<span>;<br/></span>}</pre>
<p>The preceding code uses the<span> </span><kbd>getTagName()</kbd><span> </span>method to get the tag name of the Search button element. The output of the code is as expected:</p>
<pre>Html tag of the button is: button</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing actions on WebElements</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw how to retrieve values or properties of WebElements. In this section, we will see how to perform actions on WebElements, which is the most crucial part of automation. Let's explore the various methods available in the WebElement interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The sendKeys() method</h1>
                </header>
            
            <article>
                
<p>The<kbd>sendKeys</kbd>  action is applicable for <kbd>textbox</kbd> or <kbd>textarea</kbd> HTML elements. This is used to type text into the textbox. This will simulate the user keyboard and types text into WebElements exactly as a user would. The API syntax for the <kbd>sendKeys()</kbd> method is as follows:</p>
<pre class="mce-root">void sendKeys(java.lang.CharSequence...keysToSend)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The input parameter for the preceding method is <kbd>CharSequence</kbd> of text that has to be entered into the element. This method doesn't return anything. Now, let's see a code example of how to type a search text into the Search box using the <kbd>sendKeys()</kbd> method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementSendKeysExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span><strong>searchBox.sendKeys("Phones")</strong><span><strong>;</strong><br/></span><span>    </span>searchBox.submit()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'Phones'"</span>)<span>;<br/></span>}</pre>
<p>In the preceding code, the <kbd>sendKeys()</kbd> method is used to type the required text in the textbox element of the web page. This is how we deal with normal keys, but if you want to type in some special keys, such as <em>Backspace, Enter, Tab,</em> or<em> Shift</em>, we need to use a special enum class of WebDriver, named <kbd>Keys</kbd>. Using the <kbd>Keys</kbd> enumeration, you can simulate many special keys while typing into a WebElement.</p>
<p>Now let's see some code example, which uses the <em>Shift</em> key to type the text in uppercase in the Search Box:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementSendKeysCompositeExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span><strong>searchBox.sendKeys(Keys.chord(Keys.SHIFT,"phones"))</strong><span><strong>;</strong><br/></span><span>    </span>searchBox.submit()<span>;<br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'PHONES'"</span>)<span>;<br/></span>}</pre>
<p>In the preceding code, the <kbd>chord()</kbd> method from the <kbd>Keys</kbd> enum is used to type the key, while the text specified is being given as an input to be the textbox. Try this in your environment to see all the text being typed in uppercase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The clear() method</h1>
                </header>
            
            <article>
                
<p>The clear action is similar to the <kbd>sendKeys()</kbd> method, which is applicable for the <kbd>textbox</kbd> and <kbd>textarea</kbd> elements. This is used to erase the text entered in a WebElement using the <kbd>sendKeys()</kbd> method. This can be achieved using the <kbd>Keys.BACK_SPACE</kbd> enum, but WebDriver has given us an explicit method to clear the text easily. The API syntax for the <kbd>clear()</kbd> method is as follows:</p>
<pre>void clear()</pre>
<p class="mce-root"/>
<p>This method doesn't take any input and doesn't return any output. It is simply executed on the target text-entry element.</p>
<p>Now, let's see how we can clear text that is entered in the Search box. The code example for it is as follows:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementClearExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span>searchBox.sendKeys(Keys.<span>chord</span>(Keys.<span>SHIFT</span><span>,</span><span>"phones"</span>))<span>;<br/></span><span>    </span><strong>searchBox.clear()</strong><span><strong>;</strong><br/></span>}</pre>
<p>We have used the WebElement's <kbd>clear()</kbd> method to clear the text after typing <kbd>phones</kbd> into the Search box.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The submit() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>submit()</kbd> action can be taken on a <kbd>Form</kbd> or on an element, which is inside a <kbd>Form</kbd> element. This is used to submit a form of a web page to the server hosting the web application. The API syntax for the <kbd>submit()</kbd> method is as follows:</p>
<pre>void submit()</pre>
<p>The preceding method doesn't take any input parameters and doesn't return anything. But a <kbd>NoSuchElementException</kbd> is thrown when this method is executed on a WebElement that is not present within the form.</p>
<p>Now, let's see a code example to submit the form on a Search page:                                       </p>
<pre><span>@Test<br/></span><span>public void </span><span>elementSubmitExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span>searchBox.sendKeys(Keys.<span>chord</span>(Keys.<span>SHIFT</span><span>,</span><span>"phones"</span>))<span>;<br/></span><span>    </span><strong>searchBox.submit()</strong><span><strong>;</strong><br/></span>}</pre>
<p>In the preceding code, toward the end is where the Search form is submitted to the application servers using the <kbd>submit()</kbd> method. Now, try to execute the <kbd>submit()</kbd> method on an element, let's say the About link, which is not a part of any form. We should see <kbd>NoSuchElementException</kbd> is thrown. So, when you use the <kbd>submit()</kbd> method on a WebElement, make sure it is part of the <kbd>Form</kbd> element.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the WebElement state</h1>
                </header>
            
            <article>
                
<p>In the previous sections, we saw how to retrieve values and perform actions on WebElements. Now, we will see how to check the state of a WebElement. We will explore methods to check whether the WebElement is displayed in the Browser window, whether it is editable, and if the WebElement is Radio Button of Checkbox, we can determine whether it's selected or unselected. Let's see how we can use the methods available in the WebElement interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> The isDisplayed() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>isDisplayed</kbd> action verifies whether an element is displayed on the web page and can be executed on all the WebElements. The API syntax for the <kbd>isDisplayed()</kbd> method is as follows:</p>
<pre>boolean isDisplayed()</pre>
<p>The preceding method returns a <kbd>Boolean</kbd> value specifying whether the target element is displayed on the web page. The following is the code to verify whether the Search box is displayed, which obviously should return true in this case:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementStateExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Search box is displayed: "<br/></span><span>            </span>+ <strong>searchBox.isDisplayed()</strong>)<span>;<br/></span>}</pre>
<p><span>The preceding code uses the <kbd>isDisplayed()</kbd> method to determine whether the element is displayed on a web page. The preceding code returns <kbd>true</kbd> for the Search box:  </span></p>
<pre>Search box is displayed: true</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The isEnabled() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>isEnabled</kbd> action verifies whether an element is enabled on the web page and can be executed on all the WebElements. The API syntax for the <kbd>isEnabled()</kbd> method is as follows:</p>
<pre>boolean isEnabled()</pre>
<p class="mce-root"/>
<p>The preceding method returns a <kbd>Boolean</kbd> value specifying whether the target element is enabled on the web page. The following is the code to verify whether the Search box is enabled, which obviously should return true in this case:    </p>
<pre><span>@Test<br/></span><span>public void </span><span>elementStateExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Search box is enabled: "<br/></span><span>            </span>+ <strong>searchBox.isEnabled()</strong>)<span>;<br/></span>}</pre>
<p><span>The preceding code uses the <kbd>isEnabled()</kbd> method to determine whether the element is enabled on a web page. The preceding code returns true for the Search box:  </span></p>
<pre>Search box is enabled: true </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The isSelected() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>isSelected</kbd> method returns a <kbd>boolean</kbd> value if an element is selected on the web page and can be executed only on a radio button, options in <span class="packt_screen">select</span>, and checkbox WebElements. When executed on other elements, it will return false. The API syntax for the <kbd>isSelected()</kbd> method is as follows:</p>
<pre>boolean isSelected()</pre>
<p>The preceding method returns a <kbd>Boolean</kbd> value specifying whether the target element is selected on the web page. The following is the code to verify whether the Search box is selected on a search page:</p>
<pre><span>@Test<br/></span><span>public void </span><span>elementStateExample</span>() {<br/>    WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Search box is selected: "<br/></span><span>            </span>+ <strong>searchBox.isSelected()</strong>)<span>;<br/></span>}</pre>
<p><span>The preceding code uses the </span><kbd>isSelected()</kbd><span> method. It returns false for the Search box, because this is not a radio button, options in select, or a checkbox. The preceding code returns <kbd>false</kbd> for the Search box:</span></p>
<pre>Search box is selected: false</pre>
<div class="mce-root packt_tip">To select a Checkbox or Radio button, we need to call the <kbd>WebElement.click()</kbd> method, which toggles the state of the element. We can use the <kbd>isSelected()</kbd> method to see whether it's selected.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered a brief overview of the Selenium testing tools, and the architecture of WebDriver, WebElements. We learned how to set up a test-development environment using Eclipse, Maven, and TestNG. This will provide us with the foundation to build a testing framework using Selenium. Then, we saw how to locate elements, and the actions that can be taken on them. This is the most important aspect when automating Web Applications. In this chapter, we used ChromeDriver to run our tests. In the next chapter, we will learn how to configure and run tests on Mozilla Firefox, Microsoft IE and Edge, and Apple Safari.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>True or false: Selenium is a browser automation library.</li>
<li>What are the different types of locator mechanisms provided by Selenium?</li>
<li>True or false: With the<span> </span><kbd>getAttribute()</kbd><span> </span>method, we can read CSS attributes as well?</li>
<li>What actions can be performed on a WebElement?</li>
<li>How can we determine whether the checkbox is checked or unchecked?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further information</h1>
                </header>
            
            <article>
                
<p>You can check out the following links for more information on the topics covered in this chapter:</p>
<ul>
<li>Read the WebDriver Specification at <a href="https://www.w3.org/TR/webdriver/">https://www.w3.org/TR/webdriver/</a></li>
<li>Read more about using TestNG and Maven in <em><a href="9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml">Chapter 1</a>, Creating a Faster Feedback Loop</em> from <em>Mastering Selenium WebDriver</em> By Mark Collin, Packt Publishing</li>
<li>Read more about element interaction in <em>Chapter 2, Finding Elements</em> and <em>Chapter 3, Working with Elements</em> from <em>Selenium Testing Tools Cookbook</em>, 2nd Edition, by Unmesh Gundecha, Packt Publishing</li>
</ul>


            </article>

            
        </section>
    </body></html>