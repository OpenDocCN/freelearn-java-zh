- en: Chapter 9. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is the process of cross-checking the implementation of an application/process.
    It brings its shortcomings out into the open. It can be extremely handy when you
    are upgrading/downgrading one or more dependencies. Tests can be classified into
    various categories based on different programming practices, but in this chapter,
    we will only discuss two types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These are tests that check the functionality of a specific
    section of code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional tests**: These are tests that check a specific action, mostly
    written to verify working code with regard to a use case or scenario'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will see the different ways in which we can test
    a Play application using **Specs2** and **ScalaTest**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests using either of the Specs2 and ScalaTest libraries are similar. The
    major difference is in the keywords, syntax, and style. Since different developers
    can have different preferences, in this chapter, tests are defined using both
    libraries and for convenience. Most of the tests written using Specs2 have names
    ending with `'Spec'`, while those using ScalaTest end with `'Test'`.
  prefs: []
  type: TYPE_NORMAL
- en: The setup for writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play is packaged with `Specs2`, since this is the library used internally for
    testing it. It provides support to test applications using Specs2 by default,
    that is, no additional library dependency is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `ScalaTest` earlier was difficult but now, Play also provides helpers
    for using ScalaTest. Although it is picked up from transitive dependencies, we
    need to add a library dependency to use the helper methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 1.1.0 version of `org.scalatestplus.play` is compatible with Play 2.3.x.
    It is better to check the compatibility when working with another version of Play
    at [http://www.scalatest.org/plus/play/versions](http://www.scalatest.org/plus/play/versions).
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit tests can be written as in any Scala project. For example, suppose we
    have a utility method `isNumberInRange` that takes a string and checks if it''s
    a number in the range [0,3600]. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a unit test to check this function using `Specs2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These scenarios can also be written using `ScalaTest` with slight modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unit tests that need to rely on external dependencies and data service layers
    should be defined using **mocks**. Mocking is the process of simulating actual
    behavior. **Mockito**, **ScalaMock**, **EasyMock**, and **jMock** are some of
    the libraries that facilitate mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting PlaySpecification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tests written using Specs2 can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`PlaySpecification` is a trait that provides the required helper methods to
    test a Play application using Specs2\. It is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s scan through the API exposed by each of these traits to understand its
    significance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Specification` and `NoTimeConversions` are traits of Specs2\. `NoTimeConversions`
    can be used to deactivate the time conversions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayRunners` provides helper methods to execute a block of code in a running
    application or server with or without specifying the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HeaderNames` and `Status` define constants for all the standard HTTP headers
    and HTTP status codes, respectively, with their relevant names, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`HttpProtocol` defines the constants related to the HTTP protocol:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`ResultExtractors` provides methods to extract data from the HTTP response,
    which is of the `Future[Result]` type. These methods are as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charset(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentAsBytes(of: Future[Result])(implicit timeout: Timeout): Array[Byte]`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentAsJson(of: Future[Result])(implicit timeout: Timeout): JsValue`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentAsString(of: Future[Result])(implicit timeout: Timeout): String`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentType(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookies(of: Future[Result])(implicit timeout: Timeout): Cookies`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flash(of: Future[Result])(implicit timeout: Timeout): Flash`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header(header: String, of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers(of: Future[Result])(implicit timeout: Timeout): Map[String, String]`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirectLocation(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session(of: Future[Result])(implicit timeout: Timeout): Session`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status(of: Future[Result])(implicit timeout: Timeout): Int`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `implicit Timeout` in these method calls is provided by the `DefaultAwaitTimeout`
    trait and the default timeout is set to 20 seconds. This can be overridden by
    providing an implicit timeout in the scope of the scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`RouteInvokers` provides the methods to call a corresponding `Action` for a
    given request using `Router`. These methods are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route[T](app: Application, req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route[T](app: Application, rh: RequestHeader, body: T)(implicit w: Writeable[T]):
    Option[Future[Result]]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route[T](req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route[T](rh: RequestHeader, body: T)(implicit w: Writeable[T]): Option[Future[Result]]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call[T](action: EssentialAction, rh: RequestHeader, body: T)(implicit w: Writeable[T]):
    Future[Result]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call[T](action: EssentialAction, req: FakeRequest[T])(implicit w: Writeable[T]):
    Future[Result]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `implicit Writable` in these method calls is provided by the `Writeables`
    trait. The `call` methods are inherited from `EssentialActionCaller`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `FutureAwaits` trait provides methods to wait on a request with or without
    specifying the waiting time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although the library that supports ScalaTest for a Play application has an
    `PlaySpec` abstract class, there is no equivalent to `PlaySpecification` for ScalaTest.
    Instead, there''s a helper object, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`PlaySpec` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Hence, importing `play.api.test.Helpers` is also sufficient to use only the
    helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: For the following sections, with regard to tests using Specs2, we will extend
    PlaySpecification, and for ScalaTest, we will assume that `play.api.test.Helpers`
    is imported and the test extends to `PlaySpec`.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We might have a simple project with a `User` model and `UserRepo`, defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this project, we need to test a `getUser` method of `UserController`—a controller
    that is defined to access user details, which are handled by the user model, where
    `UserController` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`AnormUserRepo` is an implementation of `UserRepo`, which uses Anorm for DB
    transactions. The methods in `UserController` are mapped in the routes file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since mocking Scala objects for tests is not yet fully supported by a testing
    library, there are different approaches to unit test a controller. These are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining all the controller's methods in a trait and then this trait can be
    extended by an object, while the trait is tested for functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining controllers as classes and wiring up other required services using
    dependency injection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both these approaches require us to modify our application code. We can choose
    the one that suits our coding practices the best. Let's see what these changes
    are and how to write the corresponding tests in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using traits for controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this approach, we define all the controller''s methods in a trait and define
    the controller by extending this trait. For example, `UserController` should be
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write tests for the `BaseUserController` trait—`UserControllerSpec`
    using Specs2 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`FakeRequest` is a helper that generates fake HTTP requests while testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we mock `UserRepo` and use this mock to generate a new instance of `TestController`.
    ScalaTest provides integration with Mockito via its `MockitoSugar` trait, so there
    will be small changes in the code for mocking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using ScalaTest, the `UserControllerTest` test will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can make our controller depend on specific services, and all of this is configurable
    through the global object's `getControllerInstance` method by using a dependency
    injection library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have used **Guice** by adding it as a dependency for our
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s update the `getControllerInstance` method in the `Global` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define `UserController` as a singleton that extends `play.api.mvc.Controller`
    and uses `UserRepo`, which is injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to modify the routes file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `@` symbol at the beginning of the method call indicates that the global
    object's `getControllerInstance` method should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we do not add the `@` suffix to the method name, it will search for an object
    with the `UserController` name and throw errors during compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write a unit test using Specs2 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we mock `AnormUserRepo` and use this mock to generate a new instance of
    `UserController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same test using ScalaTest will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the key differences in both these approaches,
    so that it''s easier to decide which one suits your requirement in the best way:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Using traits for controllers | Using dependency injection |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| It requires defining and not just declaring all the methods to be supported
    by a controller in a trait. | It requires a controller to be defined as a singleton
    class and provides implementations for the global object''s `getControllerInstance`
    method. |'
  prefs: []
  type: TYPE_TB
- en: '| It does not require additional libraries. | It requires using a dependency
    injection library and provides flexibility to plug-in different classes in different
    application modes. |'
  prefs: []
  type: TYPE_TB
- en: '| It requires defining an additional class for a controller, which extends
    a trait for testing. | It does not require any additional class definitions to
    test a controller, since a new instance can be instantiated from a singleton.
    |'
  prefs: []
  type: TYPE_TB
- en: For more examples on dependency injection, refer to [https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection](https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection).
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some of Play''s test cases to see how to use the helper methods.
    For example, consider the `DevErrorPageSpec` test, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This test starts `FakeApplication` with the Prod mode and checks the response
    when `FakeRequest` encounters an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`FakeApplication` extends an application and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The method that is running is part of PlayRunners and executes a block of code
    in the context of a given application. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'PlayRunners has a few more definitions of how to run, these are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`running[T](testServer: TestServer)(block: => T)``: T`: This can be used to
    execute a block of code in a running server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`running[T](testServer: TestServer, webDriver: WebDriver)(block: TestBrowser
    => T): T`: This can be used to execute a block of code in a running server with
    a test browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`running[T, WEBDRIVER <: WebDriver](testServer: TestServer, webDriver: Class[WEBDRIVER])(block:
    TestBrowser => T): T`: This can also be used to execute a block of code in a running
    server with a test browser using Selenium WebDriver. This method uses the previous
    method internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using the `running` method directly, as an alternative, we could
    define our tests using the wrapper classes, which make use of the running. There
    are different helpers for Specs2 and ScalaTest.
  prefs: []
  type: TYPE_NORMAL
- en: Using Specs2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at the ones available when using Specs2\. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WithApplication`: It is used to execute a test within the context of a running
    application. For example, consider a situation where we want to write functional
    tests for `CountController`, which is responsible for getting a count of distinct
    data grouped by a perspective. We can write the test as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, assume that `TestHelper` is a helper object specifically defined for simplifying
    the code of test cases (extracting common processes as methods).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we need to specify `FakeApplication`, we can do so by passing it as an argument
    to the `WithApplication` constructor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This comes in handy when we want to change the default application configurations,
    GlobalSettings, and so on for the tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`WithServer`: It is used to execute tests within the context of a running application
    on a new `TestServer`. This is quite useful when we need to start our `FakeApplication`
    on a new `TestServer` at a specific port. After slightly modifying the previous
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WithBrowser`: It is used to test an application''s functionality by performing
    certain actions in browsers. For example, consider a dummy application where the
    page title changes on the click of a button. We can test it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are assuming `TestRoute` is a partial function that maps to some of the routes
    which can then be used in tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using ScalaTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, lets see what **ScalaTestPlus-Play**, the library with helper methods
    that are used for testing with the help of ScalaTest, has to offer. In this section,
    we will see examples from `ScalatestPlus-Play` wherever applicable. The helpers
    for ScalaTest are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OneAppPerSuite`: It starts `FakeApplication` using `Play.start` before running
    any tests in a suite and then stops it once they are completed. The application
    is exposed through the variable app and can be overridden if required. From `ExampleSpec.scala`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we wish to use the same application for all or multiple suites, we can define
    a nested suite. For such an example, we can refer to `NestedExampleSpec.scala`
    from the library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OneAppPerTest`: It starts a new `FakeApplication` for each test defined in
    the suite. The application is exposed through the `newAppForTest` method and can
    be overridden if required. For example, consider the `OneAppTest` test, where
    each test uses a different `FakeApplication` obtained through `newAppForTest`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OneServerPerSuite`: It starts a new `FakeApplication` and a new `TestServer`
    for the suite. The application is exposed through the variable app and can be
    overridden if required. The server''s port is set from the variable port and can
    be changed/modified if required. This has been demonstrated in the example for
    `OneServerPerSuite` (`ExampleSpec2.scala`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we require multiple suites to use the same FakeApplication and TestServer,
    we can define tests using a nested suite similar to `NestedExampleSpec2.scala`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OneServerPerTest`: It starts a new `FakeApplication` and `TestServer` for
    each test defined in the suite. The application is exposed through the `newAppForTest`
    method and can be overridden if required. For example, consider the `DiffServerTest`
    test, where each test uses a different `FakeApplication` obtained through `newAppForTest`
    and the `TestServer` port is overridden:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OneBrowserPerSuite`: It provides a new Selenium WebDriver instance per suite.
    For example, assume that we wish to test the clicking of a button by opening the
    application in Firefox, the test can be written in the same way as `ExampleSpec3.scala`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are assuming `TestRoute` is a partial function that maps to some of the routes,
    which can then be used in tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The same trait can be used to test the application within multiple browsers,
    as demonstrated in `MultiBrowserExampleSpec.scala`. To execute tests in all the
    browsers, we should use `AllBrowsersPerSuite`, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The trait `OneBrowserPerSuite` can also be used with nested tests. Refer to
    `NestedExampleSpec3.scala`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OneBrowserPerTest`: It starts a new browser session for each test in the suite.
    This can be noticed by running the `ExampleSpec4.scala` test. It''s similar to
    `ExampleSpec3.scala`, but `OneServerPerSuite` and `OneBrowserPerSuite` have been
    replaced with `OneServerPerTest` and `OneBrowserPerTest`, respectively, as shown
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've also replaced the overridden app variable with the `newAppForTest` overridden
    method. Try writing a test that uses the `AllBrowsersPerTest` trait.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can run into an InvalidActorNameException when running multiple functional
    tests simultaneously on an application, which defines custom actors. We can avoid
    this by defining a nested test where multiple tests use the same `FakeApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how a Play application can be tested using Specs2 or
    ScalaTest. We have also come across the different helper methods available to
    simplify testing a Play application. In the unit testing section, we discussed
    the different approaches that can be taken while designing models and controller
    based on the preferred testing process using traits with defined methods or dependency
    injection. We also discussed the functional testing of a Play application within
    the context of an application with a test server and within a browser using Selenium
    WebDrivers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss debugging and logging in to your Play application.
  prefs: []
  type: TYPE_NORMAL
