- en: Chapter 12. Facelets Templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover several aspects of Facelets templating and some
    related aspects.
  prefs: []
  type: TYPE_NORMAL
- en: JSF is defined as a component-based application development framework. When
    we say Facelets, we mean friendly page development, reusability of code, templating,
    composition components, custom logic tags, expression functions, high-performance
    rendering, optimized compilation time, and so on. But what actually is Facelets?
    Well, Facelets represents a **VDL** (**View Declaration Language**), and initially,
    it was created as an alternative to JSP. During JSF 1.1 and 1.2, this view handler
    can be used only after a separate download and configuration, while JSP was the
    default view handler. Things started to change with JSF 2.0, when the mismatch
    between JSF and JSP allowed Facelets to become the standard and default VDL, while
    JSP was deprecated. Starting with JSF 2.2, this concept was seriously fortified
    and Facelets was boosted with new features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of the Facelets tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Templating** is a concept based on code reusability. Templates, or tiles,
    represent the portions of reusable code that can be puzzled together to obtain
    JSF pages. In order to accomplish this, we exploit a handful of tags from [http://xmlns.jcp.org/jsf/facelets](http://xmlns.jcp.org/jsf/facelets)
    namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, prefixed with `ui`, these tags are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<ui:composition>` tag (`TagHandler`): This defines a page composition
    that can use a template (any content outside of this tag is ignored). The `template`
    attribute is optional and is used for indicating a template to which the enclosed
    content should be applied. Multiple compositions can use the same template, thus
    encapsulating and reusing the layout. Facelets will paste the enclosed content
    into the component''s hierarchy, usually under `UIViewRoot`. The `<ui:composition>`
    tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:define>` tag (`TagHandler`): This defines the content that is inserted
    into a page by a template. It may appear in the `<ui:composition>`, `<ui:component>`,
    `<ui:decorate>`, and `<ui:fragment>` tags and it has a matching `<ui:insert>`
    tag, which is capable of inserting the defined content into a page. Most commonly,
    it appears in the `<ui:composition>` tag. The `<ui:define>` tag is used in the
    following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:insert>` tag (`TagHandler`): This inserts the content into a template.
    Usually, that content is defined by the `<ui:define>` tag in a `<ui:composition>`,
    `<ui:component>`, `<ui:decorate>`, or `<ui:fragment>` tag. This tag indicates
    the exact place where the content will be inserted. When the `name` attribute
    is missing, Facelets will add the body content of this tag to the view. The `<ui:insert>`
    tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:include>` tag (`TagHandler`): This is used to encapsulate and reuse
    content from multiple pages. The included content can be plain XHTML and XHTML
    pages that have either a `<ui:composition>` tag or a `<ui:component>` tag. This
    tag can be easily combined with `<ui:param>` to provide parameters to the included
    pages, but is also combined with the `<ui:fragment>`, `<ui:decorate>`, and `<ui:insert>`
    tags. This is one of the most used tags since it sustains the idea of reusing
    templated code. The `<ui:include>` tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Starting with JSF 2.2, the `UIViewRoot.restoreViewScopeState(FacesContext context,
    Object state)` method was added to allow the use of view scoped beans for EL expressions
    in the template from which the component tree is built. This means that the following
    code is useful:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:param>` tag (`TagHandler`): This passes parameters to an included
    file or a template. It is used in the `<ui:include>`, `<ui:composition>`, or `<ui:decorate>`
    tags. A parameter is characterized by a name-value pair—both can be string literals
    or EL expressions. In the included file or template, the parameter is available
    via EL. The `<ui:param>` tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:repeat>` tag (`ComponentHandler`): This is used as an alternative
    for loop tags such as `<c:forEach>` and `<h:dataTable>`. Since `<ui:repeat>` is
    a component handler, while `<c:forEach>` is a tag handler, you have to pay attention
    when you choose between them! The `<ui:repeat>` tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:debug>` tag (`ComponentHandler`): This defines a debug component in
    the component tree capable to capture debugging information such as component
    tree, scoped variables, and view state. By default, this information appears in
    a debug pop-up window when you press *Ctrl* + *Shift* + *D* (in Windows OS). You
    can alter the *D* key by explicitly setting another keyboard using the optional
    `hotkey` attribute. The `<ui:debug>` tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:component>` tag (`ComponentHandler`): This is similar to `<ui:composition>`,
    only that it defines a component directly into the component tree without an associated
    template. The `<ui:component>` tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:fragment>` tag (`ComponentHandler`): Again, this is similar to `<ui:component>`
    tag, but doesn''t ignore the content outside this tag. Its main skill consists
    of the `rendered` attribute, which is very useful for deciding if the enclosed
    content will be displayed or not. This tag doesn''t produce client-side effects,
    which makes it a great alternative to `<h:panelGroup>`, which has the client side
    effect of producing the `<span>` or `<div>` tags. If you want to work with `<h:panelGroup>`
    without producing the `<span>` or `<div>` tags, then skip adding an explicit ID
    to it. An `<h:panelGroup>` tag produces a `<span>` tag if it has an explicit ID,
    and a `<div>` tag if it has an explicit ID and the value of the `layout` attribute
    set to the `block` value. The `<ui:fragment>` tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:decorate>` tag (`TagHandler`): This is similar to the `<ui:composition>`
    tag, but doesn''t ignore the content outside this tag. This is a nice feature,
    since it allows us to apply any element in the page to a template. The `template`
    attribute is mandatory. The `<ui:decorate>` tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<ui:remove>` tag: This removes the content from a page. The `<ui:remove>`
    tag is used in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can read about further details of these tags at [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/ui/tld-summary.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/ui/tld-summary.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple template – PageLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When these eleven tags combine their skills, we can create amazing templates.
    For example, let''s suppose that we want to create the template from the following
    diagram and we name it `PageLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple template – PageLayout](img/6466EN_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that with just a few clicks, NetBeans can generate the code behind several
    templates of Facelets, including the preceding abstractization. But, this time
    we will write it manually, in order to exemplify the Facelets tags. While NetBeans
    provides a compact code, based on a single XHTML page, we will write an expanded
    approach using six XHTML pages. In this way, you will have two ways of writing
    this kind of template.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are five distinctive sections: **Header**, **Footer**,
    **Left**, **Center**, and **Right**. For each of these sections, we will write
    a separate XHTML page. The header is generated in the `topDefault.xhtml` page,
    that simply uses the `<ui:composition>` tag to provide the default content as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The same approach can be used for the remaining four sections. Just replace
    the default header text and create the following XHTMLs: `bottomDefault.xhtml`
    for the footer, `contentDefault.xhtml` for the center, `leftDefault.xhtml` for
    the left-hand side, and `rightDefault.xhtml` for the right-hand side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These five XHTMLs are like five pieces of the puzzle and they serve as the
    default content for our template. Now, we can compose the puzzle (this is known
    as the template file or simply the template) by writing an XHTML page that uses
    the `<ui:insert>` and `<ui:include>` tags as shown in the following code—this
    is `layout.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each section was represented by an `<ui:insert>` tag and the default content
    was included using `<ui:include>`. Some `<div>` tags and CSS were used for arranging
    and styling the pieces of the puzzle in the main template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the template, as shown in the following code, is ready to be used in `index.xhtml`;
    this is known as the **template client**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, we can alter the default content of our template using the
    `<ui:define>` tag, for example, if we want to replace the text that appears in
    the center section. This is the default content, with the **Rafael Nadal Home
    Page** text, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, you can redefine the content for the remaining four sections.
    The complete application is named `ch12_1`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty simple template that can serve us as support for presenting
    the rest of Facelets tags. We will continue with several punctual examples for
    `<ui:param>`, `<ui:decorate>`, `<ui:fragment>`, `<ui:repeat>`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters via <ui:param>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<ui:param>` tag is a tag handler that is capable of sending parameters
    to an included file or to a template. A quick example will make you understand
    how `<ui:param>` works. In the following code, we are in the template client,
    `index.xhtml`, and we send a parameter to the template file, `layout.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access this parameter in `layout.xhtml` using its name via EL.
    We can do that anywhere in the template file; for example, we can use this parameter
    for creating a new parameter to be sent to an included file, in this case, to
    the `contentDefault.xhtml` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From the same template, we can send parameters to different included pages.
    Besides the `playernamesurname` parameter, let''s send one to the `topDefault.xhtml`
    page using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, send one parameter to the `bottomDefault.xhtml` page using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `playernamesurname` parameter is accessible via EL in the `contentDefault.xhtml`
    page as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, `headertext` and `footertext` are accessible via EL in the `topDefault.xhtml`
    and `bottomDefault.xhtml` pages. Now, the result of using `<ui:param>` will be
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing parameters via <ui:param>](img/6466EN_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application is called `ch12_11`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing bean properties and action methods via <ui:param>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, you saw how to exploit `<ui:param>` for sending literal
    strings to a template or included page, but `<ui:param>` can be used for more
    than this. Let''s suppose that we have the following code of the bean, `TemplatesBean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we want to display the value of the `msgCenterDefault` property in
    `contentDefault.xhtml`. Of course, this is very easy to accomplish using the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But we want to pass the name of the bean and the name of the property via `<ui:param>`.
    This can be accomplished using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `contentDefault.xhtml`, you can display the value of the `msgCenterDefault`
    property as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that was easy! But how about calling the `centerAction` method, which
    modifies the value of the `msgCenterDefault` property? For this, we add the method
    name between single quotes, in square brackets, followed by a pair of parentheses
    indicating a method without arguments, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to call the `topAction` (or `bottomAction`) method. This time,
    we want to pass via `<ui:param>` the bean name, action method name, and the argument
    value. For this, we will write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In `topDefault.xhtml`, we can exploit the information passed through these
    three parameters, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see that everything worked as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing bean properties and action methods via <ui:param>](img/6466EN_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application is named `ch12_13`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `<ui:param>` value can be accessed from a managed bean, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Exploiting the <ui:decorate> and <ui:fragment> tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s talk about the `<ui:decorate>` tag. As its name suggests, this
    tag is used for decorating pieces of a page. Unlike `<ui:composition>`, this tag
    doesn''t ignore the content that is not enclosed in it, which may be an added
    advantage sometimes. Well, a simple example is shown in the following code (the
    `template` attribute is mandatory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet produces the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploiting the <ui:decorate> and <ui:fragment> tags](img/6466EN_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is named `ch12_10`. Basically, this example decorates a
    page with a template and proves the effect of the `<ui:decorate>` tag against
    the `<ui:composition>` tag. However, let's see a better example of decorating
    a part of a page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will decorate a `<div>` element with an `<ul>` list. The
    items of list `<li>` come from two separated pages, and the technique for accomplishing
    this is based on nested `<ui:decorate>` tags. The template client, `index.xhtml`,
    uses `<ui:decorate>` to decorate the `<div>` element with a template that contains
    the `<ul>` list, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the `ul.xhtml` template provides the `<ul>` list and a part of
    `<li>` items, but also uses the `<ui:decorate>` tag to decorate the `<ul>` list
    with the remaining `<li>` items, which are available via the `li.xhtml` template,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `li.xhtml` template uses the `<ui:fragment>` tag to provide the rest of
    the `<li>` list. But since `<ui:fragment>` doesn''t block the unclosed content,
    we can slip some `<li>` items outside of it as well, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! We have especially used different colors for `<li>` items. This is very
    useful, because it really helps us understand how the page is composed using the
    `<ui:decorate>` tag. Please refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploiting the <ui:decorate> and <ui:fragment> tags](img/6466EN_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application is named `ch12_24`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same result can be obtained using different kinds of approaches. But, another
    one that can be used as a templating technique consists in replacing the `<ui:decorate>`
    tag from the `ul.xhtml` template with a combination of the `<ui:insert>`, `<ui:define>`,
    and `<ui:include>` tags. In order to do that, we change the `ul.xhtml` template
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will change the code for the template client to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_23`.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating with <ui:repeat>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<ui:repeat>` tag is a component handler that is capable of iterating over
    a collection, and at each iteration, it adds a copy of its child elements in the
    component tree. We can say that `<ui:repeat>` acts as a `<h:dataTable>` tag without
    rendering an HTML table. Of course, you can do that explicitly, by wrapping its
    mechanism in a `<table>`, `<tr>`, and `<td>` suite (you will see an example in
    the upcoming section, *Using the jsfc attribute*).
  prefs: []
  type: TYPE_NORMAL
- en: 'It contains a set of very handy attributes that deserve to be mentioned before
    an example. Besides the well known attributes, `value` (representing the collection
    to iterate as `java.lang.Object`) and `var` (representing the iterator as `java.lang.Object`),
    we have––all the following attributes that are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '`step`: This attribute allows us to indicate, as an `int` value, the number
    of items that will be skipped for each iteration. By default, the `<ui:repeat>`
    tag iterates over each item of the collection, which indicates a `step` attribute
    equal to 1, and indicates that the process starts with the first one item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: This is the size of the collection over which to iterate; it has to
    be evaluated to an `int` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`: By default, `<ui:repeat>` begins the iteration process from the first
    item of the collection. This attribute allows us to jump over a number of items,
    by telling Facelets to start the iteration process for a certain offset. This
    offset is settled before the iteration process begins; it has to be evaluated
    to an `int` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`varStatus`: This attribute reveals the status of the current item via a POJO
    object. An explicit example of using it will follow shortly, but for now let''s
    have several examples of iterating different kinds of Java collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple example of iterating an `ArrayList` collection looks like the following
    code (the same approach can be applied to any `java.util.List` package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `<ui:repeat>` can also iterate over a `HashSet` collection using the
    `toArray` method, as follows (the same approach can be applied to `TreeSet` and
    `LinkedHashSet`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, even more, `<ui:repeat>` can also iterate over a `Map` collection (`HashMap`,
    `TreeMap`, and `LinkedHashMap`) using the following approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the first approach:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the code for the second approach:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the code for the third approach:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the code for the fourth approach:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding examples iterate the entire collection. But if you want to iterate
    only the items from even positions, then we can bring the `step` attribute into
    the scene, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For odd items, you may want to combine the powers of the `step` and `offset`
    attributes, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common approach for displaying even/odd items consists of using the
    `varStatus` attribute. The POJO object, representing the value of this attribute,
    contains several read-only JavaBeans properties. Between these properties, we
    have the even and odd properties, which can be easily used in combination with
    `<ui:fragment>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the even properties, the code is given as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the odd properties, the code is given as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire set of properties is exposed in the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding examples presented are united under the complete application
    named `ch12_6`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with <ui:include> and <f:viewParam>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may think that combining `<ui:include>` with `<f:viewParam>` is a strange
    combination, and maybe it is. But, as you know, `<ui:include>` is able to encapsulate
    and reuse content from multiple pages, while `<f:viewParam>` can be useful for
    adding view parameters in links (using the GET query string). This means that
    we can take parameters passed on the current page via `<f:viewParam>` and use
    them in `<ui:include>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the current page, we can include a random page, or a page whose
    name was hardcoded as the value of a view parameter in an outcome. We can also
    use the `includeViewParams` attribute to tell other pages to include the same
    content as the current page. These three examples are just on open gate to more
    scenarios. The following example speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for `RandomInBean` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have several buttons to prove the symbiosis between the `<ui:include>`
    and `<f:viewParam>` tags. First, we have three buttons labeled **Include in_index_A.xhtml
    Page**, **Include in_index_B.xhtml Page**, and **Include in_index_C.xhtml Page**.
    All three act the same way; they pass a view parameter named `in`. The value of
    the view parameter is a string literal, and represents the page that should be
    included. This will generate a URL of the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch12_12/faces/index.xhtml?in=in_index_B.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: So, conforming to this URL, the `<ui:include>` tag will include the `in_index_B.xhtml`
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we have a button labeled **Random Page**. This button will randomly
    choose between those three pages. In order to obtain this, we need to add `includeViewParams="false"`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can tell other pages to include the same content as the current
    page. When you click on the button labeled **Tell mypage.xhtml To Include The
    Same Page As You Did**, the `mypage.xhtml` page will include the same page as
    the current page. For this, we need to add `includeViewParams="true"`.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch12_12`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with <ui:include> and <ui:param>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<ui:include>` and `<ui:param>` tags are two tag handlers that can be used
    for accomplishing many kinds of tasks; as long as we keep in mind that tag handlers
    are efficient only when the view tree is built, we can exploit them for our benefit.
    For example, we can use them to generate a tree node structure as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with <ui:include> and <ui:param>](img/6466EN_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to accomplish this task, we will spice up the `<ui:include>` and `<ui:param>`
    tags with a dash of JSTL (the `<c:if>` and `<c:forEach>` tag handlers) and recursivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a class that represents the abstractization of the tree node
    concept. Basically, a tree node representation is a hierarchical structure of
    labels that can be recursively traversed. Based on this, we can write a generic
    tree node class as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This class can serve a bean capable of defining a particular tree node, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part is how to display this structure as a tree node. HTML
    provides the `<ul>` and `<li>` tags that are able to represent data as a list.
    Moreover, nested `<ul>` tags output a hierarchical structure, which is very useful
    since it spears us for finding a custom representation. In order to reflect the
    tree node defined in `TreeNodeBean`, we write a page named `node.xhtml` capable
    of autoinclusion in an iterative-recursive process using the `<ui:include>` tag,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `node` parameter is passed via `<ui:param>` from the main page named `index.xhtml`.
    From the main page, we pass the tree node root. Furthermore, in `node.xhtml`,
    we iterate the descendants of the root in a recursive approach and display each
    node as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you didn't find this example useful, at least keep in mind that `<ui:include>`
    can be used in a recursive process. The complete application is named `ch12_14`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with <ui:debug>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<ui:debug>` tag (`ComponentHandler`) defines a debug component in the
    component tree that is capable of capturing debugging information such as component
    tree, scoped variables, and view state. For example, you can add the `<ui:debug>`
    tag into a template using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you press *Ctrl* + *Shift* + *Q*, you will see something like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with <ui:debug>](img/6466EN_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application is named `ch12_9`. The `<ui:debug>` tag was added in
    `layout.xhtml`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the content with <ui:remove>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<ui:remove>` tag is used for removing the content. This tag is rarely
    used, but a perfect example of this is removing comments of type `<!-- -->`. You
    probably thought of something like the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn''t have any side effects on the HTML rendered code. Well, that isn''t
    true, because in the HTML source code, you will see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the content with <ui:remove>](img/6466EN_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But if we encapsulate this in `<ui:remove>`, then the preceding client side
    effect will not be produced anymore, which has the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The same effect will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to remove comments from the generated HTML code, you add the `context`
    parameter in `web.xml`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for backwards compatibility with existing Facelets tag libraries,
    the code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_8`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the jsfc attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Facelets comes with an attribute named `jsfc`. Its main goal consists in converting
    HTML elements in JSF components (the HTML prototype in the JSF page). For example,
    in the following code, we have an HTML form converted into a JSF form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This attribute stands for fast prototyping and is easy to use. The following
    is another example—this time the `jsfc` attribute is combined with `<ui:repeat>`
    for generating a `<table>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The first example is named `ch12_7` and the second one is named `ch12_25`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the PageLayout template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember the `PageLayout` template developed at the beginning of this chapter?
    Well, that is a decent template, but let''s extend it so it becomes a bit more
    realistic. Usually, a web template contains the sections title, login, search,
    logo, header, menu, left, center, right, and footer over and above the five sections
    that we have used. It would also be nice to have a template that allows us to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove sections without side effects and without manually removing orphan CSS
    code (usually, you can remove a section by writing an empty `<ui:define>` tag,
    but this will not remove the corresponding CSS code for that section). Moreover,
    an empty `<ui:define>` tag will still have a side effect of type the empty `<div>`
    tag or the empty `<span>` or `<td>` tag. This happens because, usually, `<ui:define>`
    is wrapped in a `<div>`, `<span>`, or `<td>` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the width of the template, that is, the left and right panels without altering
    CSS. These are common adjustments; therefore we can expose them via `<ui:param>`
    and spear the page author to scroll through CSS files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a menu section. We can provide support for adding it via `<ui:include>`
    as a separate file or having a convention mechanism that allows the page author
    to add it much easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end, the template will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the PageLayout template](img/6466EN_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is no secret that most websites place the content in multiple columns,
    which are created using the `<div>` or `<table>` elements. Afterwards, these elements
    are positioned in the page using CSS. Basically, this is the main idea behind
    most templates, and this one is no exception. In the following diagram, you can
    see the layout of our template, which is based on the `<div>` elements (in the
    diagram, you can see each `<div>` ID):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the PageLayout template](img/6466EN_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, since each section is wrapped in a `<div>` element, we can easily remove
    it using the `<ui:fragment>` tag and its `rendered` attribute. We can wrap each
    section in a `<ui:fragment>` tag and remove it by setting the value of the `rendered`
    attribute to `false` via a `<ui:param>` tag. This will remove the section without
    any side effects. When a section is removed, we need to skip loading the corresponding
    CSS code. For this, we can split the CSS files into the following three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: A CSS file that holds general styles for templates (usually this is a small
    file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CSS file that holds styles for positioning each section on a page (usually
    this is a small file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CSS file per section, which holds styles specific to each section (these can
    be pretty large files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having this structure, we can easily decide not to load the CSS code for the
    sections that have been removed. This can be accomplished in the `<h:outputStylesheet>`
    tag with a simple condition based on the same parameters passed for removing the
    sections. When a section is removed, we load an empty CSS file named `dummy.css`
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the template file (`layout.xhtml`) may be changed to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in the template client, we can easily remove a section (for example, the
    title section), using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, in the template client, we can easily use `<ui:define>` to
    provide our content to the template, and `<ui:param>` for the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the title section: This sets the `title` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the login and search sections: This sets the `loginsearch` parameter
    to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove only login section: This sets the `login` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove only search section: This sets the `search` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the logo section: This sets the `logo` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the top section: This sets the `top` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the menu section: This sets the `menu` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the left section: This sets the `left` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the right section: This sets the `right` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the bottom section: This sets the `bottom` parameter to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set template fixed width: This sets the `wrapperWidth` parameter to *widthpx*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set left panel fixed width: This sets the `leftWidth` parameter to *widthpx*
    (default 150px)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set right fixed width: This sets the `rightWidth` parameter to *widthpx* (default
    150px)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s focus on adding a menu. The template user can define a menu in
    a separate file, as long as it respects the following simple convention of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This file can be included as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach consists of passing menu items via `<ui:param>` using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This will work because the `menuDefault.xhtml` page provides a default implementation
    that looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete application is named `ch12_18`. In the application `ch12_19`,
    you can see a usage example of this template, which looks similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the PageLayout template](img/6466EN_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we have dropped the search and right panel sections.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets' programmatic aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the second part of this chapter, we will focus more on several programmatic
    aspects of Facelets. We will start with a new feature of JSF 2.2 regarding `FaceletFactory`,
    which produces Facelets relative to the context of the underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: FaceletFactory considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JSF 2.0, the `FaceletFactory` class was not accessible via the standard
    API for accessing factories, `FactoryFinder`. This means that something like the
    following line was not working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: But starting with JSF 2.2, the preceding snippet of code should work. At least
    this is what the list of JSF 2.2 features said. Unfortunately, it doesn't work
    because the specification doesn't contain a class named `javax.faces.view.facelets.FaceletFactory`.
    In Mojarra 2.2.6 implementation, the `FaceletFactory` class doesn't even exist;
    there is a public class named `com.sun.faces.facelets.impl.DefaultFaceletFactory`.
    On the other hand, in MyFaces 2.2.2, we have the abstract class, `org.apache.myfaces.view.facelets.FaceletFactory`.
    So, keep these aspects in mind when you decide to use, decorate, or write a new
    `FaceletFactory` class.
  prefs: []
  type: TYPE_NORMAL
- en: In the near future, we may have the ability to programmatically create a Facelet
    and call the `apply` method in order to build a component tree.
  prefs: []
  type: TYPE_NORMAL
- en: Working with FaceletCache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JSF 2.1, Facelets are created and cached via the `FaceletCache`
    API. The cache handles two different kinds of Facelets: **View Facelets** and
    **View Metadata Facelets**. For each type, the `FaceletCache` API provides a method
    that returns/creates a cached instance based on the URL that is passed (`getFacelet`/`getViewMetadataFacelet`)
    and a method capable of determining whether a cached Facelet instance exists for
    the given URL (`isFaceletCached`/`isViewMetadataFaceletCached`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**View Metadata Facelets** is a special kind of Facelet that corresponds to
    `ViewDeclarationLanguage.getViewMetadata(javax.faces.context.FacesContext, java.lang.String)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Facelets instances are created in the `getFacelet`/`getViewMetadataFacelet`
    method using the public static interface, `FaceletCache.MemberFactory`; this interface
    is responsible for the creation of Facelet or View Metadata Facelet instances
    using a method named `newInstance(URL key)`. The `getFacelet` method has access
    to `FaceletCache.MemberFactory` via the protected method, `getMemberFactory`.
    The `getViewMetadataFacelet` method has access to the same interface via the protected
    method, `getMetadataMemberFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FaceletCache` API''s instances are obtained from `FaceletCacheFactory`.
    This is a factory class that provides two methods: `getFaceletCache` and `getWrapped`.
    The first one returns a `FaceletCache` instance, the latter one returns an instance
    of the class being wrapped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to return a custom `FaceletCache` instance, we can start with a custom
    implementation of `FaceletCacheFactory`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This factory has to be configured in `faces-config.xml` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `CustomFaceletCache` class will override the `getFacelet` and `getViewMetadataFacelet`
    methods for disabling the cache mechanism; our implementation will not cache Facelets.
    The code of the `CustomFaceletCache` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to update the cache, JSF performs periodic checks of Facelets views
    changes. In the development stage, you may need to perform this check much often
    than in production. For this, you can set the `javax.faces.FACELETS_REFRESH_PERIOD`
    context parameter as shown in the following example (the value represents the
    number of seconds between two consecutive checks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for backwards compatibility with existing Facelets tag libraries,
    the following is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If you want to disable these checks, then set the `javax.faces.FACELETS_REFRESH_PERIOD`
    (or `facelets.REFRESH_PERIOD`) parameter to `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: ResourceResolver swallowed by ResourceHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSF 2.0 promotes the `ResourceResolver` class as the custom approach for loading
    Facelets views from other locations beside the application web root (like a hook
    that allows us to alter the way that the Facelets loads template files). Custom
    locations represent any location for which we can write a URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that the Facelets views of our `PageLayout` template
    are stored on the local machine, in the `facelets` folder in `D:`. A custom `ResourceResolver`
    class can load the Facelets views from this location—just override the `resolveUrl`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'A custom `ResourceResolver` class is recognized by JSF if we configure it properly
    in the `web.xml` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'However, starting with JSF 2.2, we can skip this configuration and use the
    `@FaceletsResourceResolver` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The complete application using the `web.xml` configuration is named `ch12_2`.
    The same application, using the `@FaceletsResourceResolver` annotation, is named
    `ch12_5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `ResourceHandler` class is recommended to be used for
    serving different kinds of resources to the client, such as CSS, JS, and images;
    see the *Configuring resource handlers* section in [Chapter 5](ch05.html "Chapter 5. JSF
    Configurations Using XML Files and Annotations – Part 2"), *JSF Configurations
    Using XML Files and Annotations – Part 2*. By default, the preferred location
    of `ResourceHandler` is the `/resources` folder (or `META-INF/resources` on the
    `CLASSPATH`). A custom `ResourceHandler` class is recognized by JSF if we configure
    it properly in the `faces-config.xml file`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this was a pretty awkward approach, JSF 2.2 unifies these classes into
    a single one. More exactly, the functionality of the `ResourceResolver` class
    has been merged into the `ResourceHandler` class, and the `ResourceResolver` class
    itself has been deprecated. The main result of this action was a new method in
    `ResourceHandler` named `createViewResource`. The purpose of this method is to
    replace the `resolveUrl` method. So, instead of loading Facelets views from custom
    locations via `ResourceResolver`, we can use a custom `ResourceHandler` class
    and a `createViewResource` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `ResourceResolver` class was deprecated, the existing type `javax.faces.application.Resource`
    class has been given a base class named `javax.faces.application.ViewResource`.
    This class contains a single method named `getURL`. So, when a Facelets view should
    be loaded from a custom location, we tell JSF to use our `CustomViewResource`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `createViewResource` method provides several advantages, because it *is
    applicable to general view resources and by default is functional equivalent to
    the existing* `createResource` *method. Besides being much more consistent, this
    means it's now also possible to load Facelets from a JAR file without needing
    to provide a custom resolver*.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch12_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backward compatibility, JSF will let the default resolver to call the new
    `createViewResource` method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_4`.
  prefs: []
  type: TYPE_NORMAL
- en: Include Facelets programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know how to include Facelets using the `<ui:include>` tag. But,
    sometimes you may need to programmatically reproduce something like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmatically speaking, the same thing can be accomplished if you know:
    how to obtain access to `FaceletContext`, how to use the `FaceletContext.includeFacelet`
    method, and how to set attributes using `FaceletContext.setAttribute`. For example,
    the programmatic version of the preceding snippet of code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_22`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TagHandler class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already know that several Facelets tags are tag handlers, while the others
    are component handlers—in [Chapter 10](ch10.html "Chapter 10. JSF Custom Components"),
    *JSF Custom Components*, you saw how to write a `ComponentHandler` class for a
    custom component. In this section, you will see how to write a `TagHandler` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tag handlers are efficient only when the view tree is built.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write a `TagHandler` class, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `TagHandler` class and override the `apply` method; this method process
    changes on a particular `UIComponent` class. Access the tag attributes via the
    `getAttribute` and `getRequiredAttribute` methods, which returns a `TagAttribute`
    instance that exposes the attribute value, namespace, local name, tag (the latter
    is new in JSF 2.2, see the `getTag`/`setTag` documentation), and so on. Moreover,
    use the `tag` and `tagId` fields to refer to the `Tag` instance corresponding
    to this `TagHandler` instance. Delegate control to the next tag handler using
    the `nextHandler` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `*taglib.xml` file to configure the tag namespace, name, and handler
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indicate the location of the `*taglib.xml` file using the `javax.faces.FACELETS_LIBRARIES`
    context parameter in the `web.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that we need the following functionality: we provide
    a piece of text, the number of times it should be displayed, and the possibility
    to be displayed in uppercase. We may think of a tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A `TagHandler` class can be the response to our need. First, we extend the
    `TagHandler` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, you need to write the `*taglib.xml` file and configure it in the
    `web.xml` file. The complete application is named `ch12_17`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom Facelets taglib functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you need a value to be evaluated directly in EL, then Facelets taglib
    functions (or expression functions) are a great solution. For example, let''s
    say that we want to encrypt/decrypt text and the result to be placed directly
    into an EL expression. In order to do this, you need to perform the following
    general steps of writing a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a Java `public final` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this class, implement the desired functionality using `public static` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `*taglib.xml` file for linking the `public static` methods (functions)
    with JSF pages. For each `static` method, you need to specify the name (`<function-name>`),
    the fully qualified class name that contains the `static` method (`<function-class>`),
    and the declaration of the `static` method (`<function-signature>`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indicate the location of the `*taglib.xml` file using the `javax.faces.FACELETS_LIBRARIES`
    context parameter in the `web.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, based on these steps, we can write a class that contains two functions,
    one for encryption and one for decryption, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*taglib.xml` file is straightforward as can be seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'After you configure the preceding `*taglib.xml` file in `web.xml`, you can
    try to call the encrypt/decrypt functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_16`.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a well-known fact that JSF pitfalls are not easy to understand and fix.
    This is mostly because their roots originate in: JSF life cycle, bad practices
    of using listeners and events, misunderstandings regarding EL processing and evaluation,
    conflicting combinations of tag handlers with components, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on three common Facelets pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX and <ui:repeat>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a common scenario to use AJAX for re-rendering the content of an `<ui:repeat>`
    tag. It is absolutely intuitive to write something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: So, initially, there is a list of *n* players and when we click on the button
    labeled **Half It**, we want to remove half of the players and re-render the list.
    The problem is that the preceding snippet of code will not work as expected, because
    the `<ui:repeat>` tag doesn't render HTML code; therefore, there will be no HTML
    element with the ID, `playersId`. Instead of seeing a list with only five players,
    we will get a `malformedXML` error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This more of a pitfall of using JSF AJAX with components that do not get rendered
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple workaround will be to enclose the `<ui:repeat>` tag inside a `<div>`
    tag, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_26`.
  prefs: []
  type: TYPE_NORMAL
- en: Exemplifying <c:if> versus <ui:fragment>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common scenario is to render a table data based on a `<c:if>` condition,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the result will not be as expected. The problem is that `<c:if>` is
    a tag handler; therefore, it is efficiently reflected when the tree is built.
    A perfect workaround will be to replace `<c:if>` with the `<ui:fragment>` tag,
    which is a component handler. The `rendered` attribute of `<ui:fragment>` can
    successfully replace the `<c:if>` test using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, in an even simpler way, use the `rendered` attribute of `<h:outputText>`;
    this approach is particular to this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, even cooler, using a lambda expression (EL 3.0), you can write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_20`.
  prefs: []
  type: TYPE_NORMAL
- en: Exemplifying <c:forEach> versus <ui:repeat>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apparently, you may think that the `<ui:repeat>`/`<ui:include>` pair is the
    perfect choice for including a list of Facelets pages using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the `<ui:include>` tag is a tag handler; therefore it will be available
    when the view is built, while the `<ui:repeat>` tag is a component handler available
    during the rendering process. In other words, when `<ui:include>` needs the `t`
    variable, `<ui:repeat>` is not available. Therefore, `<ui:repeat>` should be replaced
    by a tag handler, as `<c:forEach>`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch12_21`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facelets is a large subject with many interesting aspects which are pretty hard
    to cover in a few chapters of a book. As you know, there are books entirely dedicated
    to Facelets, but I hope that in the final three chapters I managed to cover a
    decent part of the JSF 2.2 default VDL. Probably, the most used part of Facelets
    is templating; therefore, I have tried to cover some handy techniques for writing
    flexible and cool templates. Of course, besides skills and techniques, writing
    templates is also a test of the imagination. Once we master the Facelets tags
    and choose the right techniques, we are ready to start writing templates. If we
    choose some naming conventions as well, then we can easily share our templates
    with the JSF world, like Mamadou Lamine Ba tried in a Java.Net project at [https://weblogs.java.net/blog/lamineba/archive/2011/10/03/conventional-ui-design-facelets-and-jsf-22](https://weblogs.java.net/blog/lamineba/archive/2011/10/03/conventional-ui-design-facelets-and-jsf-22).
    In addition, if we spice up our template files with some Facelets programmatic
    tricks, then we can really rock the world of JSF templating!
  prefs: []
  type: TYPE_NORMAL
