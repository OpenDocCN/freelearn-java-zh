- en: Chapter 12. Facelets Templating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。Facelets模板化
- en: In this chapter, we will cover several aspects of Facelets templating and some
    related aspects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖Facelets模板化的几个方面以及一些相关内容。
- en: JSF is defined as a component-based application development framework. When
    we say Facelets, we mean friendly page development, reusability of code, templating,
    composition components, custom logic tags, expression functions, high-performance
    rendering, optimized compilation time, and so on. But what actually is Facelets?
    Well, Facelets represents a **VDL** (**View Declaration Language**), and initially,
    it was created as an alternative to JSP. During JSF 1.1 and 1.2, this view handler
    can be used only after a separate download and configuration, while JSP was the
    default view handler. Things started to change with JSF 2.0, when the mismatch
    between JSF and JSP allowed Facelets to become the standard and default VDL, while
    JSP was deprecated. Starting with JSF 2.2, this concept was seriously fortified
    and Facelets was boosted with new features and capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JSF被定义为基于组件的应用程序开发框架。当我们提到Facelets时，我们指的是友好的页面开发、代码的重用性、模板化、组件组合、自定义逻辑标签、表达式函数、高性能渲染、优化编译时间等。但Facelets实际上是什么？嗯，Facelets代表了一种**VDL**（**视图声明语言**），最初它是作为JSP的替代品而创建的。在JSF
    1.1和1.2期间，这个视图处理器只能在单独下载和配置之后使用，而JSP是默认的视图处理器。随着JSF 2.0的推出，JSF和JSP之间的不匹配使得Facelets成为了标准和默认的VDL，而JSP被弃用。从JSF
    2.2开始，这个概念得到了加强，Facelets通过新的功能和能力得到了提升。
- en: A brief overview of the Facelets tags
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facelets标签的简要概述
- en: '**Templating** is a concept based on code reusability. Templates, or tiles,
    represent the portions of reusable code that can be puzzled together to obtain
    JSF pages. In order to accomplish this, we exploit a handful of tags from [http://xmlns.jcp.org/jsf/facelets](http://xmlns.jcp.org/jsf/facelets)
    namespace.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板化**是一个基于代码重用性的概念。模板，或称为砖块，代表了可以拼凑在一起以获得JSF页面的可重用代码部分。为了实现这一点，我们利用了来自[http://xmlns.jcp.org/jsf/facelets](http://xmlns.jcp.org/jsf/facelets)命名空间的一批标签。'
- en: 'Usually, prefixed with `ui`, these tags are listed as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些标签以`ui`为前缀，列表如下：
- en: 'The `<ui:composition>` tag (`TagHandler`): This defines a page composition
    that can use a template (any content outside of this tag is ignored). The `template`
    attribute is optional and is used for indicating a template to which the enclosed
    content should be applied. Multiple compositions can use the same template, thus
    encapsulating and reusing the layout. Facelets will paste the enclosed content
    into the component''s hierarchy, usually under `UIViewRoot`. The `<ui:composition>`
    tag is used in the following manner:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:composition>`标签（`TagHandler`）：这个标签定义了一个可以使用模板的页面组合（此标签之外的所有内容都将被忽略）。`template`属性是可选的，用于指示应将封装内容应用于哪个模板。多个组合可以使用相同的模板，从而封装和重用布局。Facelets会将封装的内容粘贴到组件的层次结构中，通常在`UIViewRoot`之下。《ui:composition>`标签的使用方式如下：'
- en: '[PRE0]'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `<ui:define>` tag (`TagHandler`): This defines the content that is inserted
    into a page by a template. It may appear in the `<ui:composition>`, `<ui:component>`,
    `<ui:decorate>`, and `<ui:fragment>` tags and it has a matching `<ui:insert>`
    tag, which is capable of inserting the defined content into a page. Most commonly,
    it appears in the `<ui:composition>` tag. The `<ui:define>` tag is used in the
    following manner:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:define>`标签（`TagHandler`）：这个标签定义了模板插入到页面中的内容。它可能出现在`<ui:composition>`、`<ui:component>`、`<ui:decorate>`和`<ui:fragment>`标签中，并且有一个匹配的`<ui:insert>`标签，可以将定义的内容插入到页面中。最常见的是，它出现在`<ui:composition>`标签中。`<ui:define>`标签的使用方式如下：'
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `<ui:insert>` tag (`TagHandler`): This inserts the content into a template.
    Usually, that content is defined by the `<ui:define>` tag in a `<ui:composition>`,
    `<ui:component>`, `<ui:decorate>`, or `<ui:fragment>` tag. This tag indicates
    the exact place where the content will be inserted. When the `name` attribute
    is missing, Facelets will add the body content of this tag to the view. The `<ui:insert>`
    tag is used in the following manner:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:insert>`标签（`TagHandler`）：这个标签将内容插入到模板中。通常，这个内容是由`<ui:define>`标签在`<ui:composition>`、`<ui:component>`、`<ui:decorate>`或`<ui:fragment>`标签中定义的。这个标签指示了内容将被插入的确切位置。当`name`属性缺失时，Facelets会将此标签的正文内容添加到视图中。《ui:insert>`标签的使用方式如下：'
- en: '[PRE2]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `<ui:include>` tag (`TagHandler`): This is used to encapsulate and reuse
    content from multiple pages. The included content can be plain XHTML and XHTML
    pages that have either a `<ui:composition>` tag or a `<ui:component>` tag. This
    tag can be easily combined with `<ui:param>` to provide parameters to the included
    pages, but is also combined with the `<ui:fragment>`, `<ui:decorate>`, and `<ui:insert>`
    tags. This is one of the most used tags since it sustains the idea of reusing
    templated code. The `<ui:include>` tag is used in the following manner:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:include>`标签（`TagHandler`）：这个标签用于封装和重用来自多个页面的内容。包含的内容可以是纯XHTML和具有`<ui:composition>`标签或`<ui:component>`标签的XHTML页面。这个标签可以很容易地与`<ui:param>`结合使用，为包含的页面提供参数，但它也可以与`<ui:fragment>`、`<ui:decorate>`和`<ui:insert>`标签结合使用。这是最常用的标签之一，因为它支持重用模板代码的理念。《ui:include>`标签的使用方式如下：'
- en: '[PRE3]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Starting with JSF 2.2, the `UIViewRoot.restoreViewScopeState(FacesContext context,
    Object state)` method was added to allow the use of view scoped beans for EL expressions
    in the template from which the component tree is built. This means that the following
    code is useful:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从JSF 2.2版本开始，新增了`UIViewRoot.restoreViewScopeState(FacesContext context, Object
    state)`方法，允许在构建组件树模板中使用视图作用域的bean进行EL表达式。这意味着以下代码是有用的：
- en: '[PRE4]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `<ui:param>` tag (`TagHandler`): This passes parameters to an included
    file or a template. It is used in the `<ui:include>`, `<ui:composition>`, or `<ui:decorate>`
    tags. A parameter is characterized by a name-value pair—both can be string literals
    or EL expressions. In the included file or template, the parameter is available
    via EL. The `<ui:param>` tag is used in the following manner:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:param>`标签（`TagHandler`）：这个标签用于将参数传递给包含的文件或模板。它用于`<ui:include>`、`<ui:composition>`或`<ui:decorate>`标签中。参数由一个名称-值对组成——两者都可以是字符串字面量或EL表达式。在包含的文件或模板中，参数可以通过EL访问。`<ui:param>`标签的使用方式如下：'
- en: '[PRE5]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `<ui:repeat>` tag (`ComponentHandler`): This is used as an alternative
    for loop tags such as `<c:forEach>` and `<h:dataTable>`. Since `<ui:repeat>` is
    a component handler, while `<c:forEach>` is a tag handler, you have to pay attention
    when you choose between them! The `<ui:repeat>` tag is used in the following manner:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:repeat>`标签（`ComponentHandler`）：这个标签用作循环标签（如`<c:forEach>`和`<h:dataTable>`）的替代品。由于`<ui:repeat>`是一个组件处理器，而`<c:forEach>`是一个标签处理器，所以在选择它们时需要特别注意！`<ui:repeat>`标签的使用方式如下：'
- en: '[PRE6]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `<ui:debug>` tag (`ComponentHandler`): This defines a debug component in
    the component tree capable to capture debugging information such as component
    tree, scoped variables, and view state. By default, this information appears in
    a debug pop-up window when you press *Ctrl* + *Shift* + *D* (in Windows OS). You
    can alter the *D* key by explicitly setting another keyboard using the optional
    `hotkey` attribute. The `<ui:debug>` tag is used in the following manner:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:debug>`标签（`ComponentHandler`）：这个标签在组件树中定义了一个能够捕获调试信息（如组件树、作用域变量和视图状态）的调试组件。默认情况下，当您按下*Ctrl*
    + *Shift* + *D*（在Windows操作系统上）时，这些信息会显示在调试弹出窗口中。您可以通过使用可选的`hotkey`属性显式设置另一个键盘来更改*D*键。`<ui:debug>`标签的使用方式如下：'
- en: '[PRE7]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `<ui:component>` tag (`ComponentHandler`): This is similar to `<ui:composition>`,
    only that it defines a component directly into the component tree without an associated
    template. The `<ui:component>` tag is used in the following manner:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:component>`标签（`ComponentHandler`）：这与`<ui:composition>`类似，只是它直接在组件树中定义了一个组件，而没有关联的模板。《ui:component>`标签的使用方式如下：'
- en: '[PRE8]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `<ui:fragment>` tag (`ComponentHandler`): Again, this is similar to `<ui:component>`
    tag, but doesn''t ignore the content outside this tag. Its main skill consists
    of the `rendered` attribute, which is very useful for deciding if the enclosed
    content will be displayed or not. This tag doesn''t produce client-side effects,
    which makes it a great alternative to `<h:panelGroup>`, which has the client side
    effect of producing the `<span>` or `<div>` tags. If you want to work with `<h:panelGroup>`
    without producing the `<span>` or `<div>` tags, then skip adding an explicit ID
    to it. An `<h:panelGroup>` tag produces a `<span>` tag if it has an explicit ID,
    and a `<div>` tag if it has an explicit ID and the value of the `layout` attribute
    set to the `block` value. The `<ui:fragment>` tag is used in the following manner:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:fragment>` 标签（`ComponentHandler`）：再次强调，这与 `<ui:component>` 标签类似，但不会忽略此标签之外的内容。其主要技能包括
    `rendered` 属性，这对于决定封装内容是否显示非常有用。此标签不会产生客户端效果，这使得它成为 `<h:panelGroup>` 的绝佳替代品，后者会产生
    `<span>` 或 `<div>` 标签的客户端效果。如果您想在不会产生 `<span>` 或 `<div>` 标签的情况下使用 `<h:panelGroup>`，则无需显式添加
    ID。一个 `<h:panelGroup>` 标签如果具有显式 ID，则会产生一个 `<span>` 标签；如果具有显式 ID 并且 `layout` 属性的值设置为
    `block`，则会产生一个 `<div>` 标签。《ui:fragment>` 标签的使用方法如下：'
- en: '[PRE9]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `<ui:decorate>` tag (`TagHandler`): This is similar to the `<ui:composition>`
    tag, but doesn''t ignore the content outside this tag. This is a nice feature,
    since it allows us to apply any element in the page to a template. The `template`
    attribute is mandatory. The `<ui:decorate>` tag is used in the following manner:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:decorate>` 标签（`TagHandler`）：这与 `<ui:composition>` 标签类似，但不会忽略此标签之外的内容。这是一个很好的特性，因为它允许我们将页面上的任何元素应用于模板。`template`
    属性是必需的。《ui:decorate>` 标签的使用方法如下：'
- en: '[PRE10]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `<ui:remove>` tag: This removes the content from a page. The `<ui:remove>`
    tag is used in the following manner:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ui:remove>` 标签：从页面中删除内容。《ui:remove>` 标签的使用方法如下：'
- en: '[PRE11]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can read about further details of these tags at [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/ui/tld-summary.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/ui/tld-summary.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/ui/tld-summary.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/ui/tld-summary.html)
    了解这些标签的更多详细信息。
- en: Creating a simple template – PageLayout
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单模板 – 页面布局
- en: 'When these eleven tags combine their skills, we can create amazing templates.
    For example, let''s suppose that we want to create the template from the following
    diagram and we name it `PageLayout`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当这十一个标签结合其技能时，我们可以创建令人惊叹的模板。例如，假设我们想从以下图表创建模板，并将其命名为 `PageLayout`：
- en: '![Creating a simple template – PageLayout](img/6466EN_12_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单模板 – 页面布局](img/6466EN_12_01.jpg)'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Notice that with just a few clicks, NetBeans can generate the code behind several
    templates of Facelets, including the preceding abstractization. But, this time
    we will write it manually, in order to exemplify the Facelets tags. While NetBeans
    provides a compact code, based on a single XHTML page, we will write an expanded
    approach using six XHTML pages. In this way, you will have two ways of writing
    this kind of template.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只需几点击，NetBeans 就可以生成 Facelets 几个模板背后的代码，包括前面的抽象化。但这次我们将手动编写它，以便举例说明 Facelets
    标签。虽然 NetBeans 提供了一个基于单个 XHTML 页面的紧凑代码，但我们将使用六个 XHTML 页面编写一个扩展方法。这样，你将有两种编写此类模板的方式。
- en: 'As you can see, there are five distinctive sections: **Header**, **Footer**,
    **Left**, **Center**, and **Right**. For each of these sections, we will write
    a separate XHTML page. The header is generated in the `topDefault.xhtml` page,
    that simply uses the `<ui:composition>` tag to provide the default content as
    follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有五个独特的部分：**标题**、**页脚**、**左侧**、**中心**和**右侧**。对于这些部分中的每一个，我们将编写一个单独的 XHTML
    页面。标题是在 `topDefault.xhtml` 页面生成的，该页面简单地使用 `<ui:composition>` 标签提供以下默认内容：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The same approach can be used for the remaining four sections. Just replace
    the default header text and create the following XHTMLs: `bottomDefault.xhtml`
    for the footer, `contentDefault.xhtml` for the center, `leftDefault.xhtml` for
    the left-hand side, and `rightDefault.xhtml` for the right-hand side.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也可以用于剩余的四个部分。只需替换默认的标题文本，并创建以下 XHTML 文件：`bottomDefault.xhtml` 用于页脚，`contentDefault.xhtml`
    用于中心，`leftDefault.xhtml` 用于左侧，`rightDefault.xhtml` 用于右侧。
- en: 'These five XHTMLs are like five pieces of the puzzle and they serve as the
    default content for our template. Now, we can compose the puzzle (this is known
    as the template file or simply the template) by writing an XHTML page that uses
    the `<ui:insert>` and `<ui:include>` tags as shown in the following code—this
    is `layout.xhtml`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个 XHTML 文件就像拼图的五个部分，它们作为模板的默认内容。现在，我们可以通过编写一个使用 `<ui:insert>` 和 `<ui:include>`
    标签的 XHTML 页面来组合拼图（这被称为模板文件或简单地称为模板），如下面的代码所示——这是 `layout.xhtml`：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each section was represented by an `<ui:insert>` tag and the default content
    was included using `<ui:include>`. Some `<div>` tags and CSS were used for arranging
    and styling the pieces of the puzzle in the main template file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都由一个 `<ui:insert>` 标签表示，默认内容是通过 `<ui:include>` 包含的。在主模板文件中，一些 `<div>` 标签和
    CSS 被用来排列和样式化拼图的各个部分。
- en: 'Now, the template, as shown in the following code, is ready to be used in `index.xhtml`;
    this is known as the **template client**:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如下面的代码所示，模板已经准备好在 `index.xhtml` 中使用；这被称为 **模板客户端**：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this moment, we can alter the default content of our template using the
    `<ui:define>` tag, for example, if we want to replace the text that appears in
    the center section. This is the default content, with the **Rafael Nadal Home
    Page** text, as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，我们可以使用 `<ui:define>` 标签来更改模板的默认内容，例如，如果我们想替换中心部分显示的文本。这是默认内容，包含有 **拉斐尔·纳达尔主页**
    文本，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the same way, you can redefine the content for the remaining four sections.
    The complete application is named `ch12_1`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，你可以为剩余的四个部分重新定义内容。完整的应用程序被命名为 `ch12_1`。
- en: This is a pretty simple template that can serve us as support for presenting
    the rest of Facelets tags. We will continue with several punctual examples for
    `<ui:param>`, `<ui:decorate>`, `<ui:fragment>`, `<ui:repeat>`, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的模板，它可以作为我们展示其他 Facelets 标签的支持。我们将继续使用几个具体的例子来展示 `<ui:param>`、`<ui:decorate>`、`<ui:fragment>`、`<ui:repeat>`
    等标签。
- en: Passing parameters via <ui:param>
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 <ui:param> 传递参数
- en: 'The `<ui:param>` tag is a tag handler that is capable of sending parameters
    to an included file or to a template. A quick example will make you understand
    how `<ui:param>` works. In the following code, we are in the template client,
    `index.xhtml`, and we send a parameter to the template file, `layout.xhtml`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ui:param>` 标签是一个能够向包含文件或模板发送参数的标签处理器。一个简单的例子会让你明白 `<ui:param>` 的工作原理。在下面的代码中，我们处于模板客户端
    `index.xhtml`，并向模板文件 `layout.xhtml` 发送一个参数：'
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also access this parameter in `layout.xhtml` using its name via EL.
    We can do that anywhere in the template file; for example, we can use this parameter
    for creating a new parameter to be sent to an included file, in this case, to
    the `contentDefault.xhtml` file, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 `layout.xhtml` 中使用表达式语言（EL）通过其名称访问此参数。我们可以在模板文件的任何地方这样做；例如，我们可以使用此参数来创建一个新的参数，将其发送到包含的文件，在这种情况下，是
    `contentDefault.xhtml` 文件，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the same template, we can send parameters to different included pages.
    Besides the `playernamesurname` parameter, let''s send one to the `topDefault.xhtml`
    page using the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从同一个模板，我们可以向不同的包含页面发送参数。除了 `playernamesurname` 参数外，让我们使用以下代码向 `topDefault.xhtml`
    页面发送一个参数：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, send one parameter to the `bottomDefault.xhtml` page using the following
    code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码向 `bottomDefault.xhtml` 页面发送一个参数：
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the `playernamesurname` parameter is accessible via EL in the `contentDefault.xhtml`
    page as shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`playernamesurname` 参数在 `contentDefault.xhtml` 页面中可通过表达式语言（EL）访问，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Moreover, `headertext` and `footertext` are accessible via EL in the `topDefault.xhtml`
    and `bottomDefault.xhtml` pages. Now, the result of using `<ui:param>` will be
    as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`headertext` 和 `footertext` 在 `topDefault.xhtml` 和 `bottomDefault.xhtml`
    页面中可通过表达式语言（EL）访问。现在，使用 `<ui:param>` 的结果如下面的截图所示：
- en: '![Passing parameters via <ui:param>](img/6466EN_12_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![通过 <ui:param> 传递参数](img/6466EN_12_02.jpg)'
- en: The complete application is called `ch12_11`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序被称作 `ch12_11`。
- en: Passing bean properties and action methods via <ui:param>
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 <ui:param> 传递属性和动作方法
- en: 'In the previous example, you saw how to exploit `<ui:param>` for sending literal
    strings to a template or included page, but `<ui:param>` can be used for more
    than this. Let''s suppose that we have the following code of the bean, `TemplatesBean`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你看到了如何利用 `<ui:param>` 将文本字符串发送到模板或包含页面，但 `<ui:param>` 可以用于更多的情况。假设我们有以下
    `TemplatesBean` 的代码：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Further, we want to display the value of the `msgCenterDefault` property in
    `contentDefault.xhtml`. Of course, this is very easy to accomplish using the following
    line of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望在`contentDefault.xhtml`中显示`msgCenterDefault`属性的值。当然，这使用以下代码行很容易实现：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But we want to pass the name of the bean and the name of the property via `<ui:param>`.
    This can be accomplished using the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们希望通过`<ui:param>`传递bean的名称和属性的名称。这可以通过以下代码实现：
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, in `contentDefault.xhtml`, you can display the value of the `msgCenterDefault`
    property as shown in the following line of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`contentDefault.xhtml`中，你可以显示`msgCenterDefault`属性的值，如下面的代码行所示：
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Well, that was easy! But how about calling the `centerAction` method, which
    modifies the value of the `msgCenterDefault` property? For this, we add the method
    name between single quotes, in square brackets, followed by a pair of parentheses
    indicating a method without arguments, as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单！但是，如何调用修改`msgCenterDefault`属性值的`centerAction`方法呢？为此，我们在方括号内添加方法名，并用一对括号表示没有参数的方法，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we want to call the `topAction` (or `bottomAction`) method. This time,
    we want to pass via `<ui:param>` the bean name, action method name, and the argument
    value. For this, we will write the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望调用`topAction`（或`bottomAction`）方法。这次，我们希望通过`<ui:param>`传递bean名称、action方法名称和参数值。为此，我们将编写以下代码：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `topDefault.xhtml`, we can exploit the information passed through these
    three parameters, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`topDefault.xhtml`中，我们可以利用通过这三个参数传递的信息，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the following screenshot, you can see that everything worked as expected:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以看到一切按预期工作：
- en: '![Passing bean properties and action methods via <ui:param>](img/6466EN_12_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![通过<ui:param>传递bean属性和action方法](img/6466EN_12_03.jpg)'
- en: The complete application is named `ch12_13`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_13`。
- en: 'A `<ui:param>` value can be accessed from a managed bean, as shown in the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从管理Bean中访问`<ui:param>`的值，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Exploiting the <ui:decorate> and <ui:fragment> tags
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用<ui:decorate>和<ui:fragment>标签
- en: 'First, let''s talk about the `<ui:decorate>` tag. As its name suggests, this
    tag is used for decorating pieces of a page. Unlike `<ui:composition>`, this tag
    doesn''t ignore the content that is not enclosed in it, which may be an added
    advantage sometimes. Well, a simple example is shown in the following code (the
    `template` attribute is mandatory):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈`<ui:decorate>`标签。正如其名称所暗示的，这个标签用于装饰页面的一部分。与`<ui:composition>`不同，这个标签不会忽略其外部的内容，这有时可能是一个额外的优势。好吧，一个简单的示例如下面的代码所示（`template`属性是必需的）：
- en: '[PRE29]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding snippet produces the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段产生了以下屏幕截图：
- en: '![Exploiting the <ui:decorate> and <ui:fragment> tags](img/6466EN_12_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![利用<ui:decorate>和<ui:fragment>标签](img/6466EN_12_04.jpg)'
- en: The complete example is named `ch12_10`. Basically, this example decorates a
    page with a template and proves the effect of the `<ui:decorate>` tag against
    the `<ui:composition>` tag. However, let's see a better example of decorating
    a part of a page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例命名为`ch12_10`。基本上，这个示例使用模板装饰了一个页面，并证明了`<ui:decorate>`标签相对于`<ui:composition>`标签的效果。然而，让我们看看装饰页面一部分的更好示例。
- en: 'In this example, we will decorate a `<div>` element with an `<ul>` list. The
    items of list `<li>` come from two separated pages, and the technique for accomplishing
    this is based on nested `<ui:decorate>` tags. The template client, `index.xhtml`,
    uses `<ui:decorate>` to decorate the `<div>` element with a template that contains
    the `<ul>` list, as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`<ul>`列表装饰一个`<div>`元素。列表的`<li>`项来自两个独立的页面，实现这一技术的关键是嵌套的`<ui:decorate>`标签。模板客户端`index.xhtml`使用`<ui:decorate>`装饰`<div>`元素，并包含`<ul>`列表，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Furthermore, the `ul.xhtml` template provides the `<ul>` list and a part of
    `<li>` items, but also uses the `<ui:decorate>` tag to decorate the `<ul>` list
    with the remaining `<li>` items, which are available via the `li.xhtml` template,
    as shown in the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ul.xhtml`模板提供了`<ul>`列表和部分`<li>`项，还使用`<ui:decorate>`标签装饰`<ul>`列表，以包含剩余的`<li>`项，这些项可通过`li.xhtml`模板获得，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `li.xhtml` template uses the `<ui:fragment>` tag to provide the rest of
    the `<li>` list. But since `<ui:fragment>` doesn''t block the unclosed content,
    we can slip some `<li>` items outside of it as well, as shown in the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`li.xhtml`模板使用`<ui:fragment>`标签来提供`<li>`列表的其余部分。但由于`<ui:fragment>`不会阻止未关闭的内容，我们也可以将一些`<li>`项目放在它外面，如下面的代码所示：'
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Done! We have especially used different colors for `<li>` items. This is very
    useful, because it really helps us understand how the page is composed using the
    `<ui:decorate>` tag. Please refer to the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们特别使用了不同的颜色来表示`<li>`项目。这非常有用，因为它确实有助于我们理解页面是如何使用`<ui:decorate>`标签组成的。请参考以下截图：
- en: '![Exploiting the <ui:decorate> and <ui:fragment> tags](img/6466EN_12_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![利用<ui:decorate>和<ui:fragment>标签](img/6466EN_12_05.jpg)'
- en: The complete application is named `ch12_24`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完整应用程序命名为`ch12_24`。
- en: 'The same result can be obtained using different kinds of approaches. But, another
    one that can be used as a templating technique consists in replacing the `<ui:decorate>`
    tag from the `ul.xhtml` template with a combination of the `<ui:insert>`, `<ui:define>`,
    and `<ui:include>` tags. In order to do that, we change the `ul.xhtml` template
    using the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用不同的方法获得相同的结果。但是，另一种可以作为模板技术使用的方法是将`ul.xhtml`模板中的`<ui:decorate>`标签替换为`<ui:insert>`、`<ui:define>`和`<ui:include>`标签的组合。为了做到这一点，我们使用以下代码更改`ul.xhtml`模板：
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will change the code for the template client to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更改模板客户端的代码如下：
- en: '[PRE34]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The complete application is named `ch12_23`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完整应用程序命名为`ch12_23`。
- en: Iterating with <ui:repeat>
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用<ui:repeat>进行迭代
- en: The `<ui:repeat>` tag is a component handler that is capable of iterating over
    a collection, and at each iteration, it adds a copy of its child elements in the
    component tree. We can say that `<ui:repeat>` acts as a `<h:dataTable>` tag without
    rendering an HTML table. Of course, you can do that explicitly, by wrapping its
    mechanism in a `<table>`, `<tr>`, and `<td>` suite (you will see an example in
    the upcoming section, *Using the jsfc attribute*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ui:repeat>`标签是一个能够遍历集合的组件处理器，在每次迭代时，它将子元素的一个副本添加到组件树中。我们可以这样说，`<ui:repeat>`充当一个不渲染HTML表的`<h:dataTable>`标签。当然，你可以通过将其机制包裹在`<table>`、`<tr>`和`<td>`套件中来实现这一点（你将在下一节中看到一个示例，*使用jsfc属性*）。'
- en: 'It contains a set of very handy attributes that deserve to be mentioned before
    an example. Besides the well known attributes, `value` (representing the collection
    to iterate as `java.lang.Object`) and `var` (representing the iterator as `java.lang.Object`),
    we have––all the following attributes that are optional:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一组非常实用的属性，在举例之前值得提一下。除了众所周知的属性外，还有`value`（表示迭代集合的`java.lang.Object`）和`var`（表示迭代器为`java.lang.Object`），我们还有以下可选属性：
- en: '`step`: This attribute allows us to indicate, as an `int` value, the number
    of items that will be skipped for each iteration. By default, the `<ui:repeat>`
    tag iterates over each item of the collection, which indicates a `step` attribute
    equal to 1, and indicates that the process starts with the first one item.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`：此属性允许我们以`int`值的形式指示每次迭代要跳过的项目数。默认情况下，`<ui:repeat>`标签遍历集合中的每个项目，这表示`step`属性等于1，并指示过程从第一个项目开始。'
- en: '`size`: This is the size of the collection over which to iterate; it has to
    be evaluated to an `int` value.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：这是要迭代的集合的大小；它必须评估为`int`值。'
- en: '`offset`: By default, `<ui:repeat>` begins the iteration process from the first
    item of the collection. This attribute allows us to jump over a number of items,
    by telling Facelets to start the iteration process for a certain offset. This
    offset is settled before the iteration process begins; it has to be evaluated
    to an `int` value.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`：默认情况下，`<ui:repeat>`从集合的第一个项目开始迭代过程。此属性允许我们通过告诉Facelets从某个偏移量开始迭代过程来跳过一定数量的项目。此偏移量在迭代过程开始之前确定；它必须评估为`int`值。'
- en: '`varStatus`: This attribute reveals the status of the current item via a POJO
    object. An explicit example of using it will follow shortly, but for now let''s
    have several examples of iterating different kinds of Java collections.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`varStatus`：此属性通过POJO对象揭示当前项的状态。稍后将提供一个使用它的明确示例，但现在让我们看几个迭代不同类型Java集合的示例。'
- en: 'A simple example of iterating an `ArrayList` collection looks like the following
    code (the same approach can be applied to any `java.util.List` package):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代`ArrayList`集合的一个简单例子如下代码（相同的方法可以应用于任何`java.util.List`包）：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, `<ui:repeat>` can also iterate over a `HashSet` collection using the
    `toArray` method, as follows (the same approach can be applied to `TreeSet` and
    `LinkedHashSet`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`<ui:repeat>` 也可以使用 `toArray` 方法遍历 `HashSet` 集合，如下所示（相同的方法也可以应用于 `TreeSet`
    和 `LinkedHashSet`）：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or, even more, `<ui:repeat>` can also iterate over a `Map` collection (`HashMap`,
    `TreeMap`, and `LinkedHashMap`) using the following approaches:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更进一步，`<ui:repeat>` 也可以使用以下方法遍历 `Map` 集合（`HashMap`、`TreeMap` 和 `LinkedHashMap`）：
- en: 'The following is the code for the first approach:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为第一种方法的代码：
- en: '[PRE37]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the code for the second approach:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为第二种方法的代码：
- en: '[PRE38]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the code for the third approach:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为第三种方法的代码：
- en: '[PRE39]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is the code for the fourth approach:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为第四种方法的代码：
- en: '[PRE40]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding examples iterate the entire collection. But if you want to iterate
    only the items from even positions, then we can bring the `step` attribute into
    the scene, as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例遍历了整个集合。但如果你只想遍历偶数位置的项，那么我们可以引入 `step` 属性，如下所示：
- en: '[PRE41]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For odd items, you may want to combine the powers of the `step` and `offset`
    attributes, using the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于奇数项，你可能想结合使用 `step` 和 `offset` 属性，以下代码展示了如何操作：
- en: '[PRE42]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Another common approach for displaying even/odd items consists of using the
    `varStatus` attribute. The POJO object, representing the value of this attribute,
    contains several read-only JavaBeans properties. Between these properties, we
    have the even and odd properties, which can be easily used in combination with
    `<ui:fragment>`, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 显示偶数/奇数项的另一种常见方法是通过使用 `varStatus` 属性。代表此属性值的 POJO 对象包含几个只读的 JavaBeans 属性。在这些属性之间，我们有偶数和奇数属性，可以很容易地与
    `<ui:fragment>` 结合使用，如下所示：
- en: 'For the even properties, the code is given as follows:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于偶数属性，代码如下所示：
- en: '[PRE43]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For the odd properties, the code is given as follows:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于奇数属性，代码如下所示：
- en: '[PRE44]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The entire set of properties is exposed in the following snippet of code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 整套属性在以下代码片段中暴露：
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: All the preceding examples presented are united under the complete application
    named `ch12_6`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先前示例都统一在名为 `ch12_6` 的完整应用程序下。
- en: Working with <ui:include> and <f:viewParam>
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 <ui:include> 和 <f:viewParam>
- en: You may think that combining `<ui:include>` with `<f:viewParam>` is a strange
    combination, and maybe it is. But, as you know, `<ui:include>` is able to encapsulate
    and reuse content from multiple pages, while `<f:viewParam>` can be useful for
    adding view parameters in links (using the GET query string). This means that
    we can take parameters passed on the current page via `<f:viewParam>` and use
    them in `<ui:include>`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为将 `<ui:include>` 与 `<f:viewParam>` 结合使用是一种奇怪的组合，也许确实如此。但是，正如你所知，`<ui:include>`
    能够封装和重用来自多个页面的内容，而 `<f:viewParam>` 可以在链接中添加视图参数（使用 GET 查询字符串）很有用。这意味着我们可以通过 `<f:viewParam>`
    在 `<ui:include>` 中使用当前页面传递的参数。
- en: 'For example, in the current page, we can include a random page, or a page whose
    name was hardcoded as the value of a view parameter in an outcome. We can also
    use the `includeViewParams` attribute to tell other pages to include the same
    content as the current page. These three examples are just on open gate to more
    scenarios. The following example speaks for itself:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在当前页面中，我们可以包含一个随机页面，或者一个名称被硬编码为视图参数值的页面。我们还可以使用 `includeViewParams` 属性告诉其他页面包含与当前页面相同的内容。这三个例子只是更多场景的入门。以下示例不言自明：
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The code for `RandomInBean` is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomInBean` 的代码如下：'
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'So, we have several buttons to prove the symbiosis between the `<ui:include>`
    and `<f:viewParam>` tags. First, we have three buttons labeled **Include in_index_A.xhtml
    Page**, **Include in_index_B.xhtml Page**, and **Include in_index_C.xhtml Page**.
    All three act the same way; they pass a view parameter named `in`. The value of
    the view parameter is a string literal, and represents the page that should be
    included. This will generate a URL of the following type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有几个按钮来证明 `<ui:include>` 和 `<f:viewParam>` 标签之间的共生关系。首先，我们有三个按钮，分别标记为 **包含
    in_index_A.xhtml 页面**、**包含 in_index_B.xhtml 页面** 和 **包含 in_index_C.xhtml 页面**。这三个按钮的作用相同；它们传递一个名为
    `in` 的视图参数。视图参数的值是一个字符串字面量，表示应该包含的页面。这将生成以下类型的 URL：
- en: '`http://localhost:8080/ch12_12/faces/index.xhtml?in=in_index_B.xhtml`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch12_12/faces/index.xhtml?in=in_index_B.xhtml`'
- en: So, conforming to this URL, the `<ui:include>` tag will include the `in_index_B.xhtml`
    page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据此URL，`<ui:include>` 标签将包含 `in_index_B.xhtml` 页面。
- en: 'Further, we have a button labeled **Random Page**. This button will randomly
    choose between those three pages. In order to obtain this, we need to add `includeViewParams="false"`,
    as shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有一个标签为 **随机页面** 的按钮。此按钮将在三个页面之间随机选择。为了实现这一点，我们需要添加 `includeViewParams="false"`，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, we can tell other pages to include the same content as the current
    page. When you click on the button labeled **Tell mypage.xhtml To Include The
    Same Page As You Did**, the `mypage.xhtml` page will include the same page as
    the current page. For this, we need to add `includeViewParams="true"`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以告诉其他页面包含与当前页面相同的内容。当您点击标签为 **告诉 mypage.xhtml 包含与您相同的页面** 的按钮时，`mypage.xhtml`
    页面将包含与当前页面相同的内容。为此，我们需要添加 `includeViewParams="true"`。
- en: The complete application is named `ch12_12`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch12_12`。
- en: Working with <ui:include> and <ui:param>
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 <ui:include> 和 <ui:param>
- en: 'The `<ui:include>` and `<ui:param>` tags are two tag handlers that can be used
    for accomplishing many kinds of tasks; as long as we keep in mind that tag handlers
    are efficient only when the view tree is built, we can exploit them for our benefit.
    For example, we can use them to generate a tree node structure as shown in the
    following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ui:include>` 和 `<ui:param>` 标签是两种可以用于完成许多任务的标签处理器；只要我们记住标签处理器只有在视图树构建时才是高效的，我们就可以利用它们来为我们谋福利。例如，我们可以使用它们来生成如下截图所示的树节点结构：'
- en: '![Working with <ui:include> and <ui:param>](img/6466EN_12_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用 <ui:include> 和 <ui:param>](img/6466EN_12_06.jpg)'
- en: In order to accomplish this task, we will spice up the `<ui:include>` and `<ui:param>`
    tags with a dash of JSTL (the `<c:if>` and `<c:forEach>` tag handlers) and recursivity.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们将使用一点 JSTL（`<c:if>` 和 `<c:forEach>` 标签处理器）和递归性来增强 `<ui:include>`
    和 `<ui:param>` 标签。
- en: 'First, we need a class that represents the abstractization of the tree node
    concept. Basically, a tree node representation is a hierarchical structure of
    labels that can be recursively traversed. Based on this, we can write a generic
    tree node class as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个代表树节点概念的抽象化类。基本上，树节点表示是一个可以递归遍历的标签分层结构。基于此，我们可以编写一个通用的树节点类，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This class can serve a bean capable of defining a particular tree node, as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此类可以作为一个能够定义特定树节点的 bean。如下所示：
- en: '[PRE50]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The interesting part is how to display this structure as a tree node. HTML
    provides the `<ul>` and `<li>` tags that are able to represent data as a list.
    Moreover, nested `<ul>` tags output a hierarchical structure, which is very useful
    since it spears us for finding a custom representation. In order to reflect the
    tree node defined in `TreeNodeBean`, we write a page named `node.xhtml` capable
    of autoinclusion in an iterative-recursive process using the `<ui:include>` tag,
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是如何将这个结构显示为树节点。HTML 提供了 `<ul>` 和 `<li>` 标签，能够将数据表示为列表。此外，嵌套的 `<ul>` 标签输出一个分层结构，这对于找到自定义表示非常有用。为了反映
    `TreeNodeBean` 中定义的树节点，我们编写了一个名为 `node.xhtml` 的页面，该页面能够使用 `<ui:include>` 标签在迭代-递归过程中自动包含，如下所示：
- en: '[PRE51]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `node` parameter is passed via `<ui:param>` from the main page named `index.xhtml`.
    From the main page, we pass the tree node root. Furthermore, in `node.xhtml`,
    we iterate the descendants of the root in a recursive approach and display each
    node as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`node` 参数通过 `<ui:param>` 从名为 `index.xhtml` 的主页面传递。从主页面，我们传递树节点根。此外，在 `node.xhtml`
    中，我们以递归方式遍历根节点的后代，并显示每个节点，如下面的代码所示：'
- en: '[PRE52]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you didn't find this example useful, at least keep in mind that `<ui:include>`
    can be used in a recursive process. The complete application is named `ch12_14`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得这个例子没有用，至少要记住 `<ui:include>` 可以用于递归过程。完整的应用程序命名为 `ch12_14`。
- en: Debugging with <ui:debug>
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 <ui:debug> 调试
- en: 'The `<ui:debug>` tag (`ComponentHandler`) defines a debug component in the
    component tree that is capable of capturing debugging information such as component
    tree, scoped variables, and view state. For example, you can add the `<ui:debug>`
    tag into a template using the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ui:debug>` 标签（`ComponentHandler`）在组件树中定义了一个能够捕获调试信息（如组件树、作用域变量和视图状态）的调试组件。例如，您可以使用以下代码将
    `<ui:debug>` 标签添加到模板中：'
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, when you press *Ctrl* + *Shift* + *Q*, you will see something like the
    following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您按下 *Ctrl* + *Shift* + *Q* 时，您将看到如下截图所示的内容：
- en: '![Debugging with <ui:debug>](img/6466EN_12_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用 <ui:debug> 调试](img/6466EN_12_07.jpg)'
- en: The complete application is named `ch12_9`. The `<ui:debug>` tag was added in
    `layout.xhtml`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_9`。`<ui:debug>`标签添加到了`layout.xhtml`中。
- en: Removing the content with <ui:remove>
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用<ui:remove>移除内容
- en: 'The `<ui:remove>` tag is used for removing the content. This tag is rarely
    used, but a perfect example of this is removing comments of type `<!-- -->`. You
    probably thought of something like the following line:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ui:remove>`标签用于移除内容。这个标签很少使用，但移除类型为`<!-- -->`的注释是一个完美的例子。你可能想到了以下这样的行：'
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It doesn''t have any side effects on the HTML rendered code. Well, that isn''t
    true, because in the HTML source code, you will see something similar to the following
    screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这对渲染的HTML代码没有副作用。嗯，这并不完全正确，因为在HTML源代码中，你会看到类似以下截图的内容：
- en: '![Removing the content with <ui:remove>](img/6466EN_12_08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用<ui:remove>移除内容](img/6466EN_12_08.jpg)'
- en: But if we encapsulate this in `<ui:remove>`, then the preceding client side
    effect will not be produced anymore, which has the following code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们用`<ui:remove>`将其封装起来，那么前面的客户端效果将不再产生，以下代码就是证明。
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The same effect will have the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将产生相同的效果：
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In order to remove comments from the generated HTML code, you add the `context`
    parameter in `web.xml`, as shown in the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从生成的HTML代码中移除注释，你需要在`web.xml`中添加`context`参数，如下所示：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Alternatively, for backwards compatibility with existing Facelets tag libraries,
    the code is given as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了与现有的Facelets标签库保持向后兼容性，代码如下所示：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The complete application is named `ch12_8`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_8`。
- en: Using the jsfc attribute
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jsfc属性
- en: 'Facelets comes with an attribute named `jsfc`. Its main goal consists in converting
    HTML elements in JSF components (the HTML prototype in the JSF page). For example,
    in the following code, we have an HTML form converted into a JSF form:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Facelets包含一个名为`jsfc`的属性。其主要目标是将HTML元素转换为JSF组件（JSF页面中的HTML原型）。例如，在以下代码中，我们将一个HTML表单转换成了一个JSF表单：
- en: '[PRE59]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This attribute stands for fast prototyping and is easy to use. The following
    is another example—this time the `jsfc` attribute is combined with `<ui:repeat>`
    for generating a `<table>` tag:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性代表快速原型设计，并且易于使用。以下是一个另一个例子——这次`jsfc`属性与`<ui:repeat>`结合用于生成`<table>`标签：
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first example is named `ch12_7` and the second one is named `ch12_25`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子命名为`ch12_7`，第二个例子命名为`ch12_25`。
- en: Extending the PageLayout template
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展PageLayout模板
- en: 'Remember the `PageLayout` template developed at the beginning of this chapter?
    Well, that is a decent template, but let''s extend it so it becomes a bit more
    realistic. Usually, a web template contains the sections title, login, search,
    logo, header, menu, left, center, right, and footer over and above the five sections
    that we have used. It would also be nice to have a template that allows us to
    do the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记得本章开头开发的`PageLayout`模板吗？嗯，这是一个不错的模板，但让我们扩展它，使其更加现实。通常，一个网页模板除了我们使用的五个部分之外，还包含标题、登录、搜索、标志、页眉、菜单、左侧、中间、右侧和页脚。也很有必要有一个模板，允许我们做以下事情：
- en: Remove sections without side effects and without manually removing orphan CSS
    code (usually, you can remove a section by writing an empty `<ui:define>` tag,
    but this will not remove the corresponding CSS code for that section). Moreover,
    an empty `<ui:define>` tag will still have a side effect of type the empty `<div>`
    tag or the empty `<span>` or `<td>` tag. This happens because, usually, `<ui:define>`
    is wrapped in a `<div>`, `<span>`, or `<td>` tag.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无副作用且无需手动移除孤儿CSS代码地移除部分（通常，你可以通过编写一个空的`<ui:define>`标签来移除一个部分，但这不会移除该部分的相应CSS代码）。此外，一个空的`<ui:define>`标签仍然会有副作用，即产生空的`<div>`标签或空的`<span>`或`<td>`标签。这是因为，通常`<ui:define>`被包裹在一个`<div>`、`<span>`或`<td>`标签中。
- en: Set the width of the template, that is, the left and right panels without altering
    CSS. These are common adjustments; therefore we can expose them via `<ui:param>`
    and spear the page author to scroll through CSS files.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置模板的宽度，即左侧和右侧面板，而不改变CSS。这些是常见的调整；因此，我们可以通过`<ui:param>`暴露它们，并允许页面作者在CSS文件中滚动。
- en: Add a menu section. We can provide support for adding it via `<ui:include>`
    as a separate file or having a convention mechanism that allows the page author
    to add it much easily.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个菜单部分。我们可以通过`<ui:include>`作为一个单独的文件来提供支持，或者有一个约定机制，允许页面作者更容易地添加它。
- en: 'At the end, the template will look like the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模板将看起来像以下截图：
- en: '![Extending the PageLayout template](img/6466EN_12_09.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![扩展PageLayout模板](img/6466EN_12_09.jpg)'
- en: 'There is no secret that most websites place the content in multiple columns,
    which are created using the `<div>` or `<table>` elements. Afterwards, these elements
    are positioned in the page using CSS. Basically, this is the main idea behind
    most templates, and this one is no exception. In the following diagram, you can
    see the layout of our template, which is based on the `<div>` elements (in the
    diagram, you can see each `<div>` ID):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 没有秘密，大多数网站都是将内容放置在多个列中，这些列是通过`<div>`或`<table>`元素创建的。之后，使用CSS将这些元素定位在页面上。基本上，这是大多数模板背后的主要思想，这个也不例外。在下面的图中，你可以看到我们的模板布局，它基于`<div>`元素（在图中，你可以看到每个`<div>`的ID）：
- en: '![Extending the PageLayout template](img/6466EN_12_10.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![扩展PageLayout模板](img/6466EN_12_10.jpg)'
- en: 'Well, since each section is wrapped in a `<div>` element, we can easily remove
    it using the `<ui:fragment>` tag and its `rendered` attribute. We can wrap each
    section in a `<ui:fragment>` tag and remove it by setting the value of the `rendered`
    attribute to `false` via a `<ui:param>` tag. This will remove the section without
    any side effects. When a section is removed, we need to skip loading the corresponding
    CSS code. For this, we can split the CSS files into the following three categories:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，由于每个部分都被包裹在一个`<div>`元素中，我们可以轻松地使用`<ui:fragment>`标签及其`rendered`属性来删除它。我们可以将每个部分包裹在一个`<ui:fragment>`标签中，并通过`<ui:param>`标签设置`rendered`属性的值为`false`来删除它。这将删除部分而不会产生任何副作用。当删除部分时，我们需要跳过加载相应的CSS代码。为此，我们可以将CSS文件分为以下三类：
- en: A CSS file that holds general styles for templates (usually this is a small
    file)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含模板通用样式的CSS文件（通常这是一个小文件）
- en: A CSS file that holds styles for positioning each section on a page (usually
    this is a small file)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含为页面上的每个部分定位样式的CSS文件（通常这是一个小文件）
- en: A CSS file per section, which holds styles specific to each section (these can
    be pretty large files)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部分的CSS文件，包含针对每个部分特定的样式（这些文件可能相当大）
- en: Having this structure, we can easily decide not to load the CSS code for the
    sections that have been removed. This can be accomplished in the `<h:outputStylesheet>`
    tag with a simple condition based on the same parameters passed for removing the
    sections. When a section is removed, we load an empty CSS file named `dummy.css`
    for it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样的结构，我们可以轻松地决定不加载已删除部分的CSS代码。这可以通过`<h:outputStylesheet>`标签中的简单条件实现，该条件基于用于删除部分的相同参数。当删除部分时，我们为它加载一个名为`dummy.css`的空CSS文件。
- en: 'So, the template file (`layout.xhtml`) may be changed to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模板文件（`layout.xhtml`）可能需要更改为以下内容：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'So, in the template client, we can easily remove a section (for example, the
    title section), using the following line of code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在模板客户端中，我们可以轻松地删除一个部分（例如，标题部分），使用以下代码行：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At this moment, in the template client, we can easily use `<ui:define>` to
    provide our content to the template, and `<ui:param>` for the following settings:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时刻，在模板客户端中，我们可以轻松地使用`<ui:define>`来提供我们的内容给模板，以及使用`<ui:param>`进行以下设置：
- en: 'Remove the title section: This sets the `title` parameter to `false`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除标题部分：这会将`title`参数设置为`false`
- en: 'Remove the login and search sections: This sets the `loginsearch` parameter
    to `false`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除登录和搜索部分：这会将`loginsearch`参数设置为`false`
- en: 'Remove only login section: This sets the `login` parameter to `false`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅删除登录部分：这会将`login`参数设置为`false`
- en: 'Remove only search section: This sets the `search` parameter to `false`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅删除搜索部分：这会将`search`参数设置为`false`
- en: 'Remove the logo section: This sets the `logo` parameter to `false`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除标志部分：这会将`logo`参数设置为`false`
- en: 'Remove the top section: This sets the `top` parameter to `false`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除顶部部分：这会将`top`参数设置为`false`
- en: 'Remove the menu section: This sets the `menu` parameter to `false`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除菜单部分：这会将`menu`参数设置为`false`
- en: 'Remove the left section: This sets the `left` parameter to `false`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除左侧部分：这会将`left`参数设置为`false`
- en: 'Remove the right section: This sets the `right` parameter to `false`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除右侧部分：这会将`right`参数设置为`false`
- en: 'Remove the bottom section: This sets the `bottom` parameter to `false`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除底部部分：这会将`bottom`参数设置为`false`
- en: 'Set template fixed width: This sets the `wrapperWidth` parameter to *widthpx*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置模板固定宽度：这会将`wrapperWidth`参数设置为*宽度px*
- en: 'Set left panel fixed width: This sets the `leftWidth` parameter to *widthpx*
    (default 150px)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置左侧面板固定宽度：这会将`leftWidth`参数设置为*宽度px*（默认150px）
- en: 'Set right fixed width: This sets the `rightWidth` parameter to *widthpx* (default
    150px)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置右侧固定宽度：这会将`rightWidth`参数设置为*宽度px*（默认150px）
- en: 'Now, let''s focus on adding a menu. The template user can define a menu in
    a separate file, as long as it respects the following simple convention of writing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于添加菜单。模板用户可以在一个单独的文件中定义菜单，只要它遵循以下简单的编写约定：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This file can be included as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件可以如下包含：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Another approach consists of passing menu items via `<ui:param>` using the
    following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过`<ui:param>`传递菜单项，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This will work because the `menuDefault.xhtml` page provides a default implementation
    that looks like the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将起作用，因为`menuDefault.xhtml`页面提供了一个默认实现，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The complete application is named `ch12_18`. In the application `ch12_19`,
    you can see a usage example of this template, which looks similar to the following
    screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_18`。在应用程序`ch12_19`中，你可以看到这个模板的使用示例，它看起来类似于以下截图：
- en: '![Extending the PageLayout template](img/6466EN_12_11.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![扩展PageLayout模板](img/6466EN_12_11.jpg)'
- en: Notice that we have dropped the search and right panel sections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经删除了搜索和右侧面板部分。
- en: Facelets' programmatic aspects
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facelets的程序化方面
- en: In the second part of this chapter, we will focus more on several programmatic
    aspects of Facelets. We will start with a new feature of JSF 2.2 regarding `FaceletFactory`,
    which produces Facelets relative to the context of the underlying implementation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章的第二部分，我们将更关注Facelets的几个程序化方面。我们将从JSF 2.2关于`FaceletFactory`的新特性开始，它产生与底层实现上下文相关的Facelets。 '
- en: FaceletFactory considerations
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FaceletFactory的考虑
- en: 'In JSF 2.0, the `FaceletFactory` class was not accessible via the standard
    API for accessing factories, `FactoryFinder`. This means that something like the
    following line was not working:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.0中，`FaceletFactory`类不能通过访问工厂的标准API`FactoryFinder`访问。这意味着以下这样的行不起作用：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: But starting with JSF 2.2, the preceding snippet of code should work. At least
    this is what the list of JSF 2.2 features said. Unfortunately, it doesn't work
    because the specification doesn't contain a class named `javax.faces.view.facelets.FaceletFactory`.
    In Mojarra 2.2.6 implementation, the `FaceletFactory` class doesn't even exist;
    there is a public class named `com.sun.faces.facelets.impl.DefaultFaceletFactory`.
    On the other hand, in MyFaces 2.2.2, we have the abstract class, `org.apache.myfaces.view.facelets.FaceletFactory`.
    So, keep these aspects in mind when you decide to use, decorate, or write a new
    `FaceletFactory` class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但从JSF 2.2开始，前面的代码片段应该可以工作。至少这是JSF 2.2特性列表所说的。不幸的是，它不起作用，因为规范中没有名为`javax.faces.view.facelets.FaceletFactory`的类。在Mojarra
    2.2.6实现中，`FaceletFactory`类甚至不存在；有一个名为`com.sun.faces.facelets.impl.DefaultFaceletFactory`的公开类。另一方面，在MyFaces
    2.2.2中，我们有抽象类`org.apache.myfaces.view.facelets.FaceletFactory`。所以，当你决定使用、装饰或编写一个新的`FaceletFactory`类时，请记住这些方面。
- en: In the near future, we may have the ability to programmatically create a Facelet
    and call the `apply` method in order to build a component tree.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在不久的将来，我们可能能够通过程序创建一个Facelet并调用`apply`方法来构建组件树。
- en: Working with FaceletCache
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与FaceletCache一起工作
- en: 'Starting with JSF 2.1, Facelets are created and cached via the `FaceletCache`
    API. The cache handles two different kinds of Facelets: **View Facelets** and
    **View Metadata Facelets**. For each type, the `FaceletCache` API provides a method
    that returns/creates a cached instance based on the URL that is passed (`getFacelet`/`getViewMetadataFacelet`)
    and a method capable of determining whether a cached Facelet instance exists for
    the given URL (`isFaceletCached`/`isViewMetadataFaceletCached`).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.1开始，Facelets通过`FaceletCache` API创建和缓存。缓存处理两种不同的Facelets：**视图Facelets**和**视图元数据Facelets**。对于每种类型，`FaceletCache`
    API提供了一个基于传递的URL（`getFacelet`/`getViewMetadataFacelet`）返回/创建缓存实例的方法，以及一个能够确定给定URL是否存在缓存Facelet实例的方法（`isFaceletCached`/`isViewMetadataFaceletCached`）。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**View Metadata Facelets** is a special kind of Facelet that corresponds to
    `ViewDeclarationLanguage.getViewMetadata(javax.faces.context.FacesContext, java.lang.String)`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图元数据Facelets**是一种特殊的Facelet，对应于`ViewDeclarationLanguage.getViewMetadata(javax.faces.context.FacesContext,
    java.lang.String)`。'
- en: Facelets instances are created in the `getFacelet`/`getViewMetadataFacelet`
    method using the public static interface, `FaceletCache.MemberFactory`; this interface
    is responsible for the creation of Facelet or View Metadata Facelet instances
    using a method named `newInstance(URL key)`. The `getFacelet` method has access
    to `FaceletCache.MemberFactory` via the protected method, `getMemberFactory`.
    The `getViewMetadataFacelet` method has access to the same interface via the protected
    method, `getMetadataMemberFactory`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Facelets实例是在`getFacelet`/`getViewMetadataFacelet`方法中使用公共静态接口`FaceletCache.MemberFactory`创建的；该接口负责使用名为`newInstance(URL
    key)`的方法创建Facelet或视图元数据Facelet实例。`getFacelet`方法通过受保护的方法`getMemberFactory`访问`FaceletCache.MemberFactory`。`getViewMetadataFacelet`方法通过受保护的方法`getMetadataMemberFactory`访问相同的接口。
- en: 'The `FaceletCache` API''s instances are obtained from `FaceletCacheFactory`.
    This is a factory class that provides two methods: `getFaceletCache` and `getWrapped`.
    The first one returns a `FaceletCache` instance, the latter one returns an instance
    of the class being wrapped.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`FaceletCache` API的实例是从`FaceletCacheFactory`获得的。这是一个工厂类，它提供了两个方法：`getFaceletCache`和`getWrapped`。第一个返回一个`FaceletCache`实例，后者返回被包装的类的实例。'
- en: 'In order to return a custom `FaceletCache` instance, we can start with a custom
    implementation of `FaceletCacheFactory`, as shown in the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回一个自定义的`FaceletCache`实例，我们可以从以下代码所示的自定义`FaceletCacheFactory`实现开始：
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This factory has to be configured in `faces-config.xml` using the following
    code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此工厂必须使用以下代码在`faces-config.xml`中进行配置：
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, our `CustomFaceletCache` class will override the `getFacelet` and `getViewMetadataFacelet`
    methods for disabling the cache mechanism; our implementation will not cache Facelets.
    The code of the `CustomFaceletCache` class is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`CustomFaceletCache`类将覆盖`getFacelet`和`getViewMetadataFacelet`方法以禁用缓存机制；我们的实现将不会缓存Facelets。`CustomFaceletCache`类的代码如下：
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The complete application is named `ch12_15`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_15`。
- en: 'In order to update the cache, JSF performs periodic checks of Facelets views
    changes. In the development stage, you may need to perform this check much often
    than in production. For this, you can set the `javax.faces.FACELETS_REFRESH_PERIOD`
    context parameter as shown in the following example (the value represents the
    number of seconds between two consecutive checks):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新缓存，JSF定期检查Facelets视图的变化。在开发阶段，你可能需要比在生产环境中更频繁地执行此检查。为此，你可以设置`javax.faces.FACELETS_REFRESH_PERIOD`上下文参数，如下面的示例所示（值表示两次连续检查之间的秒数）：
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Alternatively, for backwards compatibility with existing Facelets tag libraries,
    the following is the code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了与现有的Facelets标签库保持向后兼容性，以下代码如下：
- en: '[PRE72]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you want to disable these checks, then set the `javax.faces.FACELETS_REFRESH_PERIOD`
    (or `facelets.REFRESH_PERIOD`) parameter to `-1`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要禁用这些检查，则将`javax.faces.FACELETS_REFRESH_PERIOD`（或`facelets.REFRESH_PERIOD`）参数设置为`-1`。
- en: ResourceResolver swallowed by ResourceHandler
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被ResourceHandler吞没的ResourceResolver
- en: JSF 2.0 promotes the `ResourceResolver` class as the custom approach for loading
    Facelets views from other locations beside the application web root (like a hook
    that allows us to alter the way that the Facelets loads template files). Custom
    locations represent any location for which we can write a URL.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0将`ResourceResolver`类推广为从应用程序Web根目录以外的其他位置（如允许我们改变Facelets加载模板文件方式的钩子）加载Facelets视图的自定义方法。自定义位置代表我们可以编写URL的任何位置。
- en: 'For example, let''s suppose that the Facelets views of our `PageLayout` template
    are stored on the local machine, in the `facelets` folder in `D:`. A custom `ResourceResolver`
    class can load the Facelets views from this location—just override the `resolveUrl`
    method, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的`PageLayout`模板的Facelets视图存储在本地机器上，在`D:`的`facelets`文件夹中。一个自定义的`ResourceResolver`类可以从此位置加载Facelets视图——只需覆盖`resolveUrl`方法，如下面的代码所示：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'A custom `ResourceResolver` class is recognized by JSF if we configure it properly
    in the `web.xml` file, as shown in the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`web.xml`文件中正确配置，JSF将识别自定义的`ResourceResolver`类，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'However, starting with JSF 2.2, we can skip this configuration and use the
    `@FaceletsResourceResolver` annotation as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从JSF 2.2开始，我们可以跳过此配置并使用`@FaceletsResourceResolver`注解，如下所示：
- en: '[PRE75]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The complete application using the `web.xml` configuration is named `ch12_2`.
    The same application, using the `@FaceletsResourceResolver` annotation, is named
    `ch12_5`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`web.xml`配置的完整应用程序命名为`ch12_2`。使用`@FaceletsResourceResolver`注解的相同应用程序命名为`ch12_5`。
- en: 'On the other hand, the `ResourceHandler` class is recommended to be used for
    serving different kinds of resources to the client, such as CSS, JS, and images;
    see the *Configuring resource handlers* section in [Chapter 5](ch05.html "Chapter 5. JSF
    Configurations Using XML Files and Annotations – Part 2"), *JSF Configurations
    Using XML Files and Annotations – Part 2*. By default, the preferred location
    of `ResourceHandler` is the `/resources` folder (or `META-INF/resources` on the
    `CLASSPATH`). A custom `ResourceHandler` class is recognized by JSF if we configure
    it properly in the `faces-config.xml file`, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，建议使用`ResourceHandler`类向客户端提供不同类型的资源，例如CSS、JS和图像；请参阅[第5章](ch05.html "第5章。使用XML文件和注解配置JSF
    – 第2部分")中的*配置资源处理器*部分，*使用XML文件和注解配置JSF – 第2部分*。默认情况下，`ResourceHandler`的首选位置是`/resources`文件夹（或在`CLASSPATH`上的`META-INF/resources`）。如果我们正确地在`faces-config.xml`文件中配置它，JSF就能识别自定义的`ResourceHandler`类，如下所示：
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Since this was a pretty awkward approach, JSF 2.2 unifies these classes into
    a single one. More exactly, the functionality of the `ResourceResolver` class
    has been merged into the `ResourceHandler` class, and the `ResourceResolver` class
    itself has been deprecated. The main result of this action was a new method in
    `ResourceHandler` named `createViewResource`. The purpose of this method is to
    replace the `resolveUrl` method. So, instead of loading Facelets views from custom
    locations via `ResourceResolver`, we can use a custom `ResourceHandler` class
    and a `createViewResource` method, as shown in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相当尴尬的方法，JSF 2.2将这些类统一为一个。更确切地说，`ResourceResolver`类的功能已被合并到`ResourceHandler`类中，并且`ResourceResolver`类本身已被弃用。这一行动的主要结果是`ResourceHandler`类中新增了一个名为`createViewResource`的方法。这个方法的目的就是替换`resolveUrl`方法。因此，我们不再通过`ResourceResolver`从自定义位置加载Facelets视图，而是可以使用自定义的`ResourceHandler`类和`createViewResource`方法，如下面的代码所示：
- en: '[PRE77]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When the `ResourceResolver` class was deprecated, the existing type `javax.faces.application.Resource`
    class has been given a base class named `javax.faces.application.ViewResource`.
    This class contains a single method named `getURL`. So, when a Facelets view should
    be loaded from a custom location, we tell JSF to use our `CustomViewResource`
    class as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ResourceResolver`类被弃用时，现有的类型`javax.faces.application.Resource`类已被赋予一个名为`javax.faces.application.ViewResource`的基类。这个类包含一个名为`getURL`的单个方法。因此，当需要从自定义位置加载Facelets视图时，我们告诉JSF使用我们的`CustomViewResource`类，如下所示：
- en: '[PRE78]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `createViewResource` method provides several advantages, because it *is
    applicable to general view resources and by default is functional equivalent to
    the existing* `createResource` *method. Besides being much more consistent, this
    means it's now also possible to load Facelets from a JAR file without needing
    to provide a custom resolver*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`createViewResource`方法提供了几个优点，因为它*适用于通用视图资源，并且默认情况下与现有的* `createResource` *方法功能等效*。除了更加一致之外，这意味着现在也可以从JAR文件中加载Facelets，而无需提供自定义解析器*。'
- en: The complete application is named `ch12_3`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_3`。
- en: 'For backward compatibility, JSF will let the default resolver to call the new
    `createViewResource` method as shown in the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持向后兼容性，JSF将允许默认解析器调用新的`createViewResource`方法，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The complete application is named `ch12_4`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_4`。
- en: Include Facelets programmatically
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化地包含Facelets
- en: 'You already know how to include Facelets using the `<ui:include>` tag. But,
    sometimes you may need to programmatically reproduce something like the following
    code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何使用`<ui:include>`标签包含Facelets。但有时你可能需要程序化地重现如下代码：
- en: '[PRE80]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Programmatically speaking, the same thing can be accomplished if you know:
    how to obtain access to `FaceletContext`, how to use the `FaceletContext.includeFacelet`
    method, and how to set attributes using `FaceletContext.setAttribute`. For example,
    the programmatic version of the preceding snippet of code is:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度讲，如果你知道如何获取对`FaceletContext`的访问权限，如何使用`FaceletContext.includeFacelet`方法，以及如何使用`FaceletContext.setAttribute`设置属性，同样可以达到相同的效果。例如，上述代码片段的编程版本如下：
- en: '[PRE81]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The complete application is named `ch12_22`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch12_22`。
- en: Creating a TagHandler class
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建TagHandler类
- en: You already know that several Facelets tags are tag handlers, while the others
    are component handlers—in [Chapter 10](ch10.html "Chapter 10. JSF Custom Components"),
    *JSF Custom Components*, you saw how to write a `ComponentHandler` class for a
    custom component. In this section, you will see how to write a `TagHandler` class.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道几个Facelets标签是标签处理器，而其他的是组件处理器——在[第10章](ch10.html "第10章。JSF自定义组件")中，您看到了如何为自定义组件编写`ComponentHandler`类。在本节中，您将了解如何编写`TagHandler`类。
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tag handlers are efficient only when the view tree is built.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 标签处理器只有在视图树构建时才有效。
- en: 'In order to write a `TagHandler` class, you need to perform the following steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写`TagHandler`类，您需要执行以下步骤：
- en: Extend the `TagHandler` class and override the `apply` method; this method process
    changes on a particular `UIComponent` class. Access the tag attributes via the
    `getAttribute` and `getRequiredAttribute` methods, which returns a `TagAttribute`
    instance that exposes the attribute value, namespace, local name, tag (the latter
    is new in JSF 2.2, see the `getTag`/`setTag` documentation), and so on. Moreover,
    use the `tag` and `tagId` fields to refer to the `Tag` instance corresponding
    to this `TagHandler` instance. Delegate control to the next tag handler using
    the `nextHandler` field.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`TagHandler`类并重写`apply`方法；此方法处理特定`UIComponent`类上的更改。通过`getAttribute`和`getRequiredAttribute`方法访问标签属性，这些方法返回一个`TagAttribute`实例，该实例公开属性值、命名空间、本地名称、标签（后者是JSF
    2.2中的新功能，请参阅`getTag`/`setTag`文档），等等。此外，使用`tag`和`tagId`字段来引用与该`TagHandler`实例对应的`Tag`实例。使用`nextHandler`字段将控制权委托给下一个标签处理器。
- en: Write a `*taglib.xml` file to configure the tag namespace, name, and handler
    class.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`*taglib.xml`文件以配置标签命名空间、名称和处理程序类。
- en: Indicate the location of the `*taglib.xml` file using the `javax.faces.FACELETS_LIBRARIES`
    context parameter in the `web.xml` file.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`web.xml`文件中的`javax.faces.FACELETS_LIBRARIES`上下文参数来指示`*taglib.xml`文件的位置。
- en: 'For example, let''s suppose that we need the following functionality: we provide
    a piece of text, the number of times it should be displayed, and the possibility
    to be displayed in uppercase. We may think of a tag as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要以下功能：我们提供一个文本片段，指定它应该显示的次数，以及是否可以大写显示。我们可能会将标签考虑如下：
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A `TagHandler` class can be the response to our need. First, we extend the
    `TagHandler` class, as shown in the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`TagHandler`类可以满足我们的需求。首先，我们扩展`TagHandler`类，如下面的代码所示：'
- en: '[PRE83]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Furthermore, you need to write the `*taglib.xml` file and configure it in the
    `web.xml` file. The complete application is named `ch12_17`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要编写`*taglib.xml`文件并在`web.xml`文件中配置它。完整的应用程序命名为`ch12_17`。
- en: Writing custom Facelets taglib functions
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义Facelets标签库函数
- en: 'When you need a value to be evaluated directly in EL, then Facelets taglib
    functions (or expression functions) are a great solution. For example, let''s
    say that we want to encrypt/decrypt text and the result to be placed directly
    into an EL expression. In order to do this, you need to perform the following
    general steps of writing a function:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要直接在EL中评估值时，Facelets标签库函数（或表达式函数）是一个很好的解决方案。例如，假设我们想要加密/解密文本，并将结果直接放入EL表达式中。为了做到这一点，您需要执行以下一般步骤来编写函数：
- en: Write a Java `public final` class.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`public final` Java类。
- en: In this class, implement the desired functionality using `public static` methods.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，使用`public static`方法实现所需的功能。
- en: Write a `*taglib.xml` file for linking the `public static` methods (functions)
    with JSF pages. For each `static` method, you need to specify the name (`<function-name>`),
    the fully qualified class name that contains the `static` method (`<function-class>`),
    and the declaration of the `static` method (`<function-signature>`).
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`*taglib.xml`文件以将`public static`方法（函数）与JSF页面链接。对于每个`static`方法，您需要指定名称（`<function-name>`）、包含`static`方法的完全限定类名（`<function-class>`）以及`static`方法的声明（`<function-signature>`）。
- en: Indicate the location of the `*taglib.xml` file using the `javax.faces.FACELETS_LIBRARIES`
    context parameter in the `web.xml` file.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`web.xml`文件中的`javax.faces.FACELETS_LIBRARIES`上下文参数来指示`*taglib.xml`文件的位置。
- en: 'So, based on these steps, we can write a class that contains two functions,
    one for encryption and one for decryption, as shown in the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于这些步骤，我们可以编写一个包含两个函数的类，一个用于加密，一个用于解密，如下面的代码所示：
- en: '[PRE84]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `*taglib.xml` file is straightforward as can be seen in the following snippet:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`*taglib.xml`文件非常简单，如下面的代码片段所示：'
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'After you configure the preceding `*taglib.xml` file in `web.xml`, you can
    try to call the encrypt/decrypt functions, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在你配置了 `web.xml` 中的前面 `*taglib.xml` 文件后，你可以尝试调用加密/解密函数，如下所示：
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The complete application is named `ch12_16`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch12_16`。
- en: Facelets pitfalls
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facelets 陷阱
- en: 'It is a well-known fact that JSF pitfalls are not easy to understand and fix.
    This is mostly because their roots originate in: JSF life cycle, bad practices
    of using listeners and events, misunderstandings regarding EL processing and evaluation,
    conflicting combinations of tag handlers with components, and so on.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个众所周知的事实，JSF 陷阱不易理解和修复。这主要是因为它们的根源在于：JSF 生命周期、监听器和事件的使用不良习惯、对 EL 处理和评估的误解、标签处理器与组件的冲突组合等等。
- en: In this section, we will focus on three common Facelets pitfalls.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注三个常见的 Facelets 陷阱。
- en: AJAX and <ui:repeat>
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX 和 `<ui:repeat>`
- en: 'There is a common scenario to use AJAX for re-rendering the content of an `<ui:repeat>`
    tag. It is absolutely intuitive to write something like the following code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AJAX 重新渲染 `<ui:repeat>` 标签的内容是一个常见的场景。编写如下代码是完全直观的：
- en: '[PRE87]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: So, initially, there is a list of *n* players and when we click on the button
    labeled **Half It**, we want to remove half of the players and re-render the list.
    The problem is that the preceding snippet of code will not work as expected, because
    the `<ui:repeat>` tag doesn't render HTML code; therefore, there will be no HTML
    element with the ID, `playersId`. Instead of seeing a list with only five players,
    we will get a `malformedXML` error.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最初有一个包含 *n* 个玩家的列表，当我们点击标记为 **Half It** 的按钮时，我们希望删除一半的玩家并重新渲染列表。问题是前面的代码片段不会按预期工作，因为
    `<ui:repeat>` 标签不会渲染 HTML 代码；因此，将不会有一个具有 ID `playersId` 的 HTML 元素。而不是看到一个只有五个玩家的列表，我们将得到一个
    `malformedXML` 错误。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This more of a pitfall of using JSF AJAX with components that do not get rendered
    as expected.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这更多的是使用 JSF AJAX 与未按预期渲染的组件时的一个陷阱。
- en: 'A simple workaround will be to enclose the `<ui:repeat>` tag inside a `<div>`
    tag, as shown in the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是将 `<ui:repeat>` 标签包裹在一个 `<div>` 标签内，如下面的代码所示：
- en: '[PRE88]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The complete application is named `ch12_26`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch12_26`。
- en: Exemplifying <c:if> versus <ui:fragment>
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例说明 `<c:if>` 与 `<ui:fragment>` 的区别
- en: 'Another common scenario is to render a table data based on a `<c:if>` condition,
    as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的场景是根据 `<c:if>` 条件渲染表格数据，如下所示：
- en: '[PRE89]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Again, the result will not be as expected. The problem is that `<c:if>` is
    a tag handler; therefore, it is efficiently reflected when the tree is built.
    A perfect workaround will be to replace `<c:if>` with the `<ui:fragment>` tag,
    which is a component handler. The `rendered` attribute of `<ui:fragment>` can
    successfully replace the `<c:if>` test using the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，结果将不会如预期。问题是 `<c:if>` 是一个标签处理器；因此，它在树构建时有效地反映了。一个完美的解决方案是将 `<c:if>` 替换为 `<ui:fragment>`
    标签，这是一个组件处理器。`<ui:fragment>` 的 `rendered` 属性可以用以下代码成功替换 `<c:if>` 测试：
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Alternatively, in an even simpler way, use the `rendered` attribute of `<h:outputText>`;
    this approach is particular to this example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以更简单的方式，使用 `<h:outputText>` 的 `rendered` 属性；这种方法仅适用于此示例：
- en: '[PRE91]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Instead, even cooler, using a lambda expression (EL 3.0), you can write the
    following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，更酷的是，使用 lambda 表达式（EL 3.0），你可以编写以下代码：
- en: '[PRE92]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The complete application is named `ch12_20`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch12_20`。
- en: Exemplifying <c:forEach> versus <ui:repeat>
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例说明 `<c:forEach>` 与 `<ui:repeat>` 的区别
- en: 'Apparently, you may think that the `<ui:repeat>`/`<ui:include>` pair is the
    perfect choice for including a list of Facelets pages using the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可能认为 `<ui:repeat>`/`<ui:include>` 对是使用以下代码包含 Facelets 页面列表的完美选择：
- en: '[PRE93]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Well, the `<ui:include>` tag is a tag handler; therefore it will be available
    when the view is built, while the `<ui:repeat>` tag is a component handler available
    during the rendering process. In other words, when `<ui:include>` needs the `t`
    variable, `<ui:repeat>` is not available. Therefore, `<ui:repeat>` should be replaced
    by a tag handler, as `<c:forEach>`, as shown in the following code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，`<ui:include>` 标签是一个标签处理器；因此，当视图构建时它将可用，而 `<ui:repeat>` 标签是一个在渲染过程中可用的组件处理器。换句话说，当
    `<ui:include>` 需要变量 `t` 时，`<ui:repeat>` 不可用。因此，`<ui:repeat>` 应该被替换为一个标签处理器，例如
    `<c:forEach>`，如下面的代码所示：
- en: '[PRE94]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The complete application is named `ch12_21`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch12_21`。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Facelets is a large subject with many interesting aspects which are pretty hard
    to cover in a few chapters of a book. As you know, there are books entirely dedicated
    to Facelets, but I hope that in the final three chapters I managed to cover a
    decent part of the JSF 2.2 default VDL. Probably, the most used part of Facelets
    is templating; therefore, I have tried to cover some handy techniques for writing
    flexible and cool templates. Of course, besides skills and techniques, writing
    templates is also a test of the imagination. Once we master the Facelets tags
    and choose the right techniques, we are ready to start writing templates. If we
    choose some naming conventions as well, then we can easily share our templates
    with the JSF world, like Mamadou Lamine Ba tried in a Java.Net project at [https://weblogs.java.net/blog/lamineba/archive/2011/10/03/conventional-ui-design-facelets-and-jsf-22](https://weblogs.java.net/blog/lamineba/archive/2011/10/03/conventional-ui-design-facelets-and-jsf-22).
    In addition, if we spice up our template files with some Facelets programmatic
    tricks, then we can really rock the world of JSF templating!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Facelets是一个涵盖众多有趣方面的大型主题，这些方面在书的几章中很难全面覆盖。正如你所知，有专门介绍Facelets的书籍，但我希望在我写的最后三章中，我成功地涵盖了JSF
    2.2默认VDL的大部分内容。可能，Facelets最常用的部分是模板化；因此，我尝试介绍了一些编写灵活且酷炫模板的实用技巧。当然，除了技能和技术，编写模板也是对想象力的考验。一旦我们掌握了Facelets标签并选择了正确的技巧，我们就可以开始编写模板了。如果我们还选择了一些命名约定，那么我们可以轻松地将我们的模板与JSF世界分享，就像Mamadou
    Lamine Ba在[https://weblogs.java.net/blog/lamineba/archive/2011/10/03/conventional-ui-design-facelets-and-jsf-22](https://weblogs.java.net/blog/lamineba/archive/2011/10/03/conventional-ui-design-facelets-and-jsf-22)的Java.Net项目中尝试的那样。此外，如果我们用一些Facelets编程技巧来丰富我们的模板文件，那么我们真的可以在JSF模板的世界中掀起波澜！
