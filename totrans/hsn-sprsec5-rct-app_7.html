<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Spring Security Add-Ons</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we covered the implementation details of the multiple ways in which core security aspects, such as authentication and authorization, use Spring Security. In doing so, we just skimmed over a very thin layer of the capabilities that can be achieved using Spring Security. In this chapter, we will cover some other capabilities provided by Spring Security in a concise manner.</p>
<p>In addition, the chapter introduces many products (open source and paid versions) that can be considered for use along with Spring Security. I am not backing any of these products, but I do consider them strong contenders for achieving the technical capabilities that you are looking for. We will start off introducing a product by giving a gist of the technical capability that we need to address, then introduce you<span> </span><span>briefly</span><span> to the product.</span></p>
<p>In this chapter we will cover the following topics:</p>
<ul>
<li>Remember-me authentication</li>
<li>Session management</li>
<li>CSRF</li>
<li>CSP</li>
<li>Channel security</li>
<li>CORS Support</li>
<li>The Crypto module</li>
<li>Secret management</li>
<li>HTTP Data Integrity Validator</li>
<li>Custom DSL</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Remember-me authentication</h1>
                </header>
            
            <article>
                
<p>We will be reusing and enhancing the example that we built in <a href="e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml">Chapter 2</a>, <em>Deep Diving into Spring Security</em> (<kbd>jetty-db-basic-authentication</kbd>), to explain how Spring Security can be used to achieve <span>remember me, or persistent login, functionality</span>. In the example that we are going to reuse, we have used basic authentication, in which user credentials are stored in a MySQL database.</p>
<p>Remember me functionality is achieved in Spring Security by sending cookies to the browser when the user chooses to remember his/her credentials on the client side. The cookie can be configured to be stored in the browser for a stipulated time. If the cookie exists and is valid, the next time the user accesses the application, they are taken straight to the user's home page and avoid explicit authentication with a username/password combination.</p>
<p>Remember me functionality can be achieved using two approaches:</p>
<ul>
<li style="font-weight: 400"><strong>Hash-based tokens</strong>: Username, expiry time, password, and a private key are hashed and send to the client as a token</li>
<li style="font-weight: 400"><strong>Persistent tokens</strong>: A persistent storage mechanism is used to store the token on the server</li>
</ul>
<p>We will now go through a simple implementation of the persistent token approach to explain this concept in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new table in MySQL database</h1>
                </header>
            
            <article>
                
<p>We will use the same schema as the MySQL DB that we used in <a href="e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml">Chapter 2</a>, <em>Deep Diving into Spring Security</em>. Keep everything as is, and then create a new table in the MySQL database for storing persistent tokens by executing the following DDL statement in the MySQL workbench:</p>
<pre>create table persistent_logins(<br/>     series varchar(64) not null primary key,   <br/>     username varchar(75) not null,<br/>     token varchar(100) not null,<br/>     last_used timestamp not null<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security configuration</h1>
                </header>
            
            <article>
                
<p>In <a href="e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml">Chapter 2</a>, <em>Deep Diving into Spring Security</em> (in the <span>Spring Security setup sub-section of the </span><span><kbd>Sample</kbd> application section), we saw basic authentication, which we configured in our configure method in the Spring Security Configuration class. In this example, we will create a custom login page and change the login mechanism to form-based. Open the</span> <kbd>SpringSecurityConfig</kbd> <span>class and change the configure method, as shown in the following code snippet. Then, add the <kbd>tokenRepository</kbd> bean that we are going to use to accomplish remember me functionality:</span></p>
<pre>@Override<br/>protected void configure(HttpSecurity http) throws Exception {<br/>  http.csrf().disable();<br/>  http.authorizeRequests().anyRequest().hasAnyRole("ADMIN", "USER")<br/>      .and()<br/>      .authorizeRequests().antMatchers("/login**").permitAll()<br/>      .and()<br/>      .formLogin()<br/>      .loginPage("/login").loginProcessingUrl("/loginProc").permitAll()<br/>      .and()<br/>      .logout().logoutSuccessUrl("/login").permitAll()<br/>      .and()<br/>      .rememberMe()<br/>      .rememberMeParameter("rememberme").tokenRepository(tokenRepository());<br/>}<br/>@Bean<br/>public PersistentTokenRepository tokenRepository() {<br/>  JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl=new JdbcTokenRepositoryImpl();<br/>  jdbcTokenRepositoryImpl.setDataSource(dataSource);<br/>  return jdbcTokenRepositoryImpl;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The custom login page</h1>
                </header>
            
            <article>
                
<p>Create a new page, namely <kbd>login.jsp</kbd> in the <kbd>src/main/webapp/WEB-INF/view</kbd> folder. The main section of the page, containing the <kbd>username</kbd>, <kbd>password</kbd>, and <kbd>rememberme</kbd> fields, is as shown in the following code snippet:</p>
<pre>&lt;form action='&lt;spring:url value="/loginProc"/&gt;' method="post"&gt;<br/>  &lt;table&gt;<br/>      &lt;tr&gt;<br/>          &lt;td&gt;Username&lt;/td&gt;<br/>          &lt;td&gt;&lt;input type="text" name="username"&gt;&lt;/td&gt;<br/>      &lt;/tr&gt;<br/>      &lt;tr&gt;<br/>          &lt;td&gt;Password&lt;/td&gt;<br/>          &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;<br/>      &lt;/tr&gt;<br/>      &lt;tr&gt;<br/>          &lt;td&gt;&lt;input type="checkbox" name="rememberme"&gt;&lt;/td&gt;<br/>          &lt;td&gt;Remember me&lt;/td&gt;<br/>      &lt;/tr&gt;<br/>      &lt;tr&gt;<br/>          &lt;td&gt;&lt;button type="submit"&gt;Login&lt;/button&gt;&lt;/td&gt;<br/>      &lt;/tr&gt;<br/>  &lt;/table&gt;<br/>&lt;/form&gt;</pre>
<p>Make sure that you name the remember me checkbox the same as you specified in the Spring Security configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application and testing</h1>
                </header>
            
            <article>
                
<p>Run the project by executing the following command:</p>
<pre><strong>mvn jetty:run</strong></pre>
<p>Wait for the console to print <span class="packt_screen">[INFO] Started Jetty Server</span>.</p>
<p>Open a browser (I use Firefox in private mode for testing) and navigate to <kbd>http://localhost:8080</kbd>, and you will be shown the custom login page that you created, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/08fa314d-719a-44ba-935e-2b5ec788d304.png" style="width:21.83em;height:17.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1: The custom login page</div>
<p>Enter <kbd>user</kbd>/<kbd>user@password</kbd> as the username and password. Click on <kbd>Remember me</kbd> and click the <kbd>Login</kbd> button, and you will be navigated to the user home page, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb50890a-9b60-47b6-b8f9-e6b253f303bf.png" style="width:21.00em;height:10.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2: User home page</div>
<p>Query your MySQL database for the <kbd>persistent_logins</kbd> table, and you will see a new record, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/973617d1-af29-4ebf-999a-eee1c92e9ea9.png" style="width:52.33em;height:14.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3: MySQLWorkbench querying new persistent_logins table</div>
<p>Now, go to the developer tools in your browser and check for cookies. Depending on the browser that you are using, you should see something similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a4f15410-f35e-481e-8f6b-21f82a4ef7af.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 4: Browser cookie set to achieve remember-me functionality</div>
<p>The entire project for this example can be found at the book’s GitHub page in the <kbd>jetty-db-basic-authentication-remember-me</kbd><span> </span><span>project</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Session management</h1>
                </header>
            
            <article>
                
<p>Spring Security allows you to manage sessions on your server with only some configuration. Some of the most important session management activities are listed here:</p>
<ul>
<li style="font-weight: 400"><strong>Session creation</strong>: This decides when a session needs to be created and the ways in which you can interact with it. In the Spring Security configuration, put in the following code:</li>
</ul>
<pre style="padding-left: 60px">http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS);</pre>
<p style="padding-left: 60px">There are four session creation policies that you can choose from. They are as follows:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li style="font-weight: 400"><kbd>ALWAYS</kbd>: Always create a session if it doesn't exist.</li>
<li style="font-weight: 400"><kbd>IF_REQUIRED</kbd>: If required, a session is created.</li>
<li style="font-weight: 400"><kbd>NEVER</kbd>: This will never create a session; rather, it will use the session if it exists.</li>
<li style="font-weight: 400"><kbd>STATELESS</kbd>: No session will be created nor used.</li>
<li style="font-weight: 400"><kbd>invalidSession</kbd>: This controls how the user is intimated if the server sees an invalid session:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px">http.sessionManagement().invalidSessionUrl("/invalidSession");</pre>
<ul>
<li style="font-weight: 400"><strong>Session timeout</strong>: This controls how the user is intimated if the session has expired.</li>
<li style="font-weight: 400"><strong>Concurrent session</strong>: This allows control over how many sessions a user can start in an application. If the maximum sessions is set as <kbd>1</kbd>, when the user logs in for the second time, the previous session is invalidated and the user is logged out. If the value specified is greater than <kbd>1</kbd>, the user is allowed to have that many sessions concurrently:</li>
</ul>
<pre style="padding-left: 60px">http.sessionManagement().maximumSessions(1);</pre>
<p style="padding-left: 60px">The following screenshot shows the default error screen, that pops up when more than the desired amount of sessions (as configured) are created by the same user:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a56b4b3d-0c1a-4b4f-8212-066588d543ae.png" style="width:31.33em;height:9.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5: Error thrown when a user accesses multiple sessions</div>
<ul>
<li style="font-weight: 400"><strong>Session fixation</strong>: This is very similar to concurrent session control. This setting allows us to control what will happen when a new session is initiated by a user. We can specify the following three values:</li>
<li style="padding-left: 60px"><kbd>migrateSession</kbd>: On the creation of a new session after successful authentication, the old session is invalidated and all attributes are copied to the new session:</li>
</ul>
<pre style="padding-left: 120px">http.sessionManagement().sessionFixation().migrateSession();</pre>
<ul>
<li style="padding-left: 60px"><kbd>newSession</kbd>: A new session is created without copying any of the attributes from the previous valid session:</li>
</ul>
<pre style="padding-left: 120px">http.sessionManagement().sessionFixation().newSession();</pre>
<ul>
<li style="padding-left: 60px"><kbd>none</kbd>: The old session is reused and is not invalidated:</li>
</ul>
<pre style="padding-left: 120px">http.sessionManagement().sessionFixation().none();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CSRF</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Cross-Site Request Forgery</strong> (<strong>CSRF</strong>) (<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a>) is an attack that forces an end user to execute unwanted actions on a web application in which they're currently authenticated. CSRF attacks specifically target state-changing requests, not theft of data, since the attacker has no way to see the response to the forged request.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <strong>Open Web Application Security Project</strong> (<strong>OWASP</strong>) considers CSRF as one of the most common security risks for web applications. OWASP publishes a list (known as the OWASP Top 10) every year, highlighting the top 10 security risks plaguing web applications—it considers CSRF to be in fifth position.</p>
<p>In Spring Security, CSRF is enabled by default. If needs be (we have disabled this in many of our examples so that we are able to concentrate on the main concept that the examples are supposed to convey), we can disable it explicitly by adding the following code snippet in your Spring Security configuration:</p>
<pre>http<br/>  .csrf().disable();</pre>
<p>Even though CSRF is enabled by default, for it to function, each request needs to provide a CSRF token. If a CSRF token is not sent across to the server, the server will reject the request and throw an error. If you are using <strong>Java Server Page</strong> (<strong>JSP</strong>) as your view, just by including hidden input, as shown in the following code snippet, many things would happen auto-magically:</p>
<pre>&lt;input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" /&gt;</pre>
<p>If you are using an AJAX request to call a server, instead of hidden input, you can supply the CSRF token in the form of an HTTP header. You can declare the CSRF-related header as meta tags, as shown in the following code snippet:</p>
<pre>&lt;head&gt;<br/>     &lt;meta name="_csrf" content="${_csrf.token}"/&gt;<br/>     &lt;meta name="_csrf_header" content="${_csrf.headerName}"/&gt;<br/>     &lt;!-- ... --&gt;<br/> &lt;/head&gt;</pre>
<p>After that, while calling the server, include these (<kbd>_csrf</kbd> and <kbd>_csrf_header</kbd>) as headers and you will be allowed to call the required endpoints.</p>
<p>If you would like to persist the CSRF token, Spring Security allows you to do this by tweaking the configuration as shown in the following code snippet:</p>
<pre>http<br/>  .csrf()<br/>  .csrfTokenRepository(new CookieCsrfTokenRepository());</pre>
<p>While doing this, the CSRF token is persisted as a cookie, which can be read by the server and validated (all done auto-magically).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CSP</h1>
                </header>
            
            <article>
                
<p><strong>Content Security Policy</strong> (<strong>CSP</strong>) (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a>) is an added layer of security that helps to detect and mitigate certain types of attacks, including <strong>Cross Site Scripting</strong> (<strong>XSS</strong>) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware.</p>
<p>A proper CSP setup in your application can handle content injection vulnerabilities, and is a great way to reduce XSS. XSS stands at number two in the OWASP Top 10.</p>
<p>A CSP is not a solution to handling all injection vulnerabilities, but can be used as one of the tools to reduce injection attacks to a reasonable level.</p>
<p>CSP is a declarative policy, implemented using HTTP headers. It can be run in an application in two modes:</p>
<ul>
<li style="font-weight: 400">Production mode (declared as CSP)</li>
<li style="font-weight: 400">Report-only mode (used for testing and are declared as <em>Content-Security-Policy-Report-Only</em>)</li>
</ul>
<p>CSP contains a set of security policy directives responsible for putting appropriate restrictions on a web resource and then informing the client (user agent) accordingly when breached. For example, the following security policy snippet loads scripts from the defined trusted domains:</p>
<pre>Content-Security-Policy: script-src https://trusted-domain.com</pre>
<p>If there's a breach, the user agent will block it, and if the policy specifies a <kbd>report-uri</kbd> parameter, as shown in the following example, it will report the violation in the form of JSON to that URI:</p>
<pre>Content-Security-Policy: script-src https://trusted-domain.com; report-uri /csp-report-api/</pre>
<p>The previous examples showcase CSP working in production mode. If you would like to first test the security policy and after a particular period of time make those policies in production mode, CSP provides a mechanism for that, as shown in the following code snippet:</p>
<pre>Content-Security-Policy-Report-Only: script-src https://trusted-domain.com; report-uri /csp-report-api/</pre>
<p>In report-only mode, when a breach is detected, the report is posted to the <kbd>report-uri</kbd> in JSON format, as shown in the following code:</p>
<pre>{"csp-report":<br/>    {"document-uri":"...",<br/>    "violated-directive":"script-src https://trusted-domain.com",<br/>    "original-policy":"...",<br/>    "blocked-uri":"https://untrusted-domain.com"}<br/>}</pre>
<p>Apart from the security directives detailed in the preceding examples, there are a number of security directives that can be used while setting up your CSP. For a full list of directives, please refer to <a href="https://content-security-policy.com/">https://content-security-policy.com/</a>.</p>
<p>In a similar way to CSRF tokens, CSP can also be used to make sure that specific resources contain a token while accessing the server. The following example shows the use of this nonce approach:</p>
<pre>Content-Security-Policy: script-src 'self' 'nonce-&lt;cryptographically generated random string&gt;'</pre>
<p>Similar to a CSRF token, this nonce has to be included along with any resource access in the server, and this has to be newly generated while a page is loaded.</p>
<p>CSP also allows you to load the resources only if they match the hash that the server expects. The following policy is used to achieve this:</p>
<pre>Content-Security-Policy: script-src 'self' 'sha256-&lt;base64 encoded hash&gt;'</pre>
<p>CSP is supported by almost all modern browsers. Even if some security directives are not supported by certain browsers, other supported directives will work without any problem. The best way to handle that is to send only the security directives that will definitely be supported by the browser by deciphering the user agent, rather than throwing errors on the client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CSP using Spring Security</h1>
                </header>
            
            <article>
                
<p>Configuring CSP using Spring Security configuration is a breeze. By default, CSP is not enabled. You can enable it in Spring Security configuration, as shown in the following code snippet:</p>
<pre>http<br/>     .headers()<br/>         .contentSecurityPolicy("script-src 'self' https://trusted-domain.com; report-uri /csp-report-api/");</pre>
<p>The report-only CSP in the Spring Security configuration is as follows:</p>
<pre>http<br/>     .headers()<br/>         .contentSecurityPolicy("script-src 'self' https://trusted-domain.com; report-uri /csp-report-api/")<br/>        .reportOnly();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Channel security</h1>
                </header>
            
            <article>
                
<p>In addition to authentication and authorization, Spring Security can also be used to check for any additional property presence for each request reaching the server. It can check for protocol (transport type, HTTP, or HTTPS), presence of certain HTTP headers, and more. SSL is now the de facto standard for any web application (or website) to comply with, and many search engines (such as Google, for example) even penalize you if your website is not HTTPS. SSL is made use of in securing the channel on which data flows from client to server and vice versa.</p>
<p>Spring Security can be configured to explicitly check for URL patterns and explicitly redirect the user to HTTPS if they are coming with the HTTP protocol.</p>
<p>This can be easily done by configuring the appropriate URL pattern in your Spring Security configuration, as shown here:</p>
<pre>http.authorizeRequests()<br/>      .requiresChannel().antMatchers("/httpsRequired/**").requiresSecure();</pre>
<p>When users access the <kbd>/httpsRequired/**</kbd> URL pattern and if the protocol is HTTP, Spring Security will redirect the user to the same URL with the HTTPS protocol. The following configuration is used to secure all requests:</p>
<pre>http.authorizeRequests()<br/>      .requiresChannel().anyRequest().requiresSecure();</pre>
<p>To explicitly mention certain URLs as insecure, use the following code:</p>
<pre>.requiresChannel().antMatchers("/httpRequired/**").requiresInsecure();</pre>
<p>The following code snippet shows how to specify any request to be HTTP (insecure):</p>
<pre>.requiresChannel().anyRequest().requiresInsecure();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CORS Support</h1>
                </header>
            
            <article>
                
<p><strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>) (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a>) is a mechanism that uses additional HTTP headers to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. A web application makes a cross-origin HTTP request when it requests a resource that has a different origin (domain, protocol, and port) than its own origin.</p>
<p>We won't be creating full-fledged projects in this section to explain the working of CORS. We will use code snippets and will explain each bit of code so that the section is concise.</p>
<p>Change your Spring Security configuration, as shown in the following code snippet:</p>
<pre>@EnableWebSecurity<br/>@Configuration<br/>public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {<br/><br/> @Override<br/> protected void configure(HttpSecurity http) throws Exception {<br/>    http.cors();<br/> }<br/> @Bean<br/> CorsConfigurationSource corsConfigurationSource() {<br/>    UrlBasedCorsConfigurationSource urlCorsConfigSrc = new<br/>          UrlBasedCorsConfigurationSource();<br/>    urlCorsConfigSrc.registerCorsConfiguration("/**", <br/>        new CorsConfiguration().applyPermitDefaultValues());<br/>    return urlCorsConfigSrc;<br/> }<br/>}</pre>
<p>In the preceding code, we configure CORS in the Spring Security <kbd>configure</kbd> method. We then create a new bean, <kbd>corsConfigurationSource</kbd>, in which we enable the <kbd><em>/**</em></kbd> path to be accessible by other domains. This is not really ideal in many scenarios, and the following code snippet shows the more enhanced <kbd>CorsConfiguration</kbd> class:</p>
<pre>CorsConfiguration configuration = new CorsConfiguration();<br/>configuration.setAllowedOrigins(new ArrayList&lt;String&gt;(Arrays.asList("*")));<br/>configuration.setAllowedHeaders(new ArrayList&lt;String&gt;        <br/>    (Arrays.asList("Authorization", "Cache-Control", "Content-Type")));<br/>configuration.setAllowedMethods(new ArrayList&lt;String&gt;(Arrays.asList("HEAD", <br/>    "GET", "POST", "PUT", "DELETE", "PATCH")));<br/>configuration.setAllowCredentials(true);</pre>
<p>If it is a Spring MVC application, you can have a Spring MVC configuration file in which you can specify CORS mapping by creating a bean, as shown here:</p>
<pre>@Configuration<br/>public class SpringMVCConfig {<br/>  @Bean<br/>  public WebMvcConfigurer corsConfigurer() {<br/>    return new WebMvcConfigurer() {<br/>      @Override<br/>      public void addCorsMappings(CorsRegistry registry) {<br/>        registry.addMapping("/**")<br/>          .allowedMethods("HEAD", "GET", "PUT", "POST", "DELETE",<br/>            "PATCH","OPTIONS");<br/>      }<br/>    };<br/>  }<br/>}</pre>
<p>I have copied a previous example from <a href="e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml">Chapter 2</a>, <em>Deep Diving into Spring Security</em>, and created a new project in this chapter, containing full source code in <kbd>spring-boot-in-memory-basic-authentication-with-cors</kbd>. What we have done here is set the CORS global configuration by declaring the <kbd>CorsConfigurationSource</kbd> bean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Crypto module</h1>
                </header>
            
            <article>
                
<p>The Spring Security Crypto module allows you to do password encoding, symmetric encryption, and key generation. The module is bundled as part of the core Spring Security offering with no dependency upon other Spring Security code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Password encoding</h1>
                </header>
            
            <article>
                
<p>Modernized password encoding is one of the new features of Spring Security 5. Spring Security's <kbd>PasswordEncoder</kbd> interface is central to it and does one-way hashing of passwords using various algorithms, which can then be stored securely. Spring Security supports a number of password-encoding algorithms:</p>
<ul>
<li style="font-weight: 400"><kbd>BcryptPasswordEncoder</kbd>: This uses the Bcrypt strong hash function. You can optionally supply the strength parameter (default value is 10); the higher the value, the more work has to be done to hash the password.</li>
<li style="font-weight: 400"><kbd>Pbkdf2PasswordEncoder</kbd>: This uses <strong>Password-Based Key Derivation Function 2</strong> (<strong>PKDF2</strong>) with a configurable number of iterations and an 8-byte random salt value.</li>
<li style="font-weight: 400"><kbd>ScryptPasswordEncoder</kbd>: This uses the Scrypt hashing function. While hashing, clients can supply a CPU cost parameter, a memory cost parameter, and a parallelization parameter. The current implementation uses the Bouncy Castle library.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encryption</h1>
                </header>
            
            <article>
                
<p>Spring Security's <kbd>org.springframework.security.crypto.encrypt.Encryptors</kbd> class has factory methods that can be used to create symmetric encryptors. The class supports two encryptors:</p>
<ul>
<li style="font-weight: 400"><kbd>BytesEncryptor</kbd>: The service interface for symmetric data encryption of data in the form of raw byte arrays.</li>
<li style="font-weight: 400"><kbd>TextEncryptor</kbd>: The service interface for symmetric data encryption of text strings:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a10170e-1db7-4e62-81fe-4c5ed66c830f.png" style="width:44.58em;height:9.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Key generation</h1>
                </header>
            
            <article>
                
<p>As seen in the previous section on encryption, Spring Security has a class, namely <kbd>org.springframework.security.crypto.keygen.KeyGenerators</kbd>, that has a number of factory methods that can used to construct a number of keys needed for your application.</p>
<p>The following are the two supported types of key generator:</p>
<ul>
<li style="font-weight: 400"><kbd>BytesKeyGenerator</kbd>: The generator for generating unique byte array-based keys.</li>
<li style="font-weight: 400"><kbd>StringKeyGenerator</kbd>: The generator for unique string keys:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/50f4bea4-d4a6-447c-be97-1a746f3a7d4e.png" style="width:50.25em;height:9.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 7: The BytesKeyGenerator and StringKeyGenerator factory methods</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Secret management</h1>
                </header>
            
            <article>
                
<p>In an application, we need to handle a variety of secret/secure data in the form of API keys, other application passwords, and more. Often, for an application deployed and running in a production environment, keeping these in plain text can result in security breaches. With automation up for grabs quite cheaply nowadays, for modern applications, storing such data securely with access control and secure storage is a must.</p>
<p>Encryption is something that has been widely embraced, but for decryption, a key needs to be circulated, and this circulation of the key is usually a big problem. If a person decides to take the key outside of the organization, there can be serious problems.</p>
<p>Vault from HashiCorp is a very strong contender as a solution to this issue, and helps in managing these secrets easily with very rigid controls. It provides APIs that give access based on set policies. It also has the capability to provide access control, and it also comes with encryption functionality out of box. In addition, it has a variety of persistent backend supports, such as Consul (from HashiCorp), and more, making it easy for enterprises to adopt it. Vault is written in Go and has binaries available for many platforms, and can be downloaded from its website. In this section, we will quickly run you through the Vault product itself, and then go through an example in which we will create a Spring Boot project and securely access some of the secrets stored in the Vault. Without further ado, let's get our hands dirty with actual code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting by unsealing Vault</h1>
                </header>
            
            <article>
                
<p>Download the latest binary from the Vault project's website (<a href="https://www.vaultproject.io/downloads.html">https://www.vaultproject.io/downloads.html</a>), according to your operating system, and install it. To start Vault, you need to have a file—<kbd>vault.conf</kbd>—in which we will specify some of the options that are needed for Vault to start. Here is a sample <kbd>vault.conf</kbd> file that you can use:</p>
<pre>backend "inmem" {<br/>} <br/>listener "tcp" {<br/>  address = "0.0.0.0:8200"<br/>  tls_disable = 1<br/>}<br/>disable_mlock = true</pre>
<p>In the <kbd>vault.conf</kbd> file, we explicitly set the address that it will listen to and also disable TLS/SSL (so that it runs in plain text mode).</p>
<p>Start Vault by specifying the location of the <kbd>vault.conf</kbd> file with the following command:</p>
<pre><strong>./vault server -config vault.conf</strong></pre>
<p><span>As you can see from the screenshot below, Vault is running in plain text mode (with TLS/SSL disabled):</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8aa8b640-96ed-40d7-bcf8-b5bc1dbc50fa.png" style="width:39.83em;height:13.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 8: Starting and configuring Vault</div>
<p>Open a new command prompt, which is where we will now start administering Vault. Set an environment variable by executing the following command to let the clients know that they have to use plain text to connect to Vault (as we have disabled TLS/SSL):</p>
<pre>export VAULT_ADDR=http://127.0.0.1:8200</pre>
<p>After this, initialize Vault key generation by executing the following command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/49566220-3be6-4426-9f52-7bd0b97fef42.png" style="width:48.83em;height:23.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9: Initializing Vault</div>
<p>The command that we have used gave us five key shares and a key threshold of two. It's important to note that we cannot change these values once Vault is initialized (output is shown only once). Be careful to gather the necessary information; otherwise, you will not be able to retrieve any data stored in Vault. As you can see from the preceding screenshot, the <kbd>init</kbd> command of Vault gives us the keys and token that are needed to unseal Vault. Before we can use Vault, it has to be unsealed.</p>
<p class="mce-root"><strong>Unsealing</strong> (<a href="https://www.vaultproject.io/docs/concepts/seal.html">https://www.vaultproject.io/docs/concepts/seal.html</a>) is the process of constructing the master key necessary to read the decryption key to decrypt the data, allowing access to the Vault. Prior to unsealing, almost no operations are possible with Vault.</p>
<p>You can unseal Vault by executing the following command and providing any of the keys generated during the Vault initialization process:</p>
<pre><strong>./vault unseal &lt;any key generated using initialization&gt;</strong></pre>
<p>The following screenshot shows the successful execution of the preceding command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b1a8f86b-355d-4c7e-8cca-d7bc68756af3.png" style="width:42.67em;height:13.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10: Unsealing Vault</div>
<p>Once it is unsealed, your Vault is now ready to store the secret data that you may want to use in your application.</p>
<p>After you have successfully unsealed Vault, to store any data, you first need to authenticate. When we initialized Vault, we were shown a token (on the screen), and this token is used to authenticate. One of the easiest ways to achieve authentication using this token is to set up a new environment variable (<kbd>VAULT_TOKEN</kbd>). Execute the following command as shown, and when Vault starts, it will make use of this environment variable and authenticate itself:</p>
<pre><strong>export VAULT_TOKEN=ee60f275-7b16-48ea-0e74-dc48b4b3729c</strong></pre>
<p>Once the preceding command is executed, you can now write your secret by executing the following command:</p>
<pre><strong>./vault write secret/movie-application password=randomstring</strong></pre>
<p>After you enter the command, you should receive the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c8663c6c-36f8-4f51-9e57-e5605f5ad26e.png" style="width:60.25em;height:6.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 11: Writing a secret to your Vault</div>
<p>Tokens are the primary way in which authentication is done in Vault. Besides that, there are other mechanisms, such as LDAP and username/password, with which authentication can be done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Spring Boot project</h1>
                </header>
            
            <article>
                
<p>Spring has a dedicated module, called Spring Cloud Vault, that makes use of Vault in your application a breeze. Spring Cloud Vault is very easy to use, and we will be covering how to use it in this section.</p>
<p><strong>Spring Cloud Vault Config</strong> (<a href="http://cloud.spring.io/spring-cloud-vault/">http://cloud.spring.io/spring-cloud-vault/</a>) provides client-side support for externalized configuration in a distributed system. With HashiCorp's Vault you have a central place to manage external secret properties for applications across all environments. Vault can manage static and dynamic secrets such as username/password for remote applications/resources and provide credentials for external services such as MySQL, PostgreSQL, Apache Cassandra, MongoDB, Consul, AWS, and more.</p>
<p>We will be using the Spring Boot project (generated using Spring Initializr, <a href="https://start.spring.io">https://start.spring.io</a>). At the start of the application, Vault is started and all the secrets are picked up:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef82792e-746b-438b-9813-4fb8a1b0ffbc.png" style="width:60.17em;height:39.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 12: Creation of an empty Spring Initializr project</div>
<p>Unzip the downloaded Spring Initializr project by executing the following command:</p>
<pre><strong>unzip -a spring-boot-spring-cloud-vault.zip</strong></pre>
<p>Import the project in your favorite IDE (I am using IntelliJ).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Maven dependency</h1>
                </header>
            
            <article>
                
<p>Make sure that your project's <kbd>pom.xml</kbd> has the following Maven dependency added:</p>
<pre>&lt;dependency&gt;<br/> &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/> &lt;artifactId&gt;spring-cloud-starter-vault-config&lt;/artifactId&gt;<br/> &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>When the Spring Boot project starts, it will pick the default Vault configuration if the Vault server is running on port <kbd>8200</kbd>. If you want to customize these properties, you can specify <kbd>bootstrap.yml</kbd> or <kbd>bootstrap.properties</kbd>. In our example, we will explicitly set the <kbd>bootstrap.yml</kbd> file with the following content:</p>
<pre>spring:<br/>  application:<br/>      name: movie-application<br/>spring.cloud.vault:<br/>  host: localhost # hostname of vault server<br/>  port: 8200  # vault server port<br/>  scheme: http # connection scheme http or https<br/>  uri: http://localhost:8200 # vault endpoint<br/>  connection-timeout: 10000 # connection timeout in milliseconds<br/>  read-timeout: 5000  # read timeout in milliseconds<br/>  config:<br/>      order: -10  # order for property source<br/>  token: ee60f275-7b16-48ea-0e74-dc48b4b3729c<br/>health.vault.enabled: true  # health endpoint enabled using spring actuator</pre>
<p>We will be using the HTTP scheme, as we started Vault in plain text mode. If you would like to use HTTPS, it's quite easy to do so, as most things are done through scripts already provided. This is the default scheme in which Vault runs, and this is how it has to be in the production setup. Let's understand this concept first before going into a bit more depth when you implement the actual use case.</p>
<p class="mce-root"/>
<p>If you would like to run Vault in the HTTPS scheme, Spring Cloud Vault has a number of scripts available in its source code under <kbd>src/test/bash</kbd> (<a href="https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash">https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash</a>) that can be used to create the necessary certificates and then run Vault in this scheme. To keep this section concise, we won't be covering this aspect in much more detail here.</p>
<p>In the <kbd>.yml</kbd> file, we have used the root token that was created as part of the initialization of Vault. If you need to, you can get a new token by executing the following command:</p>
<pre><strong>./vault token create</strong></pre>
<p>The following screenshot shows the successful execution of the <kbd>token create</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82e4a39d-39fb-4181-8952-d676cbe990e4.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 13: New Vault token creation</div>
<p>In your Spring Boot project, add the following code snippet in your application run class, <kbd>SpringBootSpringCloudVaultApplication</kbd>:</p>
<pre>@Value("${password}")<br/>String password;<br/><br/>@PostConstruct<br/>private void postConstruct() {<br/> System.out.println("Secret in Movie application password is: " + password);<br/>}</pre>
<p>In this code, the <kbd>password</kbd> field will be filled by Spring Cloud Vault, and if you run the application (using command <kbd>mvn spring-boot:run</kbd>), you should see that Spring Cloud Vault connects to the running Vault (using the configuration in the <kbd>bootstrap.yml</kbd> file) and retrieves the value that we wrote to Vault for <kbd>movie-application</kbd>.</p>
<p>This concludes our look at a base application using Spring Boot and Spring Cloud Vault. You can see the full source in the book's GitHub page in the project under this chapter, named <kbd>spring-boot-spring-cloud-vault</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP Data Integrity Validator</h1>
                </header>
            
            <article>
                
<p>Spring Security aids us in enriching our application with common security features, allowing us to do so very easily and with minimal code. However, Spring Security is slowly and steadily catching up with many of the additional security features needed in modern applications. Most of these applications are deployed on the cloud and have very high rates of changes pushed to production on a day-to-day basis. <span><strong>HTTP Data Integrity Validator</strong> (<strong>HDIV</strong>)</span> is a product that can be used to further enrich your application security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is HDIV?</h1>
                </header>
            
            <article>
                
<p><span>HDIV</span> was originally born as an open source project when it was developed by Roberto Velasco, Gotzon Illarramendi, and Gorka Vicente to confront security issues detected in production environments. The first stable Version 1.0 was released in 2008, in the form of a security library to be integrated within web applications. HDIV was officially integrated with Spring MVC, the most-used Java solution for web application development in 2011. In 2012, HDIV was integrated with Grails. In 2015, HDIV was included within Spring Framework official documentation as a solution related to web security. Based on global interest and responding to high market demand, the creators founded the <strong>HDIV Security </strong><span>(</span><a href="https://hdivsecurity.com/">https://hdivsecurity.com/</a><span>)</span> company and launched the commercial version of HDIV in 2016. HDIV solutions are built into applications during development to deliver the strongest available <strong>Runtime Application Self Protection</strong> (<strong>RASP</strong>) against the OWASP Top 10 threats.</p>
<p class="mce-root">HDIV was born to protect applications against parameter-tampering attacks. Its first purpose (looking at the acronym) was to guarantee the integrity (no data modification) of all the data generated by the server (links, hidden fields, combo values, radio buttons, destiny pages, cookies, headers, and more). HDIV extends a web application's behavior by adding security functionalities, as well as maintaining the API and the framework specification. HDIV gradually incorporated capabilities such as CSRF, <strong>SQL Injection</strong> (<strong>SQLi</strong>), and XSS protection, thus offering greatly increased security and being more than just an HTTP data integrity validator.</p>
<p>Attacks are becoming lower in cost and more automated. Manual security testing is becoming a costly bottleneck. Spring Security protects the application by easily implementing the most important security aspects, such as authentication and authorization, but does not protect from common security bugs and design flaws in your application code. This is where integrating a Spring application that is already secured using Spring Security can bring in HDIV. We will be going through a very simple example, which will showcase a few of the areas where HDIV shines. Here are some of those advantages, as detailed by their website:</p>
<ul>
<li style="font-weight: 400">HDIV detects security bugs in source code before it is exploited, using a runtime dataflow technique to report the file and line number of the vulnerability. Reporting is immediate to developers during the development process either within the web browser or within a centralized web console.</li>
</ul>
<ul>
<li style="font-weight: 400">It protects from business logic flaws with no need to learn applications and offers detection and protection from security bugs without changing the source code.</li>
<li style="font-weight: 400">HDIV makes integration possible between the pen-testing tool (Burp Suite) and the application, communicating valuable information to the pen-tester. It avoids many hand-coded steps, focusing the attention and effort of pen-testers on the most vulnerable entry points.</li>
</ul>
<div class="packt_tip"><span>For more information, you can check the following link: <a href="https://hdivsecurity.com/">https://hdivsecurity.com/</a>.</span></div>
<p>Let's start building a simple example that showcases the protection that HDIV does by protecting links and form data in your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Bootstrap project</h1>
                </header>
            
            <article>
                
<p>We will be using a base project created out of Spring Initializr for creating our HDIV sample, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cda8ae32-ec39-4227-8761-4f613e718a7d.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 14: Basic Spring Initializr project setup</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven dependencies</h1>
                </header>
            
            <article>
                
<p>In the following code, we are calling out explicit dependency that we need as part of this project, which is HDIV:</p>
<pre>&lt;!--HDIV dependency--&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.hdiv&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-hdiv-thymeleaf&lt;/artifactId&gt;<br/>   &lt;version&gt;1.3.1&lt;/version&gt;<br/>   &lt;type&gt;pom&lt;/type&gt;<br/>&lt;/dependency&gt;</pre>
<p>HDIV has support for a number of web application frameworks. In our example, we'll be using Spring MVC along with Thymeleaf and above mentioned dependency takes care of this.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security configuration</h1>
                </header>
            
            <article>
                
<p>By now, you will already know what goes in the Spring Security configuration file. We will have in-memory authentication and will be configuring two users (similar to what we have been doing all throughout this book). We will have form-based login and also will be creating our own login page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring MVC configuration</h1>
                </header>
            
            <article>
                
<p>The Spring MVC configuration that we have been looking at so far is very basic. There isn't anything worth a special mention here. We will just need to ensure that the controller attached to the login page is explicitly defined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HDIV configuration</h1>
                </header>
            
            <article>
                
<p>This magic class will bring in HDIV capability to your application without too much trouble. The full class is as shown here:</p>
<pre>@Configuration<br/>@EnableHdivWebSecurity<br/>public class HdivSecurityConfig extends HdivWebSecurityConfigurerAdapter {<br/>    @Override<br/>    public void addExclusions(final ExclusionRegistry registry) {<br/>        registry.addUrlExclusions("/login");<br/>    }<br/>}</pre>
<p>The heavy lifting is done by the class that we are extending, <kbd>HdivWebSecurityConfigurerAdapter</kbd>. Also, the <kbd>@EnableHdivWebSecurity</kbd> annotation makes sure that much of the setup is automatically taken care of. We just need to make sure that the configuration of our login page URL is excluded from HDIV security by overriding the <kbd>addExclusions</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Model class</h1>
                </header>
            
            <article>
                
<p>We will be using the same model class we have been using throughout this book—<kbd>Movie</kbd>. To ease coding, we will be using the Lombok library, which does all the magic by looking at the various annotations configured in the class.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Controller class</h1>
                </header>
            
            <article>
                
<p>We will just have one controller class, where we will map all the pages that we are going to create in this example. To showcase the power of HDIV, we will see HDIV in action for two cases:</p>
<ul>
<li style="font-weight: 400">A movie creation page (movie bean), showing HDIV at work in a page containing a form</li>
<li style="font-weight: 400">A links page that shows HDIV intercepting and throwing errors when someone manipulates the actual link</li>
</ul>
<p>The class is quite straightforward and doesn't need to be detailed here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pages</h1>
                </header>
            
            <article>
                
<p>As mentioned before, we will have the following pages created in our example:</p>
<ul>
<li style="font-weight: 400"><kbd>login.html</kbd>: The custom login page that we will use for users to log in to the application</li>
<li style="font-weight: 400"><kbd>main.html</kbd>: The page that the user navigates to after successful login, containing links to the movie creation and links pages</li>
<li style="font-weight: 400"><kbd>links.html</kbd>: The page that the user is navigated to when they click on the links URL</li>
<li style="font-weight: 400"><kbd>movie.html</kbd>: The movie creation page, containing two fields—title and genre</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Run the application just like any other Spring Boot project by executing the following command:</p>
<pre><strong>mvn spring-boot:run</strong></pre>
<p>Go to a browser and navigate to <kbd>http://localhost:8080</kbd> and you will be presented with a login page, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0bf4a33-f46f-439f-896a-1f910bb133b3.png" style="width:34.58em;height:21.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 15: Login page</div>
<p>As shown in the preceding screenshot, enter the <kbd>username</kbd>/<kbd>password</kbd> and click on the <span class="packt_screen">Login</span> button, and you will be navigated to the home page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6a7dd816-60cf-422f-b918-c9476182fbc4.png" style="width:34.75em;height:14.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 16: The home page, which is presented to the user after successful login</div>
<p>Click on the link to navigate to the page where you can create a new movie. You will be navigated to the page shown in the following screenshot. Look closely at the URL and you will see a new query parameter has been added, <kbd>_HDIV_STATE_</kbd>. The server validates and ensures that the submitted form is genuine by looking at that value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3f55fb0-c2d2-4093-84b1-bced8cdfa19d.png" style="width:54.25em;height:12.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 17: The Create Movie screen, showing off the _HDIV_STATE_ query string</div>
<p>Now go back to the home page and click on the links page. You will be navigated to the following page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1b408edd-622f-4516-9f9a-6eb4349414d6.png" style="width:72.75em;height:10.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 18: The links page, showing the _HDIV_STATE_ query string</div>
<p>As stated in the page, try manipulating the link (change the <kbd>_HDIV_STATE_</kbd> value) and you will be taken to the HDIV error page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0823acb2-e4c4-4bce-a081-d1fdc3ed267e.png" style="width:63.00em;height:19.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 19: The HDIV error page, which displays in the case of error conditions</div>
<p>This example showcases just two of the cases where HDIV shows its worth when working alongside Spring Security. For more details, I urge you to look at the HDIV website and documentation, which is available here:</p>
<ul>
<li style="font-weight: 400"><a href="https://hdivsecurity.com/docs/">https://hdivsecurity.com/docs/</a></li>
<li style="font-weight: 400"><a href="https://hdivsecurity.com/docs/installation/library-setup/">https://hdivsecurity.com/docs/installation/library-setup/</a></li>
<li style="font-weight: 400"><a href="https://github.com/hdiv/hdiv">https://github.com/hdiv/hdiv</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom DSL</h1>
                </header>
            
            <article>
                
<p>Spring Security allows you to write your own <strong>Domain Specific Language</strong> (<strong>DSL</strong>), which can be used to configure security in your application. We have already seen a custom DSL in action when we implemented SAML authentication using OKTA. We used an OKTA-provided custom DSL to configure Spring Security.</p>
<p>To write your own custom DSL, you can extend the <kbd>AbstractHttpConfigurer</kbd> <em>class </em>and override a few of it's methods, as shown here:</p>
<pre>public class CustomDSL extends AbstractHttpConfigurer&lt;CustomDSL, HttpSecurity&gt; {<br/>    @Override<br/>    public void init(HttpSecurity builder) throws Exception {<br/>       // Any configurations that you would like to do (say as default) can be  <br/>       configured here<br/>    }<br/><br/>    @Override<br/>    public void configure(HttpSecurity builder) throws Exception {<br/>       // Can add anything specific to your application and this will be honored<br/>    }<br/>}</pre>
<p>In your Spring Security configuration class (the configure method), you can then use your custom DSL, as shown here:</p>
<pre>@Override<br/> protected void configure(HttpSecurity http) throws Exception {<br/>     http<br/>         .apply(&lt;invoke custom DSL&gt;)<br/>         ...;<br/> }</pre>
<p>When Spring Security sees a custom DSL setup, the execution of code is as follows:</p>
<ol>
<li style="font-weight: 400">Invoke the Spring Security configuration class's <kbd>configure</kbd> method</li>
<li style="font-weight: 400">Invoke the custom DSL <kbd>init</kbd> method</li>
<li style="font-weight: 400">Invoke the custom DSL <kbd>configure</kbd> method</li>
</ol>
<p>Spring Security uses this approach to implement <kbd>authorizeRequests()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter introduced you to some of the other capabilities of Spring Security that can be used in your application. Using examples, we covered how to achieve remember-me functionality in your application. We also touched briefly upon concepts such as CSRF, CORS, CSP, channel security, and session management. We also covered the Crypto module in Spring Security concisely.</p>
<p>We wrapped up the chapter by introducing two products that can work along with Spring Security—HashiCorp Vault (for secret management) and HDIV (for additional security features).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>After reading this chapter, you should have a clear understanding of some of the additional features that can be implemented using Spring Security. You should also have a good understanding of some of the products that can be used alongside Spring Security to achieve some of the most important technical capabilities that are needed for modern applications.</p>
<p>Now, pat yourself your back if you are reading this, as with this chapter, we complete the book. I hope you have enjoyed every bit of this book, and I hope you have learned something new that can be used for creating  wonderful and innovative new applications.</p>
<p class="CDPAlignLeft CDPAlign">Thank you for reading!</p>


            </article>

            
        </section>
    </body></html>