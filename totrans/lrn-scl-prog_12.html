<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building Reactive Applications with Akka Typed</h1>
                </header>
            
            <article>
                
<p class="p1">This chapter reveals another way to build reactive applications with Akka. We will introduce Akka Typed, an Akka module which implements the actor model in a slightly different way compared to untyped Akka. We will contrast <em>classical</em> and typed approaches and show how the latter reduces the developer's choices but increases type safety and simplifies reasoning about actor-based programs during the maintenance phase.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li><span>Differences between typed and untyped approaches</span></li>
<li><span>Creating, stopping, and discovering actors</span></li>
<li><span>The life cycle of an actor and supervision</span></li>
<li><span>Schedulers</span></li>
<li><span>Stashing</span></li>
<li><span>Combining behaviors</span></li>
<li><span>Testing</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Before we begin, make sure you have the following installed:</p>
<ul>
<li><span>Java 1.8+</span></li>
<li>SBT 1.2+</li>
</ul>
<p>The source code for this chapter is available on our GitHub repository at: <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12</a><a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02">.</a></p>
<p><a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02"/></p>
<p><span>The code snippets in this chapter have been simplified a bit to omit unnecessary technical details. Please refer to the GitHub repository for fully functioning examples.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a><span>, <em>An Introduction to the Akka and Actor Models</em></span>, we discovered the actor model and how Akka implements it.<span class="Apple-converted-space"> </span></p>
<p>The original actor paper states three possible actions that actors can perform as computational units:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>They can send messages to other known actors</li>
<li>They can create new actors</li>
<li>They can designate behavior for future message processing</li>
</ul>
</li>
</ul>
<p>Because of the universality of this model, the specifics of how these points are to be implemented depends on the hardware, operating system, programming language, existing libraries, and ultimately on the design choices of the implementer. Akka Typed offers a slightly different programming model compared to untyped Akka.</p>
<div class="packt_infobox">Furthermore, in this chapter, we'll refer to normal Akka as Akka untyped to be specific about which library is being mentioned, even though <em>untyped</em> Akka was always named just <em>Akka</em> in the previous chapter.</div>
<p class="mce-root"/>
<p class="mce-root"><span>Let's take a closer look at the differences and similarities between the two implementations.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The typed approach and the differences between Akka untyped</h1>
                </header>
            
            <article>
                
<p><span>Compared to the untyped version, </span>Akka Typed takes a slightly different approach to define what an actor is.</p>
<p>In Akka untyped, an actor is any object that is a subclass of an abstract <kbd>Actor</kbd> and overrides a <kbd>def receive: PartialFunction[Any, Unit]</kbd> method. This allows the developer to do anything in the implementation except return a meaningful result, which makes it hard to reason about the code and impossible to combine actor logic.</p>
<p>Akka Typed declares that any well-defined behavior is a computation entity and thus can be declared to be an actor. The <em>well-defined</em> in terms of Akka Typed means anything that defines a statically typed <kbd>Behavior</kbd>. The type of <kbd>Behavior</kbd> limits actors to receiving messages of this specific type <span>only</span>. The return type of the actor's behavior is required to be the next <kbd>Behavior</kbd> of the same type with respect to inheritance. This way, it is possible to ensure at compile time that the actor will receive only messages of the type it declares to handle.<span class="Apple-converted-space"> </span></p>
<p>In order to achieve this, actor addresses also need to be typed, and the type of address needs to be known at compile time. Hence, features of untyped Akka such as implicit access to the sender of the present message and general actor lookup are not available in typed Akka. By contrast, actor's addresses need to be defined as part of the protocol or need to be managed by an external (to the actor) facility.</p>
<p>Another notable change is the introduction of <kbd>Signal</kbd> message types, which represent events in the <span>life cycle of an </span>actor and replace dedicated callback methods that were exposed by the <span><kbd>Actor</kbd> class </span>in untyped Akka. Although this is not a very big spot in a whole picture of changes, it is a good move to make the implementation of Akka's actor model closer to the abstract actor model.</p>
<p>In short, Akka Typed restricts actor communication and behavior to the model, which can then be type checked at compile time. This limits the developer's choices and possibilities for the implementation, but at the same time makes the result easier to reason about and test. The unavailability of some untyped features makes it impossible to write code in a way that represents an Akka anti-pattern and leads to solutions resembling what are considered to be the best practices in <em>normal</em> Akka.</p>
<div class="packt_tip"><span>This module is currently marked as</span> <strong>may change</strong> (<a href="https://doc.akka.io/docs/akka/2.5/common/may-change.html">https://doc.akka.io/docs/akka/2.5/common/may-change.html</a>). This reflects the fact that the topic itself is the subject of active research and there might be some changes in the API. However, the current implementation is solid and changes in the API are minimal among recent version updates. Therefore, the Akka team considers Akka Typed to be production-ready. </div>
<p>Let's take a look at what these differences look like in practice.<span class="Apple-converted-space"> </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example actor system</h1>
                </header>
            
            <article>
                
<p>To illustrate features of Akka Typed, we'll reimplement an example we built in <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a><span>, <em>An Introduction to the Akka and Actor Models</em></span>, but this time with typed actors.</p>
<p>For those readers who are familiar with the content of the previous chapter, this approach will allow you to compare two different styles.<span class="Apple-converted-space"> </span>For those who just joined, let's quickly recap the structure of this example.</p>
<p>We're building a small cookie bakery which is populated by a number of actors, each with their own set of responsibilities:</p>
<ul>
<li>The <kbd>Manager</kbd> drives the process and passes over materials from one worker to another.</li>
<li><span>The</span> <kbd>Boy</kbd> takes a <kbd>ShoppingList</kbd> and returns to the <kbd>Manager</kbd> the respective <kbd>Groceries</kbd> from the <kbd>Store</kbd>.</li>
<li><span>The</span> <kbd>Chef</kbd> takes the <kbd>Groceries</kbd> and makes them into <kbd>Dough</kbd>. It does so by using a number of <kbd>Mixers</kbd> with the exact mixer count depending on the amount of stuff to mix.</li>
<li><span>The</span> <kbd>Cook</kbd> takes <kbd>Dough</kbd> and makes <kbd>RawCookies</kbd>.</li>
<li><span>The</span> <kbd>Baker</kbd> bakes the <kbd>RawCookies</kbd> in batches using a single <kbd>Oven</kbd> of a limited capacity.</li>
</ul>
<p>The structure of the actor system we're going to build is represented in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/59a948d7-2089-4789-a569-df739e16b199.png" style="width:39.67em;height:13.83em;" width="811" height="283"/></div>
<p>Let's start with an implementation of the simplest actor in our system <span>–</span> the <strong>Oven</strong>. Here and later on in this chapter, we'll refer to the previous implementation, meaning the implementation we came up with in regards to untyped actors in <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a><span>, <em>An Introduction to the Akka and Actor Models</em></span>. The differences are very illustrative, so we advise the reader to refer to the code in the previous chapter, even if you haven't read it because you<span> are already familiar with untyped Akka</span>.</p>
<p>To be able to use Akka <kbd>Typed</kbd> in our code, we need to put the following dependency in <kbd>build.sbt</kbd>:</p>
<pre><span>lazy val </span>akkaVersion = <span>"2.5.13"</span><span><br/></span><span>libraryDependencies </span>+= <span>"com.typesafe.akka" </span>%% <span>"akka-actor-typed" </span>% akkaVersion</pre>
<p>Defining <kbd>akkaVersion</kbd> separately as a <kbd>val</kbd> has the advantage that it can be reused for other modules and changed in a single place at the moment a new version becomes available.</p>
<p>To keep our examples clean and short, we'll assume that the following inputs are present in every code snippet:</p>
<pre><span>import </span>akka.actor.typed._<br/><span>import </span>akka.actor.typed.scaladsl._</pre>
<p>The first input brings lower level actor system abstractions into scope, and the second allows us to use higher level DSL for an actor's behavior <span>definition</span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">First example</h1>
                </header>
            
            <article>
                
<p>First, we need to define the protocol that our <kbd>Oven</kbd> will speak. In contrast to the untyped implementation, we can't reuse messages that are defined by another actor. The reason for this is that the <kbd>Oven</kbd> (and other actors at later stages) defines the type of messages it is supposed to handle. This type should not be too general in order to avoid making the whole implementation less typed than desirable.</p>
<p>The domain model is common for all actors, so we'll define it on the <kbd>Bakery</kbd> app level:</p>
<pre><span>final case class </span>Groceries(eggs: Int, flour: Int, sugar: Int, chocolate: Int)<br/><span>final case class </span>Dough(weight: Int)<br/><span>final case class </span>RawCookies(count: Int)<br/><span>final case class </span>ReadyCookies(count: Int)</pre>
<p>And this is the small language our <kbd>Oven</kbd> speaks:</p>
<pre>sealed trait Command<br/>case class Put(rawCookies: Int, sender: ActorRef[Baker.Command]) extends Command<br/>case class Extract(sender: ActorRef[Baker.Command]) extends Command</pre>
<p>The <kbd>Oven</kbd> can return <kbd>ReadyCookies</kbd> (a cookie is considered to be ready as soon as it has been put into the oven) and <kbd>RawCookies</kbd> in the case where there are more cookies in the <kbd>Put</kbd> command than can fit inside the oven. The <kbd>Command</kbd> is a type of behavior for our actor. We can see that it includes the <kbd>sender</kbd> field so that the oven knows who is the receiver of the extracted cookies.</p>
<p>Now, we need to define the actor's behavior. If you followed the previous chapter, you will remember that we used the internal mutable field to store the contents of the oven in the current moment. By using this field, we can differentiate its reaction on incoming messages. Akka Typed urges us to exercise a different approach and use separate behaviors for different states of the actor. First, we define what should happen in the case that there is nothing inside:</p>
<pre><span>def </span>empty: Behaviors.Receive[Command] = Behaviors.<span>receiveMessage</span>[Command] {<br/>  <span>case </span><span>Put</span>(rawCookies, sender) =&gt;<br/>    <span>val </span>(inside, overflow: Option[RawCookies]) = <span>insert</span>(rawCookies)<br/>    overflow.foreach(sender.tell)<br/>    <span>full</span>(inside)<br/>}</pre>
<p>Here, we define a behavior of the empty <kbd>Oven</kbd> using the <kbd>Behaviors</kbd> factory. In our case, this is a <kbd>receiveMessage</kbd> method with a type parameter called <kbd>Command</kbd>. This designates the type of messages our actor can handle.</p>
<p>Next, we define a course of action in the case of the incoming <kbd>Put</kbd> command. The <kbd>insert</kbd> method returns a number of cookies that we can put inside the <kbd>Oven</kbd> and an optional overflow. In this case, if there is an overflow, we return it to the sender by using the <kbd>tell</kbd> method of its <kbd>ActorRef[Cookies]</kbd>. The type of reference allows us to send <kbd>RawCookies</kbd> back. Because of the type-safe nature of the actor definition, this binds the behavior of the <kbd>Baker</kbd> actor (that we'll implement soon) to be <kbd>Behaviors.Receive[Cookies]</kbd>. </p>
<p>Now, we need to define what should happen in the case that the <kbd>Oven</kbd> is not empty:</p>
<pre><span>def </span>full(count: Int): Behaviors.Receive[Command] = Behaviors.<span>receiveMessage</span>[Command] {<br/>  <span>case </span><span>Extract</span>(sender) =&gt;<br/>    sender ! <span>ReadyCookies</span>(count)<br/>    <span>empty<br/></span>}</pre>
<p>This <kbd>Behavior</kbd> is even simpler, but still has the same type—<kbd>Behaviors.Receive[Command]</kbd>. We just return all of the cookies that were inside to the sender and change the future behavior to the <kbd>empty</kbd> behavior we defined earlier. </p>
<p>Now, if we compile this implementation, we'll get complaints from the compiler:</p>
<pre><strong>Warning:(18, 77) match may not be exhaustive.</strong><br/><strong> It would fail on the following input: Extract(_)</strong><br/><strong> def empty: Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {</strong><br/><strong> Warning:(25, 88) match may not be exhaustive.</strong><br/><strong> It would fail on the following input: Put(_, _)</strong><br/><strong> def full(count: Int): Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {</strong></pre>
<p>The compiler has helped us to identify our first two bugs already! The reason it is unhappy with the current implementation is that we forgot to define a reaction to the <span>messages that are </span><em>inappropriate</em> in specific states. This will be an attempt to extract cookies from the empty oven and to put something into the full one. From the type perspective, this is possible, and the compiler informed us of this.</p>
<p>Let's fix this by implementing our states properly:</p>
<p>This is the augmented definition of an <kbd>empty</kbd> state:</p>
<pre><span>def </span>empty: Behaviors.Receive[Command] = Behaviors.<span>receiveMessage</span>[Command] {<br/>  <span>case </span><span>Put</span>(rawCookies, sender) =&gt;<br/>    <span>val </span>(inside, tooMuch) = <span>insert</span>(rawCookies)<br/>    tooMuch.foreach(sender.tell)<br/>    <span>full</span>(inside)<br/>  <span>case </span><span>Extract</span>(sender) =&gt;<br/>    sender ! <span>ReadyCookies</span>(<span>0</span>)<br/>    Behaviors.<span>same<br/></span>}</pre>
<p>The sender will be sent zero cookies, and we keep current behavior by using <kbd>Behavior.same</kbd>.</p>
<p>The principle stays the same for the <kbd>full</kbd> case:</p>
<pre><span>def </span>full(count: Int): Behaviors.Receive[Command] = Behaviors.<span>receiveMessage</span>[Command] {<br/>  <span>case </span><span>Extract</span>(sender) =&gt;<br/>    sender ! <span>ReadyCookies</span>(count)<br/>    <span>empty<br/></span><span>  </span><span>case </span><span>Put</span>(rawCookies, sender) =&gt;<br/>    sender ! <span>RawCookies</span>(rawCookies)<br/>    Behaviors.<span>same<br/></span>}</pre>
<p>Again, we just returned to the sender everything we've got and kept the current behavior exactly like we did in the empty case.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Akka Typed basics</h1>
                </header>
            
            <article>
                
<p><span>Now that we've made the compiler happy and got our first impression about how typed actors tick, let's take a more principled approach and look in detail at how they can be created, discovered, and stopped, and what possibilities there are to change an actor's behavior.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating an actor</h1>
                </header>
            
            <article>
                
<p>In accordance to the actor model definition, there is exactly one way that an actor can be created—it can be spawned by another actor. Akka gives you two slightly different possibilities to do this by using <kbd>ActorContext</kbd>. Both methods are not thread safe and should only be used<span> directly </span>within the actor's thread.</p>
<p>The first variant allows you to instantiate an anonymous actor from a behavior and returns an <kbd>ActorRef[T]</kbd>:</p>
<pre><span>def </span>spawnAnonymous[T](behavior: Behavior[<span>T</span>], props: Props = Props.<span>empty</span>): ActorRef[<span>T</span>]</pre>
<p>This implementation provides a default empty value for the props parameter so that the actual call can be reduced to <kbd>spawnAnonymous(behavior)</kbd>.</p>
<p>Not naming actors might be useful in specific situations, but it is considered to be a bad practice in general. This is because it makes debugging harder and looking up children by name impossible without relying on the current implementation details of the library.</p>
<p>Thus, another realization should be preferred whenever it makes sense to use one: </p>
<pre><span>def </span>spawn[<span>T</span>](behavior: Behavior[<span>T</span>], name: <span>String</span>, props: Props = Props.<span>empty</span>): ActorRef[<span>T</span>]</pre>
<p>Here, we're required to provide a behavior and a name for an actor, which is about to be instantiated.</p>
<p>Both <kbd>spawn</kbd> and <kbd>spawnAnonymous</kbd> accept a <kbd>props</kbd> parameter, which can be used to further configure an actor instance. As of now, it is only possible to configure an actor's dispatcher.</p>
<div class="packt_infobox">Dispatchers make up the machinery that runs behaviors. Dispatchers use <kbd>ExecutorServices</kbd> to assign threads to actors and can be configured as described in <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a><span>, <em>An Introduction to the Akka and Actor Models</em></span>. Currently, Akka Typed only supports the dispatchers definition from the configuration. Properties of the default dispatcher can be changed by overriding the settings under <kbd>akka.actor.default-dispatcher</kbd> .</div>
<p>In our example system, the <kbd>Chef</kbd> actor should instantiate <kbd>Mixers</kbd> as being required to work with big chunks of work in parallel. In addition, mixers use blocking code because of the limitations of hardware and therefore need separate dispatchers in order to avoid thread starvation for the rest of the system. Let's look at how this behavior can be implemented.</p>
<p>First, by using <kbd>application.conf</kbd>, we configure a dispatcher that will be used for blocking mixers:</p>
<pre>mixers-dispatcher {<br/>  executor = <span>"thread-pool-executor"<br/></span><span>  </span>type = PinnedDispatcher<br/>}</pre>
<p>Then, we instantiate the required number of child actors:</p>
<pre><span>object </span>Chef {<br/>  <span>sealed trait </span>Command<br/>  final case class Mix(g: Groceries, manager: ActorRef[Manager.Command]) extends Command<br/>  <span>def </span>idle = Behaviors.<span>receive</span>[Command] {<br/>    <span>case </span>(context, mix@Mix(<span>Groceries</span>(eggs, flour, sugar, chocolate), manager)) =&gt;<br/>      val props = DispatcherSelector.fromConfig("mixers-dispatcher")<br/>      val mixers = for (i &lt;- 1 to eggs) yield<br/>        context.spawn(Mixer.mix, s"Mixer_$i", props)<br/>      mixing<br/>  }<br/>  def mixing = Behaviors.unhandled[Command]i<br/>}</pre>
<p>The <kbd>Chef</kbd> actor has its own hierarchy of commands which we, for now, limit to <kbd>Mix</kbd>. We need a separate <kbd>Mixer</kbd> for each egg, so we instantiate them by using <kbd>spawn</kbd>. <kbd>spawn</kbd> returns an actor reference and we collect them in the <kbd>mixers</kbd> <kbd>val</kbd>. Finally, we return the next actor's <kbd>Behavior</kbd>, which for now is <kbd>unhandled</kbd>.</p>
<p>OK, so it's possible to create new actors from an actor's context. This brings us to a <strong>Zeno's paradox</strong> kind of situation with Achilles and the tortoise. Naturally, to create a new actor, we need to have an actor already. Akka solves this paradox by requiring the developer to provide a definition of a root actor at the moment an actor system is created:</p>
<pre><span>def </span>apply[<span>T</span>](guardian: Behavior[<span>T</span>],name: <span>String</span>): ActorSystem[<span>T</span>]</pre>
<p>This leaves the developer with no choice but to design a proper actor hierarchy top-down. Following this typed approach automatically leads to avoidance of the <em>flat actor hierarchy</em> anti-pattern!</p>
<div class="packt_tip">There is another possibility for instantiating an actor. This can be done by using the <kbd>ActorSystem</kbd>'s <kbd>systemActorOf</kbd> method, which creates an actor in the <kbd>/system</kbd> space. It is arguable that this feature shouldn't normally be used, and therefore it is not covered here.</div>
<p>Now, since our <kbd>Chef</kbd> spawned enough <kbd>Mixers</kbd> to do the job, we need a way to get rid of them after our work is complete.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stopping an actor</h1>
                </header>
            
            <article>
                
<p>An actor can be stopped in one of the following ways:</p>
<ul>
<li>By designating its next behavior to be <kbd><span>Behaviors.stopped</span></kbd>.</li>
<li>By applying the <kbd>stop</kbd> method of the <kbd>ActorContext</kbd> to the immediate child. The child will finish processing the current message but leave other messages that are still in the mailbox unprocessed.</li>
<li>By the actor system as it stops its ancestor. The actual shutdown happens recursively, bottom-up, following the hierarchy. </li>
</ul>
<p>The most natural approach in our mixers example would be to pick the first option. We implement it in the following example:</p>
<pre><span>object </span>Mixer {<br/>  <span>final case class </span>Mix(groceries: Groceries, sender: ActorRef[Collect])<br/>  <span>def </span>mix = Behaviors.<span>receiveMessage</span>[Mix] {<br/>    <span>case </span><span>Mix</span>(<span>Groceries</span>(eggs, flour, sugar, chocolate), sender) =&gt;<br/>      Thread.sleep(3000)<br/>      sender ! Collect(<span>Dough</span>(eggs * <span>50 </span>+ flour + sugar + chocolate))<br/>      Behaviors.<span>stopped<br/></span><span>  </span>}<br/>}</pre>
<p>The <kbd>Mixer</kbd> behavior is very simple, so we don't need to define an ADT for that and use the single <kbd>Mix</kbd> command directly. The <kbd>Chef</kbd> actor expects <kbd>Collect(Dough)</kbd> back. This obliges us to define it as a type parameter for the sender reference. The behavior itself simulates the hardware delay for the mixing to be finished, sends the prepared dough to the <kbd>Chef</kbd>, and returns <kbd>Behaviors.stopped</kbd> as the next behavior. This leads to the graceful termination of the <kbd>Mixer</kbd> actor.</p>
<p>Now that we've sent the dough back to the <kbd>Chef</kbd>, let's see how it is supposed to be handled. The <kbd>Chef</kbd> needs to collect the results from all of the mixers it has created. To do so, we could pass references to the child actors we've created in the idle state to the mixing behavior, but let's imagine we lost the references we collected for some reason. In this case, <kbd>Chef</kbd> could look up its children.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Discovering an actor</h1>
                </header>
            
            <article>
                
<p>Actor discovery is an alternative way to obtain an actor reference. The preferred way is still to incorporate actor <span>references</span> into the message protocol.</p>
<p>Akka provides the possibility to look up a single child actor by name (only exact match) with the following method:</p>
<pre><span>def </span>child(name: <span>String</span>): Option[ActorRef[Nothing]]</pre>
<p>This returns a reference to a child actor if a child with such a name exists and is alive. Please note that because of the return type of this method, the result needs to be coerced to the proper type by the use of the <kbd>narrow</kbd> method of <kbd>ActorRef</kbd>. </p>
<p><span>Another method that allows us to look up all of the children of an actor that are alive is as follows:</span></p>
<pre><span>def </span>children: <span>Iterable</span>[ActorRef[Nothing]]</pre>
<p>The type of result is, again, a collection of <kbd>ActorRefs</kbd> with no particular type.</p>
<p>It is arguable that the lookup methods we have described here are of little use because of their basically untyped nature. Akka Typed offers a better alternative in the form of the <kbd>receptionist</kbd>.</p>
<p>The <kbd>receptionist</kbd> is a (cluster) singleton actor that is available on the actor system level and can be obtained from the <kbd>ActorContext</kbd> using the following call chain:</p>
<pre>val receptionist: ActorRef[Receptionist.Command] = context.system.receptionist</pre>
<p>The <kbd>receptionist</kbd> is just an actor of type <kbd>[Receptionist.Command]</kbd>, so let's investigate the <kbd><span>Receptionist.C</span>ommand</kbd> type to understand what it is capable of.</p>
<p>There are three concrete implementations of the abstract <kbd>Command</kbd> class: <kbd>Register</kbd>, <kbd>Find</kbd>, and <kbd>Subscribe.</kbd></p>
<p><kbd>Register</kbd> is used for associating the given <kbd>ActorRef</kbd> with the provided <kbd>ServiceKey</kbd>. It is possible to register multiple references for the same key. The registration is automatically removed from the receptionist if the registered actor is stopped.</p>
<p><span>By providing an optional reference,</span> it is possible to provide another actor, who should be notified if the service was successfully registered.</p>
<p><kbd>Find</kbd> is a mechanism for asking the receptionist about all currently known registered actors for the given <kbd>ServiceKey</kbd>. The receptionist responds with a <kbd>Set</kbd> of known actor references (which are called <strong>services</strong>) that are registered to the given key, and a key itself wrapped in a <kbd>Listing</kbd>. <kbd>Find</kbd> can be used to implement one-time queries to the receptionist.</p>
<p><kbd>Subscribe</kbd> is a way to implement push behavior for the receptionist. An actor can use subscribe to receive notifications about all added or removed services for some predefined key.</p>
<p>In our example, the <kbd>Manager</kbd> actor is used to provide a <kbd>Boy</kbd> with a reference to the <kbd>seller</kbd> actor. The <kbd>Boy</kbd> is supposed to communicate with the provided reference. In the previous chapter, we used <span>untyped Akka's </span>remote lookup to get this reference. In the typed environment, we will utilize the receptionist for this purpose.</p>
<p>This is how it is done.</p>
<p>First, the <kbd>seller</kbd> behavior needs to register itself with the receptionist at the moment it is initialized:</p>
<pre><span>import akka.actor.typed.receptionist.Receptionist._<br/><br/>val </span><span>SellerKey </span>= <span>ServiceKey</span>[SellByList](<span>"GrocerySeller"</span>)<br/><br/><span>val </span><span>seller</span> = Behaviors.<span>setup </span>{ ctx ⇒<br/>    ctx.system.receptionist ! <span>Register</span>(<span>SellerKey</span>, ctx.self)<br/>    Behaviors.<span>receiveMessage</span>[SellByList] {<br/>        <span>case </span><span>SellByList</span>(list, toWhom) ⇒<br/>          <span>import </span>list._<br/>          toWhom ! <span>Groceries</span>(eggs, flour, sugar, chocolate)<br/>          Behaviors.<span>same<br/></span><span>    </span>}<br/>  }</pre>
<p>The <kbd>Shop</kbd> defines the <kbd>SellerKey</kbd> that will be used by the actor to register as a service and by the service clients to look up the seller's reference.</p>
<p>Next, we introduce a new type of behavior constructor—<kbd>Behaviors.setup</kbd>. <kbd>setup</kbd> is a behavior factory. It takes the behavior constructor as a <span>by-name</span> parameter and creates the behavior at the moment the actor is started (as opposed to the moment the behavior is constructed). We need to use this factory for two reasons:</p>
<ul>
<li>We need our actor to be instantiated so that we can access its context</li>
<li>We want our <kbd>Seller</kbd> to register itself exactly once</li>
</ul>
<p>After registering the <kbd>Seller</kbd> with the receptionist, the real behavior is constructed. The behavior itself is just accepting the <kbd>SellByList</kbd> messages and responding with the <kbd>Groceries</kbd> that are to be provided to the <kbd>toWhom</kbd> reference.</p>
<p>On the opposite side of the receptionist, the <kbd>Manager</kbd> actor needs to look up the <kbd>Seller</kbd> and use its reference to guide the <kbd>Boy</kbd>:</p>
<pre><span>def </span>idle: Behavior[Command] = Behaviors.<span>setup </span>{ context =&gt;<br/>  <span>implicit val </span>lookupTimeout: Timeout = <span>1</span>.second<br/>  context.ask(context.system.receptionist)(<span>Find</span>(Shop.<span>SellerKey</span>)) {<br/>    <span>case </span><span>Success</span>(listing: Listing) =&gt;<br/>      listing<br/>        .serviceInstances(Shop.<span>SellerKey</span>)<br/>        .headOption<br/>        .map { seller =&gt;<br/>          <span>LookupSeller</span>(seller)<br/>        }<br/>        .getOrElse {<br/>          NoSeller<br/>        }<br/>    <span>case </span><span>Failure</span>(_) =&gt;<br/>      NoSeller<br/>  }</pre>
<p>There is quite a bit going on here. Once again, we're using <kbd>setup</kbd> to define the behavior.</p>
<p>Looking up actors is an asynchronous operation, and in this case, we utilize the <kbd>ask</kbd> pattern to keep the code concise. Ask needs to know how long it is allowed to wait for the answer, so, <span>in the second line, </span>we define a <kbd>lookupTimeout</kbd>.</p>
<p>Then, we call the <kbd>ask</kbd> method that's available in the actor context and provide a reference of a <kbd>receptionist</kbd> as an actor to be asked. The second parameter is the receptionist's <kbd>Find</kbd> command, which is given a seller key. Normally, the <kbd>Find</kbd> command takes a second parameter that defines a receiver for the response, but as it is used quite often together with <kbd>ask</kbd>, there is a special constructor that allows for the nice syntax we are using in this snippet.</p>
<p>The case literal, which comes next, defines a transformation that must be applied to the response before actually sending it back to the asking actor. It deconstructs and converts the receptionist's response so that it is either a <kbd>NoSeller</kbd> or just one <kbd>OneSeller</kbd>.</p>
<p>Next, we have to deal with the converted response by defining a behavior which is returned as a result of this lengthy factory method:</p>
<pre>Behaviors.<span>receiveMessagePartial </span>{<br/>  <span>case </span><span>OneSeller</span>(seller) =&gt;<br/>    <span>val </span>boy = context.spawn(Boy.<span>goShopping</span>, <span>"Boy"</span>)<br/>    boy ! <span>GoShopping</span>(<span>shoppingList</span>, seller, context.self)<br/>    <span>waitingForGroceries<br/></span><span>  </span><span>case </span>NoSeller =&gt;<br/>    context.log.error(<span>"Seller could not be found"</span>)<br/>    <span>idle<br/></span>}</pre>
<p>In the current manager's behavior, we only expect a small subset of all of the possible messages to arrive. We're using <kbd>receiveMessagePartial</kbd> to avoid compiler warnings for unhandled message types.</p>
<p>In this case, if there is no seller, we can use the <kbd>log</kbd> that's available in the actor's <kbd>context</kbd> to report this condition and return the current behavior.</p>
<p>In this case, if there is a <kbd>Seller</kbd> available, we instantiate a <kbd>Boy</kbd> and use it to transfer a <kbd>shoppingList</kbd> to this seller. Note how we used <kbd>context.self</kbd> as a second parameter for the <kbd>GoShopping</kbd> message. By doing this, we're making it possible to use the provided manager's reference to persuade the <kbd>Seller</kbd> to send groceries directly to the <kbd>Manager</kbd>, and then the <kbd>Boy</kbd> can immediately stop itself after sending the message:</p>
<pre><span>object </span>Boy {<br/>  <span>final case class </span>GoShopping(shoppingList: ShoppingList,<br/>                              seller: ActorRef[SellByList],<br/>                              manager: ActorRef[Manager.Command])<br/><br/>  <span>val </span><span>goShopping </span>= Behaviors.<span>receiveMessage</span>[GoShopping] {<br/>    <span>case </span><span>GoShopping</span>(shoppingList, seller, manager) =&gt;<br/>      seller ! <span>SellByList</span>(shoppingList, manager)<br/>      Behaviors.<span>stopped<br/></span><span>  </span>}<br/>}</pre>
<p>Here, we have seen how the <kbd>GoShopping</kbd> command prohibits us from interchanging actor references for the seller and manager, as this could easily happen in the case of untyped Akka.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Akka Typed – beyond the basics</h1>
                </header>
            
            <article>
                
<p>We've defined the behavior of the <kbd>Chef</kbd> actor to distribute work across mixers but left the waiting part uncovered, so let's look at that now.</p>
<p>We left the <kbd>Chef</kbd> definition for the <kbd>mixing</kbd> behavior as follows: </p>
<pre>def mixing = Behaviors.unhandled[Command]</pre>
<p>Actually, the <kbd>Chef</kbd> needs to know about the mixers that were created by its <kbd>idle</kbd> behavior. Though technically it is possible to do a children lookup, as described earlier, doing so will introduce an implicit assumption that, at the moment, we'll get the listing stating that all of the mixers are still processing jobs. This assumption might be wrong in a highly concurrent environment or in the case of failed mixers.</p>
<p>Therefore, we need to refactor the behavior constructor a bit:</p>
<pre><span>def </span>mixing(mixers: <span>Set</span>[ActorRef[Mixer.Mix]],<br/>           collected: Int,<br/>           manager: ActorRef[Manager.Command]): Behavior[Command]</pre>
<p>Now, we have a builder that captures all of the parts of the Chef's state. <span>Let's see how these parts are used in the definition of its behavior:</span></p>
<pre>Behaviors.<span>receivePartial </span>{<br/>  <span>case </span>(context, <span>Collect</span>(dough, mixer)) =&gt;<br/>    <span>val </span>mixersToGo = mixers - mixer<br/>    <span>val </span>pastryBuf = collected + dough.weight<br/>    context.stop(mixer)<br/>    <span>if </span>(mixersToGo.isEmpty) {<br/>      manager ! <span>ReceivePastry</span>(<span>Dough</span>(pastryBuf))<br/>      <span>idle<br/></span><span>    </span>} <span>else </span>{<br/>      <span>mixing</span>(mixersToGo, pastryBuf, manager)<br/>    }<br/>}</pre>
<p>We're already familiar with the constructor. In the behavior itself, we count every <kbd>Dough</kbd> message received from the mixer and recreate the behavior with the new state. In this case, if all of the mixers have delivered their parts, we return the result to the manager and go to the <kbd>idle</kbd> state.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Life cycle of an actor</h1>
                </header>
            
            <article>
                
<p>Our implementation of the <kbd>Mixer</kbd> is quite naive and does not take into account that hardware occasionally breaks.</p>
<div class="packt_infobox">Conventionally, in Akka, we distinguish between expected and unexpected failures. An expected failure of some operation, for example, a validation error is usually represented on the protocol level with the appropriate message types. Exceptional conditions of an unexpected nature such as hardware errors, are communicated by throwing exceptions. This allows you to separate handler definitions for successful and erroneous paths, which leads to the separation of business logic from the technical details of the underlying platform. Thus, having a rich set of exceptions is a prerequisite for proper error-handling definitions.</div>
<p>Let's take this aspect into account. We'll represent unreliable hardware by defining a set of exceptions, one for every possible failure. We'll do this the same way as we did in <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a>, <em>An Introduction to the Actor Model and Akka</em>:</p>
<pre><span>class </span>MotorOverheatException <span>extends </span>Exception<br/><span>class </span>SlowRotationSpeedException <span>extends </span>Exception<br/><span>class </span>StrongVibrationException <span>extends </span>Exception</pre>
<p>Now, in order to simulate the hardware failure, we'll add some code with the purpose of throwing defined exceptions to the logic of the <kbd>Mixer</kbd>. To keep the example simple, let's just throw one of them:</p>
<pre><span>case </span>(_, <span>Mix</span>(<span>Groceries</span>(eggs, flour, sugar, chocolate), sender)) =&gt;<br/>  <span>if </span>(Random.nextBoolean()) <span>throw new </span>MotorOverheatException<br/>  ...</pre>
<p>It looks like it is very warm in our bakery. The mixer motors are overheating roughly every second time the <kbd>Chef</kbd> tries to mix the <kbd>Groceries</kbd>.</p>
<p>Actors can watch themselves by calling the <kbd>receiveSignal</kbd> method on the actor's context and providing a <kbd>PartialFunction[(ActorContext[T], Signal), Behavior[T]]</kbd> as a parameter. The provided partial function will be called, with a life cycle message as a parameter, if the actor terminates or restarts.</p>
<p>This possibility for self-watching can be useful to change the behavior of the actor in appropriate cases. The following code snippet shows how mixers can monitor themselves:</p>
<pre><span>val </span><span>monitoring</span>: PartialFunction[(ActorContext[Mix], Signal), Behavior[Mix]] = {<br/>  <span>case </span>(ctx, PostStop) =&gt;<br/>    ctx.log.info(<span>"PostStop {}"</span>, context.self)<br/>    Behaviors.<span>same<br/></span><span>  </span><span>case </span>(context, PreRestart) =&gt;<br/>    ctx.log.info(<span>"PreRestart {}"</span>, context.self)<br/>    Behaviors.<span>same<br/></span><span>  </span><span>case </span>(context, t: Terminated) =&gt;<br/>    ctx.log.info(<span>"Terminated {} while {}"</span>, context.self, t.failure)<br/>    Behaviors.<span>same<br/></span>}</pre>
<p>In our case, mixers just write into the log what kind of life-changing event had happened and keep the same behavior. To take a look at the situations in which <kbd>PostStop</kbd>, <kbd>PreRestart</kbd>, and <kbd>Terminated</kbd> events happen, we first need to become familiar with the concept of supervision.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Supervision</h1>
                </header>
            
            <article>
                
<p>In essence, supervision in Akka Typed refers to the fact that all exceptions thrown from a behavior are caught and acted upon. An action can have one of three forms: resume, restart, and stop.</p>
<p>Let's see how supervision can be defined and which effect it has.</p>
<p>First, let's run our system as it is and observe its output:</p>
<pre><strong>...</strong><br/><strong> [INFO] Opening Bakery</strong><br/><strong> [INFO] Go shopping to Actor[akka://Typed-Bakery/user/Seller#1376187311]</strong><br/><strong> [INFO] Mixing Groceries(13,650,130,65)</strong><br/><strong> [ERROR] [akka://Typed-Bakery/user/Chef/Mixer_5] null</strong><br/><strong>   ch12.Mixer$MotorOverheatException</strong><br/><strong>   at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:19)</strong><br/><strong>   at akka.actor.typed.internal.BehaviorImpl$ReceiveBehavior.receive(BehaviorImpl.scala:73)</strong><br/><strong>   ...</strong><br/><strong>   at java.lang.Thread.run(Thread.java:745)</strong><br/><strong>[INFO] PostStop Actor[akka://Typed-Bakery/user/Chef/Mixer_5#-1604172140]</strong><br/><strong> ...</strong></pre>
<p>We can see how our actors start processing messages up to the point where an exception is thrown by the <kbd>Mixer</kbd>. This exception is handled using the default supervision strategy that is stopping the actor. The mixer logs the <kbd>PostStop</kbd> event via the monitoring function we defined earlier and attaches it to the actor's behavior, like so:</p>
<pre><span>def </span>mix: Behavior[Mix] = Behaviors.<span>receive</span>[Mix] {<br/> ...<span><br/></span>}.receiveSignal(<span>monitoring</span>)</pre>
<p>Let's see what will happen if we override the default supervision strategy. To change the behavior, we just wrap it into the supervising behavior by using the standard constructor. Let's restart the mixer instead of stopping it in the case of the motor overheating:</p>
<pre><span>val </span><span>controlledMix</span>: Behavior[Mix] =<br/>  Behaviors<br/>    .<span>supervise</span>(<span>mix</span>)<br/>    .onFailure[MotorOverheatException](SupervisorStrategy.<span>restart</span>)</pre>
<p>If we use this behavior by using the <kbd>Chef</kbd> actor to create mixers, running the app will produce a slightly different output:</p>
<pre class="mce-root"><strong>...</strong><br/><strong> [INFO] Mixing Groceries(6,300,60,30)</strong><br/><strong> [ERROR] Supervisor [restart] saw failure: null</strong><br/><strong>    ch12.Mixer$MotorOverheatException</strong><br/><strong>    at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:29)</strong><br/><strong> ...</strong><br/><strong>[INFO] PreRestart Actor[akka://Typed-Bakery/user/Chef/Mixer_2#-1626989026]</strong><br/><strong> [INFO] PreRestart Actor[akka://Typed-Bakery/user/Chef/Mixer_4#-668414694]</strong><br/><strong> [INFO] PreRestart Actor[akka://Typed-Bakery/user/Chef/Mixer_4#-668414694]</strong></pre>
<p>Now, the exception has been reported by the supervisor and the mixers have been restarted, as we can conclude by observing the <kbd>PreRestart</kbd> events that have been logged by the mixers. There is no <kbd>PostStop</kbd> event here.</p>
<p>There is still one more supervision strategy to look at, so let's check it out:</p>
<pre><span>val </span><span>controlledMix</span>: Behavior[Mix] =<br/>  Behaviors<br/>    .<span>supervise</span>(<span>mix</span>)<br/>    .onFailure[MotorOverheatException](SupervisorStrategy.<span>resume</span>)</pre>
<p>With this strategy, we'll still see a log output from the supervisor, but actors won't log any life cycle events:</p>
<pre><strong>...</strong><br/><strong> [INFO] Mixing Groceries(5,250,50,25)</strong><br/><strong> [ERROR] Supervisor [resume] saw failure: null</strong><br/><strong>     ch12.Mixer$MotorOverheatException</strong><br/><strong>     at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:29)</strong><br/><strong> ...</strong></pre>
<p>It is possible to define different supervision strategies for different types of exceptions that are thrown by the same behavior by nesting supervisor constructors:</p>
<pre><span>val </span><span>controlledMix</span>: Behavior[Mix] =<br/>  Behaviors.<span>supervise</span>(<br/>  Behaviors.<span>supervise</span>(<br/>  Behaviors.<span>supervise</span>(<br/>          <span>mix</span>)          .onFailure[MotorOverheatException(SupervisorStrategy.<span>stop</span>))  .onFailure[SlowRotationSpeedException(SupervisorStrategy.<span>restart</span>))<br/>.onFailure[StrongVibrationException](SupervisorStrategy.<span>resume</span>)</pre>
<p>The definition is obviously a bit verbose.</p>
<p>The supervision strategies are sticky. They are recursively applied to new behaviors that are returned by the supervised behavior.</p>
<p>Sometimes, it might be useful to try and restart an actor a few times, and if the situation is not improving, then finally stop it. A special constructor is available for this:</p>
<pre>Behaviors.<span>supervise</span>(<span>mix</span>).onFailure[SlowRotationSpeedException](<br/>  SupervisorStrategy.<span>restartWithLimit</span>(<br/>    maxNrOfRetries = <span>4</span>, <br/>    withinTimeRange = <span>2</span>.seconds))</pre>
<p>In an unlucky case, the mixer actor would throw an exception from the <kbd>Behavior.setup</kbd> constructor every time it was constructed, and we would see the following output:</p>
<pre><strong>...</strong><br/><strong> [INFO] Mixing Groceries(6,300,60,30)</strong><br/><strong> [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null</strong><br/><strong> ch12.Mixer$MotorOverheatException</strong><br/><strong> at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:26)</strong><br/><strong> ...</strong><br/><strong> [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null</strong><br/><strong> ...</strong><br/><strong> [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null</strong><br/><strong> ...</strong><br/><strong> [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null</strong><br/><strong> ...</strong><br/><strong> [ERROR] [akka://Typed-Bakery/user/Chef/Mixer_1] null</strong><br/><strong> akka.actor.ActorInitializationException: akka://Typed-Bakery/user/Chef/Mixer_1: exception during creation at akka.actor.ActorInitializationException$.apply(Actor.scala:193)</strong><br/><strong> ...</strong><br/><strong> Caused by: ch12.Mixer$MotorOverheatException at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:26)</strong><br/><strong> ...</strong><br/><strong>[INFO] Message [ch12.Mixer$Mix] without sender to Actor[akka://Typed-Bakery/user/Chef/Mixer_1#-263229034] was not delivered.</strong></pre>
<p>The supervisor tried to restart the actor four times, but then gave up and stopped it. Because of the fact that the failure happened in the setup block, the actor was able to receive neither the <kbd>Mix</kbd> command nor life cycle event notifications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Watching an actor</h1>
                </header>
            
            <article>
                
<p>If we look back to the <kbd>Chef</kbd> actor's implementation, we'll be able to see that our system is now stuck. This happened because, if mixers fail, they are stopped by an external supervising force. However, the <kbd>Chef</kbd> actor is still waiting for this mixer's part to work. It turns out that we need a way to inform the <kbd>Chef</kbd> about terminated mixers.</p>
<p>Akka Typed offers a watching mechanism for this. To watch for mixers that were stopped, we'll add the following code to the <kbd>Chef</kbd>:</p>
<pre><span>val </span>mixers = <span>for </span>(i &lt;- <span>1 </span>to eggs) <br/>  <span>yield </span>context.spawn(Mixer.<span>controlledMix</span>, <span>s"Mixer_</span><span>$</span>i<span>"</span>)<br/>mixers.foreach(mixer =&gt; context.watchWith(mixer, <span>BrokenMixer</span>(mixer)))</pre>
<p class="mce-root">Here, for each spawned <kbd>Mixer</kbd>, we're calling <kbd>context.watchWith</kbd>. The first parameter is an actor to watch and the second parameter is a message adapter. The need for the message adapter comes from the fact that the <em>proper</em> message type for the terminated actor would be <kbd>akka.actor.typed.Terminated</kbd>. We could use a watch, taking just a single actor reference, to subscribe to this message type—<kbd>def watch[T](other: ActorRef[T]): Unit</kbd>.</p>
<p>But, the fact is that our <kbd>Chef</kbd> can't handle this message type because it does not belong to its <kbd>Command</kbd> type. Therefore, we would need to define a separate actor type to watch for mixer terminations. Instead, we need to use the <em>extended</em> version of the watch method, which takes a message to be sent as a second parameter. The <kbd>BrokenMixer</kbd> message is defined and handled as follows:</p>
<pre><span>case class </span>BrokenMixer(mixer: ActorRef[Mixer.Mix]) <span>extends </span>Command<br/><br/>def mixing(...): Behavior[Command] = Behaviors.receivePartial {<br/>      ...<br/>      case (context, BrokenMixer(m)) =&gt;<br/>        context.log.warning("Broken mixer detected {}", m)<br/>        context.self ! Collect(Dough(0), m)<br/>        Behaviors.same<br/>    }</pre>
<p>In this case, if we detect a terminated child actor, the <kbd>Chef</kbd> writes a log entry and sends itself a message to compensate for the lost part of the work. </p>
<p><span>Now, we have the <kbd>Dough</kbd> ready and need a <kbd>Cook</kbd> to form cookies and a <kbd>Baker</kbd> to bake them in the <kbd>Oven</kbd>. The implementation of the <kbd>Cook</kbd> is trivial—it just converts <kbd>Dough</kbd> into a number of <kbd>RawCookies</kbd> and sends them back to the manager. Please refer to the code in the GitHub repository if you're interested in the implementation details.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Timers</h1>
                </header>
            
            <article>
                
<p>The <kbd>Baker</kbd> is more interesting. First of all, it needs a single <kbd>Oven</kbd>. We'll implement this by using a special behavior that we'll execute only once:</p>
<pre><span>def </span>turnOvenOn: Behavior[Command] = Behaviors.<span>setup </span>{ context =&gt;<br/>  <span>val </span>oven = context.spawn(Oven.<span>empty</span>, <span>"Oven"</span>)<br/>  <span>idle</span>(oven)<br/>}</pre>
<p>Now, let's define the <kbd>idle</kbd> behavior that's just waiting for work:</p>
<pre><span>def </span>idle(oven: ActorRef[Oven.Command]): Behavior[Command] =<br/>  Behaviors.<span>receivePartial </span>{<br/>    <span>case </span>(context, <span>BakeCookies</span>(rawCookies, manager)) =&gt;<br/>      oven ! <span>Put</span>(rawCookies.count, context.self)<br/>      Behaviors.<span>withTimers </span>{ timers =&gt;<br/>        timers.startSingleTimer(<span>TimerKey</span>, CheckOven, <span>DefaultBakingTime</span>)<br/>        <span>baking</span>(oven, manager)<br/>      }<br/>  }</pre>
<p>Here, we expect a message from the manager telling us to bake cookies. Then, we use a new behavior constructor, <kbd>withTimers</kbd>, which gives us access to the <kbd>TimerScheduler</kbd>. With the scheduler, it is possible to define periodic and single timers that have been identified by some key. The definition of a new timer with the same key cancels the previously defined timer and also removes messages that have been sent by it, if they are still in the message box of the actor.</p>
<p>Here, we're using the timer as a kitchen clock to set up a single reminder to check the <kbd>Oven</kbd> after baking time passes. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stashing</h1>
                </header>
            
            <article>
                
<p><span>Another challenge is that the <kbd>Baker</kbd> needs to accept <kbd>RawCookies</kbd> from the <kbd>Manager</kbd> as required, but needs to bake them in batches because of the oven's limited capacity. Basically, it needs to manage a queue of the <kbd>RawCookies</kbd>.</span></p>
<p>We'll implement this by using a stash. By using stashing, our actor will buffer messages that cannot be handled by the current behavior and replay them before switching to the alternative behavior in which buffered messages are supposed to be handled.</p>
<p>Let's see how this approach is reflected in the baking behavior of the actor:</p>
<pre><span>def </span>baking(oven: ActorRef[Oven.Command],<br/>           manager: ActorRef[Manager.Command]): Behavior[Command] =<br/>  Behaviors.<span>setup</span>[Command] { context =&gt;<br/>    <span>val </span>buffer = <span>StashBuffer</span>[Command](capacity = <span>100</span>)<br/>    Behaviors.<span>receiveMessage </span>{<br/>      <span>case </span>CheckOven =&gt;<br/>        oven ! <span>Extract</span>(context.self)<br/>        Behaviors.<span>same<br/></span>      <span>case </span>c: TooManyCookies=&gt;<br/>        buffer.stash(<span>BakeCookies</span>(c.raw, manager))<br/>        Behaviors.<span>same<br/></span><span>      </span><span>case </span>c : BakeCookies =&gt;<br/>        buffer.stash(c)<br/>        Behaviors.<span>same<br/></span><span>      case CookiesReady(cookies) =&gt;<br/>        manager ! ReceiveReadyCookies(cookies)<br/>        buffer.unstashAll(context, idle(oven))<br/>    </span>}<br/>  }</pre>
<p>First, we define a buffer that will contain our stashed messages.</p>
<div class="packt_infobox">The stash is keeping messages in memory. By stashing too many messages, it is possible to crash the system with an <kbd>OutOfMemory</kbd> error. The capacity parameter helps to avoid this situation. But, in the case that the specified capacity is too low, the <span><kbd>StashOverflowException</kbd> will be thrown after an attempt to stash a message into the full buffer. </span></div>
<p>Then, we handle four types of messages. <kbd>CheckOven</kbd> is a reminder that is sent to the <kbd>Baker</kbd> by the timer so that it does not forget to extract cookies from the <kbd>Oven</kbd>.</p>
<p>In the case of <kbd>TooManyCookies</kbd> (which is a message from the <kbd>Oven</kbd> returning cookies that did not fit into it) or <kbd>BakeCookies</kbd> being received from the manager, the <kbd>Baker</kbd> stashes them until it becomes idle again and is able to process baking work.</p>
<p><kbd>CookiesReady</kbd> indicates that the <kbd>Oven</kbd> is now empty, so we forward the cookies to the <kbd>Manager</kbd>, unstash all of the messages, and go to the <kbd>idle</kbd> state. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Combining behaviors</h1>
                </header>
            
            <article>
                
<p>Now that we have defined every worker in the bakery, it is time to finally <span>get </span>us a <kbd>Manager</kbd>. In <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a><span>, <em>An Introduction to the Akka and Actor Models</em></span>, we implemented a <kbd>Manager</kbd> using the FSM library. In Akka Typed, we can achieve the same effect without any libraries just by defining atomic behaviors for each state and then returning the appropriate behavior as required:</p>
<pre><span>def </span>waitingForGroceries = <span>receiveMessagePartial</span>[Command] {<br/>  <span>case </span><span>ReceiveGroceries</span>(g) =&gt;<br/>    context.log.info(<span>"Mixing {}"</span>, g)<br/>    chef ! Chef.<span>Mix</span>(g, context.self)<br/>    waitingForPastry<br/>}<br/><span>def </span>waitingForPastry = <span>receiveMessagePartial</span>[Command] {<br/>  <span>case </span><span>ReceivePastry</span>(p) =&gt;<br/>    context.log.info(<span>"Forming {}"</span>, p)<br/>    cook ! Cook.<span>FormCookies</span>(p, context.self)<br/>    waitingForRawCookies<br/>}<br/>...</pre>
<p>Here, we have defined two behaviors, and each of them expects a specific message type, performs the required message passing to the managed actors, and returns the next behavior in the chain. This way, it is possible to model the serial behavior we implemented with untyped Akka. </p>
<p>However, we can do better. Akka Typed allows us to combine behaviors so that we can implement a parallel version of the <kbd>Manager</kbd> by chaining behaviors together and returning the combined behavior from every atomic behavior we define:</p>
<pre>def manage(chef: ActorRef[Chef.Command],<br/>           cook: ActorRef[Cook.FormCookies],<br/>           baker: ActorRef[Baker.Command]): Behavior[Command] =<br/>  ...<br/>  def sendBoyShopping = receiveMessagePartial ...<br/>  def waitingForGroceries = receivePartial[Command] {<br/>   ... <br/>   manage(chef, cook, baker)<br/>  }<br/>  def waitingForPastry = receiveMessagePartial[Command] {<br/>    ...<br/>    manage(chef, cook, baker)<br/>  }<br/>  def waitingForRawCookies = receiveMessagePartial[Command] {<br/>    case ReceiveRawCookies(c) =&gt;<br/>      baker ! Baker.BakeCookies(c, context.self)<br/>      manage(chef, cook, baker)<br/>  }<br/>  def waitingForReadyCookies = receiveMessagePartial[Command] {<br/>    case ReceiveReadyCookies(c) =&gt;<br/>      context.log.info("Done baking cookies: {}", c)<br/>      manage(chef, cook, baker)<br/>  }<br/><br/>  lookupSeller orElse<br/>    sendBoyShopping orElse<br/>    waitingForGroceries orElse<br/>    waitingForPastry orElse<br/>    waitingForRawCookies orElse<br/>    waitingForReadyCookies<br/>}</pre>
<p>Here, the <kbd>manage</kbd> constructor is used to define atomic behaviors for each message type the <kbd>Manager</kbd> is supposed to be able to handle. Then, the existing behaviors are combined into one. This makes our <kbd>Manager</kbd> capable of processing every message in any processing state.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cluster</h1>
                </header>
            
            <article>
                
<p>The <kbd>Bakery</kbd> is now in place, but we would still like the grocery store to run as a separate actor system, just like we had it in the previous chapter. With untyped Akka, we implemented this communication with the help of remoting, but remoting is not available in the typed setup. With Akka Typed, we can achieve this with the help of clustering.</p>
<p>Akka clustering is a group of Akka systems working as a dynamic whole. This is the main difference from Akka remote, on top of which clustering is built. A single system represents one node from the cluster. An actor can exist anywhere in the cluster. Some of the features of clustering include load balancing (routing messages to specific nodes in the cluster), node partitioning (assigning specific roles to nodes), and cluster management (fault-tolerant node membership), to name a few. In our example, we don't use any advanced clustering features, and instead just throw it in an order so that we have the possibility to communicate with a remote actor system.</p>
<p>To be able to use clustering in our project, we need to add the following dependency to <kbd>build.sbt</kbd>:</p>
<pre><span>"com.typesafe.akka" </span>%% <span>"akka-cluster-typed" </span>% akkaVersion,</pre>
<p>Clustering also requires that a few configuration parameters are defined. We can provide them by putting the following additional lines into <kbd>application.conf</kbd>. This will be the default configuration used by the <kbd>Bakery</kbd>:</p>
<pre>akka {<br/>  actor.provider = <span>"cluster"<br/></span><span>  </span>remote {<br/>    netty.tcp {<br/>      hostname = <span>"127.0.0.1"<br/></span><span>      </span>port = <span>2552<br/></span><span>    </span>}<br/>  }<br/>  cluster.seed-nodes = [<br/>    <span>"akka.tcp://Typed-Bakery@127.0.0.1:2553"</span>,<br/>    <span>"akka.tcp://Typed-Bakery@127.0.0.1:2552"<br/></span><span>  </span>]<br/>}</pre>
<p>The configuration for the <kbd><span>Store</span></kbd> is defined by importing the default configuration and overriding the port definition:</p>
<pre><span>include </span><span>"application"<br/></span>akka.remote.netty.tcp.port = <span>2553<br/></span></pre>
<p>Now, we need to instantiate an actor system for <kbd><span>Store</span></kbd>:</p>
<pre><span>object Store</span> <span>extends </span>App {<br/>  <span>val </span><span>config </span>= ConfigFactory.<span>load</span>(<span>"grocery.conf"</span>)<br/>  <span>val </span><span>system </span>= <span>ActorSystem</span>(<span>seller</span>, <span>"Typed-Bakery"</span>, <span>config</span>)<br/>}</pre>
<p>And we need another one for the <kbd>Bakery</kbd> itself:</p>
<pre><span>object </span>Bakery <span>extends </span>App {<br/>  ...<br/>  <span>val </span><span>system </span>= <span>ActorSystem</span>(Manager.<span>openBakery</span>, <span>"Typed-Bakery"</span>)<br/>}</pre>
<p>Both of these defined actor systems can now be started and will simulate baking cookies by acquiring the required resources from the remote system via clustering. </p>
<p>We just demonstrated Akka's location transparency by turning a local actor system into clustered one just by changing the configuration.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>Currently, we have a working <kbd>Bakery</kbd> implementation, but we cannot be sure that our actors are doing what we expect them to do. Let's fix this by testing their behavior.</p>
<p>Testing actors is notoriously difficult because of their concurrent nature and message orientation. Luckily, in Akka Typed, an actor's behavior is just a function and thus can generally be tested in isolation. There are cases where we might want to test the interaction between actors, and in this case, it is inevitable to resort to asynchronous testing.</p>
<p>In synchronous setup, we create a behavior under test, send events that it should be able to react on, and verify that the behavior produces the expected effects (for example, spawning or stopping child actors) and sends further required messages.</p>
<p>The asynchronous scenario brings this approach into the context of a test actor system, which is close to a real one. We will see how this is done in practice in a moment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependencies and setup</h1>
                </header>
            
            <article>
                
<p>To automate repetitive tasks such as setting up testing environments for actors, Akka Typed provides a test kit in the same way Akka untyped does. We need the following dependencies to be present in <kbd>build.sbt</kbd> so that we can <span>use it within our project:</span></p>
<pre><span>"com.typesafe.akka" </span>%% <span>"akka-actor-testkit-typed" </span>% akkaVersion % <span>Test</span>,<br/><span>"org.scalatest" </span>%% <span>"scalatest" </span>% <span>"3.0.5" </span>% <span>Test<br/></span></pre>
<p>Having both of them in scope will allow us to create <kbd>ScalaTest</kbd> specifications and use the Akka Typed test kit functionality.</p>
<p>As mentioned previously, in regards to synchronous actor testing, we do not need to have an <kbd>ActorSystem</kbd>. The only dependency, in this case, is an actor context. Akka provides a factory for building special testing actor contexts in the form of the <kbd>BehaviorTestKit</kbd>. A skeleton of the <kbd>ScalaTest</kbd> specification, in this case, could look as follows:</p>
<pre><span>import </span>akka.actor.testkit.typed.scaladsl.BehaviorTestKit<br/><span>import </span>org.scalatest.WordSpec<br/><br/><span>class </span>SynchronousSpec <span>extends </span>WordSpec {<br/><br/>  <span>"TestScenario" </span>should {<br/>    <span>"have test conditions" </span>in {<br/>      <span>val </span>testKit = <span>BehaviorTestKit</span>(behaviorToTest)<br/>      // ... testing logic<br/>    }<br/>  }<br/>}</pre>
<p>In the case of asynchronous testing, we have to extend the <kbd>ActorTestKit</kbd> to have a test actor system in the scope of the specification. This actor system needs to be shut down after all tests are finished running in order to prevent resource leakage. Because of this, the minimal specification in the case of asynchronous testing will look a bit more involved:</p>
<pre><span>class </span>AsyncronousSpec <span>extends </span>WordSpec <span>with </span>ActorTestKit <span>with </span>BeforeAndAfterAll {<br/><br/>  <span>override def </span>afterAll: Unit = shutdownTestKit()<br/>  <br/>  // actual testing code<br/>}</pre>
<p>Now, it is time to look at the different features Akka <kbd>TestKit</kbd> has to offer to simplify checking the correctness of the actor-based system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Synchronous testing</h1>
                </header>
            
            <article>
                
<p>The <span><kbd>BehaviorTestKit</kbd> provides the possibility to verify the reaction of an actor behavior to specific messages. The reaction can be in the form of an <kbd>Effect</kbd> (different ways of spawning and stopping children actors), sending and receiving messages, and changes in behavior. Let's illustrate this testing process with an example:</span></p>
<pre><span>"The boy should" </span>should {<br/>  <span>"forward given ShoppingList to the seller" </span>in {<br/>    <span>val </span>testKit = <span>BehaviorTestKit</span>(Boy.<span>goShopping</span>)<br/>    <span>val </span>seller = <span>TestInbox</span>[Shop.SellByList]()<br/>    <span>val </span>manager = <span>TestInbox</span>[Manager.Command]()<br/>    <span>val </span>list = <span>ShoppingList</span>(<span>1</span>, <span>1</span>, <span>1</span>, <span>1</span>)<br/>    testKit.run(<span>GoShopping</span>(list, seller.ref, manager.ref))<br/>    seller.expectMessage(<span>SellByList</span>(list, manager.ref))<br/>    assert(!testKit.isAlive)<br/>    testKit.expectEffect(NoEffects)<br/>  }<br/>}</pre>
<p>Here, we have wrapped a <kbd>goShopping</kbd> behavior into the <kbd>BehaviorTestKit</kbd> so that we can test it synchronously. The two <kbd>TestInbox</kbd> references represent actors that the <kbd>Boy</kbd> is supposed to communicate with. They are basically <kbd>ActorRefs</kbd>, but they allow us to express expectations regarding incoming messages. To trigger the test, we can create a message and run the <kbd>testKit</kbd> using this message as an input.</p>
<p>In the next line, we expect the <kbd>seller</kbd> actor to receive the same message, with the <kbd>manager</kbd> reference being propagated as a sender. This is how our boy's logic is supposed to work. Then, we verify that the <kbd>Boy</kbd> stopped itself by checking that it is not alive. Finally, we don't expect any effects on children as the <kbd>Boy</kbd> actor is not supposed to have or create any children.</p>
<p>In the same way that we tested that the <kbd>Boy</kbd> has no effects on children, we can test that the <kbd>Chef</kbd> has such effects:</p>
<pre><span>"The chef should" </span>should {<br/>  <span>"create and destroy mixers as required" </span>in {<br/><span>    </span><span>val </span>mixerFactory = Mixer.<span>mix</span>(<span>0 </span>seconds)<br/>    <span>val </span>chef = <span>BehaviorTestKit</span>(Chef.<span>idle</span>(mixerFactory))<br/>    <span>val </span>manager = <span>TestInbox</span>[Manager.Command]()<br/>    <span>val </span>message = <span>Mix</span>(<span>Groceries</span>(<span>1</span>, <span>1</span>, <span>1</span>, <span>1</span>), manager.ref)<br/>    val dispatcher = DispatcherSelector.fromConfig("mixers-dispatcher")<br/>    chef.run(message)<br/>    chef.expectEffect(<span>Spawned</span>(mixerFactory, <span>"Mixer_1"</span>, dispatcher))<br/>    <span>val </span>expectedByMixer = Mixer.<span>Mix</span>(<span>Groceries</span>(<span>1</span>, <span>1</span>, <span>1</span>, <span>1</span>), chef.ref)<br/>    chef.childInbox(<span>"Mixer_1"</span>).expectMessage(expectedByMixer)<br/>  }<br/>}</pre>
<p>In this test, we create a behavior under test in the same way we just did with the <kbd>Boy</kbd> actor. We create a message and run it with the testing behavior wrapper. As a result, we expect a <kbd>chef</kbd> to have the effect of spawning a single <kbd>Mixer</kbd> actor with an appropriate name and dispatcher. Finally, we're looking up the mailbox of the spawned child actor by using the <kbd>childInbox</kbd> method and expect it to have a message that's been sent by the <kbd>chef</kbd> to be present in it.</p>
<p>Unfortunately, at the time of writing this book, the Akka <kbd>TestKist</kbd> still has some rough edges that require us, in this specific case, to refactor our <kbd>Chef</kbd> behavior to accept the mixer factory as a parameter. The reason for this is that behaviors are compared by reference, which requires us to have the same instance of the behavior for the test to pass.</p>
<p>Another limitation of the <kbd>BehaviorTestKit</kbd> is its lack of support for extensions like cluster, cluster singleton, distributed data, and receptionist. This makes it impossible to test the <kbd>Seller</kbd> actor in a synchronous setup because this actor registers itself with the <kbd>receptionist</kbd>:</p>
<pre>context.system.receptionist ! <span>Register</span>(<span>SellerKey</span>, context.self)</pre>
<p>We could use the synchronous approach or we could refactor the seller to take a constructor function for the receptionist and provide a mock receptionist in the test. This is an example of how this can be done in the code of the <kbd>Seller</kbd>:</p>
<pre><span>type </span><span>ReceptionistFactory </span>= ActorContext[SellByList] =&gt; ActorRef[Receptionist.Command]<br/><span>val </span><span>systemReceptionist</span>: <span>ReceptionistFactory </span>= _.system.receptionist<br/><span>def </span>seller(receptionist: <span>ReceptionistFactory</span>) = setup { ctx ⇒<br/>    receptionist(ctx) ! Register(SellerKey, ctx.self)<br/>...</pre>
<p>The factory is just a function from <kbd>ActorContext</kbd> to the <kbd>ActorRef</kbd> with the appropriate types.</p>
<p>With this change, we can implement our test, as follows:</p>
<pre><span>"A seller in the shop" </span>should {<br/>  <span>"return groceries if given a shopping list" </span>in {<br/>    <span>val </span>receptionist = <span>TestInbox</span>[Receptionist.Command]()<br/>    <span>val </span>mockReceptionist: Shop.<span>ReceptionistFactory </span>= _ =&gt; receptionist.ref<br/>    <span>val </span>seller = <span>BehaviorTestKit</span>(Shop.<span>seller</span>(mockReceptionist))<br/>    <span>val </span>inbox = <span>TestInbox</span>[Manager.Command]()<br/>    <span>val </span>message = <span>ShoppingList</span>(<span>1</span>,<span>1</span>,<span>1</span>,<span>1</span>)<br/>    seller.run(<span>SellByList</span>(message, inbox.ref))<br/>    inbox.expectMessage(<span>ReceiveGroceries</span>(<span>Groceries</span>(<span>1</span>, <span>1</span>, <span>1</span>, <span>1</span>)))<br/>    receptionist.expectMessage(<span>Register</span>(Shop.<span>SellerKey</span>, seller.ref))<br/>    seller.expectEffect(NoEffects)<br/>  }<br/>}</pre>
<p>We provide a mock receptionist which is just a <kbd>TestInbox[Receptionist.Command]</kbd> and use it as the result of the factory, ignoring the actual actor context. Then, we execute the test as we did previously and expect the messages to be sent to the <kbd>manager</kbd> and <kbd>receptionist</kbd> appropriately. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Asynchronous testing</h1>
                </header>
            
            <article>
                
<p>Synchronous testing is a good and deterministic way to test actor logic, but sometimes it is just not enough, for example, when testing specific aspects of communication between actors. Another example is having asynchronous code in the actor's behavior, for example, <kbd>Feature</kbd> or scheduler, which needs to be finished before test assertions can be executed.</p>
<p>One example of such a situation is the <kbd>Baker</kbd> actor. We expect it to check the <kbd>Oven</kbd> after some predefined time interval. Unfortunately, this interval is hardcoded, so there is no possibility of being able to override it in the test and we need to wait for the timer to trigger.</p>
<p>As part of the asynchronous testing toolkit, Akka provides a <kbd>ManualTimer</kbd>, which can be used to advance time in tests in a flexible manner. We'll use it to reliably test our <kbd>Baker</kbd> actor.</p>
<p>First, we need to provide an appropriate configuration for the manual timer. We do this by overriding the <kbd>config</kbd> method of the actor system which is represented by the <kbd>ActorTestKit</kbd> and define an instance of the time we'll use in our test:</p>
<pre><span>override def </span>config: Config = ManualTime.<span>config<br/></span><span>val </span><span>manualTime</span>: ManualTime = <span>ManualTime</span>()</pre>
<p>Now, we can specify the testing logic:</p>
<pre><span>"The baker should" </span>should {<br/>  <span>"bake cookies in batches" </span>in {<br/>    <span>val </span>oven = <span>TestProbe</span>[Oven.Command]()<br/>    <span>val </span>manager = <span>TestInbox</span>[Manager.Command]()<br/>    <span>val </span>baker = spawn(Baker.<span>idle</span>(oven.ref))<br/>    baker ! <span>BakeCookies</span>(<span>RawCookies</span>(<span>1</span>), manager.ref)<br/>    oven.expectMessage(Oven.<span>Put</span>(<span>1</span>, baker))<br/>    val justBeforeDone = DefaultBakingTime - 1.millisecond<br/>    <span>manualTime</span>.expectNoMessageFor(justBeforeDone, oven)<br/>    <span>manualTime</span>.timePasses(<span>DefaultBakingTime</span>)<br/>    oven.expectMessage(<span>Extract</span>(baker))<br/>  }<br/>}</pre>
<p>In this scenario,  we create an <kbd>oven</kbd> and a <kbd>manager</kbd> using <kbd>TestProbe</kbd> (as opposed to the <kbd>TestInbox</kbd> we used before) and also a <kbd>baker</kbd> behavior using the <kbd>spawn</kbd> method of the <kbd>ActorTestKit</kbd>. We send a request to the <kbd>baker</kbd> and expect it to react appropriately by putting a single cookie into the oven.</p>
<p>Next, we can see that the <kbd>baker</kbd> waits for the cookies to be ready by checking that no messages are sent during this period of time. We're using the annual time here, and because of this, the check itself is done instantly. Finally, we manually advance the timer so that the <kbd>baker</kbd> needs to extract the cookies from the oven and verify that this has indeed happened, and that the <kbd>oven</kbd> received the <kbd>Extract</kbd> message as expected.</p>
<p>The application has been successfully tested; let's wait no more and run it!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Please refer to <a href="bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml">Appendix A</a>, <em>Preparing the Environment and Running Code Samples</em>, if you don't have Java and SBT installed yet.</p>
<p>We will run our application in the Terminal in the same way as we did in the previous chapter by using two separate terminal sessions for <kbd>Store</kbd> and <kbd>Bakery</kbd>. It is possible to run both in interactive mode, or by issuing one of the two following commands in the corresponding shell:</p>
<pre>sbt "runMain ch12.Store"<br/> sbt "runMain ch12.Bakery"</pre>
<p>Because we're using clustering instead of remoting for our example, we don't need to start them in a particular order as we had to in the previous chapter. The following screenshot shows two Terminal windows ready to run the application with the aforementioned commands typed in:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5e6f8daa-7acc-4b5f-b97b-5634362a35d8.png" width="1950" height="100"/></p>
<p>As both parts of the application start, they will establish a connection and start to work together to produce cookies. The following screenshot shows us that the bakery part of the application is already running and waiting for the store to start on the right-hand side of the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/983c3c61-8573-4c06-849d-dac0e4829373.png" width="1950" height="1031"/></p>
<p>If you'd like to start the demo in interactive mode from the SBT shell, please refer to <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a><span>, </span><em>An Introduction to the Akka and Actor Models</em>, where we explained how to do this in detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Akka Typed allows you to implement an actor system in a type-safe way. It represents actor logic as a well-typed behavior with the types of both input and output channels determined at compile time. Behaviors can be combined together, allowing for a higher degree of code reuse.</p>
<p>Typed actors are not only supposed to receive and send messages but are also required to explicitly define a new behavior after processing every message. Interactions with other actors are limited to creating, stopping, looking up, and watching children, and getting typed references to explicitly registered services.</p>
<p>Actor context provides useful functionality, such as timers and stashing.</p>
<p>Typed supervision is defined directly on behavior, and the failure propagation to the parent actor must be implemented explicitly <span>if needed</span>. The Akka team took a holistic approach by promoting an actor's life cycle hooks, from methods to events.</p>
<p>Actors in typed Akka are basically just functions. Because of this, testing is not limited to<span class="Apple-converted-space"> </span>asynchronous communication as it was before. This can be done synchronously, thus allowing for deterministic and stable test code that executes quickly.</p>
<p>Akka Typed offers a set of useful extensions like cluster, cluster singleton, persistence, and distributed data. We touched briefly upon how the cluster module allows us to utilize the existing code in a distributed scenario by solely changing the configuration of the system. Please refer to the Akka Typed official documentation online (<a href="https://doc.akka.io/docs/akka/current/typed/index.html">https://doc.akka.io/docs/akka/current/typed/index.html</a>)  to explore further capabilities provided by the typed actor's toolkit.</p>
<p>In the next chapter, we're going to implement the bakery once again, this time using yet another Akka library—Akka Streams.</p>


            </article>

            
        </section>
    </div>



  </body></html>