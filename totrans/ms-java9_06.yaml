- en: Experimenting with the Java Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored how to migrate pre-Java 9 applications
    to the new Java platform. We examined several issues that might cause your current
    applications to have problems running on Java 9\. We started with a review of
    Project Jigsaw and then looked at how modules fit into the new Java platform.
    We provided you with insights and processes to get your Java 8 code working with
    Java 9\. Specifically, we provided tips for migration planning, shared advice
    from Oracle regarding migration, and shared tools that you can use to help you
    as you get started with Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take our first look at the new command line, **read-eval-print
    loop** (also referred to as **REPL**) tool in Java 9, the **Java Shell** (**JShell**).
    We will start with introductory information regarding the tool, the read-eval-print
    loop concept, and move into the commands and command-line options for use with
    JShell. We will take a practitioner's approach to our review of the Java Shell
    and include examples you can try on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is JShell?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical uses of JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is JShell?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JShell is a new tool introduced with Java 9\. It is an interactive read-eval-print
    loop tool that is used to evaluate the following Java programming language components--declarations,
    statements, and expressions. It has its own API so that it can be used by external
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Read-Eval-Print Loop is often referred to as REPL, taking the first letter from
    each word in the phrase. It is also knows language shell or interactive top-level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The introduction of JShell was a result of **Java Enhancement Program** (**JEP**)
    222\. Here are the stated goals of this JEP in regards to the Java Shell command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Facilitate rapid investigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitate rapid coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an edit history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rapid investigation and coding listed previously includes statements and
    expressions. Impressively, these statements and expressions do not need to be
    part of a method. Furthermore, variables and methods are not required to be part
    of a class, making this tool especially dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the following listed features were included to make JShell much
    easier to use and to make your time using JShell as time-efficient as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Tab-completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-completion for end-of-statement semicolons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-completion for imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-completion for definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started with JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JShell is a command-line tool that is located in the `/bin` folder. The syntax
    for this tool is `jshell <options> <load files>`. As you can see here, there are
    several options that can be used with this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79170c70-1fa1-4f3b-a6c0-61566af67576.png)'
  prefs: []
  type: TYPE_IMG
- en: You have already seen the `-h` option, that we executed with `jshell -h`. This
    provided the listing of JShell options.
  prefs: []
  type: TYPE_NORMAL
- en: 'To log into your JShell, you simply use the `jshell` command. You will see
    that the prompt in the command window changes accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a06a27e-8f36-4fcd-8fde-1573ac2a19e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Exiting the shell is as easy as entering `/exit`. Once inside the JShell, you
    can enter any of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Functionality** |'
  prefs: []
  type: TYPE_TB
- en: '| `/drop` | Use this command to delete a source entry that is referenced by
    `name` or `id`. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/edit` | With this command, you can edit a source entry using a `name` or
    `id` reference. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/env` | This powerful command allows you to view or change the evaluation
    context. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/exit` | This command is used to exit the JShell. The syntax is simply `/exit`
    without any options or parameters available. |'
  prefs: []
  type: TYPE_TB
- en: '| `/history` | The history command provides a history of what you have typed.
    The syntax is simply `/history` without any options or parameters available. |'
  prefs: []
  type: TYPE_TB
- en: '| `/<id>` | This command is used to rerun a previous snippet by referencing
    the `id`. Here is the syntax: `/<id>`You can also run a specific snippet by referencing
    the *n*^(th) previous snippet with `/-<n>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `/imports` | You can use this command to list the imported items. The syntax
    is `/imports` and it does not accept any options or parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `/list` | This command will list the source you typed. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/methods` | This command lists all declared methods as well as their signatures.
    Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/open` | Using this command, you can open a file as source input. Here is
    the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/reload` | The reload command gives you the ability to reset and replay
    relevant history. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/reset` | This command resets the JShell. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/save` | This command saves the snippet source to a file specified by you.
    Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/set` | This command is used to set the JShell configuration information.
    Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/types` | This command simply lists declared types. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/vars` | This command lists all declared variables as well as their values.
    Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/!` | This command will rerun the last snippet. The syntax is simply `/!`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Several of the previously listed commands use the term **snippet**. In the
    context of Java 9 and JShell, a snippet is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '- ClassDeclaration'
  prefs: []
  type: TYPE_NORMAL
- en: '- Expression'
  prefs: []
  type: TYPE_NORMAL
- en: '- FieldDeclaration'
  prefs: []
  type: TYPE_NORMAL
- en: '- ImportDeclaration'
  prefs: []
  type: TYPE_NORMAL
- en: '- InterfaceDeclaration'
  prefs: []
  type: TYPE_NORMAL
- en: '- MethodDeclaration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering the `/help` or `/?` command in the JShell provides a complete list
    of commands and syntax that can be used in the shell. That list is provided as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74b0198b-5ff2-4ce2-8614-755ededffdcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `/help` command can be especially helpful if you are still new to JShell.
    As you can see in the following screenshot, we can obtain an introduction to JShell
    by simply entering the `/help intro` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74ab00b5-f43f-41f9-a5b4-7572ea599217.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you find yourself using JShell often you might benefit from one or more
    of the following listed shortcuts. These can be listed at any time from within
    JShell by using the `/help shortcuts` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef5d4a71-3e70-409b-b616-c12b64b82889.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additional help can be obtained from within the JShell by using the `/help`
    command followed by the command you want additional help on. For example, entering
    `/help reload` provides detailed information regarding the `/reload` command.
    That information is provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3911d74-214e-4f95-91c8-6bce2c1e4dc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Practical uses of JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether you are a new or seasoned developer or just new to Java, you are bound
    to find the JShell very useful. In this section, we will look at some practical
    uses of JShell. Specifically, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Feedback modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing your assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing in the JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feedback modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-line tools usually provide relatively sparse feedback in an effort to
    not overcrowd the screen or otherwise become a nuisance to developers. JShell
    has several feedback modes in addition to giving developers the ability to create
    their own custom modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following screenshot, there are four feedback modes--`concise`,
    `normal`, `silent`, and `verbose`. Here, we entered the `/set feedback` command
    without any parameters to list the feedback modes as well as to identify what
    the current feedback mode is. The first line of output displays the command-line
    command and argument set that would be used to set the mode to the currently set
    mode. So, in the following screenshot, the current feedback mode is set to `verbose`
    and the other three modes are listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dddc60ca-7c07-4686-9145-f8c900e3de1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can dictate which mode we want to enter when we first enter JShell by including
    an option when we launch JShell. Here are the command-line options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command-line command and option** | **Feedback mode** |'
  prefs: []
  type: TYPE_TB
- en: '| `jshell -q` | `concise` |'
  prefs: []
  type: TYPE_TB
- en: '| `jshell -n` | `normal` |'
  prefs: []
  type: TYPE_TB
- en: '| `jshell -s` | `silent` |'
  prefs: []
  type: TYPE_TB
- en: '| `jshell -v` | `verbose` |'
  prefs: []
  type: TYPE_TB
- en: You will notice that we use `-q` for `concise` mode instead of `-c`. The `-c`
    option has the `-c<flag>` syntax and is used to pass `<flag>` to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to review the differences between the feedback modes is to use
    examples. Starting with the `normal` mode, we will execute command-line commands
    to accomplish the following ordered feedback demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the variable's value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start our first test, we will execute the `/set feedback normal` command
    at the `jshell>` prompt, which sets the JShell feedback mode to `normal`. After
    entering the `normal` feedback mode, we will enter the necessary commands to run
    our demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da31124e-cf8d-42f5-86c7-34320be3a32f.png)'
  prefs: []
  type: TYPE_IMG
- en: After entering `normal` feedback mode, we entered `int myVar = 3` to and received
    `myVar ==> 3` as feedback. In our next command, we changed the value of the same
    variable and received the same output with the new value. Our next statement,
    `void quickMath() {System.out.println("Your result is " + (x*30 + 19));}`, used
    a variable that was not declared and you see the resulting two-part feedback--one
    part indicating that the method was created and the other to inform that the method
    cannot be invoked until the undeclared variable is declared. Next, we changed
    our method to include the `myVar` variable and the feedback reported that the
    method was modified. Our last step was to run the method using `quickMath();`
    and the results are as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this same feedback demonstration in `concise` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/607d40d3-e5c6-42c5-9c77-db99bcf36dc6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, the `concise` feedback mode provides
    us with much less feedback. We created and modified the variables and received
    no feedback. When we created the method with an undeclared variable, we received
    the same feedback that we did in `normal` mode. We updated the method without
    confirmation or other feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next use of the feedback demonstration will be in `silent` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a36a879b-5760-41b5-baf6-59f858aa81cd.png)'
  prefs: []
  type: TYPE_IMG
- en: When we entered `silent` feedback mode, as you can see in the preceding screenshot,
    the JShell prompt changed from `jshell>` to `->`. There was no feedback provided
    when we created the `myVar` variable, modified the `myVar` variable, or created
    the `quickMath()` method. We intentionally created the `quickMath()` method to
    use an undeclared variable. Because we were in `silent` feedback mode, we were
    not informed that the method had an undeclared variable. Based on this lack of
    feedback, we ran the method and were not provided any output or feedback. Next,
    we updated the method to include the `myVar` declared variable and then ran the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `silent` feedback mode might seem pointless as no feedback is provided,
    but there is a great utility with this mode. Using the `silent` mode might be
    appropriate for pipelining or simply when you want to minimize the amount of terminal
    output. You can include specific, conditional, outputs with implicit `System.out.println`
    commands, as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last use of the feedback demonstration is in `verbose` feedback mode. This
    feedback mode, as you would assume from its name, provides the most amount of
    feedback. Here are our test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2247bbaf-0d96-46df-bf51-ca9af8e428ed.png)'
  prefs: []
  type: TYPE_IMG
- en: In our feedback demonstration, using `verbose` feedback mode, we receive a bit
    more feedback as well as a nicer format for the feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom feedback mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the internal feedback modes (`normal`, `concise`, `silent`, and `verbose`)
    cannot be modified, you can create your own custom feedback mode. The first step
    in this process is to copy an existing mode. The following example demonstrates
    how to copy the `verbose` mode to a `myCustom` mode with the `/set mode myCustom
    verbose -command` command string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bda794ab-e212-4f42-809e-aca69f132974.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We used the `-command` option to ensure we would receive the command feedback.
    You can make various changes to your feedback mode using the `/set` command along
    with one of the options listed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8d25f6c-3c92-4e9c-9bf5-2ed9e704d056.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As an example, let''s walk through the truncation setting that mandates how
    many characters are displayed on each output line. Using the `/set truncation`
    command, as illustrated in the following screenshot, shows the current truncation
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15b9336e-af3a-4bc5-888b-044067fc108d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our `myCustom` feedback mode has a truncation of `80`. We will
    change that to `60` with the `/set truncation myCustom 60` command and then use
    the `/set truncation` command for verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b50e340c-6e9a-4a4d-a410-c95a394eb919.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the previous screenshot, the truncation for our `myCustom`
    feedback mode was successfully changed from the `80` inherited from the `verbose`
    mode to `60`, based on our use of the `/set truncation myCustom 60` JShell command.
  prefs: []
  type: TYPE_NORMAL
- en: Listing your assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few JShell commands that are convenient for listing assets that
    you have created. Using the feedback demonstration from the previous section,
    we executed the `/vars,` `/methods`, and `/list` commands to provide a list of
    variables, methods, and all sources respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1153ebd7-03ec-4b23-b70c-08296217bf83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the `/list -all` command and option combination to see what
    packages the JShell imported. As you can see in the following screenshot, JShell
    imported several packages that make our work within the shell more convenient,
    saving us time from having to import these standard packages in our methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af691bad-e276-4b12-9f96-5d6bcae6c00c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you just want to list the startup imports, you can use the `/list -start`
    command and option combination. As you can see in the following screenshot, each
    start up import has an "`s`" prefix and is numerically ordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10654dec-f7f3-4329-83ef-62abc5eb3550.png)'
  prefs: []
  type: TYPE_IMG
- en: Editing in the JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JShell is not a full-featured text editor, but there are several things you
    can do within the shell. This section provides you with the editing techniques
    grouped into modifying text, basic navigation, historical navigation, and advanced
    editing commands.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default text edit/entry mode is that the text you type will appear at the
    current cursor position. You have several options available to you when you want
    to delete text. Here is a complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Delete action** | **PC keyboard combination** | **Mac keyboard combination**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Delete the character at the current cursor location | *Delete* | *Delete*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Delete the character to the left of the cursor | *Backspace* | *Backspace*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Delete the text from the cursor location to the end of the line | *Ctrl*
    + *K* | *Cmd* + *K* |'
  prefs: []
  type: TYPE_TB
- en: '| Delete the text from the cursor location to the end of the current word |
    *Alt* + *D* | *Alt*/*Opt* + *D* |'
  prefs: []
  type: TYPE_TB
- en: '| Delete from the cursor location to the previous white space | *Ctrl* + *W*
    | *Cmd* + *W* |'
  prefs: []
  type: TYPE_TB
- en: '| Paste the most recently deleted text at the cursor location | *Ctrl* + *Y*
    | *Cmd* + *Y* |'
  prefs: []
  type: TYPE_TB
- en: '| When the *Ctrl* + *Y* (or *Cmd* + *Y* on Mac) is used, you will be able to
    use the *Alt* + *Y* keyboard combination to cycle through previously deleted text
    | *Alt* + *Y* | *Alt*/*Opt* + *Y* |'
  prefs: []
  type: TYPE_TB
- en: Basic navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While navigational control inside the JShell is similar to most command-line
    editors, it is helpful to have a list of basic navigational controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key/Key combination** | **Navigation action** |'
  prefs: []
  type: TYPE_TB
- en: '| *Left arrow* | Move backward one character |'
  prefs: []
  type: TYPE_TB
- en: '| *Right arrow* | Move forward one character |'
  prefs: []
  type: TYPE_TB
- en: '| *Up arrow* | Move up one line through history |'
  prefs: []
  type: TYPE_TB
- en: '| *Down arrow* | Move down one line forward through history |'
  prefs: []
  type: TYPE_TB
- en: '| *Return* | Enter (submit) the current line |'
  prefs: []
  type: TYPE_TB
- en: '| *Ctrl* + *A* (c*md* - *A* on Mac) | Jump to the beginning of the current
    line |'
  prefs: []
  type: TYPE_TB
- en: '| *Ctrl* + *E* (c*md* - *E* on Mac) | Jump to the end of the current line |'
  prefs: []
  type: TYPE_TB
- en: '| *Alt* + *B* | Jump back one word |'
  prefs: []
  type: TYPE_TB
- en: '| *Alt* + *F* | Jump forward one word |'
  prefs: []
  type: TYPE_TB
- en: Historical navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JShell remembers the snippets and commands that you enter. It maintains this
    history so that you can reuse snippets and commands you already entered. To cycle
    through snippets and commands, you can hold down the *Ctrl* key (c*md* on Mac)
    and then use the up and down arrow keys until you see the snippet or command you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced editing commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several more editing options to include search functionality, macros
    creation and use, and more. JShell''s editor is based on JLine2, a Java library
    for parsing console input and editing. You can learn more about JLine2 at this
    URL: [https://github.com/jline/jline2/wiki/JLine-2.x-Wiki](https://github.com/jline/jline2/wiki/JLine-2.x-Wiki).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, you have entered data directly into JShell from the keyboard.
    You also have the ability to work with JShell scripts which are a sequence of
    JShell commands and snippets. The format is the same as other scripting formats
    with one command per line.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at start up scripts, examine how to load scripts,
    how to save scripts, and then end with a look at advanced scripting with JShell.
  prefs: []
  type: TYPE_NORMAL
- en: Start up scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each time the JShell is launched, the start up scripts are loaded. This also
    occurs each time the `/reset`, `/reload`, and `/env` commands are used.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the DEFAULT start up script is used by JShell. If you want to use
    a different start up script, you merely need to use the `/set start <script>`
    command. Here is an example--`/set start MyStartupScript.jsh`. Alternatively,
    you can use the `jshell --start MyStartupScript.jsh` command at the Command Prompt
    to launch JShell and load the `MyStartupScript.jsh` JShell start up script.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `/set start <script>` command with the `-retain` option, you
    are telling JShell to use the new start up script the next time you launch JShell.
  prefs: []
  type: TYPE_NORMAL
- en: Loading scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loading scripts in the JShell can be accomplished with one of the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `/open` command along with the name of the script as a parameter.
    For example, if our script name is `MyScript`, we would use `/open MyScript`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second option for loading scripts is to use the `jshell MyScript.jsh` at the
    Command Prompt. This will launch JShell and load the `MyScript.jsh` JShell script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to creating JShell scripts in external editors, we can create them
    within the JShell environment as well. When taking this approach, you will need
    to use the `/save` command to save your scripts. As you can see in the following
    screenshot, the `/save` command requires, at a minimum, a file name argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/def4106e-dc00-4d62-9dea-cb861036220a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three options available to you with the `/save` command:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-all` option can be used to save the source of all snippets to the specified
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-history` option saves a sequential history of all commands and snippets
    you entered since JShell was launched. JShell's ability to perform this operation
    informs you that it maintains a history of everything you enter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-start` option saves the current start up definitions to the specified
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced scripting with JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the limits of JShell? There is so much you can do with this tool, and
    you are virtually only limited by your imagination and programming abilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an advanced code base that can be used to compile and run Java
    programs from a JShell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see with this script, we created a `runSomeProcess()` method and
    can use it to explicitly compile and run external Java files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined JShell, Java 9's new read-eval-print loop command-line
    tool. We started with introductory information regarding the tool and looked closely
    at the read-eval-print loop concept. We spent considerable time reviewing JShell
    commands and command-line options. Our coverage included practical guides to feedback
    modes, asset listing, and editing in the shell. We also gained experience working
    with scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at Java 9's new default garbage collector.
    Specifically, we will look at the default garbage collection, depreciated garbage
    collection combinations, and examine garbage collection logging.
  prefs: []
  type: TYPE_NORMAL
