<html><head></head><body>
<div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.2.1">Contexts and Dependency Injection</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Contexts and Dependency Injection</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.5.1">CDI</span></strong><span class="koboSpan" id="kobo.6.1">) is a </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.7.1">powerful dependency injection framework that allows us to easily integrate different parts of our Jakarta EE applications. </span><span class="koboSpan" id="kobo.7.2">CDI beans can have different scopes, allowing their life cycle to be managed automatically by the Jakarta EE runtime. </span><span class="koboSpan" id="kobo.7.3">They can be easily injected as dependencies by using a simple annotation. </span><span class="koboSpan" id="kobo.7.4">CDI also includes an event mechanism to allow decoupled communication between different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Named beans</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Dependency injection</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Qualifiers</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">CDI </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">bean scopes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">CDI events</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.17.1">CDI Lite</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.18.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.19.1">Code samples for this chapter can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">at </span></span><a href="https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src"><span class="No-Break"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.22.1">.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.23.1">Named beans</span></h1>
<p><span class="koboSpan" id="kobo.24.1">CDI provides us </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.25.1">with the ability to name our beans via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">@Named </span></strong><span class="koboSpan" id="kobo.27.1">annotation. </span><span class="koboSpan" id="kobo.27.2">Named beans allow us to easily inject our beans into other classes that depend on them (see the next section) and to easily refer to them from Jakarta Faces via the unified </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">expression language.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.29.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.30.1">Jakarta Faces is covered in detail in </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Chapters 6</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.32.1">and </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.33.1">7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">The following example shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">@Named</span></strong><span class="koboSpan" id="kobo.37.1"> annotation </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">in action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.39.1">
package com.ensode.jakartaeebook.cdidependencyinjection.beans;
import jakarta.enterprise.context.RequestScoped;
import jakarta.inject.Named;
</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">@Named</span></strong><span class="koboSpan" id="kobo.41.1">
@RequestScoped
public class Customer {
  private String firstName;
  private String lastName;
  public String getFirstName() {
    return firstName;
  }
  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }
  public String getLastName() {
    return lastName;
  }
  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.42.1">As we can see, all </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.43.1">we need to do to name our class is to decorate it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">@Named</span></strong><span class="koboSpan" id="kobo.45.1"> annotation. </span><span class="koboSpan" id="kobo.45.2">By default, the name of the bean will be the class name with its first letter switched to lowercase. </span><span class="koboSpan" id="kobo.45.3">In our example, the name of the bean would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">customer</span></strong><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">If we wish to use a different name, we can do so by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">value</span></strong><span class="koboSpan" id="kobo.49.1"> attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">@Named</span></strong><span class="koboSpan" id="kobo.51.1"> annotation. </span><span class="koboSpan" id="kobo.51.2">For example, if we wanted to use the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">customerBean</span></strong><span class="koboSpan" id="kobo.53.1"> for our bean, we could have done so by modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">@Named</span></strong><span class="koboSpan" id="kobo.55.1"> annotation </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
@Named(value="customerBean")</span></pre> <p><span class="koboSpan" id="kobo.58.1">Or, we could simply use </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
@Named("customerBean")</span></pre> <p><span class="koboSpan" id="kobo.61.1">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">value</span></strong><span class="koboSpan" id="kobo.63.1"> attribute name does not need to be specified, if we don’t use an attribute name, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">value</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.65.1">is implied.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">This name can be used to </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.67.1">access our bean from Jakarta Faces pages using the unified </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">expression language:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;Enter Customer Information&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:form&gt;
      &lt;h:panelGrid columns="2"&gt;
        &lt;h:outputLabel for="firstName" value="First Name"/&gt;
        </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">&lt;h:inputText id="firstName"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.71.1">          value="#{customer.firstName}"/&gt;</span></strong><span class="koboSpan" id="kobo.72.1">
        &lt;h:outputLabel for="lastName" value="Last Name"/&gt;
        </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">&lt;h:inputText id="lastName"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.74.1">          value="#{customer.lastName}"/&gt;</span></strong><span class="koboSpan" id="kobo.75.1">
        &lt;h:panelGroup/&gt;
        &lt;h:commandButton value="Submit"
          action="#{customerController.saveCustomer}"/&gt;
      &lt;/h:panelGrid&gt;
    &lt;/h:form&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</span></pre> <p><span class="koboSpan" id="kobo.76.1">In our example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">firstName</span></strong><span class="koboSpan" id="kobo.78.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">lastName</span></strong><span class="koboSpan" id="kobo.80.1"> properties or our </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Customer</span></strong><span class="koboSpan" id="kobo.82.1"> named bean are bound to two text input fields in our Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">Faces page.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">When </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.85.1">deployed and executed, our simple application looks </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.87.1"><img alt="Figure 2.1 – CDI named beans in action" src="image/B21231_2_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.88.1">Figure 2.1 – CDI named beans in action</span></p>
<p><span class="koboSpan" id="kobo.89.1">Now that we’ve seen how we can name our CDI beans, we will focus our attention on the dependency injection capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">of CDI.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.91.1">Dependency injection</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.92.1">Dependency injection</span></strong><span class="koboSpan" id="kobo.93.1"> is a</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.94.1"> technique for supplying external dependencies to a Java class. </span><span class="koboSpan" id="kobo.94.2">CDI includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">@Inject</span></strong><span class="koboSpan" id="kobo.96.1"> annotation, which can be used to inject instances of CDI beans into any </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">dependent objects.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Jakarta Faces</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.99.1"> applications typically follow the </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.101.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.102.1">MVC</span></strong><span class="koboSpan" id="kobo.103.1">) design pattern. </span><span class="koboSpan" id="kobo.103.2">As such, frequently some Jakarta Faces managed beans take the role of controllers in the pattern, while others take the role of the model. </span><span class="koboSpan" id="kobo.103.3">This approach typically requires the controller-managed bean to have access to one or more of the model-managed beans. </span><span class="koboSpan" id="kobo.103.4">CDI’s dependency injection capabilities make injecting beans into one another very simple, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
package com.ensode.jakartaeebook.cdinamedbeans.beans;
//imports omitted for brevity
@Named
@RequestScoped
public class CustomerController {
  private static final Logger logger = Logger.getLogger(
      CustomerController.class.getName());
  </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">@Inject</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.107.1">  private Customer customer;</span></strong><span class="koboSpan" id="kobo.108.1">
  public String saveCustomer() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">logger.info("Saving the following information \n" +</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.110.1">      customer.toString());</span></strong><span class="koboSpan" id="kobo.111.1">
    //If this was a real application,
    //we would have code to save customer data to the
    //database here.
</span><span class="koboSpan" id="kobo.111.2">    return "confirmation";
  }
}</span></pre> <p><span class="koboSpan" id="kobo.112.1">Notice that </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.113.1">all we had to do to initialize our </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Customer</span></strong><span class="koboSpan" id="kobo.115.1"> instance was to annotate it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">@Inject</span></strong><span class="koboSpan" id="kobo.117.1"> annotation. </span><span class="koboSpan" id="kobo.117.2">When the bean is constructed by the application server, an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Customer</span></strong><span class="koboSpan" id="kobo.119.1"> bean is automatically injected into this field. </span><span class="koboSpan" id="kobo.119.2">Notice that the injected bean is used in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">saveCustomer()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">As we have seen in this section, CDI dependency injection is very simple. </span><span class="koboSpan" id="kobo.122.2">We simply need to annotate the instance variable of the class we wish to inject with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Inject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1"> annotation.</span></span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.126.1">Qualifiers</span></h1>
<p><span class="koboSpan" id="kobo.127.1">In some</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.128.1"> instances, the type of bean we wish to inject into our code may be an interface or a Java superclass. </span><span class="koboSpan" id="kobo.128.2">However, we may be interested in injecting a specific subclass or a class implementing the interface. </span><span class="koboSpan" id="kobo.128.3">For cases like this, CDI provides qualifiers we can use to indicate the specific type we wish to inject into </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">A CDI qualifier is </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.131.1">an annotation that must be decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">@Qualifier</span></strong><span class="koboSpan" id="kobo.133.1"> annotation. </span><span class="koboSpan" id="kobo.133.2">This annotation can then be used to decorate the specific subclass or interface implementation we wish to qualify. </span><span class="koboSpan" id="kobo.133.3">Additionally, the injected field in the client code needs to be decorated with the qualifier </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Suppose our application could have a special kind of customer; for example, frequent customers could be given the status of premium customers. </span><span class="koboSpan" id="kobo.135.2">To handle these premium customers, we could extend our </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Customer</span></strong><span class="koboSpan" id="kobo.137.1"> named bean and decorate it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">following qualifier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
package package com.ensode.jakartaeebook.qualifiers;
import jakarta.inject.Qualifier;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
</span><strong class="bold"><span class="koboSpan" id="kobo.140.1">@Qualifier</span></strong><span class="koboSpan" id="kobo.141.1">
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface Premium {
}</span></pre> <p><span class="koboSpan" id="kobo.142.1">As we</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.143.1"> mentioned before, qualifiers are standard annotations. </span><span class="koboSpan" id="kobo.143.2">They typically have retention of runtime and can target methods, fields, parameters, or types, as illustrated in the preceding example. </span><span class="koboSpan" id="kobo.143.3">The only difference between a qualifier and a standard annotation however is that qualifiers are decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Qualifier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Once we have our qualifier in place, we need to use it to decorate the specific subclass or interface implementation, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
package com.ensode.jakartaeebook.cdidependencyinjection.beans;
import com.ensode.jakartaeebook.qualifiers.Premium;
import jakarta.enterprise.context.RequestScoped;
import jakarta.inject.Named;
@Named
@RequestScoped
</span><strong class="bold"><span class="koboSpan" id="kobo.150.1">@Premium</span></strong><span class="koboSpan" id="kobo.151.1">
public class PremiumCustomer extends Customer {
  private Integer discountCode;
  public Integer getDiscountCode() {
    return discountCode;
  }
  public void setDiscountCode(Integer discountCode) {
    this.discountCode = discountCode;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.152.1">Once we </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.153.1">have decorated the specific instance, we need to qualify it. </span><span class="koboSpan" id="kobo.153.2">We can use our qualifiers in the controller to specify the exact type of dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">we need:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
package com.ensode.jakartaeebook.cdidependencyinjection.beans;
import java.util.logging.Logger;
import com.ensode.jakartaeebook.qualifiers.Premium;
import jakarta.enterprise.context.RequestScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
@Named
@RequestScoped
public class CustomerController {
  private static final Logger logger = Logger.getLogger(
      CustomerController.class.getName());
  </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">@Inject</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.157.1">  @Premium</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.158.1">  private Customer customer;</span></strong><span class="koboSpan" id="kobo.159.1">
  public String saveCustomer() {
    PremiumCustomer premiumCustomer =
      (PremiumCustomer) customer;
    logger.info("Saving the following information \n"
        + premiumCustomer.getFirstName() + " "
        + premiumCustomer.getLastName()
        + ", discount code = "
        + premiumCustomer.getDiscountCode());
    //If this was a real application, we would have code
    // to save customer data to the database here.
</span><span class="koboSpan" id="kobo.159.2">    return "confirmation";
  }
}</span></pre> <p><span class="koboSpan" id="kobo.160.1">Since we used our </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">@Premium</span></strong><span class="koboSpan" id="kobo.162.1"> qualifier to annotate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">customer</span></strong><span class="koboSpan" id="kobo.164.1"> field, an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">PremiumCustomer</span></strong><span class="koboSpan" id="kobo.166.1"> is injected into that field, since this class is also decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Premium</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1"> qualifier.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">As far as our</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.171.1"> Jakarta Faces pages go, we simply access our named bean as usual using its name, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
    &lt;h:head&gt;
        &lt;title&gt;Enter Customer Information&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
        &lt;h:form&gt;
            &lt;h:panelGrid columns="2"&gt;
                &lt;h:outputLabel for="firstName" value="First Name"/&gt;
                </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">&lt;h:inputText id="firstName"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.175.1">                   value="#{premiumCustomer.firstName}"/&gt;</span></strong><span class="koboSpan" id="kobo.176.1">
                &lt;h:outputLabel for="lastName"
                  value="Last Name"/&gt;
                </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">&lt;h:inputText id="lastName"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.178.1">                   value="#{premiumCustomer.lastName}"/&gt;</span></strong><span class="koboSpan" id="kobo.179.1">
                &lt;h:outputLabel for="discountCode"
                  value="Discount Code"/&gt;
                </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">&lt;h:inputText id="discountCode"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.181.1">                   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.182.1">value="#{premiumCustomer.discountCode}"/&gt;</span></strong><span class="koboSpan" id="kobo.183.1">
                &lt;h:panelGroup/&gt;
                &lt;h:commandButton value="Submit" action=
                  "#{customerController.saveCustomer}"/&gt;
            &lt;/h:panelGrid&gt;
        &lt;/h:form&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</span></pre> <p><span class="koboSpan" id="kobo.184.1">In this example, we</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.185.1"> are using the default name for our bean, which is the class name with the first letter switched </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">to lowercase.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Our simple application renders and acts just like a “plain” Jakarta Faces application, as far as the user is concerned. </span><span class="koboSpan" id="kobo.187.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.188.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.189.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.191.1"><img alt="Figure 2.2 – Premium customer data displayed in the browser" src="image/B21231_2_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.192.1">Figure 2.2 – Premium customer data displayed in the browser</span></p>
<p><span class="koboSpan" id="kobo.193.1">Now that we’ve seen how to use CDI qualifiers to inject different implementations of the same type, we’ll focus our attention on </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">CDI scopes.</span></span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.195.1">CDI bean scopes</span></h1>
<p><span class="koboSpan" id="kobo.196.1">CDI </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.197.1">stands for “Contexts and Dependency Injection,” CDI Beans have a scope which defines their lifecycle, their scope determines when the Jakarta EE runtime creates and destroys CDI beans. </span><span class="koboSpan" id="kobo.197.2">“Contexts” in “Contexts and Dependency Injection” refers to CDI scopes. </span><span class="koboSpan" id="kobo.197.3">When a CDI bean is needed, either because of injection or because it is referred to from a Jakarta Faces page, CDI looks for an instance of the bean in the scope it belongs to and injects it into the dependent code. </span><span class="koboSpan" id="kobo.197.4">If no instance is found, one is created and stored in the appropriate scope for future use. </span><span class="koboSpan" id="kobo.197.5">The different scopes are the context in which the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">bean exists.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">The following table lists</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.200.1"> the different valid </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">CDI scopes:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.202.1">Scope</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.203.1">Annotation</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.204.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.205.1">Request</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">RequestScoped</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.208.1">Request-scoped beans are shared through the duration of a single request. </span><span class="koboSpan" id="kobo.208.2">A single request could refer to an HTTP request, an invocation to a method in an EJB, a web service invocation, or sending a JMS message to a </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">message-driven bean.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.210.1">Conversation</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">ConversationScoped</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.213.1">The conversation scope can span multiple requests, but is typically shorter than the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">session scope.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.215.1">Session</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">SessionScoped</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.218.1">Session-scoped beans are shared across all requests in an HTTP session. </span><span class="koboSpan" id="kobo.218.2">Each user of an application gets their own instance of a </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">session-scoped bean.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.220.1">Application</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">ApplicationScoped</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><span class="koboSpan" id="kobo.223.1">Application-scoped beans live through the whole application lifetime. </span><span class="koboSpan" id="kobo.223.2">Beans in this scope are shared across user sessions.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.224.1">Dependent</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Dependent</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.227.1">Dependent-scoped beans are not shared. </span><span class="koboSpan" id="kobo.227.2">Any time a dependent scoped bean is injected, a new instance </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">is created.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.229.1">Table 2.1 – CDI scopes</span></p>
<p><span class="koboSpan" id="kobo.230.1">CDI’s </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">request scope</span></strong><span class="koboSpan" id="kobo.232.1"> does</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.233.1"> not necessarily refer to an HTTP request; it could simply be an invocation on an EJB method, a web service invocation, or sending a JMS message to a </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">message-driven bean.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">conversation scope</span></strong><span class="koboSpan" id="kobo.237.1"> is</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.238.1"> longer than the request scope but shorter than the session scope. </span><span class="koboSpan" id="kobo.238.2">It typically spans three or more pages. </span><span class="koboSpan" id="kobo.238.3">Classes wishing to access a conversation-scoped bean must have an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">jakarta.enterprise.context.Conversation</span></strong><span class="koboSpan" id="kobo.240.1"> injected. </span><span class="koboSpan" id="kobo.240.2">At the point, where we want to start the conversation, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">begin()</span></strong><span class="koboSpan" id="kobo.242.1"> method must be invoked on this object. </span><span class="koboSpan" id="kobo.242.2">At the point where we want to end the conversation, its </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">end()</span></strong><span class="koboSpan" id="kobo.244.1"> method must be invoked </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">CDI’s </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">session scope</span></strong><span class="koboSpan" id="kobo.248.1"> ties the life cycle of a CDI bean to an HTTP session. </span><span class="koboSpan" id="kobo.248.2">Session-scoped CDI beans are </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.249.1">created when they are first injected, and stick around until the HTTP session is destroyed, usually when a user logs out of a web application or closes </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">CDI’s </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">application scope</span></strong><span class="koboSpan" id="kobo.253.1"> ties </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.254.1">the life cycle of a CDI bean to the life of an application. </span><span class="koboSpan" id="kobo.254.2">A single instance of each application-scoped bean exists per application, which means that the same instance is accessible to all </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">HTTP sessions.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">CDI’s </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">dependent scope</span></strong><span class="koboSpan" id="kobo.258.1"> is </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.259.1">the default scope if none is explicitly specified. </span><span class="koboSpan" id="kobo.259.2">A new instance of a dependent-scoped bean is instantiated every time it is needed, usually when it is injected into a class that depends </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">For most of CDI’s scopes, simply annotating our CDI bean with the desired scope annotation is all we need to do. </span><span class="koboSpan" id="kobo.261.2">The Jakarta EE runtime then manages the bean’s life cycle behind the scenes. </span><span class="koboSpan" id="kobo.261.3">The conversation scope requires a bit more work on our part, namely we need to indicate when a conversation starts and ends. </span><span class="koboSpan" id="kobo.261.4">For this reason, we will use the conversation scope to illustrate the usage of </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">CDI scopes.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">Suppose we wanted to have a user enter some data that would be stored in a single named bean; however, this bean has several fields. </span><span class="koboSpan" id="kobo.263.2">Therefore, we would like to split the data entry into several pages. </span><span class="koboSpan" id="kobo.263.3">For cases like this, CDI’s conversation scope is a good solution. </span><span class="koboSpan" id="kobo.263.4">The following example illustrates how to use CDI’s </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">conversation scope:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
package com.ensode.jakartaeebook.conversationscope.model;
import jakarta.enterprise.context.ConversationScoped;
import jakarta.inject.Named;
import java.io.Serializable;
@Named
</span><strong class="bold"><span class="koboSpan" id="kobo.266.1">@ConversationScoped</span></strong><span class="koboSpan" id="kobo.267.1">
public class Customer implements Serializable {
  private String firstName;
  private String middleName;
  private String lastName;
  private String addrLine1;
  private String addrLine2;
  private String addrCity;
  private String state;
  private String zip;
  private String phoneHome;
  private String phoneWork;
  private String phoneMobile;
  //getters and setters omitted for brevity
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("Customer{");
    sb.append("firstName=").append(firstName);
    sb.append(", middleName=").append(middleName);
    sb.append(", lastName=").append(lastName);
    sb.append(", addrLine1=").append(addrLine1);
    sb.append(", addrLine2=").append(addrLine2);
    sb.append(", addrCity=").append(addrCity);
    sb.append(", state=").append(state);
    sb.append(", zip=").append(zip);
    sb.append(", phoneHome=").append(phoneHome);
    sb.append(", phoneWork=").append(phoneWork);
    sb.append(", phoneMobile=").append(phoneMobile);
    sb.append('}');
    return sb.toString();
  }
}</span></pre> <p><span class="koboSpan" id="kobo.268.1">We declare </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.269.1">that our bean is conversation scoped by decorating it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">@ConversationScoped</span></strong><span class="koboSpan" id="kobo.271.1"> annotation. </span><span class="koboSpan" id="kobo.271.2">Conversation-scoped beans also need to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">java.io.Serializable</span></strong><span class="koboSpan" id="kobo.273.1">. </span><span class="koboSpan" id="kobo.273.2">Other than these two requirements, there is nothing special about our code; it is a simple Java class with private properties and corresponding getter and </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">setter methods.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">In addition to having our conversation-scoped bean injected, our client code must also have an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">jakarta.enterprise.context.Conversation</span></strong><span class="koboSpan" id="kobo.277.1"> injected, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
package com.ensode.jakartaeebook.conversationscope.controller;
import jakarta.enterprise.context.Conversation;
import jakarta.enterprise.context.RequestScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.io.Serializable;
import com.ensode.jakartaeebook.conversationscope.model.Customer;
@Named
@RequestScoped
public class CustomerInfoController implements Serializable {
    </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">@Inject</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.281.1">    private Conversation conversation;</span></strong><span class="koboSpan" id="kobo.282.1">
    @Inject
    private Customer customer;
    public String customerInfoEntry() {
        </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">conversation.begin();</span></strong><span class="koboSpan" id="kobo.284.1">
        System.out.println(customer);
        return "page1";
    }
    public String navigateToPage1() {
        System.out.println(customer);
        return "page1";
    }
    public String navigateToPage2() {
        System.out.println(customer);
        return "page2";
    }
    public String navigateToPage3() {
        System.out.println(customer);
        return "page3";
    }
    public String navigateToConfirmationPage() {
        System.out.println(customer);
        </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">conversation.end();</span></strong><span class="koboSpan" id="kobo.286.1">
        return "confirmation";
    }
}</span></pre> <p><span class="koboSpan" id="kobo.287.1">Conversations can be either </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">long-running</span></strong><span class="koboSpan" id="kobo.289.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">transient</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">Transient conversations end at the</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.292.1"> end </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.293.1">of a request. </span><span class="koboSpan" id="kobo.293.2">Long-running conversations span multiple requests. </span><span class="koboSpan" id="kobo.293.3">In most cases, we will use long-running conversations to hold a reference to a conversation-scoped bean across multiple HTTP requests in a </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">A long-running conversation</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.296.1"> starts when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">begin()</span></strong><span class="koboSpan" id="kobo.298.1"> method is invoked in the injected </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Conversation</span></strong><span class="koboSpan" id="kobo.300.1"> instance, and it ends when we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">end()</span></strong><span class="koboSpan" id="kobo.302.1"> method on this </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">same object.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Jakarta Faces pages simply access our CDI beans </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">as usual:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
    &lt;h:head&gt;
        &lt;title&gt;Customer Information&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
        &lt;h3&gt;Enter Customer Information (Page 1 of 3)&lt;/h3&gt;
        &lt;h:form&gt;
            &lt;h:panelGrid columns="2"&gt;
                &lt;h:outputLabel for="firstName"
                  value="First Name"/&gt;
                </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">&lt;h:inputText  id="firstName"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.308.1">                  value="#{customer.firstName}"/&gt;</span></strong><span class="koboSpan" id="kobo.309.1">
                &lt;h:outputLabel for="middleName"
                  value="Middle Name"/&gt;
                </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">&lt;h:inputText id="middleName"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.311.1">                  value="#{customer.middleName}"/&gt;</span></strong><span class="koboSpan" id="kobo.312.1">
                &lt;h:outputLabel for="lastName"
                  value="Last Name"/&gt;
                </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">&lt;h:inputText id="lastName"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.314.1">                  value="#{customer.lastName}"/&gt;</span></strong><span class="koboSpan" id="kobo.315.1">
                &lt;h:panelGroup/&gt;
                &lt;h:commandButton value="Next"
                  action=
               "#{customerInfoController.navigateToPage2}"/&gt;
            &lt;/h:panelGrid&gt;
        &lt;/h:form&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</span></pre> <p><span class="koboSpan" id="kobo.316.1">As we navigate</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.317.1"> from one page to the next, we keep the same instance of our conversation-scoped bean; therefore, all user-entered data remains. </span><span class="koboSpan" id="kobo.317.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">end()</span></strong><span class="koboSpan" id="kobo.319.1"> method is called on our Conversation bean, the conversation ends and our conversation-scoped bean </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">is destroyed.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Keeping our bean in the conversation scope simplifies the task of implementing “wizard-style” user interfaces, where data can be entered across several pages. </span><span class="koboSpan" id="kobo.321.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.322.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.323.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.325.1"><img alt="Figure ﻿2.3 – Page 1 of CDI Conversation Scope Example" src="image/B21231_2_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.326.1">Figure 2.3 – Page 1 of CDI Conversation Scope Example</span></p>
<p><span class="koboSpan" id="kobo.327.1">In our example, after clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">Next</span></strong><span class="koboSpan" id="kobo.329.1"> button on the first page, we can see our partially populated bean in the application </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">server log.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
[2023-05-28T08:33:35.113817-04:00] [GF 7.0.4] [INFO] [] [jakarta.enterprise.logging.stdout] [tid: _ThreadID=35 _ThreadName=http-listener-1(2)] [levelValue: 800] [[
  Customer{firstName=Daniel, middleName=, lastName=Jones, addrLine1=null, addrLine2=null, addrCity=null, state=null, zip=null, phoneHome=null, phoneWork=null, phoneMobile=null}]]</span></pre> <p><span class="koboSpan" id="kobo.332.1">At this</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.333.1"> point, the second page in our simple wizard is displayed, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.334.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.335.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.337.1"><img alt="Figure ﻿2.4 – Page 2 of CDI Conversation Scope Example" src="image/B21231_2_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.338.1">Figure 2.4 – Page 2 of CDI Conversation Scope Example</span></p>
<p><span class="koboSpan" id="kobo.339.1">When clicking </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">Next</span></strong><span class="koboSpan" id="kobo.341.1">, we can see that additional fields are populated in our </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">conversation-scoped bean.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
[2023-05-28T08:44:23.434029-04:00] [GF 7.0.4] [INFO] [] [jakarta.enterprise.logging.stdout] [tid: _ThreadID=36 _ThreadName=http-listener-1(3)] [levelValue: 800] [[
  Customer{firstName=Daniel, middleName=, lastName=Jones, addrLine1=123 Basketball Ct, addrLine2=, addrCity=Montgomery, state=AL, zip=36101, phoneHome=, phoneWork=, phoneMobile=}]]</span></pre> <p><span class="koboSpan" id="kobo.344.1">When we submit the third page in our wizard (not shown), additional bean properties corresponding to the fields on that page </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">are populated.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">When we are at the point where we don’t need to keep the customer information in memory anymore, we need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">end()</span></strong><span class="koboSpan" id="kobo.348.1"> method on the Conversation bean that was injected into our code. </span><span class="koboSpan" id="kobo.348.2">This is exactly what we do in our code before displaying the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">confirmation page:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
public String navigateToConfirmationPage() {
        System.out.println(customer);
        </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">conversation.end();</span></strong><span class="koboSpan" id="kobo.352.1">
        return "confirmation";
    }</span></pre> <p><span class="koboSpan" id="kobo.353.1">After the</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.354.1"> request to show the confirmation page is completed, our conversation-scoped bean is destroyed, since we invoked the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">end()</span></strong><span class="koboSpan" id="kobo.356.1"> method in our injected </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Conversation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Now that we’ve seen all scopes supported by CDI, we will turn our attention to how we can implement loosely coupled communication via </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">CDI events.</span></span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.361.1">CDI events</span></h1>
<p><span class="koboSpan" id="kobo.362.1">CDI </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.363.1">provides event-handling facilities. </span><span class="koboSpan" id="kobo.363.2">Events allow loosely coupled communication between different CDI beans. </span><span class="koboSpan" id="kobo.363.3">A CDI bean can fire an event, then one or more event listeners handle </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the event.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.365.1">Firing CDI events</span></h2>
<p><span class="koboSpan" id="kobo.366.1">The</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.367.1"> following example is a new version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">CustomerInfoController</span></strong><span class="koboSpan" id="kobo.369.1"> class we discussed in the previous section. </span><span class="koboSpan" id="kobo.369.2">The class has been modified to fire an event every time the user navigates to a </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">new page:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
package com.ensode.jakartaeebook.cdievents.controller;
import jakarta.enterprise.context.Conversation;
import jakarta.enterprise.context.RequestScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.io.Serializable;
import com.ensode.jakartaeebook.cdievents.event.NavigationInfo;
import com.ensode.jakartaeebook.cdievents.model.Customer;
import jakarta.enterprise.event.Event;
@Named
@RequestScoped
public class CustomerInfoController implements Serializable {
    @Inject
    private Conversation conversation;
    @Inject
    private Customer customer;
    </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">@Inject</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.373.1">    private Event&lt;NavigationInfo&gt; navigationInfoEvent;</span></strong><span class="koboSpan" id="kobo.374.1">
    public String customerInfoEntry() {
        conversation.begin();
        NavigationInfo navigationInfo =
          new NavigationInfo();
        navigationInfo.setPage("1");
        navigationInfo.setCustomer(customer);
        </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">navigationInfoEvent.fire(navigationInfo);</span></strong><span class="koboSpan" id="kobo.376.1">
        return "page1";
    }
    public String navigateToPage1() {
        NavigationInfo navigationInfo =
          new NavigationInfo();
        navigationInfo.setPage("1");
        navigationInfo.setCustomer(customer);
        </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">navigationInfoEvent.fire(navigationInfo);</span></strong><span class="koboSpan" id="kobo.378.1">
        return "page1";
    }
    public String navigateToPage2() {
        NavigationInfo navigationInfo =
          new NavigationInfo();
        navigationInfo.setPage("2");
        navigationInfo.setCustomer(customer);
        </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">navigationInfoEvent.fire(navigationInfo);</span></strong><span class="koboSpan" id="kobo.380.1">
        return "page2";
    }
    public String navigateToPage3() {
        NavigationInfo navigationInfo =
          new NavigationInfo();
        navigationInfo.setPage("3");
        navigationInfo.setCustomer(customer);
        </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">navigationInfoEvent.fire(navigationInfo);</span></strong><span class="koboSpan" id="kobo.382.1">
        return "page3";
    }
    public String navigateToConfirmationPage() {
        NavigationInfo navigationInfo =
          new NavigationInfo();
        navigationInfo.setPage("confirmation");
        navigationInfo.setCustomer(customer);
        </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">navigationInfoEvent.fire(navigationInfo);</span></strong><span class="koboSpan" id="kobo.384.1">
        conversation.end();
        return "confirmation";
    }
}</span></pre> <p><span class="koboSpan" id="kobo.385.1">As we can see, to </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.386.1">create an event, we inject an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">jakarta.enterprise.event.Event</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">This class uses generics; therefore, we need to specify its type. </span><span class="koboSpan" id="kobo.388.3">The type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">Event</span></strong><span class="koboSpan" id="kobo.390.1"> class can be any class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">java.io.Serializable</span></strong><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">In our case, we are passing an instance of a simple POJO we wrote as the type parameter, our POJO is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">NavigationInfo</span></strong><span class="koboSpan" id="kobo.394.1"> and has two properties, one of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">Customer</span></strong><span class="koboSpan" id="kobo.396.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">String</span></strong><span class="koboSpan" id="kobo.398.1"> containing the page the user is navigating to. </span><span class="koboSpan" id="kobo.398.2">Recall from the previous sections that each of the methods on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">CustomerInfoController</span></strong><span class="koboSpan" id="kobo.400.1"> class triggers navigation from one page in the application to another. </span><span class="koboSpan" id="kobo.400.2">In </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.401.1">this version of the controller, a CDI event is fired every time we navigate to a new page. </span><span class="koboSpan" id="kobo.401.2">In each case, we create a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">NavigationInfo</span></strong><span class="koboSpan" id="kobo.403.1">, populate it, then fire the event by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">fire()</span></strong><span class="koboSpan" id="kobo.405.1"> method on our instance </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">jakarta.enterprise.event.Event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.409.1">Handling CDI events</span></h2>
<p><span class="koboSpan" id="kobo.410.1">To handle</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.411.1"> CDI events, the CDI bean handling the event needs to implement </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.412.1">an </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">observer method</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">Observer methods accept a parameter of the type that was used to fire the event, that is, the generic type used to create the event that was fired. </span><span class="koboSpan" id="kobo.414.3">In our example, the generic type of our event is an instance of a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">NavigationInfo</span></strong><span class="koboSpan" id="kobo.416.1">, as can be seen in the declaration of our event in the preceding section. </span><span class="koboSpan" id="kobo.416.2">To handle the event, the observer method needs to annotate the corresponding parameter with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">@Observes</span></strong><span class="koboSpan" id="kobo.418.1"> annotation, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
package com.ensode.jakartaeebook.cdievents.eventlistener;
import jakarta.enterprise.context.SessionScoped;
import jakarta.enterprise.event.Observes;
import java.io.Serializable;
import com.ensode.jakartaeebook.cdievents.event.NavigationInfo;
import java.util.logging.Level;
import java.util.logging.Logger;
@SessionScoped
public class NavigationEventListener implements Serializable {
     private static final Logger LOG =
       Logger.getLogger(
       NavigationEventListener.class.getName());
    </span><strong class="bold"><span class="koboSpan" id="kobo.421.1">public void handleNavigationEvent(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.422.1">      @Observes NavigationInfo navigationInfo)</span></strong><span class="koboSpan" id="kobo.423.1"> {
        LOG.info("Navigation event fired");
        LOG.log(Level.INFO, "Page: {0}",
          navigationInfo.getPage());
        LOG.log(Level.INFO, "Customer: {0}",
          navigationInfo.getCustomer());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.424.1">In this</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.425.1"> example event handler, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">handleNavigationEvent()</span></strong><span class="koboSpan" id="kobo.427.1"> method takes an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">NavigationInfo</span></strong><span class="koboSpan" id="kobo.429.1"> as a parameter. </span><span class="koboSpan" id="kobo.429.2">Notice that this parameter is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">@Observes</span></strong><span class="koboSpan" id="kobo.431.1">. </span><span class="koboSpan" id="kobo.431.2">This causes the method to be invoked automatically by CDI every time an event of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">NavigationInfo</span></strong><span class="koboSpan" id="kobo.433.1"> is fired. </span><span class="koboSpan" id="kobo.433.2">Notice that we never explicitly call this method; the Jakarta EE runtime invokes it automatically whenever a navigation event </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">is fired.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">CDI events allow us to implement loosely coupled communication between CDI beans. </span><span class="koboSpan" id="kobo.435.2">In our example, notice that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">CustomerController</span></strong><span class="koboSpan" id="kobo.437.1"> CDI bean has no direct reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">NavigationEventListener</span></strong><span class="koboSpan" id="kobo.439.1">. </span><span class="koboSpan" id="kobo.439.2">In general, the CDI bean firing the event does not need to know any details about the listeners; it just fires the event and CDI takes over </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the details.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.441.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.442.1">In our example, we have only one event listener, but in practice, we can have as many event listeners as </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">we need.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.444.1">Asynchronous events</span></h2>
<p><span class="koboSpan" id="kobo.445.1">CDI </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.446.1">has the ability to fire events asynchronously. </span><span class="koboSpan" id="kobo.446.2">Firing events asynchronously can help with performance, since various observer methods can be invoked concurrently. </span><span class="koboSpan" id="kobo.446.3">Firing an event asynchronously is very similar to firing an event synchronously. </span><span class="koboSpan" id="kobo.446.4">The only syntactical difference is that instead of invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">fire()</span></strong><span class="koboSpan" id="kobo.448.1"> method in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Event</span></strong><span class="koboSpan" id="kobo.450.1"> instance, we invoke its </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">fireAsync()</span></strong><span class="koboSpan" id="kobo.452.1"> method. </span><span class="koboSpan" id="kobo.452.2">The following example illustrates how to </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
public class EventSource{
  @Inject Event&lt;MyEvent&gt; myEvent;
  public void fireEvent(){
    </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">myEvent.fireAsync(myEvent);</span></strong><span class="koboSpan" id="kobo.456.1">
  }
}</span></pre> <p><span class="koboSpan" id="kobo.457.1">Observer methods to handle asynchronous events are identical to their </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">synchronous counterparts.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.459.1">Event ordering</span></h2>
<p><span class="koboSpan" id="kobo.460.1">Another </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.461.1">new feature introduced in CDI 2.0 is the ability to specify in what order our observer methods handle CDI events. </span><span class="koboSpan" id="kobo.461.2">This can be accomplished via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">@Priority</span></strong><span class="koboSpan" id="kobo.463.1"> annotation, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
import jakarta.enterprise.context.SessionScoped;
import jakarta.enterprise.event.Observes;
import jakarta.annotation.Priority;
import jakarta.interceptor.Interceptor;
@SessionScoped
public class EventHandler{
    </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">void handleIt (</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.467.1">     @Observes </span></strong><strong class="bold"><span class="koboSpan" id="kobo.468.1">@Priority(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.469.1">       Interceptor.Priority.APPLICATION) MyEvent me)</span></strong><span class="koboSpan" id="kobo.470.1">{
    //handle the event
  }
}</span></pre> <p><span class="koboSpan" id="kobo.471.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">@Priority</span></strong><span class="koboSpan" id="kobo.473.1"> annotation </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.474.1">takes an argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">int</span></strong><span class="koboSpan" id="kobo.476.1">. </span><span class="koboSpan" id="kobo.476.2">This argument specifies the priority for the observer method. </span><span class="koboSpan" id="kobo.476.3">The highest priority is defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">APPLICATION</span></strong><span class="koboSpan" id="kobo.478.1"> constant defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Interceptor.Priority</span></strong><span class="koboSpan" id="kobo.480.1"> class. </span><span class="koboSpan" id="kobo.480.2">This is the priority we gave to the observer method in our example. </span><span class="koboSpan" id="kobo.480.3">Lower-priority values take precedence and the default priority is </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Interceptor.Priority.APPLICATION + </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">100</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">As mentioned in </span><a href="B21231_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.485.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.486.1">, in addition to the full Jakarta EE specification, there are two Jakarta EE profiles we can use if we are developing simpler applications that don’t need the full power of Jakarta EE. </span><span class="koboSpan" id="kobo.486.2">There’s the Web Profile, suitable for web applications, and the Core Profile, suitable for microservices. </span><span class="koboSpan" id="kobo.486.3">The Core Profile includes CDI support but does not support all of CDI’s features. </span><span class="koboSpan" id="kobo.486.4">This lightweight version of CDI included in the Jakarta EE Core Profile is called </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">CDI Lite.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.488.1">CDI Lite</span></h1>
<p><span class="koboSpan" id="kobo.489.1">The </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.490.1">Jakarta EE Core Profile </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.491.1">contains a subset of the full CDI specification, named, appropriately enough, CDI Lite. </span><span class="koboSpan" id="kobo.491.2">Most of the changes of CDI Lite are at the implementation level; namely, some functionality that the full CDI implementation performs at runtime is moved to build time, allowing applications utilizing CDI Lite to </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">initialize faster.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">CDI Lite is primarily meant to be used in microservices applications, implementing functionality as RESTful web services. </span><span class="koboSpan" id="kobo.493.2">Since REST applications are typically stateless, not all CDI scopes are applicable when working on this type of application. </span><span class="koboSpan" id="kobo.493.3">For this reason, the session and conversation scopes are not available when using CDI Lite. </span><span class="koboSpan" id="kobo.493.4">This is the primary limitation of CDI Lite when compared to the full </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">CDI specification.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">We only need to be concerned with CDI Lite limitations when deploying our code to a Jakarta EE Core Profile implementation. </span><span class="koboSpan" id="kobo.495.2">The Jakarta EE Web Profile and the full Jakarta EE platform </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.496.1">contain full </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">CDI functionality.</span></span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.498.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.499.1">In this chapter, we provided an introduction to CDI, an integral part of the Jakarta EE specification. </span><span class="koboSpan" id="kobo.499.2">We looked into </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.501.1">We covered how Jakarta Faces pages can access CDI-named beans via the unified </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">expression language.</span></span></li>
<li><span class="koboSpan" id="kobo.503.1">We also covered how CDI makes it easy to inject dependencies into our code via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Inject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.506.1"> annotation.</span></span></li>
<li><span class="koboSpan" id="kobo.507.1">Additionally, we explained how we can use qualifiers to determine what specific implementation of a dependency to inject into </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">our code.</span></span></li>
<li><span class="koboSpan" id="kobo.509.1">We also discussed all the scopes that a CDI bean can be placed into, allowing us to delegate the life cycle of CDI beans to the Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">EE runtime.</span></span></li>
<li><span class="koboSpan" id="kobo.511.1">We discussed how to implement loosely coupled communication between CDI beans via CDI’s </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">event handling.</span></span></li>
<li><span class="koboSpan" id="kobo.513.1">Lastly, we discussed CDI Lite, a lightweight version of CDI suitable for </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">microservices development.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.515.1">CDI is an integral part of Jakarta EE, as it is used to integrate different layers of our Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">EE applications.</span></span></p>
</div>
</body></html>