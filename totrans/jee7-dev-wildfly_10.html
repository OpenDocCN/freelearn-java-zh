<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Securing WildFly Applications</h1></div></div></div><p class="calibre8">In the previous chapter, we described how to manage your application server. The next stop in our journey will be learning about security, which is a key element of any Enterprise application. You must be able to control and restrict who is permitted to access your applications and what operations users may perform.</p><p class="calibre8">The Java Enterprise Edition specification defines a simple role-based security model for Enterprise JavaBeans and web components. The implementation of WildFly security is delivered by<a id="id1035" class="calibre1"/> the <span class="strong"><strong class="calibre9">Picketbox</strong></span> framework (formerly known as JBoss Security), which is part of the application server and provides the authentication, authorization, auditing, and mapping capabilities for Java applications.</p><p class="calibre8">Here is the list of topics we will cover in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A short introduction to the Java security API</li><li class="listitem">The foundation of the WildFly security subsystem</li><li class="listitem">Defining and applying login modules to secure Java EE applications</li><li class="listitem">Using <a id="id1036" class="calibre1"/>the <span class="strong"><strong class="calibre9">Secure Sockets Layer</strong></span> (<span class="strong"><strong class="calibre9">SSL</strong></span>) protocol to encrypt the traffic</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications">
<div class="book" title="Approaching the Java security API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec49" class="calibre1"/>Approaching the Java security API</h1></div></div></div><p class="calibre8">Java EE <a id="id1037" class="calibre1"/>security services provide a robust and easily configurable security mechanism to authenticate users and authorize access to application functions and the associated data. To better understand the topics related to security, we should first lay out some basic definitions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Authentication</strong></span>: This<a id="id1038" class="calibre1"/> is the process by which<a id="id1039" class="calibre1"/> you can verify who is currently executing an application, regardless of whether it is an EJB or a servlet (and so on). Authentication is usually performed by means of a <code class="email">Login</code> module contained in a web/standalone application. The Java EE specification provides only general requirements that must be met by all compliant containers. This means that every application server provides its own authentication mechanisms, which<a id="id1040" class="calibre1"/> is a problem when it <a id="id1041" class="calibre1"/>comes to portability of applications and their configuration.</li><li class="listitem"><span class="strong"><strong class="calibre9">Authorization</strong></span>: This is the process by which you can verify if a user has the right (permission) to access system resources or invoke certain operations. Authorization, therefore, presupposes that authentication has occurred; it would be <a id="id1042" class="calibre1"/>impossible to grant any access control <a id="id1043" class="calibre1"/>if you don't know who the user is first. Java EE<a id="id1044" class="calibre1"/> specification provides means to authorize a user's actions. The authorization declarations are usually portable between <a id="id1045" class="calibre1"/>different application servers. The <a id="id1046" class="calibre1"/>difference between authentication and authorization is depicted in the following diagram:<div class="mediaobject"><img src="../images/00079.jpeg" alt="Approaching the Java security API" class="calibre11"/></div><p class="calibre14"> </p></li></ul></div><p class="calibre8">In Java EE, the containers are responsible for providing application security. A container basically provides two types of security: declarative and programmatic. Let's take a look at both of them:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Declarative security</strong></span>: This expresses an application component's security requirements<a id="id1047" class="calibre1"/> by means of deployment <a id="id1048" class="calibre1"/>descriptors. Because deployment descriptor information is contained in an external file, it can be changed without the need to modify the source code.<p class="calibre15">For example, Enterprise JavaBeans components use an EJB deployment descriptor, which must be named <code class="email">ejb-jar.xml</code> and placed in the <code class="email">META-INF</code> folder of the EJB JAR file.</p><p class="calibre15">Web components use a web application deployment descriptor named <code class="email">web.xml</code>, which is located in the <code class="email">WEB-INF</code> directory.</p><div class="note" title="Note"><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">Since the release of Java EE 5, you can apply declarative security by means of annotations just like we have for other key APIs (EJB, web services, and so on). Annotations are specified within a class file, and when the application is deployed, the application server translates this information internally.</p></div></li><li class="listitem"><span class="strong"><strong class="calibre9">Programmatic security</strong></span>: This is embedded in an application and used to make security decisions. It can be used when declarative security alone is not sufficient to express the security model of an application. The Java EE security <a id="id1049" class="calibre1"/>API allows the developer to test whether<a id="id1050" class="calibre1"/> or not the current user <a id="id1051" class="calibre1"/>has access to a specific role, using the following calls:<div class="book"><ul class="itemizedlist3"><li class="listitem"><code class="email">isUserInRole()</code> for servlets and JSPs (adopted in <code class="email">javax.servlet.http.HttpServletRequest</code>)</li><li class="listitem"><code class="email">isCallerInRole()</code> for EJBs (adopted in <code class="email">javax.ejb.SessionContext</code>)</li></ul></div><p class="calibre15">Additionally, there are other API calls that provide access to the user's identity, which are as follows:</p><div class="book"><ul class="itemizedlist3"><li class="listitem"><code class="email">getUserPrincipal()</code> for servlets and JSPs (adopted in <code class="email">javax.servlet.http.HttpServletRequest</code>)</li><li class="listitem"><code class="email">getCallerPrincipal()</code> for EJBs (adopted in <code class="email">javax.ejb.SessionContext</code>)</li></ul></div><p class="calibre15">Using these APIs, you can develop arbitrarily complex authorization models.</p></li></ul></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications">
<div class="book" title="Approaching the Java security API">
<div class="book" title="The WildFly security subsystem"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec69" class="calibre1"/>The WildFly security subsystem</h2></div></div></div><p class="calibre8">WildFly <a id="id1052" class="calibre1"/>security qualifies as an extension to <a id="id1053" class="calibre1"/>the application server and is included, by default, both in standalone and domain servers using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;extension module="org.jboss.as.security"/&gt;</pre></div><p class="calibre8">WildFly defines security policies using two terms: security realms and security domains. Security realms are configuration sets mapped to external connectors (for example, EJB remoting and management interface). They allow every connection type to have its own appropriate authentication and authorization properties defined. For instance, both management and application realms define two separate files, which store the allowed usernames. Additionally, the application realm contains a reference to a file that defines user role.</p><p class="calibre8">The configuration defined in the security realm is then passed to a security domain requested by the deployed application. The security domain defines a set of login modules that are responsible for checking the user's credentials and creating a security principal representing the client (along with a set of roles for the requester).</p><p class="calibre8">The following is an extract from the default security subsystem contained in the server configuration file, which contains the <code class="email">RealmDirect</code> login that will be used in the next section<a id="id1054" class="calibre1"/> to secure the Ticket example <a id="id1055" class="calibre1"/>application:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
    &lt;security-domains&gt;
        &lt;security-domain name="other" cache-type="default"&gt;
            &lt;authentication&gt;
                &lt;login-module code="Remoting" flag="optional"&gt;
                    &lt;module-option name="password-stacking" value="useFirstPass"/&gt;
                &lt;/login-module&gt;
<span class="strong"><strong class="calibre9">                &lt;login-module code="RealmDirect" flag="required"&gt;</strong></span>
<span class="strong"><strong class="calibre9">                    &lt;module-option name="password-stacking" value="useFirstPass"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">                &lt;/login-module&gt;</strong></span>
            &lt;/authentication&gt;
        &lt;/security-domain&gt;
        &lt;security-domain name="jboss-web-policy" cache-type="default"&gt;
            &lt;authorization&gt;
                &lt;policy-module code="Delegating" flag="required"/&gt;
            &lt;/authorization&gt;
        &lt;/security-domain&gt;
        &lt;security-domain name="jboss-ejb-policy" cache-type="default"&gt;
            &lt;authorization&gt;
                &lt;policy-module code="Delegating" flag="required"/&gt;
            &lt;/authorization&gt;
        &lt;/security-domain&gt;
    &lt;/security-domains&gt;
&lt;/subsystem&gt;</pre></div><p class="calibre8">Configuration files are defined in the security realm using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;security-realm name="ApplicationRealm"&gt;
    &lt;authentication&gt;
        &lt;local default-user="$local" allowed-users="*"/&gt;
            &lt;properties path="application-users.properties" relative-to="jboss.server.config.dir"/&gt;
     &lt;/authentication&gt;
    &lt;authorization&gt;
        &lt;properties path="application-roles.properties" relative-to="jboss.server.config.dir"/&gt;
   &lt;/authorization&gt;
&lt;/security-realm&gt;</pre></div><p class="calibre8">As you can see, the configuration is pretty short as it relies largely on default values, especially for high-level structures such as the security management area. By defining your own security management options, you could, for example, override the default authentication/authorization managers with your implementations. Since it is likely that you will <a id="id1056" class="calibre1"/>not need to override these<a id="id1057" class="calibre1"/> interfaces, we will rather concentrate on the <code class="email">security-domain</code> element, which is the core aspect of WildFly security.</p><p class="calibre8">A security domain can be thought of as a Customs Office for foreigners. Before the request crosses WildFly borders, the security domain performs all the required authentication and authorization checks and eventually notifies if he/she can proceed or not.</p><p class="calibre8">Security domains are generally configured at server startup and subsequently bound into the JNDI tree under the key <code class="email">java:/jaas/</code>. Within the security domain, you can configure login authentication modules so that you can easily change your authentication provider by simply changing its <code class="email">login-module</code> element.</p><p class="calibre8">There are several implementations of login modules available out of the box; there is obviously not enough room here to describe in detail the features of each module, though we will offer a comprehensive description of some popular options, such as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The<a id="id1058" class="calibre1"/> <code class="email">RealmDirect</code> login module, which can be used for basic file-based authentication</li><li class="listitem">The <code class="email">Database</code> login module, which checks user credentials against a relational <a id="id1059" class="calibre1"/>database</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note51" class="calibre1"/>Note</h3><p class="calibre8">Should <a id="id1060" class="calibre1"/>you need further information about login modules, check out the WildFly documentation at:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><a class="calibre1" href="https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration">https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration</a></li><li class="listitem"><a class="calibre1" href="https://docs.jboss.org/author/display/WFLY8/Security+Realms">https://docs.jboss.org/author/display/WFLY8/Security+Realms</a></li></ul></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications">
<div class="book" title="Approaching the Java security API">
<div class="book" title="Setting up your first login module"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec70" class="calibre1"/>Setting up your first login module</h2></div></div></div><p class="calibre8">In<a id="id1061" class="calibre1"/> the following section, we will demonstrate<a id="id1062" class="calibre1"/> how to secure an application using the <code class="email">RealmDirect</code> security domain, which was introduced earlier. The <code class="email">RealmDirect</code> login module is based on the following two files:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">application-users.properties</code>: This contains the list of usernames and passwords</li><li class="listitem"><code class="email">application-roles.properties</code>: This contains the mapping between the users and their roles</li></ul></div><p class="calibre8">These files are located in the application server configuration folder and they are updated each time you add a new user via the <code class="email">add-user.sh/add-user.cmd</code> script. For our purpose, we will create a new application user named <code class="email">demouser</code>, which belongs to the role <code class="email">Manager</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00080.jpeg" alt="Setting up your first login module" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Once the user is added, the <code class="email">application-users.properties</code> file will contain the username and the MD5 encoding of the password, shown as follows:</p><div class="informalexample"><pre class="programlisting">demouser=9e21f32c593ef5248e7d6b2aab28717b</pre></div><p class="calibre8">Conversely, the<a id="id1063" class="calibre1"/> <code class="email">application-roles.properties</code> file <a id="id1064" class="calibre1"/>will contain the roles granted to the <code class="email">demouser</code> username once logged in:</p><div class="informalexample"><pre class="programlisting">demouser=Manager</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications">
<div class="book" title="Approaching the Java security API">
<div class="book" title="Using the login module in the Ticket web application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec71" class="calibre1"/>Using the login module in the Ticket web application</h2></div></div></div><p class="calibre8">We <a id="id1065" class="calibre1"/>can now apply <a id="id1066" class="calibre1"/>the <code class="email">RoleDirect</code> login module in<a id="id1067" class="calibre1"/> the Ticket web application described in <a class="calibre1" title="Chapter 4. Learning Context and Dependency Injection" href="part0028_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre10">Learning Context and Dependency Injection</em></span> (you could pick the version from another chapter if you like). We will first show how to provide a BASIC web authentication, and then we will show a slightly more complex example using FORM-based authentication.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note52" class="calibre1"/>Note</h3><p class="calibre8">BASIC-access authentication is the simplest way to provide a username and password when making a request through a browser.</p><p class="calibre8">It works by sending an encoded string containing the user credentials. This Base64-encoded string is transmitted and decoded by the receiver, resulting in colon-separated username and password strings. When it comes to safety, BASIC authentication is usually not the best solution. The password can be stolen during the transmission, so SSL is a must in order to protect it.</p></div><p class="calibre8">Turning on web authentication requires the <code class="email">security-constraints</code> element to be defined in the web application configuration file (<code class="email">web.xml</code>), as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;web-app 
         
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1"&gt;
. . . . . .

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;HtmlAuth&lt;/web-resource-name&gt;
            &lt;description&gt;application security constraints
            &lt;/description&gt;
            <span class="strong"><strong class="calibre9">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</strong></span>
            &lt;http-method&gt;GET&lt;/http-method&gt;
            &lt;http-method&gt;POST&lt;/http-method&gt;
        &lt;/web-resource-collection&gt;
        <span class="strong"><strong class="calibre9">&lt;auth-constraint&gt;</strong></span>
            <span class="strong"><strong class="calibre9">&lt;role-name&gt;Manager&lt;/role-name&gt;</strong></span>
        <span class="strong"><strong class="calibre9">&lt;/auth-constraint&gt;</strong></span>
    &lt;/security-constraint&gt;
    &lt;login-config&gt;
        &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;/login-config&gt;

    <span class="strong"><strong class="calibre9">&lt;security-role&gt;</strong></span>
        <span class="strong"><strong class="calibre9">&lt;role-name&gt;Manager&lt;/role-name&gt;</strong></span>
    <span class="strong"><strong class="calibre9">&lt;/security-role&gt;</strong></span>
&lt;/web-app&gt;</pre></div><p class="calibre8">This configuration will <a id="id1068" class="calibre1"/>add a security constraint<a id="id1069" class="calibre1"/> on <a id="id1070" class="calibre1"/>any JSP/servlet of the web application that will restrict access to users authenticated with the role <code class="email">Manager</code>. All login modules shown in the earlier section define this role, so you can just use the login module that suits your needs best.</p><p class="calibre8">From Java EE 7, there are two more methods to express your security constraints. Firstly, you can use a new container provided role: <code class="email">**</code>. It indicates that you are referring to any authenticated user, without taking its roles into account.</p><p class="calibre8">The second one is the <code class="email">deny-http-uncovered-methods</code> tag, which can be used in a <code class="email">web.xml</code> file to forbid access to every HTTP method that is not covered by a separate security constraint.</p><p class="calibre8">The next configuration tweak needs to be performed on the JBoss web deployment's descriptor, <code class="email">WEB-INF/jboss-web.xml</code>. You need to declare the security domain here, which will be used to authenticate the users. Since we are using <code class="email">RealmDirect</code>, which is part of the other built-in login module, we will need to include the <code class="email">java:/jaas/other</code> context information:</p><div class="informalexample"><pre class="programlisting">&lt;jboss-web&gt; 
<span class="strong"><strong class="calibre9">      &lt;security-domain&gt;java:/jaas/other&lt;/security-domain&gt;</strong></span>
&lt;/jboss-web&gt;</pre></div><p class="calibre8">The following diagram illustrates the whole configuration sequence applied to a <code class="email">Database</code> login module:</p><div class="mediaobject"><img src="../images/00081.jpeg" alt="Using the login module in the Ticket web application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Once you have deployed your application, the outcome should be a blocking pop up requesting user authentication. The window will look a little different on every browser and its appearance cannot be changed.</p><p class="calibre8">Logging in with <code class="email">demouser</code> username and the<a id="id1071" class="calibre1"/> valid <a id="id1072" class="calibre1"/>password <a id="id1073" class="calibre1"/>will grant access to the application with the <code class="email">Manager</code> role.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications">
<div class="book" title="Approaching the Java security API">
<div class="book" title="Switching to FORM-based security"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch10lvl2sec72" class="calibre1"/>Switching to FORM-based security</h2></div></div></div><p class="calibre8">FORM-based <a id="id1074" class="calibre1"/>authentication lets developers customize the authentication user interface, adapting it, for example, to your company's standards. Configuring it in your application requires you to basically modify just the <code class="email">login-config</code> stanza of the security section of your <code class="email">web.xml</code> file. Within it, we will define a login landing page (<code class="email">login.xhtml</code>) and an error page (<code class="email">error.xhtml</code>), in case the login fails. The code snippet for it is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;login-config&gt;
    &lt;auth-method&gt;FORM&lt;/auth-method&gt;
    &lt;form-login-config&gt;
      &lt;form-login-page&gt;/faces/login.xhtml&lt;/form-login-page&gt;
      &lt;form-error-page&gt;/faces/error.xhtml&lt;/form-error-page&gt;
    &lt;/form-login-config&gt;
&lt;/login-config&gt;</pre></div><p class="calibre8">The<a id="id1075" class="calibre1"/> login form must contain fields to enter a username and password. These fields must be named <code class="email">j_username</code> and <code class="email">j_password</code>, respectively. The authentication form should post these values to the <code class="email">j_security_check</code> logical name. All these names beginning with <code class="email">j_</code> are standardized by the Java Servlet specification—we just need to follow the convention in order to let the automatic mechanisms work. Here's a simple <code class="email">login.xhtml</code> page, which can be used to pass the required values to the security system:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
&lt;head&gt;
    &lt;title&gt;FORM based Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form method="post" action="j_security_check" name="loginForm"&gt;
    &lt;h:panelGrid columns="2"&gt;
        &lt;h:outputLabel id="userNameLabel" for="j_username" value="Username:"/&gt;
        &lt;h:inputText id="j_username" autocomplete="off"/&gt;
        &lt;h:outputLabel id="passwordLabel" for="j_password" value="Password:"/&gt;
        &lt;h:inputSecret id="j_password" autocomplete="off"/&gt;

        &lt;div/&gt;
        &lt;h:panelGroup&gt;
            &lt;h:commandButton type="submit" value="Login"/&gt;
            &lt;h:commandButton type="reset" value="Clear"/&gt;
        &lt;/h:panelGroup&gt;
    &lt;/h:panelGrid&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">For<a id="id1076" class="calibre1"/> the sake of brevity, we <a id="id1077" class="calibre1"/>won't include the error page, which will simply alert that the user entered an incorrect combination of username and password. The expected outcome is the following login screen, which will intercept all user access to your application and grant access to the default home page if the <code class="email">username</code> and <code class="email">password</code> credentials are correct.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications">
<div class="book" title="Approaching the Java security API">
<div class="book" title="Creating a Database login module"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch10lvl2sec73" class="calibre1"/>Creating a Database login module</h2></div></div></div><p class="calibre8">The <code class="email">UserRoles</code> login module is a good starting point to learn how to put together all the pieces <a id="id1078" class="calibre1"/>required to secure a web<a id="id1079" class="calibre1"/> application. In real-world cases, there are better alternatives to protect your applications, such as the <code class="email">Database</code> login module. A database security domain follows the same logic exposed in the earlier example; it just stores the credentials within the database. In order to run this example, we will refer to a data source defined in <a class="calibre1" title="Chapter 5. Combining Persistence with CDI" href="part0030_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre10">Combining Persistence with CDI</em></span> (bound at the JNDI name <code class="email">java:jboss/datasources/wflydevelopment</code>), which needs to be deployed on the application server:</p><div class="informalexample"><pre class="programlisting">&lt;security-domain name="dbdomain" cache-type="default"&gt;
    &lt;authentication&gt;
        &lt;login-module code="Database" flag="required"&gt;
            &lt;module-option name="dsJndiName" value=" java:jboss/datasources/wflydevelopment"/&gt;
            &lt;module-option name="principalsQuery" value="select passwd from USERS where login=?"/&gt;
            &lt;module-option name="rolesQuery" value="select role 'Roles' from USER_ROLES where login=?"/&gt;
        &lt;/login-module&gt;
    &lt;/authentication&gt;
&lt;/security-domain&gt;</pre></div><p class="calibre8">In order to get this configuration working, you have to first create the required tables and insert some sample data in it using the following queries:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE USERS(login VARCHAR(64) PRIMARY KEY, passwd VACHAR(64));
CREATE TABLE USER_ROLES(login VARCHAR(64), role VARCHAR(32));
INSERT into USERS values('admin', 'admin');
INSERT into USER_ROLES values('admin', 'Manager');</pre></div><p class="calibre8">As you <a id="id1080" class="calibre1"/>can see, the <code class="email">admin</code> user will<a id="id1081" class="calibre1"/> map again to the <code class="email">Manager</code> role. One caveat of this configuration is that it uses clear text passwords in the database; so before rolling this module into production, you should consider adding additional security to your login module. Let's see how to do this in the next section.</p><div class="book" title="Encrypting passwords"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec65" class="calibre1"/>Encrypting passwords</h3></div></div></div><p class="calibre8">Storing <a id="id1082" class="calibre1"/>passwords in the database as a clear <a id="id1083" class="calibre1"/>text string is not considered a good practice; as a matter of fact, a database has even more potential security holes than a regular filesystem. Imagine, for example, that a DBA added a public synonym for some tables, forgetting that one of those tables held sensitive information such as application passwords, as shown in the following screenshot! You then need to be sure that no potential attackers will ever be able to deliver the following query.</p><div class="mediaobject"><img src="../images/00082.jpeg" alt="Encrypting passwords" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Fortunately, securing application passwords is relatively easy; you can add a few extra options <a id="id1084" class="calibre1"/>to your login module, specifying <a id="id1085" class="calibre1"/>that the stored passwords are encrypted using a message digest algorithm. For example, in the <code class="email">Database</code> login module, you should add the following highlighted options at the bottom:</p><div class="informalexample"><pre class="programlisting">&lt;login-module code="Database" flag="required"&gt;
     &lt;module-option name="dsJndiName" value="java:jboss/datasources/wflydevelopment"/&gt;
     &lt;module-option name="principalsQuery" value="select passwd from USERS where login=?"/&gt;
     &lt;module-option name="rolesQuery" value="select role, 'Roles' from USER_ROLES where login=?"/&gt;
<span class="strong"><strong class="calibre9">     &lt;module-option name="hashAlgorithm" value="SHA-256"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">     &lt;module-option name="hashEncoding" value="BASE64"/&gt;</strong></span>
&lt;/login-module&gt;</pre></div><p class="calibre8">Here, we specified that the password will be hashed against an SHA hash algorithm; alternatively, you can use any other algorithm allowed by your JCA provider.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note53" class="calibre1"/>Note</h3><p class="calibre8">For an <a id="id1086" class="calibre1"/>excellent introduction to hashing algorithms, refer to <a class="calibre1" href="http://www.unixwiz.net/techtips/iguide-crypto-hashes.html">http://www.unixwiz.net/techtips/iguide-crypto-hashes.html</a>.</p></div><p class="calibre8">For the sake of completeness, we include a small application as follows, which generates the Base64 hashed password that is to be inserted in <code class="email">Database</code>:</p><div class="informalexample"><pre class="programlisting">public class Hash {

    public static void main(String[] args) throws Exception{
       String password = args[0];
       MessageDigest md = MessageDigest.getInstance("SHA-256");
       byte[] passwordBytes = password.getBytes();
       byte[] hash = md.digest(passwordBytes);
<span class="strong"><strong class="calibre9">       String passwordHash =</strong></span> 
            Base64.getEncoder().encodeToString(hash);

       System.out.println("password hash: "+passwordHash);
}</pre></div><p class="calibre8">Running the main program with <code class="email">admin</code> as the argument will generate the hash <code class="email">jGl25bVBBBW96Qi9Te4V37Fnqchz/Eu4qB9vKrRIqRg=</code>. This hash will be your updated password, which needs to be updated in your database, as shown in the following screenshot. Update<a id="id1087" class="calibre1"/> the password using the<a id="id1088" class="calibre1"/> following code:</p><div class="informalexample"><pre class="programlisting">UPDATE USERS SET PASSWD =  'jGl25bVBBBW96Qi9Te4V37Fnqchz/Eu4qB9vKrRIqRg=' WHERE LOGIN = 'admin';</pre></div><p class="calibre8">You can update it with any SQL client of your choice.</p><div class="mediaobject"><img src="../images/00083.jpeg" alt="Encrypting passwords" class="calibre11"/></div><p class="calibre12"> </p></div><div class="book" title="Using the Database login module in your application"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec66" class="calibre1"/>Using the Database login module in your application</h3></div></div></div><p class="calibre8">Once <a id="id1089" class="calibre1"/>you are done with the login module <a id="id1090" class="calibre1"/>configuration, don't forget to reference it through the JBoss web deployment's descriptor, <code class="email">WEB-INF/jboss-web.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;jboss-web&gt; 
<span class="strong"><strong class="calibre9">      &lt;security-domain&gt;java:/jaas/dbdomain&lt;/security-domain&gt;</strong></span>
&lt;/jboss-web&gt;</pre></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Securing WildFly Applications">
<div class="book" title="Approaching the Java security API">
<div class="book" title="Securing EJBs"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch10lvl2sec74" class="calibre1"/>Securing EJBs</h2></div></div></div><p class="calibre8">Securing <a id="id1091" class="calibre1"/>applications by means of a web login form is the <a id="id1092" class="calibre1"/>most frequently used option in Enterprise applications. Nevertheless, the HTTP protocol is not the only choice available to access applications. For example, EJBs can be accessed by remote clients using the RMI-IIOP protocol. In such a case, you should further refine your security policies by restricting access to the EJB components, which are usually involved in the business layer of your applications.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">How does security work at the EJB level?</strong></span></p><p class="calibre8">Authentication must be performed before any EJB method is called. Authorization, on the other hand, occurs at the beginning of each EJB method call.</p></div><p class="calibre8">One vast area of improvement introduced in Java EE 5 concerns the use of annotations, which can also be used to perform the basic security checks. There are five available annotations, which are listed as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">@org.jboss.ejb3.annotation.SecurityDomain</code>: This<a id="id1093" class="calibre1"/> specifies the security domain that is associated with the class/method.</li><li class="listitem"><code class="email">@javax.annotation.security.RolesAllowed</code>: This<a id="id1094" class="calibre1"/> specifies the list of roles permitted to access a method(s) in an EJB application.</li><li class="listitem"><code class="email">@javax.annotation.security.RunAs</code>: This<a id="id1095" class="calibre1"/> assigns a role dynamically to the EJB application during the invocation of the method. It can be used, for example, if we need to temporarily allow permission to access certain methods.</li><li class="listitem"><code class="email">@javax.annotation.security.PermitAll</code>: This specifies that an EJB application<a id="id1096" class="calibre1"/> can<a id="id1097" class="calibre1"/> be invoked by any client. The purpose of this annotation is to widen security access to some methods in situations where you don't exactly know what role will access the EJB application (imagine that some modules have been developed by a third party and they access your EJB application with some roles that are not well identified).</li><li class="listitem"><code class="email">@javax.annotation.security.DenyAll</code>: This <a id="id1098" class="calibre1"/>specifies that an EJB application cannot be invoked by external clients. It has the same considerations as those for <code class="email">@PermitAll</code>.</li></ul></div><p class="calibre8">The following snippet is an example of how to secure the <code class="email">TheatreBooker</code> SFSB, which we discussed in <a class="calibre1" title="Chapter 4. Learning Context and Dependency Injection" href="part0028_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre10">Learning Context and Dependency Injection</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@RolesAllowed("Manager")</strong></span>
<span class="strong"><strong class="calibre9">@SecurityDomain("dbdomain")</strong></span>
@Stateful
@Remote(TheatreBooker.class) 
public class TheatreBooker implements TheatreBooker {

}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note54" class="calibre1"/>Note</h3><p class="calibre8">Be <a id="id1099" class="calibre1"/>careful! There is more than one <code class="email">SecurityDomain</code> API available. You have to include <code class="email">org.jboss.ejb3.annotation.SecurityDomain</code>. The <code class="email">@RolesAllowed</code> annotation, on the other hand, needs to import <code class="email">javax.annotation.security.RolesAllowed</code>.</p><p class="calibre8">The JBoss-specific annotations can be found in the following maven dependency:</p><div class="informalexample"><pre class="programlisting">&lt;groupId&gt;org.jboss.ejb3&lt;/groupId&gt;
&lt;artifactId&gt;jboss-ejb3-ext-api&lt;/artifactId&gt;
&lt;version&gt;2.0.0&lt;/version&gt;
&lt;scope&gt;provided&lt;/scope&gt;</pre></div></div><p class="calibre8">Annotations<a id="id1100" class="calibre1"/> can also be applied at the method level; for example, if we want to secure just the <code class="email">bookSeat</code> object of the <code class="email">TheatreBookerBean</code> class, we will tag the <code class="email">bookSeat</code> method as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@RolesAllowed("Manager")</strong></span>
<span class="strong"><strong class="calibre9">@SecurityDomain("dbdomain")</strong></span>
public String bookSeat(int seatId) throws SeatBookedException {

}</pre></div><p class="calibre8">What if you don't want to use annotations to establish security roles? For example, if you have a security role that is used crosswise by all your EJB applications, perhaps it is simpler to use a plain old XML configuration instead of tagging all EJBs with annotations. In this scenario, you have to declare the security constraints first in the generic <code class="email">META-INF/ejb-jar.xml</code> file, shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;ejb-jar  
  version="3.2"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_2.xsd"&gt;
  &lt;assembly-descriptor&gt;
    &lt;method-permission&gt;
      &lt;role-name&gt;Manager&lt;/role-name&gt;
      &lt;method&gt;
        &lt;ejb-name&gt;*&lt;/ejb-name&gt;
        &lt;method-name&gt;*&lt;/method-name&gt;
      &lt;/method&gt;
    &lt;/method-permission&gt;
  &lt;/assembly-descriptor&gt;
&lt;/ejb-jar&gt;</pre></div><p class="calibre8">Then, inside<a id="id1101" class="calibre1"/> the <code class="email">META-INF/jboss-ejb3.xml</code> configuration file, just add a reference to your security domain:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jboss:ejb-jar 
   
   version="3.1" impl-version="2.0"&gt;
  &lt;assembly-descriptor&gt;
    &lt;s:security&gt;
      &lt;ejb-name&gt;*&lt;/ejb-name&gt;
      &lt;s:security-domain&gt;dbdomain&lt;/s:security-domain&gt;
    &lt;/s:security&gt;
  &lt;/assembly-descriptor&gt;
&lt;/jboss:ejb-jar&gt;</pre></div><p class="calibre8">Here's a snapshot illustrating the role configuration of the EJB file:</p><div class="mediaobject"><img src="../images/00084.jpeg" alt="Securing EJBs" class="calibre11"/></div><p class="calibre12"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="note55" class="calibre1"/>Note</h3><p class="calibre8">If you want to use a login module via EJB remoting, you must configure your security <a id="id1102" class="calibre1"/>realm accordingly using the JAAS <a id="id1103" class="calibre1"/>entry, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;security-realm name="ApplicationRealm"&gt;
  &lt;authentication&gt;
   &lt;jaas name="dbdomain"/&gt;
  &lt;/authentication&gt;
&lt;/security-realm&gt;</pre></div><p class="calibre8">Additionally, you should place the following entries in <code class="email">jbossyourjboss-ejb-client-properties</code>:</p><div class="informalexample"><pre class="programlisting">remote.connection.default.username=admin
remote.connection.default.password=admin
remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED=false
remote.connection.default.connect.options.org.xnio.Options.SASL_POLICY_NOPLAINTEXT=false
remote.connection.default.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=true</pre></div><p class="calibre8">These entries will ensure (besides passing the credentials), that the transmitted password will not be additionally hashed by the remoting mechanism.</p></div><div class="book" title="Securing web services"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec67" class="calibre1"/>Securing web services</h3></div></div></div><p class="calibre8">Web <a id="id1104" class="calibre1"/>service authorization can basically be carried out in two <a id="id1105" class="calibre1"/>ways, depending on whether we are dealing with a POJO-based web service or an EJB-based web service. Security changes to POJO web services are identical to those we introduced for servlets/JSP, consistent in defining the <code class="email">security-constraints</code> element in <code class="email">web.xml</code> and the login modules in <code class="email">jboss-web.xml</code>.</p><p class="calibre8">If you are using a web client to access your web service, it is all you need to get authenticated. If you are using a standalone client, you will need to specify the credentials in the JAX-WS Factory. The following is an example of how to access the secured <code class="email">CalculatePowerService</code> instance, which was described in <a class="calibre1" title="Chapter 7. Adding Web Services to Your Applications" href="part0038_split_000.html#page">Chapter 7</a>, <span class="strong"><em class="calibre10">Adding Web Services to Your Applications</em></span>:</p><div class="informalexample"><pre class="programlisting">JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();

factory.getInInterceptors().add(new LoggingInInterceptor());
factory.getOutInterceptors().add(new LoggingOutInterceptor());

factory.setServiceClass(CalculatePowerWebService.class);
factory.setAddress("http://localhost:8080/pojoService");
<span class="strong"><strong class="calibre9">factory.setUsername("admin");</strong></span>
<span class="strong"><strong class="calibre9">factory.setPassword("admin");</strong></span>
CalculatePowerWebService client = (CalculatePowerWebService) factory.create();</pre></div><p class="calibre8">What about EJB-based web services? The configuration is slightly different; since the security domain is not specified in web descriptors, we have to provide it by means of annotations:</p><div class="informalexample"><pre class="programlisting">@Stateless
<span class="strong"><strong class="calibre9">@WebService(targetNamespace = "http://www.packtpub.com/", serviceName = "TicketWebService") </strong></span>
<span class="strong"><strong class="calibre9">@WebContext(authMethod = "BASIC",</strong></span>
<span class="strong"><strong class="calibre9">            secureWSDLAccess = false)</strong></span>
<span class="strong"><strong class="calibre9">@SecurityDomain(value = "dbdomain")</strong></span>
<span class="strong"><strong class="calibre9">@RolesAllowed("Manager")</strong></span>
public class TicketSOAPService implements TicketSOAPServiceItf, Serializable {

   . . . . 
}</pre></div><p class="calibre8">As you can see, the <code class="email">@org.jboss.ws.api.annotation.Webcontext</code> annotation basically reflects the same configuration options as that of POJO-based web services, with <a id="id1106" class="calibre1"/>BASIC authentication and unrestricted WSDL access.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note58" class="calibre1"/>Note</h3><p class="calibre8">The <code class="email">@WebContext</code> annotation can be found in the following dependency:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.ws&lt;/groupId&gt;
      &lt;artifactId&gt;jbossws-api&lt;/artifactId&gt;
      &lt;version&gt;1.0.2.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;</pre></div></div><p class="calibre8">The <code class="email">@org.jboss.ejb3.annotation.SecurityDomain</code> annotation should be familiar to you since <a id="id1107" class="calibre1"/>we introduced it to illustrate how to secure an EJB. As you can see, it's a replacement for the information contained in the <code class="email">jboss-web.xml</code> file, except that the security domain is referenced directly by <code class="email">dbdomain</code> (instead of <code class="email">java:/jaas/dbdomain</code>).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note59" class="calibre1"/>Note</h3><p class="calibre8">The previous security configuration can also be specified by means of the <code class="email">META-INF/ejb-jar.xml</code> and <code class="email">META-INF/jboss-ejb3.xml</code> file in case you prefer using standard configuration files.</p></div><p class="calibre8">To pass your login credentials to the web service, you can use the <code class="email">RequestContext</code> object:</p><div class="informalexample"><pre class="programlisting">final TicketWebService infoService = service.getPort(TicketWebService.class);
Map&lt;String, Object&gt; requestContext = ((BindingProvider) infoService).getRequestContext();
requestContext.put(BindingProvider.USERNAME_PROPERTY, "admin");
requestContext.put(BindingProvider.PASSWORD_PROPERTY, "admin");</pre></div><p class="calibre8">The username and password values will be passed to the login module defined in the security domain, just like in every other authentication method.</p></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Securing the transport layer"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec50" class="calibre1"/>Securing the transport layer</h1></div></div></div><p class="calibre8">If you <a id="id1108" class="calibre1"/>were to create a mission-critical application with just the bare concepts you learned until now, you would be exposed to all sorts of security threats. For example, if you need to design a payment gateway, where the credit card information is transmitted by means of an EJB or servlet, using just the authorization and authentication stack is really not enough, as the sensitive information is still sent across a network and it could be disclosed by a hacker.</p><p class="calibre8">In order to prevent disclosure of critical information to unauthorized individuals or systems, you have to use a protocol that provides encryption of the information. Encryption is the conversion of data into a form that cannot be understood by unauthorized people. Conversely, decryption is the process of converting encrypted data back into its original form so that it can be understood.</p><p class="calibre8">The protocols used to secure the communication are SSL and TLS, the latter being considered a replacement for the older SSL.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip11" class="calibre1"/>Tip</h3><p class="calibre8">The differences between the two protocols are minor and very technical. In short, TLS uses stronger encryption algorithms and has the ability to work on different ports. For<a id="id1109" class="calibre1"/> the rest of this chapter, we will refer to SSL for both protocols. Check out Wikipedia for more information on it: <a class="calibre1" href="http://en.wikipedia.org/wiki/Transport_Layer_Security">http://en.wikipedia.org/wiki/Transport_Layer_Security</a>.</p></div><p class="calibre8">There are two<a id="id1110" class="calibre1"/> basic techniques to encrypt information: symmetric encryption (also called secret-key encryption) and asymmetric encryption (also called public-key encryption).</p><p class="calibre8">Symmetric<a id="id1111" class="calibre1"/> encryption is the oldest and best-known technique. It is<a id="id1112" class="calibre1"/> based on a secret key, which is applied to the text of a message to change the content in a particular way. As long as both the sender and recipient know the secret key, they can encrypt and decrypt all messages that use this key. These encryption algorithms typically work fast and are well suited to encrypt blocks of messages at once.</p><p class="calibre8">One significant issue with symmetric algorithms is the requirement of a safe administrative organization to distribute keys to users. This generally results in increased overhead from the administrative aspect while the keys remain vulnerable to unauthorized disclosure and potential abuse.</p><p class="calibre8">For this reason, a mission-critical enterprise system usually relies on the asymmetric encryption algorithms, which tend to be easier to employ, manage, and are ultimately more secure.</p><p class="calibre8">Asymmetric cryptography, also known as <span class="strong"><strong class="calibre9">public-key cryptography</strong></span>, is based on the concept that the key used to encrypt is not the same as the key that is used to decrypt the message. In <a id="id1113" class="calibre1"/>practice, each user holds a couple of keys: the public key <a id="id1114" class="calibre1"/>that is distributed to other parties and the private key that is kept as a secret. Each message is encrypted with the recipient's public key and can only be decrypted (by the recipient) with his private key, as shown in the following diagram:</p><div class="mediaobject"><img src="../images/00085.jpeg" alt="Securing the transport layer" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Using <a id="id1115" class="calibre1"/>asymmetric encryption, you can be sure that your message cannot be disclosed to a third party. However, there is still one vulnerability.</p><p class="calibre8">Suppose you want to exchange some valuable information with a business partner and to that end are requesting his public key by telephone or email. A fraudulent user intercepts your e-mail or simply listens to your conversation and quickly sends you a fake mail with his public key. Now, even if your data transmission is secured, it will be directed to the wrong person!</p><p class="calibre8">In order to solve this issue, we need a document to verify that the public key belongs to a particular individual. This<a id="id1116" class="calibre1"/> document is called a <span class="strong"><strong class="calibre9">digital certificate</strong></span> or public-key certificate. A digital certificate consists of a formatted block of data that contains the name of the certificate holder (which may be either a user or system name) and the holder's public key, along with the digital signature of a <span class="strong"><strong class="calibre9">Certification Authority</strong></span> (<span class="strong"><strong class="calibre9">CA</strong></span>) for<a id="id1117" class="calibre1"/> authentication. The CA attests that the sender's name is the one associated with the public key in the document.</p><div class="mediaobject"><img src="../images/00086.jpeg" alt="Securing the transport layer" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Public key certificates are commonly used to secure the interaction with websites. By default, the <a id="id1118" class="calibre1"/>web browser ships with a set of predefined CAs; they are used to verify that the public certificate served to a browser when you enter a secure site has actually been issued by the owner of the website. In short, if you connect your browser to <code class="email">https://www.abc.com</code> and your browser doesn't give any certificate warning, you can safely interact with the entity in charge of the site, that is, unless the site or your browser has been hacked. However, this is another story.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note60" class="calibre1"/>Note</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Simple authentication and client authentication</strong></span></p><p class="calibre8">In the previous example, we depicted a simple authentication, (also called server authentication). In this scenario, the only party that needs to prove its identity is the server.</p><p class="calibre8">SSL, however, is able to perform mutual authentication (also called client or two-way authentication); here too, the server requests a client certificate during the SSL handshake over the network.</p><p class="calibre8">Client authentication requires a client certificate in the x.509 format from a CA. The x.509 format is an industry-standard format for SSL certificates. In the next section, we will explore which tools are available to generate digital certificates, and how to get your certificates signed by a CA.</p></div></div>

<div class="book" title="Securing the transport layer">
<div class="book" title="Enabling the Secure Socket Layer on WildFly"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec75" class="calibre1"/>Enabling the Secure Socket Layer on WildFly</h2></div></div></div><p class="calibre8">WildFly <a id="id1119" class="calibre1"/>uses the <span class="strong"><strong class="calibre9">Java Secure Socket Extension</strong></span> (<span class="strong"><strong class="calibre9">JSSE</strong></span>), which is bundled in the Java SE to leverage the SSL/TLS<a id="id1120" class="calibre1"/> communication.</p><p class="calibre8">An <a id="id1121" class="calibre1"/>Enterprise application can be secured <a id="id1122" class="calibre1"/>at two different locations: the HTTP level for web applications, and the RMI level for applications using EJB. HTTP communication is handled by the web subsystem within the <code class="email">standalone.xml</code>/<code class="email">domain.xml</code> file. Securing the RMI transport is, on the other hand, not always a compelling requirement of your applications. Actually, in most production environments, WildFly is placed behind a firewall.</p><p class="calibre8">As you can see from the following diagram, this implies that your EJBs are not directly exposed to untrusted networks, which usually connect through the web server placed in a demilitarized zone:</p><div class="mediaobject"><img src="../images/00087.jpeg" alt="Enabling the Secure Socket Layer on WildFly" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">In order to get started with WildFly and SSL, we need a tool that generates a public/private key pair in the form of an x.509 certificate for use by the SSL server sockets. This is covered in the next section.</p><div class="book" title="Certificate management tools"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec68" class="calibre1"/>Certificate management tools</h3></div></div></div><p class="calibre8">One <a id="id1123" class="calibre1"/>tool that can be used <a id="id1124" class="calibre1"/>to set <a id="id1125" class="calibre1"/>up a digital certificate is <span class="strong"><strong class="calibre9">keytool</strong></span>, a key and certificate management utility that ships with the Java SE. It enables users to administer their own public/private key pairs and associated certificates for use in self-authentication (where the user authenticates himself or herself to other users or services) or data integrity and authentication services, using digital signatures. It also allows users to cache the public keys (in the form of certificates) of their communicating peers.</p><p class="calibre8">The keytool stores the keys and certificates in a file termed keystore, a repository of certificates used to identify a client or server. Typically, a keystore contains a client or server's identity, which is protected by a password. Let's see an example of the keystore generation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -genkey -keystore wildfly.keystore -storepass mypassword -keypass mypassword -keyalg RSA -validity 180  -alias wflyalias   -dname "cn=John Smith,o=PackPub,c=GB"</strong></span>
</pre></div><p class="calibre8">This command creates the keystore named <code class="email">wildfly.keystore</code> in the working directory, and assigns it the password <code class="email">mypassword</code>. It generates a public/private key pair for the entity whose unique name has the common name <code class="email">John Smith</code>, organization <code class="email">PacktPub</code>, and two-letter country code <code class="email">GB</code>.</p><p class="calibre8">The result of this action will be a self-signed certificate (using the RSA signature algorithm), which includes the public key and the unique name. This certificate will be valid for 180 days, and is associated with the private key in a keystore entry referred to by<a id="id1126" class="calibre1"/> the alias <code class="email">wflyalias</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip12" class="calibre1"/>Tip</h3><p class="calibre8">A self-signed certificate is a certificate that has not been verified by a CA and thus, leaves <a id="id1127" class="calibre1"/>you vulnerable to the classic man-in-the-middle attack. A self-signed certificate is only suitable for in-house use or for testing while you wait for your real certificate to arrive.</p></div></div><div class="book" title="Securing the HTTP communication with a self-signed certificate"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec69" class="calibre1"/>Securing the HTTP communication with a self-signed certificate</h3></div></div></div><p class="calibre8">Now<a id="id1128" class="calibre1"/> let's see how <a id="id1129" class="calibre1"/>you <a id="id1130" class="calibre1"/>can use this keystore file to secure your WildFly web channel. Open your server configuration file and locate the web subsystem.</p><p class="calibre8">Within the web subsystem, you have to first change the default <code class="email">http-listener</code> and <code class="email">socket-binding</code> to <code class="email">https-listener</code> and <code class="email">"https"</code>, and add the <code class="email">security-realm </code>element to it. Next, you have to insert an <code class="email">ssl</code> stanza within it, which contains the details of your <code class="email">keystore</code> object (in our example, we dropped the file <code class="email">jboss.keystore</code> into the server configuration directory):</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
            &lt;buffer-caches&gt;
                &lt;buffer-cache name="default" buffer-size="1024" buffers-per-region="1024" max-regions="10"/&gt;
            &lt;/buffer-caches&gt;
            &lt;server name="default-server"&gt;
<span class="strong"><strong class="calibre9">                &lt;https-listener name="default" socket-binding="https" security-realm="EJBRealm"/&gt;</strong></span>
                &lt;host name="default-host" alias="localhost"&gt;
                    &lt;location name="/" handler="welcome-content"/&gt;
                    &lt;filter-ref name="server-header"/&gt;
                    &lt;filter-ref name="x-powered-by-header"/&gt;
                &lt;/host&gt;
            &lt;/server&gt;
            &lt;servlet-container name="default" default-buffer-cache="default" stack-trace-on-error="local-only"&gt;
                &lt;jsp-config/&gt;
            &lt;/servlet-container&gt;
            // some more code
        &lt;/subsystem&gt;</pre></div><p class="calibre8">As you can see, we referenced <code class="email">EJBRealm</code> in the configuration, but we still need to define it. We will do this in the next sections.</p></div><div class="book" title="Generating the server and client certificates"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec70" class="calibre1"/>Generating the server and client certificates</h3></div></div></div><p class="calibre8">Start by generating a<a id="id1131" class="calibre1"/> public/private key<a id="id1132" class="calibre1"/> pair<a id="id1133" class="calibre1"/> for the entity whose unique name has the <a id="id1134" class="calibre1"/>common name <code class="email">John Smith</code>, organization <code class="email">PacktPub</code>, and two-letter country code <code class="email">GB</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -genkey -v -alias wflyAlias -keyalg RSA -keysize 1024 -keystore wfly.keystore -validity 180 -keypass mypassword -storepass mypassword -dname "cn=John Smith,o=PacktPub,c=GB"</strong></span>
</pre></div><p class="calibre8">Next, export the server's public key into a certificate named <code class="email">sslPublicKey.cer</code> that uses the password <code class="email">mypassword</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -export -keystore jboss.keystore -alias wflyAlias -file sslPublicKey.cer -keypass mypassword -storepass mypassword</strong></span>
</pre></div><p class="calibre8">Now that we have finished configuring the server, we will generate a key pair for the client too. We will do this by using the alias <code class="email">ejbclientalias</code> and the same properties as we did for the server's <code class="email">keystore</code> object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -genkey -v -alias ejbclientalias -keyalg RSA -keysize 1024 -keystore jbossClient.keystore -validity 180 -keypass clientPassword -storepass clientPassword -dname "cn=John Smith,o=PacktPub,c=GB"</strong></span>
</pre></div><p class="calibre8">The client public key will also be exported to a certificate named <code class="email">clientPublicKey.cer</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -export -keystore jbossClient.keystore -alias ejbclientalias -file clientPublicKey.cer -keypass clientPassword -storepass clientPassword</strong></span>
</pre></div><p class="calibre8">Now, in order to complete the SSL handshake successfully, we need to first import the client's public key into the server's <code class="email">truststore</code> object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -import -v -trustcacerts -alias ejbclientalias -file clientPublicKey.cer -keystore jboss.keystore -keypass mypassword -storepass mypassword</strong></span>
</pre></div><p class="calibre8">The server certificate also needs to be trusted by the client. You have two available options to solve this issue, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Import the server certificate into the client's JDK bundle of certificates</li><li class="listitem">Create a new repository of certificates trusted by the client (<code class="email">truststore</code>)</li></ul></div><p class="calibre8">Importing the server certificate into the client JDK means executing a certificate import into the client's certified authorities.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -import -v -trustcacerts -alias wflyAlias -file sslPublicKey.cer -keystore C:\Java\jdk1.8.0_20\jre\lib\security\cacerts   </strong></span>
</pre></div><p class="calibre8">We just have to replace the path we used with our actual JDK path and use the client store's password in order to complete this operation (the default value is <code class="email">changeit</code>).</p><p class="calibre8">Otherwise, if you want to import the certificate into a newly created <code class="email">truststore</code> object, just substitute the <code class="email">cacerts</code> destination<a id="id1135" class="calibre1"/> with your <a id="id1136" class="calibre1"/>client's <code class="email">truststore</code> object.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -import -v -trustcacerts -alias wflyAlias -file sslPublicKey.cer -keystore jbossClient.keystore -keypass clientPassword -storepass  clientPassword</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note61" class="calibre1"/>Note</h3><p class="calibre8">If <a id="id1137" class="calibre1"/>you choose the latter option, you need to add the <a id="id1138" class="calibre1"/>following properties to your client's JDK arguments, which will override the default JDK's <code class="email">truststore</code> object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">java -Djavax.net.ssl.trustStore=&lt;truststorefile&gt;</strong></span>
<span class="strong"><strong class="calibre9">-Djavax.net.ssl.trustStorePassword=&lt;password&gt;</strong></span>
</pre></div></div></div><div class="book" title="Creating an SSL-aware security realm"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec71" class="calibre1"/>Creating an SSL-aware security realm</h3></div></div></div><p class="calibre8">Within WildFly, security<a id="id1139" class="calibre1"/> realms are used to secure access to the management interfaces, HTTP interface, and<a id="id1140" class="calibre1"/> remote JNDI and EJB access. Within a security realm, it is also possible to define an identity for the server; this identity can be used for both inbound connections to the server and outbound connections being established by the server.</p><p class="calibre8">Therefore, in order to enable SSL communication for our EJB communication and HTTP, we will define a security realm (named <code class="email">EJBRealm</code>) that is bound to a server identity, which references the server's <code class="email">keystore</code> object, shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;security-realm name="EJBRealm"&gt;
&lt;server-identities&gt;
      &lt;ssl&gt;
<span class="strong"><strong class="calibre9">       &lt;keystore path="jboss.keystore" relative-to="jboss.server.config.dir" keystore-password="mypassword"/&gt;</strong></span>
      &lt;/ssl&gt;
   &lt;/server-identities&gt;
   &lt;authentication&gt;
<span class="strong"><strong class="calibre9">        &lt;jaas name="ejb-security-domain"/&gt;</strong></span>
   &lt;/authentication&gt;
&lt;/security-realm&gt;</pre></div><p class="calibre8">Besides containing the location where SSL certificates are stored, this security realm also contains the authentication policy used by your EJBs, which is defined by the JAAS's security domain, named <code class="email">ejb-security-domain</code>.</p><p class="calibre8">The following is a security domain definition, which is a simple file-based security domain containing the user credentials and roles in the files <code class="email">ejb-users.properties</code> and <code class="email">ejb-roles.properties</code>, respectively:</p><div class="informalexample"><pre class="programlisting">&lt;security-domain name="ejb-security-domain" cache-type="default"&gt;
&lt;authentication&gt;
  &lt;login-module code="Remoting" flag="optional"&gt;
    &lt;module-option name="password-stacking" value="useFirstPass"/&gt;
  &lt;/login-module&gt;
  &lt;login-module code="org.jboss.security.auth.spi.UsersRolesLoginModule" flag="required"&gt;
    &lt;module-option name="defaultUsersProperties" value="${jboss.server.config.dir}/ejb-users.properties"/&gt;
    &lt;module-option name="defaultRolesProperties" value="${jboss.server.config.dir}/ejb-roles.properties"/&gt;
    &lt;module-option name="usersProperties" value="${jboss.server.config.dir}/ejb-users.properties"/&gt;
    &lt;module-option name="rolesProperties" value="${jboss.server.config.dir}/ejb-roles.properties"/&gt;
    &lt;module-option name="password-stacking" value="useFirstPass"/&gt;
  &lt;/login-module&gt;
&lt;/authentication&gt;
&lt;/security-domain&gt;</pre></div><p class="calibre8">As <a id="id1141" class="calibre1"/>you can imagine, you<a id="id1142" class="calibre1"/> need to create the two property files, each with some values in them. For example, here's the <code class="email">ejb-user.properties</code> file to be placed in the server configuration's folder:</p><div class="informalexample"><pre class="programlisting">adminUser=admin123</pre></div><p class="calibre8">The following is the corresponding <code class="email">ejb-roles.properties</code> file that grants the role <code class="email">ejbRole</code> to the <code class="email">adminUser</code> role:</p><div class="informalexample"><pre class="programlisting">adminUser=ejbRole</pre></div><p class="calibre8">The last configuration effort <a id="id1143" class="calibre1"/>would <a id="id1144" class="calibre1"/>be to specify it in the <code class="email">security-realm</code> attribute of your <code class="email">remoting</code> connector's element:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
    &lt;endpoint worker="default"/&gt;
    &lt;http-connector name="http-remoting-connector" 
    connector-ref="default" 
<span class="strong"><strong class="calibre9">    security-realm="EJBRealm"/&gt;</strong></span>
&lt;/subsystem&gt;</pre></div><p class="calibre8">Let's check the outcome of our work. First, we will try out the HTTPS connection.</p><p class="calibre8">You have to restart WildFly to activate the changes. You should see the following log at the bottom of your console, which informs you about the new HTTPS channel running on port 8443:</p><div class="informalexample"><pre class="programlisting">[org.wildfly.extension.undertow] (MSC service thread 1-9) JBAS017519: Undertow HTTP listener default listening on /127.0.0.1:8443</pre></div><p class="calibre8">The following screen is what will be displayed by the Internet Explorer (don't try this at home) browser (the same kind of error message, with a different format, will be displayed by other browsers such as Firefox and Google Chrome) if you try to access the Ticket example using the secured channel (for example, <code class="email">https://localhost:8443/ticket-agency-cdi</code>):</p><div class="mediaobject"><img src="../images/00088.jpeg" alt="Creating an SSL-aware security realm" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">What happened? Once you establish a secure connection with the web server, the server certificate is sent to the browser. Since the certificate has not been signed by any recognized CA, the browser security sandbox warns the user about the potential security threat.</p><p class="calibre8">This is an in-house test so we can safely proceed by choosing <span class="strong"><strong class="calibre9">Continue to this website</strong></span>. That's all you need to do in order to activate the Secure Socket Layer with a self-signed certificate.</p></div><div class="book" title="Securing HTTP communication with a certificate signed by a CA"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec72" class="calibre1"/>Securing HTTP communication with a certificate signed by a CA</h3></div></div></div><p class="calibre8">Having<a id="id1145" class="calibre1"/> your<a id="id1146" class="calibre1"/> certificate<a id="id1147" class="calibre1"/> signed requires a <span class="strong"><strong class="calibre9">certificate-signing request</strong></span> (<span class="strong"><strong class="calibre9">CSR</strong></span>) to be issued to a CA, which will return a signed certificate to be installed on your server. This implies a cost for your organization, which depends on how many certificates you request, the encryption strength, and other factors.</p><p class="calibre8">Firstly, generate a CSR using the newly created <code class="email">keystore</code> and keyentry:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -certreq -keystore jboss.keystore -alias wflyalias -storepass mypassword -keypass mypassword  -keyalg RSA  -file certreq.csr</strong></span>
</pre></div><p class="calibre8">This will create a new certificate request named <code class="email">certreq.csr</code>, bearing the following format:</p><div class="informalexample"><pre class="programlisting">-----BEGIN NEW CERTIFICATE REQUEST-----
. . . . . .
-----END NEW CERTIFICATE REQUEST-----</pre></div><p class="calibre8">The previous<a id="id1148" class="calibre1"/> certificate needs to be transmitted to the CA. At the end of the<a id="id1149" class="calibre1"/> enrollment phase, the CA will return a signed certificate, which needs to be imported into your keychain. The following code assumes you saved your CA certificate in a file named <code class="email">signed_ca.txt</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">keytool -import -keystore jboss.keystore -alias testkey1 -storepass mypassword -keypass mypassword -file signed_ca.txt</strong></span>
</pre></div><p class="calibre8">Now, your web browser will recognize your new certificate as being signed by a CA, so it won't complain about not being able to validate the certificate.</p></div><div class="book" title="Securing EJB communication"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec73" class="calibre1"/>Securing EJB communication</h3></div></div></div><p class="calibre8">EJB<a id="id1150" class="calibre1"/> clients interact <a id="id1151" class="calibre1"/>with the Enterprise EJB tier using the RMI-IIOP protocol. The RMI-IIOP protocol has been developed by Sun to combine the RMI programming model with the IIOP underlying transport.</p><p class="calibre8">Securing the EJB transport is required for applications that have strict secure policies, which cannot be carried out using clear text transmission. In order to do this, we need to be sure to complete the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, generate the SSL certificates and then store the client's public key in the server's <code class="email">keystore</code> object and the server's public key on the client's <code class="email">truststore;</code> we've already done this in order to prepare our HTTPS connector.</li><li class="listitem" value="2">Next, we need to create an SSL-aware security realm, which will be used by the <code class="email">remoting</code> transport. We can use the one created for the HTTPS communication.</li><li class="listitem" value="3">Finally, we need to apply some changes to our EJB application so that it actually uses the SSL secure channel. We will cover this in the next subsection.</li></ol><div class="calibre16"/></div></div><div class="book" title="Connecting to an SSL-aware security realm"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec74" class="calibre1"/>Connecting to an SSL-aware security realm</h3></div></div></div><p class="calibre8">As you saw in <a class="calibre1" title="Chapter 3. Introducing Java EE 7 – EJBs" href="part0023_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Introducing Java EE 7 – EJBs</em></span>, the<a id="id1152" class="calibre1"/> RMI-IIOP connection properties are <a id="id1153" class="calibre1"/>specified in the <code class="email">jboss-ejb-client.properties</code> file, which needs to be tweaked a bit to enable SSL connections:</p><div class="informalexample"><pre class="programlisting">remote.connections=node1 
remote.connection.node1.host=localhost
remote.connection.node1.port = 4447
<span class="strong"><strong class="calibre9">remote.connection.node1.username=adminUser</strong></span>
<span class="strong"><strong class="calibre9">remote.connection.node1.password=admin123</strong></span>
<span class="strong"><strong class="calibre9">remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED=true</strong></span>
<span class="strong"><strong class="calibre9">remote.connection.node1.connect.options.org.xnio.Options.SSL_STARTTLS=true</strong></span>
<span class="strong"><strong class="calibre9">remote.connection.node1.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=true</strong></span>
</pre></div><p class="calibre8">The <code class="email">SSL_ENABLED</code> option, when<a id="id1154" class="calibre1"/> set to <code class="email">true</code>, enables the <code class="email">remoting</code> connector's SSL communication.</p><p class="calibre8">The <code class="email">STARTTLS</code> option<a id="id1155" class="calibre1"/> specifies whether to use the <span class="strong"><strong class="calibre9">Tunneled Transport Layer Security</strong></span> (<span class="strong"><strong class="calibre9">TTLS</strong></span>) mode<a id="id1156" class="calibre1"/> at startup or when needed.</p><p class="calibre8">The <a id="id1157" class="calibre1"/>
<code class="email">SASL_POLICY_NOANONYMOUS</code> option<a id="id1158" class="calibre1"/> specifies whether <span class="strong"><strong class="calibre9">Simple Authentication and Security Layer</strong></span> (<span class="strong"><strong class="calibre9">SASL</strong></span>) mechanisms, which accept anonymous logins, are permitted.</p><p class="calibre8">Finally, since our security realm also includes an authentication security domain, we can choose to restrict access to some methods by specifying a <code class="email">@RolesAllowed</code> annotation, which requires the role <code class="email">ejbRole</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@RolesAllowed("ejbRole")</strong></span>
public String bookSeat(int seatId)  throws SeatBookedException {
 . . . .
}</pre></div><p class="calibre8">In order to activate the security domain on your EJBs, we need to mention it in the assembly descriptor of your <code class="email">jboss-ejb3.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;jboss:ejb-jar&gt;
  &lt;assembly-descriptor&gt;
    &lt;s:security&gt;
      &lt;ejb-name&gt;*&lt;/ejb-name&gt;
<span class="strong"><strong class="calibre9">          &lt;s:security-domain&gt;ejb-security-domain&lt;/s:security-domain&gt;</strong></span>
    &lt;/s:security&gt;
  &lt;/assembly-descriptor&gt;
&lt;/jboss:ejb-jar&gt;</pre></div><p class="calibre8">Now, redeploy the Ticket EJB example application, following the directions contained in <a class="calibre1" title="Chapter 3. Introducing Java EE 7 – EJBs" href="part0023_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Introducing Java EE 7 – EJBs</em></span>, and execute the client.</p><p class="calibre8">If the connection is successful, then<a id="id1159" class="calibre1"/> you have configured a fully working and secured remoting <a id="id1160" class="calibre1"/>connection.</p></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec51" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">We started this chapter by discussing the basic concepts of security and the difference between authentication and authorization.</p><p class="calibre8">WildFly uses the PicketBox framework sitting on top of the <span class="strong"><strong class="calibre9">Java Authentication and Authorization Service</strong></span> (<span class="strong"><strong class="calibre9">JAAS</strong></span>), which secures all the Java EE technologies running in the application. The core section of the security subsystem is contained in the security-domain element that performs all the required <span class="strong"><strong class="calibre9">authorization</strong></span> and <span class="strong"><strong class="calibre9">authentication</strong></span> checks.</p><p class="calibre8">Then, we took a much closer look at the login modules, which are used to store the user credentials and their associated roles. In particular, you learned how to apply the file-based <code class="email">UserRoles</code> login module and the <code class="email">Database</code> login module. Each login module can be used by Enterprise applications in either a programmatic or declarative way. While programmatic security can provide a fine-grained security model, you should consider using declarative security, which allows a clean separation between the business layer and the security policies.</p><p class="calibre8">Finally, in the last section of this chapter, we covered how to encrypt the communication channel using the Secure Socket Layer and the certificates produced by the <code class="email">keytool</code> Java utility.</p><p class="calibre8">In the next chapter, we are going to discuss clustering, which is the environment where critical applications are deployed.</p></div></body></html>