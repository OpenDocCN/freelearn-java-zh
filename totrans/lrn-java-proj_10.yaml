- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Interfaces and Abstract Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口和抽象类
- en: In [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), we learned about another
    core pillar of OOP, namely inheritance. We saw that Java uses the `extends` keyword
    to define an “is-a” inheritance relationship between the child and the parent
    class. The subclass inherits functionality from its parent that enables code reuse,
    a core benefit of inheritance. Java prevents multiple class inheritance by ensuring
    you can only extend from one class at a time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19793_09.xhtml#_idTextAnchor205)中，我们学习了面向对象编程的另一个核心支柱，即继承。我们了解到Java使用`extends`关键字来定义子类和父类之间的“是”继承关系。子类从其父类继承功能，这实现了代码重用，这是继承的核心好处。Java通过确保一次只能从一个类扩展来防止多重类继承。
- en: We also took a deep dive into the other remaining pillar of OOP, polymorphism.
    Polymorphism is enabled by subclasses overriding the parent class instance methods.
    We saw that, regarding the hierarchy, references can point (across) to objects
    of their own type and (down) to subclass objects. An exception occurs if a reference
    attempts to point (up) to parent objects in the hierarchy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入探讨了面向对象编程（OOP）的另一个支柱——多态。多态是通过子类重写父类实例方法来实现的。我们了解到，在层次结构中，引用可以指向它们自己的类型对象（跨类型）和子类对象（向下）。如果引用尝试指向层次结构中的父对象，则会发生异常。
- en: Next, we compared and contrasted method overloading and method overriding. In
    method overriding, the method signatures must match (except for covariant returns).
    In method overloading, while the method names are the same, the method signatures
    must be different.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们比较和对比了方法重载和方法重写。在方法重写中，方法签名必须匹配（除了协变返回）。在方法重载中，虽然方法名称相同，但方法签名必须不同。
- en: We also discovered that the order of constructor calls is from the top (base
    class) down. This is facilitated by the `super()` keyword. To access a parent
    (non-constructor) member, we can use the `super.` syntax.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现构造函数调用的顺序是从上（基类）到下。这是由`super()`关键字实现的。要访问父（非构造函数）成员，我们可以使用`super.`语法。
- en: We then revisited the `protected` access modifier and demonstrated that, for
    subclasses outside the package to access the protected member, they must do so
    via inheritance in a very specific manner. In effect, once outside the package,
    the `protected` member becomes private to subclasses (of the class containing
    the `protected` member).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了`protected`访问修饰符，并演示了对于包外部的子类要访问受保护的成员，它们必须以非常具体的方式通过继承来这样做。实际上，一旦包外部，受保护的成员对子类（包含受保护成员的类）来说就变成了私有。
- en: 'We then covered two keywords that have an impact on inheritance: `abstract`
    and `final`. As an `abstract` method has no implementation code, it is intended
    to be overridden. The first non-abstract (concrete) subclass must provide implementation
    code for any inherited `abstract` methods. The `final` keyword can be applied
    in several scenarios. Concerning inheritance, a `final` method cannot be overridden
    and a `final` class cannot be subclassed.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了两个对继承有影响的关键字：`abstract`和`final`。由于抽象方法没有实现代码，它旨在被重写。第一个非抽象（具体）子类必须为任何继承的`abstract`方法提供实现代码。`final`关键字可以在几种情况下应用。关于继承，`final`方法不能被重写，`final`类不能被继承。
- en: Next, we discussed `sealed` classes, which enable us to scope parts of the inheritance
    tree. Using the `sealed` and `permits` keywords, we can state that a class can
    only be subclassed by certain other named classes. The `non-sealed` keyword ends
    the scoping task and thus enables us to subclass as normal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了`sealed`类，它使我们能够限制继承树的部分。使用`sealed`和`permits`关键字，我们可以声明一个类只能被某些其他命名的类继承。`non-sealed`关键字结束范围任务，因此使我们能够正常地继承。
- en: We examined both `instance` and `static` blocks in an inheritance hierarchy.
    A `static` block is only executed once when a class is first loaded. An `instance`
    block, on the other hand, is executed every time an object instance is created,
    making it an ideal place to insert code common to all constructors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了继承层次结构中的`instance`和`static`块。`static`块仅在类首次加载时执行一次。另一方面，`instance`块在每次创建对象实例时执行，这使得它成为插入对所有构造函数都通用的代码的理想位置。
- en: Lastly, we examined upcasting and downcasting. Whereas upcasting is never an
    issue, downcasting can lead to an exception. Use of the `instanceof` keyword helps
    prevent this exception.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了向上转型和向下转型。向上转型永远不会成为问题，而向下转型可能会导致异常。使用`instanceof`关键字有助于防止这种异常。
- en: In this chapter, we will cover `abstract` classes and interfaces. We will compare
    and contrast them. Interfaces have had several changes over the years. With the
    aid of examples, we will examine these changes. Java 8 introduced both `static`
    and `default` methods for interfaces, thereby enabling code to be present in an
    interface for the first time. In Java 9, to reduce code duplication and improve
    encapsulation, `private` methods were introduced to interfaces. Finally, Java
    17 introduced `sealed` interfaces, which enable us to customize what classes can
    implement our interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍`abstract`类和接口。我们将比较和对比它们。接口在多年中经历了几次变化。通过示例，我们将检查这些变化。Java 8为接口引入了`static`和`default`方法，从而使得代码第一次可以存在于接口中。在Java
    9中，为了减少代码重复并提高封装性，接口中引入了`private`方法。最后，Java 17引入了`sealed`接口，这使得我们可以自定义哪些类可以实现我们的接口。
- en: 'This chapter covers the following main topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Understanding `abstract` classes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`abstract`类
- en: Mastering interfaces
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握接口
- en: Examining `default` and `static` interface methods
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`default`和`static`接口方法
- en: Explaining `private` interface methods
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`private`接口方法
- en: Exploring `sealed` interfaces
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`sealed`接口
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10)。
- en: Understanding abstract classes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`abstract`类
- en: In [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), we covered the `abstract`
    keyword. Let’s review some key points that we discussed. An `abstract` method
    is exactly that – it is abstract. It has no code. It doesn’t even have curly braces
    – `{}`. This is typically a design decision. The class containing the `abstract`
    method wants subclasses to provide the code. This means that the class itself
    is “incomplete” and therefore any class defining an `abstract` method must itself
    be `abstract`. Any subclass of the `abstract` class must either override the `abstract`
    method or declare that it too is `abstract`. The compiler will complain otherwise.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19793_09.xhtml#_idTextAnchor205)中，我们介绍了`abstract`关键字。让我们回顾一下我们讨论的一些关键点。一个`abstract`方法正是如此——它是抽象的。它没有代码。甚至没有花括号——`{}`。这通常是一个设计决策。包含`abstract`方法的类希望子类提供代码。这意味着该类本身是“不完整”的，因此任何定义`abstract`方法的类本身也必须是`abstract`。任何`abstract`类的子类必须要么覆盖`abstract`方法，要么声明它本身也是`abstract`。否则，编译器会报错。
- en: However, the inverse is not the case – an `abstract` class need not have any
    `abstract` methods at all. Again, this is a design decision. Since the class is
    marked as `abstract`, it is considered “incomplete” (even though it may contain
    code for all the methods). This prevents objects based on `abstract` classes from
    being instantiated. In other words, you cannot `new` an object based on an `abstract`
    class. You can, however, have a reference based on an `abstract` type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并非总是如此——一个`abstract`类根本不需要有任何`abstract`方法。同样，这也是一个设计决策。由于类被标记为`abstract`，它被认为是“不完整”的（即使它可能包含所有方法的代码）。这阻止了基于`abstract`类的对象被实例化。换句话说，你不能基于`abstract`类创建对象。然而，你可以有一个基于`abstract`类型的引用。
- en: Please refer to *Figure 9**.14* for a code example of `abstract` methods and
    classes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*图9**.14*以获取`abstract`方法和类的代码示例。
- en: Mastering interfaces
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握接口
- en: By default, an interface is an `abstract` construct. Before Java 8, all the
    methods in an interface were `abstract`. In general, when you create an interface,
    you are defining a contract for *what* a class can do without saying anything
    about *how* the class will do it. A class signs the contract when it implements
    an interface. A class implementing an interface is agreeing to “obey” the contract
    defined in the interface. “Obeying” here means that, if a concrete (non-abstract)
    class is implementing an interface, the compiler will ensure that the class has
    implementation code for each `abstract` method in the interface. As the Oracle
    tutorials state, “*Implementing an interface allows a class to become more formal
    about the behavior it promises* *to provide*.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，接口是一个`abstract`结构。在Java 8之前，接口中的所有方法都是`abstract`的。一般来说，当你创建一个接口时，你是在定义一个关于类可以做什么的合同，而没有说关于类将如何做的任何事情。一个类在实现接口时签署了这个合同。实现接口的类是同意“遵守”接口中定义的合同。“遵守”在这里意味着，如果一个具体的（非抽象）类实现了接口，编译器将确保该类为接口中的每个`abstract`方法都有实现代码。正如Oracle教程所述，“*实现接口允许一个类更正式地承诺它将提供的行为*。”
- en: 'In contrast to classes, where you can (directly) inherit from only one other
    class, a class can implement many interfaces. Thus, interfaces enable multiple
    inheritance. Let’s look at an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与类不同，你只能（直接）从另一个类继承，但一个类可以实现多个接口。因此，接口实现了多重继承。让我们看看一个例子：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line of code states that `Dog` “is-a” `Animal`, `Moveable`, and `Loveable`.
    Interface names are often adjectives as they often describe a quality of a noun.
    Thus, interface names often end in “able.” For example, `Iterable` and `Callable`
    are interface names in the Java API.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码表明`Dog`“是”`Animal`、“Moveable”和`Loveable`。接口名称通常是形容词，因为它们通常描述名词的性质。因此，接口名称通常以“able”结尾。例如，`Iterable`和`Callable`是Java
    API中的接口名称。
- en: n the previous line of code, we are limited to extending from one class but
    we can implement as many interfaces as we like. This flexibility is very powerful
    as we can link into hierarchies without forcing artificial class relationships.
    This is one of the core reasons for interfaces – *to be able to cast to more than
    one* *base type*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们受限于只能从一个类扩展，但我们可以实现任意多的接口。这种灵活性非常强大，因为我们可以在不强制人工类关系的情况下链接到层次结构。这是接口的核心原因之一——*能够将类型转换为多个*基础类型*。
- en: As with `abstract` classes, given that interfaces are also `abstract`, you cannot
    `new` an `interface` type. In addition, similarly to `abstract` classes, you can
    (and often do) have references that are interface types.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与`abstract`类一样，由于接口也是`abstract`的，你不能`new`一个接口类型。此外，类似于`abstract`类，你可以（并且经常这样做）有接口类型的引用。
- en: 'In later sections, we will discuss the `static`, `default`, and `private` methods,
    all of which have implementation code. Before that, we will deal with the other
    type of methods we can use in an interface: `abstract` methods. Additionally,
    we will discuss interface constants.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将讨论具有实现代码的`static`、`default`和`private`方法。在此之前，我们将处理我们可以在接口中使用的另一种类型的方法：`abstract`方法。此外，我们还将讨论接口常量。
- en: Abstract methods in interfaces
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口中的抽象方法
- en: Prior to Java 8, all of the methods in an interface were implicitly `public`
    and `abstract` by default. Back then, you could state that an interface was a
    “purely abstract class.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，接口中的所有方法默认都是`public`和`abstract`的。那时，你可以认为接口是一个“纯粹的抽象类”。
- en: Concerning the `public` access modifier, this is still the case, even though
    Java 9 introduced `private` methods. This means that, you can explicitly mark
    a method in an interface as `public` or `private`. However, if you do *not* specify
    any access modifier, `public` is the default.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`public`访问修饰符，尽管Java 9引入了`private`方法，但这仍然适用。这意味着你可以在接口中显式地将一个方法标记为`public`或`private`。然而，如果你没有指定任何访问修饰符，`public`是默认的。
- en: 'What about their abstract nature? Well, any method that is *not* denoted as
    `static`, `default`, or `private` is still `abstract` by default. *Figure 10**.1*
    encapsulates this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的抽象性质如何呢？嗯，任何未标记为`static`、`default`或`private`的方法默认情况下都是`abstract`的。*图10.1*概括了这一点：
- en: '![Figure 10.1 – Abstract methods in an interface](img/B19793_10_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 接口中的抽象方法](img/B19793_10_1.jpg)'
- en: Figure 10.1 – Abstract methods in an interface
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 接口中的抽象方法
- en: In this figure, we can see that the `m2()` method is `public` and `abstract`,
    even though none of those keywords are explicitly coded. The only other valid
    access modifier is `private`, as shown when declaring `m3()` on line 6\. The fact
    that `m4()` does not compile (line 7) demonstrates that `protected` is not a valid
    access modifier on interface methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以看到`m2()`方法是`public`和`abstract`的，尽管这些关键字都没有明确编码。唯一的其他有效访问修饰符是`private`，正如在第6行声明`m3()`时所示。`m4()`无法编译（第7行）的事实表明，`protected`不是接口方法的有效访问修饰符。
- en: Can we declare variables in an interface? Yes, we can. Let’s discuss them now.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否在接口中声明变量？是的，我们可以。现在让我们来讨论它们。
- en: Interface constants
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口常量
- en: 'Any variables specified in an interface are `public`, `static`, and `final`
    by default. In effect, they are constants, and thus, their initial values cannot
    be changed. By placing these constants in the interface, any class implementing
    the interface has access to them (via inheritance), but they are read-only. *Figure
    10**.2* shows some interface constants:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中指定的任何变量默认都是`public`、`static`和`final`。实际上，它们是常量，因此，它们的初始值不能被更改。通过将这些常量放在接口中，任何实现该接口的类都可以访问它们（通过继承），但它们是只读的。*图10**.2*展示了某些接口常量：
- en: '![Figure 10.2 – Interface constants](img/B19793_10_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 接口常量](img/B19793_10_2.jpg)'
- en: Figure 10.2 – Interface constants
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 接口常量
- en: In the preceding figure, we have two variables, namely `VALUE1` and `VALUE2`.
    Both are constants. `VALUE1` states explicitly that it is `public`, `static`,
    and `final`, whereas `VALUE2` does the same implicitly (no keywords are used).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有两个变量，即`VALUE1`和`VALUE2`。它们都是常量。`VALUE1`明确声明它是`public`、`static`和`final`，而`VALUE2`隐式地做了同样的事情（没有使用关键字）。
- en: Now, let’s look at an example where a class implements an interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个类实现接口的例子。
- en: '*Figure 10**.3* represents a class implementing an interface:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10**.3*表示一个实现接口的类：'
- en: '![Figure 10.3 – A class implementing an interface](img/B19793_10_3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 实现接口的类](img/B19793_10_3.jpg)'
- en: Figure 10.3 – A class implementing an interface
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 实现接口的类
- en: In this figure, lines 3-6 represent an interface called `Moveable` that declares
    a constant, `HOW`, and a method, `move()`. The `Dog` class on line 7 declares
    that it implements `Moveable`. Therefore, since `Dog` is a concrete, non-abstract
    class, it must provide an implementation for `move()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第3-6行代表一个名为`Moveable`的接口，它声明了一个常量`HOW`和一个方法`move()`。第7行的`Dog`类声明它实现了`Moveable`。因此，由于`Dog`是一个具体的、非抽象类，它必须为`move()`提供实现。
- en: As we know, interface methods are `public` by default. However, this is not
    the case for classes. In classes, methods are package-private by default; which
    means, if you do not provide an access modifier on a method in a class, the method
    is package-private. Therefore, when overriding an interface method in a class,
    ensure that the method is `public`. As `package-private` (line 9) is weaker than
    `public` (line 5), we get a compiler error – hence this line is commented out.
    Line 11 shows that `move()` must be explicitly declared `public` in `Dog`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，接口方法默认是`public`的。然而，对于类来说并非如此。在类中，方法默认是包私有（package-private）；这意味着，如果你在类中的方法上没有提供访问修饰符，该方法是包私有的。因此，当在类中重写接口方法时，请确保该方法为`public`。因为`package-private`（第9行）比`public`（第5行）的权限弱，所以我们得到编译器错误——因此这一行被注释掉了。第11行显示，在`Dog`中必须显式声明`move()`为`public`。
- en: Line 15 shows that `HOW`, declared on line 4, is a constant. If uncommented,
    line 15 gives a compiler error as constants, once assigned a value, cannot change.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行显示，在第4行声明的`HOW`是一个常量。如果取消注释，第15行将给出编译器错误，因为常量一旦赋值后就不能更改。
- en: Lines 16 and 17 demonstrate both ways we can access the `HOW` constant – either
    by prepending it with the interface name (line 16) or directly (line 17).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第16行和第17行展示了我们可以访问`HOW`常量的两种方式——要么在接口名称前加上它（第16行），要么直接访问（第17行）。
- en: Line 19 shows that once inside a `static` method, which `main()` is, you cannot
    directly access an instance method, which `move()` is. This is because instance
    methods are secretly passed a reference to the (object) instance responsible for
    calling it, namely the `this` reference. Since `static` methods relate to the
    class and not a specific instance of the class, there is no `this` reference available
    in `static` methods. Thus, as per line 20, we need to create an instance and then
    use that instance to invoke `move()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第19行显示，一旦进入一个`static`方法，例如`main()`方法，就不能直接访问实例方法，例如`move()`方法。这是因为实例方法秘密地传递了一个指向调用它的（对象）实例的引用，即`this`引用。由于`static`方法与类相关，而不是与类的特定实例相关，因此在`static`方法中没有`this`引用。因此，根据第20行，我们需要创建一个实例，然后使用该实例来调用`move()`。
- en: When we run this program, lines 16 and 17 both output the value of the `walk`
    constant. Line 20 outputs `Dog::move()`, the output from the `Dog` implementation
    of `move()` (line 12).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，第16行和第17行都输出了`walk`常量的值。第20行输出了`Dog::move()`，这是`Dog`对`move()`（第12行）的实现的结果。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since Java 8, code is allowed in `default` methods. As `default` methods are
    inheritable, the compiler must step in to prevent multiple inheritance in interfaces
    from causing an issue. We will return to this when we discuss `default` methods
    in interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，允许在`default`方法中编写代码。由于`default`方法是可继承的，编译器必须介入以防止接口中的多重继承导致问题。我们将在讨论接口中的`default`方法时回到这个问题。
- en: Now, let’s look at multiple interface inheritance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看多重接口继承。
- en: Multiple interface inheritance
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重接口继承
- en: Unlike classes, where multiple inheritance is prohibited in Java, multiple inheritance
    is allowed in interfaces. Note that the issue with multiple class inheritance
    is that *if* multiple *class* inheritance was allowed, you could potentially inherit
    two distinct implementations for the same method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与类不同，在Java中不允许多重继承，但在接口中允许多重继承。请注意，多重类继承的问题在于，如果允许多重类继承，你可能会继承两个不同的同一方法实现。
- en: '*Figure 10**.4* shows an example of multiple interface inheritance:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10**.4* 展示了多重接口继承的一个例子：'
- en: '![Figure 10.4 – Multiple interface inheritance](img/B19793_10_4.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 多重接口继承](img/B19793_10_4.jpg)'
- en: Figure 10.4 – Multiple interface inheritance
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 多重接口继承
- en: 'In this figure, the `MoveableObject` interface on line 2 is an interface with
    no methods at all. This is known as a tagging interface. A tagging interface is
    used for type information using `instanceof`. For example, if you wanted to know
    if an object is an instance of a class that implements `MoveableObject`, you would
    code the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第2行的`MoveableObject`接口是一个没有任何方法的接口。这被称为标记接口。标记接口用于使用`instanceof`进行类型信息。例如，如果你想检查一个对象是否是实现了`MoveableObject`的类的实例，你会编写以下代码：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Lines 3-5 define an interface called `Spherical`. At this point we could simply
    define a class that directly implements both of these interfaces as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第3-5行定义了一个名为`Spherical`的接口。在这个阶段，我们可以简单地定义一个类，直接实现这两个接口，如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Line 6 is interesting – we can define an interface (`Bounceable` in this instance)
    that `extends` (inherits) from *both* of the other interfaces, namely `MoveableObject`
    and `Spherical`. Therefore, `Bounceable` has two `abstract` methods: one it defined
    itself, called `bounce()`, and one it inherited from `Spherical`, called `doSphericalThings()`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行很有趣——我们可以定义一个接口（在这个例子中是`Bounceable`），它从其他两个接口（即`MoveableObject`和`Spherical`）中扩展（继承）。因此，`Bounceable`有两个`abstract`方法：一个它自己定义的，称为`bounce()`，另一个它从`Spherical`继承的，称为`doSphericalThings()`。
- en: Since the `Volleyball` class implements `Bounceable` (line 11), it must override
    both `bounce()` and `doSphericalThings()`. As `Volleyball` does this, it compiles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Volleyball`类实现了`Bounceable`（第11行），它必须重写`bounce()`和`doSphericalThings()`这两个方法。当`Volleyball`这样做时，它就可以编译了。
- en: Note that on line 17, the `abstract` class, `Beachball`, states that it implements
    `Bounceable` also. However, as `Beachball` is `abstract`, the “contract” does
    not have to be obeyed; meaning, `Beachball` is free to implement all, some, or
    none of the `abstract` methods in `Bounceable`. In this example, none of the `abstract`
    methods required by `Bounceable` were implemented by `Beachball`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第17行，`abstract`类`Beachball`声明它也实现了`Bounceable`。然而，由于`Beachball`是`abstract`的，所以“合同”不必遵守；这意味着`Beachball`可以自由实现`Bounceable`中所有、一些或没有任何`abstract`方法。在这个例子中，`Beachball`没有实现`Bounceable`所要求的任何`abstract`方法。
- en: Now that we understand the implication of `abstract` methods in interfaces for
    implementing classes, let’s examine two of the non-abstract methods in interfaces
    – the `default` and `static` methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了接口中的`abstract`方法对实现类的影响，让我们来检查接口中的两个非`abstract`方法——`default`和`static`方法。
- en: Examining default and static interface methods
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查默认和静态接口方法
- en: Before Java 8, only `abstract` methods were allowed in interfaces. This meant
    that if you introduced a new `abstract` method to an existing interface, the classes
    that had already implemented that interface would break. This was inconvenient
    for not only Java developers but also the designers of Java.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，接口中只允许有`abstract`方法。这意味着如果你向现有的接口中引入一个新的`abstract`方法，已经实现该接口的类将会出错。这对Java开发者来说不方便，对Java的设计者来说也是如此。
- en: This all changed in Java 8, with the introduction of both `default` and `static`
    methods. One of the primary drivers for introducing `default` methods was to be
    able to introduce code into the interface and not break the existing client base.
    This maintained backward compatibility. In addition, this new code is automatically
    available to clients implementing that interface.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在Java 8中发生了变化，引入了`default`和`static`方法。引入`default`方法的主要驱动力是能够在接口中引入代码，而不破坏现有的客户端基础。这保持了向后兼容性。此外，新代码自动对实现该接口的客户端可用。
- en: A primary driver for the introduction of `static` methods was to keep utility
    code local to the interface rather than having it in a separate class, which was
    the case before their introduction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 引入`static`方法的主要驱动力是将实用代码保留在接口内部，而不是像引入之前那样放在一个单独的类中。
- en: Let’s discuss them in turn, starting with `default` methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次讨论它们，首先是`default`方法。
- en: ‘default’ interface methods
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ‘默认’接口方法
- en: An interface uses the `default` keyword to mark a method as inheritable by implementing
    classes. As already stated, if you do not specify an access modifier, they are
    `public` by default (pardon the pun!). Default methods must have an implementation
    - a set of curly braces must be present (even if they are empty braces). Classes
    that implement interfaces inherit any `default` methods. These classes may override
    the inherited version but this is not necessary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接口使用`default`关键字来标记一个方法，使其可以被实现类继承。正如之前所述，如果你没有指定访问修饰符，它们默认是`public`（请原谅这个双关语！）。默认方法必须有一个实现
    - 必须存在一组花括号（即使它们是空的花括号）。实现接口的类会继承任何`default`方法。这些类可以覆盖继承的版本，但这不是必需的。
- en: 'Let’s look at some example code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例代码：
- en: '![Figure 10.5 – Interface default methods](img/B19793_10_5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 接口默认方法](img/B19793_10_5.jpg)'
- en: Figure 10.5 – Interface default methods
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 接口默认方法
- en: In this figure, we have an `interface` called `Moveable` (lines 3-8). If line
    4 was uncommented, it would not compile since `default` (or `static`) interface
    methods must have code bodies. Line 5 defines a `default` method called `move()`.
    As there are no `abstract` methods in `Moveable`, classes implementing `Moveable`
    are not required to provide any particular methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有一个名为`Moveable`的`interface`（第3-8行）。如果第4行取消注释，它将无法编译，因为`default`（或`static`）接口方法必须具有代码体。第5行定义了一个名为`move()`的`default`方法。由于`Moveable`中没有`abstract`方法，实现`Moveable`的类不需要提供任何特定的方法。
- en: The `Cheetah` class (lines 9-14) implements `Moveable` and overrides `move()`.
    The `Elephant` class (line 15) implements `Moveable` also but does not override
    `move()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cheetah`类（第9-14行）实现了`Moveable`并覆盖了`move()`方法。`Elephant`类（第15行）也实现了`Moveable`，但没有覆盖`move()`方法。'
- en: Thus, `Cheetah` objects will have a custom `move()` implementation, whereas
    `Elephant` objects will use the version inherited from `Moveable`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Cheetah`对象将有一个自定义的`move()`实现，而`Elephant`对象将使用从`Moveable`继承的版本。
- en: Line 20 shows that, as with `abstract` classes, you cannot `new` an interface
    type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第20行显示，与`abstract`类一样，你不能`new`一个接口类型。
- en: Line 21 creates a `Cheetah` object referenced by a `Moveable` reference, namely
    `cheetah`. This is perfectly okay for two reasons. Firstly, references can be
    of the `interface` type and in many cases are. Secondly, this will compile so
    long as the object type implements the interface type, either directly (as is
    the case here) or indirectly (by inheriting from a class that implements the interface
    for you). Since the `Cheetah` class implements `Moveable`, all is well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第21行创建了一个名为`Cheetah`的对象，通过一个`Moveable`引用进行引用，即`cheetah`。这完全没问题，原因有两个。首先，引用可以是`接口`类型，在许多情况下确实是。其次，只要对象类型实现了接口类型，无论是直接实现（如这里的情况）还是间接实现（通过从实现了接口的类继承），这个程序就可以编译。由于`Cheetah`类实现了`Moveable`接口，所以一切正常。
- en: Line 22 executes the `move()` method from `Cheetah` polymorphically, resulting
    in `Moving very fast!` being output to the screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第22行以多态方式执行了`Cheetah`类的`move()`方法，结果在屏幕上输出了`Moving very fast!`。
- en: Line 23 creates an `Elephant` object referenced by a `Moveable` reference, namely
    `elephant`. Since `Elephant` implements `Moveable`, this is ok.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第23行创建了一个名为`Elephant`的对象，通过一个`Moveable`引用进行引用，即`elephant`。由于`Elephant`实现了`Moveable`接口，这是可以的。
- en: Line 24 is interesting. Since `Elephant` does not provide a custom version of
    `move()`, the `default` one from `Moveable` (which `Elephant` implements) is used.
    Thus, `Moving` is output to the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第24行很有趣。由于`Elephant`没有提供自定义的`move()`版本，因此使用了`Moveable`接口（`Elephant`实现了该接口）的默认版本。因此，屏幕上输出了`Moving`。
- en: Now, let’s discuss `static` interface methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下`静态`接口方法。
- en: ‘static’ interface methods
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ‘静态’接口方法
- en: An interface uses the `static` keyword to mark a method as a utility method.
    As with `default` methods, `static` methods are `public` by default. Similarly,
    as with `default` methods, `static` methods must have an implementation. However,
    classes that implement interfaces do not inherit `static` methods. To access a
    `static` method, you must use the `InterfaceName.staticMethodName()` syntax.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接口使用`static`关键字来标记一个方法作为工具方法。与`default`方法一样，`static`方法默认是`public`的。同样，与`default`方法一样，`static`方法必须有实现。然而，实现接口的类不会继承`static`方法。要访问`static`方法，你必须使用`InterfaceName.staticMethodName()`语法。
- en: 'Let’s look at an example in terms of code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例来看看：
- en: '![Figure 10.6 – Interface static methods](img/B19793_10_6.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 接口静态方法](img/B19793_10_6.jpg)'
- en: Figure 10.6 – Interface static methods
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 接口静态方法
- en: In the preceding figure, we have an interface, `I`, that has a `static` method
    called `m1()` on line 5\. Note that line 4 is commented out because, as with `default`
    methods, the code body must be present for `static` methods also.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有一个接口`I`，它在第5行有一个名为`m1()`的静态方法。请注意，第4行被注释掉了，因为与`default`方法一样，静态方法也必须有代码体。
- en: The `TestStaticMethods` class implements the `I` interface. As there are no
    `abstract` methods in the interface, no particular methods are implemented. Line
    9 shows the incorrect syntax to use and thus generates a compiler error. Line
    10 shows the correct syntax to use and outputs `3` when run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestStaticMethods`类实现了`I`接口。由于接口中没有`抽象`方法，因此没有实现特定的方法。第9行显示了错误的语法，因此会生成编译器错误。第10行显示了正确的语法，并在运行时输出了`3`。'
- en: Earlier, we referred to multiple interface inheritance having a potential issue
    regarding `default` methods. Let’s explore that now.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到多接口继承可能存在关于`default`方法的潜在问题。现在让我们来探讨一下。
- en: Multiple interface inheritance
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多接口继承
- en: The Diamond of Death ([https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C](https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C))
    arises when a class finds that it has inherited two methods of the same name;
    which one should it work with? This was a concern in C++, where multiple-class
    inheritance is allowed and was an influencing factor in prohibiting multiple-class
    inheritance in Java.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 死亡菱形([https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C](https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C)))出现在一个类发现它继承了两个同名方法时；它应该使用哪一个？这在允许多重继承的C++中是一个问题，并且是禁止Java多重继承的一个影响因素。
- en: However, Java has always allowed a class to implement multiple interfaces. However,
    now that Java 8 allows `default` methods, which have code bodies that are inheritable,
    is it not possible for Java 8 to encounter a “Diamond of Death” scenario? Couldn’t
    a class implement two (or more) interfaces that have the same `default` methods?
    What happens then? The good news is that the compiler steps in and forces your
    class to override the “offending” `default` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java始终允许一个类实现多个接口。然而，现在Java 8允许有代码体的可继承的`default`方法，Java 8不可能遇到“死亡菱形”场景吗？一个类是否可以实现两个（或更多）具有相同`default`方法的接口？那会怎样呢？好消息是编译器介入并强制你的类覆盖“违规”的`default`方法。
- en: So, that just leaves the question, what if we wanted to access each of the `default`
    methods? For example, let’s assume we have a `default` method called `foo()` in
    interface `A` and a `default` method called `foo()` in interface `B`. What if,
    in our class, we wanted to execute the three different versions of `foo()` – the
    one from `A`, the one from `B`, and the one from our class that the compiler forced
    us to create?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这就留下了一个问题，如果我们想访问每个`default`方法怎么办？例如，假设我们在接口`A`中有一个名为`foo()`的`default`方法，在接口`B`中也有一个名为`foo()`的`default`方法。如果在我们自己的类中，我们想执行`foo()`的三个不同版本——来自`A`的、来自`B`的以及编译器强制我们创建的来自我们自己的类，会怎样呢？
- en: '*Figure 10**.7* shows how to do this in code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.7* 展示了如何在代码中实现这一点：'
- en: '![Figure 10.7 – Accessing multiple default code implementations](img/B19793_10_7.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 访问多个默认代码实现](img/B19793_10_7.jpg)'
- en: Figure 10.7 – Accessing multiple default code implementations
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 访问多个默认代码实现
- en: In this figure, interface `A` defines its `foo()` method on line 4, whereas
    interface `B` defines its `foo()` method on line 7\. The `TestMultipleInheritance`
    class implements both `A` and `B`. As there is `foo()` code coming from both `A`
    and `B`, the compiler has to step in to prevent the “Diamond of Death.” Thus,
    the `foo()` method in `TestMultipleInheritance` (lines 11-16) is mandatory; otherwise,
    the code will not compile. As `default` methods are instance methods, when we
    override the interface version of `foo()`, we must ensure it is non-static.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，接口`A`在第4行定义了它的`foo()`方法，而接口`B`在第7行定义了它的`foo()`方法。`TestMultipleInheritance`类实现了`A`和`B`。由于`A`和`B`都有`foo()`代码，编译器必须介入以防止“死亡菱形”。因此，`TestMultipleInheritance`中的`foo()`方法（第11-16行）是强制性的；否则，代码将无法编译。由于`default`方法是实例方法，当我们覆盖接口版本的`foo()`时，我们必须确保它是非静态的。
- en: Line 13 shows the syntax to use to invoke `foo()` from `A`. This syntax is `InterfaceName.super.methodName()`.
    So in this example, it is `A.super.foo()`. Since `super` is used, the methods
    must be instance methods. This is because only instance methods have access to
    (the parent instance using) the `super` reference (and to the current instance
    using the `this` reference).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第13行展示了调用`A`中的`foo()`的语法。这个语法是`InterfaceName.super.methodName()`。所以在这个例子中，它是`A.super.foo()`。由于使用了`super`，方法必须是实例方法。这是因为只有实例方法才能访问（使用`super`引用的父实例）`super`引用（以及使用`this`引用的当前实例）。
- en: Similarly, line 15 invokes `foo()` from `B` using `B.super.foo()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，第15行使用`B.super.foo()`从`B`中调用`foo()`。
- en: Note that line 14 does not compile and is commented out as a result. This is
    because, with the `A.foo()` syntax, the compiler is looking for a `static` method
    named `foo()` in interface `A`. However, the `foo()` method in `A` is non-static
    (line 4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第14行无法编译，因此被注释掉了。这是因为，使用`A.foo()`语法，编译器正在寻找接口`A`中名为`foo()`的`static`方法。然而，`A`中的`foo()`方法是非静态的（第4行）。
- en: Interestingly, line 18 fails to compile. This is because, since `main()` is
    a `static` method (a `static` context), we cannot use `super`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，第18行无法编译。这是因为，由于`main()`是一个`static`方法（一个`static`上下文），我们不能使用`super`。
- en: Line 19 shows how to execute the custom `foo()` method in the class itself.
    Recall that we need an instance when calling a non-static (instance) method from
    a `static` method, hence the `new TestMultipleInheritance()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第19行展示了如何在类本身中执行自定义的`foo()`方法。回想一下，当我们从`static`方法中调用非静态（实例）方法时，我们需要一个实例，因此有`new
    TestMultipleInheritance()`。
- en: 'With that, we’ve covered two types of non-abstract methods, namely `default`
    and `static` methods. There is one more: `private` interface methods.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经涵盖了两种非抽象方法的类型，即`default`方法和`static`方法。还有一个：`private`接口方法。
- en: Explaining ‘private’ interface methods
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释“私有”接口方法
- en: Interfaces can also have `private` methods with code implementations. They were
    introduced to reduce code duplication and improve encapsulation. These `private`
    methods can be both `static` and non-static. As they are `private`, they can only
    be accessed from within the interface. As with classes, you cannot access a non-static
    method from a `static` method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以有带有代码实现的`private`方法。它们被引入以减少代码重复并提高封装性。这些`private`方法可以是`static`的也可以是非`static`的。由于它们是`private`的，它们只能从接口内部访问。与类一样，你不能从一个`static`方法中访问一个非`static`方法。
- en: 'Let’s have a look at an example in code. Firstly, we will examine code that
    has code duplication. *Figure 10**.8* shows such an interface:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例。首先，我们将检查有代码重复的代码。*图10.8*显示了这样的接口：
- en: '![Figure 10.8 – An interface with code duplication](img/B19793_10_8.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 带有代码重复的接口](img/B19793_10_8.jpg)'
- en: Figure 10.8 – An interface with code duplication
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 带有代码重复的接口
- en: 'As this figure shows, lines 6, 11, and 16 are the same. In addition, lines
    8, 13, and 18 are also the same. We will refactor this interface to address this
    code duplication by using `private` methods. *Figure 10**.9* shows the code for
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图中所示，第6、11和16行是相同的。此外，第8、13和18行也是相同的。我们将通过使用`private`方法重构这个接口来解决这个代码重复问题。*图10.9*显示了相应的代码：
- en: '![Figure 10.9 – An interface with private methods](img/B19793_10_9.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 带有私有方法的接口](img/B19793_10_9.jpg)'
- en: Figure 10.9 – An interface with private methods
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 带有私有方法的接口
- en: In this figure, we have a `private` `static` method called `hit(String)` that
    accepts the stroke (shot) to be played. The first thing to notice is that, as
    with `default` and `static` methods, a code body is expected and is present.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有一个名为`hit(String)`的`private``static`方法，它接受要执行的击球（射击）。首先要注意的是，与`default`和`static`方法一样，预期并存在一个代码体。
- en: Line 25, which was replicated three times in *Figure 10**.8*, now appears only
    once. The same is true for line 27\. Line 26 outputs the stroke being played.
    Note that `hit(String)` is `static`. This enables the method to be invoked from
    `static` methods, such as `forehand()` (line 32).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第25行，在*图10.8*中重复了三次，现在只出现一次。第27行也是如此。第26行输出正在进行的击球动作。请注意`hit(String)`是`static`的。这使得方法可以从`static`方法（如第32行的`forehand()`）中调用。
- en: There is a mix of `default`, `static`, and `private` methods to facilitate further
    discussion. Firstly, line 29 is a `default` method that invokes the `private`
    `hit(String)` method, which passes in the `backhand` string. Note that `default`
    methods cannot also be marked `private` as they have opposite semantics – `private`
    methods, as with classes, are not inherited, whereas `default` methods are inherited.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中存在`default`、`static`和`private`方法的混合，以促进进一步的讨论。首先，第29行是一个`default`方法，它调用了`private`的`hit(String)`方法，传递了`backhand`字符串。请注意，`default`方法不能也被标记为`private`，因为它们的语义相反——`private`方法，就像类一样，是不可继承的，而`default`方法是可继承的。
- en: Secondly, the `forehand()` method (lines 30-33) represents invoking `hit(String)`
    from a `static` context (line 32), passing in `forehand`. Line 31 represents an
    attempt to call a non-static `private` method called `smash()` from a `static`
    method. As with classes, this is not allowed and has been commented out as a result.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`forehand()`方法（第30-33行）表示从`static`上下文（第32行）调用`hit(String)`，传递`forehand`。第31行表示尝试从一个`static`方法中调用一个名为`smash()`的非`static``private`方法。与类一样，这是不允许的，因此已被注释掉。
- en: Lastly, we can call `private` methods from other `private` methods (line 34).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从其他`private`方法中调用`private`方法（第34行）。
- en: Line 35 is a reminder that methods that are not marked `default`, `static`,
    or `private` are `abstract` by default, so no code is permitted.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第35行是一个提醒，即未标记为`default`、`static`或`private`的方法默认是`abstract`的，因此不允许有代码。
- en: 'Let’s examine how to use the `EfficientTennis` interface from a class that
    implements it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何从一个实现了它的类中如何使用`EfficientTennis`接口：
- en: '![Figure 10.10 – An interface with private methods](img/B19793_10_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 带有私有方法的接口](img/B19793_10_10.jpg)'
- en: Figure 10.10 – An interface with private methods
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 带有私有方法的接口
- en: The first thing to notice is that the `SportTest` class has no methods to implement.
    This is because `EfficientTennis` does not declare any `abstract` methods, only
    `default`, `static`, and `private` ones.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要注意的是`SportTest`类没有要实现的方法。这是因为`EfficientTennis`没有声明任何`abstract`方法，只有`default`、`static`和`private`方法。
- en: Line 41 executes the `default` method called `backhand()` and line 42 executes
    the `static` method called `forehand()`. Note that line 43 attempts to access
    the `private` method called `hit(String)`. As the method is `private` to the interface,
    this is not allowed and, as a result, line 43 is commented out. This demonstrates
    that `hit(String)` is encapsulated from the outside world. In effect, `SportTest`
    does not know of and is therefore not dependent upon the `hit(String)` method.
    If `hit(String)` is changed or even deleted, provided that the `backhand()` and
    `forehand()` methods still work, `SportTest` will not be impacted.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第41行执行了名为`backhand()`的`default`方法，第42行执行了名为`forehand()`的`static`方法。请注意，第43行尝试访问名为`hit(String)`的`private`方法。由于该方法是对接口私有的，这是不允许的，因此第43行被注释掉了。这表明`hit(String)`被封装在外部世界之外。实际上，`SportTest`不知道`hit(String)`方法，因此不依赖于它。如果`hit(String)`被更改或甚至删除，只要`backhand()`和`forehand()`方法仍然工作，`SportTest`就不会受到影响。
- en: 'Now, let’s move on to our last topic: `sealed` interfaces.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的最后一个主题：`sealed`接口。
- en: Exploring sealed interfaces
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索封闭接口
- en: In [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), we learned that `sealed`
    classes enable us to scope our inheritance hierarchy by specifying which classes
    can subtype our class. We used both the `sealed` and `permits` keywords as a pair
    to do this. Once a class has been sealed, each subclass of that class must be
    `sealed`, `non-sealed`, or `final` – that is, we continue the sealed hierarchy
    (`sealed`), end the sealed hierarchy (`non-sealed`), or end the hierarchy altogether
    (`final`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19793_09.xhtml#_idTextAnchor205)中，我们了解到`sealed`类使我们能够通过指定哪些类可以成为我们的类的子类型来范围我们的继承层次结构。我们使用`sealed`和`permits`关键字作为一对来完成此操作。一旦一个类被封闭，该类的每个子类都必须是`sealed`、`non-sealed`或`final`——也就是说，我们继续封闭层次结构（`sealed`）、结束封闭层次结构（`non-sealed`）或完全结束层次结构（`final`）。
- en: 'It is also possible to seal interfaces. We will use the example from [*Chapter
    9*](B19793_09.xhtml#_idTextAnchor205) with some small changes. Firstly, *Figure
    10**.11* shows the relevant UML diagram, which will help explain the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭接口也是可能的。我们将使用来自[*第9章*](B19793_09.xhtml#_idTextAnchor205)的例子，并进行一些小的修改。首先，*图10*.*11*显示了相关的UML图，这将有助于解释代码：
- en: '![Figure 10.11 – Sealed interface UML diagram](img/B19793_10_11.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 封闭接口UML图](img/B19793_10_11.jpg)'
- en: Figure 10.11 – Sealed interface UML diagram
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 封闭接口UML图
- en: In this figure, we have an interface, indicated by `<<interface>>`, called `Driveable`.
    In UML, to specify that a class implements an interface, the `<<realize>>` keyword
    is used (plus the dashed line with an arrow referring to the interface).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有一个接口，用`<<interface>>`表示，称为`Driveable`。在UML中，为了指定一个类实现一个接口，使用`<<realize>>`关键字（加上指向接口的虚线箭头）。
- en: 'In this example, we are going to scope the hierarchy as follows: the only class
    allowed to implement `Driveable` is `Vehicle`, the only `Vehicle` subclass allowed
    is `Car`, and the only subclass of `Car` allowed is `Saloon`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将对层次结构进行如下范围定义：允许实现`Driveable`的唯一类是`Vehicle`，允许的`Vehicle`子类是`Car`，允许的`Car`子类是`Saloon`。
- en: When we get to `Saloon`, we want to open up the hierarchy again – unseal it,
    if you like. This allows `Ford` and `Volvo` to extend from `Saloon`. Note that
    this is for demonstration purposes only as any class can now subclass `Saloon`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达`Saloon`时，我们希望再次打开层次结构——如果你愿意的话，就是解封它。这允许`Ford`和`Volvo`从`Saloon`扩展。请注意，这只是为了演示目的，因为现在任何类都可以成为`Saloon`的子类。
- en: The `Chair`, `Table`, and `Window` classes are all unrelated and not part of
    the sealed hierarchy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chair`、`Table`和`Window`类都是无关的，并且不是封闭层次结构的一部分。'
- en: '*Figure 10**.12* shows some code where a sealed interface is used:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10*.*12*显示了使用封闭接口的一些代码：'
- en: '![Figure 10.12 – Sealed interface code](img/B19793_10_12.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 封闭接口代码](img/B19793_10_12.jpg)'
- en: Figure 10.12 – Sealed interface code
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 封闭接口代码
- en: The important lines in this figure are lines 3-4\. Line 3 states that the `Driveable`
    interface is `sealed` and that only one class is allowed to implement it, namely
    `Vehicle`. `Vehicle` must now implement `Driveable`; otherwise, the code will
    fail to compile. `Vehicle` does implement `Driveable` (line 4), so all is well.
    In addition, `Vehicle` is `sealed` and the only subclass permitted is `Car`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此图中的重要行是第3-4行。第3行说明`Driveable`接口是`sealed`的，并且只允许一个类实现它，即`Vehicle`。`Vehicle`现在必须实现`Driveable`；否则，代码将无法编译。`Vehicle`确实实现了`Driveable`（第4行），所以一切正常。此外，`Vehicle`是`sealed`的，允许的唯一子类是`Car`。
- en: Line 6 states that `Car` subclasses `Vehicle` and that `Saloon` is the only
    subtype allowed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行指出`Car`是`Vehicle`的子类，而`Saloon`是唯一允许的子类型。
- en: Line 7 states that `Saloon` is, as expected, a subclass of `Car`. The fact that
    `Saloon` is `non-sealed` opens up the hierarchy and enables `Volvo` (line 8) and
    `Ford` (line 9) to extend from `Saloon`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行指出`Saloon`是预期的`Car`子类。`Saloon`是`non-sealed`的事实打开了层次结构，并允许`Volvo`（第8行）和`Ford`（第9行）从`Saloon`扩展。
- en: Lines 11-13 all fail to compile. Line 11 reminds us that `Vehicle` permits `Car`
    subtypes only. Similarly, line 12 reminds us that `Car` permits `Saloon` subtypes
    only. Line 13 shows, as per line 3, that the only class that can implement `Driveable`
    is `Vehicle`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第11-13行都无法编译。第11行提醒我们`Vehicle`只允许`Car`子类型。同样，第12行提醒我们`Car`只允许`Saloon`子类型。第13行显示，根据第3行的内容，唯一可以实现`Driveable`的类是`Vehicle`。
- en: That completes our discussion on interfaces and `abstract` classes. Now, let’s
    apply what we have learned!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对接口和`abstract`类的讨论。现在，让我们应用我们所学到的知识！
- en: Exercises
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'With interfaces and `abstract` classes, we can improve our application structure
    even further! Take a look at the following exercises to test your knowledge:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接口和`abstract`类，我们可以进一步改进我们的应用程序结构！查看以下练习以测试你的知识：
- en: Dinosaurs, no matter the exact species, have common behaviors such as eating
    and moving. Define an interface that encapsulates these behaviors, come up with
    a logical name for it, and implement it in the `Dinosaur` class.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恐龙，无论具体物种如何，都有共同的行为，如进食和移动。定义一个封装这些行为的接口，并为它想出一个合理的名字，然后在`Dinosaur`类中实现它。
- en: Our park uses different types of vehicles for different purposes. Design an
    `abstract` class called `Vehicle` and derive concrete classes such as `Jeep` and
    `Helicopter` from it.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们公园使用不同类型的车辆来完成不同的目的。设计一个名为`Vehicle`的`abstract`类，并从中派生出如`Jeep`和`Helicopter`等具体类。
- en: Modify the `Vehicle` class so that it includes an `abstract` method called `travel()`
    that provides different implementations in its subclasses.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Vehicle`类，使其包含一个名为`travel()`的`abstract`方法，并在其子类中提供不同的实现。
- en: Make our `Dinosaur` class sortable by implementing the `Comparable` interface
    to compare dinosaurs based on their age.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现`Comparable`接口来比较恐龙的年龄，使我们的`Dinosaur`类可排序。
- en: Similarly, our employees also have common behaviors. Define a `Worker` interface
    with methods that represent these behaviors and implement it in the `Employee`
    class.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们的员工也有共同的行为。定义一个`Worker`接口，其中包含代表这些行为的函数，并在`Employee`类中实现它。
- en: Our dinosaurs are housed in different enclosures. Implement the `List` interface
    using `ArrayList` to manage dinosaurs for an enclosure.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们把恐龙安置在不同的围栏里。使用`ArrayList`实现`List`接口来管理围栏中的恐龙。
- en: Dinosaurs have different feeding behaviors based on their diet. Create `Carnivore`
    and `Herbivore` interfaces and implement them in the appropriate dinosaur subclasses.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恐龙的进食行为根据它们的饮食不同。创建`Carnivore`和`Herbivore`接口，并在适当的恐龙子类中实现它们。
- en: Project – unified park management system
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 - 统一公园管理系统
- en: In this rather advanced project, you will elevate the Mesozoic Eden Park Manager
    application to the next level. You’ll do so by utilizing the classes you created
    earlier. You can continue to work on the previous project or start from scratch.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相对高级的项目中，你将把中生代伊甸园公园管理应用提升到下一个层次。你可以通过利用你之前创建的类来实现这一点。你可以继续进行上一个项目，或者从头开始。
- en: 'The enhanced system will implement polymorphism so that different types of
    dinosaurs and employees can be managed. This will increase the versatility and
    functionality of your park management, allowing for diverse dinosaur species and
    employee roles. The enhanced system should include the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 增强后的系统将实现多态性，以便可以管理不同类型的恐龙和员工。这将增加公园管理的灵活性和功能性，允许多样化的恐龙物种和员工角色。增强后的系统应包括以下内容：
- en: The capability to manage various dinosaur species profiles, broadening the diversity
    of your park
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理各种恐龙物种档案的能力，扩大了你公园的多样性
- en: The capacity to manage different types of employee profiles, such as veterinarians,
    guides, maintenance workers, and security personnel
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理不同类型员工档案的能力，例如兽医、导游、维修工人和安全人员
- en: All other features should also accommodate these new changes, including editing
    and removing profiles, tracking dinosaurs, managing employee schedules, managing
    guest admissions, and handling special events
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他功能也应适应这些新变化，包括编辑和删除档案、追踪恐龙、管理员工日程、管理游客入场和处理特殊事件
- en: 'Here’s a step-by-step plan to achieve this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个逐步计划来实现这一点：
- en: '`Dinosaur` and `Employee` classes into various subclasses to represent different
    types of dinosaurs and employees. Make sure you use the principle of polymorphism.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Dinosaur`和`Employee`类扩展到各种子类中，以表示不同类型的恐龙和员工。请确保您使用多态原则。
- en: '`Dinosaur` and `Employee` objects, each of which could be an instance of any
    subclass.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dinosaur`和`Employee`对象，每个都可以是任何子类的实例。'
- en: '**Update interaction**: Adapt your interactive console-based interface so that
    it can handle the new types of dinosaurs and employees. You might need to add
    new options or submenus.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新交互**：调整您的基于控制台的交互界面，使其能够处理新的恐龙和员工类型。您可能需要添加新选项或子菜单。'
- en: '**Update menu creation**: Your menu should now provide options for managing
    various types of dinosaurs and employees. Ensure each option corresponds to a
    particular function in the program.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新菜单创建**：您的菜单现在应提供管理各种类型恐龙和员工的选择。确保每个选项对应程序中的特定功能。'
- en: '`Manage Dinosaurs` option could now trigger a function to add, remove, or edit
    profiles for any dinosaur species.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Manage Dinosaurs`选项现在可以触发一个函数，用于添加、删除或编辑任何恐龙物种的配置文件。'
- en: '**Exit program**: Provide an option for the user to exit the program.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**退出程序**：提供一个选项让用户退出程序。'
- en: 'Your starting code will be very similar to the code shown in the last two chapters.
    Some methods, such as `manageDinosaurs()` and `manageEmployees()`, will need to
    be updated and become a bit more complex:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您的起始代码将与最后两个章节中展示的代码非常相似。一些方法，如`manageDinosaurs()`和`manageEmployees()`，需要更新并变得更加复杂：
- en: '[PRE3]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `manageDinosaurs()`, `manageEmployees()`, `manageTickets()`, `checkParkStatus()`,
    and `handleSpecialEvents()` methods need to handle the added complexity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`manageDinosaurs()`、`manageEmployees()`、`manageTickets()`、`checkParkStatus()`和`handleSpecialEvents()`方法需要处理增加的复杂性。'
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by examining `abstract` classes. An `abstract` class
    has zero or more `abstract` methods. However, if any method is `abstract`, then
    the class must be `abstract`. While an `abstract` class cannot be instantiated,
    a reference can be of an `abstract` type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时考察了`抽象`类。一个`抽象`类可以有零个或多个`抽象`方法。然而，如果任何方法是`抽象`的，那么该类必须是`抽象`的。虽然`抽象`类不能被实例化，但引用可以是`抽象`类型。
- en: Before Java 8, interfaces consisted of only `abstract` methods (and constants).
    We started our discussion on interfaces at this point, where all the methods were
    `abstract`. While a class can only extend from one class, a class can implement
    many interfaces. This is one of the main reasons why interfaces were introduced
    – to be able to cast to more than one base type.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，接口只包含`抽象`方法（和常量）。我们关于接口的讨论始于这一点，当时所有方法都是`抽象`的。虽然一个类只能从一个类扩展，但一个类可以实现多个接口。这是引入接口的主要原因之一——能够将类型转换为多个基类型。
- en: A class that implements an interface signs a “contract” to provide code for
    each of the `abstract` methods (if any) in the interface. If there is an `abstract`
    method in the interface and the concrete, non-abstract class does not provide
    code implementation for it, the compiler complains. Therefore, interfaces are
    a great way of guaranteeing that certain methods will be present in a class. Variables
    in an interface are constants by default. These constants are available to implementing
    classes, but are read-only. We noted that multiple interface inheritance, where
    an interface can inherit from several other interfaces, is allowed. This contrasts
    with classes, be they `abstract` or concrete, where multiple inheritance is prohibited.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口的类签订了一个“合同”，为接口中（如果有）的每个`抽象`方法提供代码。如果接口中有一个`抽象`方法，而具体的非抽象类没有为其提供代码实现，编译器会报错。因此，接口是保证某些方法存在于类中的绝佳方式。接口中的变量默认为常量。这些常量对实现类可用，但只读。我们注意到，允许多接口继承，即一个接口可以继承自多个其他接口。这与类形成对比，无论是`抽象`类还是具体类，多重继承都是被禁止的。
- en: In Java 8, `default` and `static` methods, both with code bodies, were introduced
    to interfaces. This was the first time code was allowed in interfaces. Regarding
    inheritance, `default` methods are inherited by implementing classes, whereas
    `static` methods are not. Thus, accessing both requires different syntaxes. As
    `default` methods are inherited, they can be overridden by implementing classes.
    Both types of methods, as with `abstract` methods, are `public` by default.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，接口中引入了具有代码体的`default`方法和`static`方法。这是第一次允许在接口中添加代码。关于继承，`default`方法会被实现类继承，而`static`方法则不会。因此，访问这两种方法需要不同的语法。由于`default`方法可以被继承，实现类可以覆盖它们。这两种方法类型，与`abstract`方法一样，默认情况下都是`public`的。
- en: Next, we saw how the compiler prevents us from experiencing the “Diamond of
    Death.” This issue could arise when two interfaces have the same `default` method
    name. A class that implements these two interfaces is forced to provide a custom
    implementation to avoid ambiguity. This led nicely to the syntax (using `super`),
    which enables us the `default` methods in both interfaces and the custom (non-default)
    version in the class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了编译器如何防止我们遇到“死亡菱形”问题。当两个接口具有相同的`default`方法名称时，可能会出现这个问题。实现这两个接口的类被迫提供自定义实现以避免歧义。这很自然地引出了语法（使用`super`），它使我们能够在两个接口中实现`default`方法，并在类中实现自定义（非默认）版本。
- en: Java 9 introduced `private` interface methods, which also have code bodies.
    They were introduced to reduce code duplication and improve encapsulation. We
    detailed an example where we refactored code by introducing `private` interface
    methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了具有代码体的`private`接口方法。它们被引入以减少代码重复并提高封装性。我们详细说明了通过引入`private`接口方法重构代码的例子。
- en: We concluded this chapter by discussing `sealed` interfaces, which were introduced
    in Java 17\. Much like `sealed` classes ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)),
    `sealed` interfaces enable us to scope the hierarchy – that is, when declaring
    a `sealed` interface, we specify the classes that are permitted to implement it.
    We presented a UML diagram and some code to explain this in more detail.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过讨论在Java 17中引入的`sealed`接口来结束本章。与`sealed`类（[*第9章*](B19793_09.xhtml#_idTextAnchor205)）类似，`sealed`接口使我们能够限制层次结构——也就是说，当我们声明一个`sealed`接口时，我们指定允许实现它的类。我们提供了一个UML图和一些代码来更详细地解释这一点。
- en: That completes our discussion on interfaces and `abstract` classes. In the next
    chapter, we will cover exceptions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对接口和`abstract`类的讨论。在下一章中，我们将介绍异常。
