- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces and Abstract Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), we learned about another
    core pillar of OOP, namely inheritance. We saw that Java uses the `extends` keyword
    to define an “is-a” inheritance relationship between the child and the parent
    class. The subclass inherits functionality from its parent that enables code reuse,
    a core benefit of inheritance. Java prevents multiple class inheritance by ensuring
    you can only extend from one class at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a deep dive into the other remaining pillar of OOP, polymorphism.
    Polymorphism is enabled by subclasses overriding the parent class instance methods.
    We saw that, regarding the hierarchy, references can point (across) to objects
    of their own type and (down) to subclass objects. An exception occurs if a reference
    attempts to point (up) to parent objects in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compared and contrasted method overloading and method overriding. In
    method overriding, the method signatures must match (except for covariant returns).
    In method overloading, while the method names are the same, the method signatures
    must be different.
  prefs: []
  type: TYPE_NORMAL
- en: We also discovered that the order of constructor calls is from the top (base
    class) down. This is facilitated by the `super()` keyword. To access a parent
    (non-constructor) member, we can use the `super.` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We then revisited the `protected` access modifier and demonstrated that, for
    subclasses outside the package to access the protected member, they must do so
    via inheritance in a very specific manner. In effect, once outside the package,
    the `protected` member becomes private to subclasses (of the class containing
    the `protected` member).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then covered two keywords that have an impact on inheritance: `abstract`
    and `final`. As an `abstract` method has no implementation code, it is intended
    to be overridden. The first non-abstract (concrete) subclass must provide implementation
    code for any inherited `abstract` methods. The `final` keyword can be applied
    in several scenarios. Concerning inheritance, a `final` method cannot be overridden
    and a `final` class cannot be subclassed.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed `sealed` classes, which enable us to scope parts of the inheritance
    tree. Using the `sealed` and `permits` keywords, we can state that a class can
    only be subclassed by certain other named classes. The `non-sealed` keyword ends
    the scoping task and thus enables us to subclass as normal.
  prefs: []
  type: TYPE_NORMAL
- en: We examined both `instance` and `static` blocks in an inheritance hierarchy.
    A `static` block is only executed once when a class is first loaded. An `instance`
    block, on the other hand, is executed every time an object instance is created,
    making it an ideal place to insert code common to all constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we examined upcasting and downcasting. Whereas upcasting is never an
    issue, downcasting can lead to an exception. Use of the `instanceof` keyword helps
    prevent this exception.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover `abstract` classes and interfaces. We will compare
    and contrast them. Interfaces have had several changes over the years. With the
    aid of examples, we will examine these changes. Java 8 introduced both `static`
    and `default` methods for interfaces, thereby enabling code to be present in an
    interface for the first time. In Java 9, to reduce code duplication and improve
    encapsulation, `private` methods were introduced to interfaces. Finally, Java
    17 introduced `sealed` interfaces, which enable us to customize what classes can
    implement our interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding `abstract` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining `default` and `static` interface methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining `private` interface methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring `sealed` interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), we covered the `abstract`
    keyword. Let’s review some key points that we discussed. An `abstract` method
    is exactly that – it is abstract. It has no code. It doesn’t even have curly braces
    – `{}`. This is typically a design decision. The class containing the `abstract`
    method wants subclasses to provide the code. This means that the class itself
    is “incomplete” and therefore any class defining an `abstract` method must itself
    be `abstract`. Any subclass of the `abstract` class must either override the `abstract`
    method or declare that it too is `abstract`. The compiler will complain otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: However, the inverse is not the case – an `abstract` class need not have any
    `abstract` methods at all. Again, this is a design decision. Since the class is
    marked as `abstract`, it is considered “incomplete” (even though it may contain
    code for all the methods). This prevents objects based on `abstract` classes from
    being instantiated. In other words, you cannot `new` an object based on an `abstract`
    class. You can, however, have a reference based on an `abstract` type.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to *Figure 9**.14* for a code example of `abstract` methods and
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, an interface is an `abstract` construct. Before Java 8, all the
    methods in an interface were `abstract`. In general, when you create an interface,
    you are defining a contract for *what* a class can do without saying anything
    about *how* the class will do it. A class signs the contract when it implements
    an interface. A class implementing an interface is agreeing to “obey” the contract
    defined in the interface. “Obeying” here means that, if a concrete (non-abstract)
    class is implementing an interface, the compiler will ensure that the class has
    implementation code for each `abstract` method in the interface. As the Oracle
    tutorials state, “*Implementing an interface allows a class to become more formal
    about the behavior it promises* *to provide*.”
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to classes, where you can (directly) inherit from only one other
    class, a class can implement many interfaces. Thus, interfaces enable multiple
    inheritance. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This line of code states that `Dog` “is-a” `Animal`, `Moveable`, and `Loveable`.
    Interface names are often adjectives as they often describe a quality of a noun.
    Thus, interface names often end in “able.” For example, `Iterable` and `Callable`
    are interface names in the Java API.
  prefs: []
  type: TYPE_NORMAL
- en: n the previous line of code, we are limited to extending from one class but
    we can implement as many interfaces as we like. This flexibility is very powerful
    as we can link into hierarchies without forcing artificial class relationships.
    This is one of the core reasons for interfaces – *to be able to cast to more than
    one* *base type*.
  prefs: []
  type: TYPE_NORMAL
- en: As with `abstract` classes, given that interfaces are also `abstract`, you cannot
    `new` an `interface` type. In addition, similarly to `abstract` classes, you can
    (and often do) have references that are interface types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In later sections, we will discuss the `static`, `default`, and `private` methods,
    all of which have implementation code. Before that, we will deal with the other
    type of methods we can use in an interface: `abstract` methods. Additionally,
    we will discuss interface constants.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract methods in interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to Java 8, all of the methods in an interface were implicitly `public`
    and `abstract` by default. Back then, you could state that an interface was a
    “purely abstract class.”
  prefs: []
  type: TYPE_NORMAL
- en: Concerning the `public` access modifier, this is still the case, even though
    Java 9 introduced `private` methods. This means that, you can explicitly mark
    a method in an interface as `public` or `private`. However, if you do *not* specify
    any access modifier, `public` is the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about their abstract nature? Well, any method that is *not* denoted as
    `static`, `default`, or `private` is still `abstract` by default. *Figure 10**.1*
    encapsulates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Abstract methods in an interface](img/B19793_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Abstract methods in an interface
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we can see that the `m2()` method is `public` and `abstract`,
    even though none of those keywords are explicitly coded. The only other valid
    access modifier is `private`, as shown when declaring `m3()` on line 6\. The fact
    that `m4()` does not compile (line 7) demonstrates that `protected` is not a valid
    access modifier on interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: Can we declare variables in an interface? Yes, we can. Let’s discuss them now.
  prefs: []
  type: TYPE_NORMAL
- en: Interface constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any variables specified in an interface are `public`, `static`, and `final`
    by default. In effect, they are constants, and thus, their initial values cannot
    be changed. By placing these constants in the interface, any class implementing
    the interface has access to them (via inheritance), but they are read-only. *Figure
    10**.2* shows some interface constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Interface constants](img/B19793_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Interface constants
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have two variables, namely `VALUE1` and `VALUE2`.
    Both are constants. `VALUE1` states explicitly that it is `public`, `static`,
    and `final`, whereas `VALUE2` does the same implicitly (no keywords are used).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an example where a class implements an interface.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.3* represents a class implementing an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – A class implementing an interface](img/B19793_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – A class implementing an interface
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, lines 3-6 represent an interface called `Moveable` that declares
    a constant, `HOW`, and a method, `move()`. The `Dog` class on line 7 declares
    that it implements `Moveable`. Therefore, since `Dog` is a concrete, non-abstract
    class, it must provide an implementation for `move()`.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, interface methods are `public` by default. However, this is not
    the case for classes. In classes, methods are package-private by default; which
    means, if you do not provide an access modifier on a method in a class, the method
    is package-private. Therefore, when overriding an interface method in a class,
    ensure that the method is `public`. As `package-private` (line 9) is weaker than
    `public` (line 5), we get a compiler error – hence this line is commented out.
    Line 11 shows that `move()` must be explicitly declared `public` in `Dog`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 shows that `HOW`, declared on line 4, is a constant. If uncommented,
    line 15 gives a compiler error as constants, once assigned a value, cannot change.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 16 and 17 demonstrate both ways we can access the `HOW` constant – either
    by prepending it with the interface name (line 16) or directly (line 17).
  prefs: []
  type: TYPE_NORMAL
- en: Line 19 shows that once inside a `static` method, which `main()` is, you cannot
    directly access an instance method, which `move()` is. This is because instance
    methods are secretly passed a reference to the (object) instance responsible for
    calling it, namely the `this` reference. Since `static` methods relate to the
    class and not a specific instance of the class, there is no `this` reference available
    in `static` methods. Thus, as per line 20, we need to create an instance and then
    use that instance to invoke `move()`.
  prefs: []
  type: TYPE_NORMAL
- en: When we run this program, lines 16 and 17 both output the value of the `walk`
    constant. Line 20 outputs `Dog::move()`, the output from the `Dog` implementation
    of `move()` (line 12).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since Java 8, code is allowed in `default` methods. As `default` methods are
    inheritable, the compiler must step in to prevent multiple inheritance in interfaces
    from causing an issue. We will return to this when we discuss `default` methods
    in interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at multiple interface inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple interface inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike classes, where multiple inheritance is prohibited in Java, multiple inheritance
    is allowed in interfaces. Note that the issue with multiple class inheritance
    is that *if* multiple *class* inheritance was allowed, you could potentially inherit
    two distinct implementations for the same method.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.4* shows an example of multiple interface inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Multiple interface inheritance](img/B19793_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Multiple interface inheritance
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, the `MoveableObject` interface on line 2 is an interface with
    no methods at all. This is known as a tagging interface. A tagging interface is
    used for type information using `instanceof`. For example, if you wanted to know
    if an object is an instance of a class that implements `MoveableObject`, you would
    code the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines 3-5 define an interface called `Spherical`. At this point we could simply
    define a class that directly implements both of these interfaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Line 6 is interesting – we can define an interface (`Bounceable` in this instance)
    that `extends` (inherits) from *both* of the other interfaces, namely `MoveableObject`
    and `Spherical`. Therefore, `Bounceable` has two `abstract` methods: one it defined
    itself, called `bounce()`, and one it inherited from `Spherical`, called `doSphericalThings()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Volleyball` class implements `Bounceable` (line 11), it must override
    both `bounce()` and `doSphericalThings()`. As `Volleyball` does this, it compiles.
  prefs: []
  type: TYPE_NORMAL
- en: Note that on line 17, the `abstract` class, `Beachball`, states that it implements
    `Bounceable` also. However, as `Beachball` is `abstract`, the “contract” does
    not have to be obeyed; meaning, `Beachball` is free to implement all, some, or
    none of the `abstract` methods in `Bounceable`. In this example, none of the `abstract`
    methods required by `Bounceable` were implemented by `Beachball`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the implication of `abstract` methods in interfaces for
    implementing classes, let’s examine two of the non-abstract methods in interfaces
    – the `default` and `static` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Examining default and static interface methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Java 8, only `abstract` methods were allowed in interfaces. This meant
    that if you introduced a new `abstract` method to an existing interface, the classes
    that had already implemented that interface would break. This was inconvenient
    for not only Java developers but also the designers of Java.
  prefs: []
  type: TYPE_NORMAL
- en: This all changed in Java 8, with the introduction of both `default` and `static`
    methods. One of the primary drivers for introducing `default` methods was to be
    able to introduce code into the interface and not break the existing client base.
    This maintained backward compatibility. In addition, this new code is automatically
    available to clients implementing that interface.
  prefs: []
  type: TYPE_NORMAL
- en: A primary driver for the introduction of `static` methods was to keep utility
    code local to the interface rather than having it in a separate class, which was
    the case before their introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss them in turn, starting with `default` methods.
  prefs: []
  type: TYPE_NORMAL
- en: ‘default’ interface methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface uses the `default` keyword to mark a method as inheritable by implementing
    classes. As already stated, if you do not specify an access modifier, they are
    `public` by default (pardon the pun!). Default methods must have an implementation
    - a set of curly braces must be present (even if they are empty braces). Classes
    that implement interfaces inherit any `default` methods. These classes may override
    the inherited version but this is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Interface default methods](img/B19793_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Interface default methods
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an `interface` called `Moveable` (lines 3-8). If line
    4 was uncommented, it would not compile since `default` (or `static`) interface
    methods must have code bodies. Line 5 defines a `default` method called `move()`.
    As there are no `abstract` methods in `Moveable`, classes implementing `Moveable`
    are not required to provide any particular methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cheetah` class (lines 9-14) implements `Moveable` and overrides `move()`.
    The `Elephant` class (line 15) implements `Moveable` also but does not override
    `move()`.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `Cheetah` objects will have a custom `move()` implementation, whereas
    `Elephant` objects will use the version inherited from `Moveable`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 20 shows that, as with `abstract` classes, you cannot `new` an interface
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Line 21 creates a `Cheetah` object referenced by a `Moveable` reference, namely
    `cheetah`. This is perfectly okay for two reasons. Firstly, references can be
    of the `interface` type and in many cases are. Secondly, this will compile so
    long as the object type implements the interface type, either directly (as is
    the case here) or indirectly (by inheriting from a class that implements the interface
    for you). Since the `Cheetah` class implements `Moveable`, all is well.
  prefs: []
  type: TYPE_NORMAL
- en: Line 22 executes the `move()` method from `Cheetah` polymorphically, resulting
    in `Moving very fast!` being output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Line 23 creates an `Elephant` object referenced by a `Moveable` reference, namely
    `elephant`. Since `Elephant` implements `Moveable`, this is ok.
  prefs: []
  type: TYPE_NORMAL
- en: Line 24 is interesting. Since `Elephant` does not provide a custom version of
    `move()`, the `default` one from `Moveable` (which `Elephant` implements) is used.
    Thus, `Moving` is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss `static` interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: ‘static’ interface methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface uses the `static` keyword to mark a method as a utility method.
    As with `default` methods, `static` methods are `public` by default. Similarly,
    as with `default` methods, `static` methods must have an implementation. However,
    classes that implement interfaces do not inherit `static` methods. To access a
    `static` method, you must use the `InterfaceName.staticMethodName()` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Interface static methods](img/B19793_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Interface static methods
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have an interface, `I`, that has a `static` method
    called `m1()` on line 5\. Note that line 4 is commented out because, as with `default`
    methods, the code body must be present for `static` methods also.
  prefs: []
  type: TYPE_NORMAL
- en: The `TestStaticMethods` class implements the `I` interface. As there are no
    `abstract` methods in the interface, no particular methods are implemented. Line
    9 shows the incorrect syntax to use and thus generates a compiler error. Line
    10 shows the correct syntax to use and outputs `3` when run.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we referred to multiple interface inheritance having a potential issue
    regarding `default` methods. Let’s explore that now.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple interface inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Diamond of Death ([https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C](https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C))
    arises when a class finds that it has inherited two methods of the same name;
    which one should it work with? This was a concern in C++, where multiple-class
    inheritance is allowed and was an influencing factor in prohibiting multiple-class
    inheritance in Java.
  prefs: []
  type: TYPE_NORMAL
- en: However, Java has always allowed a class to implement multiple interfaces. However,
    now that Java 8 allows `default` methods, which have code bodies that are inheritable,
    is it not possible for Java 8 to encounter a “Diamond of Death” scenario? Couldn’t
    a class implement two (or more) interfaces that have the same `default` methods?
    What happens then? The good news is that the compiler steps in and forces your
    class to override the “offending” `default` method.
  prefs: []
  type: TYPE_NORMAL
- en: So, that just leaves the question, what if we wanted to access each of the `default`
    methods? For example, let’s assume we have a `default` method called `foo()` in
    interface `A` and a `default` method called `foo()` in interface `B`. What if,
    in our class, we wanted to execute the three different versions of `foo()` – the
    one from `A`, the one from `B`, and the one from our class that the compiler forced
    us to create?
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.7* shows how to do this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Accessing multiple default code implementations](img/B19793_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Accessing multiple default code implementations
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, interface `A` defines its `foo()` method on line 4, whereas
    interface `B` defines its `foo()` method on line 7\. The `TestMultipleInheritance`
    class implements both `A` and `B`. As there is `foo()` code coming from both `A`
    and `B`, the compiler has to step in to prevent the “Diamond of Death.” Thus,
    the `foo()` method in `TestMultipleInheritance` (lines 11-16) is mandatory; otherwise,
    the code will not compile. As `default` methods are instance methods, when we
    override the interface version of `foo()`, we must ensure it is non-static.
  prefs: []
  type: TYPE_NORMAL
- en: Line 13 shows the syntax to use to invoke `foo()` from `A`. This syntax is `InterfaceName.super.methodName()`.
    So in this example, it is `A.super.foo()`. Since `super` is used, the methods
    must be instance methods. This is because only instance methods have access to
    (the parent instance using) the `super` reference (and to the current instance
    using the `this` reference).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, line 15 invokes `foo()` from `B` using `B.super.foo()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that line 14 does not compile and is commented out as a result. This is
    because, with the `A.foo()` syntax, the compiler is looking for a `static` method
    named `foo()` in interface `A`. However, the `foo()` method in `A` is non-static
    (line 4).
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, line 18 fails to compile. This is because, since `main()` is
    a `static` method (a `static` context), we cannot use `super`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 19 shows how to execute the custom `foo()` method in the class itself.
    Recall that we need an instance when calling a non-static (instance) method from
    a `static` method, hence the `new TestMultipleInheritance()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we’ve covered two types of non-abstract methods, namely `default`
    and `static` methods. There is one more: `private` interface methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining ‘private’ interface methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces can also have `private` methods with code implementations. They were
    introduced to reduce code duplication and improve encapsulation. These `private`
    methods can be both `static` and non-static. As they are `private`, they can only
    be accessed from within the interface. As with classes, you cannot access a non-static
    method from a `static` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at an example in code. Firstly, we will examine code that
    has code duplication. *Figure 10**.8* shows such an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – An interface with code duplication](img/B19793_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – An interface with code duplication
  prefs: []
  type: TYPE_NORMAL
- en: 'As this figure shows, lines 6, 11, and 16 are the same. In addition, lines
    8, 13, and 18 are also the same. We will refactor this interface to address this
    code duplication by using `private` methods. *Figure 10**.9* shows the code for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – An interface with private methods](img/B19793_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – An interface with private methods
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have a `private` `static` method called `hit(String)` that
    accepts the stroke (shot) to be played. The first thing to notice is that, as
    with `default` and `static` methods, a code body is expected and is present.
  prefs: []
  type: TYPE_NORMAL
- en: Line 25, which was replicated three times in *Figure 10**.8*, now appears only
    once. The same is true for line 27\. Line 26 outputs the stroke being played.
    Note that `hit(String)` is `static`. This enables the method to be invoked from
    `static` methods, such as `forehand()` (line 32).
  prefs: []
  type: TYPE_NORMAL
- en: There is a mix of `default`, `static`, and `private` methods to facilitate further
    discussion. Firstly, line 29 is a `default` method that invokes the `private`
    `hit(String)` method, which passes in the `backhand` string. Note that `default`
    methods cannot also be marked `private` as they have opposite semantics – `private`
    methods, as with classes, are not inherited, whereas `default` methods are inherited.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the `forehand()` method (lines 30-33) represents invoking `hit(String)`
    from a `static` context (line 32), passing in `forehand`. Line 31 represents an
    attempt to call a non-static `private` method called `smash()` from a `static`
    method. As with classes, this is not allowed and has been commented out as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we can call `private` methods from other `private` methods (line 34).
  prefs: []
  type: TYPE_NORMAL
- en: Line 35 is a reminder that methods that are not marked `default`, `static`,
    or `private` are `abstract` by default, so no code is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine how to use the `EfficientTennis` interface from a class that
    implements it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – An interface with private methods](img/B19793_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – An interface with private methods
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that the `SportTest` class has no methods to implement.
    This is because `EfficientTennis` does not declare any `abstract` methods, only
    `default`, `static`, and `private` ones.
  prefs: []
  type: TYPE_NORMAL
- en: Line 41 executes the `default` method called `backhand()` and line 42 executes
    the `static` method called `forehand()`. Note that line 43 attempts to access
    the `private` method called `hit(String)`. As the method is `private` to the interface,
    this is not allowed and, as a result, line 43 is commented out. This demonstrates
    that `hit(String)` is encapsulated from the outside world. In effect, `SportTest`
    does not know of and is therefore not dependent upon the `hit(String)` method.
    If `hit(String)` is changed or even deleted, provided that the `backhand()` and
    `forehand()` methods still work, `SportTest` will not be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move on to our last topic: `sealed` interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring sealed interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), we learned that `sealed`
    classes enable us to scope our inheritance hierarchy by specifying which classes
    can subtype our class. We used both the `sealed` and `permits` keywords as a pair
    to do this. Once a class has been sealed, each subclass of that class must be
    `sealed`, `non-sealed`, or `final` – that is, we continue the sealed hierarchy
    (`sealed`), end the sealed hierarchy (`non-sealed`), or end the hierarchy altogether
    (`final`).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to seal interfaces. We will use the example from [*Chapter
    9*](B19793_09.xhtml#_idTextAnchor205) with some small changes. Firstly, *Figure
    10**.11* shows the relevant UML diagram, which will help explain the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Sealed interface UML diagram](img/B19793_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Sealed interface UML diagram
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an interface, indicated by `<<interface>>`, called `Driveable`.
    In UML, to specify that a class implements an interface, the `<<realize>>` keyword
    is used (plus the dashed line with an arrow referring to the interface).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are going to scope the hierarchy as follows: the only class
    allowed to implement `Driveable` is `Vehicle`, the only `Vehicle` subclass allowed
    is `Car`, and the only subclass of `Car` allowed is `Saloon`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we get to `Saloon`, we want to open up the hierarchy again – unseal it,
    if you like. This allows `Ford` and `Volvo` to extend from `Saloon`. Note that
    this is for demonstration purposes only as any class can now subclass `Saloon`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Chair`, `Table`, and `Window` classes are all unrelated and not part of
    the sealed hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.12* shows some code where a sealed interface is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Sealed interface code](img/B19793_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Sealed interface code
  prefs: []
  type: TYPE_NORMAL
- en: The important lines in this figure are lines 3-4\. Line 3 states that the `Driveable`
    interface is `sealed` and that only one class is allowed to implement it, namely
    `Vehicle`. `Vehicle` must now implement `Driveable`; otherwise, the code will
    fail to compile. `Vehicle` does implement `Driveable` (line 4), so all is well.
    In addition, `Vehicle` is `sealed` and the only subclass permitted is `Car`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 6 states that `Car` subclasses `Vehicle` and that `Saloon` is the only
    subtype allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Line 7 states that `Saloon` is, as expected, a subclass of `Car`. The fact that
    `Saloon` is `non-sealed` opens up the hierarchy and enables `Volvo` (line 8) and
    `Ford` (line 9) to extend from `Saloon`.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 11-13 all fail to compile. Line 11 reminds us that `Vehicle` permits `Car`
    subtypes only. Similarly, line 12 reminds us that `Car` permits `Saloon` subtypes
    only. Line 13 shows, as per line 3, that the only class that can implement `Driveable`
    is `Vehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on interfaces and `abstract` classes. Now, let’s
    apply what we have learned!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With interfaces and `abstract` classes, we can improve our application structure
    even further! Take a look at the following exercises to test your knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Dinosaurs, no matter the exact species, have common behaviors such as eating
    and moving. Define an interface that encapsulates these behaviors, come up with
    a logical name for it, and implement it in the `Dinosaur` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our park uses different types of vehicles for different purposes. Design an
    `abstract` class called `Vehicle` and derive concrete classes such as `Jeep` and
    `Helicopter` from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `Vehicle` class so that it includes an `abstract` method called `travel()`
    that provides different implementations in its subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make our `Dinosaur` class sortable by implementing the `Comparable` interface
    to compare dinosaurs based on their age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, our employees also have common behaviors. Define a `Worker` interface
    with methods that represent these behaviors and implement it in the `Employee`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our dinosaurs are housed in different enclosures. Implement the `List` interface
    using `ArrayList` to manage dinosaurs for an enclosure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dinosaurs have different feeding behaviors based on their diet. Create `Carnivore`
    and `Herbivore` interfaces and implement them in the appropriate dinosaur subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – unified park management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this rather advanced project, you will elevate the Mesozoic Eden Park Manager
    application to the next level. You’ll do so by utilizing the classes you created
    earlier. You can continue to work on the previous project or start from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The enhanced system will implement polymorphism so that different types of
    dinosaurs and employees can be managed. This will increase the versatility and
    functionality of your park management, allowing for diverse dinosaur species and
    employee roles. The enhanced system should include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The capability to manage various dinosaur species profiles, broadening the diversity
    of your park
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capacity to manage different types of employee profiles, such as veterinarians,
    guides, maintenance workers, and security personnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other features should also accommodate these new changes, including editing
    and removing profiles, tracking dinosaurs, managing employee schedules, managing
    guest admissions, and handling special events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step plan to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` classes into various subclasses to represent different
    types of dinosaurs and employees. Make sure you use the principle of polymorphism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` objects, each of which could be an instance of any
    subclass.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Update interaction**: Adapt your interactive console-based interface so that
    it can handle the new types of dinosaurs and employees. You might need to add
    new options or submenus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Update menu creation**: Your menu should now provide options for managing
    various types of dinosaurs and employees. Ensure each option corresponds to a
    particular function in the program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Manage Dinosaurs` option could now trigger a function to add, remove, or edit
    profiles for any dinosaur species.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exit program**: Provide an option for the user to exit the program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your starting code will be very similar to the code shown in the last two chapters.
    Some methods, such as `manageDinosaurs()` and `manageEmployees()`, will need to
    be updated and become a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `manageDinosaurs()`, `manageEmployees()`, `manageTickets()`, `checkParkStatus()`,
    and `handleSpecialEvents()` methods need to handle the added complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by examining `abstract` classes. An `abstract` class
    has zero or more `abstract` methods. However, if any method is `abstract`, then
    the class must be `abstract`. While an `abstract` class cannot be instantiated,
    a reference can be of an `abstract` type.
  prefs: []
  type: TYPE_NORMAL
- en: Before Java 8, interfaces consisted of only `abstract` methods (and constants).
    We started our discussion on interfaces at this point, where all the methods were
    `abstract`. While a class can only extend from one class, a class can implement
    many interfaces. This is one of the main reasons why interfaces were introduced
    – to be able to cast to more than one base type.
  prefs: []
  type: TYPE_NORMAL
- en: A class that implements an interface signs a “contract” to provide code for
    each of the `abstract` methods (if any) in the interface. If there is an `abstract`
    method in the interface and the concrete, non-abstract class does not provide
    code implementation for it, the compiler complains. Therefore, interfaces are
    a great way of guaranteeing that certain methods will be present in a class. Variables
    in an interface are constants by default. These constants are available to implementing
    classes, but are read-only. We noted that multiple interface inheritance, where
    an interface can inherit from several other interfaces, is allowed. This contrasts
    with classes, be they `abstract` or concrete, where multiple inheritance is prohibited.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 8, `default` and `static` methods, both with code bodies, were introduced
    to interfaces. This was the first time code was allowed in interfaces. Regarding
    inheritance, `default` methods are inherited by implementing classes, whereas
    `static` methods are not. Thus, accessing both requires different syntaxes. As
    `default` methods are inherited, they can be overridden by implementing classes.
    Both types of methods, as with `abstract` methods, are `public` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we saw how the compiler prevents us from experiencing the “Diamond of
    Death.” This issue could arise when two interfaces have the same `default` method
    name. A class that implements these two interfaces is forced to provide a custom
    implementation to avoid ambiguity. This led nicely to the syntax (using `super`),
    which enables us the `default` methods in both interfaces and the custom (non-default)
    version in the class.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 introduced `private` interface methods, which also have code bodies.
    They were introduced to reduce code duplication and improve encapsulation. We
    detailed an example where we refactored code by introducing `private` interface
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter by discussing `sealed` interfaces, which were introduced
    in Java 17\. Much like `sealed` classes ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)),
    `sealed` interfaces enable us to scope the hierarchy – that is, when declaring
    a `sealed` interface, we specify the classes that are permitted to implement it.
    We presented a UML diagram and some code to explain this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on interfaces and `abstract` classes. In the next
    chapter, we will cover exceptions.
  prefs: []
  type: TYPE_NORMAL
