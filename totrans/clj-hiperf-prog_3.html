<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Leaning on Java"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Leaning on Java</h1></div></div></div><p>Being hosted on the JVM, there are several aspects of Clojure that really help to understand about the Java language and platform. The need is not only due to interoperability with Java or understanding its implementation, but also for performance reasons. In certain cases, Clojure may not generate optimized JVM bytecode by default; in some other cases, you may want to go beyond the performance that Clojure data structures offer—you can use the Java alternatives via Clojure to get better performance. This chapter discusses those aspects of Clojure. In this chapter we will discuss:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inspecting Java and bytecode generated from a Clojure source</li><li class="listitem" style="list-style-type: disc">Numerics and primitives</li><li class="listitem" style="list-style-type: disc">Working with arrays</li><li class="listitem" style="list-style-type: disc">Reflection and type hinting</li></ul></div><div class="section" title="Inspecting the equivalent Java source for Clojure code"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Inspecting the equivalent Java source for Clojure code</h1></div></div></div><p>Inspecting the equivalent <a class="indexterm" id="id163"/>Java source for a given <a class="indexterm" id="id164"/>Clojure code provides great insight into how that might impact its performance. However, Clojure generates only Java bytecodes at runtime unless we compile a namespace out to the disk. When developing with Leiningen, only selected namespaces under the <code class="literal">:aot</code> vector in the <code class="literal">project.clj</code> file are output as the compiled <code class="literal">.class</code> files containing bytecodes. Fortunately, an easy and quick way to know the equivalent Java source for the Clojure code is to AOT-compile namespaces and then decompile the bytecodes into equivalent Java sources, using a Java bytecode decompiler.</p><p>There are several commercial and open source Java bytecode decompilers available. One of the open source decompilers we will discuss here is<a class="indexterm" id="id165"/> <span class="strong"><strong>JD-GUI</strong></span>, which you can download from<a class="indexterm" id="id166"/> its website (<a class="ulink" href="http://jd.benow.ca/#jd-gui">http://jd.benow.ca/#jd-gui</a>). Use a version suitable for your operating system.</p><div class="section" title="Creating a new project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Creating a new project</h2></div></div></div><p>Let's see how exactly to<a class="indexterm" id="id167"/> arrive at the equivalent Java source code from Clojure. Create a new project using Leiningen: <code class="literal">lein new foo</code>. Then edit the <code class="literal">src/foo/core.clj</code> file with a <code class="literal">mul</code> function to find out the product of two numbers:</p><div class="informalexample"><pre class="programlisting">(ns foo.core)

(defn mul [x y]
  (* x y))</pre></div></div><div class="section" title="Compiling the Clojure sources into Java bytecode"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Compiling the Clojure sources into Java bytecode</h2></div></div></div><p>Now, to compile<a class="indexterm" id="id168"/> Clojure sources into bytecodes and <a class="indexterm" id="id169"/>output them as <code class="literal">.class</code> files, run the <code class="literal">lein compile :all</code> command. It creates the <code class="literal">.class</code> files in the <code class="literal">target/classes</code> directory of the project as follows:</p><div class="informalexample"><pre class="programlisting">target/classes/
`-- foo
    |-- core$fn__18.class
    |-- core__init.class
    |-- core$loading__4910__auto__.class
    `-- core$mul.class</pre></div><p>You can see that the <code class="literal">foo.core</code> namespace has been compiled into four <code class="literal">.class</code> files.</p></div><div class="section" title="Decompiling the .class files into Java source"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Decompiling the .class files into Java source</h2></div></div></div><p>Assuming that you<a class="indexterm" id="id170"/> have already installed JD-GUI, decompiling<a class="indexterm" id="id171"/> the <code class="literal">.class</code> files is as simple as opening them using the JD-GUI application.</p><div class="mediaobject"><img alt="Decompiling the .class files into Java source" src="graphics/B04596_03_01.jpg"/></div><p>On inspection, the <a class="indexterm" id="id172"/>code for the <code class="literal">foo.core/mul</code> function <a class="indexterm" id="id173"/>looks as follows:</p><div class="informalexample"><pre class="programlisting">package foo;

import clojure.lang.AFunction;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Var;

public final class core$mul extends AFunction
{
  public static final Var const__0 = (Var)RT.var("clojure.core", "*");

  public Object invoke(Object x, Object y) { x = null; y = null; return Numbers.multiply(x, y);
  }
}</pre></div><p>It is easy to understand from the decompiled Java source that the foo.core/mul function is an instance of the core$mul class in the foo package extending the clojure.lang.AFunction class. We can also see that the argument types are of the Object type in method invoke(Object, Object), which implies the numbers will be boxed. In a similar fashion, you can decompile class files of any Clojure code to inspect the equivalent Java code. If you can combine this with knowledge about Java types and potential reflection and boxing, you can find the suboptimal spots in code and focus on what to improve upon.</p></div><div class="section" title="Compiling the Clojure source without locals clearing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Compiling the Clojure source without locals clearing</h2></div></div></div><p>Note the Java code<a class="indexterm" id="id174"/> in the method invoke where it says <code class="literal">x = null; y = null;</code> —how is it possible that the code throws away the arguments, sets them to null, and effectively multiplies two null objects? This misleading decompilation happens due to locals clearing, a feature of the JVM bytecode implementation of Clojure, which has no equivalent in the Java language.</p><p>Starting with Clojure 1.4, the compiler supports the <code class="literal">:disable-locals-clearing</code> key in the dynamic <code class="literal">clojure.core/*compiler-options*</code> var that we cannot configure in the <code class="literal">project.clj</code> file. So, we cannot use the <code class="literal">lein compile</code> command, but we can start a <span class="strong"><strong>REPL</strong></span>
<a class="indexterm" id="id175"/> with the <code class="literal">lein repl</code> command to compile the classes:</p><div class="informalexample"><pre class="programlisting">user=&gt; (binding [*compiler-options* {:disable-locals-clearing true}] (compile 'foo.core))
foo.core</pre></div><p>This generates the class files in the same location as we saw earlier in this section, but without <code class="literal">x = null; y = null;</code> because locals clearing is omitted.</p></div></div></div>
<div class="section" title="Numerics, boxing, and primitives"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Numerics, boxing, and primitives</h1></div></div></div><p>
<span class="strong"><strong>Numerics</strong></span> <a class="indexterm" id="id176"/>are scalars. The discussion on numerics was deferred till this chapter for the sole reason that the numerics implementation in Clojure has strong Java underpinnings. Since version 1.3, Clojure has settled with 64-bit numerics as the default. Now, <code class="literal">long</code> and <code class="literal">double</code> are idiomatic and the default numeric types. Note that these are primitive Java types, not objects. Primitives in Java lead to high performance and have several optimizations associated with them at compiler and runtime levels. A local primitive is created on the stack (hence does not contribute to heap allocation and GC) and can be accessed directly without any kind of dereferencing. In Java, there also exist object equivalents of the numeric primitives, known as<a class="indexterm" id="id177"/> <span class="strong"><strong>boxed numerics</strong></span>—these are regular objects that are allocated on the heap. The boxed numerics are also immutable objects, which mean not only does the JVM need to dereference the stored value when reading it, but also needs to create a new boxed object when a new value needs to be created.</p><p>It should be obvious that boxed numerics are slower than their primitive equivalents. The Oracle HotSpot JVM, when started with the <code class="literal">-server</code> option, aggressively inlines those functions (on frequent invocation) that contain a call to primitive operations. Clojure automatically uses <span class="strong"><strong>primitive numerics</strong></span>
<a class="indexterm" id="id178"/> at several levels. In the <code class="literal">let</code> blocks, <code class="literal">loop</code> blocks, arrays, and arithmetic operations (<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code>, <code class="literal">inc</code>, <code class="literal">dec</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, <code class="literal">&gt;=</code>), primitive numerics are detected and retained. The following table describes the primitive numerics with their boxed equivalents:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Primitive numeric type</p>
</th><th style="text-align: left" valign="bottom">
<p>Boxed equivalent</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>byte (1 byte)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.lang.Byte</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>short (2 bytes)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.lang.Short</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>int (4 bytes)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.lang.Integer</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>float (4 bytes)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.lang.Float</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>long (8 bytes)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.lang.Long</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>double (8 bytes)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.lang.Double</code>
</p>
</td></tr></tbody></table></div><p>In Clojure, sometimes you may find the numerics are passed or returned as boxed objects to or from functions due to the lack of type information at runtime. Even if you have no control over such functions, you can coerce the values to be treated as primitives. The <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">long</code>, and <code class="literal">double</code> functions create primitive equivalents from given boxed numeric values.</p><p>One of the Lisp traditions is to <a class="indexterm" id="id179"/>provide correct (<a class="ulink" href="http://en.wikipedia.org/wiki/Numerical_tower">http://en.wikipedia.org/wiki/Numerical_tower</a>) arithmetic implementation. A lower type should not truncate values when overflow or underflow happens, but rather should be promoted to construct a higher type to maintain correctness. Clojure follows this constraint and provides <a class="indexterm" id="id180"/>
<span class="strong"><strong>autopromotion</strong></span> via prime (<a class="ulink" href="http://en.wikipedia.org/wiki/Prime_(symbol)">http://en.wikipedia.org/wiki/Prime_(symbol)</a>) functions: <code class="literal">+'</code>, <code class="literal">-'</code>, <code class="literal">*'</code>, <code class="literal">inc'</code>, and <code class="literal">dec'</code>. Autopromotion<a class="indexterm" id="id181"/> provides correctness at the cost of some performance.</p><p>There are also arbitrary length or precision numeric types in Clojure that let us store unbounded numbers but have poorer performance compared to primitives. The <code class="literal">bigint</code> and <code class="literal">bigdec</code> functions let us create numbers of arbitrary length and precision.</p><p>If we try to carry out any operations with primitive numerics that may result in a number beyond its maximum capacity, the operation maintains correctness by throwing an exception. On the other hand, when we use the prime functions, they autopromote to provide correctness. There is another set of operations called unchecked operations, which do not check for overflow or underflow and can potentially return incorrect results.</p><p>In some cases, they may be faster than regular and prime functions. Such functions are <code class="literal">unchecked-add</code>, <code class="literal">unchecked-subtract</code>, <code class="literal">unchecked-multiply</code>, <code class="literal">unchecked-divide</code>, <code class="literal">unchecked-inc</code>, and <code class="literal">unchecked-dec</code>. We can also enable unchecked math behavior for regular arithmetic functions using the <code class="literal">*unchecked-math*</code> var; simply include the following in your source code file:</p><div class="informalexample"><pre class="programlisting">(set! *unchecked-math* true)</pre></div><p>One of the common needs in the arithmetic is the division used to find out the quotient and remainder after a natural number division. Clojure's <code class="literal">/</code> function provides a rational number division yielding a ratio, and the <code class="literal">mod</code> function provides a true modular arithmetic division. These functions are slower than the <code class="literal">quot</code> and <code class="literal">rem</code> functions that compute the division quotient and the remainder, respectively.</p></div>
<div class="section" title="Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Arrays</h1></div></div></div><p>Besides<a class="indexterm" id="id182"/> objects and primitives, Java has a special type of collection storage structure called <span class="strong"><strong>arrays</strong></span>. Once created, arrays cannot be grown or shrunk without copying data and creating another array to hold the result. Array elements are always homogeneous in type. The array elements are similar to places where you can mutate them to hold new values. Unlike collections such as list and vector, arrays can contain primitive elements, which make them a very fast storage mechanism without GC overhead.</p><p>Arrays often form a basis for mutable data structures. For example, Java's <code class="literal">java.lang.ArrayList</code> implementation uses arrays internally. In Clojure, arrays can be used for fast numeric storage and processing, efficient algorithms, and so on. Unlike collections, arrays<a class="indexterm" id="id183"/> can have one or more dimensions. So you could layout data in an array such as a matrix or cube. Let's see Clojure's support for arrays:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th><th style="text-align: left" valign="bottom">
<p>Notes</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Create array</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(make-array Integer 20)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Array of type (boxed) integer</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">(make-array Integer/TYPE 20)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Array of primitive type integer</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">(make-array Long/TYPE 20 10)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Two-dimensional array of primitive long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Create array of primitives</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(int-array 20)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Array of primitive integer of size 20</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">(int-array [10 20 30 40])</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Array of primitive integer created from a vector</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Create array from coll</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(to-array [10 20 30 40])</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Array from sequable</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">(to-array-2d [[10 20 30][40 50 60]])</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Two-dimensional array from collection</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Clone an array</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(aclone (to-array [:a :b :c]))</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Get array element</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(aget array-object 0 3)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Get element at index [0][3] in a 2-D array</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Mutate array element</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(aset array-object 0 3 :foo)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Set obj :foo at index [0][3] in a 2-D array</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Mutate primitive array element</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(aset-int int-array-object 2 6 89)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Set value 89 at index [2][6] in 2-D array</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Find length of array</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(alength array-object)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">alength</code> is significantly faster than count</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Map over an array</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(def a (int-array [10 20 30 40 50 60]))</code>
</p>
<p>
<code class="literal">(seq</code>
</p>
<p>
<code class="literal">  (amap a idx ret</code>
</p>
<p>
<code class="literal">    (do (println idx (seq ret))</code>
</p>
<p>
<code class="literal">      (inc (aget a idx)))))</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Unlike map, <code class="literal">amap</code> returns a non-lazy array, which is significantly faster over array elements. Note that <code class="literal">amap</code> is faster only when properly type hinted. See next section for type hinting.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Reduce over an array</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(def a (int-array [10 20 30 40 50 60]))</code>
</p>
<p>
<code class="literal">(areduce a idx ret 0</code>
</p>
<p>
<code class="literal">  (do (println idx ret)</code>
</p>
<p>
<code class="literal">    (+ ret idx)))</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Unlike reduce, <code class="literal">areduce</code> is significantly faster over array elements. Note that reduce is faster only when properly type hinted. See next section for type hinting.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Cast to primitive arrays</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(ints int-array-object)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Used with type hinting (see next section)</p>
</td></tr></tbody></table></div><p>Like <code class="literal">int-array</code> and <code class="literal">ints</code>, there are <a class="indexterm" id="id184"/>functions for other types as well:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Array construction function</p>
</th><th style="text-align: left" valign="bottom">
<p>Primitive-array casting function</p>
</th><th style="text-align: left" valign="bottom">
<p>Type hinting (does not work for vars)</p>
</th><th style="text-align: left" valign="bottom">
<p>Generic array type hinting</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>boolean-array</p>
</td><td style="text-align: left" valign="top">
<p>booleans</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^booleans</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[Z"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>byte-array</p>
</td><td style="text-align: left" valign="top">
<p>bytes</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^bytes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[B"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>short-array</p>
</td><td style="text-align: left" valign="top">
<p>shorts</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^shorts</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[S"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>char-array</p>
</td><td style="text-align: left" valign="top">
<p>chars</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^chars</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[C"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>int-array</p>
</td><td style="text-align: left" valign="top">
<p>ints</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^ints</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[I"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>long-array</p>
</td><td style="text-align: left" valign="top">
<p>longs</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^longs</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[J"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>float-array</p>
</td><td style="text-align: left" valign="top">
<p>floats</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^floats</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[F"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>double-array</p>
</td><td style="text-align: left" valign="top">
<p>doubles</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^doubles</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[D"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>object-array</p>
</td><td style="text-align: left" valign="top">
<p>   ––</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^objects</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^"[Ljava.lang.Object"</code>
</p>
</td></tr></tbody></table></div><p>Arrays are favored over other data structures mainly due to performance, and sometimes due to interop. Extreme care should be taken to type hint the arrays and use the appropriate functions to work with them.</p></div>
<div class="section" title="Reflection and type hints"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Reflection and type hints</h1></div></div></div><p>Sometimes, as Clojure is dynamically typed, the Clojure compiler is unable to figure out the type of object to invoke a certain method. In such cases, Clojure uses <a class="indexterm" id="id185"/>
<span class="strong"><strong>reflection</strong></span>, which is considerably slower than the direct method dispatch. Clojure's solution to this is something called <a class="indexterm" id="id186"/>
<span class="strong"><strong>type hints</strong></span>. Type hints are a way to annotate arguments and objects with static types, so that the Clojure compiler can emit bytecodes for efficient dispatch.</p><p>The easiest way to know where to put type hints is to turn on reflection warning in the code. Consider this code that determines the length of a string:</p><div class="informalexample"><pre class="programlisting">user=&gt; (set! *warn-on-reflection* true)
true
user=&gt; (def s "Hello, there")
#'user/s
user=&gt; (.length s)
Reflection warning, NO_SOURCE_PATH:1 - reference to field length can't be resolved.
12
user=&gt; (defn str-len [^String s] (.length s))
#'user/str-len
user=&gt; (str-len s)
12
user=&gt; (.length ^String s)  ; type hint when passing argument
12
user=&gt; (def ^String t "Hello, there")  ; type hint at var level
#'user/t
user=&gt; (.length t)  ; no more reflection warning
12
user=&gt; (time (dotimes [_ 1000000] (.length s)))
Reflection warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init6904047906685577265.clj:1:28 - reference to field length can't be resolved.
"Elapsed time: 2409.155848 msecs"
nil
user=&gt; (time (dotimes [_ 1000000] (.length t)))
"Elapsed time: 12.991328 msecs"
nil</pre></div><p>In the previous snippet, we can clearly see there is a very big difference in performance in the code that uses reflection versus the code that does not. When working on a project, you may want reflection warning to be turned on for all files. You can do it easily in Leiningen. Just put the following entry in your <code class="literal">project.clj</code> file:</p><div class="informalexample"><pre class="programlisting">:profiles {:dev {:global-vars {*warn-on-reflection* true}}}</pre></div><p>This will automatically turn on warning reflection every time you begin any kind of invocation via Leiningen in the dev workflow such as REPL and test.</p><div class="section" title="An array of primitives"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>An array of primitives</h2></div></div></div><p>Recall the <a class="indexterm" id="id187"/>examples on <code class="literal">amap</code> and <code class="literal">areduce</code> from the previous section. If we run them with reflection warning on, we'd be warned that it uses reflection. Let's type hint them:</p><div class="informalexample"><pre class="programlisting">(def a (int-array [10 20 30 40 50 60]))
;; amap example
(seq
<span class="strong"><strong>  (amap ^ints a idx ret</strong></span>
    (do (println idx (seq ret))
      (inc (aget ^ints a idx)))))
;; areduce example
(areduce ^ints a idx ret 0
  (do (println idx ret)
    (+ ret idx)))</pre></div><p>Note that the primitive array hint <code class="literal">^ints</code> does not work at the var level. So, it would not work if you defined the var <code class="literal">a</code>, as in the following:</p><div class="informalexample"><pre class="programlisting">(def ^ints a (int-array [10 20 30 40 50 60]))  ; wrong, will complain later
(def ^"[I" a (int-array [10 20 30 40 50 60]))  ; correct
(def ^{:tag 'ints} a (int-array [10 20 30 40 50 60])) ; correct</pre></div><p>This notation is for an array of integers. Other primitive array types have similar type hints. Refer to the previous section for type hinting for various primitive array types.</p></div><div class="section" title="Primitives"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Primitives</h2></div></div></div><p>The type hinting of <a class="indexterm" id="id188"/>primitive locals is neither required nor allowed. However, you can type hint function arguments as primitives. Clojure allows up to four arguments in functions to be type hinted:</p><div class="informalexample"><pre class="programlisting">(defn do-something
  [^long a ^long b ^long c ^long d]
  ..)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Boxing may result in something not always being a primitive. In those cases, you can coerce those using respective primitive types.</p></div></div></div><div class="section" title="Macros and metadata"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Macros and metadata</h2></div></div></div><p>In <a class="indexterm" id="id189"/>macros, type hinting does not work the way it does in the other parts of the code. Since macros are about transforming the <a class="indexterm" id="id190"/>
<span class="strong"><strong>Abstract Syntax Tree</strong></span> (<span class="strong"><strong>AST</strong></span>), we need to have a mental map of the transformation and we <a class="indexterm" id="id191"/>should add type hints as metadata in the code. For example, if <code class="literal">str-len</code> is a macro to find the length of a string, we make use of the following code:</p><div class="informalexample"><pre class="programlisting">(defmacro str-len
  [s]
  `(.length ~(with-meta s {:tag String})))
;; below is another way to write the same macro
(defmacro str-len
  [s]
  `(.length ~(vary-meta s assoc :tag `String)))</pre></div><p>In the preceding code, we alter the metadata of the symbol <code class="literal">s</code> by tagging it with the type <code class="literal">String</code>, which happens to be the <code class="literal">java.lang.String</code> class in this case. For array types, we can use <code class="literal">[Ljava.lang.String</code> for an array of string objects and similarly for others. If you try to use <code class="literal">str-len</code> listed previously, you may notice this works only when we pass the string bound to a local or a var, not as a string literal. To mitigate this, we can write the macro as follows:</p><div class="informalexample"><pre class="programlisting">(defmacro str-len
  [s]
  `(let [^String s# ~s] (.length s#)))</pre></div><p>Here we bind the argument to a type-hinted gensym local, hence calling <code class="literal">.length</code> on it does not use reflection and there is no reflection warning emitted as such.</p><p>Type hinting via metadata also works with functions, albeit in a different notation:</p><div class="informalexample"><pre class="programlisting">(defn foo [] "Hello")
(defn foo ^String [] "Hello")
(defn foo (^String [] "Hello") (^String [x] (str "Hello, " x)))</pre></div><p>Except for the first example in the preceding snippet, they are type hinted to return the <code class="literal">java.lang.String</code> type.</p><div class="section" title="String concatenation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>String concatenation</h3></div></div></div><p>The <code class="literal">str</code> function in Clojure is <a class="indexterm" id="id192"/>used to concatenate and convert to string tokens. In Java, when we write <code class="literal">"hello" + e</code>, the Java compiler translates this to an equivalent code that uses <code class="literal">StringBuilder</code> and is considerably faster than the <code class="literal">str</code> function in micro-benchmarks. To obtain close-to-Java performance, in Clojure we can use a similar mechanism with a macro directly using Java interop to avoid the indirection via the <code class="literal">str</code> function. The<a class="indexterm" id="id193"/> <span class="strong"><strong>Stringer</strong></span> (<a class="ulink" href="https://github.com/kumarshantanu/stringer">https://github.com/kumarshantanu/stringer</a>) library adopts the same technique to come up with<a class="indexterm" id="id194"/> fast string concatenation in Clojure:</p><div class="informalexample"><pre class="programlisting">(require '[stringer.core :as s])
user=&gt; (time (dotimes [_ 10000000] (str "foo" :bar 707 nil 'baz)))
"Elapsed time: 2044.284333 msecs"
nil
user=&gt; (time (dotimes [_ 10000000] (s/strcat "foo" :bar 707 nil 'baz)))
"Elapsed time: 555.843271 msecs"
nil</pre></div><p>Here, Stringer also aggressively concatenates the literals during the compile phase.</p></div></div><div class="section" title="Miscellaneous"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Miscellaneous</h2></div></div></div><p>In a type (as in <code class="literal">deftype</code>), the mutable instance variables can be optionally annotated as <code class="literal">^:volatile-mutable</code> or <code class="literal">^:unsynchronized-mutable</code>. For example:</p><div class="informalexample"><pre class="programlisting">(deftype Counter [^:volatile-mutable ^long now]
  ..)</pre></div><p>Unlike <code class="literal">defprotocol</code>, the <code class="literal">definterface</code> macro lets us provide a return type hint for methods:</p><div class="informalexample"><pre class="programlisting">(definterface Foo
  (^long doSomething [^long a ^double b]))</pre></div><p>The <code class="literal">proxy-super</code> macro (which is used inside the <code class="literal">proxy</code> macro) is a <a class="indexterm" id="id195"/>special case where you cannot directly apply a type hint. The reason being that it relies on the implicit this object that is automatically created by the <code class="literal">proxy</code> macro. In this case, you must explicitly bind this to a type:</p><div class="informalexample"><pre class="programlisting">(proxy [Object][]
  (equals [other]
    (let [^Object this this]
      (proxy-super equals other))))</pre></div><p>Type hinting is quite important for performance in Clojure. Fortunately, we need to type hint only when required and it's easy to find out when. In many cases, a gain from type hinting overshadows the gains from code inlining.</p></div></div>
<div class="section" title="Using array/numeric libraries for efficiency"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Using array/numeric libraries for efficiency</h1></div></div></div><p>You may have<a class="indexterm" id="id196"/> noticed in the <a class="indexterm" id="id197"/>previous sections, when working with numerics, performance depends a lot on whether the data is based on arrays and primitives. It may take a lot of meticulousness on the programmer's part to correctly coerce data into primitives and arrays at all stages of the computation in order to achieve optimum efficiency. Fortunately, the high-performance enthusiasts from the Clojure community realized this issue early on and created some dedicated open source libraries to mitigate the problem.</p><div class="section" title="HipHip"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>HipHip</h2></div></div></div><p>
<span class="strong"><strong>HipHip</strong></span>
<a class="indexterm" id="id198"/> is a Clojure library used to work with arrays of primitive types. It provides a safety net, that is, it strictly accepts only primitive array arguments to work with. As a result, passing silently boxed primitive arrays as arguments always results in an exception. HipHip macros and functions rarely need the programmer to type hint anything during the operations. It supports arrays of primitive types such as <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, and <code class="literal">double</code>.</p><p>The HipHip<a class="indexterm" id="id199"/> project is available at <a class="ulink" href="https://github.com/Prismatic/hiphip">https://github.com/Prismatic/hiphip</a>.</p><p>As of writing, HipHip's most recent version is 0.2.0 that supports Clojure 1.5.x or above, and is tagged as an Alpha release. There is a standard set of operations provided by HipHip for arrays of all of the four primitive types: integer array operations are in the namespace <code class="literal">hiphip.int</code>; double precision array operations in <code class="literal">hiphip.double</code>; and so on. The operations are all type hinted for the respective types. All of the operations for <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, and <code class="literal">double</code> in respective namespaces are essentially the same except for the array type:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Category</p>
</th><th style="text-align: left" valign="bottom">
<p>Function/macro</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Core functions</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">aclone</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">clojure.core/aclone</code>, for primitives</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">alength</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">clojure.core/alength</code>, for primitives</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">aget</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">clojure.core/aget</code>, for primitives</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">aset</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">clojure.core/aset</code>, for primitives</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">ainc</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Increment array element by specified value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Equiv hiphip.array operations</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">amake</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Make a new array and fill values computed by expression</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">areduce</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">clojure.core/areduce</code>, with HipHip array bindings</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">doarr</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">clojure.core/doseq</code>, with HipHip array bindings</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">amap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">clojure.core/for</code>, creates new array</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">afill!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like preceding <code class="literal">amap</code>, but overwrites array argument</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Mathy operations</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">asum</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Compute sum of array elements using expression</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">aproduct</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Compute product of array elements using expression</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">amean</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Compute<a class="indexterm" id="id200"/> mean over array elements</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">dot-product</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Compute dot product of two arrays</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Finding minimum/maximum, Sorting</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">amax-index</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Find maximum value in array and return the index</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">amax</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Find maximum value in array and return it</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">amin-index</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Find minimum value in array and return the index</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">amin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Find minimum value in array and return it</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">apartition!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Three-way partition of array: less, equal, greater than pivot</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">aselect!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Gather smallest <code class="literal">k</code> elements at the beginning of array</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">asort!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sort array in-place using Java's built-in implementation</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">asort-max!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Partial in-place sort gathering top <code class="literal">k</code> elements to the end</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">asort-min!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Partial in-place sort gathering min <code class="literal">k</code> elements to the top</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">apartition-indices!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">apartition!</code> but mutates index-array instead of values</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">aselect-indices!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">aselect!</code> but mutates index-array instead of values</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">asort-indices!</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like <code class="literal">asort!</code> but mutates index-array instead of values</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">amax-indices</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Get index-array; last <code class="literal">k</code> indices pointing to max <code class="literal">k</code> values</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">amin-indices</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Get index-array; first <code class="literal">k</code> indices pointing to min <code class="literal">k</code> values</p>
</td></tr></tbody></table></div><p>To include HipHip as a <a class="indexterm" id="id201"/>dependency in your Leiningen project, specify it in <code class="literal">project.clj</code>:</p><div class="informalexample"><pre class="programlisting">:dependencies [;; other dependencies
               [prismatic/hiphip "0.2.0"]]</pre></div><p>As an example of how to use HipHip, let's see how to compute the normalized values of an array:</p><div class="informalexample"><pre class="programlisting">(require '[hiphip.double :as hd])

(def xs (double-array [12.3 23.4 34.5 45.6 56.7 67.8]))

(let [s (hd/asum xs)] (hd/amap [x xs] (/ x s)))</pre></div><p>Unless we make sure that <code class="literal">xs</code> is an array of primitive doubles, HipHip will throw <code class="literal">ClassCastException</code> when the type is incorrect, and <code class="literal">IllegalArgumentException</code> in other cases. I recommend exploring the HipHip project to gain more insight into using it effectively.</p></div><div class="section" title="primitive-math"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>primitive-math</h2></div></div></div><p>We can set <code class="literal">*warn-on-reflection*</code> to true to <a class="indexterm" id="id202"/>let Clojure warn us when the reflection is used at invocation boundaries. However, when Clojure has to implicitly use reflection to perform math, the only resort is to either use a profiler or compile the Clojure source down to bytecode, and analyze boxing and reflection with a decompiler. This is where the <code class="literal">primitive-math</code> library helps, by producing extra warnings and throwing exceptions.</p><p>The <code class="literal">primitive-math</code> library <a class="indexterm" id="id203"/>is available at <a class="ulink" href="https://github.com/ztellman/primitive-math">https://github.com/ztellman/primitive-math</a>.</p><p>As of writing, primitive-math is at version 0.1.4; you can include it as a dependency in your Leiningen project by editing <code class="literal">project.clj</code> as follows:</p><div class="informalexample"><pre class="programlisting">:dependencies [;; other dependencies
               [primitive-math "0.1.4"]]</pre></div><p>The following code is how it can be used (recall the example from the <span class="emphasis"><em>Decompiling the .class files into Java source</em></span> section):</p><div class="informalexample"><pre class="programlisting">;; must enable reflection warnings for extra warnings from primitive-math
(set! *warn-on-reflection* true)
(require '[primitive-math :as pm])
(defn mul [x y] (pm/* x y))  ; primitive-math produces reflection warning
(mul 10.3 2)                        ; throws exception
(defn mul [^long x ^long y] (pm/* x y))  ; no warning after type hinting
(mul 10.3 2)  ; returns 20</pre></div><p>While <code class="literal">primitive-math</code> is a<a class="indexterm" id="id204"/> useful library, the problem it solves is mostly taken care of by the boxing detection feature in Clojure 1.7 (see next section <span class="emphasis"><em>Detecting boxed math</em></span>). However, this library is still useful if you are unable to use Clojure 1.7 or higher.</p><div class="section" title="Detecting boxed math"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec11"/>Detecting boxed math</h3></div></div></div><p>
<span class="strong"><strong>Boxed math</strong></span> is <a class="indexterm" id="id205"/>hard to detect and is a source of performance issues. Clojure 1.7 introduces a way to warn the user when boxed math happens. This can be configured in the following way:</p><div class="informalexample"><pre class="programlisting">(set! *unchecked-math* :warn-on-boxed)

(defn sum-till [n] (/ (* n (inc n)) 2))  ; causes warning
Boxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:28 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:23 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:20 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,long).

;; now we define again with type hint
(defn sum-till [^long n] (/ (* n (inc n)) 2))</pre></div><p>When working with Leiningen, you can enable boxed math warnings by putting the following entry in the <code class="literal">project.clj</code> file:</p><div class="informalexample"><pre class="programlisting">:global-vars {*unchecked-math* :warn-on-boxed}</pre></div><p>The math operations in <code class="literal">primitive-math</code> (like HipHip) are implemented via macros. Therefore, they cannot be used as higher order functions and, as a consequence, may not compose well <a class="indexterm" id="id206"/>with other code. I recommend exploring the project to see what suits your program use case. Adopting Clojure 1.7 obviates the boxing discovery issues by means of a boxed-warning feature.</p></div></div></div>
<div class="section" title="Resorting to Java and native code"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Resorting to Java and native code</h1></div></div></div><p>In a handful of cases, where the <a class="indexterm" id="id207"/>lack of imperative, stack-based, mutable variables in <a class="indexterm" id="id208"/>Clojure may make the code not perform as well as Java, we may need to evaluate alternatives to make it faster. I would advise you to consider writing such code directly in Java for better performance.</p><p>Another consideration is to use native OS capabilities, such as <a class="indexterm" id="id209"/>memory-mapped buffers (<a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html</a>) or files and unsafe operations (<a class="ulink" href="http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/">http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/</a>). Note that unsafe operations are potentially hazardous and not recommended in general. Such times are also an opportunity to consider writing performance-critical pieces of code in C or C++ and then access them via the <a class="indexterm" id="id210"/>
<span class="strong"><strong>Java Native Interface</strong></span> (<span class="strong"><strong>JNI</strong></span>).</p><div class="section" title="Proteus – mutable locals in Clojure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Proteus – mutable locals in Clojure</h2></div></div></div><p>Proteus <a class="indexterm" id="id211"/>is an open source <a class="indexterm" id="id212"/>Clojure library that lets you treat a local as a local variable, thereby allowing its unsynchronized mutation within the local scope only. Note that this library depends on the internal implementation structure of Clojure as of Clojure 1.5.1. The <a class="indexterm" id="id213"/>
<span class="strong"><strong>Proteus</strong></span> project is available at <a class="ulink" href="https://github.com/ztellman/proteus">https://github.com/ztellman/proteus</a>.</p><p>You can include Proteus as a dependency in the Leiningen project by editing <code class="literal">project.clj</code>:</p><div class="informalexample"><pre class="programlisting">:dependencies [;;other dependencies
               [proteus "0.1.4"]]</pre></div><p>Using Proteus in code is straightforward, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">(require '[proteus :as p])
(p/let-mutable [a 10]
  (println a)
  (set! a 20)
  (println a))
;; Output below:
;; 10
;; 20</pre></div><p>Since Proteus allows mutation only in the local scope, the following throws an exception:</p><div class="informalexample"><pre class="programlisting">(p/let-mutable [a 10 add2! (fn [x] (set! x (+ 2 x)))]
  (add2! a)
  (println a))</pre></div><p>The mutable locals <a class="indexterm" id="id214"/>are very fast and may be quite useful in tight loops. Proteus is unconventional by Clojure idioms, but it may give the required performance boost without having to write Java code.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>Clojure has strong Java interoperability and underpinning, due to which programmers can leverage the performance benefits nearing those of Java. For performance-critical code, it is sometimes necessary to understand how Clojure interacts with Java and how to turn the right knobs. Numerics is a key area where Java interoperability is required to get optimum performance. Type hints are another important performance trick that is frequently useful. There are several open source Clojure libraries that make such activities easier for the programmer.</p><p>In the next chapter, we will dig deeper below Java and see how the hardware and the JVM stack play a key role in offering the performance we get, what their constraints are, and how to use their understanding to get better performance.</p></div></body></html>