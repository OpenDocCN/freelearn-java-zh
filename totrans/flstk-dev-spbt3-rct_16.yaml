- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding CRUD Functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes how we can implement **Create**, **Read**, **Update**,
    and **Delete** (**CRUD**) functionalities in our frontend. We are going to use
    the components that we learned about in *Chapter 11*, *Useful Third-Party Components
    for React*. We will fetch data from our backend and present the data in a table.
    Then, we will implement the delete, edit, and create functionalities. In the final
    part of this chapter, we will add features so that we can export our data to a
    CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the list page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the delete functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the add functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the edit functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting the data to CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot `cardatabase` application that we created in *Chapter 12*, *Setting
    Up the Frontend for Our Spring Boot RESTful Web Service*, (the unsecured backend)
    is required, as is the React app that we created in the same chapter, `carfront`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following GitHub link will also be required: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the list page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this first section, we will create the list page to show cars with paging,
    filtering, and sorting features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your unsecured Spring Boot backend. The cars can be fetched by sending
    the `GET` request to the `http://localhost:8080/api/cars` URL, as shown in *Chapter
    4*, *Creating a RESTful Web Service with Spring Boot*. Now, let’s inspect the
    JSON data from the response. The array of cars can be found in the `_embedded.cars`
    node of the JSON response data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Fetching cars'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `carfront` React app with Visual Studio Code (the React app we created
    in the previous chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using React Query for networking, so we have to initialize the query
    provider first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You learned the basics of React Query in *Chapter 10*, *Consuming the REST API
    with React*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QueryClientProvider` component is used to connect and provide `QueryClient`
    to your application. Open your `App.tsx` file and add the highlighted imports
    and components to your `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s fetch some cars.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data from the backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we know how to fetch cars from the backend, we will be ready to implement
    the list page to show the cars. The following steps describe this in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When your app has multiple components, it is recommended that you create a
    folder for them. Create a new folder called `components` in the `src` folder.
    With Visual Studio Code, you can create a folder by right-clicking the folder
    in the sidebar file explorer and selecting **New Folder...** from the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: New folder'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `Carlist.tsx` in the `components` folder. Your project
    structure should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Carlist.tsx` file in the editor view and write the base code of the
    component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when we are using TypeScript, we have to define the type for our car data.
    Let’s create a new file where we define our types. Create a file called `types.ts`
    in the `src` folder of your project. From the response, you can see that the car
    object looks like the following, and it contains all the car properties and also
    links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following `CarResponse` type in the `types.ts` file and export it
    so that we can use it in files where it is needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a function that fetches cars from our backend by sending
    a `GET` request to the `http://localhost:8080/api/cars` endpoint. The function
    returns a **promise** that contains an array of `CarResponse` objects that we
    defined in our `types.ts` file. We can use the `Promise<Type>` generic, where
    `Type` indicates the resolved value type of the promise. Open the `Carlist.tsx`
    file and add the following imports and function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will use the `useQuery` hook to fetch cars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `useQuery` hook uses TypeScript generics because it doesn’t fetch data
    and doesn’t know the type of your data. However, React Query can infer the type
    of the data, so we don’t have to do it manually here using generics. If you explicitly
    set generics, the code looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use **conditional rendering** to check if the fetch is successful and
    if there are any errors. If `isSuccess` is `false`, it means the data fetching
    is still in progress and, in this case, a loading message is returned. We also
    check if `error` is `true`, which indicates there’s an error, and an error message
    is returned. When data is available, we use the `map` function to transform car
    objects into table rows in the `return` statement and add the `table` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have to import and render the `Carlist` component in our `App.tsx`
    file. In the `App.tsx` file, add the `import` statement, and then render the `Carlist`
    component inside the `QueryClientProvider` component, as highlighted. `QueryClientProvider`
    is a component that provides the React Query context to your components, and it
    should wrap the components where you are making REST API requests from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you start the React app using the `npm run dev` command, you should
    see the following list page. Note that your backend should also be running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Car frontend'
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s do some code refactoring before we move on. The server URL can be repeated
    multiple times in the source code when we create more CRUD functionalities, and
    it will change when the backend is deployed to a server other than the local host;
    therefore, it is better to define it as an **environment variable**. Then, when
    the URL value changes, we only have to modify it in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Vite, environment variable names should start with the text `VITE_`.
    Only variables prefixed with `VITE_` are exposed to your source code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `.env` file in the root folder of our app. Open the file in the
    editor and add the following line to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also separate all API call functions into their own module. Create
    a new folder named `api` in the `src` folder of your project. Create a new file
    called `carapi.ts` in the `api` folder, and now your project structure should
    look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `getCars` function from the `Carlist.tsx` file to the `carapi.ts`
    file. Add `export` at the beginning of the function so that we can use it in other
    components. In Vite, the environment variables are exposed to your app source
    code via `import.meta.env` as strings. Then, we can import the server URL environment
    variable to our `getCars` function and use it there. We also need to import `axios`
    and the `CarResponse` type into the `carapi.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can remove the `getCars` function and unused `axios` import from the
    `Carlist.tsx` file and import it from the `carapi.ts` file. The source code should
    appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After these refactoring steps, you should see the car list page like previously.
  prefs: []
  type: TYPE_NORMAL
- en: Adding paging, filtering, and sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used the `ag-grid` component to implement a data grid in *Chapter
    11*, *Useful Third-Party Components for React*, and it could be used here as well.
    Instead, we will use the new MUI `DataGrid` component to get paging, filtering,
    and sorting features out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the development server by pressing *Ctrl* + *C* in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will install the MUI data grid community version. The following is the installation
    command at the time of writing, but you should check the latest installation command
    and usage from the MUI documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After installation, restart the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `DataGrid` component into your `Carlist.tsx` file. We will also
    import `GridColDef`, which is a type for the column definitions in the MUI data
    grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The grid columns are defined in the `columns` variable, which has the type
    `GridColDef[]`. The column `field` property defines where data in the columns
    is coming from; we are using our car object properties. The `headerName` prop
    can be used to set the title of the columns. We will also set the width of the
    columns. Add the following column definition code inside the `Carlist` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, remove the `table` and all its child elements from the component’s `return`
    statement and add the `DataGrid` component. Also remove the unused `CarResponse`
    import that we used in the `map` function. The data source of the data grid is
    the `data`, which contains fetched cars and is defined using the `rows` prop.
    The `DataGrid` component requires all rows to have a unique ID property that is
    defined using the `getRowId` prop. We can use the `link` field of the car object
    because that contains the unique car ID (`_links.self.href`). Refer to the source
    code of the following `return` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the MUI `DataGrid` component, we implemented all the necessary features
    for our table with only a small amount of coding. Now, the list page looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Car frontend'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data grid columns can be filtered using the column menu and clicking the **Filter**
    menu item. You can also set the visibility of the columns from the column menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Column menu'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will implement the delete functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the delete functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Items can be deleted from the database by sending the `DELETE` method request
    to the `http://localhost:8080/api/cars/{carId}` endpoint. If we look at the JSON
    response data, we can see that each car contains a link to itself, which can be
    accessed from the `_links.self.href` node, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Car link'
  prefs: []
  type: TYPE_NORMAL
- en: We already used the `link` field in the previous section to set a unique ID
    for every row in the grid. That row ID can be used in deletion, as we will see
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how to implement the delete functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a button for each row in the MUI `DataGrid`. When we need
    more complex cell content, we can use the `renderCell` column property to define
    how a cell’s contents are rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s add a new column to the table using `renderCell` to render the `button`
    element. The `params` argument that is passed to the function is a row object
    that contains all values from a row. The type of `params` is `GridCellParams`,
    which is provided by MUI. In our case, it contains a link to a car in each row,
    and that is needed in the deletion. The link is in the row’s `_links.self.href`
    property, and we will pass this value to a `delete` function. Let’s first show
    an alert with the ID when a button is pressed to test that the button is working
    properly. Refer to the following source code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don’t want to enable sorting and filtering for the `button` column, so the
    `filterable` and `sortable` props are set to `false`. We also disable the column
    menu in this column by setting the `disableColumnMenu` prop to `true`. The button
    invokes the `onDelClick` function when pressed and passes a link (`row.id`) to
    the function as an argument, and the link value is shown in an alert.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you should see a **delete** button in each row. If you press any of the
    buttons, you can see an alert that shows the link for the car. To delete a car,
    we should send a `DELETE` request to its link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Delete button'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will implement the `deleteCar` function, which sends the `DELETE`
    request to a car link using the Axios `delete` method. A `DELETE` request to the
    backend returns a deleted car object. We will implement the `deleteCar` function
    in the `carapi.ts` file and export it. Open the `carapi.ts` file and add the following
    function there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the React Query `useMutation` hook to handle deletion. We saw an example
    in *Chapter 10*. First, we have to add the `useMutation` import to the `Carlist.tsx`
    file. We will also import the `deleteCar` function from the `carapi.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `useMutation` hook, which calls our `deleteCar` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, call `mutate` in our delete button and pass the car link as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you start the app and press the **delete** button, the car is deleted
    from the database, but it still exists in the frontend. You can manually refresh
    the browser, after which the car disappears from the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also refresh the frontend automatically when a car is deleted. In React
    Query, the fetched data is saved to a cache that the query client handles. The
    `QueryClient` has a **query invalidation** feature that we can use to fetch data
    again. First, we have to import and call the `useQueryClient` hook function, which
    returns the current query client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `queryClient` has an `invalidateQueries` method that we can call to re-fetch
    our data after successful deletion. You can pass the key of the query that you
    want to re-fetch. Our query key for fetching cars is `cars`, which we defined
    in our `useQuery` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, every time a car is deleted, all the cars are fetched again. The car disappears
    from the list when the **Delete** button is pressed. After a deletion, you can
    restart the backend to re-populate the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see that when you click any row in the grid, the row is selected.
    You can disable that by setting the `disableRowSelectionOnClick` prop in the grid
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a toast message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be nice to show the user some feedback in the case of a successful
    deletion, or if there are any errors. Let’s implement a **toast message** to show
    the status of the deletion. For this, we are going to use the MUI `Snackbar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to import the `Snackbar` component by adding the following `import`
    statement to our `Carlist.tsx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Snackbar` component’s `open` prop value is a boolean, and if it is `true`,
    the component is shown; otherwise, it is hidden. Let’s import the `useState` hook
    and define a state called `open` to handle the visibility of our `Snackbar` component.
    The initial value is `false` because the message is shown only after the deletion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add the `Snackbar` component in the `return` statement after the MUI
    `DataGrid` component. The `autoHideDuration` prop defines the time in milliseconds
    after which the `onClose` function is called automatically and the message disappears.
    The `message` prop defines the message to display. We also have to wrap the `DataGrid`
    and `Snackbar` components inside the fragment (`<></>`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we set the `open` state to `true` after the successful deletion in
    our `useMutation` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you will see the toast message when the car is deleted, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_13_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: Toast message'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a confirmation dialog window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid accidental deletion of a car, it would be useful to have a confirmation
    dialog after the **Delete** button has been pressed. We will implement this using
    the `window` object’s `confirm` method. It opens a dialog with an optional message
    and returns `true` if you press the **OK** button. Add `confirm` to the delete
    button’s `onClick` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the confirmation message, we have used ES6 string interpolation to display
    the car’s brand and model. (Note! Remember to use backticks.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you press the **Delete** button now, the confirmation dialog will open and
    the car will only be deleted if you press the **OK** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_13_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: Confirmation dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will begin the implementation of the functionality to add a new car.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the add functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to add an add functionality to the frontend. We will implement
    this using the MUI modal dialog.
  prefs: []
  type: TYPE_NORMAL
- en: We went through the MUI modal form in *Chapter 11*, *Useful Third-Party Components
    for React*.
  prefs: []
  type: TYPE_NORMAL
- en: We will add the **New Car** button to the user interface, which opens the modal
    form when it is pressed. The modal form contains all the fields that are required
    to add a new car, as well as the buttons for saving and canceling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show you how to create the add functionality using the
    modal dialog component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `AddCar.tsx` in the `components` folder and write
    some functional component base code to the file, as shown here. Add the imports
    for the MUI `Dialog` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have already defined the type for our `Car` response data (a car object
    with links). Let’s also create a type for the car object that doesn’t contain
    links, because the user doesn’t enter links in the form. We need this for the
    state where we will save a new car. Add the following `Car` type to your `types.ts`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a state of type `Car` that contains all car fields using the `useState`
    hook. For the dialog, we also need a boolean state to define the visibility of
    the dialog form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add two functions to close and open the dialog form. The `handleClose`
    and `handleOpen` functions set the value of the `open` state, which affects the
    visibility of the modal form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Dialog` component inside the `AddCar` component’s `return` statement.
    The form contains the MUI `Dialog` component with buttons and the input fields
    that are required to collect the car data. The button that opens the modal window,
    which will be shown on the car list page, must be outside of the `Dialog` component.
    All input fields should have a `name` attribute with a value that is the same
    as the name of the state the value will be saved to. Input fields also have the
    `onChange` prop, which saves the value to the `car` state by invoking the `handleChange`
    function. The `handleChange` function dynamically updates the `car` state by creating
    a new object with the existing state properties and updating a property based
    on the input element’s name and the new value entered by the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `addCar` function in the `carapi.ts` file, which will send the
    `POST` request to the backend `api/cars` endpoint. We are using the Axios `post`
    method to send `POST` requests. The request will include the new car object inside
    the body and the `''Content-Type'':''application/json''` header. We also need
    to import the `Car` type because we are passing a new car object as an argument
    to the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we use the React Query `useMutation` hook, like we did in the delete
    functionality. We also invalidate the cars query after the car has been added
    successfully. The `addCar` function that we use in the `useMutation` hook is imported
    from the `carapi.ts` file. Add the following imports and the `useMutation` hook
    to your `AddCar.tsx` file. We also need to get the query client from the context
    using the `useQueryClient` hook. Remember that context is used to provide access
    to the query client to components deep in the component tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `AddCar` component into the `Carlist.tsx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `AddCar` component to the `Carlist.tsx` file’s `return` statement.
    You also have to import the `AddCar` component. Now, the `return` statement of
    the `Carlist.tsx` file should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you start the car shop app, it should now look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Car Shop'
  prefs: []
  type: TYPE_NORMAL
- en: If you press the **New Car** button, it should open the modal form.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save a new car, create a function called `handleSave` in the `AddCar.tsx`
    file. The `handleSave` function calls `mutate`. Then, we set the `car` state back
    to its initial state, and the modal form is closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have to change the `AddCar` component’s `onClick` save button to
    call the `handleSave` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can open the modal form by pressing the **New Car** button. You will
    see that there is placeholder text in each field when it is empty. You can fill
    out the form with data and press the **Save** button. At this point, the form
    doesn’t have a nice appearance, but we are going to style it in the next chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Add new car'
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving, the list page is refreshed, and the new car can be seen in the
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Car Shop'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can do some code refactoring. When we start to implement the edit functionality,
    we will actually need the same fields in the **Edit** form as in the **New Car**
    form. Let’s create a new component that renders the text fields in our **New Car**
    form. The idea is that we are splitting the text fields into their own component,
    which can then be used in both the **New Car** and **Edit** forms. Create a new
    file called `CarDialogContent.tsx` in the `components` folder. We have to pass
    the `car` object and the `handleChange` function to the component using `props`.
    To do that, we create a new type called `DialogFormProps`. We can define this
    type in the same file because we don’t need it in any other file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can move our `DialogContent` component from the `AddCar` component
    to the `CarDialogContent` component. Your code should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can import the `CarDialogContent` to the `AddCar` component and render
    it inside the `Dialog` component. Pass the `car` state and the `handleChange`
    function to the component using props. Also, remove the unused MUI `DialogContent`
    import from the `AddCar` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try to add a new car, and it should work like it did before the refactoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will begin to implement the edit functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the edit functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the edit functionality by adding the **Edit** button to each
    table row. When the row **Edit** button is pressed, it opens a modal form where
    the user can edit the existing car and save their changes. The idea is that we
    pass car data from the grid row to the edit form, and the form fields are populated
    when the form is opened:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file called `EditCar.tsx` in the `components` folder. We have
    to define a `FormProps` type for our props, and this can be defined inside our
    component because we don’t need this type anywhere else. The type of data that
    will be passed to the `EditCar` component is the `CarResponse` type. We will also
    create a state for car data like we did in the add functionality section. The
    code for the `EditCar.tsx` file looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create a dialog that will be opened when the **Edit** button is pressed.
    We need the `open` state to define if the dialog is visible or hidden. Add the
    functions that open and close the `Dialog` component and save updates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will import the `CarDialogContent` component and render it inside
    the `Dialog` component. We also need to add the `handleChange` function, which
    saves edited values to the `car` state. We pass in the `car` state and the `handleChange`
    function using the props, as we did earlier with the add functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will set the values of the `car` state using the props in the `handleClickOpen`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our form will be populated with the values from the car object that is passed
    to the component in props.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will add the edit functionality to our data grid in the `Carlist`
    component. Open the `Carlist.tsx` file and import the `EditCar` component. Create
    a new column that renders the `EditCar` component using the `renderCell` column
    property, as we did in the delete functionality section. We pass the row object
    to the `EditCar` component, and that object contains the car object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you should see the **Edit** button in each table row in your car list.
    When you press the **Edit** button, it should open the car form and populate fields
    using the car from the row where you pressed the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: Edit button'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have to implement the update request that sends an updated car to the
    backend. To update the car data, we have to send a `PUT` request to the `http://localhost:8080/api/cars/[carid]`
    URL. The link will be the same as it is for the delete functionality. The request
    contains the updated car object inside the body, and the `'Content-Type':'application/json'`
    header that we also set for the add functionality. For the update functionality,
    we need a new type. In React Query, the mutation function can only take one parameter,
    but in our case, we have to send the car object (`Car` type) and its link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can solve that by passing an object that contains both values. Open the
    `types.ts` file and create the following type, called `CarEntry`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, open the `carapi.ts` file, create the following function, and export
    it. The function gets the `CarEntry` type object as an argument and it has `car`
    and `url` properties, where we get the values that are needed in the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we import the `updateCar` function into the `EditCar` component and use
    the `useMutation` hook to send a request. We invalidate the cars query to re-fetch
    the list after a successful edit; therefore, we also have to get the query client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we call `mutate` in the `handleSave` function. As was already mentioned,
    `mutate` only accepts one parameter, and we have to pass the car object and URL;
    therefore, we create an object that contains both values and pass that one. We
    also need to import the `CarEntry` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, if you press the **Edit** button in the table, it opens the modal form
    and displays the car from that row. The updated values are saved to the database
    when you press the **Save** button:![](img/B19818_13_16.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.16: Edit car'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, if you press the **New Car** button, it will open an empty form and
    save the new car to the database when the form is filled and the **Save** button
    is pressed. We used one component to handle both use cases by using the component
    props.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also see what happens in the backend when you edit a car. If you look
    at the Eclipse console after a successful edit, you can see that there is an `update`
    SQL statement that updates the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: Update car statement'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have implemented all the CRUD functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the data to CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One feature that we will also implement is a **comma-separated values** (**CSV**)
    export of the data. We don’t need any extra libraries for the export because the
    MUI data grid provides this feature. We will activate the data grid toolbar, which
    contains a lot of nice features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following import to the `Carlist.tsx` file. The `GridToolbar` component
    is a toolbar for the MUI data grid that contains nice functionalities, such as
    export:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to enable our toolbar, which contains the **Export** button and other
    buttons. To enable the toolbar in the MUI data grid, you have to use the `slots`
    prop and set the value to `toolbar: GridToolbar`. The `slots` prop can be used
    to override the data grid’s internal components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you will see the **EXPORT** button in the grid. If you press the button
    and select **Download as CSV**, the grid data is exported to a CSV file. You can
    **Print** your grid using the **EXPORT** button, and you will get a printer-friendly
    version of your page (you can also hide and filter columns and set row density
    using the toolbar):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_13_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: Export CSV'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the page title and icon by editing the `index.html` page, as
    shown in the following code. The icon can be found in your project’s `public`
    folder, and you can use your own icon instead of Vite’s default one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, all the functionalities have been implemented. In *Chapter 14*, *Styling
    the Frontend with React MUI*, we will focus on styling the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented all the functionalities for our app. We started
    with fetching the cars from the backend and showing these in the MUI `DataGrid`,
    which provides paging, sorting, and filtering features. Then, we implemented the
    delete functionality and used the `SnackBar` component to give feedback to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: The add and edit functionalities were implemented using the MUI modal `dialog`
    component. Finally, we implemented the ability to export data to a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to style the rest of our frontend using the
    React Material UI component library.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you fetch and present data using the REST API with React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you delete data using the REST API with React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you show toast messages with React and MUI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you add data using the REST API with React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you update data using the REST API with React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you export data to a CSV file with React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are other good resources available for learning about React and React
    Query. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Practical React Query – TkDoDo’s blog*, by Dominik Dorfmeister ([https://tkdodo.eu/blog/practical-react-query](https://tkdodo.eu/blog/practical-react-query))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Material Design Blog*, by Google ([https://material.io/blog/](https://material.io/blog/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10796108009382640.png)'
  prefs: []
  type: TYPE_IMG
