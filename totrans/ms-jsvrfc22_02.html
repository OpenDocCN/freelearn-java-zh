<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Communication in JSF"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Communication in JSF</h1></div></div></div><p>Communication is the core of a JSF application, and is one of the main aspects that dictate the architecture of such an application. Thinking of the big picture, you need to identify—right from the start—the main parts and how they will communicate with one another and with the end user. After selecting design patterns, drawing the UML diagrams, and sketching the architecture and the application flow, it's time to get to work and start implementing the communication pipes using forms, parameters, arguments, values, pages, beans, and so on.</p><p>Fortunately, JSF provides many solutions for ensuring a powerful and flexible communication layer between JSF components and also between JSF and XHTML pages, the JavaScript code, and other third-party components. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using context parameters</li><li class="listitem" style="list-style-type: disc">Passing request parameters with the <code class="literal">&lt;f:param&gt;</code> tag</li><li class="listitem" style="list-style-type: disc">Working with view parameters</li><li class="listitem" style="list-style-type: disc">Calling actions on GET requests</li><li class="listitem" style="list-style-type: disc">Passing attributes with the <code class="literal">&lt;f:attribute&gt;</code> tag</li><li class="listitem" style="list-style-type: disc">Setting property values via action listeners</li><li class="listitem" style="list-style-type: disc">Passing parameters using the Flash scope</li><li class="listitem" style="list-style-type: disc">Replacing the <code class="literal">&lt;f:param&gt;</code> tag with the JSTL <code class="literal">&lt;c:set&gt;</code> tag</li><li class="listitem" style="list-style-type: disc">Sending data through cookies</li><li class="listitem" style="list-style-type: disc">Working with hidden fields</li><li class="listitem" style="list-style-type: disc">Sending passwords</li><li class="listitem" style="list-style-type: disc">Accessing UI component attributes programmatically</li><li class="listitem" style="list-style-type: disc">Passing parameters via method expressions</li><li class="listitem" style="list-style-type: disc">Communicating via the <code class="literal">binding</code> attribute</li></ul></div><div class="section" title="Passing and getting parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Passing and getting parameters</h1></div></div></div><p>As you will see in the next sections, JSF provides several approaches to pass/get parameters to/from Facelets, managed beans, UI components, and so on.</p><div class="section" title="Using context parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Using context parameters</h2></div></div></div><p>Context parameters are defined in the <code class="literal">web.xml</code> file using the <code class="literal">&lt;context-param&gt;</code> tag. This tag allows two important children: <code class="literal">&lt;param-name&gt;</code>, which indicates the parameter name, and <code class="literal">&lt;param-value&gt;</code>, which<a id="id158" class="indexterm"/> indicates the parameter value. For example, a user-defined context parameter<a id="id159" class="indexterm"/> looks like the following code:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;number.one.in.ATP&lt;/param-name&gt;
  &lt;param-value&gt;Rafael Nadal&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Now, in a JSF page, you can access this parameter as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText value="#{initParam['number.one.in.ATP']}"/&gt;
&lt;h:outputText value="#{facesContext.externalContext.initParameterMap['number.one.in.ATP']}"/&gt;</pre></div><p>In a managed bean, the same context<a id="id160" class="indexterm"/> parameter can be accessed via the <code class="literal">getInitParameter</code> method:</p><div class="informalexample"><pre class="programlisting">facesContext.getExternalContext().getInitParameter("number.one.in.ATP");</pre></div><p>The complete application is named <code class="literal">ch2_27</code>.</p></div><div class="section" title="Passing request parameters with the &lt;f:param&gt; tag"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Passing request parameters with the &lt;f:param&gt; tag</h2></div></div></div><p>Sometimes, you need to pass parameters from a Facelet to a managed bean or to another Facelet. In this case, you may need the <code class="literal">&lt;f:param&gt;</code> tag, which can be used to add query string name-value pairs<a id="id161" class="indexterm"/> to a request, or put simply, to send request parameters. Commonly, the <code class="literal">&lt;f:param&gt;</code> tag is used inside the <code class="literal">&lt;h:commandButton&gt;</code> and <code class="literal">&lt;h:commandLink&gt;</code> tags for sending request parameters to a managed bean. For example, the following snippet of code adds two parameters to<a id="id162" class="indexterm"/> the request when the form is submitted. These parameters are accessed in the <code class="literal">PlayersBean</code> bean; the first parameter is named <code class="literal">playerNameParam</code> and the second one is named <code class="literal">playerSurnameParam</code>.</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  Click to send name, 'Rafael' surname, 'Nadal', with f:param:
  &lt;h:commandButton value="Send Rafael Nadal"  action="#{playersBean.parametersAction()}"&gt;
  &lt;f:param id="playerName" name="playerNameParam" value="Rafael"/&gt;
  &lt;f:param id="playerSurname" name="playerSurnameParam" value="Nadal"/&gt;
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p>As you can see, when the button is clicked, the request parameters are sent and the <code class="literal">parametersAction</code> method is called (via <code class="literal">action</code> or <code class="literal">actionListener</code>). When the application flow reaches this method, the two request parameters are already available for use. You can easily extract them inside this method by accessing the request parameters map through the current <code class="literal">FacesContext</code> instance as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private String playerName;
private String playerSurname;
...
//getter and setter
...

public String parametersAction() {

  FacesContext fc = FacesContext.getCurrentInstance();
  Map&lt;String, String&gt; params = fc.getExternalContext().getRequestParameterMap();
  playerName = params.get("playerNameParam");
  playerSurname = params.get("playerSurnameParam");
       
  return "some_page";
}</pre></div><p>The values of both<a id="id163" class="indexterm"/> the parameters<a id="id164" class="indexterm"/> are stored in the <code class="literal">playerName</code> and <code class="literal">playerSurname</code> managed beans' properties (these can be modified further without affecting the original parameters), but you can easily display the parameters' values using the <code class="literal">param</code> EL reserved word in <span class="emphasis"><em>some_page</em></span> (remember the <span class="emphasis"><em>EL implicit objects</em></span> section of <a class="link" href="ch01.html" title="Chapter 1. Dynamic Access to JSF Application Data through Expression Language (EL 3.0)">Chapter 1</a>, <span class="emphasis"><em>Dynamic Access to JSF Application Data through Expression Language (EL 3.0)</em></span>, which explains that <code class="literal">param</code> is a predefined variable referring to the request parameter map):</p><div class="informalexample"><pre class="programlisting">Name: #{param.playerNameParam} 
Surname: #{param.playerSurnameParam}</pre></div><p>The <code class="literal">&lt;f:param&gt;</code> tag can also be used inside the <code class="literal">&lt;h:outputFormat&gt;</code> tag to substitute message parameters; <code class="literal">&lt;f:param&gt;</code> is used to pass parameters to a UI component as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputFormat value="Name: {0} Surname: {1}"&gt;
  &lt;f:param value="#{playersBean.playerName}" /&gt;
  &lt;f:param value="#{playersBean.playerSurname}" /&gt; 
&lt;/h:outputFormat&gt;</pre></div><p>The preceding code's output is as follows:</p><p><span class="strong"><strong>Name: Rafael Surname: Nadal</strong></span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>If you want to execute some initialization tasks (or something else) after setting the managed bean properties but before an action method is called (if it exists), then you can define a public void method annotated with <code class="literal">@PostConstruct</code>. In this example, the <code class="literal">init</code> method will be called before the <code class="literal">parametersAction</code> method, and the passed request parameters are available through the request map.</p></div></div><p>The <code class="literal">init</code> method is shown in the following code:</p><div class="informalexample"><pre class="programlisting">@PostConstruct
public void init(){
  //do something with playerNameParam and playerSurnameParam
}</pre></div><p>This example is wrapped into the application named <code class="literal">ch2_1</code>.</p><p>If you think that it is not a very convenient approach to access the request map in the managed bean, then you can use <code class="literal">@ManagedProperty</code>, which sets the parameter as a managed bean property and links its value to the request parameter:</p><div class="informalexample"><pre class="programlisting">@ManagedProperty(value = "#{param.playerNameParam}")
private String playerName;
@ManagedProperty(value = "#{param.playerSurnameParam}")
private String playerSurname;</pre></div><p>The values are set immediately after the bean's construction <a id="id165" class="indexterm"/>and are available during <code class="literal">@PostConstruct</code>, but keep in mind that <code class="literal">@ManagedProperty</code> is usable only<a id="id166" class="indexterm"/> with beans managed by JSF (<code class="literal">@ManagedBean</code>), not with beans managed by CDI (<code class="literal">@Named</code>).</p><p>This example is wrapped into the application named <code class="literal">ch2_2</code> which is available in the code bundle of this chapter. You may also be interested in the application <code class="literal">ch2_3</code>, which is another example of using <code class="literal">&lt;f:param&gt;</code>, <code class="literal">@ManagedProperty</code>, and <code class="literal">@PostConstruct</code>. In this example, the <code class="literal">&lt;h:commandButton&gt;</code> action indicates another JSF page instead of a managed bean method.</p><p>The <code class="literal">&lt;f:param&gt;</code> tag can be used to pass request parameters directly between Facelets, without involving a managed bean. Usually, this happens in the <code class="literal">&lt;h:link&gt;</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:link value="Send Rafael Nadal" outcome="result"&gt;
  &lt;f:param id="playerName" name="playerNameParam" value="Rafael"/&gt;
  &lt;f:param id="playerSurname" name="playerSurnameParam" value="Nadal"/&gt;               
&lt;/h:link&gt;</pre></div><p>When the <span class="strong"><strong>Send Rafael Nadal</strong></span> link is clicked, JSF will use the prepared URL containing the <code class="literal">result.xhtml</code> file's resource name and the request parameters, <code class="literal">playerNameParam</code> and <code class="literal">playerSurnameParam</code>. Both the parameters are displayed in the <code class="literal">result.xhtml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">Name: #{param.playerNameParam} 
Surname: #{param.playerSurnameParam}</pre></div><p>If you check the URL generated by the <code class="literal">&lt;h:link&gt;</code> tag in the browser address bar, then you will see something like the following URL:</p><p><code class="literal">http://</code><span class="emphasis"><em>hostname</em></span><code class="literal">/ch2_4/faces/result.xhtml?playerNameParam=Rafael&amp;playerSurnameParam=Nadal</code></p><p>This example is wrapped into the application named <code class="literal">ch2_4</code>. In that application, you can also see an example using the <code class="literal">&lt;h:commandButton&gt;</code> tag. Notice that, in this case, we need to wrap the <code class="literal">&lt;h:commandButton&gt;</code> tag in a <code class="literal">&lt;h:form&gt;</code> tag, which is submitted using the POST request; therefore, the request parameters<a id="id167" class="indexterm"/> are not visible<a id="id168" class="indexterm"/> in the URL anymore.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The <code class="literal">&lt;f:param&gt;</code> tag cannot be fortified with declarative/imperative validations and/or conversions. You need to accomplish this task by yourself.</p><p>Do not try to place the <code class="literal">&lt;f:param&gt;</code> tag inside the <code class="literal">&lt;h:inputText&gt;</code> tag or any other input component. That will simply not work.</p></div></div></div><div class="section" title="Working with view parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Working with view parameters</h2></div></div></div><p>Starting with JSF 2.0, we can use a new category <a id="id169" class="indexterm"/>of parameters, known as <span class="strong"><strong>view parameters</strong></span>. These kinds of parameters are implemented by the <code class="literal">UIViewParameter</code> class (that extends the <code class="literal">UIInput</code> class) and are defined in Facelets using the <code class="literal">&lt;f:viewParam&gt;</code> tag. Through this tag, we can declaratively register the <code class="literal">UIViewParameter</code> class as<a id="id170" class="indexterm"/> metadata for the parent view; this is why the <code class="literal">&lt;f:viewParam&gt;</code> tag is nested in the <code class="literal">&lt;f:metadata&gt;</code> tag.</p><p>Starting with JSF 2.0, the metadata concept was materialized in a section of a view, which provides the following two main advantages (the section is demarcated by the <code class="literal">&lt;f:metadata&gt;</code> tag):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The content of this section is readable without having the entire view available</li><li class="listitem" style="list-style-type: disc">At the initial request, components from this section can accomplish different things before the view is rendered</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Starting with JSF 2.2, the metadata section (and subsequent components) is detected via a public static method, named the <code class="literal">hasMetadata</code> (<code class="literal">UIViewRoot</code>) method. This method was added in <code class="literal">javax.faces.view.ViewMetadata</code> and returns <code class="literal">true</code> if there is a metadata section and <code class="literal">false</code> otherwise. Among other benefits, the main advantage of using the <code class="literal">&lt;f:viewParam&gt;</code> tag is the URL bookmarking support.</p></div></div><p>For better understanding, let's<a id="id171" class="indexterm"/> look at a simple example of using the <code class="literal">&lt;f:viewParam&gt;</code> tag. The following pieces of code are from the same page, <code class="literal">index.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;
  &lt;f:viewParam name="playersurnameparam"  value="#{playersBean.playerSurname}"/&gt; 
&lt;/f:metadata&gt;
...
&lt;h:body&gt;
  You requested name: &lt;h:outputText value="#{playersBean.playerName}"/&gt;&lt;br/&gt;
  You requested surname: &lt;h:outputText value="#{playersBean.playerSurname}"/&gt;
&lt;/h:body&gt;</pre></div><p>Now, let's see what is happening at the initial request. First, let's focus on the first block of code: here, JSF gets the request parameter's values by their names (<code class="literal">playernameparam</code> and <code class="literal">playersurnameparam</code>) from the page URL and applies the specified converter/validators (these are optional). After conversion/validation succeeds, before the view is rendered, JSF binds the values of the <code class="literal">playernameparam</code> and <code class="literal">playersurnameparam</code> request parameters to the managed bean properties, <code class="literal">playerName</code> and <code class="literal">playerSurname</code>, by calling the <code class="literal">setPlayerName</code> and <code class="literal">setPlayerSurname</code> methods (called only if we provide<a id="id172" class="indexterm"/> request parameters in the URL). If the <code class="literal">value</code> attribute is missing, then JSF sets request parameters as request attributes on names, <code class="literal">playernameparam</code> and <code class="literal">playersurnameparam</code>, available via <code class="literal">#{playernameparam}</code> and <code class="literal">#{playersurnameparam}</code>.</p><p>The page's initial URL should be something like the following one:</p><p><code class="literal">http://</code><span class="emphasis"><em>hostname</em></span><code class="literal">/ch2_5/?playernameparam=Rafael&amp;playersurnameparam=Nadal</code></p><p>In the second block of code, the values of the managed bean properties, <code class="literal">playerName</code> and <code class="literal">playerSurname</code>, are displayed (the <code class="literal">getPlayerName</code> and <code class="literal">getPlayerSurname</code> methods are called); they should reflect the values of the request parameters.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Since the <code class="literal">UIViewParameter</code> class extends the <code class="literal">UIInput</code> class, the managed bean properties are set during the <span class="strong"><strong>Update Model</strong></span> phase<a id="id173" class="indexterm"/> only.</p></div></div><p>This example is wrapped into the application named <code class="literal">ch2_5</code>.</p><p>View parameters can be included in links (the GET query string) by using the <code class="literal">includeViewParams="true"</code> attribute in the <code class="literal">&lt;h:link&gt;</code> tag, or the <code class="literal">includeViewParams=true</code> request parameter in any URL. Both these cases can be seen in the upcoming examples.</p><p>In the <code class="literal">index.xhtml</code> file, you can <a id="id174" class="indexterm"/>have something like the following code, in which view parameters are included through the request parameter:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;
  &lt;f:viewParam name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt; 
&lt;/f:metadata&gt;
...
&lt;h:body&gt;        
  &lt;h:form&gt;
    Enter name:&lt;h:inputText value="#{playersBean.playerName}"/&gt;
    Enter name:&lt;h:inputText value="#{playersBean.playerSurname}"/&gt;
  &lt;h:commandButton value="Submit" action="results?faces-redirect=true&amp;amp;includeViewParams=true"/&gt;
  &lt;/h:form&gt;               
&lt;/h:body&gt;</pre></div><p>The initial URL can be:</p><p><code class="literal">http://</code><span class="emphasis"><em>hostname</em></span><code class="literal">/ch2_6/?playernameparam=Rafael&amp;playersurnameparam=Nadal</code></p><p>The view parameters, <code class="literal">playernameparam</code> and <code class="literal">playersurnameparam</code>, will be extracted from this URL and bound to the managed bean properties, <code class="literal">playerName</code> and <code class="literal">playerSurname</code>. Optionally, both properties can be further altered by the user through two <code class="literal">&lt;h:inputText&gt;</code> tags, or<a id="id175" class="indexterm"/> other UI components. (If the initial URL does not contain the view parameters, then the <code class="literal">&lt;h:inputText&gt;</code> generated fields will be empty.) The button rendered through the <code class="literal">&lt;h:commandButton&gt;</code> tag will redirect the flow to the <code class="literal">results.xhtml</code> page and will include the view parameters in the new URL. The values of the view parameters will reflect the values of the corresponding managed bean properties, since the form is submitted before the following URL is composed:</p><p><code class="literal">http://</code><span class="emphasis"><em>hostname</em></span><code class="literal">/ch2_6/faces/results.xhtml?playernameparam=Rafael&amp;playersurnameparam=Nadal</code></p><p>The <code class="literal">results.xhtml</code> file (or any other page that the <code class="literal">index.xhtml</code> file directs) will use the <code class="literal">&lt;f:viewParam&gt;</code> tag to take parameters<a id="id176" class="indexterm"/> from the GET request into bound properties, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;
  &lt;f:viewParam name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt; 
&lt;/f:metadata&gt;
...
&lt;h:body&gt;        
  You requested name: &lt;h:outputTextvalue="#{playersBean.playerName}"/&gt;&lt;br/&gt;
  You requested surname: &lt;h:outputText value="#{playersBean.playerSurname}"/&gt;       
&lt;/h:body&gt;</pre></div><p>If you prefer to use a <code class="literal">&lt;h:link&gt;</code> tag in conjunction with the <code class="literal">includeViewParams</code> attribute set to <code class="literal">true</code>, then the <code class="literal">index.xhtml</code> file will be as<a id="id177" class="indexterm"/> follows (in this case, there is no form submission and no POST request):</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;            
 &lt;f:viewParam name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt; 
&lt;/f:metadata&gt;
...
&lt;h:body&gt;        
  &lt;h:link value="Send"outcome="results?faces-redirect=true" includeViewParams="true"/&gt;
&lt;/h:body&gt;</pre></div><p>These examples are wrapped into the application named <code class="literal">ch2_6</code>.</p><p>You can use the <code class="literal">includeViewParams</code> request parameter in any URL, which means that you can use it in managed beans to include view parameters in the navigation links as follows:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;            
  &lt;f:viewParam name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt; 
&lt;/f:metadata&gt;
...
&lt;h:body&gt;
  &lt;h:form&gt;
    Enter name:&lt;h:inputText value="#{playersBean.playerName}"/&gt;
    Enter name:&lt;h:inputText value="#{playersBean.playerSurname}"/&gt;
    &lt;h:commandButton value="Submit" action="#{playersBean.toUpperCase()}"/&gt;
  &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>And the action method is as follows:</p><div class="informalexample"><pre class="programlisting">public String toUpperCase(){
  playerName=playerName.toUpperCase();
  playerSurname=playerSurname.toUpperCase();
        
  return "results?faces-redirect=true&amp;includeViewParams=true";
}</pre></div><p>The complete application is named <code class="literal">ch2_7</code> and is available in the code bundle of this chapter on the Packt Publishing website.</p><p>As you know from the previous code, the <code class="literal">UIViewParameter</code> class extends the <code class="literal">UIInput</code> class, which means that it<a id="id178" class="indexterm"/> inherits all attributes, such as <code class="literal">required</code> and <code class="literal">requiredMessage</code>. When the URL must contain view parameters, you can use these two attributes to ensure that the application flow is controlled and the user is correctly informed. The following is the example code:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" required="true" requiredMessage="Player name required!" value="#{playersBean.playerName}"/&gt;            
  &lt;f:viewParam name="playersurnameparam" required="true" requiredMessage="Player surname required!" value="#{playersBean.playerSurname}"/&gt; 
&lt;/f:metadata&gt;</pre></div><p>If the initial URL does not contain the view parameters (one or both), then you will receive a message that report this fact. This example is wrapped into the application named <code class="literal">ch2_9</code>.</p><p>Moreover, view parameters support fine-grained conversion and validation. You can use <code class="literal">&lt;f:validator&gt;</code> and <code class="literal">&lt;f:converter&gt;</code>, or the <code class="literal">validator</code> and <code class="literal">converter</code> attributes inherited from the <code class="literal">UIInput</code> class. Supposing that you have a custom validator, named <code class="literal">PlayerValidator</code> (its implementation is not really relevant), the following is its code:</p><div class="informalexample"><pre class="programlisting">@FacesValidator("playerValidator")
public class PlayerValidator implements Validator {

  @Override
  public void validate(FacesContext context, UIComponent component, 
  Object value) throws ValidatorException {
    //validation conditions
   ...</pre></div><p>Then, you can attach it to a view parameter as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam id="nameId" name="playernameparam"  validator="playerValidator" value="#{playersBean.playerName}"/&gt;            
  &lt;f:viewParam id="surnameId" name="playersurnameparam" validator="playerValidator"value="#{playersBean.playerSurname}"/&gt;         
&lt;/f:metadata&gt;  </pre></div><p>The preceding snippet of code accomplishes the following tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Gets the request parameters' values by their names, <code class="literal">playernameparam</code> and <code class="literal">playersurnameparam</code></li><li class="listitem" style="list-style-type: disc">Converts and validates (in this case, validates) parameters</li><li class="listitem" style="list-style-type: disc">If conversions and validations end successfully, then the parameters are set in managed bean properties</li><li class="listitem" style="list-style-type: disc">Any validation failure will result in a message being displayed</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>For the customize messages style, you can attach a <code class="literal">&lt;h:message&gt;</code> tag to the <code class="literal">&lt;f:viewParam&gt;</code> tag.</p></div></div><p>This example is<a id="id179" class="indexterm"/> wrapped into the application named <code class="literal">ch2_10</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>If you want to preserve the view parameters over validation failures, then you need to use a broader scope than <code class="literal">@RequestScoped</code>, such as <code class="literal">@ViewScoped</code>, or to manually preserve the request parameters for the subsequent requests through the <code class="literal">&lt;f:param&gt;</code> tag in the command components.</p></div></div><p>Sometimes, you may need a converter for a view parameter. For example, if you try to pass a <code class="literal">java.util.Date</code> parameter as a view parameter from a managed bean, you will probably will code it as follows:</p><div class="informalexample"><pre class="programlisting">private Date date = new Date();
...  
public String sendDate() {
  String dateAsString = new SimpleDateFormat("dd-MM-yyyy").format(date);
  return "date.xhtml?faces-redirect=true&amp;date=" + dateAsString;
}</pre></div><p>Now, in the <code class="literal">date.xhtml</code> file, you need to convert the view parameter from string to <code class="literal">date</code>, and for this, you may use the <code class="literal">&lt;f:convertDateTime&gt;</code> converter,<a id="id180" class="indexterm"/> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;f:viewParam name="date" value="#{dateBean.date}"&gt;
  &lt;f:convertDateTime pattern="dd-MM-yyyy" /&gt;
&lt;/f:viewParam&gt;</pre></div><p>Of course, a custom converter can also be used. The complete application is named <code class="literal">ch2_29</code>.</p><p>Among so many advantages of using the <code class="literal">&lt;f:viewParam&gt;</code> tag, we have a gap. When view parameters are set in managed bean properties, the set values are not available in <code class="literal">@PostConstruct</code>; therefore, you cannot perform initialization or preload tasks directly. You can quickly<a id="id181" class="indexterm"/> fix this by attaching the <code class="literal">preRenderView</code> event listener, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;            
  &lt;f:viewParam name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt; 
<span class="strong"><strong>  &lt;f:event type="preRenderView" listener="#{playersBean.init()}"/&gt;</strong></span>
&lt;/f:metadata&gt;</pre></div><p>The <code class="literal">init</code> method is shown as follows:</p><div class="informalexample"><pre class="programlisting">public void init() {        
  // do something with playerName and playerSurname 
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>The set values are not available in <code class="literal">@PostConstruct</code> when using the <code class="literal">&lt;f:viewParam&gt;</code> tag. You can fix this by attaching the <code class="literal">preRenderView</code> event listener, or, as you will see next, the <code class="literal">&lt;f:viewAction&gt;</code> tag.</p></div></div><p>This example is wrapped into the application named <code class="literal">ch2_8</code>.</p><p>Well, there is one more aspect that I'd like to discuss here. The <code class="literal">UIViewParameter</code> class (<code class="literal">&lt;f:viewParam&gt;</code>) is a stateful component that stores its value in state. This is very nice as the value is available over postbacks, even if it doesn't come from the page URL anymore or the managed bean is request scoped. So, you need to indicate view parameters only once, and not for every request. But, there are a few drawbacks of this behavior—the most significant being calling the setter method at each postback (you don't want this in view beans). Another one is calling, for each postback, the method indicated through the <code class="literal">preRenderView</code> event handler; this can be fixed using a test as shown in the following code. The complete application is named <code class="literal">ch2_28</code>.</p><div class="informalexample"><pre class="programlisting">public void init() {        
  if (!FacesContext.getCurrentInstance().isPostback()) {
    // do something with playerName and playerSurname 
  }
}</pre></div><p>Maybe the most painful drawback is converting and validating view parameters at each postback. Obviously, this is not the behavior you are expecting to see. In order to call a converter/validator only when the page URL contains the request parameters, you need to alter the <code class="literal">UIViewParameter</code> class implementation by writing a custom implementation. You can try to write a stateless <code class="literal">UIViewParameter</code> class or to control the conversion/validation calls. Of course, you have to keep in mind that altering the default implementation may lead to more or less unpredictable drawbacks. As an alternative, you can use the <code class="literal">&lt;o:viewParam&gt;</code> tag from OmniFaces, which fixes these issues. A relevant example can be seen at <a class="ulink" href="http://showcase.omnifaces.org/components/viewParam">http://showcase.omnifaces.org/components/viewParam</a>.</p><p>So, as a final conclusion<a id="id182" class="indexterm"/> of this section, the <code class="literal">&lt;f:viewParam&gt;</code> tag is used to capture the request parameters. Moreover, it can be used with the <code class="literal">&lt;h:link&gt;</code> and <code class="literal">&lt;h:button&gt;</code> tags to send outgoing request parameters, or in non-JSF forms, to send data to JSF pages that use the <code class="literal">&lt;f:viewParam&gt;</code> tag, or to make JSF results pages bookmarkable in a POST-redirect-GET flow. On the other hand, the <code class="literal">&lt;f:viewParam&gt;</code> tag doesn't sustain the <code class="literal">&lt;h:form&gt;</code> tag to use GET or provide access to random JSF pages via the GET request.</p></div><div class="section" title="Calling actions on GET requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Calling actions on GET requests</h2></div></div></div><p>Starting with JSF 2.2, we can<a id="id183" class="indexterm"/> deal with calling actions on GET requests by using the new<a id="id184" class="indexterm"/> generic <span class="strong"><strong>view action</strong></span> feature (well-known in Seam 2 and 3). This new feature is materialized in the <code class="literal">&lt;f:viewAction&gt;</code> tag, which is declared as a<a id="id185" class="indexterm"/> child of the metadata facet, <code class="literal">&lt;f:metadata&gt;</code>. This allows the view action to<a id="id186" class="indexterm"/> be part of the JSF life cycle for faces/non-faces requests.</p><p>In the preceding section, we saw how to attach a custom validator to a <code class="literal">&lt;f:viewParam&gt;</code> tag for validating view parameters. The same thing can be accomplished using the <code class="literal">&lt;f:viewAction&gt;</code> tag, when the validation method is declared in the managed bean instead of being a separate implementation of the <code class="literal">Validator</code> interface. For example, in the <code class="literal">index.xhtml</code> file, you may have the following code:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam id="nameId" name="playernameparam" value="#{playersBean.playerName}"/&gt;            
  &lt;f:viewParam id="surnameId" name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt;   
<span class="strong"><strong>  &lt;f:viewAction action="#{playersBean.validateData()}"/&gt;</strong></span>
&lt;/f:metadata&gt;</pre></div><p>As you can see, the <a id="id187" class="indexterm"/>following <code class="literal">validateData</code> method is just a common method declared in <code class="literal">PlayersBean</code>:</p><div class="informalexample"><pre class="programlisting">public String validateData() {
  //validation conditions
  return "index"; //or other page
}</pre></div><p>This example is <a id="id188" class="indexterm"/>wrapped into the application named <code class="literal">ch2_11</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>The <code class="literal">&lt;f:viewAction&gt;</code> tag and the <code class="literal">preRenderView</code> event listener are not the same!</p></div></div><p>The preceding note underlines our next discussion. You may think that they are the same because in the preceding<a id="id189" class="indexterm"/> example, you can replace <code class="literal">&lt;f:viewAction&gt;</code> with <code class="literal">preRenderView</code> and obtain the same effect (result). Well, it is true that they are partially<a id="id190" class="indexterm"/> the same, but a few existing differences are important, as you can see in the following four bullets:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By default, the <code class="literal">preRenderView</code> event listener is executed on postback requests, while the view action is not. In the case of the <code class="literal">preRenderView</code> event listener, you need to<a id="id191" class="indexterm"/> overcome this by testing the request type as follows:<div class="informalexample"><pre class="programlisting">if (!FacesContext.getCurrentInstance().isPostback()) {
  // code that should not be executed in postback phase
}</pre></div><p>For example, the following code will try to apply some modifications over the set values using the <code class="literal">preRenderView</code> event listener:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;
  &lt;f:viewParam name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt; 
  &lt;f:event type="preRenderView" listener="#{playersBean.init()}"/&gt;
&lt;/f:metadata&gt;</pre></div><p>The <code class="literal">init</code> method is declared in <code class="literal">PlayersBean</code> and it just turns the set values to uppercase, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void init() {
  if (playerName != null) {
    playerName = playerName.toUpperCase();
  }
  if (playerSurname != null) {
    playerSurname = playerSurname.toUpperCase();
  }
}</pre></div><p>Next, when the<a id="id192" class="indexterm"/> JSF page is rendered, the set values are used in uppercase, and<a id="id193" class="indexterm"/> further requests can be accomplished (for example, you may want to call the method <code class="literal">#{playersBean.userAction()}</code> when a certain button is clicked). But, each<a id="id194" class="indexterm"/> further request will call the <code class="literal">init</code> method again (after the <code class="literal">userAction</code> method), because the <code class="literal">preRenderView</code> event listener is executed at postback time. Except for the case<a id="id195" class="indexterm"/> when this is the desired<a id="id196" class="indexterm"/> functionality, you need to programmatically test the postbacks to prevent the following <code class="literal">init</code> method code from being executed:</p><div class="informalexample"><pre class="programlisting">public void init() {
  if (!FacesContext.getCurrentInstance().isPostback()) {
    if (playerName != null) {
      playerName = playerName.toUpperCase();
    }
    if (playerSurname != null) {
      playerSurname = playerSurname.toUpperCase();
    }
   }
}</pre></div><p>Well, this is not the same in the case of the <code class="literal">&lt;f:viewAction&gt;</code> tag. Replace the <code class="literal">preRenderView</code> event listener with the <code class="literal">&lt;f:viewAction&gt;</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;f:metadata&gt;
  &lt;f:viewParam name="playernameparam" value="#{playersBean.playerName}"/&gt;
  &lt;f:viewParam name="playersurnameparam" value="#{playersBean.playerSurname}"/&gt; 
  &lt;f:viewAction action="#{playersBean.init()}"/&gt;
&lt;/f:metadata&gt;</pre></div><p>The <code class="literal">&lt;f:viewAction&gt;</code> tag supports an attribute named <code class="literal">onPostback</code> which is set to <code class="literal">false</code> by default, meaning that the <code class="literal">init</code> method will not be called on<a id="id197" class="indexterm"/> postback requests. Of course, if you set it to <code class="literal">true</code>, then it will function contrary; but, notice that in the case of the <code class="literal">preRenderView</code> event listener, the <code class="literal">init</code> method is called after the <code class="literal">userAction</code> method, while<a id="id198" class="indexterm"/> in the case of the <code class="literal">&lt;f:viewAction&gt;</code> tag, the <code class="literal">init</code> method is called before the <code class="literal">userAction</code> method, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">&lt;f:viewAction action="#{playersBean.init()}" <span class="strong"><strong>onPostback="true"</strong></span>/&gt;</pre></div><p>The example based on the <code class="literal">preRenderView</code> event listener is wrapped in the application named <code class="literal">ch_12_1</code>, while for the <code class="literal">&lt;f:viewAction&gt;</code> tag it is named <code class="literal">ch_12_2</code>.</p></li><li class="listitem" style="list-style-type: disc">The view action<a id="id199" class="indexterm"/> has navigation capabilities, while the <code class="literal">preRenderView</code> event listener doesn't. While<a id="id200" class="indexterm"/> the view action can naturally accomplish<a id="id201" class="indexterm"/> navigation tasks, the <code class="literal">preRenderView</code> event listener requires explicit navigation based on the JSF API.<p>For example, if you modify the preceding <code class="literal">init</code> method to return the <code class="literal">start.xhtml</code> view, then you will probably change it as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public String init() {
  if (playerName != null) {
    playerName = playerName.toUpperCase();
  }
  if (playerSurname != null) {
    playerSurname = playerSurname.toUpperCase();
  }
  return "start";
}</pre></div><p>But, this will not work with the <code class="literal">preRenderView</code> event listener! You will need to add explicit navigation by returning void and replacing the return <code class="literal">"start"</code> code line with the following code:</p><div class="informalexample"><pre class="programlisting">ConfigurableNavigationHandler handler = (ConfigurableNavigationHandler) FacesContext.getCurrentInstance().getApplication().getNavigationHandler();
handler.performNavigation("start");</pre></div><p>If you drop the <code class="literal">preRenderView</code> event listener and use the <code class="literal">&lt;f:viewAction&gt;</code> tag instead, then the preceding <code class="literal">init</code> method will correctly navigate to <code class="literal">start.xhtml</code> without involving an explicit call of the navigation handler.</p><p>The example<a id="id202" class="indexterm"/> based on the <code class="literal">preRenderView</code> event listener is <a id="id203" class="indexterm"/>wrapped in the <a id="id204" class="indexterm"/>application named <code class="literal">ch_13_1</code>, while for the <code class="literal">&lt;f:viewAction&gt;</code> tag it is named <code class="literal">ch_13_2</code>.</p><p>Moreover, the <code class="literal">&lt;f:viewAction&gt;</code> tag supports declarative navigation. So, you can write a<a id="id205" class="indexterm"/> navigation rule in the <code class="literal">faces-config.xml</code> file that is consulted before the page is rendered. For example:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
  &lt;from-view-id&gt;index.xhtml&lt;/from-view-id&gt;
  &lt;navigation-case&gt;
    &lt;from-action&gt;#{playersBean.init()}&lt;/from-action&gt; 
    &lt;from-outcome&gt;start&lt;/from-outcome&gt;
    &lt;to-view-id&gt;rafa.xhtml&lt;/to-view-id&gt;
    &lt;redirect/&gt;
  &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p>Now, the <code class="literal">rafa.xhtml</code> page will be rendered instead of the <code class="literal">start.xhtml</code> page. This example is wrapped into the application named <code class="literal">ch2_13_3</code>.</p></li><li class="listitem" style="list-style-type: disc">By default, the view action is executed in the<a id="id206" class="indexterm"/> <span class="strong"><strong>Invoke Application</strong></span> phase. But, it can be executed in the <span class="strong"><strong>Apply Request Values</strong></span> phase<a id="id207" class="indexterm"/> by setting the <code class="literal">immediate</code> attribute to <code class="literal">true</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;f:viewAction action="#{playersBean.init()}" immediate="true"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Moreover, you can<a id="id208" class="indexterm"/> specify in which phase to execute the action using the <code class="literal">phase</code> attribute whose<a id="id209" class="indexterm"/> value represents the phase<a id="id210" class="indexterm"/> name as a<a id="id211" class="indexterm"/> predefined constant. For <a id="id212" class="indexterm"/>example:<div class="informalexample"><pre class="programlisting">&lt;f:viewAction action="#{playersBean.init()}" phase="UPDATE_MODEL_VALUES"/&gt;</pre></div><p>The supported values are <code class="literal">APPLY_REQUEST_VALUES</code>, <code class="literal">INVOKE_APPLICATION</code>, <code class="literal">PROCESS_VALIDATIONS</code>, and <code class="literal">UPDATE_MODEL_VALUES</code>.</p></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The view action can be placed into a view metadata facet that doesn't contain other view parameters.</p></div></div></div><div class="section" title="Passing attributes with the &lt;f:attribute&gt; tag"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Passing attributes with the &lt;f:attribute&gt; tag</h2></div></div></div><p>When the <code class="literal">&lt;f:param&gt;</code> tag does not satisfy your needs, maybe the <code class="literal">&lt;f:attribute&gt;</code> tag will. This tag allows you<a id="id213" class="indexterm"/> to pass the value of an attribute of a component or to pass a parameter to a component.</p><p>For example, you can assign<a id="id214" class="indexterm"/> the value of the attribute named <code class="literal">value</code> of a <code class="literal">&lt;h:commandButton&gt;</code> tag as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton actionListener="#{playersBean.parametersAction}"&gt;
  &lt;f:attribute name="value" value="Send Rafael Nadal" /&gt;
&lt;/h:commandButton&gt;</pre></div><p>This will render a button labeled <span class="strong"><strong>Send Rafael Nadal</strong></span>. Its code is given as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Send Rafael Nadal" actionListener="#{playersBean.parametersAction}"&gt;</pre></div><p>Moreover, the <code class="literal">&lt;f:attribute&gt;</code> tag can be used to pass a parameter to a component, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton actionListener="#{playersBean.parametersAction}"&gt;
  &lt;f:attribute id="playerName" name="playerNameAttr" value="Rafael"/&gt;               
  &lt;f:attribute id="playerSurname" name="playerSurnameAttr" value="Nadal"/&gt;
&lt;/h:commandButton&gt;</pre></div><p>In the action listener method, you can extract the attributes' values as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private final static Logger logger = Logger.getLogger(PlayersBean.class.getName());
private String playerName;
private String playerSurname;
...
//getters and setters
...
public void parametersAction(ActionEvent evt) {     

  playerName = (String) evt.getComponent().getAttributes().get("playerNameAttr");
  playerSurname = (String) evt.getComponent().getAttributes().get("playerSurnameAttr");

  logger.log(Level.INFO, "Name: {0} Surname: {1}", new Object[]{playerName, playerSurname});
}</pre></div><p>This example is wrapped into the application named <code class="literal">ch2_14</code>.</p><p>If you are a fan of PrimeFaces<a id="id215" class="indexterm"/> (<a class="ulink" href="http://primefaces.org/">http://primefaces.org/</a>), then you will probably find the next example useful. One of the greatest built-in components of PrimeFaces is the <code class="literal">&lt;p:fileUpload&gt;</code> tag, which can be used, obviously, to upload files. Sometimes, besides the files that will be uploaded, you need to<a id="id216" class="indexterm"/> pass some extra<a id="id217" class="indexterm"/> parameters, for example, the files' owner name and surname. Well, the <code class="literal">&lt;p:fileUpload&gt;</code> tag doesn't come with a solution for this, but the <code class="literal">&lt;f:attribute&gt;</code> tag can be helpful. The following is the code of a classic <code class="literal">&lt;p:fileUpload&gt;</code> tag with the <code class="literal">&lt;f:attribute&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;  
  &lt;p:fileUpload 
    fileUploadListener="#{fileUploadController.handleFileUpload}" 
    mode="advanced" dragDropSupport="false"  
    update="messages" sizeLimit="100000" fileLimit="3"   
    allowTypes="/(\.|\/)(gif|jpe?g|png)$/"&gt;  
  &lt;f:attribute id="playerName" name="playerNameAttr" value="Rafael"/&gt;               
  &lt;f:attribute id="playerSurname" name="playerSurnameAttr" value="Nadal"/&gt; 
  &lt;/p:fileUpload&gt;
  &lt;p:growl id="messages" showDetail="true"/&gt;  
&lt;/h:form&gt;</pre></div><p>The <code class="literal">handleFileUpload</code> method<a id="id218" class="indexterm"/> is responsible for the upload-specific steps (skipped in the following code), but it can also access the values passed by the <code class="literal">&lt;f:attribute&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">public void handleFileUpload(FileUploadEvent evt) {

  //upload specific tasks, see PrimeFaces documentation

  String playerName = (String) evt.getComponent().getAttributes().get("playerNameAttr");
  String playerSurname = (String) evt.getComponent().getAttributes().get("playerSurnameAttr");

  FacesMessage msg = new FacesMessage("Successful", evt.getFile().getFileName() + " is uploaded for " + playerName + " " + playerSurname);

  FacesContext.getCurrentInstance().addMessage(null, msg);
}</pre></div><p>If you are not a fan of PrimeFaces, then you might probably think that this example is useless, but maybe you are a fan of some <a id="id219" class="indexterm"/>other third-party library, such as RichFaces, ICEFaces, and MyFaces. You can apply this technique for other component libraries as well.</p><p>This example is wrapped into the application named <code class="literal">ch2_15</code>.</p><p>Another case when the <code class="literal">&lt;f:attribute&gt;</code> tag can be useful is when dynamically passing parameters in conjunction with UI components<a id="id220" class="indexterm"/> bound to the managed bean using the <code class="literal">binding</code> attribute. This is very useful, especially because there is no solution provided by JSF for passing parameters to the getters/setters methods of the bound UI components, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText binding="#{playersBean.htmlInputText}" value="#{playersBean.playerNameSurname}"&gt;
    &lt;f:attribute name="playerNameAttr" value="Rafael Nadal"/&gt;
  &lt;/h:inputText&gt;
&lt;/h:form&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Now, the value of the <code class="literal">&lt;h:inputText&gt;</code> tag should contain the value set via the <code class="literal">&lt;f:attribute&gt;</code> tag. Be careful to use only unique names for the attributes and to not interfere (try to overwrite) with the default attributes of the UI component.</p></div></div><p>Also, the <code class="literal">PlayersBean</code> managed bean's code is as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@RequestScoped
public class PlayersBean {

  private UIInput htmlInputText= null;    
  
  public PlayersBean() {
  }

  public UIInput getHtmlInputText() {
    return htmlInputText;
  }

  public void setHtmlInputText(UIInput htmlInputText) {
    this.htmlInputText = htmlInputText;
  }    
    
  public String getPlayerNameSurname() {
<span class="strong"><strong>    return (String) htmlInputText.getAttributes().get("playerNameAttr");</strong></span>
  }    
}</pre></div><p>As you can see, all the parameters passed this<a id="id221" class="indexterm"/> way are accessible via the <code class="literal">getAttributes</code> method of the parent UI component.</p><p>This example is wrapped into the<a id="id222" class="indexterm"/> application named <code class="literal">ch2_23</code>.</p></div><div class="section" title="Setting property values via action listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Setting property values via action listeners</h2></div></div></div><p>The <code class="literal">&lt;f:setPropertyActionListener&gt;</code> tag uses an action listener (created by the framework) to directly set a<a id="id223" class="indexterm"/> value into a managed bean property; it is placed within a component derived from the <code class="literal">ActionSource</code> class. The <code class="literal">target</code> attribute indicates the managed bean property, while the <code class="literal">value</code> attribute indicates<a id="id224" class="indexterm"/> the value<a id="id225" class="indexterm"/> of the property, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Send Rafael Nadal 1"&gt;
  &lt;f:setPropertyActionListener id="playerName"  target="#{playersBean.playerName}" value="Rafael"/&gt;
  &lt;f:setPropertyActionListener  id="playerSurname" target="#{playersBean.playerSurname}" value="Nadal"/&gt;
&lt;/h:commandButton&gt;</pre></div><p>Now, in the <code class="literal">PlayersBean</code> managed bean, the setter methods are called and the values are set; <code class="literal">logger</code> is useful to see the application flow and to understand how listeners are fired, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private final static Logger logger =Logger.getLogger(PlayersBean.class.getName());
private String playerName;
private String playerSurname;

public void setPlayerName(String playerName) {
  this.playerName = playerName;
  logger.log(Level.INFO, "Player name (from setPlayerName() method: {0}", playerName);
}

public void setPlayerSurname(String playerSurname) {
  this.playerSurname = playerSurname;
  logger.log(Level.INFO, "Player surname (from setPlayerSurname() method: {0}", playerSurname);
}</pre></div><p>When the button labeled <span class="strong"><strong>Send Rafael Nadal 1</strong></span> is clicked, the application output will be as follows:</p><div class="informalexample"><pre class="programlisting">INFO:   Player name (from setPlayerName() method: Rafael
INFO:   Player surname (from setPlayerSurname() method: Nadal</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Keep in mind that action listeners are executed in the order they are defined, which means that the presence of the <code class="literal">&lt;f:setPropertyActionListener&gt;</code> tag can affect the order in which the listeners are fired.</p></div></div><p>This note is important! For a clear understanding, take<a id="id226" class="indexterm"/> a look at the<a id="id227" class="indexterm"/> following snippet of code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Send Rafael Nadal 2" actionListener="#{playersBean.parametersAction}"&gt;
  &lt;f:setPropertyActionListener id="playerName" target="#{playersBean.playerName}" value="Rafael"/&gt;
  &lt;f:setPropertyActionListener  id="playerSurname" target="#{playersBean.playerSurname}" value="Nadal"/&gt;
&lt;/h:commandButton&gt;</pre></div><p>The following code <a id="id228" class="indexterm"/>is of the<a id="id229" class="indexterm"/> <code class="literal">parametersAction</code> method:</p><div class="informalexample"><pre class="programlisting">public void parametersAction(ActionEvent e) {        
  logger.log(Level.INFO, "Player name (from parametersAction(ActionEvent) method: {0}", playerName);
  logger.log(Level.INFO, "Player surname (from parametersAction(ActionEvent) method: {0}", playerSurname);
}</pre></div><p>Well, this code does not work as expected! Probably, you think that the setters method is called first and the <code class="literal">parametersAction</code> method later; therefore, the set values are available in the action method. But, the following output will prove the opposite:</p><div class="informalexample"><pre class="programlisting">INFO:   Player name (from parametersAction() method: null
INFO:   Player surname (from parametersAction() method: null
INFO:   Player name (from setPlayerName() method: Rafael
INFO:   Player surname (from setPlayerSurname() method: Nadal</pre></div><p>So, the properties are set after the command action listener is fired! To fix this issue, you can use the <code class="literal">action</code> attribute instead of <code class="literal">actionListener</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Send Rafael Nadal 3" action="#{playersBean.parametersAction()}"&gt;
  &lt;f:setPropertyActionListener id="playerName" target="#{playersBean.playerName}" value="Rafael"/&gt;
  &lt;f:setPropertyActionListener  id="playerSurname" target="#{playersBean.playerSurname}" value="Nadal"/&gt;
&lt;/h:commandButton&gt;</pre></div><p>Of course, you need to adjust the <code class="literal">parametersAction</code> method<a id="id230" class="indexterm"/> accordingly, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void parametersAction() {        
  logger.log(Level.INFO, "Player name (from parametersAction() method: {0}", playerName);
  logger.log(Level.INFO, "Player surname (from parametersAction() method: {0}", playerSurname);
}</pre></div><p>Now, the output<a id="id231" class="indexterm"/> will reflect the following<a id="id232" class="indexterm"/> desired result:</p><div class="informalexample"><pre class="programlisting">INFO:   Player name (from setPlayerName() method: Rafael
INFO:   Player surname (from setPlayerSurname() method: Nadal
INFO:   Player name (from parametersAction() method: Rafael
INFO:   Player surname (from parametersAction() method: Nadal</pre></div><p>This example is wrapped into <a id="id233" class="indexterm"/>the application named <code class="literal">ch2_16</code>.</p></div><div class="section" title="Passing parameters using the Flash scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Passing parameters using the Flash scope</h2></div></div></div><p>The new JSF Flash scope is a very handy tool when you need to pass parameters between user views without the need to store them in the session. The Flash scope is simple to understand if you keep in <a id="id234" class="indexterm"/>mind that variables stored in the Flash scope<a id="id235" class="indexterm"/> will be available over a redirection and they will be eliminated afterwards. This is really useful when implementing a POST-redirect-GET pattern.</p><p>For a better understanding, let's suppose the following scenario:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A player (user) needs to register on the ATP website. Among other information, he will provide his name and surname and click on the <span class="strong"><strong>Register</strong></span> button. This is accomplished in the <code class="literal">index.xhtml</code> page.</li><li class="listitem" style="list-style-type: disc">The application flow redirects the player to the page <code class="literal">terms.xhtml</code>. On this page, the user can see a welcome message containing his name and surname and some terms and conditions that must be accepted (using the <span class="strong"><strong>Accept</strong></span> button) or rejected (using the <span class="strong"><strong>Reject</strong></span> button).</li><li class="listitem" style="list-style-type: disc">If the <span class="strong"><strong>Reject</strong></span> button is clicked, then the user is redirected to the <code class="literal">index.xhtml</code> home page, and the form registration fields will reveal the information provided by him earlier. Moreover, he will see a generated message stating <span class="strong"><strong>Terms rejected! Player not registered!</strong></span>. This is outputted by the <code class="literal">&lt;h:message&gt;</code> tag.</li><li class="listitem" style="list-style-type: disc">If the <span class="strong"><strong>Accept</strong></span> button is clicked, then the user is redirected to a page named <code class="literal">done.xhtml</code>. On this page, the user will see a generated message stating <span class="strong"><strong>Terms accepted and player registered!</strong></span> and another message stating <span class="emphasis"><em>Name Surname</em></span><span class="strong"><strong> successfully registered!</strong></span>. The first message is outputted by the <code class="literal">&lt;h:message&gt;</code> tag, while the second one by the <code class="literal">&lt;h:outputText&gt;</code> tag.</li></ul></div><p>The following is a screenshot of both the scenarios:</p><div class="mediaobject"><img src="graphics/6466EN_02_01.jpg" alt="Passing parameters using the Flash scope"/></div><p>Obviously, you can implement this flow only if you store the submitted values somewhere, because<a id="id236" class="indexterm"/> they will not survive during the <a id="id237" class="indexterm"/>redirect process. This means that using a managed bean in the request scope cannot be a valid option. But, if we add in discussion the new Flash scope, then things become more favorable for the request scoped bean.</p><p>It will be much easier to follow this idea if you take a quick look at the following code of the request scoped bean, named <code class="literal">PlayersBean</code>:</p><div class="informalexample"><pre class="programlisting">@Named
@RequestScoped
public class PlayersBean {

  private final static Logger logger = Logger.getLogger(PlayersBean.class.getName());
  private String playerName;
  private String playerSurname;

...

  public String addValuesToFlashAction() {

    Flash flash = FacesContext.getCurrentInstance().getExternalContext().getFlash();
    flash.put("playerName", playerName);
    flash.put("playerSurname", playerSurname);

    return "terms?faces-redirect=true";
  }

  public void pullValuesFromFlashAction(ComponentSystemEvent e) {

    Flash flash = FacesContext.getCurrentInstance().getExternalContext().getFlash();
    playerName = (String) flash.get("playerName");
    playerSurname = (String) flash.get("playerSurname");
  }

  public String termsAcceptedAction() {

    Flash flash = FacesContext.getCurrentInstance().getExternalContext().getFlash();

    flash.setKeepMessages(true);
    pullValuesFromFlashAction(null);

    //do something with firstName, lastName 
    logger.log(Level.INFO, "First name: {0}", playerName);
    logger.log(Level.INFO, "Last name: {0}", playerSurname);

    FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Terms accepted and player registered!"));
    return "done?faces-redirect=true";
  }

  public String termsRejectedAction() {

    Flash flash = FacesContext.getCurrentInstance().getExternalContext().getFlash();

    flash.setKeepMessages(true);
    pullValuesFromFlashAction(null);

    FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Terms rejected! Player not registered!"));
    return "index?faces-redirect=true";
  }
}</pre></div><p>Also, take a<a id="id238" class="indexterm"/> look at the start page, <code class="literal">index.xhtml</code>. Its code is as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;h:body&gt;
    &lt;f:metadata&gt; 
      &lt;f:event type="preRenderView" listener="#{playersBean.pullValuesFromFlashAction}"/&gt; 
    &lt;/f:metadata&gt;
    &lt;h:messages /&gt;  
    &lt;h:form&gt;                       
      Name: &lt;h:inputText value="#{playersBean.playerName}"/&gt;
      Surname: &lt;h:inputText value="#{playersBean.playerSurname}"/&gt;
     &lt;h:commandButton value="Register" action="#{playersBean.addValuesToFlashAction()}"/&gt;          
    &lt;/h:form&gt;
  &lt;/h:body&gt;</pre></div><p>So, the submission process<a id="id239" class="indexterm"/> begins when the user clicks on the button labeled <span class="strong"><strong>Register</strong></span>. JSF will call the <code class="literal">addValuesToFlashAction</code> method, which is responsible for putting the submitted values to the Flash scope; this will ensure that the values will survive during redirect to the <code class="literal">terms.xhtml</code> page.</p><p>If the user rejects the terms and conditions, then he is redirected to the <code class="literal">index.xhtml</code> page. Here, you need to repopulate the registration form fields with the user-inserted values. For this, you can use the <code class="literal">preRenderView</code> event, which will load the values from the Flash scope during the render response phase by calling the <code class="literal">pullValuesFromFlashAction</code> method.</p><p>Next, let's focus on the <code class="literal">terms.xhtml</code> page; its code is as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;h:body&gt;
    &lt;h:messages /&gt;  
      Hello, &lt;h:outputText value="#{flash.keep.playerName} #{flash.keep.playerSurname}"/&gt;    
    &lt;br/&gt;&lt;br/&gt;Terms &amp;amp; Conditions ... ... ... ... ...
    &lt;h:form&gt;
    &lt;h:commandButton value="Reject" action="#{playersBean.termsRejectedAction()}" /&gt;
    &lt;h:commandButton value="Accept" action="#{playersBean.termsAcceptedAction()}" /&gt;
    &lt;/h:form&gt;
  &lt;/h:body&gt;</pre></div><p>First, this page displays<a id="id240" class="indexterm"/> the entered values wrapped into a welcome message. The<a id="id241" class="indexterm"/> values are obtained from the Flash scope using the following code:</p><div class="informalexample"><pre class="programlisting">#{flash.keep.playerName}
#{flash.keep.playerSurname}</pre></div><p>Notice that this approach has two functions, which are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It obtains the values from the Flash scope, which could also be accomplished with the following lines:<div class="informalexample"><pre class="programlisting">#{flash.playerName}
#{flash.playerSurname}</pre></div></li><li class="listitem" style="list-style-type: disc">It tells JSF to keep the values in the Flash scope for the next request. This is needed because values put to the Flash scope survive only one redirect and then are deleted. We have already fired a redirect when we have navigated from the <code class="literal">index.xhtml</code> page to the <code class="literal">terms.xhtml</code> page. But, another redirect will appear when the <span class="strong"><strong>Accept</strong></span> or <span class="strong"><strong>Reject</strong></span> button is clicked.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Values stored in the Flash scope survive only one redirect and then are deleted.</p></div></div><p>Furthermore, the page displays both the buttons for navigating back to the <code class="literal">index.xhtml</code> page and forward to the <code class="literal">done.xhtml</code> page. The <span class="strong"><strong>Accept</strong></span> button will call the <code class="literal">termsAcceptedAction</code> method, <a id="id242" class="indexterm"/>which will basically preserve messages across redirects (it calls the <code class="literal">setKeepMessages</code> method) and redirects the flow to the <code class="literal">done.xhtml</code> page. In the same manner, the <span class="strong"><strong>Reject</strong></span> button calls the<a id="id243" class="indexterm"/> <code class="literal">termsRejectedAction</code> method, preserves messages in the Flash scope, and redirects the flow to the <code class="literal">index.xhtml</code> page.</p><p>The <code class="literal">done.xhtml</code> page is presented using the following code:</p><div class="informalexample"><pre class="programlisting">  &lt;h:body&gt;
    &lt;f:metadata&gt; 
     &lt;f:event type="preRenderView" listener="#{playersBean.pullValuesFromFlashAction}"/&gt; 
    &lt;/f:metadata&gt;
    &lt;h:messages /&gt;  
    &lt;h:outputText value="#{playersBean.playerName} #{playersBean.playerSurname}"/&gt; successfully registered!
  &lt;/h:body&gt;</pre></div><p>The <code class="literal">preRenderView</code> event listener is<a id="id244" class="indexterm"/> used again for<a id="id245" class="indexterm"/> obtaining the values from the Flash scope.</p><p>This example is wrapped into the application named <code class="literal">ch2_21</code>.</p></div><div class="section" title="Replacing the &lt;f:param&gt; tag with the JSTL &lt;c:set&gt; tag"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Replacing the &lt;f:param&gt; tag with the JSTL &lt;c:set&gt; tag</h2></div></div></div><p>Sometimes, the JSTL <code class="literal">&lt;c:set&gt;</code> tag can<a id="id246" class="indexterm"/> solve issues that the JSF <code class="literal">&lt;f:param&gt;</code> tag can't. Probably, you know that<a id="id247" class="indexterm"/> we can pass parameters to the <code class="literal">&lt;ui:include&gt;</code> tag using the <code class="literal">&lt;f:param&gt;</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ui:include src="rafa.xhtml"&gt;
  &lt;f:param name="rafa" value="Rafael Nadal Page"/&gt;,
&lt;/ui:include&gt;</pre></div><p>Well, this approach triggers an issue! Now, the <code class="literal">Rafael Nadal Page</code> value will be available in the included page through EL, <code class="literal">#{rafa}</code>, but will not be available in the constructor of the managed bean of the included page!</p><p>It is time for the <code class="literal">&lt;c:set&gt;</code> tag to save the situation; therefore, the code will be changed to the following:</p><div class="informalexample"><pre class="programlisting">&lt;ui:include src="rafa.xhtml"&gt;
  &lt;c:set var="rafa" value="Rafael Nadal Page" scope="request"/&gt;,
&lt;/ui:include&gt;</pre></div><p>Done! Now, in the constructor of the managed bean, the value can be extracted as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public ConstructorMethod(){
  FacesContext facesContext = FacesContext.getCurrentInstance();
  HttpServletRequest httpServletRequest  = (HttpServletRequest) facesContext.getExternalContext().getRequest();
  String rafa = (String) request.getAttribute("rafa");
}</pre></div><p>In the <span class="emphasis"><em>Configuring system event listeners</em></span> section in <a class="link" href="ch04.html" title="Chapter 4. JSF Configurations Using XML Files and Annotations – Part 1">Chapter 4</a>, <span class="emphasis"><em>JSF Configurations Using XML Files and Annotations – Part 1</em></span>, you <a id="id248" class="indexterm"/>will see how to work with <a id="id249" class="indexterm"/>system events dedicated to the Flash scope.</p></div><div class="section" title="Sending data through cookies"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Sending data through cookies</h2></div></div></div><p>JSF provides a request cookie map<a id="id250" class="indexterm"/> that can be used to work with HTTP cookies. Setting <a id="id251" class="indexterm"/>cookies can be easily accomplished through JavaScript; the following are just some helper methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The JavaScript method for setting a cookie is as follows:<div class="informalexample"><pre class="programlisting">function setCookie(cookie_name, value, expiration_days)
{
  var expiration_date = new Date();
  expiration_date.setDate(expiration_date.getDate() + expiration_days);
  var c_value = escape(value) + ((expiration_days == null) ? "" : "; 
  expires=" + expiration_date.toUTCString());
  document.cookie = cookie_name + "=" + c_value;
}</pre></div><p>The JavaScript method for deleting a cookie by the name is as follows:</p><div class="informalexample"><pre class="programlisting">function deleteCookie(cookie_name) {
  document.cookie = encodeURIComponent(cookie_name) + "=deleted; expires=" + new Date(0).toUTCString();
}</pre></div></li><li class="listitem" style="list-style-type: disc">The JavaScript method for extracting a cookie by the name is as follows:<div class="informalexample"><pre class="programlisting">function getCookie(cookie_name) {
  var i, part_1, part_2;
  var cookieslist = document.cookie.split(";");
  //&lt;![CDATA[
  for (i = 0; i &lt; cookieslist.length; i++)
  {
    part_1 = cookieslist[i].substr(0, cookieslist[i].indexOf("="));
    part_2 = cookieslist[i].substr(cookieslist[i].indexOf("=") + 1);
    part_1 = part_1.replace(/^\s+|\s+$/g, "");
    if (part_1 == cookie_name)
    {
      return unescape(part_2);
    }
  }
  //]]&gt;
  return "nocookie";
}</pre></div></li></ul></div><p>Let's suppose that you<a id="id252" class="indexterm"/> have two cookies named <code class="literal">name</code> and<a id="id253" class="indexterm"/> <code class="literal">surname</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">setCookie('name', 'Rafael', 1);
setCookie('surname', 'Nadal', 1);</pre></div><p>JSF can access these cookies through the following request cookie map:</p><div class="informalexample"><pre class="programlisting">Object name_cookie = FacesContext.getCurrentInstance().getExternalContext().getRequestCookieMap().get("name");
Object surname_cookie = FacesContext.getCurrentInstance().getExternalContext().getRequestCookieMap().get("surname");

//set playerName property 
if (name_cookie != null) {
  playerName = (((Cookie) name_cookie).getValue());
}

//set playerSurname property 
if (surname_cookie != null) {
  playerSurname = (((Cookie) surname_cookie).getValue());
}</pre></div><p>JSF also provides several getters and setters methods for working with cookies. These methods are given in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Getter methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Setter methods</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">String getComment()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setComment(String arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">String getDomain()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setDomain(String arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">String getName()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setHttpOnly(boolean arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">String getPath()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setPath(String arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">String getValue()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setValue(String arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">int getMaxAge()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setMaxAge(int arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boolean getSecure()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setSecure(boolean arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">int getVersion()</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">setVersion(int arg)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boolean isHttpOnly()</code></p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>This example is<a id="id254" class="indexterm"/> wrapped into the application named <code class="literal">ch2_18</code> and can be<a id="id255" class="indexterm"/> found in the code bundle of this chapter.</p></div><div class="section" title="Working with hidden fields"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Working with hidden fields</h2></div></div></div><p>Hidden fields can sometimes be very useful<a id="id256" class="indexterm"/>! Passing data in a subtle manner can be the perfect choice for dealing with temporary data or information provided by the user that should be used again and again. JSF offers the <code class="literal">&lt;h:inputHidden&gt;</code> tag to pass <a id="id257" class="indexterm"/>hidden parameters. The following code passes two hidden parameters to a managed bean:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="hiddenFormId"&gt;
  &lt;h:commandButton value="Send Rafael Nadal" onclick="setHiddenValues();" action="#{playersBean.parametersAction()}"/&gt;
  &lt;h:inputHidden id="playerName" value="#{playersBean.playerName}"/&gt;
 &lt;h:inputHidden id="playerSurname" value="#{playersBean.playerSurname}"/&gt;
&lt;/h:form&gt;</pre></div><p>Usually, setting hidden field values from JavaScript is a common practice. When the button <span class="strong"><strong>Send Rafael Nadal</strong></span> is clicked, the JavaScript function named <code class="literal">setHiddenValues</code> is called; this happens before the form submission. The <code class="literal">setHiddenValues</code> function is given in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
  function setHiddenValues() {
    document.getElementById('hiddenFormId:playerName').value = "Rafael";
    document.getElementById('hiddenFormId:playerSurname').value = "Nadal";
  }
&lt;/script&gt;</pre></div><p>Next, the hidden parameters are set in the indicated managed bean properties and the <code class="literal">parametersAction</code> method is called—the set values are ready to use!</p><p>This example is wrapped into the application named <code class="literal">ch2_17</code> and can be found in the code bundle of this chapter.</p></div><div class="section" title="Sending passwords"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Sending passwords</h2></div></div></div><p>JSF provides a dedicated<a id="id258" class="indexterm"/> tag named <code class="literal">&lt;h:inputSecret&gt;</code> for rendering the following well-known HTML code:</p><div class="informalexample"><pre class="programlisting">&lt;input type="password"&gt;</pre></div><p>For example, you can use it as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputSecret value="#{playersBean.playerPassword}"/&gt;
  &lt;h:commandButton value="Send Password" action="#{playersBean.passwordAction()}"/&gt;
&lt;/h:form&gt;</pre></div><p>This example is wrapped into the application named <code class="literal">ch2_19</code>.</p></div><div class="section" title="Accessing UI component attributes programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Accessing UI component attributes programmatically</h2></div></div></div><p>Accessing UI component attributes from<a id="id259" class="indexterm"/> managed beans using the JSF API is not a common approach, but sometimes<a id="id260" class="indexterm"/> you may find it useful. For example, let's suppose that we have the following form:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="playerFormId"&gt;
  &lt;h:inputText id="playerNameId" value="#{playersBean.playerName}"/&gt; 
  &lt;h:inputText id="playerSurnameId" value="#{playersBean.playerSurname}"/&gt;
  &lt;h:commandButton value="Process" action="#{playersBean.processAction()}"/&gt;
&lt;/h:form&gt;</pre></div><p>Now, you want to obtain the values of the components with IDs, <code class="literal">playerNameId</code> and <code class="literal">playerSurnameId</code>, in the <code class="literal">processAction</code> method. Moreover, you want to set the value of the component with the ID, <code class="literal">playerNameId</code>, as <code class="literal">RAFAEL</code>. Programmatically (using the JSF API), you can achieve this as follows:</p><div class="informalexample"><pre class="programlisting">public void processAction() {

  UIViewRoot view = FacesContext.getCurrentInstance().getViewRoot();
  UIComponent uinc = view.findComponent("playerFormId:playerNameId");
  Object prev = ((UIInput) uinc).getAttributes().put("value", "RAFAEL");


  UIComponent uisc = view.findComponent("playerFormId:playerSurnameId");
  Object current = ((UIInput) uisc).getAttributes().get("value");
}</pre></div><p>First, you need to obtain access to <code class="literal">UIViewRoot</code>, which is the top level UI component—the root of the <code class="literal">UIComponent</code> tree. Then, you can search by the ID for the desired UI component through the UI components tree using the <code class="literal">findComponent</code> method. Each UI component provides the <code class="literal">getAttributes</code> method, which can be used to gain access to the UI component<a id="id261" class="indexterm"/> attributes by their names. At this point, you can extract an attribute value using the <code class="literal">get</code> method, or set a new attribute value using the <code class="literal">put</code> method.</p><p>This example is wrapped into the application named <code class="literal">ch2_20</code>.</p></div><div class="section" title="Passing parameters via method expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Passing parameters via method expressions</h2></div></div></div><p>Passing parameters using <a id="id262" class="indexterm"/>method expressions is an elegant<a id="id263" class="indexterm"/> solution to send parameters as arguments to an action method of a managed bean. For example, let's focus on the following snippet of code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
 &lt;h:commandButton value="Send Rafael Nadal"  action="#{playersBean.parametersAction('Rafael','Nadal')}"/&gt;
&lt;/h:form&gt;</pre></div><p>As you can see in the following code, the <code class="literal">action</code> attribute indicates a method that gets two arguments:</p><div class="informalexample"><pre class="programlisting">private String playerName;
private String playerSurname;

//getters and setters

public String parametersAction(String playerNameArg, String playerSurnameArg) {       
       
  playerName = playerNameArg;
  playerSurname = playerSurnameArg;
        
  return "result";
}</pre></div><p>In the same manner, you can pass numeric values or objects.</p><p>This example is wrapped into the application named <code class="literal">ch2_26</code>.</p></div><div class="section" title="Communicating via the binding attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Communicating via the binding attribute</h2></div></div></div><p>JSF UI components <a id="id264" class="indexterm"/>support an attribute named <code class="literal">binding</code>, which is rarely used and, sometimes, poorly understood. The story behind its meaning can be stretched over several pages or summed up in some golden rules. We will start with the binding lifespan and a brief overview and will end with the important rules that should be taken into account when you decide to used it in production.</p><p>If we want to localize the moment in time when the <code class="literal">binding</code> attribute enters the fray, we can refer to the moment when the JSF view is built or restored; the result of building/restoring the view is present in the component tree. So, before the component tree is deliverable, JSF needs to inspect all <code class="literal">binding</code> attributes. For each of them, JSF will check the presence of a pre-existing (precreated) component. If a pre-existing component is found,<a id="id265" class="indexterm"/> then it is used; otherwise, JSF will automatically create a brand new one, and will pass it as an argument to the setter method that corresponds to that <code class="literal">binding</code> attribute. In addition, JSF adds a reference of the component in the view state. Furthermore, a postback request (a form submit) will tell JSF to restore the view, which will restore the components and bindings based on view state.</p><p>Now that you know what happens with the <code class="literal">binding</code> attribute, let's enumerate some important aspects of using it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">After each request (initial or postback), JSF creates an instance of the component indicated by the <code class="literal">binding</code> attribute.</li><li class="listitem" style="list-style-type: disc">At the restore view (at the postback), after the component instance is created, JSF populates it from the view state, based on the stored reference.</li><li class="listitem" style="list-style-type: disc">When you bind a component to a bean property (of type <code class="literal">UIComponent</code>), you actually bind the whole component. This kind of binding is a very rare use case, and it may be useful when you want to work/expose a component's methods that are not available in the view or you need to alter the component's children in a programmatic fashion. Moreover, you can alter the component's attributes and instantiate the component rather than letting the page author do so.</li><li class="listitem" style="list-style-type: disc">Since JSF instantiates the component at each request, the bean must be in the request scope; otherwise, the component may be shared between different views. The view scope may also be a solution.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">binding</code> attribute is also used to bind the component to the current view, without the need of a bean. This is useful to gain access to the state of a component from another component.</li><li class="listitem" style="list-style-type: disc">Binding a component without a bean property will put the component in the EL scope. This happens when the component tree is built; therefore, EL is perfectly capable to reveal the bound component at the rendering stage, which takes place after the component tree was built.</li></ul></div><p>For example, a <code class="literal">&lt;h:dataTable&gt;</code> tag has three useful properties: <code class="literal">first</code>, <code class="literal">rows</code>, and <code class="literal">rowCount</code>. If you bind a <code class="literal">&lt;h:dataTable&gt;</code> tag to the current view, then outside of this component, you can access these properties as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataArrayList}" <span class="strong"><strong>binding="#{table}"</strong></span> var="t"&gt;</pre></div><p>For example, you can set the <code class="literal">rows</code> property as follows:</p><div class="informalexample"><pre class="programlisting">#{table.rows = 3;''}</pre></div><p>Also, display the <code class="literal">rowCount</code> and <code class="literal">first</code> properties as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText value="#{table.rowCount}"/&gt;
&lt;h:outputText value="#{table.first}"/&gt;</pre></div><p>The complete application is named <code class="literal">ch2_32</code>.</p><p>We can accomplish the same thing from a bean. First, we bind the <code class="literal">&lt;h:dataTable&gt;</code> tag to a bean property of type <code class="literal">HtmlDataTable</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataArrayList}" <span class="strong"><strong>binding="#{playersBean.table}"</strong></span> var="t"&gt;</pre></div><p>Now, in <code class="literal">PlayersBean</code>, we add the following code:</p><div class="informalexample"><pre class="programlisting">private HtmlDataTable table;
...
//getter and setter
...
public void tableAction() {
  logger.log(Level.INFO, "First:{0}", table.getFirst());
  logger.log(Level.INFO, "Row count: {0}", table.getRowCount());
  table.setRows(3);
}</pre></div><p>The complete<a id="id266" class="indexterm"/> application is named <code class="literal">ch2_31</code>.</p></div></div></div>
<div class="section" title="Managed bean communication"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Managed bean communication</h1></div></div></div><p>Until now, we have focused especially on the communication between Facelets and managed beans. In this section,<a id="id267" class="indexterm"/> we will cover another important aspect regarding JSF communication—managed beans communication. We will discuss the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Injecting a managed bean into another bean</li><li class="listitem" style="list-style-type: disc">Communication between managed beans using the application/session map</li><li class="listitem" style="list-style-type: disc">Accessing other managed beans programmatically</li></ul></div><div class="section" title="Injecting a managed bean into another bean"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Injecting a managed bean into another bean</h2></div></div></div><p>A managed bean can be<a id="id268" class="indexterm"/> injected into another managed bean using <code class="literal">@ManagedProperty</code>. For example, let's suppose<a id="id269" class="indexterm"/> that you have a managed bean in the session scope that stores a player name and surname, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@SessionScoped
public class PlayersBean implements Serializable{

  private String playerName;
  private String playerSurname;

  public PlayersBean() {
    playerName = "Rafael";
    playerSurname = "Nadal";
  }

//getters and setters
}</pre></div><p>Now, let's suppose that <a id="id270" class="indexterm"/>you want to have access to this bean's properties from another view scoped bean,<a id="id271" class="indexterm"/> named <code class="literal">ProfileBean</code>. For this, you can use <code class="literal">@ManagedProperty</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@ManagedBean //cannot be @Named
@ViewScoped
public class ProfileBean implements Serializable{

  private final static Logger logger = Logger.getLogger(PlayersBean.class.getName());
  @ManagedProperty("#{playersBean}")
  private PlayersBean playersBean;
  private String greetings;

  public ProfileBean() {     
  }   

  public void setPlayersBean(PlayersBean playersBean) {
    this.playersBean = playersBean;
  }        
    
  @PostConstruct
  public void init(){
    greetings = "Hello, " + playersBean.getPlayerName() + " " +playersBean.getPlayerSurname() + " !";
  }
    
  public void greetingsAction(){
    logger.info(greetings);
  }
    
}</pre></div><p>A Facelet that calls the <code class="literal">greetingsAction</code> method will draw something like the following line in the log:</p><div class="informalexample"><pre class="programlisting">INFO:   Hello, Rafael Nadal !</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>The presence of the <code class="literal">@PostConstruct</code> method is optional, but it is good to know that this is the earliest place where an injected dependency is available.</p></div></div><p>This example is wrapped into the application named <code class="literal">ch2_22</code>.</p><p>If you want to use CDI beans, then you can<a id="id272" class="indexterm"/> accomplish the same thing as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@ViewScoped
public class ProfileBean implements Serializable{

  @Inject
  private PlayersBean playersBean;
  private String greetings;
  ...</pre></div><p>This example is<a id="id273" class="indexterm"/> wrapped into the application named <code class="literal">ch2_30</code>.</p></div><div class="section" title="Communication between managed beans using the application/session map"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Communication between managed beans using the application/session map</h2></div></div></div><p>Communication between managed beans can be ensured through an application map or a session map, depending on <a id="id274" class="indexterm"/>what kind of communication is needed, during multiple browser sessions or during one browser session.</p><p>The advantage of using the application/session map is in the fact that multiple beans can communicate with each other independent of their scopes. First, you need to define a helper class that provides two static methods, one for <a id="id275" class="indexterm"/>adding a value into the application map and one for deleting a value from the application map, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class ApplicationMapHelper {
    
  public static Object getValueFromApplicationMap(String key) {
    return FacesContext.getCurrentInstance().getExternalContext().getApplicationMap().get(key);
  }  

  public static void setValueInApplicationMap(String key, Object value) {
    FacesContext.getCurrentInstance().getExternalContext().getApplicationMap().put(key, value);
  }    
}</pre></div><p>Now, you can improvise a simple scenario: in one managed bean (request scoped), put some values into the application map, <a id="id276" class="indexterm"/>and in another managed bean (session scoped), get those values. So, the first bean code is as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@RequestScoped
public class PlayersBeanSet {  

  public void playerSetAction() {     
    ApplicationMapHelper.setValueInApplicationMap("PlayersBeanSet.name", "Rafael");
    ApplicationMapHelper.setValueInApplicationMap("PlayersBeanSet.surname", "Nadal");
  }
}</pre></div><p>The managed beans that extract<a id="id277" class="indexterm"/> these values from the application map are given out as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@SessionScoped
public class PlayersBeanGet implements Serializable{  

  private final static Logger logger = Logger.getLogger(PlayersBeanGet.class.getName());
    
  public void playerGetAction() {    
    String name = String.valueOf(ApplicationMapHelper.getValueFromApplicationMap("PlayersBeanSet.name"));
    String surname = String.valueOf(ApplicationMapHelper.getValueFromApplicationMap("PlayersBeanSet.surname"));
        
    logger.log(Level.INFO, "Name: {0} Surname: {1}", new Object[]{name, surname});
  }
}</pre></div><p>This example is wrapped into the application named <code class="literal">ch2_24</code>.</p></div><div class="section" title="Accessing other managed beans programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Accessing other managed beans programmatically</h2></div></div></div><p>Sometimes, you may need to access one managed bean from an event listener class or another managed bean. Suppose<a id="id278" class="indexterm"/> that we have a managed bean <a id="id279" class="indexterm"/>on session scope, named <code class="literal">PlayersBean</code>, and one on request scope, named <code class="literal">ProfileBean</code>, and you want to programmatically access <code class="literal">PlayersBean</code> inside <code class="literal">ProfileBean</code>. Supposing that <code class="literal">PlayersBean</code> has been created, you can accomplish this task in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the <code class="literal">evaluateExpressionGet</code> method<a id="id280" class="indexterm"/> inside <code class="literal">ProfileBean</code> as follows:<div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
PlayersBean playersBean = (PlayersBean) context.getApplication().evaluateExpressionGet(context, "#{playersBean}", PlayersBean.class);

if (playersBean != null) {
  //call the PlayersBean method   
} else {
  logger.info("SESSION BEAN NOT FOUND!");
}</pre></div></li><li class="listitem" style="list-style-type: disc">Use the <code class="literal">createValueExpression</code> method<a id="id281" class="indexterm"/> inside <code class="literal">ProfileBean</code> as follows:<div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
ELContext elcontext = context.getELContext();

PlayersBean playersBean = (PlayersBean) context.getApplication().getExpressionFactory().createValueExpression(elcontext, "#{playersBean}", PlayersBean.class).getValue(elcontext);

if (playersBean != null) {
  //call the PlayersBean method   
} else {
  logger.info("SESSION BEAN NOT FOUND!");
}</pre></div><p>In order to make things simpler, when you need to programmatically create a value expression, you can use a simple helper method and pass only the expression and class, as follows:</p><div class="informalexample"><pre class="programlisting">private ValueExpression createValueExpression(String exp, Class&lt;?&gt; cls) {
  FacesContext facesContext = FacesContext.getCurrentInstance();
  ELContext elContext = facesContext.getELContext();
  return facesContext.getApplication().getExpressionFactory().createValueExpression(elContext, exp, cls);
}</pre></div></li><li class="listitem" style="list-style-type: disc">Use <code class="literal">ELResolver</code> inside <code class="literal">ProfileBean</code> as follows:<div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
ELContext elcontext = context.getELContext();

PlayersBean playersBean = (PlayersBean) elcontext.getELResolver().getValue(elcontext, null, "playersBean");

if (playersBean != null) {
  //call the PlayersBean method   
} else {
  logger.info("SESSION BEAN NOT FOUND!");
}</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>The <code class="literal">evaluateExpressionGet</code> method is the most common one.</p></div></div><p>This example is wrapped into the<a id="id282" class="indexterm"/> application<a id="id283" class="indexterm"/> named <code class="literal">ch2_25</code>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>Communication in JSF is one of the most important aspects, since the entire application's flow spins around the capability of processing and sharing data between JSF components. As you have seen, there are many ways to pass/get parameters and to access managed beans from other managed beans, but choosing the right ones for obtaining a robust, harmonious, balanced application depends on experience. This chapter covers a wide range of solutions for building communication pipes between JSF components, but, as any developer knows, there is always a case that requires a new approach!</p><p>See you in the next chapter, where we will talk about JSF scopes.</p></div></body></html>