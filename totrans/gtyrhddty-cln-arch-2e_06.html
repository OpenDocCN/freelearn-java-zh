<html><head></head><body>
<div id="_idContainer045">
<h1 class="hapter-number" id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.2.1">Implementing a Web Adapter</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Most applications today have some kind of web interface – either a UI that we can interact with via a web browser or an HTTP API that other systems can call to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In our target architecture, all communication with the outside world goes through adapters. </span><span class="koboSpan" id="kobo.5.2">So, let’s discuss how we can</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.6.1"> implement an adapter that provides such a </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">web interface.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.8.1">Dependency Inversion</span></h1>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.9.1">Figure 6</span></em></span><em class="itali"><span class="koboSpan" id="kobo.10.1">.1</span></em><span class="koboSpan" id="kobo.11.1"> gives a zoomed-in view</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.12.1"> of the architecture elements that are relevant to our discussion of a web adapter – the adapter itself and the ports through which it interacts with our </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">application core:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.14.1"><img alt="Figure 6.1 – An incoming adapter talks to the application layer through dedicated incoming ports, which are interfaces implemented by the domain services" src="image/Figure_06.1_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.15.1">Figure 6.1 – An incoming adapter talks to the application layer through dedicated incoming ports, which are interfaces implemented by the domain services</span></p>
<p><span class="koboSpan" id="kobo.16.1">The web adapter is a “driving” or “incoming” adapter. </span><span class="koboSpan" id="kobo.16.2">It takes requests from the outside and translates them into calls to our application core, telling it what to do. </span><span class="koboSpan" id="kobo.16.3">The control flow goes from the controllers in the web adapter to the services in the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">application layer.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">The application layer provides </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.19.1">specific ports through which the web adapter may communicate. </span><span class="koboSpan" id="kobo.19.2">Each port is what I have called a “use case” in the previous chapter, and it is implemented by a domain service in the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">application layer.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">If we look closer, we </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.22.1">notice that this is the Dependency Inversion Principle </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.23.1">in action. </span><span class="koboSpan" id="kobo.23.2">Since the control flow goes from left to right, we could just as well let the web adapter call the use cases directly, as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.24.1">Figure 6</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.25.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.27.1"><img alt="Figure 6.2 – We can remove the port interfaces and call the services directly" src="image/Figure_06.2_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.28.1">Figure 6.2 – We can remove the port interfaces and call the services directly</span></p>
<p><span class="koboSpan" id="kobo.29.1">So why do we add another layer of indirection between the adapter and the use cases? </span><span class="koboSpan" id="kobo.29.2">The reason is that the ports are a specification of the places where the outside world can interact with our application core. </span><span class="koboSpan" id="kobo.29.3">By having ports in place, we know exactly which communication with the outside world takes place, which is valuable information for any maintenance engineer working on your legacy </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Knowing the ports that drive the application also lets us build a test driver for the application. </span><span class="koboSpan" id="kobo.31.2">This test driver is an adapter that calls the input ports to simulate and test certain usage scenarios – more about testing in </span><a href="B19916_08.xhtml#_idTextAnchor071"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.32.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.33.1">, </span><em class="itali"><span class="koboSpan" id="kobo.34.1">Testing </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.35.1">Architecture Elements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Having talked about the importance of input ports, one of the shortcuts we’ll talk about in </span><a href="B19916_11.xhtml#_idTextAnchor096"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.38.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.39.1">, </span><em class="itali"><span class="koboSpan" id="kobo.40.1">Taking Shortcuts Consciously</span></em><span class="koboSpan" id="kobo.41.1">, is just leaving the incoming ports out and calling the application </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">services directly.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">One</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.44.1"> question remains, though, which is relevant for highly interactive applications. </span><span class="koboSpan" id="kobo.44.2">Imagine a server application that sends real-time data to the user’s browser via WebSocket. </span><span class="koboSpan" id="kobo.44.3">How does the application core send this real-time data to the web adapter, which in turn sends it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">user’s browser?</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">For this scenario, we </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.47.1">definitely need a port because, without a port, the application would have to depend on an adapter implementation, breaking our efforts to keep the application free from dependencies on the outside. </span><span class="koboSpan" id="kobo.47.2">This port must be implemented by the web adapter and called by the application core, as depicted in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.48.1">Figure 6</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.49.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 6.3 – If an application must actively notify a web adapter, we need to go through an outgoing port to keep the dependencies in the right direction" src="image/Figure_06.3_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 6.3 – If an application must actively notify a web adapter, we need to go through an outgoing port to keep the dependencies in the right direction</span></p>
<p><span class="koboSpan" id="kobo.53.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.54.1">WebSocketController</span></strong><span class="koboSpan" id="kobo.55.1"> on the left implements the port interface in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.56.1">out</span></strong><span class="koboSpan" id="kobo.57.1"> package, and services in the application core can call this port to send real-time data to the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">user’s browser.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Technically speaking, this would be an outgoing port and make the web adapter an incoming and outgoing adapter. </span><span class="koboSpan" id="kobo.59.2">But there is no reason that the same adapter cannot be both at the same time. </span><span class="koboSpan" id="kobo.59.3">For the rest of this chapter, we’ll assume that the web adapter is an incoming adapter only since this is the most </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">common case.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.61.1">Responsibilities of a web adapter</span></h1>
<p><span class="koboSpan" id="kobo.62.1">What does </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.63.1">a web adapter actually do? </span><span class="koboSpan" id="kobo.63.2">Let’s say we want to provide a REST API for our BuckPal application. </span><span class="koboSpan" id="kobo.63.3">Where do the responsibilities of the web adapter start and where do </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">they end?</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">A web adapter usually does </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">these things:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.67.1">Maps the incoming HTTP request </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">to objects.</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">Performs </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">authorization checks.</span></span></li>
<li><span class="koboSpan" id="kobo.71.1">Validates </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">the input.</span></span></li>
<li><span class="koboSpan" id="kobo.73.1">Maps the request objects to the input model of the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">use case.</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">Calls the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">use case.</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">Maps the output of the use case back </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">to HTTP.</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">Returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">HTTP response.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.81.1">First of all, a web adapter must listen to HTTP requests that match certain criteria such as a URL path, HTTP method, and content type. </span><span class="koboSpan" id="kobo.81.2">The parameters and the content of a matching HTTP request must then be deserialized into objects we can </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">work with.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Commonly, a web adapter then does an authentication and authorization check and returns an error if </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">it fails.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">The state of the incoming objects can then be validated. </span><span class="koboSpan" id="kobo.85.2">But haven’t we already discussed input validation as a responsibility of the input model to the use cases? </span><span class="koboSpan" id="kobo.85.3">Yes, the input model to the use cases should only allow input that is valid in the context of the use cases. </span><span class="koboSpan" id="kobo.85.4">But here, we’re talking about the input model to the web adapter. </span><span class="koboSpan" id="kobo.85.5">It might have a completely different structure and semantics from the input model to the use cases, so we might have to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">different validations.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">I don’t advocate implementing the same validations in the web adapter as we have already done in the input model of the use cases. </span><span class="koboSpan" id="kobo.87.2">Instead, we should validate that we can transform the input model of the web adapter into the input model of the use cases. </span><span class="koboSpan" id="kobo.87.3">Anything that prevents us from doing this transformation is a </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">validation error.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">This brings us to the next responsibility of a web adapter: to call a certain use case with the transformed input model. </span><span class="koboSpan" id="kobo.89.2">The adapter then takes the output of the use case and serializes it into an HTTP response, which is sent back to </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the caller.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">If anything</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.92.1"> goes wrong on the way and an exception is thrown, the web adapter must translate the error into a message that is sent back to </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the caller.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">That’s a lot of responsibilities weighing on the shoulders of our web adapter. </span><span class="koboSpan" id="kobo.94.2">But it’s also a lot of responsibilities that the application layer should not be concerned with. </span><span class="koboSpan" id="kobo.94.3">Anything that has to do with HTTP must not leak into the application layer. </span><span class="koboSpan" id="kobo.94.4">If the application core knows that we’re dealing with HTTP on the outside, we have lost the option to perform the same domain logic from other incoming adapters that do not use HTTP. </span><span class="koboSpan" id="kobo.94.5">In a maintainable architecture, we want to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">options open.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Note that this boundary between the web adapter and application layer comes naturally if we start development with the domain and application layers instead of with the web layer. </span><span class="koboSpan" id="kobo.96.2">If we implement the use cases first, without thinking about any specific incoming adapter, we are not tempted to blur </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">the boundary.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.98.1">Slicing controllers</span></h1>
<p><span class="koboSpan" id="kobo.99.1">In most</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.100.1"> web frameworks – such as Spring MVC in the Java world – we create controller classes that perform the responsibilities we have discussed previously. </span><span class="koboSpan" id="kobo.100.2">So, do we build a single controller that answers all requests directed at our application? </span><span class="koboSpan" id="kobo.100.3">We don’t have to. </span><span class="koboSpan" id="kobo.100.4">A web adapter may certainly consist of more than </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">one class.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">We should take care, however, to put these classes into the same package hierarchy to mark them as belonging together, as discussed in </span><a href="B19916_04.xhtml#_idTextAnchor037"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.103.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.104.1">, </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.105.1">Organizing Code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">So, how many controllers do we build? </span><span class="koboSpan" id="kobo.107.2">I say we should rather build too many than too few. </span><span class="koboSpan" id="kobo.107.3">We should make sure that each controller implements a slice of the web adapter that is as narrow as possible and that shares as little as possible with </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">other controllers.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Let’s take the operations on an account entity within our BuckPal application. </span><span class="koboSpan" id="kobo.109.2">A popular approach is to create a single </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.110.1">AccountController</span></strong><span class="koboSpan" id="kobo.111.1"> that accepts requests for all operations that relate </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">to accounts.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">A Spring controller </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.114.1">providing a REST API </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.115.1">might look like the following </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">code snippet:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.117.1"><img alt="" src="image/code-6.1.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.118.1">Everything concerning the account resource is in a single class, which feels good. </span><span class="koboSpan" id="kobo.118.2">But let’s discuss the downsides of </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">this approach.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">First, less code </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.121.1">per class is a good thing. </span><span class="koboSpan" id="kobo.121.2">I have worked on a legacy project where the largest class had 30,000 lines of code.</span><span id="footnote-022-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-022"><span class="koboSpan" id="kobo.122.1">1</span></a></span><span class="supers ript"> </span><span class="koboSpan" id="kobo.123.1">That’s no fun. </span><span class="koboSpan" id="kobo.123.2">Even if the controller only accumulates 200 lines of code over the years, it’s still harder to grasp than 50 lines, even when it’s cleanly separated </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">into methods.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-022">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-022-backlink"><span class="koboSpan" id="kobo.125.1">1</span></a><span class="koboSpan" id="kobo.126.1">	30,000 lines of code: it was actually a conscious architecture decision (by our predecessors, mind you) that lead to those 30,000 lines being in a single class: to change the system at runtime, without re-deployment, it allowed them to upload compiled Java bytecode in a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.127.1">.class</span></strong><span class="koboSpan" id="kobo.128.1"> file. </span><span class="koboSpan" id="kobo.128.2">And it only allowed them to upload a single file, so this file had to contain all </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the code.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.130.1">The same argument is valid for test code. </span><span class="koboSpan" id="kobo.130.2">If the controller itself has a lot of code, there will be a lot of test code. </span><span class="koboSpan" id="kobo.130.3">And often, test code is even harder to grasp than production code because it tends to be more abstract. </span><span class="koboSpan" id="kobo.130.4">We also want to make the tests for a certain piece of production code to be easy to find, which is easier in </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">small classes.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Equally important, however, is that putting all operations into a single controller class encourages the reuse of data structures. </span><span class="koboSpan" id="kobo.132.2">In the preceding code example, many operations share the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.133.1">AccountResource</span></strong><span class="koboSpan" id="kobo.134.1"> model class. </span><span class="koboSpan" id="kobo.134.2">It serves as a bucket for everything that is needed in any of the operations. </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.135.1">AccountResource</span></strong><span class="koboSpan" id="kobo.136.1"> probably has an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.137.1">id</span></strong><span class="koboSpan" id="kobo.138.1"> field. </span><span class="koboSpan" id="kobo.138.2">This is not needed in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.139.1">create</span></strong><span class="koboSpan" id="kobo.140.1"> operation and will probably confuse here more than it will help. </span><span class="koboSpan" id="kobo.140.2">Imagine that an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.141.1">Account</span></strong><span class="koboSpan" id="kobo.142.1"> has a one-to-many relationship with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.143.1">User</span></strong><span class="koboSpan" id="kobo.144.1"> objects. </span><span class="koboSpan" id="kobo.144.2">Do we include those </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.145.1">User</span></strong><span class="koboSpan" id="kobo.146.1"> objects when creating or updating an account? </span><span class="koboSpan" id="kobo.146.2">Will the users be returned by the list operation? </span><span class="koboSpan" id="kobo.146.3">This is an easy example, but in any above-play-size project, we’ll ask these questions at </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">some point.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">So, I advocate the approach to create a separate controller, potentially in a separate package, for each operation. </span><span class="koboSpan" id="kobo.148.2">Also, we should name the methods and classes as close to our use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">as possible:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.150.1"><img alt="" src="image/code-6.2.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.151.1">We can take primitives as input, as we did with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.152.1">sourceAccountId</span></strong><span class="koboSpan" id="kobo.153.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.154.1">targetAccountId</span></strong><span class="koboSpan" id="kobo.155.1">, and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.156.1">amount</span></strong><span class="koboSpan" id="kobo.157.1"> in the example. </span><span class="koboSpan" id="kobo.157.2">But each controller can also have its own input model. </span><span class="koboSpan" id="kobo.157.3">Instead of a generic model such as </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.158.1">AccountResource</span></strong><span class="koboSpan" id="kobo.159.1">, we might then</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.160.1"> have a model specific to the use case such as </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.161.1">CreateAccountResource</span></strong><span class="koboSpan" id="kobo.162.1"> or </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.163.1">UpdateAccountResource</span></strong><span class="koboSpan" id="kobo.164.1">. </span><span class="koboSpan" id="kobo.164.2">Those specialized model classes may even be private to the controller’s package to prevent accidental reuse. </span><span class="koboSpan" id="kobo.164.3">Controllers may still share models, but using shared classes from another package makes us think about it more and perhaps we will find out that we don’t need half of the fields and will create our own, </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">after all.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Also, we should think hard about the names of the controllers and services. </span><span class="koboSpan" id="kobo.166.2">Instead of </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.167.1">CreateAccount</span></strong><span class="koboSpan" id="kobo.168.1">, for instance, wouldn’t </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.169.1">RegisterAccount</span></strong><span class="koboSpan" id="kobo.170.1"> be a better name? </span><span class="koboSpan" id="kobo.170.2">In our BuckPal application, the only way to create an account is for a user to register it. </span><span class="koboSpan" id="kobo.170.3">So, we use the word “register” in class names to better convey their meaning. </span><span class="koboSpan" id="kobo.170.4">There are certainly cases where the usual suspects (</span><strong class="sour e-inline"><span class="koboSpan" id="kobo.171.1">Create...</span></strong><span class="koboSpan" id="kobo.172.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.173.1">Update...</span></strong><span class="koboSpan" id="kobo.174.1">, and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.175.1">Delete...</span></strong><span class="koboSpan" id="kobo.176.1">) sufficiently describe a use case, but we might want to think twice before actually </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">using them.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Another benefit of this slicing style is that it makes parallel work on different operations a breeze. </span><span class="koboSpan" id="kobo.178.2">We won’t </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.179.1">have merge conflicts if two developers work on </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">different operations.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.181.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.182.1">When building a web adapter to an application, we should keep in mind that we’re building an adapter that translates the HTTP protocol to method calls on the use cases of our application, translates the results back to HTTP, and does not do any </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">domain logic.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The application layer, on the other hand, should not do HTTP, so we should make sure not to leak HTTP details. </span><span class="koboSpan" id="kobo.184.2">This makes the web adapter replaceable with another adapter should the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">need arise.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">When slicing web controllers, we should not be afraid to build many small classes that don’t share a model. </span><span class="koboSpan" id="kobo.186.2">They’re easier to grasp and test, and they support parallel work. </span><span class="koboSpan" id="kobo.186.3">It’s more work initially to set up such fine-grained controllers, but it will pay off </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">during maintenance.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Having looked at the incoming side of our application, we’ll now take a look at the outgoing side and how to implement a </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">persistence adapter.</span></span></p>
</div>
</body></html>