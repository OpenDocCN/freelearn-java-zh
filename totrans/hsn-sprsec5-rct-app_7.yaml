- en: Spring Security Add-Ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we covered the implementation details of the multiple
    ways in which core security aspects, such as authentication and authorization,
    use Spring Security. In doing so, we just skimmed over a very thin layer of the
    capabilities that can be achieved using Spring Security. In this chapter, we will
    cover some other capabilities provided by Spring Security in a concise manner.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the chapter introduces many products (open source and paid versions)
    that can be considered for use along with Spring Security. I am not backing any
    of these products, but I do consider them strong contenders for achieving the
    technical capabilities that you are looking for. We will start off introducing
    a product by giving a gist of the technical capability that we need to address,
    then introduce you briefly to the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Remember-me authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CORS Support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Crypto module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Data Integrity Validator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember-me authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be reusing and enhancing the example that we built in [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security* (`jetty-db-basic-authentication`), to explain how
    Spring Security can be used to achieve remember me, or persistent login, functionality.
    In the example that we are going to reuse, we have used basic authentication,
    in which user credentials are stored in a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Remember me functionality is achieved in Spring Security by sending cookies
    to the browser when the user chooses to remember his/her credentials on the client
    side. The cookie can be configured to be stored in the browser for a stipulated
    time. If the cookie exists and is valid, the next time the user accesses the application,
    they are taken straight to the user's home page and avoid explicit authentication
    with a username/password combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember me functionality can be achieved using two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash-based tokens**: Username, expiry time, password, and a private key are
    hashed and send to the client as a token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent tokens**: A persistent storage mechanism is used to store the
    token on the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now go through a simple implementation of the persistent token approach
    to explain this concept in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new table in MySQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the same schema as the MySQL DB that we used in [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*. Keep everything as is, and then create a new table
    in the MySQL database for storing persistent tokens by executing the following
    DDL statement in the MySQL workbench:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Spring Security configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep Diving into
    Spring Security* (in the Spring Security setup sub-section of the `Sample` application
    section), we saw basic authentication, which we configured in our configure method
    in the Spring Security Configuration class. In this example, we will create a
    custom login page and change the login mechanism to form-based. Open the `SpringSecurityConfig`
    class and change the configure method, as shown in the following code snippet.
    Then, add the `tokenRepository` bean that we are going to use to accomplish remember
    me functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The custom login page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new page, namely `login.jsp` in the `src/main/webapp/WEB-INF/view`
    folder. The main section of the page, containing the `username`, `password`, and
    `rememberme` fields, is as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you name the remember me checkbox the same as you specified in
    the Spring Security configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the project by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the console to print [INFO] Started Jetty Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a browser (I use Firefox in private mode for testing) and navigate to
    `http://localhost:8080`, and you will be shown the custom login page that you
    created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08fa314d-719a-44ba-935e-2b5ec788d304.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: The custom login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `user`/`user@password` as the username and password. Click on `Remember
    me` and click the `Login` button, and you will be navigated to the user home page,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb50890a-9b60-47b6-b8f9-e6b253f303bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: User home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Query your MySQL database for the `persistent_logins` table, and you will see
    a new record, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/973617d1-af29-4ebf-999a-eee1c92e9ea9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: MySQLWorkbench querying new persistent_logins table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to the developer tools in your browser and check for cookies. Depending
    on the browser that you are using, you should see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4f15410-f35e-481e-8f6b-21f82a4ef7af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Browser cookie set to achieve remember-me functionality'
  prefs: []
  type: TYPE_NORMAL
- en: The entire project for this example can be found at the book’s GitHub page in
    the `jetty-db-basic-authentication-remember-me` project.
  prefs: []
  type: TYPE_NORMAL
- en: Session management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security allows you to manage sessions on your server with only some
    configuration. Some of the most important session management activities are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session creation**: This decides when a session needs to be created and the
    ways in which you can interact with it. In the Spring Security configuration,
    put in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four session creation policies that you can choose from. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ALWAYS`: Always create a session if it doesn''t exist.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IF_REQUIRED`: If required, a session is created.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NEVER`: This will never create a session; rather, it will use the session
    if it exists.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATELESS`: No session will be created nor used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalidSession`: This controls how the user is intimated if the server sees
    an invalid session:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Session timeout**: This controls how the user is intimated if the session
    has expired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent session**: This allows control over how many sessions a user can
    start in an application. If the maximum sessions is set as `1`, when the user
    logs in for the second time, the previous session is invalidated and the user
    is logged out. If the value specified is greater than `1`, the user is allowed
    to have that many sessions concurrently:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the default error screen, that pops up when
    more than the desired amount of sessions (as configured) are created by the same
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a56b4b3d-0c1a-4b4f-8212-066588d543ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Error thrown when a user accesses multiple sessions'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session fixation**: This is very similar to concurrent session control. This
    setting allows us to control what will happen when a new session is initiated
    by a user. We can specify the following three values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`migrateSession`: On the creation of a new session after successful authentication,
    the old session is invalidated and all attributes are copied to the new session:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`newSession`: A new session is created without copying any of the attributes
    from the previous valid session:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`none`: The old session is reused and is not invalidated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: CSRF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery** (**CSRF**) ([https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)))
    is an attack that forces an end user to execute unwanted actions on a web application
    in which they''re currently authenticated. CSRF attacks specifically target state-changing
    requests, not theft of data, since the attacker has no way to see the response
    to the forged request.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Open Web Application Security Project** (**OWASP**) considers CSRF as
    one of the most common security risks for web applications. OWASP publishes a
    list (known as the OWASP Top 10) every year, highlighting the top 10 security
    risks plaguing web applications—it considers CSRF to be in fifth position.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Spring Security, CSRF is enabled by default. If needs be (we have disabled
    this in many of our examples so that we are able to concentrate on the main concept
    that the examples are supposed to convey), we can disable it explicitly by adding
    the following code snippet in your Spring Security configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though CSRF is enabled by default, for it to function, each request needs
    to provide a CSRF token. If a CSRF token is not sent across to the server, the
    server will reject the request and throw an error. If you are using **Java Server
    Page** (**JSP**) as your view, just by including hidden input, as shown in the
    following code snippet, many things would happen auto-magically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using an AJAX request to call a server, instead of hidden input,
    you can supply the CSRF token in the form of an HTTP header. You can declare the
    CSRF-related header as meta tags, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After that, while calling the server, include these (`_csrf` and `_csrf_header`)
    as headers and you will be allowed to call the required endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to persist the CSRF token, Spring Security allows you to
    do this by tweaking the configuration as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While doing this, the CSRF token is persisted as a cookie, which can be read
    by the server and validated (all done auto-magically).
  prefs: []
  type: TYPE_NORMAL
- en: CSP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Content Security Policy** (**CSP**) ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP))
    is an added layer of security that helps to detect and mitigate certain types
    of attacks, including **Cross Site Scripting** (**XSS**) and data injection attacks.
    These attacks are used for everything from data theft to site defacement or distribution
    of malware.'
  prefs: []
  type: TYPE_NORMAL
- en: A proper CSP setup in your application can handle content injection vulnerabilities,
    and is a great way to reduce XSS. XSS stands at number two in the OWASP Top 10.
  prefs: []
  type: TYPE_NORMAL
- en: A CSP is not a solution to handling all injection vulnerabilities, but can be
    used as one of the tools to reduce injection attacks to a reasonable level.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSP is a declarative policy, implemented using HTTP headers. It can be run
    in an application in two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Production mode (declared as CSP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Report-only mode (used for testing and are declared as *Content-Security-Policy-Report-Only*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSP contains a set of security policy directives responsible for putting appropriate
    restrictions on a web resource and then informing the client (user agent) accordingly
    when breached. For example, the following security policy snippet loads scripts
    from the defined trusted domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If there''s a breach, the user agent will block it, and if the policy specifies
    a `report-uri` parameter, as shown in the following example, it will report the
    violation in the form of JSON to that URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous examples showcase CSP working in production mode. If you would
    like to first test the security policy and after a particular period of time make
    those policies in production mode, CSP provides a mechanism for that, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In report-only mode, when a breach is detected, the report is posted to the
    `report-uri` in JSON format, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the security directives detailed in the preceding examples, there
    are a number of security directives that can be used while setting up your CSP.
    For a full list of directives, please refer to [https://content-security-policy.com/](https://content-security-policy.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way to CSRF tokens, CSP can also be used to make sure that specific
    resources contain a token while accessing the server. The following example shows
    the use of this nonce approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Similar to a CSRF token, this nonce has to be included along with any resource
    access in the server, and this has to be newly generated while a page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSP also allows you to load the resources only if they match the hash that
    the server expects. The following policy is used to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: CSP is supported by almost all modern browsers. Even if some security directives
    are not supported by certain browsers, other supported directives will work without
    any problem. The best way to handle that is to send only the security directives
    that will definitely be supported by the browser by deciphering the user agent,
    rather than throwing errors on the client.
  prefs: []
  type: TYPE_NORMAL
- en: CSP using Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuring CSP using Spring Security configuration is a breeze. By default,
    CSP is not enabled. You can enable it in Spring Security configuration, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The report-only CSP in the Spring Security configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Channel security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to authentication and authorization, Spring Security can also be
    used to check for any additional property presence for each request reaching the
    server. It can check for protocol (transport type, HTTP, or HTTPS), presence of
    certain HTTP headers, and more. SSL is now the de facto standard for any web application
    (or website) to comply with, and many search engines (such as Google, for example)
    even penalize you if your website is not HTTPS. SSL is made use of in securing
    the channel on which data flows from client to server and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security can be configured to explicitly check for URL patterns and explicitly
    redirect the user to HTTPS if they are coming with the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be easily done by configuring the appropriate URL pattern in your
    Spring Security configuration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When users access the `/httpsRequired/**` URL pattern and if the protocol is
    HTTP, Spring Security will redirect the user to the same URL with the HTTPS protocol.
    The following configuration is used to secure all requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To explicitly mention certain URLs as insecure, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows how to specify any request to be HTTP (insecure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: CORS Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**) ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))
    is a mechanism that uses additional HTTP headers to tell a browser to let a web
    application running at one origin (domain) have permission to access selected
    resources from a server at a different origin. A web application makes a cross-origin
    HTTP request when it requests a resource that has a different origin (domain,
    protocol, and port) than its own origin.'
  prefs: []
  type: TYPE_NORMAL
- en: We won't be creating full-fledged projects in this section to explain the working
    of CORS. We will use code snippets and will explain each bit of code so that the
    section is concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your Spring Security configuration, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we configure CORS in the Spring Security `configure`
    method. We then create a new bean, `corsConfigurationSource`, in which we enable
    the `*/***` path to be accessible by other domains. This is not really ideal in
    many scenarios, and the following code snippet shows the more enhanced `CorsConfiguration`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is a Spring MVC application, you can have a Spring MVC configuration
    file in which you can specify CORS mapping by creating a bean, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I have copied a previous example from [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*, and created a new project in this chapter, containing
    full source code in `spring-boot-in-memory-basic-authentication-with-cors`. What
    we have done here is set the CORS global configuration by declaring the `CorsConfigurationSource`
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: The Crypto module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Security Crypto module allows you to do password encoding, symmetric
    encryption, and key generation. The module is bundled as part of the core Spring
    Security offering with no dependency upon other Spring Security code.
  prefs: []
  type: TYPE_NORMAL
- en: Password encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modernized password encoding is one of the new features of Spring Security
    5\. Spring Security''s `PasswordEncoder` interface is central to it and does one-way
    hashing of passwords using various algorithms, which can then be stored securely.
    Spring Security supports a number of password-encoding algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BcryptPasswordEncoder`: This uses the Bcrypt strong hash function. You can
    optionally supply the strength parameter (default value is 10); the higher the
    value, the more work has to be done to hash the password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pbkdf2PasswordEncoder`: This uses **Password-Based Key Derivation Function
    2** (**PKDF2**) with a configurable number of iterations and an 8-byte random
    salt value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScryptPasswordEncoder`: This uses the Scrypt hashing function. While hashing,
    clients can supply a CPU cost parameter, a memory cost parameter, and a parallelization
    parameter. The current implementation uses the Bouncy Castle library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security''s `org.springframework.security.crypto.encrypt.Encryptors`
    class has factory methods that can be used to create symmetric encryptors. The
    class supports two encryptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BytesEncryptor`: The service interface for symmetric data encryption of data
    in the form of raw byte arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextEncryptor`: The service interface for symmetric data encryption of text
    strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0a10170e-1db7-4e62-81fe-4c5ed66c830f.png)'
  prefs: []
  type: TYPE_IMG
- en: Key generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen in the previous section on encryption, Spring Security has a class,
    namely `org.springframework.security.crypto.keygen.KeyGenerators`, that has a
    number of factory methods that can used to construct a number of keys needed for
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two supported types of key generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BytesKeyGenerator`: The generator for generating unique byte array-based keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringKeyGenerator`: The generator for unique string keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/50f4bea4-d4a6-447c-be97-1a746f3a7d4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: The BytesKeyGenerator and StringKeyGenerator factory methods'
  prefs: []
  type: TYPE_NORMAL
- en: Secret management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an application, we need to handle a variety of secret/secure data in the
    form of API keys, other application passwords, and more. Often, for an application
    deployed and running in a production environment, keeping these in plain text
    can result in security breaches. With automation up for grabs quite cheaply nowadays,
    for modern applications, storing such data securely with access control and secure
    storage is a must.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption is something that has been widely embraced, but for decryption, a
    key needs to be circulated, and this circulation of the key is usually a big problem.
    If a person decides to take the key outside of the organization, there can be
    serious problems.
  prefs: []
  type: TYPE_NORMAL
- en: Vault from HashiCorp is a very strong contender as a solution to this issue,
    and helps in managing these secrets easily with very rigid controls. It provides
    APIs that give access based on set policies. It also has the capability to provide
    access control, and it also comes with encryption functionality out of box. In
    addition, it has a variety of persistent backend supports, such as Consul (from
    HashiCorp), and more, making it easy for enterprises to adopt it. Vault is written
    in Go and has binaries available for many platforms, and can be downloaded from
    its website. In this section, we will quickly run you through the Vault product
    itself, and then go through an example in which we will create a Spring Boot project
    and securely access some of the secrets stored in the Vault. Without further ado,
    let's get our hands dirty with actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Starting by unsealing Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the latest binary from the Vault project''s website ([https://www.vaultproject.io/downloads.html](https://www.vaultproject.io/downloads.html)),
    according to your operating system, and install it. To start Vault, you need to
    have a file—`vault.conf`—in which we will specify some of the options that are
    needed for Vault to start. Here is a sample `vault.conf` file that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the `vault.conf` file, we explicitly set the address that it will listen
    to and also disable TLS/SSL (so that it runs in plain text mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Vault by specifying the location of the `vault.conf` file with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the screenshot below, Vault is running in plain text mode
    (with TLS/SSL disabled):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aa8b640-96ed-40d7-bcf8-b5bc1dbc50fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Starting and configuring Vault'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command prompt, which is where we will now start administering Vault.
    Set an environment variable by executing the following command to let the clients
    know that they have to use plain text to connect to Vault (as we have disabled
    TLS/SSL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, initialize Vault key generation by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49566220-3be6-4426-9f52-7bd0b97fef42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Initializing Vault'
  prefs: []
  type: TYPE_NORMAL
- en: The command that we have used gave us five key shares and a key threshold of
    two. It's important to note that we cannot change these values once Vault is initialized
    (output is shown only once). Be careful to gather the necessary information; otherwise,
    you will not be able to retrieve any data stored in Vault. As you can see from
    the preceding screenshot, the `init` command of Vault gives us the keys and token
    that are needed to unseal Vault. Before we can use Vault, it has to be unsealed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unsealing** ([https://www.vaultproject.io/docs/concepts/seal.html](https://www.vaultproject.io/docs/concepts/seal.html)) is
    the process of constructing the master key necessary to read the decryption key
    to decrypt the data, allowing access to the Vault. Prior to unsealing, almost
    no operations are possible with Vault.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can unseal Vault by executing the following command and providing any of
    the keys generated during the Vault initialization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the successful execution of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1a8f86b-355d-4c7e-8cca-d7bc68756af3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Unsealing Vault'
  prefs: []
  type: TYPE_NORMAL
- en: Once it is unsealed, your Vault is now ready to store the secret data that you
    may want to use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have successfully unsealed Vault, to store any data, you first need
    to authenticate. When we initialized Vault, we were shown a token (on the screen),
    and this token is used to authenticate. One of the easiest ways to achieve authentication
    using this token is to set up a new environment variable (`VAULT_TOKEN`). Execute
    the following command as shown, and when Vault starts, it will make use of this
    environment variable and authenticate itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command is executed, you can now write your secret by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After you enter the command, you should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8663c6c-36f8-4f51-9e57-e5605f5ad26e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: Writing a secret to your Vault'
  prefs: []
  type: TYPE_NORMAL
- en: Tokens are the primary way in which authentication is done in Vault. Besides
    that, there are other mechanisms, such as LDAP and username/password, with which
    authentication can be done.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring has a dedicated module, called Spring Cloud Vault, that makes use of
    Vault in your application a breeze. Spring Cloud Vault is very easy to use, and
    we will be covering how to use it in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud Vault Config** ([http://cloud.spring.io/spring-cloud-vault/](http://cloud.spring.io/spring-cloud-vault/))
    provides client-side support for externalized configuration in a distributed system.
    With HashiCorp''s Vault you have a central place to manage external secret properties
    for applications across all environments. Vault can manage static and dynamic
    secrets such as username/password for remote applications/resources and provide
    credentials for external services such as MySQL, PostgreSQL, Apache Cassandra,
    MongoDB, Consul, AWS, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the Spring Boot project (generated using Spring Initializr,
    [https://start.spring.io](https://start.spring.io)). At the start of the application,
    Vault is started and all the secrets are picked up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef82792e-746b-438b-9813-4fb8a1b0ffbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: Creation of an empty Spring Initializr project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unzip the downloaded Spring Initializr project by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Import the project in your favorite IDE (I am using IntelliJ).
  prefs: []
  type: TYPE_NORMAL
- en: The Maven dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure that your project''s `pom.xml` has the following Maven dependency
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When the Spring Boot project starts, it will pick the default Vault configuration
    if the Vault server is running on port `8200`. If you want to customize these
    properties, you can specify `bootstrap.yml` or `bootstrap.properties`. In our
    example, we will explicitly set the `bootstrap.yml` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the HTTP scheme, as we started Vault in plain text mode. If
    you would like to use HTTPS, it's quite easy to do so, as most things are done
    through scripts already provided. This is the default scheme in which Vault runs,
    and this is how it has to be in the production setup. Let's understand this concept
    first before going into a bit more depth when you implement the actual use case.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to run Vault in the HTTPS scheme, Spring Cloud Vault has a
    number of scripts available in its source code under `src/test/bash` ([https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash](https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash))
    that can be used to create the necessary certificates and then run Vault in this
    scheme. To keep this section concise, we won't be covering this aspect in much
    more detail here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `.yml` file, we have used the root token that was created as part of
    the initialization of Vault. If you need to, you can get a new token by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the successful execution of the `token create`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82e4a39d-39fb-4181-8952-d676cbe990e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: New Vault token creation'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Spring Boot project, add the following code snippet in your application
    run class, `SpringBootSpringCloudVaultApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `password` field will be filled by Spring Cloud Vault, and
    if you run the application (using command `mvn spring-boot:run`), you should see
    that Spring Cloud Vault connects to the running Vault (using the configuration
    in the `bootstrap.yml` file) and retrieves the value that we wrote to Vault for
    `movie-application`.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our look at a base application using Spring Boot and Spring Cloud
    Vault. You can see the full source in the book's GitHub page in the project under
    this chapter, named `spring-boot-spring-cloud-vault`.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Data Integrity Validator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security aids us in enriching our application with common security features,
    allowing us to do so very easily and with minimal code. However, Spring Security
    is slowly and steadily catching up with many of the additional security features
    needed in modern applications. Most of these applications are deployed on the
    cloud and have very high rates of changes pushed to production on a day-to-day
    basis. **HTTP Data Integrity Validator** (**HDIV**) is a product that can be used
    to further enrich your application security.
  prefs: []
  type: TYPE_NORMAL
- en: What is HDIV?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HDIV was originally born as an open source project when it was developed by
    Roberto Velasco, Gotzon Illarramendi, and Gorka Vicente to confront security issues
    detected in production environments. The first stable Version 1.0 was released
    in 2008, in the form of a security library to be integrated within web applications.
    HDIV was officially integrated with Spring MVC, the most-used Java solution for
    web application development in 2011\. In 2012, HDIV was integrated with Grails.
    In 2015, HDIV was included within Spring Framework official documentation as a
    solution related to web security. Based on global interest and responding to high
    market demand, the creators founded the **HDIV Security **([https://hdivsecurity.com/](https://hdivsecurity.com/))
    company and launched the commercial version of HDIV in 2016\. HDIV solutions are
    built into applications during development to deliver the strongest available
    **Runtime Application Self Protection** (**RASP**) against the OWASP Top 10 threats.
  prefs: []
  type: TYPE_NORMAL
- en: HDIV was born to protect applications against parameter-tampering attacks. Its
    first purpose (looking at the acronym) was to guarantee the integrity (no data
    modification) of all the data generated by the server (links, hidden fields, combo
    values, radio buttons, destiny pages, cookies, headers, and more). HDIV extends
    a web application's behavior by adding security functionalities, as well as maintaining
    the API and the framework specification. HDIV gradually incorporated capabilities
    such as CSRF, **SQL Injection** (**SQLi**), and XSS protection, thus offering
    greatly increased security and being more than just an HTTP data integrity validator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attacks are becoming lower in cost and more automated. Manual security testing
    is becoming a costly bottleneck. Spring Security protects the application by easily
    implementing the most important security aspects, such as authentication and authorization,
    but does not protect from common security bugs and design flaws in your application
    code. This is where integrating a Spring application that is already secured using
    Spring Security can bring in HDIV. We will be going through a very simple example,
    which will showcase a few of the areas where HDIV shines. Here are some of those
    advantages, as detailed by their website:'
  prefs: []
  type: TYPE_NORMAL
- en: HDIV detects security bugs in source code before it is exploited, using a runtime
    dataflow technique to report the file and line number of the vulnerability. Reporting
    is immediate to developers during the development process either within the web
    browser or within a centralized web console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It protects from business logic flaws with no need to learn applications and
    offers detection and protection from security bugs without changing the source
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HDIV makes integration possible between the pen-testing tool (Burp Suite) and
    the application, communicating valuable information to the pen-tester. It avoids
    many hand-coded steps, focusing the attention and effort of pen-testers on the
    most vulnerable entry points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information, you can check the following link: [https://hdivsecurity.com/](https://hdivsecurity.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start building a simple example that showcases the protection that HDIV
    does by protecting links and form data in your application.
  prefs: []
  type: TYPE_NORMAL
- en: The Bootstrap project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using a base project created out of Spring Initializr for creating
    our HDIV sample, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cda8ae32-ec39-4227-8761-4f613e718a7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: Basic Spring Initializr project setup'
  prefs: []
  type: TYPE_NORMAL
- en: Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are calling out explicit dependency that we need
    as part of this project, which is HDIV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: HDIV has support for a number of web application frameworks. In our example,
    we'll be using Spring MVC along with Thymeleaf and above mentioned dependency
    takes care of this.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you will already know what goes in the Spring Security configuration
    file. We will have in-memory authentication and will be configuring two users
    (similar to what we have been doing all throughout this book). We will have form-based
    login and also will be creating our own login page.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring MVC configuration that we have been looking at so far is very basic.
    There isn't anything worth a special mention here. We will just need to ensure
    that the controller attached to the login page is explicitly defined.
  prefs: []
  type: TYPE_NORMAL
- en: HDIV configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This magic class will bring in HDIV capability to your application without
    too much trouble. The full class is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The heavy lifting is done by the class that we are extending, `HdivWebSecurityConfigurerAdapter`.
    Also, the `@EnableHdivWebSecurity` annotation makes sure that much of the setup
    is automatically taken care of. We just need to make sure that the configuration
    of our login page URL is excluded from HDIV security by overriding the `addExclusions`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The Model class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the same model class we have been using throughout this book—`Movie`.
    To ease coding, we will be using the Lombok library, which does all the magic
    by looking at the various annotations configured in the class.
  prefs: []
  type: TYPE_NORMAL
- en: The Controller class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will just have one controller class, where we will map all the pages that
    we are going to create in this example. To showcase the power of HDIV, we will
    see HDIV in action for two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A movie creation page (movie bean), showing HDIV at work in a page containing
    a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A links page that shows HDIV intercepting and throwing errors when someone manipulates
    the actual link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class is quite straightforward and doesn't need to be detailed here.
  prefs: []
  type: TYPE_NORMAL
- en: Pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, we will have the following pages created in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`login.html`: The custom login page that we will use for users to log in to
    the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.html`: The page that the user navigates to after successful login, containing
    links to the movie creation and links pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`links.html`: The page that the user is navigated to when they click on the
    links URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie.html`: The movie creation page, containing two fields—title and genre'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the application just like any other Spring Boot project by executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to a browser and navigate to `http://localhost:8080` and you will be presented
    with a login page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0bf4a33-f46f-439f-896a-1f910bb133b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: Login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, enter the `username`/`password` and click
    on the Login button, and you will be navigated to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7dd816-60cf-422f-b918-c9476182fbc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16: The home page, which is presented to the user after successful login'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the link to navigate to the page where you can create a new movie.
    You will be navigated to the page shown in the following screenshot. Look closely
    at the URL and you will see a new query parameter has been added, `_HDIV_STATE_`.
    The server validates and ensures that the submitted form is genuine by looking
    at that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3f55fb0-c2d2-4093-84b1-bced8cdfa19d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17: The Create Movie screen, showing off the _HDIV_STATE_ query string'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go back to the home page and click on the links page. You will be navigated
    to the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b408edd-622f-4516-9f9a-6eb4349414d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18: The links page, showing the _HDIV_STATE_ query string'
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated in the page, try manipulating the link (change the `_HDIV_STATE_`
    value) and you will be taken to the HDIV error page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0823acb2-e4c4-4bce-a081-d1fdc3ed267e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19: The HDIV error page, which displays in the case of error conditions'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example showcases just two of the cases where HDIV shows its worth when
    working alongside Spring Security. For more details, I urge you to look at the
    HDIV website and documentation, which is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hdivsecurity.com/docs/](https://hdivsecurity.com/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://hdivsecurity.com/docs/installation/library-setup/](https://hdivsecurity.com/docs/installation/library-setup/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/hdiv/hdiv](https://github.com/hdiv/hdiv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security allows you to write your own **Domain Specific Language** (**DSL**),
    which can be used to configure security in your application. We have already seen
    a custom DSL in action when we implemented SAML authentication using OKTA. We
    used an OKTA-provided custom DSL to configure Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write your own custom DSL, you can extend the `AbstractHttpConfigurer` *class *and
    override a few of it''s methods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In your Spring Security configuration class (the configure method), you can
    then use your custom DSL, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When Spring Security sees a custom DSL setup, the execution of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke the Spring Security configuration class's `configure` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the custom DSL `init` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the custom DSL `configure` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Security uses this approach to implement `authorizeRequests()`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to some of the other capabilities of Spring Security
    that can be used in your application. Using examples, we covered how to achieve
    remember-me functionality in your application. We also touched briefly upon concepts
    such as CSRF, CORS, CSP, channel security, and session management. We also covered
    the Crypto module in Spring Security concisely.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped up the chapter by introducing two products that can work along with
    Spring Security—HashiCorp Vault (for secret management) and HDIV (for additional
    security features).
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should have a clear understanding of some of
    the additional features that can be implemented using Spring Security. You should
    also have a good understanding of some of the products that can be used alongside
    Spring Security to achieve some of the most important technical capabilities that
    are needed for modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, pat yourself your back if you are reading this, as with this chapter, we
    complete the book. I hope you have enjoyed every bit of this book, and I hope
    you have learned something new that can be used for creating  wonderful and innovative
    new applications.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading!
  prefs: []
  type: TYPE_NORMAL
