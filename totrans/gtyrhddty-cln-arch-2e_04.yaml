- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Organizing Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织
- en: Wouldn’t it be nice to recognize the architecture just by looking at the code?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 只需通过查看代码就能识别架构，这不是很好吗？
- en: In this chapter, we’ll examine different ways of organizing code and introduce
    an expressive package structure that directly reflects a Hexagonal Architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的代码组织方法，并介绍一种直接反映六边形架构的表达式包结构。
- en: In greenfield software projects, the first thing we try to get right is the
    package structure. We set up a nice-looking structure that we intend to use for
    the rest of the project. Then, during the project, things become hectic, and we
    realize that in many places the package structure is just a nice-looking facade
    for an unstructured mess of code. Classes in one package import classes from other
    packages that should not be imported.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在绿色软件项目中，我们首先试图做对的事情是包结构。我们设置了一个看起来很不错的结构，打算在整个项目中使用。然后，在项目进行中，事情变得繁忙，我们意识到在许多地方，包结构只是无序代码混乱的一个漂亮门面。一个包中的类导入其他包中的类，而这些类本不应该被导入。
- en: We’ll discuss different options for structuring the code of the BuckPal example
    application that was introduced in the *Preface*. More specifically, we’ll look
    at the *Send money* use case, which allows a user to transfer money from their
    account to another.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论BuckPal示例应用程序的结构化选项，该应用程序在*前言*中介绍。更具体地说，我们将查看*发送金钱*用例，它允许用户将资金从他们的账户转移到另一个账户。
- en: Organizing By Layer
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层组织
- en: 'The first approach to organizing our code is by layer. We might organize the
    code like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组织代码的第一个方法是按层。我们可能会这样组织代码：
- en: '![](img/code-4.1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-4.1.jpg)'
- en: For each of our layers – `web`, `domain`, and `persistence` – we have a dedicated
    package. As discussed in [*Chapter 2*](B19916_04.xhtml), *What’s Wrong with Layers?*,
    simple layers may not be the best structure for our code for several reasons,
    so we have already applied the `domain` package. We did this by introducing the
    `AccountRepository` interface in the `domain` package and implementing it in the
    `persistence` package.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的每一层——`web`、`domain`和`persistence`——我们都有一个专门的包。如[*第2章*](B19916_04.xhtml)中讨论的，*层有什么问题？*，简单的层可能不是我们代码的最佳结构，有多个原因，因此我们已应用了`domain`包。我们通过在`domain`包中引入`AccountRepository`接口并在`persistence`包中实现它来做到这一点。
- en: 'We can find at least three reasons why this package structure is suboptimal,
    however:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到至少三个原因说明这种包结构不是最优的，然而：
- en: First, we have no package boundary between functional slices or features of
    our application. If we add a feature for managing users, we’ll add a `UserController`
    to the `web` package; a `UserService`, `UserRepository`, and `User` to the `domain`
    package; and a `UserRepositoryImpl` to the `persistence` package. Without further
    structure, this might quickly become a mess of classes, leading to unwanted side
    effects between supposedly unrelated features of the application.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们在应用的功能切片或特性之间没有包边界。如果我们添加一个用于管理用户的特性，我们将在`web`包中添加一个`UserController`；在`domain`包中添加`UserService`、`UserRepository`和`User`；在`persistence`包中添加`UserRepositoryImpl`。如果没有进一步的结构，这可能会迅速变成一个类混乱，导致应用中看似无关的特性之间出现不希望出现的副作用。
- en: Second, we can’t see which use cases our application provides. Can you tell
    what use cases the `AccountService` or `AccountController` classes implement?
    If we’re looking for a certain feature, we have to guess which service implements
    it and then search for the responsible method within that service.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们看不到我们的应用提供了哪些用例。你能说出`AccountService`或`AccountController`类实现了哪些用例吗？如果我们正在寻找某个特性，我们必须猜测哪个服务实现了它，然后在该服务中搜索负责的方法。
- en: Finally, we can’t see our target architecture within the package structure.
    We can guess that we have followed the Hexagonal Architecture style and then browse
    the classes in the `web` and `persistence` packages to find the web and persistence
    adapters. But we can’t see at a glance which functionality is called by the web
    adapter and which functionality the persistence adapter provides to the domain
    layer. The incoming and outgoing ports are hidden in the code.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在包结构中看不到我们的目标架构。我们可以猜测我们已经遵循了六边形架构风格，然后浏览`web`和`persistence`包中的类来找到网络和持久性适配器。但我们无法一眼看出哪个功能是由网络适配器调用的，哪个功能是由持久性适配器提供给领域层的。输入和输出端口隐藏在代码中。
- en: Let’s try to address some issues of the “organize by layer” approach.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试解决“按层组织”方法的一些问题。
- en: Organizing by feature
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按功能组织
- en: 'The next approach is to organize our code by feature:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是将我们的代码按功能组织：
- en: '![](img/code-4.2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![代码-4.2](img/code-4.2.jpg)'
- en: In essence, we have put all the code related to accounts into the high-level
    package, `account`. We have also removed the layer packages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我们将所有与账户相关的代码都放入了高级包`account`中。我们还移除了层包。
- en: Each new group of features will get a new high-level package next to `account`
    and we can enforce package boundaries between the features by using **package-private**
    visibility for the classes that should not be accessed from the outside.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的特性组都会在`account`旁边获得一个新的高级包，我们可以通过使用**包私有**可见性来强制特性之间的包边界，对于不应从外部访问的类。
- en: The package boundaries, combined with package-private visibility, enable us
    to avoid unwanted dependencies between features.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 包边界，结合包私有可见性，使我们能够避免特性之间的不必要依赖。
- en: We have also renamed `AccountService` `SendMoneyService` to narrow its responsibility
    (we actually could have done that in the package-by-layer approach, too). We can
    now see that the code implements the *Send money* use case just by looking at
    the class name. Making the application’s functionality visible in the code is
    what Robert Martin calls a “Screaming Architecture” because it screams its intention
    at us.[1](#footnote-017)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`AccountService`重命名为`SendMoneyService`以缩小其责任范围（我们实际上也可以在按层划分包的方法中这样做）。现在我们可以看到，只需看类名，代码就实现了*发送货币*用例。罗伯特·马丁将使应用程序的功能在代码中可见称为“呼啸架构”，因为它在我们面前大声喊出其意图。[1](#footnote-017)
- en: '[1](#footnote-017-backlink) Screaming Architecture*: Clean Architecture* by
    Robert C. Martin, Prentice Hall, 2017, *Chapter 21*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-017-backlink) 呼啸架构*：《清晰架构》*，罗伯特·C·马丁，普雷蒂斯·霍尔，2017年，*第21章*。'
- en: However, the package-by-feature approach makes our architecture even less evident
    in the code than the package-by-layer approach. We have no package names to identify
    our adapters, and we still don’t see the incoming and outgoing ports. What’s more,
    even though we have inverted the dependencies between the domain code and persistence
    code so that `SendMoneyService` only knows about the `AccountRepository` interface
    and not its implementation, we cannot use package-private visibility to protect
    the domain code from accidental dependencies on the persistence code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，按特性划分包的方法使得我们的架构在代码中的表现比按层划分包的方法更加不明显。我们没有包名来识别我们的适配器，而且我们仍然看不到输入和输出端口。更重要的是，尽管我们已经反转了领域代码和持久化代码之间的依赖关系，使得`SendMoneyService`只知道`AccountRepository`接口而不是其实例，但我们不能使用包私有可见性来保护领域代码免受对持久化代码的意外依赖。
- en: So, how can we make our target architecture visible at a glance? It would be
    nice if we could point a finger at a box in an architecture diagram like *Figure
    3**.4* and instantly know which part of the code is responsible for that box.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使我们的目标架构一目了然？如果我们可以像*图3**.4*那样指向架构图中的一个框，并立即知道代码的哪个部分负责该框，那就太好了。
- en: Let’s take one more step to create a package structure that is expressive enough
    to support this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再迈出一步，创建一个足够表达以支持这种架构的包结构。
- en: An architecturally expressive package structure
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个具有建筑表达性的包结构
- en: 'In a Hexagonal Architecture, we have entities, use cases, **input** and **output**
    **ports**, and input and output (or “**driving**” and “**driven**”) adapters as
    our main architectural elements. Let’s fit them into a package structure that
    expresses this architecture:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在六角架构中，我们有实体、用例、**输入**和**输出****端口**，以及输入和输出（或“**驱动**”和“**被驱动**”）适配器作为我们的主要架构元素。让我们将这些元素放入一个能够表达这种架构的包结构中：
- en: '![](img/code-4.3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![代码-4.3](img/code-4.3.jpg)'
- en: We can map each element of the architecture directly to one of the packages.
    At the highest level, we have the `adapter` and `application` packages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将架构的每个元素映射到其中一个包。在最高级别，我们有`adapter`和`application`包。
- en: The `adapter` package contains the incoming adapters that call the application’s
    incoming ports and the outgoing adapters that provide implementations for the
    application’s outgoing ports. In our case, we’re building a simple web application
    with the `web` and `persistence` adapters, each having its own sub-package.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`adapter`包包含调用应用程序输入端口的输入适配器和为应用程序输出端口提供实现的输出适配器。在我们的案例中，我们正在构建一个简单的Web应用程序，使用`web`和`persistence`适配器，每个适配器都有自己的子包。'
- en: Moving the adapters’ code to their own packages has the benefit that we can
    very easily replace one adapter with another implementation, should the need arise.
    Imagine we have started implementing a persistence adapter against a simple key-value
    database because we thought we knew the required access patterns, but those patterns
    have changed, and we would be better off with an SQL database now. We simply implement
    all relevant outgoing ports in a new adapter package and then remove the old package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将适配器的代码移动到它们自己的包中有一个好处，那就是我们可以非常容易地用另一个实现替换一个适配器，如果需要的话。想象一下，我们开始实现一个针对简单键值数据库的持久性适配器，因为我们认为我们知道了所需的访问模式，但那些模式已经改变了，现在我们最好使用一个SQL数据库。我们只需在新的适配器包中实现所有相关的输出端口，然后删除旧包。
- en: The `application` package contains the “hexagon,” as in, our application code.
    This code consists of our domain model, which lives in the `domain` package, and
    the port interfaces, which live in the `port` package.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`application` 包包含“六边形”，即我们的应用程序代码。这段代码由我们的领域模型组成，该模型位于 `domain` 包中，以及端点接口，它们位于
    `port` 包中。'
- en: Why are the ports inside the `application` package and not next to it? The ports
    are our way to apply the `port` package inside the `application` package expresses
    that the application owns the ports.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么端口在 `application` 包内而不是旁边？端口是我们将 `port` 包应用于 `application` 包的方式，这表明应用程序拥有端口。
- en: The `domain` package contains our domain entities and domain services that implement
    the input ports and coordinate between the domain entities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`domain` 包包含我们的领域实体和领域服务，这些服务实现了输入端口并在领域实体之间进行协调。'
- en: Finally, there is a `common` package, which contains some code that is shared
    across the rest of the code base.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个 `common` 包，其中包含一些在代码库的其余部分共享的代码。
- en: Phew, that’s a lot of technical-sounding packages. Isn’t that confusing?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这么多听起来很技术性的包。这不令人困惑吗？
- en: Imagine we have a high-level view of our Hexagonal Architecture hanging on the
    office wall and we’re talking to a colleague about modifying a client to a third-party
    API we’re consuming. While discussing this, we can point at the corresponding
    outgoing adapter on the poster to better understand each other. Then, when we’re
    finished talking, we sit down in front of our IDE and can start working on the
    client right away because the code of the API client we have talked about can
    be found in the `adapter/out/<name-of-adapter>` package. Rather helpful instead
    of confusing, don’t you think?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们在办公室墙上挂着一个关于我们的六边形架构的高级视图，我们正在和一个同事讨论修改客户端以使用我们正在消费的第三方API。在讨论这个话题时，我们可以指向海报上的相应输出适配器，以便更好地理解彼此。然后，当我们交谈完毕后，我们坐在IDE前，可以立即开始修改客户端，因为我们讨论过的API客户端代码可以在
    `adapter/out/<适配器名称>` 包中找到。这比令人困惑要更有帮助，不是吗？
- en: This package structure is a powerful element in the fight against the so-called
    **architecture/code gap** or **model/code gap**.[2](#footnote-016) These terms
    describe the fact that in most software development projects, the architecture
    is only an abstract concept that cannot be directly mapped to the code. With time,
    if the package structure (among other things) does not reflect the architecture,
    the code will usually deviate more and more from the target architecture.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包结构是对抗所谓的**架构/代码差距**或**模型/代码差距**的有力元素。[2](#footnote-016) 这些术语描述了这样一个事实：在大多数软件开发项目中，架构只是一个抽象概念，不能直接映射到代码。随着时间的推移，如果包结构（以及其他因素）不能反映架构，代码通常会越来越偏离目标架构。
- en: '[2](#footnote-016-backlink) Model/code gap: *Just Enough Architecture* by George
    Fairbanks, Marshall & Brainerd, 2010, page 167.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-016-backlink) 模型/代码差距：乔治·费尔班克斯、马歇尔和布赖恩德，《Just Enough Architecture》，2010年，第167页。'
- en: Also, this expressive package structure promotes active thinking about the architecture.
    We have to actively decide which package our code to put into. But don’t so many
    packages mean that everything has to be public in order to allow access across
    packages?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种表达式的包结构促进了关于架构的积极思考。我们必须积极决定将我们的代码放入哪个包。但是，包的数量那么多，是不是意味着为了允许跨包访问，所有内容都必须是公开的？
- en: For the adapter packages, at least, this is not true. All the classes they contain
    may be package-private since they are not called by the outside world except over
    port interfaces, which live within the `application` package. So, there are no
    accidental dependencies from the **application layer** to the adapter classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 至少对于适配器包来说，这一点并不成立。它们包含的所有类都可以是包私有的，因为它们除了通过端口接口（这些接口位于`application`包内）之外，不会被外部世界调用。因此，没有从**应用层**到适配器类的意外依赖。
- en: Within the `application` package, however, some classes indeed have to be public.
    The ports must be public because they must be accessible to the adapters by design.
    The domain model must be public to be accessible to the services and, potentially,
    to the adapters. The services don’t need to be public because they can be hidden
    behind the incoming port interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`application`包内部，确实有一些类必须是公共的。端口必须是公共的，因为它们必须按设计对适配器可访问。域模型必须是公共的，以便对服务以及可能对适配器可访问。服务不需要是公共的，因为它们可以隐藏在传入端口接口后面。
- en: So, yes, a fine-grained package structure such as this requires us to make some
    classes public that might be package-private in a coarser-grained package structure.
    We’ll look at ways to catch unwanted access to those public classes in [*Chapter
    12*](B19916_12.xhtml#_idTextAnchor105), *Enforcing* *Architecture Boundaries*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是的，这样一个细粒度的包结构要求我们使一些类成为公共的，而在较粗粒度的包结构中它们可能是包私有的。我们将在[*第12章*](B19916_12.xhtml#_idTextAnchor105)中探讨如何捕捉对这些公共类的不希望访问，*强制架构边界*。
- en: You might notice that this package structure contains only one domain, namely
    the domain handling account transactions. Many applications will contain code
    from more than one domain, however.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个包结构只包含一个域，即处理账户交易的域。然而，许多应用程序将包含来自多个域的代码。
- en: As we will learn in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing
    Multiple Bounded Contexts*, Hexagonal Architecture doesn’t really tell us how
    to manage multiple domains. We can, of course, put the code for each domain into
    its own sub-package under the `domain` package and have the domains separated
    this way. If you’re thinking about separating the ports and adapters per domain,
    however, be careful because this quickly turns into a mapping nightmare. More
    about this in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[*第13章*](B19916_13.xhtml#_idTextAnchor112)中学习的，*管理多个边界上下文*，六边形架构并没有真正告诉我们如何管理多个域。当然，我们可以将每个域的代码放入`domain`包下的自己的子包中，并通过这种方式将域分开。但是，如果你正在考虑按域分别分离端口和适配器，那么请小心，因为这很快就会变成一个映射噩梦。更多关于这一点的内容请参考[*第13章*](B19916_13.xhtml#_idTextAnchor112)。
- en: As with every structure, it takes discipline to maintain this package structure
    over the lifetime of a software project. Also, there will be cases when the package
    structure just does not fit and we see no other way than to widen the architecture/code
    gap and create a package that does not reflect the architecture.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个结构一样，在软件项目的整个生命周期中维护这个包结构需要纪律。此外，也可能会出现包结构根本不适合的情况，我们别无选择，只能扩大架构/代码差距，创建一个不反映架构的包。
- en: There is no perfection. But with an expressive package structure, we can at
    least reduce the gap between code and architecture.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 没有完美。但通过一个有表达力的包结构，我们至少可以减少代码和架构之间的差距。
- en: The role of dependency injection
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入的作用
- en: The package structure described previously goes a long way toward achieving
    a clean architecture, but an essential requirement of such an architecture is
    that the **application layer** does not have dependencies on the incoming and
    outgoing adapters, as we have learned in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029),
    *Inverting Dependencies*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的包结构在很大程度上有助于实现干净的架构，但这样一个架构的基本要求是**应用层**不依赖于传入和传出的适配器，正如我们在[*第3章*](B19916_03.xhtml#_idTextAnchor029)中学习的，*反转依赖*。
- en: For incoming adapters, such as our web adapter, this is easy since the control
    flow points in the same direction as the dependency between the adapter and the
    domain code. The adapter simply calls the service within the application layer.
    In order to clearly bring out the entry points to our application, we’ll want
    to hide the actual services behind port interfaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传入适配器，例如我们的Web适配器，这很容易，因为控制流的方向与适配器和域代码之间的依赖关系相同。适配器只需在应用层调用服务。为了清楚地展示我们应用的入口点，我们希望将实际服务隐藏在端口接口后面。
- en: For outgoing adapters, such as our persistence adapter, we have to make use
    of the **Dependency Inversion Principle** to turn the dependency against the direction
    of the control flow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外出的适配器，例如我们的持久化适配器，我们必须利用**依赖倒置原则**来逆转对控制流方向的依赖。
- en: We have already seen how that works. We create an interface within the application
    layer, which is implemented by a class within the adapter. Within our Hexagonal
    Architecture, this interface is a port. The application layer then calls this
    port interface to call the functionality of the adapter, as shown in *Figure 4**.1*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了它是如何工作的。我们在应用层内部创建了一个接口，由适配器内部的类实现。在我们的六边形架构中，这个接口是一个端口。然后应用层调用这个端口接口来调用适配器的功能，如图
    *图 4.1* 所示。
- en: '![Figure 4.1 – The web controller calls an incoming port, which is implemented
    by a service, and the service calls an outgoing port, which is implemented by
    an adapter](img/Figure_4.4_B19916.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 网络控制器调用一个由服务实现的外来端口，而服务调用一个由适配器实现的外出端口](img/Figure_4.4_B19916.jpg)'
- en: Figure 4.1 – The web controller calls an incoming port, which is implemented
    by a service, and the service calls an outgoing port, which is implemented by
    an adapter
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 网络控制器调用一个由服务实现的外来端口，而服务调用一个由适配器实现的外出端口
- en: But who provides the application with the actual objects that implement the
    port interfaces? We don’t want to instantiate the ports manually within the application
    layer because we don’t want to introduce a dependency on an adapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但谁为应用提供实现端口接口的实际对象呢？我们不希望在应用层手动实例化端口，因为我们不希望引入对适配器的依赖。
- en: This is where **dependency injection** comes into play. We introduce a neutral
    component that has a dependency on all layers. This component is responsible for
    instantiating most of the classes that make up our architecture.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**依赖注入**发挥作用的地方。我们引入了一个对所有层都有依赖的中立组件。这个组件负责实例化构成我们架构的大多数类。
- en: In the preceding example figure, the neutral dependency injection component
    would create instances of the `SendMoneyController`, `SendMoneyService`, and `AccountPersistenceAdapter`
    classes. Since `SendMoneyController` requires a `SendMoneyUseCase`, the dependency
    injection mechanism will give it an instance of the `SendMoneyService` class during
    construction. The controller doesn’t know that it actually got a `SendMoneyService`
    instance since it only needs to know the interface.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例图中，中立的依赖注入组件会创建`SendMoneyController`、`SendMoneyService`和`AccountPersistenceAdapter`类的实例。由于`SendMoneyController`需要一个`SendMoneyUseCase`，依赖注入机制将在构造过程中给它一个`SendMoneyService`类的实例。控制器不知道它实际上得到了一个`SendMoneyService`实例，因为它只需要知道接口。
- en: Similarly, when constructing the `SendMoneyService` instance, the dependency
    injection mechanism will inject an instance of the `AccountPersistenceAdapter`
    class, in the guise of the `UpdateAccountStatePort` interface. The service never
    knows the actual class behind the interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在构建`SendMoneyService`实例时，依赖注入机制将以`UpdateAccountStatePort`接口的形式注入`AccountPersistenceAdapter`类的实例。服务永远不会知道接口背后的实际类。
- en: We’ll talk more about initializing an application using the Spring framework
    as an example in [*Chapter 10*](B19916_10.xhtml#_idTextAnchor089), *Assembling*
    *the Application*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 10 章*](B19916_10.xhtml#_idTextAnchor089)“组装*应用”中更详细地讨论使用Spring框架初始化应用，作为一个例子。
- en: How does this help me build maintainable software?
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: We looked at a package structure for a Hexagonal Architecture that takes the
    actual code structure as close to the target architecture as possible. Finding
    an element of the architecture in the code is now a matter of navigating down
    the package structure along the names of certain boxes in an architecture diagram,
    helping with communication, development, and maintenance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了适用于六边形架构的包结构，使其尽可能接近目标代码结构。现在，在代码中找到架构元素变成了一件通过架构图上某些框的名称导航包结构的事情，这有助于沟通、开发和维护。
- en: In the following chapters, we’ll see this package structure and dependency injection
    in action as we implement a use case in the application layer, a web adapter,
    and a persistence adapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过在应用层、网络适配器和持久化适配器中实现一个用例来展示这个包结构和依赖注入的实际应用。
