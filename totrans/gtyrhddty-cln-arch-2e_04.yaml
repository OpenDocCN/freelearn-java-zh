- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn’t it be nice to recognize the architecture just by looking at the code?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine different ways of organizing code and introduce
    an expressive package structure that directly reflects a Hexagonal Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In greenfield software projects, the first thing we try to get right is the
    package structure. We set up a nice-looking structure that we intend to use for
    the rest of the project. Then, during the project, things become hectic, and we
    realize that in many places the package structure is just a nice-looking facade
    for an unstructured mess of code. Classes in one package import classes from other
    packages that should not be imported.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss different options for structuring the code of the BuckPal example
    application that was introduced in the *Preface*. More specifically, we’ll look
    at the *Send money* use case, which allows a user to transfer money from their
    account to another.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing By Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first approach to organizing our code is by layer. We might organize the
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For each of our layers – `web`, `domain`, and `persistence` – we have a dedicated
    package. As discussed in [*Chapter 2*](B19916_04.xhtml), *What’s Wrong with Layers?*,
    simple layers may not be the best structure for our code for several reasons,
    so we have already applied the `domain` package. We did this by introducing the
    `AccountRepository` interface in the `domain` package and implementing it in the
    `persistence` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find at least three reasons why this package structure is suboptimal,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have no package boundary between functional slices or features of
    our application. If we add a feature for managing users, we’ll add a `UserController`
    to the `web` package; a `UserService`, `UserRepository`, and `User` to the `domain`
    package; and a `UserRepositoryImpl` to the `persistence` package. Without further
    structure, this might quickly become a mess of classes, leading to unwanted side
    effects between supposedly unrelated features of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we can’t see which use cases our application provides. Can you tell
    what use cases the `AccountService` or `AccountController` classes implement?
    If we’re looking for a certain feature, we have to guess which service implements
    it and then search for the responsible method within that service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we can’t see our target architecture within the package structure.
    We can guess that we have followed the Hexagonal Architecture style and then browse
    the classes in the `web` and `persistence` packages to find the web and persistence
    adapters. But we can’t see at a glance which functionality is called by the web
    adapter and which functionality the persistence adapter provides to the domain
    layer. The incoming and outgoing ports are hidden in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s try to address some issues of the “organize by layer” approach.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing by feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next approach is to organize our code by feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-4.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In essence, we have put all the code related to accounts into the high-level
    package, `account`. We have also removed the layer packages.
  prefs: []
  type: TYPE_NORMAL
- en: Each new group of features will get a new high-level package next to `account`
    and we can enforce package boundaries between the features by using **package-private**
    visibility for the classes that should not be accessed from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: The package boundaries, combined with package-private visibility, enable us
    to avoid unwanted dependencies between features.
  prefs: []
  type: TYPE_NORMAL
- en: We have also renamed `AccountService` `SendMoneyService` to narrow its responsibility
    (we actually could have done that in the package-by-layer approach, too). We can
    now see that the code implements the *Send money* use case just by looking at
    the class name. Making the application’s functionality visible in the code is
    what Robert Martin calls a “Screaming Architecture” because it screams its intention
    at us.[1](#footnote-017)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-017-backlink) Screaming Architecture*: Clean Architecture* by
    Robert C. Martin, Prentice Hall, 2017, *Chapter 21*.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the package-by-feature approach makes our architecture even less evident
    in the code than the package-by-layer approach. We have no package names to identify
    our adapters, and we still don’t see the incoming and outgoing ports. What’s more,
    even though we have inverted the dependencies between the domain code and persistence
    code so that `SendMoneyService` only knows about the `AccountRepository` interface
    and not its implementation, we cannot use package-private visibility to protect
    the domain code from accidental dependencies on the persistence code.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we make our target architecture visible at a glance? It would be
    nice if we could point a finger at a box in an architecture diagram like *Figure
    3**.4* and instantly know which part of the code is responsible for that box.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take one more step to create a package structure that is expressive enough
    to support this.
  prefs: []
  type: TYPE_NORMAL
- en: An architecturally expressive package structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Hexagonal Architecture, we have entities, use cases, **input** and **output**
    **ports**, and input and output (or “**driving**” and “**driven**”) adapters as
    our main architectural elements. Let’s fit them into a package structure that
    expresses this architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-4.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can map each element of the architecture directly to one of the packages.
    At the highest level, we have the `adapter` and `application` packages.
  prefs: []
  type: TYPE_NORMAL
- en: The `adapter` package contains the incoming adapters that call the application’s
    incoming ports and the outgoing adapters that provide implementations for the
    application’s outgoing ports. In our case, we’re building a simple web application
    with the `web` and `persistence` adapters, each having its own sub-package.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the adapters’ code to their own packages has the benefit that we can
    very easily replace one adapter with another implementation, should the need arise.
    Imagine we have started implementing a persistence adapter against a simple key-value
    database because we thought we knew the required access patterns, but those patterns
    have changed, and we would be better off with an SQL database now. We simply implement
    all relevant outgoing ports in a new adapter package and then remove the old package.
  prefs: []
  type: TYPE_NORMAL
- en: The `application` package contains the “hexagon,” as in, our application code.
    This code consists of our domain model, which lives in the `domain` package, and
    the port interfaces, which live in the `port` package.
  prefs: []
  type: TYPE_NORMAL
- en: Why are the ports inside the `application` package and not next to it? The ports
    are our way to apply the `port` package inside the `application` package expresses
    that the application owns the ports.
  prefs: []
  type: TYPE_NORMAL
- en: The `domain` package contains our domain entities and domain services that implement
    the input ports and coordinate between the domain entities.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is a `common` package, which contains some code that is shared
    across the rest of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Phew, that’s a lot of technical-sounding packages. Isn’t that confusing?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we have a high-level view of our Hexagonal Architecture hanging on the
    office wall and we’re talking to a colleague about modifying a client to a third-party
    API we’re consuming. While discussing this, we can point at the corresponding
    outgoing adapter on the poster to better understand each other. Then, when we’re
    finished talking, we sit down in front of our IDE and can start working on the
    client right away because the code of the API client we have talked about can
    be found in the `adapter/out/<name-of-adapter>` package. Rather helpful instead
    of confusing, don’t you think?
  prefs: []
  type: TYPE_NORMAL
- en: This package structure is a powerful element in the fight against the so-called
    **architecture/code gap** or **model/code gap**.[2](#footnote-016) These terms
    describe the fact that in most software development projects, the architecture
    is only an abstract concept that cannot be directly mapped to the code. With time,
    if the package structure (among other things) does not reflect the architecture,
    the code will usually deviate more and more from the target architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-016-backlink) Model/code gap: *Just Enough Architecture* by George
    Fairbanks, Marshall & Brainerd, 2010, page 167.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, this expressive package structure promotes active thinking about the architecture.
    We have to actively decide which package our code to put into. But don’t so many
    packages mean that everything has to be public in order to allow access across
    packages?
  prefs: []
  type: TYPE_NORMAL
- en: For the adapter packages, at least, this is not true. All the classes they contain
    may be package-private since they are not called by the outside world except over
    port interfaces, which live within the `application` package. So, there are no
    accidental dependencies from the **application layer** to the adapter classes.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `application` package, however, some classes indeed have to be public.
    The ports must be public because they must be accessible to the adapters by design.
    The domain model must be public to be accessible to the services and, potentially,
    to the adapters. The services don’t need to be public because they can be hidden
    behind the incoming port interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: So, yes, a fine-grained package structure such as this requires us to make some
    classes public that might be package-private in a coarser-grained package structure.
    We’ll look at ways to catch unwanted access to those public classes in [*Chapter
    12*](B19916_12.xhtml#_idTextAnchor105), *Enforcing* *Architecture Boundaries*.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that this package structure contains only one domain, namely
    the domain handling account transactions. Many applications will contain code
    from more than one domain, however.
  prefs: []
  type: TYPE_NORMAL
- en: As we will learn in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing
    Multiple Bounded Contexts*, Hexagonal Architecture doesn’t really tell us how
    to manage multiple domains. We can, of course, put the code for each domain into
    its own sub-package under the `domain` package and have the domains separated
    this way. If you’re thinking about separating the ports and adapters per domain,
    however, be careful because this quickly turns into a mapping nightmare. More
    about this in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112).
  prefs: []
  type: TYPE_NORMAL
- en: As with every structure, it takes discipline to maintain this package structure
    over the lifetime of a software project. Also, there will be cases when the package
    structure just does not fit and we see no other way than to widen the architecture/code
    gap and create a package that does not reflect the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: There is no perfection. But with an expressive package structure, we can at
    least reduce the gap between code and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The role of dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package structure described previously goes a long way toward achieving
    a clean architecture, but an essential requirement of such an architecture is
    that the **application layer** does not have dependencies on the incoming and
    outgoing adapters, as we have learned in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029),
    *Inverting Dependencies*.
  prefs: []
  type: TYPE_NORMAL
- en: For incoming adapters, such as our web adapter, this is easy since the control
    flow points in the same direction as the dependency between the adapter and the
    domain code. The adapter simply calls the service within the application layer.
    In order to clearly bring out the entry points to our application, we’ll want
    to hide the actual services behind port interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: For outgoing adapters, such as our persistence adapter, we have to make use
    of the **Dependency Inversion Principle** to turn the dependency against the direction
    of the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen how that works. We create an interface within the application
    layer, which is implemented by a class within the adapter. Within our Hexagonal
    Architecture, this interface is a port. The application layer then calls this
    port interface to call the functionality of the adapter, as shown in *Figure 4**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The web controller calls an incoming port, which is implemented
    by a service, and the service calls an outgoing port, which is implemented by
    an adapter](img/Figure_4.4_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The web controller calls an incoming port, which is implemented
    by a service, and the service calls an outgoing port, which is implemented by
    an adapter
  prefs: []
  type: TYPE_NORMAL
- en: But who provides the application with the actual objects that implement the
    port interfaces? We don’t want to instantiate the ports manually within the application
    layer because we don’t want to introduce a dependency on an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is where **dependency injection** comes into play. We introduce a neutral
    component that has a dependency on all layers. This component is responsible for
    instantiating most of the classes that make up our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example figure, the neutral dependency injection component
    would create instances of the `SendMoneyController`, `SendMoneyService`, and `AccountPersistenceAdapter`
    classes. Since `SendMoneyController` requires a `SendMoneyUseCase`, the dependency
    injection mechanism will give it an instance of the `SendMoneyService` class during
    construction. The controller doesn’t know that it actually got a `SendMoneyService`
    instance since it only needs to know the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when constructing the `SendMoneyService` instance, the dependency
    injection mechanism will inject an instance of the `AccountPersistenceAdapter`
    class, in the guise of the `UpdateAccountStatePort` interface. The service never
    knows the actual class behind the interface.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll talk more about initializing an application using the Spring framework
    as an example in [*Chapter 10*](B19916_10.xhtml#_idTextAnchor089), *Assembling*
    *the Application*.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at a package structure for a Hexagonal Architecture that takes the
    actual code structure as close to the target architecture as possible. Finding
    an element of the architecture in the code is now a matter of navigating down
    the package structure along the names of certain boxes in an architecture diagram,
    helping with communication, development, and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we’ll see this package structure and dependency injection
    in action as we implement a use case in the application layer, a web adapter,
    and a persistence adapter.
  prefs: []
  type: TYPE_NORMAL
