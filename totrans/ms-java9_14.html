<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Command Line Flags</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we looked a<span>t several security changes to the JDK. Java 9's security enhancements provide developers with the ability to write and maintain applications that implement security. Specifically, we covered d</span>atagram transport layer security, Keystores, improving security application performance, the TLS application-layer protocol negotiation extension, leveraging CPU instructions for GHASH and RSA, OCSP stapling for TLS, and DRBG-based <kbd>SecureRandom</kbd> implementations.</p>
<p>In this chapter, we will explore several changes to the Java 9 platform with the common theme of command-line flags. Specifically, we will cover the following concepts:</p>
<ul>
<li>Unified JVM logging</li>
<li>Compiler control</li>
<li>Diagnostic commands</li>
<li>Heap profiling agent</li>
<li>Removing your JHAT</li>
<li>Command-line flag argument validation</li>
<li>Compiling for older platform versions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unified JVM Logging [JEP 158]</h1>
                </header>
            
            <article>
                
<p>Creating a unified logging schema for the JVM was the central goal of JEP-158. Here is a comprehensive list of the goals of the JEP:</p>
<ul>
<li>Create a JVM-wide set of command-line options for all logging operations</li>
<li>Use categorized tags for logging</li>
<li>Permit messages to have multiple tags, also referred to as tag sets</li>
<li>Provide six levels of logging:
<ul>
<li>Error</li>
<li>Warning</li>
<li>Information</li>
<li>Debug</li>
<li>Trace</li>
<li>Develop</li>
</ul>
</li>
<li>Select which messages are logged based on levels</li>
<li>Optionally direct logging to the console or a file
<ul>
<li>Print one line at a time and do not support interleaving within the same line</li>
</ul>
</li>
<li>Permit output of multiple line logs (non-interleaved)</li>
<li>Format all logging messages so that they are easily human-read</li>
<li>Add decorations such as uptime, level, and tags</li>
<li>Like levels, select which messages are logged based on decorations</li>
<li>Convert pre-Java 9 <kbd>tty&gt;print</kbd> logging to use unified logging as the output</li>
<li>Permit dynamic message configuration using <kbd>jcmd</kbd> and <kbd>MBeans</kbd></li>
<li>Permit the ability to enable and disable individual log messages</li>
<li>Add ability to determine the order in which decorations are printed</li>
</ul>
<p>The unified logging changes to the JVM can be grouped into the five categories listed here:</p>
<ul>
<li><span>Command-line options</span></li>
<li>Decorations</li>
<li>Levels</li>
<li>Output</li>
<li>Tags</li>
</ul>
<p>Let's briefly look at each of these categories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command-line options</h1>
                </header>
            
            <article>
                
<p>The new command-line option, <kbd>-Xlog</kbd>, was added to the logging framework in Java 9. This command-line option has an extensive array of parameters and possibilities. The basic syntax is simply <kbd>-Xlog</kbd> followed by an option. Here is the formal basic syntax:</p>
<pre><strong>-Xlog[:option]</strong></pre>
<p>Here is a basic example with the <kbd>all</kbd> option:</p>
<pre><strong>-Xlog:all</strong></pre>
<p>Here is the extensive command-line syntax used to configure the new unified logging:</p>
<pre><strong>-Xlog[:option]</strong><br/><br/><strong>option          := [&lt;what&gt;][:[&lt;output&gt;][:[&lt;decorators&gt;][:&lt;output-options&gt;]]]</strong><br/><strong>                   'help'</strong><br/><strong>                   'disable'</strong><br/><br/><strong>what            := &lt;selector&gt;[,...]</strong><br/><br/><strong>selector        := &lt;tag-set&gt;[*][=&lt;level&gt;]</strong><br/><br/><strong>tag-set         := &lt;tag&gt;[+..]</strong><br/><strong>                   'all'</strong><br/><br/><strong>tag             := name of tag</strong><br/><br/><strong>level           := trace</strong><br/><strong>                   debug</strong><br/><strong>                   info</strong><br/><strong>                   warning</strong><br/><strong>                   error</strong><br/><br/><strong>output          := 'stderr'</strong><br/><strong>                   'stdout'</strong><br/><strong>                   [file=]&lt;filename&gt;</strong><br/><br/><strong>decorators      := &lt;decorator&gt;[,...]</strong><br/><strong>                   'none'</strong><br/><br/><strong>decorator       := time</strong><br/><strong>                   uptime</strong><br/><strong>                   timemillis</strong><br/><strong>                   uptimemillis</strong><br/><strong>                   timenanos</strong><br/><strong>                   uptimenanos</strong><br/><strong>                   pid</strong><br/><strong>                   tid</strong><br/><strong>                   level</strong><br/><strong>                   tags</strong><br/><br/><strong>output-options  := &lt;output_option&gt;[,...]</strong><br/><br/><strong>output-option   := filecount=&lt;file count&gt;</strong><br/><strong>                   filesize=&lt;file size in kb&gt;</strong><br/><strong>                   parameter=value</strong></pre>
<p>The following <kbd>-Xlog</kbd> examples are followed by a description:</p>
<pre><strong>-Xlog:all</strong></pre>
<p>In the preceding example, we are telling the JVM to take the following actions:</p>
<ul>
<li>Log all messages</li>
<li>Use the <kbd>info</kbd> level</li>
<li>Provide output to <kbd>stdout</kbd></li>
</ul>
<div class="packt_infobox">With this example, all <kbd>warning</kbd> messages will still be output to <kbd>stderr</kbd>.</div>
<p>The next example, shown here, logs messages at the <kbd>debug</kbd> level:</p>
<pre><strong>-Xlog:gc+rt*=debug</strong></pre>
<p>In the preceding example, we are telling the JVM to take the following actions:</p>
<ul>
<li>Log all messages tagged with, at a minimum, the <kbd>gc</kbd> and <kbd>rt</kbd> tags</li>
<li>Use the <kbd>debug</kbd> level</li>
<li>Provide output to <kbd>stdout</kbd></li>
</ul>
<p>The next example pushes the output to an external file:</p>
<pre><strong>-Xlog:disable - Xlog:rt=debug:rtdebug.txt</strong></pre>
<p>In the preceding example, we are telling the JVM to take the following actions:</p>
<ul>
<li>Disable all messages except those tagged with <kbd>rt</kbd> tags</li>
<li>Use the <kbd>debug</kbd> level</li>
<li>Provide output to a file named <kbd>rtdebug.txt</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorations</h1>
                </header>
            
            <article>
                
<p>In the context of Java 9's logging framework, decorations are metadata about the log message. Here is the alphabetic list of decorations that are available:</p>
<ul>
<li><strong>level</strong>: The level associated with the logged message</li>
<li><strong>pid</strong>: PID = Processor IDentifier</li>
<li><strong>tags</strong>: The tag-set associated with the logged message</li>
<li><strong>tid</strong>: TID = Thread IDentifier</li>
<li><strong>time</strong>: Refers to current date and time using ISO-8601 format</li>
<li><strong>timemillis</strong>: Current time in milliseconds</li>
<li><strong>timenanos</strong>: Current time in nanoseconds</li>
<li><strong>uptime</strong>: Time, in seconds and milliseconds, since the JVM started</li>
<li><strong>uptimemillis</strong>: Time, in milliseconds, since the JVM started</li>
<li><strong>uptimenanos</strong>: Time, in nanoseconds, since the JVM started</li>
</ul>
<p>Decorations can be surpassed or included in unified logging output. Regardless of which decorations are used, they will appear in the output in the following order:</p>
<ol>
<li>time</li>
<li>uptime</li>
<li>timemillis</li>
<li>uptimemillis</li>
<li>timenanos</li>
<li>uptimenanos</li>
<li>pid</li>
<li>tid</li>
<li>level</li>
<li>tags</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Levels</h1>
                </header>
            
            <article>
                
<p>Logged messages are individually associated with a verbosity level. As previously listed, the levels are <strong>error</strong>, <strong>warning</strong>, <strong>information</strong>, <strong>debug</strong>, <strong>trace</strong>, and <strong>develop</strong>. The following chart shows how the levels have an increasing level of verbosity in respect to how much information is logged. The <strong>develop</strong> level is for development purposes only and is not available in on-product application builds:</p>
<div class="CDPAlignCenter CDPAlign"><img height="256" width="311" src="assets/c21d072f-4b08-4ac1-9b5b-0f8e96bd8ba5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Output</h1>
                </header>
            
            <article>
                
<p>The Java 9 logging framework supports three types of output with examples of direct use with the <kbd>-Xlog</kbd> command-line syntax:</p>
<p class="mce-root">In the following example, we provide output to <kbd>stderr</kbd>:</p>
<pre><strong>-Xlog:all=warning:stderr:none</strong></pre>
<p>The following example provides output to <kbd>stdout</kbd>:</p>
<pre><strong>-Xlog:all=warning:stdout:none</strong></pre>
<p>The following example writes the output to a text file:</p>
<pre><strong>-Xlog:all=warning:file=logmessages.txt:none</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tags</h1>
                </header>
            
            <article>
                
<p>The new logging framework consists of a set of tags identified in the JVM. These tags can be changed in source code if needed. The tags should be self-identifying, such as <kbd>gc</kbd> for garbage collection.</p>
<p>When more than one tag is grouped together, they form a tag-set. When we add our own tags via source code, each tag should be associated with a tag-set. This will help ensure the tags stay organized and easily human-readable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiler control [JEP 165]</h1>
                </header>
            
            <article>
                
<p>Controlling Java Virtual Machine compilers might seem like an unnecessary task, but for many developers, this is an important aspect of testing. Java Enhancement Proposal 165 detailed a plan to implement runtime management of JVM compilers. This is accomplished with method-dependent compiler flags.</p>
<p>In this section, we will start with a look at JVM compilation modes, then look at the compiler that can be controlled using the Java 9 platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compilation modes</h1>
                </header>
            
            <article>
                
<p>The changes in the Java 9 platform include granular control of both the c1 and c2 JVM compliers. As you can see in the following illustration, the Java HotSpot JVM has two <span><strong>Just-in-Time</strong> (<strong>JIT</strong>)</span> compilation modes--<strong>c1</strong> and <strong>c2</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="206" width="269" src="assets/fbebf216-df20-4e3d-8776-59db2318f590.png"/></div>
<p>The <strong>C1</strong> and <strong>C2</strong> compilation modes use different compilation techniques and, if used on the same code base, can produce different sets of machine code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C1 compilation mode</h1>
                </header>
            
            <article>
                
<p>The C1 compilation mode inside Java HotSpot VM is typically used for applications that have the following characteristics:</p>
<ul>
<li>Quick startup</li>
<li>Increased optimization</li>
<li>Client-side</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C2 compilation mode</h1>
                </header>
            
            <article>
                
<p>The second compilation mode, C2, is used by applications with the following listed characteristics:</p>
<ul>
<li>Long runtimes</li>
<li>Server-side</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tiered compilation</h1>
                </header>
            
            <article>
                
<p>Tiered compilation allows us to use both <strong>c1</strong> and <strong>c2</strong> compilation modes. Starting with Java 8, tiered compilation is the default process. As illustrated here, the <strong>c1</strong> mode is used at startup to help provide greater optimization. Then, once the app has sufficiently warmed up, the <strong>c2</strong> mode is employed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="171" width="248" src="assets/9d2cf64e-b566-4e3b-bb0b-042455b9bcdc.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiler control in Java 9</h1>
                </header>
            
            <article>
                
<p>Java 9 comes with the promise of the ability to have finite control over JVM compilers and to make changes at runtime. These additional abilities do not degrade performance. This permits greater fidelity of testing and testing optimization as we can run small compiler tests without having to relaunch the entire JVM.</p>
<p>To control compiler operations, we need to create a directives file. These files contain compiler directives which consist of a set of options with values. Directive files essentially use a subset of JSON:</p>
<div class="CDPAlignCenter CDPAlign"><img height="234" width="239" src="assets/c1a98d14-0fb8-4462-ba76-c06a66a767a4.png"/></div>
<p>The <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) format is used for data-interchange. The directive files have the following formatting differences from JSON:</p>
<ul>
<li><kbd>int</kbd> and <kbd>doubles</kbd> are the only supported number formats</li>
<li>Double forward slash (<kbd>//</kbd>) can be used for comment lines</li>
<li>Trailing commas (<kbd>,</kbd>) can be used in arrays and objects</li>
<li>Escape characters are not supported</li>
<li>Option names are formatted as strings and do not have to be quoted</li>
</ul>
<div class="packt_tip">You can learn more about JSON at <a href="http://www.json.org">http://www.json.org</a>.</div>
<p>We can add our directive file using the following syntax at the command line:</p>
<pre><strong>-XX:CompilerDirectivesFile=&lt;file&gt;</strong></pre>
<p>Here is a shell example of a directives file:</p>
<pre><span>    [  // Open square bracket marks the start of the directives file<br/></span><span><br/>    { // Open curly brace marks the start of a directive block<br/><br/></span><span>      // A directives block that applies specifically to the C1 mode<br/></span><span>      c1: {   <br/></span><span>             // directives go here<br/></span><span>          },<br/></span><span>    <br/></span><span>      // A directives block that applies specifically to the C2 mode<br/></span><span>      c2: {   <br/></span><span>             // directives go here<br/></span><span>          },<br/><br/></span><span>      // Here we can put a directives that do not apply to<br/></span><span>      // a specific compiler mode<br/><br/></span><span>    },<br/><br/></span><span>    {  // can have multiple directive blocks<br/><br/></span><span>       c1: {<br/></span><span>             // directives go here<br/></span><span>           }   <br/></span><span><br/>       c2: {<br/></span><span>             // directives go here<br/></span><span>           }    <br/></span><span>    }<br/></span><span><br/>    ] </span><span>// Close square bracket marks the start of the directives file</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diagnostic commands [JEP 228]</h1>
                </header>
            
            <article>
                
<p>The Java Enhancement Proposal 228, <strong>Add More Diagnostic Commands</strong>, defined seven additional diagnostic commands to enhance the ability to diagnose the JDK and the JVM. The new diagnostic commands are detailed here.</p>
<p>The <kbd>print_codegenlist</kbd> command <span>prints methods that are currently queued for compilation. Since c1 and c2 compilation modes are on separate queues, this command would need to be issued to a</span> specific queue<span>.</span></p>
<p><span>The <kbd>dump_codelist</kbd> diagnostic command will print the following listed information for the compiled methods:</span></p>
<ul>
<li>Full signature</li>
<li>Address range</li>
<li>State
<ul>
<li>Alive</li>
<li>Nonentrant</li>
<li>Zombie</li>
</ul>
</li>
</ul>
<p><span>In addition, the <kbd>dump_codelist</kbd> diagnostic command allows the output to be directed to <kbd>stdout</kbd> or to a specified file. Output can be in XML form or standard text.</span></p>
<p>The <kbd>print_codeblocks</kbd> command allows us to print:</p>
<ul>
<li><span>Code cache size</span></li>
<li><span>Code cache list</span></li>
<li><span>List of blocks in the code cache</span></li>
<li><span>Addresses for code blocks</span></li>
</ul>
<p><span>Th <kbd>datadump_request</kbd> diagnostic command sends a dump request to the <strong>Java Virtual Machine Tool Interface</strong> (<strong>JVMTI</strong>). This replaces the <strong>Java Virtual Machine Debug Interface</strong> (<strong>JVMDI</strong>) and the <strong>Java Virtual Machine Profiling Interface</strong> (<strong>JVMPI</strong>) interfaces.</span></p>
<p><span>With the <kbd>set_vmflag</kbd> command, we can set a command-line flag or option in the JVM or the libraries.</span></p>
<p><span>Th <kbd>print_class_summary</kbd> diagnostic command prints a list of all loaded classes as well as the structure of their inheritance.</span></p>
<p><span>The <kbd>print_utf8pool</kbd> command prints all UTF-8 string constants.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Heap profiling agent [JEP 240]</h1>
                </header>
            
            <article>
                
<p>Java Enhancement Proposal 240 is titled <em>Remove the JVM TI hprof Agent</em>. Here are the key terms associated with this JEP and referenced in the title that might be new to you:</p>
<ul>
<li><strong>Tool Interface (TI)</strong>: This is a native programming interface that allows tools to control the execution of applications that are being run inside the Java Virtual Machine. The interface also permits state inquiries. The full nomenclature for this tool is the Java Virtual Machine Tool Interface, or JVM TI.</li>
<li><strong>Heap Profiling (HPROF)</strong>: This is an internal JDK tool used for profiling a JVM's use of CPUs and the heap. The most common exposure developers have to <kbd>hprof</kbd> is the file that is generated when following a crash. The generated file contains a heap dump.</li>
</ul>
<p>The Java 9 JDK does not contain the <kbd>hprof</kbd> agent. It was removed largely because there are superior alternatives available. Here is a table of the related functionality:</p>
<table>
<tbody>
<tr>
<td><strong>HPROF Functionality</strong></td>
<td><strong>Alternative</strong></td>
</tr>
<tr>
<td>
<p class="mce-root">Allocation Profiler</p>
<p>(heap=sites)</p>
</td>
<td>
<p>Java VisualVM</p>
</td>
</tr>
<tr>
<td>
<p class="mce-root">CPU Profiler</p>
<p>(cpu=samples)</p>
<p>(cpu=times)</p>
</td>
<td>
<p class="mce-root">Java VisualVM</p>
<p>Java Flight Recorder</p>
</td>
</tr>
<tr>
<td>
<p class="mce-root">Heap Dumps</p>
<p>(heap=dump)</p>
</td>
<td>
<p class="mce-root">Internal JVM functionality:</p>
<ul>
<li><kbd>GC.heap_dump(icmd &lt;pid&gt; GC.heap_dump)</kbd></li>
<li><kbd>jmap -dump</kbd></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Interestingly, when HPROF was originally created, it was not intended to be used in production. In fact, it was only meant to test code for the JVM Tool Interface. So, with the advent of the Java 9 platform, the HPROF library (<kbd>libhprof.so</kbd>) will no longer be part of the JDK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing your JHAT [JEP 241]</h1>
                </header>
            
            <article>
                
<p>The <strong>Java Heap Analysis Tool</strong> (<strong>JHAT</strong>) is used to parse Java heap dump files. The syntax for this heap dump file parsing tool is as follows:</p>
<pre><strong>jhat <br/>     [-stack &lt;bool&gt;] <br/>     [-refs &lt;bool&gt;] <br/>     [-port &lt;port&gt;] <br/>     [-baseline &lt;file&gt;] <br/>     [-debug &lt;int&gt;] <br/>     [-version] <br/>     [-h|-help] <br/>     &lt;file&gt;</strong></pre>
<p>Here is a quick look at the options associated with the JHAT command:</p>
<table>
<tbody>
<tr>
<td><strong>Option</strong></td>
<td><strong>Description</strong></td>
<td><strong>Default</strong></td>
</tr>
<tr>
<td><kbd>-J&lt;flag&gt;</kbd></td>
<td>This passes <kbd>&lt;flag&gt;</kbd> to the runtime system.</td>
<td>N/A</td>
</tr>
<tr>
<td><kbd>-stack&lt;bool&gt;</kbd></td>
<td>Toggles tracking of object allocation call stack.</td>
<td><kbd>true</kbd></td>
</tr>
<tr>
<td><kbd>-refs&lt;bool&gt;</kbd></td>
<td>Toggles tracking of references to objects.</td>
<td><kbd>true</kbd></td>
</tr>
<tr>
<td><kbd>-port&lt;port&gt;</kbd></td>
<td>Indicates the port for the JHAT HTTP server.</td>
<td><kbd>7000</kbd></td>
</tr>
<tr>
<td><kbd>-exclude&lt;exclude-filename&gt;</kbd></td>
<td>Exclude indicated file from reachable objects query.</td>
<td>N/A</td>
</tr>
<tr>
<td><kbd>-baseline&lt;filename&gt;</kbd></td>
<td>Specifies the baseline heap dump for use in comparisons.</td>
<td>N/A</td>
</tr>
<tr>
<td><kbd>-debug&lt;int&gt;</kbd></td>
<td>Sets verbosity of output.</td>
<td>N/A</td>
</tr>
<tr>
<td><kbd>-version</kbd></td>
<td>Simply outputs the <span>JHAT</span> release number.</td>
<td>N/A</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>-h</kbd></p>
<p><kbd>-help</kbd></p>
</td>
<td>Provides help text.</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p> </p>
<p>JHAT has been part of the Java platform since JDK-6 in an experimental form. It was not supported and has been deemed to be outdated. Starting with Java 9, this tool will no longer be part of the JDK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JVM command-line flag argument validation [JEP 245]</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have gained exposure to much of the command-line flag usage with the Java 9 platform. Java Enhancement Proposal 245, titled <em>Validate JVM Command-Line Flag Arguments</em>, was created to ensure all JVM command-line flags with arguments are validated. The primary goals of this effort were:</p>
<ul>
<li>Avoid JVM crashes</li>
<li>Provide error messages to inform of invalid flag arguments</li>
</ul>
<p>As you can see from the following graphic, there was no attempt to auto-correct the flag argument errors; rather, just to identify the errors and prevent the JVM from crashing:</p>
<div class="CDPAlignCenter CDPAlign"><img height="156" width="239" src="assets/f1063222-f613-4e35-8b74-2ab7485d80dc.png"/></div>
<p>A sample error message is provided here and indicates that the flag argument was out of range. This error would be displayed during the flag argument range check performed during the JVM's initialization:</p>
<pre><strong>exampleFlag UnguardOnExecutionViolation = 4 is outside the allowed range [ 0 . . . 3]</strong></pre>
<p>Here are some specifics regarding this change to the Java platform:</p>
<ul>
<li>Expand on the current <kbd>globals.hpp</kbd> source file to ensure complete flag default values and permissible ranges are documented</li>
<li>Define a framework to support adding new JVM command-line flags in the future:
<ul>
<li>This will include value ranges and value sets</li>
<li>This will ensure the validity checking will apply to all newly added command-line flags</li>
</ul>
</li>
<li>Modify macro tables:
<ul>
<li>Add min/max for optional range</li>
<li>Add constraint entries for the following:
<ul>
<li>Ensure constraint checks are performed each time a flag changes</li>
<li>All manageable flags will continue to be checked while the JVM is running</li>
</ul>
</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compile for older platform versions [JEP 247]</h1>
                </header>
            
            <article>
                
<p>The Java Compiler, <kbd>javac</kbd>, has been updated for Java 9 to ensure it can be used to compile Java programs to run on user-selected older versions of the Java platform. This was the focus of Java Enhancement Proposal 247, <strong>Compile for Older Platform Versions</strong>.</p>
<p>As you can see in the following screenshot, <kbd>javac</kbd> has several options including <kbd>-source</kbd> and <kbd>-target</kbd>. The <kbd>javac</kbd> presented in the following screenshot is from Java 8:</p>
<div class="CDPAlignCenter CDPAlign"><img height="400" width="656" src="assets/a45da48e-a26e-46ea-b76a-ff52b0ba85a8.png"/></div>
<p>The <kbd>-source</kbd> option is used to dictate the Java version accepted by the compiler. The <kbd>-target</kbd> option informs which version of class files <kbd>javac</kbd> will produce. By default, <kbd>javac</kbd> generates class files in the most recent java version and that of the platform APIs. This can cause a problem when the compiled application uses APIs that are only available in the most recent platform version. This would render the application ineligible to run on older platform versions, despite what is dictated with the <kbd>-source</kbd> and <kbd>-target</kbd> options.</p>
<p>To address the aforementioned problem, a new command-line option is introduced with the Java 9 platform. This option is the <kbd>--release</kbd> option and, when used, will automatically configure javac to generate class files that link against a specific platform version. The following screenshot shows the <kbd>javac</kbd> options with the Java 9 platform. As you can see, the new <kbd>--release</kbd> option is included:</p>
<div class="CDPAlignCenter CDPAlign"><img height="600" width="425" src="assets/f85e9e29-06fe-48cc-a36c-a87a4404d6a3.png"/></div>
<p>Here is the syntax for the new option:</p>
<pre><strong>javac --release &lt;release&gt; &lt;source files&gt;</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter we explored several changes to the Java 9 platform with the common theme of command-line flags. Specifically, we covered <span>unified JVM logging,</span> compiler control, <span>new diagnostic commands, removal of the HPROF h</span><span>eap profiling agent, the removal of the</span> <span>JHAT,</span> <span>command-line flag argument validation, and</span> <span>the ability to compile for older platform versions.</span></p>
<p>In the next chapter, we will focus on best practices with additional utilities provided with the Java 9 platform. These will include UTF-8, Unicode 7.0, Linux, and more.</p>


            </article>

            
        </section>
    </body></html>