- en: Application Packaging and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring Boot executable JAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building self-executing binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot environment configuration, hierarchy, and precedence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a custom PropertySource to the environment using EnvironmentPostProcessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using property files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using Java system properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Consul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using Consul and envconsul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What good is an application unless it is being used? In today's day and age—when
    DevOps has become the way of doing software development, when the cloud is the
    king, and when building microservices is considered the thing to do—a lot of attention
    is being focused on how applications get packaged, distributed, and deployed in
    their designated environments.
  prefs: []
  type: TYPE_NORMAL
- en: The Twelve-Factor App methodology has played an instrumental role in defining
    how a modern **Software as a Service** (**SaaS**) application is supposed to be
    built and deployed. One of the key principles is the separation of environmental
    configuration definitions from the application and storage of this in the environments.
    The Twelve-Factor App methodology also favors the isolation and bundling of the
    dependencies, development versus production parity, and ease of deployment and
    disposability of the applications, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: The Twelve-Factor App methodology can be found at [http://12factor.net/](http://12factor.net/).
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps model also encourages us to have complete ownership of our application,
    starting from writing and testing the code all the way to building and deploying
    it. If we are to assume this ownership, we need to ensure that the maintenance
    and overhead costs are not excessive and won't take away much time from our primary
    task of developing new features. This can be achieved by having clean, well-defined,
    and isolated deployable artifacts, which are self-contained, self-executed, and
    can be deployed in any environment without having to be rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: The following recipes will walk us through all the necessary steps to achieve
    the goal of low-effort deployment and maintenance while having clean and elegant
    code behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring Boot executable JAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot magic would not be complete without providing a nice way to
    package the entire application including all of its dependencies, resources, and
    so on in one composite, executable JAR file. After the JAR file is created, it
    can simply be launched by running a `java -jar <name>.jar` command.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue with the application code that we built in the previous chapters
    and will add the necessary functionalities to package it. Let's go ahead and take
    a look at how to create the Spring Boot Uber JAR.
  prefs: []
  type: TYPE_NORMAL
- en: The Uber JAR is typically known as an application bundle encapsulated in a single
    composite JAR file that internally contains a `/lib` directory with all the dependent
    inner jars and optionally a `/bin` directory with the executables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go to our code directory from [Chapter 5](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml),
    *Application Testing*, and execute `./gradlew clean build`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Uber JAR built, let's launch the application by executing `java -jar
    build/libs/ch6-0.0.1-SNAPSHOT.jar`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will result in our application running in the JAR file with the following
    console output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, getting the packaged executable JAR file is fairly straightforward.
    All the magic is already coded and provided to us as part of the Spring Boot Gradle
    plugin. The addition of the plugin adds a number of tasks, which allow us to package
    the Spring Boot application, run it and build the JAR, TAR, WAR files, and so
    on. For example, the `bootRun` task, which we have been using throughout this
    book, is provided by the Spring Boot Gradle plugin, among others. We can see a
    complete list of the available Gradle tasks by executing `./gradlew tasks`. When
    we run this command, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output is not complete; I''ve excluded the non-relevant task
    groups such as IDE, documentation, and so on, but you will see them on your console.
    In the task list, we will see tasks such as `bootRun`, `bootJar`, and others.
    These tasks have been added by the Spring Boot Gradle plugin and executing them
    gets the required Spring Boot steps added to the build pipeline. You can see the
    actual task dependency if you execute `./gradlew tasks --all`, which will not
    only print the visible tasks, but also the depended, internal tasks, and the task
    dependencies. For example, when we were running the `build` task, all the following
    dependent tasks were executed as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `build` task will execute the `assemble` task, which in
    turn will call `bootJar`, where the creation of the Uber JAR is actually taking
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin also provides a number of very useful configuration options. While
    I am not going to go into detail about all of them, I''ll mention the two that
    I find very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This configuration allows us to specify the executable JAR file `classifier`,
    along with the JAR `baseName`, allowing for having the regular JAR contain just
    the application code and the executable JAR with the `classifier` in the name,
    `bookpub-0.0.1-SNAPSHOT-exec.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful configuration option allows us to specify which dependency JARs
    require unpacking because, for some reason, they can''t be included as nested
    inner JARs. This comes in very handy when you need something to be available in
    the system `Classloader` such as setting a custom `SecurityManager` via the startup
    system properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the contents of the `some-jar-name-1.0.3.jar` dependency will
    be unpacked into a temporary folder on a filesystem when the application is launched.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker, Docker, Docker! I hear this phrase more and more in all the conferences
    and tech meetups that I have attended. The arrival of Docker has been welcomed
    by the community with open arms and it has instantly become a hit. The Docker
    ecosystem has been rapidly expanding with many other companies providing services,
    support, and complementing frameworks such as **Apache Mesos**, Amazon Elastic
    Beanstalk, ECS, and Kubernetes, just to name a few. Even Microsoft is providing
    Docker support in their Azure Cloud Service and is partnering with Docker to bring
    Docker to Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for Docker's overwhelming popularity lies in its ability to package
    and deploy applications in a form of self-contained containers. The containers
    are more lightweight than the traditional full-blown virtual machines. Multiple
    numbers of them can be run on top of a single OS instance, thus increasing the
    number of applications that can be deployed on the same hardware compared to traditional
    VMs.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at what it would take to package our Spring
    Boot application as a Docker image and how to deploy and run it.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image and just running it on your development machine is doable,
    but not as much fun as being able to share it with the world. You will need to
    publish it somewhere for it to be deployable, especially if you are thinking of
    using it with Amazon or some other cloud-like environment. Luckily, Docker provides
    us with not only the container solution, but also with a repository service, Docker
    Hub, located at [https://hub.docker.com](https://hub.docker.com), where we can
    create repositories and publish our Docker images. So think of it like Maven Central
    for Docker.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step will be to create an account on Docker Hub so that we can publish
    our images. Go to [https://hub.docker.com](https://hub.docker.com) and create
    an account. You can also use your GitHub account and log in using it if you have
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have an account, we will need to create a repository named `springbootcookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this account created, now is the time to build the image. For this, we
    will use one of the Gradle Docker plugins. We will start by changing `build.gradle`
    to modify the `buildscript` block with the following change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to apply this plugin by adding the `apply plugin: ''docker''`
    directive to the `build.gradle` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to explicitly add the `application` plugin to `build.gradle` as
    well, since it is no longer automatically included by the Spring Boot Gradle plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `apply plugin: ''application''` to the list of plugins in the `build.gradle`
    file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, we will need to add the following Docker configuration to the `build.gradle`
    file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that you already have Docker installed on your machine, we can proceed
    to creating the image by executing `./gradlew clean distDocker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Docker installation instructions, please visit the tutorial that is located
    at [https://docs.docker.com/installation/#installation](https://docs.docker.com/installation/#installation).
    If everything has worked out correctly, you should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also execute the following Docker images command so as to see the newly
    created image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the image built successfully, we are now ready to start it in Docker by
    executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the container has started, we can query the Docker registry for the port
    bindings so that we can access the HTTP endpoints for our service. This can be
    done via the `docker ps` command. If the container is running successfully, we
    should see the following result (names and ports will vary):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From this output, we can tell that the port mapping for the internal port `8080`
    has been set up to be `32778` (your port will vary for every run). Let''s open
    `http://localhost:32778/books` in the browser to see our application in action,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/425c27f4-c4c1-4e8e-876e-c45ddf26145f.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are using macOS X with `boot2docker`, then you won't be running the Docker
    container locally. In this scenario, you will be using the `boot2docker ip` instead
    of the local host to connect to the application. For more tips on how to make
    the `boot2docker` integration easier, please visit [http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide](http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide).
    One can also use a nice Docker façade, generously created by Ian Sinnott, which
    will automatically start boot2docker and handle the environment variables as well.
    To get the wrapper, go to [https://gist.github.com/iansinnott/0a0c212260386bdbfafb](https://gist.github.com/iansinnott/0a0c212260386bdbfafb).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we saw how easy it is to have our `build` package
    the application in a Docker container. The additional Gradle-Docker plugin does
    the bulk of the work of the `Dockerfile` creation, image building, and publishing;
    all we have to do is give it some instructions on what and how we want the image
    to be. Because the Spring Boot Gradle plugin uses a `boot` distribution, the Gradle-Docker
    plugin does not know that it needs to use a bootified TAR archive. To help with
    that, we override the `distDocker` task. Let''s examine these instructions in
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `group` and `description` attributes merely help with displaying the task
    properly when the `./gradlew tasks` command is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `inputs.files project.bootDistTar` directive is very important. This is
    what instructs the `distDocker` task to use the TAR archive created by the Spring
    Boot distribution, instead of the generic one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `def installDir = "/" + project.bootDistTar.archiveName - ".${project.bootDistTar.extension}"`
    directive is creating a variable, containing the directory where the untarred
    artifacts will be placed inside the Docker container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exposePort` directive tells the plugin to add an `EXPOSE <port>` instruction
    to the Dockerfile so that when our container is started, it will expose these
    internal ports to the outside via port mapping. We saw this mapping while running
    the `docker ps` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addFile` directive tells the plugin to add an `ADD <src> <dest>` instruction
    to the Dockerfile so that when the container is being built, we will copy the
    file from the source filesystem in the filesystem in the container image. In our
    case, we will need to copy the `.keystore` certificate file that we configured
    in one of our previous recipes for the HTTPS connector, which we instructed in
    `tomcat.https.properties` to be loaded from `${user.home}/.keystore`. Now, we
    need it to be in the `/root/ directory` directory as, in the container, our application
    will be executed under the root. (This can be changed with more configurations.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Gradle-Docker plugin uses the project name as a name for the image by default.
    The project name, in turn, is being inferred by Gradle from the project's directory
    name, unless an explicit property value is configured. As the code example is
    for [Chapter 6](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml), *Application Packaging
    and Deployment* the project directory is named `ch6`, thus the name of the image.
    The project name can be explicitly configured by adding `name='some_project_name'`
    in `gradle.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the resulting Dockerfile, which can be found in the `build/docker/`
    directory at the root of the project, you will see the following two instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `ADD` instruction adds the TAR application archive that was produced by
    the `bootDistTar` task and contains our application bundled up as a tarball. We
    can even see the contents of the produced tarball by executing `tar tvf build/distributions/ch6-boot-0.0.1-SNAPSHOT.tar`.
    During the building of the container, the contents of the TAR file will be extracted
    in the `/` directory in the container and later used to launch the application.
  prefs: []
  type: TYPE_NORMAL
- en: It is followed by the `ENTRYPOINT` instruction. This tells Docker to execute
    `/ch6-boot-0.0.1-SNAPSHOT/bin/ch6`, which we saw as part of the tarball content,
    once the container is started, thus automatically launching our application.
  prefs: []
  type: TYPE_NORMAL
- en: The first line in the Dockerfile, which is `FROM aglover/java8-pier`, is the
    instruction to use the `aglover/java8-pier` image, which contains the Ubuntu OS
    with Java 8 installed as a base image for our container, on which we will install
    our application. This image comes from the Docker Hub Repository and is automatically
    used by the plugin, but can be changed via the configuration settings, if so desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you created an account on Docker Hub, we can also publish the created Docker
    image to the registry. As fair warning, the resulting image could be many hundreds
    of megabytes in size so uploading it could take some time. To publish this image,
    we will need to change the tag to `tag "<docker hub username>/<docker hub repository
    name>"` and add the `push true` setting to the `distDocker` task definition in
    `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `tag` property sets up the created image tag and, by default, the plugin
    assumes that it is residing in the Docker Hub Repository. This is where it will
    be publishing it if the `push` configuration is set to `true`, as it is in our
    case.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of all the Gradle-Docker plugin configuration options, take
    a look at the [https://github.com/Transmode/gradle-docker](https://github.com/Transmode/gradle-docker)
    GitHub project page.
  prefs: []
  type: TYPE_NORMAL
- en: 'When launching a Docker image, we use the `-d` and `-P` command-line arguments.
    Their uses are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: This argument indicates the desire to run the container in a detached
    mode where the process starts in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P`: This argument instructs Docker to publish all the internally exposed
    ports to the outside so that we can access them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a detailed explanation of all the possible command-line options, refer to
    [https://docs.docker.com/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/).
  prefs: []
  type: TYPE_NORMAL
- en: Building self-executing binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Spring Boot version 1.3, the Gradle and Maven plugins support the option
    of generating true executable binaries. These look like normal JAR files, but
    have the content of JAR fused together with the launch script that contains the
    command-building logic and is capable of self-starting itself without the need
    to execute the `java -jar file.jar` command explicitly. This capability comes
    in very handy as it allows for the easy configuration of Linux autostart services
    such as `init.d` or `systemd`, and `launchd` on macOS X.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use our existing application build. We will examine
    how the self-starting executable JAR files get created and how to modify the default
    launch script to add support for the custom JVM start up arguments, such as the
    `-D` start up system properties, JVM memory, Garbage Collection, and other settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, make sure that `build.gradle` is using Spring Boot version
    2.0.0 or above. If it is not, then change the following setting in the `buildscript`
    configuration block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The same upgrade of the Spring Boot version should be done in the `db-counter-starter/build.gradle`
    file as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a default self-executing JAR file is very easy; actually, it is done
    automatically once we execute the `./gradlew clean bootJar` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can proceed to launch the created application simply by invoking `./build/libs/bookpub-0.0.1-SNAPSHOT.jar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In an enterprise environment, it is rare that we are satisfied with the default
    JVM launch arguments as we often need to tweak the memory settings, GC configurations,
    and even pass the startup system properties in order to ensure that we are using
    the desired version of the XML parser or a proprietary implementation of class
    loader or security manager. To accomplish those needs, we will modify the default
    `launch.script` file to add support for the JVM options. Let's start by copying
    the default `launch.script` file from the [https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script)
    Spring Boot GitHub repository in the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `launch.script` file is supported only on Linux and OS X environments. If
    you are looking to make self-executing JARs for Windows, you will need to provide
    your own `launch.script` file that is tailored for the Windows shell command execution.
    The good news is that it is the only special thing that is required; all the instructions
    and concepts in this recipe will work just fine on Windows as well, provided that
    the compliant `launch.script` template is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will modify the copied `launch.script` file and add the following content
    right above the *line 142* mark (this is showing only the relevant part of the
    script so as to condense the space):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the custom `launch.script` file in place, we will need to add the options
    setting to our `build.gradle` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to launch our application. First, let's use the `./gradlew
    clean bootRun` command, and if we look at the JConsole VM Summary tab, we will
    see that our arguments indeed have been passed to the JVM, as follows:![](img/dd0b250c-6176-4663-9d7f-d74644feb2fe.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also build the self-starting executable JAR by running the `./gradlew
    clean bootJar` command and then executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`
    in order to launch our application. We should expect to see a similar result in
    JConsole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, we can also use the `JAVA_OPTS` environment variable to override
    some of the JVM arguments. Say we want to change the minimum memory heap size
    to 128 megabytes. We can launch our application using the `JAVA_OPTS=-Xmx128m
    ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar` command and this would show us the
    following effect in JConsole:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20ed07bc-00c6-490b-89c5-9d1e20772536.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a small customization to `launch.script`, we were able to create a self-executing
    deployable application, packaged as a self-contained JAR file, which on top of
    everything else can also be configured in order to be launched using the various
    OS-specific autostarting frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot Gradle and Maven plugins provide us with lots of options for
    parameter customization and even an ability to embed mustache-like template placeholders
    in `launch.script`, which can later be replaced with values during build time.
    We have leveraged this capability to inject our JVM arguments into the file using
    the `launchScript{properties}` configuration setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our custom version of `launch.script`, we added the `jvmopts="{{jvm_options:}}"`
    line, which will be replaced with the value of the `jvm_options` parameter during
    the build and packaging time. This parameter is declared in our `build.gradle`
    file as a value of the `launchScript.properties` argument `: launchScript{properties
    ''jvm_options'' : applicationDefaultJvmArgs.join('' '')}`.'
  prefs: []
  type: TYPE_NORMAL
- en: The JVM arguments can be hardcoded, but it is much better to maintain consistency
    between how our application starts using the `bootRun` task and how it starts
    when launched from the self-executing JAR. To achieve this, we will use the same
    `applicationDefaultJvmArgs` collection of arguments that we will define for the
    `bootRun` execution purpose, only with all the different arguments collapsed in
    a single line of text separated by white spaces. Using this approach, we have
    to define the JVM arguments only once and use them in both modes of execution.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to notice that this reuse also applies to the application distributions
    that are built using the `distZip` and `distTar` tasks defined by Gradle's `application`
    plugin, as well as Spring Boot Gradle's `bootDistZip` and `bootDistTar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify the build to create the Docker image by launching our self-executing
    JAR instead of the contents of the TAR file produced by the `distTar` task by
    default. To do this, we will need to change our `distDocker` configuration block
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will make our `distDocker` task put the executable jar inside a Docker
    image instead of a TAR archive.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot environment configuration, hierarchy, and precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous few recipes, we looked at how to package our application in
    a variety of ways and how it can be deployed. The next logical step is the need
    to configure the application in order to provide some behavioral control as well
    as some environment-specific configuration values, which could and most likely
    will vary from environment to environment.
  prefs: []
  type: TYPE_NORMAL
- en: A common example of such an environmental configuration difference is the database
    setup. We certainly don't want to connect to a production environment database
    with an application running on our development machine. There are also cases where
    we want an application to run in different modes or use a different set of profiles,
    as they are referred to by Spring. An example could be running an application
    in live or simulator mode.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will pick up from the previous state of the code base and
    add the support for different configuration profiles as well as examine how to
    use the property values as placeholders in other properties.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by adding an `@Profile` annotation to the `@Bean` creation of
    `schedulerRunner` by changing the definition of the `schedulerRunner(...)` method
    in `BookPubApplication.java`, located in the `src/main/java/org/test/bookpub`
    directory at the root of our project, to the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the application is running, we should no longer see the previous log output
    from the `StartupRunner` class, which looked like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's build the application by running `./gradlew clean bootJar` and start
    it by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`;
    we will see the log output line show up again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another functionality that is enabled by the profile selector is the ability
    to add profile-specific property files. Let''s create an `application-inmemorydb.properties`
    file in the `src/main/resources` directory at the root of our project with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's build the application by running `./gradlew clean bootJar` and start it
    by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger,inmemorydb`,
    which will use the `inmemorydb` profile configuration in order to use the in-memory
    database instead of the file-based one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we experimented with using profiles and applying additional
    configuration settings based on the active profiles. Profiles were first introduced
    in Spring Framework 3.2 and were used to conditionally configure the beans in
    context, depending on which profiles were active. In Spring Boot, this facility
    was extended even further to allow configuration separation as well.
  prefs: []
  type: TYPE_NORMAL
- en: By placing an `@Profile("logger")` annotation on our `StartupRunner@Bean` creation
    method, Spring will be instructed to create the bean only if the logger profile
    has been activated. Conventionally, this is done by passing the `--spring.profiles.active`
    option in the command line during the application startup. In the tests, another
    way that this can be done is using the `@ActiveProfiles("profile")` annotation
    on the `Test` class, but it is not supported for the execution of a normal application.
    It is also possible to negate profiles such as `@Profile("!production")`. When
    such an annotation is used (with `!` marking the negation), the bean will be created
    only if no profile production is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'During startup, Spring Boot treats all the options that get passed via the
    command line as application properties, and thus anything that gets passed during
    startup ends up as a property value that is capable of being used. This same mechanism
    not only works for new properties but can be used as a way of overriding the existing
    properties as well. Let''s imagine a situation where we already have an active
    profile defined in our `application.properties` file that looks like this: `spring.profiles.active=basic`.
    By passing the `--spring.profiles.active=logger` option via the command line,
    we will replace the active profile from `basic` to `logger`. If we want to include
    some profiles regardless of the active configuration, Spring Boot gives us a `spring.profiles.include`
    option to configure. Any profiles that are set up this way will be added to the
    list of active profiles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As these options are nothing more than regular Spring Boot application properties,
    they all follow the same hierarchy for override precedence. The options have been
    outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-line arguments**: These values supersede every other property source
    in the list, and you can always rest assured that anything passed via `--property.name=value`
    will take precedence over the other means.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JNDI attributes**: They are the next in precedence priority. If you are using
    an application container that provides data via a JNDI `java:comp/env` namespace,
    these values will override all the other settings from below.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java system properties**: These values are another way to pass the properties
    to the application either via the `-Dproperty=name` command-line arguments or
    by calling `System.setProperty(...)` in the code. They provide another way to
    replace the existing properties. Anything coming from `System.getProperty(...)`
    will win over the others in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OS environment variables**: Whether from Windows, Linux, OS X, or any other,
    they are a common way to specify a configuration, especially for locations and
    values. The most notable one is `JAVA_HOME`, which is a common way to indicate
    where the JVM location resides in the filesystem. If neither of the preceding
    settings are present, the `ENV` variables will be used for the property values
    instead of the ones mentioned as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the OS environment variables typically don't support dots (`.`) or dashes
    (`-`), Spring Boot provides an automatic remapping mechanism that replaces the
    underscores (`_`) with dots (`.`) during the property evaluation; it also handles
    the case conversion. Thus, `JAVA_HOME` becomes synonymous with `java.home`.
  prefs: []
  type: TYPE_NORMAL
- en: '`random.*`: This provides special support for the random values of primitive
    types that can be used as placeholders in configuration properties. For example,
    we can define a property named `some.number=${random.int}` where `${random.int}`
    will be replaced by some random integer value. The same goes for `${random.value}`
    for textual values and `${random.long}` for longs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application-{profile}.properties`: They are the profile-specific files that
    get applied only if a corresponding profile gets activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application.properties`: They are the main property files that contain the
    base/default application configuration. Similar to the profile-specific ones,
    these values can be loaded from the following list of locations, with the top
    one taking priority over the lower entries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file:config/`: This is a `/config` directory located in the current directory:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file:`: This is the current directory'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`classpath:/config`: This is a `/config` package in the classpath'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`classpath:`: This is a root of the classpath'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Configuration annotated classes annotated with @PropertySource**: These
    are any in-code property sources that have been configured using annotations.
    We have seen an example of such usage the *Adding custom connectors* recipe from
    [Chapter 3](f10744d1-32d1-4047-a3a6-df7e9a3ede92.xhtml), *Web Framework Behavior
    Tuning*. They are very low in the precedence chain and are only preceded by the
    default properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default properties**: They are configured via the `SpringApplication.setDefaultProperties(...)`
    call and are seldom used, as it feels very much like hardcoding values in code
    instead of externalizing them in configuration files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a custom PropertySource to the environment using EnvironmentPostProcessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In cases where the enterprise is already using a particular configuration system,
    custom written or off the shelf, Spring Boot provides us with a facility to integrate
    this into the application via the creation of a custom `PropertySource` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that we have an existing configuration setup that uses a popular
    Apache Commons Configuration framework and stores the configuration data in XML
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To mimic our supposed pre-existing configuration system, add the following
    content to the dependencies section in the `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow this up by creating a simple configuration file named `commons-config.xml`
    in the `src/main/resources` directory at the root of our project with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the `PropertySource` implementation file named `ApacheCommonsConfigurationPropertySource.java`
    in the `src/main/java/org/test/bookpub` directory at the root of our project with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create the `EnvironmentPostProcessor` implementation class so as
    to bootstrap our `PropertySource` named `ApacheCommonsConfigurationEnvironmentPostProcessor.java`
    in the `src/main/java/org/test/bookpub` directory at the root of our project with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will need to create a new directory named `META-INF` in the `src/main/resources`
    directory at the root of our project and create a file named `spring.factories`
    in it with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the setup done, we are now ready to use our new properties in our application.
    Let''s change the configuration of the `@Scheduled` annotation for our `StartupRunner`
    class located in the `src/main/java/org/test/bookpub` directory at the root of
    our project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's build the application by running `./gradlew clean bootJar` and start it
    by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`
    in order to ensure that our `StartupRunner` class is still logging the book count
    every ten seconds, as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have explored how to add our own custom `PropertySource`
    that allowed us to bridge the existing system in the Spring Boot environment.
    Let's look into the inner workings of how the pieces fit together.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we learned how the different configuration definitions
    stacked up and what rules were used to overlay them on top of each other. This
    will help us to better understand how the bridging of an Apache Commons Configuration,
    using a custom `PropertySource` implementation, works. (This should not be confused
    with an `@PropertySource` annotation!)
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](6139967b-794e-479a-8461-d3197eb0322e.xhtml), *Writing Custom
    Spring Boot Starters*, we learned about the use of `spring.factories`, and so
    we already know that this file serves to define the classes that should automatically
    be incorporated by Spring Boot during application startup. The only difference
    this time is that instead of configuring the `EnableAutoConfiguration` settings,
    we will configure the `SpringApplicationRunListener` ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created the following two classes to support our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApacheCommonsConfigurationPropertySource`: This is the extension of the `EnumerablePropertySource`
    base class that provides you with internal functionality in order to bridge XMLConfiguration
    from Apache Commons Configuration to the world of Spring Boot by providing transformation
    to get the specific property values by name via the `getProperty(String name)`
    implementation, and the list of all the supported property names via the `getPropertyNames()`
    implementation. In situations where you are dealing with the use case when the
    complete list of the available property names is not known or is very expensive
    to compute, you can just extend the `PropertySource` abstract class instead of
    using `EnumerablePropertySource`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApacheCommonsConfigurationEnvironmentPostProcessor`: This is the implementation
    of the `EnvironmentPostProcessor` interface that gets instantiated by Spring Boot
    during the application startup and receives notification callback after the initial
    environment initialization has been completed, but before the application context
    startup. This class is configured in `spring.factories` and is automatically created
    by Spring Boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our post-processor, we implement the `postProcessEnvironment(ConfigurableEnvironment
    environment, SpringApplication application)` method, which gives us access to
    the `ConfigurableEnvironment` instance. By the time this callback is invoked,
    we will get an environment instance that has already been populated with all of
    the properties from the preceding hierarchy. However, we will get the opportunity
    to inject our own `PropertySource` implementation anywhere in the list, which
    we will successfully do in the `ApacheCommonsConfigurationPropertySource.addToEnvironment(...)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will choose to insert our source right below `systemEnvironment`
    in the order of precedence, but if needs be, we can alter this order to whatever
    highest precedence we desire. Just be careful not to place it so high that your
    properties become impossible to override via the command-line arguments, system
    properties, or environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using property files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe taught us about the application properties and how they
    are provisioned. As was mentioned at the beginning of this chapter, during application
    deployment, it is almost inevitable to have some property values that are environment
    dependant. They can be database configurations, service topologies, or even simple
    feature configurations where something might be enabled in development but not
    quite ready for production just yet.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use an externally residing properties file
    for an environment-specific configuration, which might reside in the local filesystem
    or out in the wild on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the same application with all the existing configurations
    as we used in the previous recipe. We will use it to experiment with starting
    up using the external configuration properties that are living in the local filesystem
    and from an internet URL, such as GitHub or any other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding a bit of code to log the value of our particular configuration
    property so that we can easily see the change in it as we do different things.
    Add an `@Bean` method to the `BookPubApplication` class located in the `src/main/java/org/test/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the application by running `./gradlew clean bootJar` and start
    it by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`
    so as to see the following log output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The value is empty, as we expected. Next, we will create a file named `external.properties`
    in our home directly with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our application by executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger --spring.config.location=file:/home/<username>/external.properties`
    in order to see the following output in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For macOS users, the home directories can be found in the `/Users/<username>`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: We can also load the file as an HTTP resource and not from the local filesystem.
    So, place a file named `external.properties` with the content of `my.config.value=From
    HTTP Config` somewhere on the web. It can even be checked in a GitHub or BitBucket
    repository, as long as it is accessible without any need for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run our application by executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger --spring.config.location=http://<your file location
    path>/external.properties` in order to see the following output in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before delving into the details of an external configuration setup, let's quickly
    look at the code that was added in order to print the property value in the log.
    The element of focus is the `@Value` annotation that can be used on class fields
    or method arguments; it also instructs Spring to automatically inject the annotated
    variable with the value defined in the annotation. If the value is positioned
    in the wrapping curly braces prefixed with a dollar sign, (`${ }`), Spring will
    replace this with the value from the corresponding application property or with
    the default value, if it is provided, by adding the textual data after the colon
    (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we defined it as `@Value("${my.config.value:}")String configValue`,
    so unless an application property named `my.config.value` exists, the default
    value of an empty String will be assigned to the `configValue` method argument.
    This construct is quite handy and eliminates the need to explicitly wire in the
    instance of an environment object just to get a specific property value out of
    it, as well as simplifying the code during testing, with less objects to mock.
  prefs: []
  type: TYPE_NORMAL
- en: The support for being able to specify the location of the application properties
    configuration file is geared towards supporting a dynamic multitude of environmental
    topologies, especially in cloud environments. This is often the case when the
    compiled application gets bundled into different cloud images that are destined
    for different environments and are being specially assembled by deployment tools
    such as Packer, Vagrant, and others.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, it is very common to drop a configuration file in the image
    filesystem while making the image, depending on what environment it is destined
    for. Spring Boot provides a very convenient ability to specify, via the command-line
    arguments, where the configuration properties file, which should be added to the
    application configuration bundle, resides.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `--spring.config.location` startup option, we can specify a location
    of one or multiple files, which can then be separated by a comma (`,`) to be added
    to the default ones. The file designations can be either files from a local filesystem,
    a classpath, or a remote URL. The locations will be resolved either by the `DefaultResourceLoader`
    class or, if configured via a `SpringApplication` constructor or setter, by the
    implementation that is provided by the `SpringApplication` instance.
  prefs: []
  type: TYPE_NORMAL
- en: If the location contains directories, the names should end with a `/` so as
    to let Spring Boot know that it should look for the `application.properties` file
    in these directories.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change the default name of the file, Spring Boot provides you
    with this ability as well. Just set the `--spring.config.name` option to whatever
    filename that you want.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the default search paths for the configuration
    of `classpath:,classpath:/config,file:,file:config/` will always be used regardless
    of the presence of the `--spring.config.location` setting. This way, you can always
    retain your default configuration in `application.properties` and just override
    the ones that you need via the start up settings.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we have, a number of times, alluded to the fact that
    configuration values to a Spring Boot application can be passed and overridden
    by using OS environment variables. Operating systems rely on these variables to
    store information about various things. We probably have to set `JAVA_HOME` or
    `PATH` a few times, and these are examples of environment variables. OS environment
    variables is also a very important feature if one deploys their application using
    a PaaS system such as Heroku or Amazon AWS. In these environments, configuration
    values such as database access credentials and various API tokens are all provided
    over the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Their power comes from the ability to completely externalize the configuration
    of simple key-value data pairs without the need to rely on placing a property
    or some other files in a particular location, and having this hardcoded in the
    application code base. These variables are also agnostic to the particular operating
    system and can be consumed in the Java program in the same way, `System.getenv()`,
    regardless of which OS the program is running on.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how this power can be leveraged to pass the
    configuration properties to our Spring Boot applications. We will continue to
    use the code base from the previous recipe and experiment with a few different
    ways of starting the application and using the OS environment variables in order
    to change the configuration values of some properties.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we added a configuration property named `my.config.value`.
    Let''s build the application by running `./gradlew clean bootJar` and start it
    by running `MY_CONFIG_VALUE="From ENV Config" ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger` so as to see the following output in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If we want to use the environment variables while running our application via
    the Gradle `bootRun` task, the command line will be `MY_CONFIG_VALUE="From ENV
    Config" ./gradlew clean bootRun` and should produce the same output as in the
    preceding step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Conveniently enough, we can even mix and match how we set the configurations.
    We can use the environment variable to configure the `spring.config.location`
    property and use it to load other property values from the external properties
    file, as we did in the previous recipe. Let''s try this by launching our application
    by executing `SPRING_CONFIG_LOCATION= file:/home/<username>/external.properties
    ./gradlew bootRun`. We should see the following in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While using environment variables is very convenient, it does have maintenance
    overhead if the number of these variables gets to be too many. To help deal with
    this issue, it is good practice to use a method of delegation by setting the `SPRING_CONFIG_LOCATION`
    variable to configure the location of the environment-specific properties file,
    typically by loading them from a URL location.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you learned from the section on environment configuration hierarchy, Spring
    Boot offers multiple ways of providing the configuration properties. Each of these
    is managed via an appropriate `PropertySource` implementation. We looked at how
    to create a custom implementation of `PropertySource` when we were implementing
    `ApacheCommonsConfigurationPropertySource`. Spring Boot already provides a `SystemEnvironmentPropertySource`
    implementation for us to use out of the box. This even gets automatically registered
    with the default implementation of the environment interface: the `SystemEnvironment`.'
  prefs: []
  type: TYPE_NORMAL
- en: As the `SystemEnvironment` implementation provides a composite façade on top
    of a multitude of different `PropertySource` implementations, the overriding takes
    place seamlessly, simply because the `SystemEnvironmentPropertySource` class sits
    higher up in the list than the `application.properties` file one.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect that you should notice is the use of `ALL_CAPS` with underscores
    (`_`) in order to separate the words instead of the traditional conventional `all.lower.cased`
    format with dots (`.`) separating the words used in Spring Boot to name the configuration
    properties. This is due to the nature of some operating systems, namely Linux
    and OS X, which prevent the use of dots (`.`) in the names and instead encourages
    the use of the `ALL_CAPS` underscore-separated notation.
  prefs: []
  type: TYPE_NORMAL
- en: In situations where the usage of environment variables to specify or override
    the configuration properties is not desired, Spring provides us with the `-Dspring.getenv.ignore`
    system property, which can be set to true and prevents the usage of environment
    variables. You might want to change this setting to true if you see errors or
    exceptions in the log due to the running of your code on some application servers
    or a particular security policy configuration that might not allow access to environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing an environmental configuration using Java system properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While environment variables can, on rare occasions, be hit or miss, the good
    old Java system properties can always be trusted to be there for you. In addition
    to using the environment variables and command-line arguments represented by the
    property names prefixed with a double dash (`--`), Spring Boot provides you with
    the ability to use the plain Java system properties to set or override the configuration
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful in a number of situations, particularly if your application
    is running in a container that sets certain values during startup via the system
    properties that you want to get access to, or if a property value is not set via
    a command-line `-D` argument, but rather in some library via code and by calling
    `System.setProperty(...)`, especially if property value is being accessed from
    inside a static method of sorts. While arguably these cases are rare, it takes
    only one to make you bend over backwards in an effort to try and integrate this
    value into your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the same application executable that was used for
    the previous one, with the only difference being that we are using Java system
    properties instead of command-line arguments or environment variables to set our
    configuration properties at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue our experiments by setting the `my.config.value` configuration
    property. Build the application by running `./gradlew clean bootJar` and start
    it by running `java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`
    so as to see the following in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to be able to set the Java system property while running our application
    using the Gradle''s `bootRun` task, we will need to add this to the `applicationDefaultJvmArgs`
    configuration in the `build.gradle` file. Let''s add `-Dmy.config.value=Gradle`
    to this list and start the application by running `./gradlew clean bootRun`. We
    should see the following in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As we made the `applicationDefaultJvmArgs` setting to be shared with `launch.script`,
    rebuilding the application by running `./gradlew clean bootJar` and starting it
    by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar` should yield the same
    output in the logs as in the preceding step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have already guessed that Java system properties are consumed by a
    similar mechanism that is used for environment variables, and you would be correct.
    The only real difference is the implementation of `PropertySource`. This time,
    a more generic `MapPropertySource` implementation is used by `StandardEnvironment`.
  prefs: []
  type: TYPE_NORMAL
- en: What you have also probably noticed is the need to launch our application using
    the `java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`
    command instead of just simply invoking the self-executing packaged JAR by itself.
    This is because, unlike the environment variables and command-line arguments,
    Java system properties have to be set on the Java executable ahead of everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: We did manage to work around this need by effectively hardcoding the values
    in our `build.gradle` file, which, combined with the enhancements that we made
    to `launch.script`, allowed us embed the `my.config.value` property in the command
    line in the self-executing jar, as well as use it with the Gradle's `bootRun`
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The risk of using this approach with the configuration properties is that it
    will always override the values that we set in the higher layers of the configuration,
    such as `application.properties` and others. Unless you are explicitly constructing
    the Java executable command line and not using the self-launching capabilities
    of the packaged JAR, it is best not to use Java system properties and consider
    using the command-line arguments or environment variables instead.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing an environmental config using JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at a number of different ways to externally add or override the
    values of specific properties, either by using environment variables, system properties,
    or command-line arguments. All those options provide us with a great deal of flexibility,
    but with the exception of external property files, are all limited to setting
    one property at a time. When it comes to using property files, the syntax is not
    exactly the best at representing nested, hierarchical data structures, and can
    get a bit tricky. To avoid this situation, Spring Boot provides us with an ability
    to also pass, externally, JSON-encoded content containing an entire config hierarchy
    of settings.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the same application executable that was used for
    the previous one, with the only difference being using external JSON content to
    set our configuration properties at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue our experiments by setting the `my.config.value` configuration
    property. Build the application by running `./gradlew clean bootJar` and start
    it by running `java -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.application.json={"my":{"config":{"value":"From
    external JSON"}}}` so as to see the following in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If we want to be able to set the content using Java system properties, we can
    use `-Dspring.application.json` instead, assigning the same JSON content as the
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, we can also rely on the `SPRING_APPLICATION_JSON` environment
    variable to pass the same JSON content in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like every other configuration approach we have looked at, the JSON content
    is consumed by a dedicated `EnvironmentPostProcessor` implementation. The only
    difference is the flattening of the JSON tree into a flat property map, to match
    the dot-separated properties naming style. In our case, the `my->config->value`
    nested map gets converted into a flat map with only one key, `my.config.value`,
    with the value of `From external JSON`.
  prefs: []
  type: TYPE_NORMAL
- en: The setting of the JSON content can come from ANY property source, available
    from the environment at the time of loading, which contains a key named `spring.application.json`
    with a value of valid JSON content, and is not only limited to being set by an
    Environment Variable or using the `SPRING_APPLICATION_JSON` name or Java System
    Property.
  prefs: []
  type: TYPE_NORMAL
- en: This capability can be very useful to provide externally-defined, environment-specific
    configuration in bulk. The best way is to do so via setting the `SPRING_APPLICATION_JSON`
    environment variable on the machine instance using machine/image provisioning
    tools such as Chef, Puppet, Ansible, Packer, and so on. This enables you to store
    an entire configuration hierarchy in one JSON file externally, and then simply
    provision the correct content on the specific machine during provisioning time
    by just setting an Environment Variable. All applications running on that machine
    will automatically consume it upon startup.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything that we have been doing with the configuration was connected
    to the local set of data. In a real, large-scale enterprise environment, this
    is not always the case and quite frequently there is the desire to be able to
    make the configuration changes at large, across hundreds or even thousands of
    instances or machines.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of tools that exist to help you with this task, and in this
    recipe, we will take a look at one that, in my opinion, stands out from the group,
    giving you the ability to cleanly and elegantly configure the environment variables
    for a starting application using a distributed data store. The tool's name is
    **Consul**. It is an open source product from Hashicorp and is designed to discover
    and configure the services in a large, distributed infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at how to install and configure Consul and
    experiment with some key functionalities that it provides. This will give us the
    necessary familiarity for our next recipe, where we will be using Consul to provide
    the configuration values that are needed to start our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to [https://consul.io/downloads.html](https://consul.io/downloads.html) and
    download the appropriate archive, depending on the operating system that you are
    using. Consul supports Windows, OS X, and Linux, so it should work for the majority
    of readers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are an OS X user, you can install Consul using Homebrew by running `brew
    install caskroom/cask/brew-cask` followed by `brew cask install consul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, we should be able to run `consul --version` and see
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With Consul successfully installed, we should be able to start it by running
    the `consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul` command and
    our terminal window will display the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With the Consul service running, we can verify that it contains one member
    by running the `consul members` command, and should see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While Consul can also provide discovery for services, health checks, distributed
    locks, and more, we are going to focus on the key/value service as this is what
    will be used to provide the configuration in the next recipe. So, let's put the
    `From Consul Config` value in the key/value store by executing the `curl -X PUT
    -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Windows, you can get curl from [http://curl.haxx.se/download.html](http://curl.haxx.se/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve the data by running the `curl http://localhost:8500/v1/kv/bookpub/my/config/value`
    command and should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can delete this value by running the `curl -X DELETE http://localhost:8500/v1/kv/bookpub/my/config/value`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to modify the existing value and change it for something else, execute
    the `curl -X PUT -d 'newval' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=20`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed explanation about how Consul works and all the possible options for
    its key/value service would take a book of its own, so here we will look only
    at the basic pieces. It is strongly recommended that you read Consul's documentation
    at [https://consul.io/intro/getting-started/services.html](https://consul.io/intro/getting-started/services.html).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we started the Consul agent in server mode. It acts as a main master
    node and, in real deployment, the local agents running on the individual instances
    will be using the server node to connect to and retrieve data from. For our test
    purposes, we will just use this server node as if it were a local agent.
  prefs: []
  type: TYPE_NORMAL
- en: The information displayed upon startup shows us that our node has started as
    a server node, establishing an HTTP service on port `8500` as well as the DNS
    and RPC services, if that's how one chooses to connect to it. We can also see
    that there is only one node in the cluster, ours, and we are the elected leader
    running in a healthy state.
  prefs: []
  type: TYPE_NORMAL
- en: As we will be using the convenient RESTful HTTP API via cURL, all of our requests
    will be using localhost on port `8500`. Being a RESTful API, it fully adheres
    to CRUD verb terminology, and to insert the data, we will use a `PUT` method on
    a `/v1/kv` endpoint in order to set the `bookpub/my/config/value` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving the data is even more straightforward: we just make a `GET` request
    to the same `/v1/kv` service using the desired key. The same goes for `DELETE`,
    with the only difference being the method name.'
  prefs: []
  type: TYPE_NORMAL
- en: The update operation requires a bit more information in the URL, namely the
    `cas` parameter. The value of this parameter should be the `ModifyIndex` of the
    desired key, which can be obtained from the `GET` request. In our case, it has
    a value of 20.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing an environmental config using Consul and envconsul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we had our Consul service installed and experimented
    with its key/value capabilities to learn how we could manipulate the data in it
    in order to integrate Consul with our application and make the data extraction
    process seamless and non-invasive from an application standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: As we don't want our application to know anything about Consul and have to explicitly
    connect to it, even though such a possibility exists, we will employ another utility,
    also created as open source by Hashicorp, called **envconsul**. It will connect
    to the Consul service for us, extract the specified configuration key/value tree,
    and expose it as the environment variables to be used while also launching our
    application. Pretty cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with launching our application, which was created in the
    previous recipes, we need to install the envconsul utility.
  prefs: []
  type: TYPE_NORMAL
- en: Download the binary for your respective operating system from [https://github.com/hashicorp/envconsul/releases](https://github.com/hashicorp/envconsul/releases)
    and extract the executable to any directory of your choice, though it is better
    to put it somewhere that is in the PATH.
  prefs: []
  type: TYPE_NORMAL
- en: Once envconsul is extracted from the downloaded archive, we are ready to start
    using it so as to configure our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not already added the value for the `my/config/value` key to Consul,
    let's add it by running `curl -X PUT -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is to make sure envconsul can connect to the Consul server and
    that it extracts the correct data based on our configuration key. Let''s execute
    a simple test by running the `envconsul --once --sanitize --upcase --prefix bookpub
    env` command. We should see the following in the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have verified that envconsul is returning the correct data to us,
    we will use it to launch our `BookPub` application by running `envconsul --once
    --sanitize --upcase --prefix bookpub ./gradlew clean bootRun`. Once the application
    has started, we should see the following output in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can do the same thing by building the self-starting executable JAR by running
    `./gradlew clean bootJar`, and start it by running `envconsul --once --sanitize
    --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar` to make
    sure we see the same output in the logs as in the preceding step. If you see `Gradle`
    instead of `From Consul Config`, make sure the `applicationDefaultJvmArgs` configuration
    in `build.gradle` does not have `-Dmy.config.value=Gradle` in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another marvelous ability of envconsul is not only to export the configuration
    key values as environment variables, but also to monitor for any changes and restart
    the application if the values in Consul change. Let''s launch our application
    by running `envconsul --sanitize --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`,
    and we should see the following value in the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now use the consul command to get the current `ModifyIndex` of our
    key and update its value to `From UpdatedConsul Config` by opening another terminal
    window and executing `curl http://localhost:8500/v1/kv/bookpub/my/config/value`,
    grabbing the `ModifyIndex` value, and using it to execute `curl -X PUT -d ''From
    UpdatedConsul Config'' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=<ModifyIndex
    Value>`. We should see our running application magically restart itself and our
    newly updated value displayed in the log at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we just did was pretty sweet, right? Let's examine the magic going on behind
    the scenes in more detail. We will start by dissecting the command line and explaining
    what each argument control option does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first execution command line was `envconsul --once --sanitize --upcase
    --prefix bookpub ./gradlew clean bootRun`, so let''s take a look at exactly what
    we did, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, one might notice that there is no indication about which Consul node
    we should be connecting to. This is because there is an implicit understanding
    or an assumption that you already have a Consul agent running locally on `localhost:8500`.
    If this is not the case for whatever reason, you can always explicitly specify
    the Consul instance to connect via the `--consul localhost:8500` argument added
    to the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `--prefix` option specifies the starting configuration key segment in which
    to look for the different values. When we were adding keys to Consul, we used
    the following key: `bookpub/my/config/value`. By specifying the `--prefix bookpub`
    option, we tell envconsul to strip the `bookpub` part of the key and use all the
    internal tree elements in `bookpub` to construct the environment variables. Thus,
    `my/config/value` becomes the environment variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--sanitize` option tells envconsul to replace all the invalid characters
    with underscores (`_`). So, if we were to only use `--sanitize`, we would end
    up with `my_config_value` as an environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--upcase` option, as you might already have guessed, changes the environment
    variable key to all upper case characters, so when combined with the `--sanitize` option,
    `my/config/value` key gets transformed into the `MY_CONFIG_VALUE` environment
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--once` option indicates that we only want to externalize the keys as environment
    variables once and do not want to continuously monitor for changes in the Consul
    cluster. If a key in our prefix tree has changed its value, we re-externalize
    the keys as environment variables and restart the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last option, `--once`, provides a very useful choice of functionalities.
    If you are interested only in the initial bootstrapping of your application via
    the use of a Consul-shared configuration, then the keys will be set as environment
    variables, the application will be launched, and envconsul will consider its job
    done. However, if you would like to monitor the Consul cluster for changes to
    keys/values and, after the change has taken place, restart your application reflecting
    the new change, then remove the `--once` option and envconsul will restart the
    application once the change has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Such behavior can be very useful and handy for things such as a near-instantaneous
    changes to the database connection configuration. Imagine that you need to do
    a quick failover from one database to another and your JDBC URL is configured
    via Consul. All you need to do is push a new JDBC URL value and envconsul will
    almost immediately detect this change and restart the application, telling it
    to connect to a new database node.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, this functionality is implemented by sending a traditional SIGTERM
    signal to an application running process, telling it to terminate and, once the
    process is exited, restart the application. This might not always be the desired
    behavior, especially if it takes some time for an application to start up and
    be capable of taking traffic. You don't want your entire cluster of web applications
    to be shut down, even if it will only be for a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a better handling of this scenario, envconsul was enhanced to be
    able to send a number of standard signals that can be configured via a newly added
    `--kill-signal` option. Using this option, we can specify any of the SIGHUP, SIGTERM,
    SIGINT, SIGQUIT, SIGUSR1, or SIGUSR2 signals to be used instead of the default
    SIGTERM, to be sent to a running application process once the key/value changes
    have been detected.
  prefs: []
  type: TYPE_NORMAL
- en: The process signal handling in Java is not as clear and straightforward due
    to most of the behavior being very specific to a particular operating system and
    the JVM that is run atop it. Some of the signals in the list will terminate the
    application anyway or, in the case of SIGQUIT, the JVM will print Core Dump into
    the standard output. However, there are ways to configure the JVM, depending on
    the operating system, to let us use SIGUSR1 and SIGUSR2 instead of acting on those
    signals itself, but unfortunately that topic falls outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample example of how to deal with **Signal Handlers**: [https://github.com/spotify/daemon-java](https://github.com/spotify/daemon-java),
    or see the Oracle Java documentation at [https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html)
    for a detailed explanation.'
  prefs: []
  type: TYPE_NORMAL
