- en: Application Packaging and Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序打包和部署
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a Spring Boot executable JAR
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Spring Boot 可执行 JAR 文件
- en: Creating Docker images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像
- en: Building self-executing binaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自执行二进制文件
- en: Spring Boot environment configuration, hierarchy, and precedence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 环境配置、层次结构和优先级
- en: Adding a custom PropertySource to the environment using EnvironmentPostProcessor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EnvironmentPostProcessor 向环境中添加自定义 PropertySource
- en: Externalizing an environmental configuration using property files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性文件外部化环境配置
- en: Externalizing an environmental configuration using environment variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量外部化环境配置
- en: Externalizing an environmental configuration using Java system properties
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java 系统属性外部化环境配置
- en: Externalizing an environmental configuration using JSON
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON 外部化环境配置
- en: Setting up Consul
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Consul
- en: Externalizing an environmental configuration using Consul and envconsul
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Consul 和 envconsul 外部化环境配置
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: What good is an application unless it is being used? In today's day and age—when
    DevOps has become the way of doing software development, when the cloud is the
    king, and when building microservices is considered the thing to do—a lot of attention
    is being focused on how applications get packaged, distributed, and deployed in
    their designated environments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序如果没有被使用，那还有什么意义？在当今这个时代——当 DevOps 成为软件开发的方式，当云成为王者，当构建微服务被认为是应该做的事情时——很多注意力都集中在应用程序如何在指定的环境中打包、分发和部署。
- en: The Twelve-Factor App methodology has played an instrumental role in defining
    how a modern **Software as a Service** (**SaaS**) application is supposed to be
    built and deployed. One of the key principles is the separation of environmental
    configuration definitions from the application and storage of this in the environments.
    The Twelve-Factor App methodology also favors the isolation and bundling of the
    dependencies, development versus production parity, and ease of deployment and
    disposability of the applications, among other things.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用方法在定义现代 **软件即服务** (**SaaS**) 应用程序应该如何构建和部署方面发挥了关键作用。其中一个关键原则是将环境配置定义与应用程序和存储分离。十二要素应用方法还倾向于依赖项的隔离和捆绑、开发与生产一致性、以及应用程序部署的简便性和可丢弃性，以及其他方面。
- en: The Twelve-Factor App methodology can be found at [http://12factor.net/](http://12factor.net/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用方法可以在 [http://12factor.net/](http://12factor.net/) 找到。
- en: The DevOps model also encourages us to have complete ownership of our application,
    starting from writing and testing the code all the way to building and deploying
    it. If we are to assume this ownership, we need to ensure that the maintenance
    and overhead costs are not excessive and won't take away much time from our primary
    task of developing new features. This can be achieved by having clean, well-defined,
    and isolated deployable artifacts, which are self-contained, self-executed, and
    can be deployed in any environment without having to be rebuilt.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 模型还鼓励我们对自己的应用程序拥有完整的所有权，从编写和测试代码到构建和部署。如果我们想要承担这种所有权，我们需要确保维护和运营成本不会过高，并且不会占用我们开发新功能的主要任务太多时间。这可以通过拥有干净、定义良好且隔离的部署工件来实现，这些工件是自包含的、自执行的，并且可以在任何环境中部署而无需重新构建。
- en: The following recipes will walk us through all the necessary steps to achieve
    the goal of low-effort deployment and maintenance while having clean and elegant
    code behind it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱将指导我们完成所有必要的步骤，以实现低努力度的部署和维护，同时保持代码的干净和优雅。
- en: Creating a Spring Boot executable JAR
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Spring Boot 可执行 JAR 文件
- en: The Spring Boot magic would not be complete without providing a nice way to
    package the entire application including all of its dependencies, resources, and
    so on in one composite, executable JAR file. After the JAR file is created, it
    can simply be launched by running a `java -jar <name>.jar` command.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 的魔力如果没有提供一种优雅的方式来打包整个应用程序，包括所有依赖项、资源等，在一个复合的可执行 JAR 文件中，那就不会完整。JAR
    文件创建后，只需运行 `java -jar <name>.jar` 命令即可简单地启动。
- en: We will continue with the application code that we built in the previous chapters
    and will add the necessary functionalities to package it. Let's go ahead and take
    a look at how to create the Spring Boot Uber JAR.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前几章中构建的应用程序代码，并添加必要的功能以打包它。让我们继续看看如何创建 Spring Boot Uber JAR。
- en: The Uber JAR is typically known as an application bundle encapsulated in a single
    composite JAR file that internally contains a `/lib` directory with all the dependent
    inner jars and optionally a `/bin` directory with the executables.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Uber JAR通常被称为一个封装在单个复合JAR文件中的应用程序包，该文件内部包含一个`/lib`目录，其中包含所有依赖的内部JAR，以及可选的包含可执行文件的`/bin`目录。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's go to our code directory from [Chapter 5](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml),
    *Application Testing*, and execute `./gradlew clean build`
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从[第5章](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml)，“应用测试”，进入代码目录，并执行`./gradlew
    clean build`
- en: With the Uber JAR built, let's launch the application by executing `java -jar
    build/libs/ch6-0.0.1-SNAPSHOT.jar`
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建了Uber JAR之后，让我们通过执行`java -jar build/libs/ch6-0.0.1-SNAPSHOT.jar`来启动应用程序
- en: 'This will result in our application running in the JAR file with the following
    console output:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将导致我们的应用程序在以下控制台输出的JAR文件中运行：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you can see, getting the packaged executable JAR file is fairly straightforward.
    All the magic is already coded and provided to us as part of the Spring Boot Gradle
    plugin. The addition of the plugin adds a number of tasks, which allow us to package
    the Spring Boot application, run it and build the JAR, TAR, WAR files, and so
    on. For example, the `bootRun` task, which we have been using throughout this
    book, is provided by the Spring Boot Gradle plugin, among others. We can see a
    complete list of the available Gradle tasks by executing `./gradlew tasks`. When
    we run this command, we will get the following output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，获取打包的可执行JAR文件相当简单。所有的魔法代码都已经编码并提供给我们，作为Spring Boot Gradle插件的组成部分。插件的添加增加了许多任务，允许我们打包Spring
    Boot应用程序，运行它，并构建JAR、TAR、WAR文件等。例如，我们一直在本书中使用到的`bootRun`任务，是由Spring Boot Gradle插件提供的。我们可以通过执行`./gradlew
    tasks`来查看可用的Gradle任务列表。当我们运行此命令时，我们将得到以下输出：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding output is not complete; I''ve excluded the non-relevant task
    groups such as IDE, documentation, and so on, but you will see them on your console.
    In the task list, we will see tasks such as `bootRun`, `bootJar`, and others.
    These tasks have been added by the Spring Boot Gradle plugin and executing them
    gets the required Spring Boot steps added to the build pipeline. You can see the
    actual task dependency if you execute `./gradlew tasks --all`, which will not
    only print the visible tasks, but also the depended, internal tasks, and the task
    dependencies. For example, when we were running the `build` task, all the following
    dependent tasks were executed as well:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出并不完整；我已经排除了非相关任务组，如IDE、文档等，但你将在控制台上看到它们。在任务列表中，我们将看到`bootRun`、`bootJar`和其他任务。这些任务是由Spring
    Boot Gradle插件添加的，执行它们会将所需的Spring Boot步骤添加到构建管道中。如果你执行`./gradlew tasks --all`，你将看到实际的任务依赖关系，这将不仅打印出可见的任务，还包括依赖的内部任务和任务依赖关系。例如，当我们运行`build`任务时，以下所有依赖任务也被执行了：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that the `build` task will execute the `assemble` task, which in
    turn will call `bootJar`, where the creation of the Uber JAR is actually taking
    place.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`build`任务会执行`assemble`任务，然后它会调用`bootJar`，实际上Uber JAR的创建就在这里进行。
- en: 'The plugin also provides a number of very useful configuration options. While
    I am not going to go into detail about all of them, I''ll mention the two that
    I find very useful:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 插件还提供了一些非常实用的配置选项。虽然我不会详细介绍所有这些选项，但我将提到两个我认为非常有用的选项：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This configuration allows us to specify the executable JAR file `classifier`,
    along with the JAR `baseName`, allowing for having the regular JAR contain just
    the application code and the executable JAR with the `classifier` in the name,
    `bookpub-0.0.1-SNAPSHOT-exec.jar`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置允许我们指定可执行JAR文件的`classifier`以及JAR的`baseName`，这样常规JAR中只包含应用程序代码，而可执行JAR则带有`classifier`名称，例如`bookpub-0.0.1-SNAPSHOT-exec.jar`。
- en: 'Another useful configuration option allows us to specify which dependency JARs
    require unpacking because, for some reason, they can''t be included as nested
    inner JARs. This comes in very handy when you need something to be available in
    the system `Classloader` such as setting a custom `SecurityManager` via the startup
    system properties:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的配置选项允许我们指定哪些依赖JAR需要解包，因为出于某种原因，它们不能作为嵌套内部JAR包含在内。当你需要某些内容在系统`Classloader`中可用时，例如通过启动系统属性设置自定义的`SecurityManager`，这会非常有用：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the contents of the `some-jar-name-1.0.3.jar` dependency will
    be unpacked into a temporary folder on a filesystem when the application is launched.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当应用程序启动时，`some-jar-name-1.0.3.jar` 依赖项的内容将被解压缩到文件系统上的一个临时文件夹中。
- en: Creating Docker images
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像
- en: Docker, Docker, Docker! I hear this phrase more and more in all the conferences
    and tech meetups that I have attended. The arrival of Docker has been welcomed
    by the community with open arms and it has instantly become a hit. The Docker
    ecosystem has been rapidly expanding with many other companies providing services,
    support, and complementing frameworks such as **Apache Mesos**, Amazon Elastic
    Beanstalk, ECS, and Kubernetes, just to name a few. Even Microsoft is providing
    Docker support in their Azure Cloud Service and is partnering with Docker to bring
    Docker to Windows operating system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker，Docker，Docker！我在我参加的所有会议和科技聚会上越来越频繁地听到这个短语。Docker 的到来受到了社区的欢迎，它立刻成为了热门。Docker
    生态系统正在迅速扩张，许多其他公司提供服务、支持和补充框架，如 **Apache Mesos**、Amazon Elastic Beanstalk、ECS
    和 Kubernetes，仅举几例。甚至微软也在他们的 Azure 云服务中提供 Docker 支持，并与 Docker 合作将 Docker 带到 Windows
    操作系统。
- en: The reason for Docker's overwhelming popularity lies in its ability to package
    and deploy applications in a form of self-contained containers. The containers
    are more lightweight than the traditional full-blown virtual machines. Multiple
    numbers of them can be run on top of a single OS instance, thus increasing the
    number of applications that can be deployed on the same hardware compared to traditional
    VMs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 极其受欢迎的原因在于其能够以自包含容器形式打包和部署应用程序。这些容器比传统的完整虚拟机更轻量。可以在单个操作系统实例上运行多个容器，因此与传统的虚拟机相比，可以在相同的硬件上部署更多的应用程序。
- en: In this recipe, we will take a look at what it would take to package our Spring
    Boot application as a Docker image and how to deploy and run it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何将我们的 Spring Boot 应用程序打包成 Docker 镜像，以及如何部署和运行它。
- en: Building a Docker image and just running it on your development machine is doable,
    but not as much fun as being able to share it with the world. You will need to
    publish it somewhere for it to be deployable, especially if you are thinking of
    using it with Amazon or some other cloud-like environment. Luckily, Docker provides
    us with not only the container solution, but also with a repository service, Docker
    Hub, located at [https://hub.docker.com](https://hub.docker.com), where we can
    create repositories and publish our Docker images. So think of it like Maven Central
    for Docker.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的开发机器上构建 Docker 镜像并运行它是可行的，但这并不像能够与世界分享那样有趣。您需要将其发布到某个地方以便部署，尤其是如果您打算在亚马逊或其他类似云环境中使用它。幸运的是，Docker
    不仅为我们提供了容器解决方案，还提供了位于 [https://hub.docker.com](https://hub.docker.com) 的仓库服务 Docker
    Hub，我们可以在那里创建仓库并发布我们的 Docker 镜像。所以把它想象成 Docker 的 Maven Central。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The first step will be to create an account on Docker Hub so that we can publish
    our images. Go to [https://hub.docker.com](https://hub.docker.com) and create
    an account. You can also use your GitHub account and log in using it if you have
    one.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在 Docker Hub 上创建账户，这样我们就可以发布我们的镜像。访问 [https://hub.docker.com](https://hub.docker.com)
    并创建账户。如果您有 GitHub 账户，您也可以使用它登录。
- en: Once you have an account, we will need to create a repository named `springbootcookbook`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您拥有账户，我们需要创建一个名为 `springbootcookbook` 的仓库。
- en: 'With this account created, now is the time to build the image. For this, we
    will use one of the Gradle Docker plugins. We will start by changing `build.gradle`
    to modify the `buildscript` block with the following change:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了账户后，现在是构建镜像的时候了。为此，我们将使用 Gradle Docker 插件之一。我们将首先更改 `build.gradle` 以修改 `buildscript`
    块，进行以下更改：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will also need to apply this plugin by adding the `apply plugin: ''docker''`
    directive to the `build.gradle` file.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们还需要通过在 `build.gradle` 文件中添加 `apply plugin: ''docker''` 指令来应用此插件。'
- en: We also need to explicitly add the `application` plugin to `build.gradle` as
    well, since it is no longer automatically included by the Spring Boot Gradle plugin.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要明确地将 `application` 插件添加到 `build.gradle` 中，因为它不再由 Spring Boot Gradle 插件自动包含。
- en: 'Add `apply plugin: ''application''` to the list of plugins in the `build.gradle`
    file.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将 `apply plugin: ''application''` 添加到 `build.gradle` 文件中的插件列表中。'
- en: 'Lastly, we will need to add the following Docker configuration to the `build.gradle`
    file as well:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要将以下 Docker 配置添加到 `build.gradle` 文件中：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assuming that you already have Docker installed on your machine, we can proceed
    to creating the image by executing `./gradlew clean distDocker`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您已经在您的机器上安装了 Docker，我们可以通过执行 `./gradlew clean distDocker` 来创建镜像。
- en: 'For Docker installation instructions, please visit the tutorial that is located
    at [https://docs.docker.com/installation/#installation](https://docs.docker.com/installation/#installation).
    If everything has worked out correctly, you should see the following output:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于 Docker 安装说明，请访问位于 [https://docs.docker.com/installation/#installation](https://docs.docker.com/installation/#installation)
    的教程。如果一切顺利，您应该会看到以下输出：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also execute the following Docker images command so as to see the newly
    created image:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以执行以下 Docker 镜像命令，以便查看新创建的镜像：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the image built successfully, we are now ready to start it in Docker by
    executing the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功构建了镜像后，我们现在可以通过执行以下命令在 Docker 中启动它：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the container has started, we can query the Docker registry for the port
    bindings so that we can access the HTTP endpoints for our service. This can be
    done via the `docker ps` command. If the container is running successfully, we
    should see the following result (names and ports will vary):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器启动后，我们可以通过 `docker ps` 命令查询 Docker 仓库的端口绑定，以便我们可以访问我们服务的 HTTP 端点。这可以通过 `docker
    ps` 命令完成。如果容器运行成功，我们应该看到以下结果（名称和端口可能会有所不同）：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From this output, we can tell that the port mapping for the internal port `8080`
    has been set up to be `32778` (your port will vary for every run). Let''s open
    `http://localhost:32778/books` in the browser to see our application in action,
    as shown in the following screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以看出内部端口 `8080` 的端口映射已经设置为 `32778`（您的端口在每次运行时可能会有所不同）。让我们在浏览器中打开 `http://localhost:32778/books`，以查看我们的应用程序的实际运行情况，如下面的截图所示：
- en: '![](img/425c27f4-c4c1-4e8e-876e-c45ddf26145f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/425c27f4-c4c1-4e8e-876e-c45ddf26145f.png)'
- en: If you are using macOS X with `boot2docker`, then you won't be running the Docker
    container locally. In this scenario, you will be using the `boot2docker ip` instead
    of the local host to connect to the application. For more tips on how to make
    the `boot2docker` integration easier, please visit [http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide](http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide).
    One can also use a nice Docker façade, generously created by Ian Sinnott, which
    will automatically start boot2docker and handle the environment variables as well.
    To get the wrapper, go to [https://gist.github.com/iansinnott/0a0c212260386bdbfafb](https://gist.github.com/iansinnott/0a0c212260386bdbfafb).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 macOS X 和 `boot2docker`，那么您将不会在本地运行 Docker 容器。在这种情况下，您将使用 `boot2docker
    ip` 而不是本地主机来连接到应用程序。有关如何使 `boot2docker` 集成更简单的更多提示，请访问 [http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide](http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide)。还可以使用由
    Ian Sinnott 慷慨提供的漂亮的 Docker 外壳，它将自动启动 boot2docker 并处理环境变量。要获取包装器，请访问 [https://gist.github.com/iansinnott/0a0c212260386bdbfafb](https://gist.github.com/iansinnott/0a0c212260386bdbfafb)。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding example, we saw how easy it is to have our `build` package
    the application in a Docker container. The additional Gradle-Docker plugin does
    the bulk of the work of the `Dockerfile` creation, image building, and publishing;
    all we have to do is give it some instructions on what and how we want the image
    to be. Because the Spring Boot Gradle plugin uses a `boot` distribution, the Gradle-Docker
    plugin does not know that it needs to use a bootified TAR archive. To help with
    that, we override the `distDocker` task. Let''s examine these instructions in
    detail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何轻松地将我们的 `build` 包在 Docker 容器中。Gradle-Docker 插件负责创建 `Dockerfile`、构建镜像和发布的大部分工作；我们只需要给它一些指令，说明我们希望镜像如何构建。因为
    Spring Boot Gradle 插件使用 `boot` 分发，所以 Gradle-Docker 插件不知道它需要使用一个 bootified TAR
    归档。为了帮助解决这个问题，我们覆盖了 `distDocker` 任务。让我们详细检查这些指令：
- en: The `group` and `description` attributes merely help with displaying the task
    properly when the `./gradlew tasks` command is executed.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group` 和 `description` 属性仅有助于在执行 `./gradlew tasks` 命令时正确显示任务。'
- en: The `inputs.files project.bootDistTar` directive is very important. This is
    what instructs the `distDocker` task to use the TAR archive created by the Spring
    Boot distribution, instead of the generic one.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inputs.files project.bootDistTar` 指令非常重要。这是指导 `distDocker` 任务使用 Spring Boot
    分发创建的 TAR 归档，而不是通用的归档。'
- en: The `def installDir = "/" + project.bootDistTar.archiveName - ".${project.bootDistTar.extension}"`
    directive is creating a variable, containing the directory where the untarred
    artifacts will be placed inside the Docker container.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def installDir = "/" + project.bootDistTar.archiveName - ".${project.bootDistTar.extension}"`
    指令正在创建一个变量，包含解压缩的工件将被放置在 Docker 容器内的目录。'
- en: The `exposePort` directive tells the plugin to add an `EXPOSE <port>` instruction
    to the Dockerfile so that when our container is started, it will expose these
    internal ports to the outside via port mapping. We saw this mapping while running
    the `docker ps` command.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exposePort` 指令告诉插件向 Dockerfile 添加一个 `EXPOSE <port>` 指令，这样当我们的容器启动时，它将通过端口映射将这些内部端口暴露给外部。我们在运行
    `docker ps` 命令时看到了这种映射。'
- en: The `addFile` directive tells the plugin to add an `ADD <src> <dest>` instruction
    to the Dockerfile so that when the container is being built, we will copy the
    file from the source filesystem in the filesystem in the container image. In our
    case, we will need to copy the `.keystore` certificate file that we configured
    in one of our previous recipes for the HTTPS connector, which we instructed in
    `tomcat.https.properties` to be loaded from `${user.home}/.keystore`. Now, we
    need it to be in the `/root/ directory` directory as, in the container, our application
    will be executed under the root. (This can be changed with more configurations.)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addFile` 指令告诉插件向 Dockerfile 添加一个 `ADD <src> <dest>` 指令，这样在构建容器时，我们将从容器镜像中的文件系统复制源文件系统中的文件。在我们的例子中，我们需要复制
    `.keystore` 证书文件，这是我们之前在配置 HTTPS 连接器时设置的，我们在 `tomcat.https.properties` 中指示它从 `${user.home}/.keystore`
    加载。现在，我们需要它在 `/root/` 目录中，因为在容器中，我们的应用程序将在 root 用户下执行。（这可以通过更多的配置来更改。）'
- en: The Gradle-Docker plugin uses the project name as a name for the image by default.
    The project name, in turn, is being inferred by Gradle from the project's directory
    name, unless an explicit property value is configured. As the code example is
    for [Chapter 6](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml), *Application Packaging
    and Deployment* the project directory is named `ch6`, thus the name of the image.
    The project name can be explicitly configured by adding `name='some_project_name'`
    in `gradle.properties`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle-Docker 插件默认使用项目名称作为镜像名称。项目名称反过来由 Gradle 从项目的目录名称推断，除非配置了显式的属性值。由于代码示例是关于
    [第 6 章](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml)，“应用程序打包和部署”，项目目录被命名为 `ch6`，因此镜像名称。项目名称可以通过在
    `gradle.properties` 中添加 `name='some_project_name'` 来显式配置。
- en: 'If you look at the resulting Dockerfile, which can be found in the `build/docker/`
    directory at the root of the project, you will see the following two instructions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看生成的 Dockerfile，它可以在项目的根目录下的 `build/docker/` 目录中找到，你会看到以下两个指令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ADD` instruction adds the TAR application archive that was produced by
    the `bootDistTar` task and contains our application bundled up as a tarball. We
    can even see the contents of the produced tarball by executing `tar tvf build/distributions/ch6-boot-0.0.1-SNAPSHOT.tar`.
    During the building of the container, the contents of the TAR file will be extracted
    in the `/` directory in the container and later used to launch the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` 指令添加了由 `bootDistTar` 任务生成的 TAR 应用程序存档，其中包含我们的应用程序作为 tarball 打包。我们甚至可以通过执行
    `tar tvf build/distributions/ch6-boot-0.0.1-SNAPSHOT.tar` 来查看生成的 tarball 的内容。在构建容器的过程中，TAR
    文件的内容将被提取到容器中的 `/` 目录，并随后用于启动应用程序。'
- en: It is followed by the `ENTRYPOINT` instruction. This tells Docker to execute
    `/ch6-boot-0.0.1-SNAPSHOT/bin/ch6`, which we saw as part of the tarball content,
    once the container is started, thus automatically launching our application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是 `ENTRYPOINT` 指令。这告诉 Docker 在容器启动后执行 `/ch6-boot-0.0.1-SNAPSHOT/bin/ch6`，这是我们作为
    tarball 内容的一部分看到的，从而自动启动我们的应用程序。
- en: The first line in the Dockerfile, which is `FROM aglover/java8-pier`, is the
    instruction to use the `aglover/java8-pier` image, which contains the Ubuntu OS
    with Java 8 installed as a base image for our container, on which we will install
    our application. This image comes from the Docker Hub Repository and is automatically
    used by the plugin, but can be changed via the configuration settings, if so desired.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 的第一行，即 `FROM aglover/java8-pier`，是使用 `aglover/java8-pier` 镜像的指令，该镜像包含安装了
    Java 8 的 Ubuntu OS，作为我们容器的基镜像，我们将在此镜像上安装我们的应用程序。这个镜像来自 Docker Hub 仓库，并且插件会自动使用它，但可以通过配置设置来更改，如果需要的话。
- en: 'If you created an account on Docker Hub, we can also publish the created Docker
    image to the registry. As fair warning, the resulting image could be many hundreds
    of megabytes in size so uploading it could take some time. To publish this image,
    we will need to change the tag to `tag "<docker hub username>/<docker hub repository
    name>"` and add the `push true` setting to the `distDocker` task definition in
    `build.gradle`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已在 Docker Hub 上创建了账户，我们还可以将创建的 Docker 镜像发布到注册库。作为公平警告，生成的镜像大小可能达到数百兆字节，因此上传可能需要一些时间。要发布此镜像，我们需要将标签更改为
    `tag "<docker hub username>/<docker hub repository name>"` 并在 `build.gradle` 中的
    `distDocker` 任务定义中添加 `push true` 设置：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `tag` property sets up the created image tag and, by default, the plugin
    assumes that it is residing in the Docker Hub Repository. This is where it will
    be publishing it if the `push` configuration is set to `true`, as it is in our
    case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag` 属性设置创建的镜像标签，默认情况下，插件假定它位于 Docker Hub 仓库中。如果 `push` 配置设置为 `true`（正如我们的情况一样），它将在这里发布。'
- en: For a complete list of all the Gradle-Docker plugin configuration options, take
    a look at the [https://github.com/Transmode/gradle-docker](https://github.com/Transmode/gradle-docker)
    GitHub project page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有 Gradle-Docker 插件配置选项的完整列表，请查看 [https://github.com/Transmode/gradle-docker](https://github.com/Transmode/gradle-docker)
    GitHub 项目页面。
- en: 'When launching a Docker image, we use the `-d` and `-P` command-line arguments.
    Their uses are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 Docker 镜像时，我们使用 `-d` 和 `-P` 命令行参数。它们的使用如下：
- en: '`-d`: This argument indicates the desire to run the container in a detached
    mode where the process starts in the background'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：此参数表示希望以分离模式运行容器，其中进程在后台启动'
- en: '`-P`: This argument instructs Docker to publish all the internally exposed
    ports to the outside so that we can access them'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P`：此参数指示 Docker 将所有内部公开的端口发布到外部，以便我们可以访问它们'
- en: For a detailed explanation of all the possible command-line options, refer to
    [https://docs.docker.com/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解所有可能的命令行选项，请参阅 [https://docs.docker.com/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)。
- en: Building self-executing binaries
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自执行二进制文件
- en: As of Spring Boot version 1.3, the Gradle and Maven plugins support the option
    of generating true executable binaries. These look like normal JAR files, but
    have the content of JAR fused together with the launch script that contains the
    command-building logic and is capable of self-starting itself without the need
    to execute the `java -jar file.jar` command explicitly. This capability comes
    in very handy as it allows for the easy configuration of Linux autostart services
    such as `init.d` or `systemd`, and `launchd` on macOS X.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Spring Boot 版本 1.3 以来，Gradle 和 Maven 插件支持生成真正的可执行二进制文件的功能。这些看起来像普通的 JAR 文件，但它们的
    JAR 内容与包含命令构建逻辑的启动脚本融合在一起，能够无需显式执行 `java -jar file.jar` 命令即可自我启动。这种功能非常有用，因为它允许轻松配置
    Linux 自动启动服务，如 `init.d` 或 `systemd`，以及 macOS X 上的 `launchd`。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use our existing application build. We will examine
    how the self-starting executable JAR files get created and how to modify the default
    launch script to add support for the custom JVM start up arguments, such as the
    `-D` start up system properties, JVM memory, Garbage Collection, and other settings.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用现有的应用程序构建。我们将检查自启动的可执行 JAR 文件是如何创建的，以及如何修改默认的启动脚本以添加对自定义 JVM 启动参数的支持，例如
    `-D` 启动系统属性、JVM 内存、垃圾回收和其他设置。
- en: 'For this recipe, make sure that `build.gradle` is using Spring Boot version
    2.0.0 or above. If it is not, then change the following setting in the `buildscript`
    configuration block:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，请确保 `build.gradle` 正在使用 Spring Boot 版本 2.0.0 或更高版本。如果不是，请在 `buildscript`
    配置块中更改以下设置：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The same upgrade of the Spring Boot version should be done in the `db-counter-starter/build.gradle`
    file as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应在 `db-counter-starter/build.gradle` 文件中执行相同的 Spring Boot 版本升级。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Building a default self-executing JAR file is very easy; actually, it is done
    automatically once we execute the `./gradlew clean bootJar` command.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建默认的自执行 JAR 文件非常简单；实际上，一旦我们执行 `./gradlew clean bootJar` 命令，它就会自动完成。
- en: We can proceed to launch the created application simply by invoking `./build/libs/bookpub-0.0.1-SNAPSHOT.jar`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过简单地调用 `./build/libs/bookpub-0.0.1-SNAPSHOT.jar` 来启动创建的应用程序。
- en: In an enterprise environment, it is rare that we are satisfied with the default
    JVM launch arguments as we often need to tweak the memory settings, GC configurations,
    and even pass the startup system properties in order to ensure that we are using
    the desired version of the XML parser or a proprietary implementation of class
    loader or security manager. To accomplish those needs, we will modify the default
    `launch.script` file to add support for the JVM options. Let's start by copying
    the default `launch.script` file from the [https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script)
    Spring Boot GitHub repository in the root of our project.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在企业环境中，我们很少对默认的 JVM 启动参数感到满意，因为我们经常需要调整内存设置、GC 配置，甚至传递启动系统属性，以确保我们使用的是所需的 XML
    解析器版本或类加载器或安全管理器的专有实现。为了满足这些需求，我们将修改默认的 `launch.script` 文件以添加对 JVM 选项的支持。让我们首先从项目的根目录中复制默认的
    `launch.script` 文件到 [https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script)
    Spring Boot GitHub 仓库。
- en: The `launch.script` file is supported only on Linux and OS X environments. If
    you are looking to make self-executing JARs for Windows, you will need to provide
    your own `launch.script` file that is tailored for the Windows shell command execution.
    The good news is that it is the only special thing that is required; all the instructions
    and concepts in this recipe will work just fine on Windows as well, provided that
    the compliant `launch.script` template is being used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch.script` 文件仅在 Linux 和 OS X 环境中得到支持。如果您想为 Windows 创建可执行的 JAR 文件，您需要提供自己的
    `launch.script` 文件，该文件针对 Windows 壳命令执行进行了定制。好消息是，这仅是所需的一项特殊事项；本食谱中的所有说明和概念在 Windows
    上也能正常工作，前提是使用符合规范的 `launch.script` 模板。'
- en: 'We will modify the copied `launch.script` file and add the following content
    right above the *line 142* mark (this is showing only the relevant part of the
    script so as to condense the space):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改复制的 `launch.script` 文件，并在 *第 142 行* 标记上方添加以下内容（这里只显示脚本的相关部分，以便压缩空间）：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the custom `launch.script` file in place, we will need to add the options
    setting to our `build.gradle` file with the following content:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置了自定义的 `launch.script` 文件后，我们需要在我们的 `build.gradle` 文件中添加选项设置，内容如下：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are now ready to launch our application. First, let's use the `./gradlew
    clean bootRun` command, and if we look at the JConsole VM Summary tab, we will
    see that our arguments indeed have been passed to the JVM, as follows:![](img/dd0b250c-6176-4663-9d7f-d74644feb2fe.png)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好启动我们的应用程序。首先，让我们使用 `./gradlew clean bootRun` 命令，然后查看 JConsole 的 VM
    概述选项卡，我们会看到我们的参数确实已经传递给了 JVM，如下所示：![](img/dd0b250c-6176-4663-9d7f-d74644feb2fe.png)
- en: We can also build the self-starting executable JAR by running the `./gradlew
    clean bootJar` command and then executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`
    in order to launch our application. We should expect to see a similar result in
    JConsole.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过运行 `./gradlew clean bootJar` 命令来构建自启动的可执行 JAR 文件，然后执行 `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`
    以启动我们的应用程序。我们应该在 JConsole 中看到类似的结果。
- en: 'Alternatively, we can also use the `JAVA_OPTS` environment variable to override
    some of the JVM arguments. Say we want to change the minimum memory heap size
    to 128 megabytes. We can launch our application using the `JAVA_OPTS=-Xmx128m
    ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar` command and this would show us the
    following effect in JConsole:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用 `JAVA_OPTS` 环境变量来覆盖一些 JVM 参数。比如说，我们想将最小堆内存大小更改为 128 兆字节。我们可以使用 `JAVA_OPTS=-Xmx128m
    ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar` 命令来启动我们的应用程序，并在 JConsole 中看到以下效果：
- en: '![](img/20ed07bc-00c6-490b-89c5-9d1e20772536.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20ed07bc-00c6-490b-89c5-9d1e20772536.png)'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With a small customization to `launch.script`, we were able to create a self-executing
    deployable application, packaged as a self-contained JAR file, which on top of
    everything else can also be configured in order to be launched using the various
    OS-specific autostarting frameworks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 `launch.script` 的小幅定制，我们能够创建一个自执行的部署应用程序，打包为一个自包含的 JAR 文件，除了其他一切之外，还可以配置为使用各种操作系统特定的自动启动框架启动。
- en: The Spring Boot Gradle and Maven plugins provide us with lots of options for
    parameter customization and even an ability to embed mustache-like template placeholders
    in `launch.script`, which can later be replaced with values during build time.
    We have leveraged this capability to inject our JVM arguments into the file using
    the `launchScript{properties}` configuration setting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Gradle 和 Maven 插件为我们提供了大量的参数自定义选项，甚至可以在 `launch.script` 中嵌入类似 mustache
    的模板占位符，这些占位符可以在构建时替换为值。我们已经利用了这一功能，通过 `launchScript{properties}` 配置设置将我们的 JVM
    参数注入到文件中。
- en: 'In our custom version of `launch.script`, we added the `jvmopts="{{jvm_options:}}"`
    line, which will be replaced with the value of the `jvm_options` parameter during
    the build and packaging time. This parameter is declared in our `build.gradle`
    file as a value of the `launchScript.properties` argument `: launchScript{properties
    ''jvm_options'' : applicationDefaultJvmArgs.join('' '')}`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们自定义的 `launch.script` 版本中，我们添加了 `jvmopts="{{jvm_options:}}"` 行，该行将在构建和打包时替换为
    `jvm_options` 参数的值。此参数在我们的 `build.gradle` 文件中声明为 `launchScript.properties` 参数
    `: launchScript{properties ''jvm_options'' : applicationDefaultJvmArgs.join(''
    '')}` 的值。'
- en: The JVM arguments can be hardcoded, but it is much better to maintain consistency
    between how our application starts using the `bootRun` task and how it starts
    when launched from the self-executing JAR. To achieve this, we will use the same
    `applicationDefaultJvmArgs` collection of arguments that we will define for the
    `bootRun` execution purpose, only with all the different arguments collapsed in
    a single line of text separated by white spaces. Using this approach, we have
    to define the JVM arguments only once and use them in both modes of execution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 参数可以硬编码，但保持我们的应用程序使用 `bootRun` 任务启动的方式和从自执行 JAR 启动时启动的方式之间的一致性要好得多。为了实现这一点，我们将使用为
    `bootRun` 执行目的定义的相同的 `applicationDefaultJvmArgs` 参数集合，只是将所有不同的参数折叠成一行文本，由空格分隔。使用这种方法，我们只需要定义一次
    JVM 参数，并在两种执行模式中使用它们。
- en: It is important to notice that this reuse also applies to the application distributions
    that are built using the `distZip` and `distTar` tasks defined by Gradle's `application`
    plugin, as well as Spring Boot Gradle's `bootDistZip` and `bootDistTar`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这种重用也适用于使用 Gradle 的 `application` 插件以及 Spring Boot Gradle 的 `bootDistZip`
    和 `bootDistTar` 定义的 `distZip` 和 `distTar` 任务构建的应用程序分发。
- en: 'We can modify the build to create the Docker image by launching our self-executing
    JAR instead of the contents of the TAR file produced by the `distTar` task by
    default. To do this, we will need to change our `distDocker` configuration block
    using the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动我们的自执行 JAR 文件而不是默认情况下由 `distTar` 任务生成的 TAR 文件内容来修改构建以创建 Docker 镜像。为此，我们需要使用以下代码更改我们的
    `distDocker` 配置块：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will make our `distDocker` task put the executable jar inside a Docker
    image instead of a TAR archive.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的 `distDocker` 任务将可执行 JAR 文件放入 Docker 镜像中，而不是 TAR 存档。
- en: Spring Boot environment configuration, hierarchy, and precedence
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 环境配置、层次结构和优先级
- en: In the previous few recipes, we looked at how to package our application in
    a variety of ways and how it can be deployed. The next logical step is the need
    to configure the application in order to provide some behavioral control as well
    as some environment-specific configuration values, which could and most likely
    will vary from environment to environment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的几个配方中，我们探讨了如何以各种方式打包我们的应用程序以及如何部署它。下一步合乎逻辑的步骤是需要配置应用程序，以便提供一些行为控制以及一些特定环境的配置值，这些值可能会并且很可能会根据环境的不同而不同。
- en: A common example of such an environmental configuration difference is the database
    setup. We certainly don't want to connect to a production environment database
    with an application running on our development machine. There are also cases where
    we want an application to run in different modes or use a different set of profiles,
    as they are referred to by Spring. An example could be running an application
    in live or simulator mode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种环境配置差异的常见例子是数据库设置。我们当然不希望在我们的开发机器上运行的应用程序连接到生产环境数据库。也存在我们希望应用程序以不同的模式运行或使用不同的配置文件集的情况，正如Spring所称呼的那样。一个例子可能是以实时或模拟模式运行应用程序。
- en: For this recipe, we will pick up from the previous state of the code base and
    add the support for different configuration profiles as well as examine how to
    use the property values as placeholders in other properties.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将从代码库的先前状态开始，添加对不同配置配置文件的支持，并检查如何将属性值用作其他属性中的占位符。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will start by adding an `@Profile` annotation to the `@Bean` creation of
    `schedulerRunner` by changing the definition of the `schedulerRunner(...)` method
    in `BookPubApplication.java`, located in the `src/main/java/org/test/bookpub`
    directory at the root of our project, to the following content:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过更改位于项目根目录`src/main/java/org/test/bookpub`目录中的`BookPubApplication.java`文件中`schedulerRunner(...)`方法的定义，向`schedulerRunner`的`@Bean`创建中添加一个`@Profile`注解，内容如下：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`来启动应用程序。
- en: 'Once the application is running, we should no longer see the previous log output
    from the `StartupRunner` class, which looked like this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序启动，我们就不再应该看到来自`StartupRunner`类的先前日志输出，它看起来像这样：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's build the application by running `./gradlew clean bootJar` and start
    it by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`;
    we will see the log output line show up again.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行`./gradlew clean bootJar`来构建应用程序，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger`来启动它；我们将再次看到日志输出行出现。
- en: 'Another functionality that is enabled by the profile selector is the ability
    to add profile-specific property files. Let''s create an `application-inmemorydb.properties`
    file in the `src/main/resources` directory at the root of our project with the
    following content:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由配置选择器启用的另一个功能是能够添加特定配置文件的属性文件。让我们在项目根目录`src/main/resources`目录下创建一个名为`application-inmemorydb.properties`的文件，内容如下：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's build the application by running `./gradlew clean bootJar` and start it
    by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger,inmemorydb`,
    which will use the `inmemorydb` profile configuration in order to use the in-memory
    database instead of the file-based one.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行`./gradlew clean bootJar`来构建应用程序，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger,inmemorydb`来启动它，这将使用`inmemorydb`配置文件配置来使用内存数据库而不是基于文件的数据库。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we experimented with using profiles and applying additional
    configuration settings based on the active profiles. Profiles were first introduced
    in Spring Framework 3.2 and were used to conditionally configure the beans in
    context, depending on which profiles were active. In Spring Boot, this facility
    was extended even further to allow configuration separation as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们尝试了使用配置文件并根据活动配置文件应用额外的配置设置。配置文件首次在Spring Framework 3.2中引入，用于根据活动配置文件有条件地配置上下文中的bean。在Spring
    Boot中，这个功能得到了进一步的扩展，允许配置分离。
- en: By placing an `@Profile("logger")` annotation on our `StartupRunner@Bean` creation
    method, Spring will be instructed to create the bean only if the logger profile
    has been activated. Conventionally, this is done by passing the `--spring.profiles.active`
    option in the command line during the application startup. In the tests, another
    way that this can be done is using the `@ActiveProfiles("profile")` annotation
    on the `Test` class, but it is not supported for the execution of a normal application.
    It is also possible to negate profiles such as `@Profile("!production")`. When
    such an annotation is used (with `!` marking the negation), the bean will be created
    only if no profile production is active.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的 `StartupRunner@Bean` 创建方法上放置一个 `@Profile("logger")` 注解，Spring 将被指示仅在日志记录器配置文件被激活时创建该
    Bean。通常，这是通过在应用程序启动期间通过命令行传递 `--spring.profiles.active` 选项来完成的。在测试中，另一种实现方式是在
    `Test` 类上使用 `@ActiveProfiles("profile")` 注解，但这不支持正常应用程序的执行。也可以否定配置文件，例如 `@Profile("!production")`。当使用此类注解（`!`
    标记否定）时，只有在没有活动生产配置文件的情况下才会创建 Bean。
- en: 'During startup, Spring Boot treats all the options that get passed via the
    command line as application properties, and thus anything that gets passed during
    startup ends up as a property value that is capable of being used. This same mechanism
    not only works for new properties but can be used as a way of overriding the existing
    properties as well. Let''s imagine a situation where we already have an active
    profile defined in our `application.properties` file that looks like this: `spring.profiles.active=basic`.
    By passing the `--spring.profiles.active=logger` option via the command line,
    we will replace the active profile from `basic` to `logger`. If we want to include
    some profiles regardless of the active configuration, Spring Boot gives us a `spring.profiles.include`
    option to configure. Any profiles that are set up this way will be added to the
    list of active profiles.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，Spring Boot 将通过命令行传递的所有选项视为应用程序属性，因此启动过程中传递的任何内容最终都会成为可以使用的属性值。这种相同的机制不仅适用于新属性，还可以用作覆盖现有属性的方法。让我们设想一个场景，即我们已经在
    `application.properties` 文件中定义了一个活动配置文件，如下所示：`spring.profiles.active=basic`。通过命令行传递
    `--spring.profiles.active=logger` 选项，我们将替换活动配置文件从 `basic` 更改为 `logger`。如果我们想包含一些配置文件而不管活动配置如何，Spring
    Boot 提供了一个 `spring.profiles.include` 选项来配置。以这种方式设置的任何配置文件都将被添加到活动配置文件列表中。
- en: 'As these options are nothing more than regular Spring Boot application properties,
    they all follow the same hierarchy for override precedence. The options have been
    outlined as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些选项不过是常规的 Spring Boot 应用程序属性，它们都遵循相同的覆盖优先级层次结构。选项概述如下：
- en: '**Command-line arguments**: These values supersede every other property source
    in the list, and you can always rest assured that anything passed via `--property.name=value`
    will take precedence over the other means.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行参数**：这些值覆盖列表中的所有其他属性源，你可以始终确信通过 `--property.name=value` 传递的内容将优先于其他方式。'
- en: '**JNDI attributes**: They are the next in precedence priority. If you are using
    an application container that provides data via a JNDI `java:comp/env` namespace,
    these values will override all the other settings from below.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JNDI 属性**：它们在优先级顺序中排在下一级。如果你使用的是提供数据的应用程序容器，并且通过 JNDI `java:comp/env` 命名空间提供数据，这些值将覆盖下面所有其他设置。'
- en: '**Java system properties**: These values are another way to pass the properties
    to the application either via the `-Dproperty=name` command-line arguments or
    by calling `System.setProperty(...)` in the code. They provide another way to
    replace the existing properties. Anything coming from `System.getProperty(...)`
    will win over the others in the list.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 系统属性**：这些值是另一种将属性传递给应用程序的方式，无论是通过 `-Dproperty=name` 命令行参数还是通过在代码中调用
    `System.setProperty(...)`。它们提供了另一种替换现有属性的方法。来自 `System.getProperty(...)` 的任何内容都将覆盖列表中的其他内容。'
- en: '**OS environment variables**: Whether from Windows, Linux, OS X, or any other,
    they are a common way to specify a configuration, especially for locations and
    values. The most notable one is `JAVA_HOME`, which is a common way to indicate
    where the JVM location resides in the filesystem. If neither of the preceding
    settings are present, the `ENV` variables will be used for the property values
    instead of the ones mentioned as follows:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统环境变量**：无论是来自Windows、Linux、OS X还是任何其他操作系统，它们都是指定配置的常见方式，特别是对于位置和值。最著名的一个是`JAVA_HOME`，它通常用来指示JVM在文件系统中的位置。如果前面的设置都不存在，将使用`ENV`变量而不是以下提到的变量来为属性值：'
- en: As the OS environment variables typically don't support dots (`.`) or dashes
    (`-`), Spring Boot provides an automatic remapping mechanism that replaces the
    underscores (`_`) with dots (`.`) during the property evaluation; it also handles
    the case conversion. Thus, `JAVA_HOME` becomes synonymous with `java.home`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统环境变量通常不支持点（`.`）或破折号（`-`），Spring Boot提供了一个自动重映射机制，在属性评估期间将下划线（`_`）替换为点（`.`）；它还处理大小写转换。因此，`JAVA_HOME`与`java.home`同义。
- en: '`random.*`: This provides special support for the random values of primitive
    types that can be used as placeholders in configuration properties. For example,
    we can define a property named `some.number=${random.int}` where `${random.int}`
    will be replaced by some random integer value. The same goes for `${random.value}`
    for textual values and `${random.long}` for longs.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random.*`：这为原始类型的随机值提供了特殊支持，可以用作配置属性中的占位符。例如，我们可以定义一个名为`some.number=${random.int}`的属性，其中`${random.int}`将被某个随机整数值替换。对于文本值，同样适用于`${random.value}`，对于长整型则适用于`${random.long}`。'
- en: '`application-{profile}.properties`: They are the profile-specific files that
    get applied only if a corresponding profile gets activated.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-{profile}.properties`：它们是特定配置文件的文件，只有当相应的配置文件被激活时才会应用。'
- en: '`application.properties`: They are the main property files that contain the
    base/default application configuration. Similar to the profile-specific ones,
    these values can be loaded from the following list of locations, with the top
    one taking priority over the lower entries:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.properties`：它们是主要属性文件，包含基本/默认应用程序配置。与特定配置文件类似，这些值可以从以下位置加载，其中最高优先级高于较低条目：'
- en: '`file:config/`: This is a `/config` directory located in the current directory:'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file:config/`：这是位于当前目录中的`/config`目录：'
- en: '`file:`: This is the current directory'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file:`：这是当前目录'
- en: '`classpath:/config`: This is a `/config` package in the classpath'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classpath:/config`：这是类路径中的一个`/config`包'
- en: '`classpath:`: This is a root of the classpath'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classpath:`：这是类路径的根'
- en: '**@Configuration annotated classes annotated with @PropertySource**: These
    are any in-code property sources that have been configured using annotations.
    We have seen an example of such usage the *Adding custom connectors* recipe from
    [Chapter 3](f10744d1-32d1-4047-a3a6-df7e9a3ede92.xhtml), *Web Framework Behavior
    Tuning*. They are very low in the precedence chain and are only preceded by the
    default properties.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用@PropertySource注解的@Configuration类**：这些是在代码中使用注解配置的任何内联属性源。我们在[第3章](f10744d1-32d1-4047-a3a6-df7e9a3ede92.xhtml)的“添加自定义连接器”配方中看到了这样的用法，*Web框架行为调整*。它们在优先级链中非常低，并且只由默认属性
    precede。'
- en: '**Default properties**: They are configured via the `SpringApplication.setDefaultProperties(...)`
    call and are seldom used, as it feels very much like hardcoding values in code
    instead of externalizing them in configuration files.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认属性**：它们通过调用`SpringApplication.setDefaultProperties(...)`进行配置，很少使用，因为它感觉非常像在代码中硬编码值而不是在外部配置文件中外部化它们。'
- en: Adding a custom PropertySource to the environment using EnvironmentPostProcessor
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EnvironmentPostProcessor向环境添加自定义PropertySource
- en: In cases where the enterprise is already using a particular configuration system,
    custom written or off the shelf, Spring Boot provides us with a facility to integrate
    this into the application via the creation of a custom `PropertySource` implementation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业已经使用特定配置系统的情况下，无论是自定义编写还是现成的，Spring Boot为我们提供了一个通过创建自定义`PropertySource`实现来将此集成到应用程序中的功能。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s imagine that we have an existing configuration setup that uses a popular
    Apache Commons Configuration framework and stores the configuration data in XML
    files:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个现有的配置设置，它使用流行的Apache Commons Configuration框架，并将配置数据存储在XML文件中：
- en: 'To mimic our supposed pre-existing configuration system, add the following
    content to the dependencies section in the `build.gradle` file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟我们假设的现有配置系统，将以下内容添加到`build.gradle`文件的依赖部分：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Follow this up by creating a simple configuration file named `commons-config.xml`
    in the `src/main/resources` directory at the root of our project with the following
    content:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在项目根目录下的`src/main/resources`目录中创建一个简单的配置文件`commons-config.xml`，内容如下：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will create the `PropertySource` implementation file named `ApacheCommonsConfigurationPropertySource.java`
    in the `src/main/java/org/test/bookpub` directory at the root of our project with
    the following content:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在项目根目录下的`src/main/java/org/test/bookpub`目录中创建一个名为`ApacheCommonsConfigurationPropertySource.java`的`PropertySource`实现文件，内容如下：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will now create the `EnvironmentPostProcessor` implementation class so as
    to bootstrap our `PropertySource` named `ApacheCommonsConfigurationEnvironmentPostProcessor.java`
    in the `src/main/java/org/test/bookpub` directory at the root of our project with
    the following content:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建`EnvironmentPostProcessor`实现类，以便在项目根目录下的`src/main/java/org/test/bookpub`目录中启动我们的名为`ApacheCommonsConfigurationEnvironmentPostProcessor.java`的`PropertySource`，内容如下：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we will need to create a new directory named `META-INF` in the `src/main/resources`
    directory at the root of our project and create a file named `spring.factories`
    in it with the following content:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在项目根目录下的`src/main/resources`目录中创建一个名为`META-INF`的新目录，并在其中创建一个名为`spring.factories`的文件，内容如下：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the setup done, we are now ready to use our new properties in our application.
    Let''s change the configuration of the `@Scheduled` annotation for our `StartupRunner`
    class located in the `src/main/java/org/test/bookpub` directory at the root of
    our project, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置完成后，我们现在可以开始在应用中使用我们的新属性了。让我们更改位于项目根目录下的`src/main/java/org/test/bookpub`目录中的`StartupRunner`类的`@Scheduled`注解的配置，如下所示：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's build the application by running `./gradlew clean bootJar` and start it
    by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`
    in order to ensure that our `StartupRunner` class is still logging the book count
    every ten seconds, as expected.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootJar`来构建应用，并通过`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger`来启动它，以确保我们的`StartupRunner`类仍然每十秒记录一次书籍数量，正如预期的那样。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have explored how to add our own custom `PropertySource`
    that allowed us to bridge the existing system in the Spring Boot environment.
    Let's look into the inner workings of how the pieces fit together.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨了如何添加我们自己的自定义`PropertySource`，这使我们能够连接Spring Boot环境中的现有系统。让我们看看这些组件是如何协同工作的内部机制。
- en: In the previous section, we learned how the different configuration definitions
    stacked up and what rules were used to overlay them on top of each other. This
    will help us to better understand how the bridging of an Apache Commons Configuration,
    using a custom `PropertySource` implementation, works. (This should not be confused
    with an `@PropertySource` annotation!)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了不同的配置定义是如何堆叠的，以及用于将它们叠加在一起的规则。这将帮助我们更好地理解使用自定义`PropertySource`实现桥接Apache
    Commons Configuration的工作原理。（这不应与`@PropertySource`注解混淆！）
- en: In [Chapter 4](6139967b-794e-479a-8461-d3197eb0322e.xhtml), *Writing Custom
    Spring Boot Starters*, we learned about the use of `spring.factories`, and so
    we already know that this file serves to define the classes that should automatically
    be incorporated by Spring Boot during application startup. The only difference
    this time is that instead of configuring the `EnableAutoConfiguration` settings,
    we will configure the `SpringApplicationRunListener` ones.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](6139967b-794e-479a-8461-d3197eb0322e.xhtml)《编写自定义Spring Boot启动器》中，我们学习了`spring.factories`的使用，因此我们已经知道这个文件的作用是在应用启动时自动包含应该被Spring
    Boot集成的类。这次的不同之处在于，我们不是配置`EnableAutoConfiguration`设置，而是配置`SpringApplicationRunListener`设置。
- en: 'We created the following two classes to support our needs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了以下两个类来满足我们的需求：
- en: '`ApacheCommonsConfigurationPropertySource`: This is the extension of the `EnumerablePropertySource`
    base class that provides you with internal functionality in order to bridge XMLConfiguration
    from Apache Commons Configuration to the world of Spring Boot by providing transformation
    to get the specific property values by name via the `getProperty(String name)`
    implementation, and the list of all the supported property names via the `getPropertyNames()`
    implementation. In situations where you are dealing with the use case when the
    complete list of the available property names is not known or is very expensive
    to compute, you can just extend the `PropertySource` abstract class instead of
    using `EnumerablePropertySource`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApacheCommonsConfigurationPropertySource`：这是`EnumerablePropertySource`基类的扩展，它为您提供了内部功能，以便通过`getProperty(String
    name)`实现将XMLConfiguration从Apache Commons Configuration桥接到Spring Boot的世界，通过提供转换来获取特定属性值，以及通过`getPropertyNames()`实现获取所有支持的属性名称列表。在您处理的情况中，如果不知道或计算完整的属性名称列表非常昂贵，您可以直接扩展`PropertySource`抽象类，而不是使用`EnumerablePropertySource`。'
- en: '`ApacheCommonsConfigurationEnvironmentPostProcessor`: This is the implementation
    of the `EnvironmentPostProcessor` interface that gets instantiated by Spring Boot
    during the application startup and receives notification callback after the initial
    environment initialization has been completed, but before the application context
    startup. This class is configured in `spring.factories` and is automatically created
    by Spring Boot.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApacheCommonsConfigurationEnvironmentPostProcessor`：这是`EnvironmentPostProcessor`接口的实现，由Spring
    Boot在应用程序启动时实例化，并在初始环境初始化完成后、应用程序上下文启动之前接收通知回调。此类在`spring.factories`中配置，并由Spring
    Boot自动创建。'
- en: In our post-processor, we implement the `postProcessEnvironment(ConfigurableEnvironment
    environment, SpringApplication application)` method, which gives us access to
    the `ConfigurableEnvironment` instance. By the time this callback is invoked,
    we will get an environment instance that has already been populated with all of
    the properties from the preceding hierarchy. However, we will get the opportunity
    to inject our own `PropertySource` implementation anywhere in the list, which
    we will successfully do in the `ApacheCommonsConfigurationPropertySource.addToEnvironment(...)`
    method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的后处理器中，我们实现了`postProcessEnvironment(ConfigurableEnvironment environment,
    SpringApplication application)`方法，这使我们能够访问`ConfigurableEnvironment`实例。当此回调被调用时，我们将获得一个已经填充了前面层次结构中所有属性的`环境实例`。然而，我们将有机会在任何位置注入我们自己的`PropertySource`实现，我们将在`ApacheCommonsConfigurationPropertySource.addToEnvironment(...)`方法中成功实现这一点。
- en: In our case, we will choose to insert our source right below `systemEnvironment`
    in the order of precedence, but if needs be, we can alter this order to whatever
    highest precedence we desire. Just be careful not to place it so high that your
    properties become impossible to override via the command-line arguments, system
    properties, or environment variables.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将选择在优先级顺序中将我们的源代码插入到`systemEnvironment`下方，但如果需要的话，我们可以将此顺序更改为我们想要的最高优先级。但请务必小心，不要将其放置得过高，以至于无法通过命令行参数、系统属性或环境变量覆盖您的属性。
- en: Externalizing an environmental configuration using property files
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性文件外部化环境配置
- en: The previous recipe taught us about the application properties and how they
    are provisioned. As was mentioned at the beginning of this chapter, during application
    deployment, it is almost inevitable to have some property values that are environment
    dependant. They can be database configurations, service topologies, or even simple
    feature configurations where something might be enabled in development but not
    quite ready for production just yet.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节食谱教给我们有关应用程序属性以及它们是如何提供的。正如本章开头所提到的，在应用程序部署期间，几乎不可避免地会有一些属性值与环境相关。它们可以是数据库配置、服务拓扑，甚至是简单的功能配置，其中某些功能可能在开发中已启用，但尚未准备好投入生产。
- en: In this recipe, we will learn how to use an externally residing properties file
    for an environment-specific configuration, which might reside in the local filesystem
    or out in the wild on the internet.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用外部存储的属性文件进行特定环境的配置，这些文件可能位于本地文件系统或互联网上的任何地方。
- en: In this recipe, we will use the same application with all the existing configurations
    as we used in the previous recipe. We will use it to experiment with starting
    up using the external configuration properties that are living in the local filesystem
    and from an internet URL, such as GitHub or any other.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用与上一个菜谱中相同的配置，使用相同的应用程序。我们将使用它来实验使用存储在本地文件系统中的外部配置属性以及来自互联网URL（如GitHub或任何其他）的属性。
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start by adding a bit of code to log the value of our particular configuration
    property so that we can easily see the change in it as we do different things.
    Add an `@Bean` method to the `BookPubApplication` class located in the `src/main/java/org/test/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先添加一些代码来记录我们特定配置属性的值，这样我们就可以轻松地看到它在执行不同操作时的变化。在项目根目录下的`src/main/java/org/test/bookpub`目录中的`BookPubApplication`类中添加一个`@Bean`方法，内容如下：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s build the application by running `./gradlew clean bootJar` and start
    it by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`
    so as to see the following log output:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootJar`来构建应用程序，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger`来启动它，以便查看以下日志输出：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The value is empty, as we expected. Next, we will create a file named `external.properties`
    in our home directly with the following content:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值为空，正如我们所预期的。接下来，我们将在主目录中创建一个名为`external.properties`的文件，内容如下：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s run our application by executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger --spring.config.location=file:/home/<username>/external.properties`
    in order to see the following output in the logs:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过执行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger
    --spring.config.location=file:/home/<username>/external.properties`来运行我们的应用程序，以便在日志中看到以下输出：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For macOS users, the home directories can be found in the `/Users/<username>`
    folder.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS用户，主目录可以在`/Users/<username>`文件夹中找到。
- en: We can also load the file as an HTTP resource and not from the local filesystem.
    So, place a file named `external.properties` with the content of `my.config.value=From
    HTTP Config` somewhere on the web. It can even be checked in a GitHub or BitBucket
    repository, as long as it is accessible without any need for authentication.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以将文件作为HTTP资源加载，而不是从本地文件系统加载。因此，将名为`external.properties`的文件放置在Web上的某个位置，其中包含`my.config.value=From
    HTTP Config`的内容。它甚至可以检查GitHub或BitBucket存储库，只要它不需要任何身份验证即可访问。
- en: 'Let''s run our application by executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger --spring.config.location=http://<your file location
    path>/external.properties` in order to see the following output in the logs:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过执行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger
    --spring.config.location=http://<your file location path>/external.properties`来运行我们的应用程序，以便在日志中看到以下输出：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before delving into the details of an external configuration setup, let's quickly
    look at the code that was added in order to print the property value in the log.
    The element of focus is the `@Value` annotation that can be used on class fields
    or method arguments; it also instructs Spring to automatically inject the annotated
    variable with the value defined in the annotation. If the value is positioned
    in the wrapping curly braces prefixed with a dollar sign, (`${ }`), Spring will
    replace this with the value from the corresponding application property or with
    the default value, if it is provided, by adding the textual data after the colon
    (`:`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨外部配置设置的细节之前，让我们快速看一下添加的代码，以便在日志中打印属性值。关注的元素是`@Value`注解，它可以用于类字段或方法参数；它还指示Spring自动将注解变量注入到注解中定义的值。如果值位于以美元符号为前缀的括号中（`${
    }`），Spring将用相应的应用程序属性值替换它，如果没有提供默认值，则通过在冒号（`:`）之后添加文本数据来添加默认值。
- en: In our case, we defined it as `@Value("${my.config.value:}")String configValue`,
    so unless an application property named `my.config.value` exists, the default
    value of an empty String will be assigned to the `configValue` method argument.
    This construct is quite handy and eliminates the need to explicitly wire in the
    instance of an environment object just to get a specific property value out of
    it, as well as simplifying the code during testing, with less objects to mock.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将其定义为`@Value("${my.config.value:}")String configValue`，除非存在名为`my.config.value`的应用程序属性，否则将默认值空字符串分配给`configValue`方法参数。这种结构非常方便，消除了显式连接环境对象实例以从中获取特定属性值的需要，同时在测试期间简化了代码，减少了需要模拟的对象。
- en: The support for being able to specify the location of the application properties
    configuration file is geared towards supporting a dynamic multitude of environmental
    topologies, especially in cloud environments. This is often the case when the
    compiled application gets bundled into different cloud images that are destined
    for different environments and are being specially assembled by deployment tools
    such as Packer, Vagrant, and others.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 支持指定应用程序属性配置文件的位置，旨在支持动态的多种环境拓扑，尤其是在云环境中。这种情况通常发生在编译后的应用程序被打包成不同的云镜像，这些镜像旨在不同的环境中使用，并且由Packer、Vagrant等部署工具特别组装时。
- en: In this scenario, it is very common to drop a configuration file in the image
    filesystem while making the image, depending on what environment it is destined
    for. Spring Boot provides a very convenient ability to specify, via the command-line
    arguments, where the configuration properties file, which should be added to the
    application configuration bundle, resides.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在制作镜像时将配置文件放入镜像文件系统中是很常见的，具体取决于它旨在哪个环境。Spring Boot提供了一个非常方便的功能，可以通过命令行参数指定配置属性文件的位置，该文件应添加到应用程序配置包中。
- en: Using the `--spring.config.location` startup option, we can specify a location
    of one or multiple files, which can then be separated by a comma (`,`) to be added
    to the default ones. The file designations can be either files from a local filesystem,
    a classpath, or a remote URL. The locations will be resolved either by the `DefaultResourceLoader`
    class or, if configured via a `SpringApplication` constructor or setter, by the
    implementation that is provided by the `SpringApplication` instance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--spring.config.location`启动选项，我们可以指定一个或多个文件的位置，然后可以通过逗号（`,`）与默认值分开，以添加到默认值中。文件指定可以是本地文件系统中的文件、类路径或远程URL。位置将由`DefaultResourceLoader`类解析，或者如果通过`SpringApplication`构造函数或setter配置，则由`SpringApplication`实例提供的实现解析。
- en: If the location contains directories, the names should end with a `/` so as
    to let Spring Boot know that it should look for the `application.properties` file
    in these directories.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位置包含目录，名称应以`/`结尾，以便Spring Boot知道它应在这些目录中查找`application.properties`文件。
- en: If you want to change the default name of the file, Spring Boot provides you
    with this ability as well. Just set the `--spring.config.name` option to whatever
    filename that you want.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更改文件的默认名称，Spring Boot也提供了这个功能。只需将`--spring.config.name`选项设置为所需的任何文件名。
- en: It is important to remember that the default search paths for the configuration
    of `classpath:,classpath:/config,file:,file:config/` will always be used regardless
    of the presence of the `--spring.config.location` setting. This way, you can always
    retain your default configuration in `application.properties` and just override
    the ones that you need via the start up settings.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，无论是否存在`--spring.config.location`设置，默认的搜索路径`classpath:,classpath:/config,file:,file:config/`都将始终使用。这样，您始终可以保留`application.properties`中的默认配置，只需通过启动设置覆盖您需要的部分。
- en: Externalizing an environmental configuration using environment variables
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量外部化环境配置
- en: In the previous recipes, we have, a number of times, alluded to the fact that
    configuration values to a Spring Boot application can be passed and overridden
    by using OS environment variables. Operating systems rely on these variables to
    store information about various things. We probably have to set `JAVA_HOME` or
    `PATH` a few times, and these are examples of environment variables. OS environment
    variables is also a very important feature if one deploys their application using
    a PaaS system such as Heroku or Amazon AWS. In these environments, configuration
    values such as database access credentials and various API tokens are all provided
    over the environment variables.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们多次提到，可以通过使用操作系统环境变量来传递和覆盖Spring Boot应用程序的配置值。操作系统依赖于这些变量来存储有关各种事物的信息。我们可能需要设置`JAVA_HOME`或`PATH`几次，这些都是环境变量的例子。如果一个人使用像Heroku或Amazon
    AWS这样的PaaS系统部署他们的应用程序，那么OS环境变量也是一个非常重要的特性。在这些环境中，数据库访问凭证和各种API令牌等配置值都是通过环境变量提供的。
- en: Their power comes from the ability to completely externalize the configuration
    of simple key-value data pairs without the need to rely on placing a property
    or some other files in a particular location, and having this hardcoded in the
    application code base. These variables are also agnostic to the particular operating
    system and can be consumed in the Java program in the same way, `System.getenv()`,
    regardless of which OS the program is running on.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的力量来自于完全外部化简单键值对配置的能力，无需依赖于将属性或某些其他文件放置在特定位置，也不需要在应用程序代码库中硬编码。这些变量对特定的操作系统也是不可知的，可以在Java程序中以相同的方式使用，即`System.getenv()`，无论程序在哪个操作系统上运行。
- en: In this recipe, we will explore how this power can be leveraged to pass the
    configuration properties to our Spring Boot applications. We will continue to
    use the code base from the previous recipe and experiment with a few different
    ways of starting the application and using the OS environment variables in order
    to change the configuration values of some properties.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何利用这种力量将配置属性传递给我们的Spring Boot应用程序。我们将继续使用之前菜谱中的代码库，并尝试几种不同的启动应用程序和使用操作系统环境变量来更改某些属性配置值的方法。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the previous recipe, we added a configuration property named `my.config.value`.
    Let''s build the application by running `./gradlew clean bootJar` and start it
    by running `MY_CONFIG_VALUE="From ENV Config" ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar
    --spring.profiles.active=logger` so as to see the following output in the logs:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们添加了一个名为`my.config.value`的配置属性。让我们通过运行`./gradlew clean bootJar`来构建应用程序，并通过运行`MY_CONFIG_VALUE="From
    ENV Config" ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`来启动它，以便在日志中看到以下输出：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we want to use the environment variables while running our application via
    the Gradle `bootRun` task, the command line will be `MY_CONFIG_VALUE="From ENV
    Config" ./gradlew clean bootRun` and should produce the same output as in the
    preceding step.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在运行应用程序时通过Gradle的`bootRun`任务使用环境变量，命令行将是`MY_CONFIG_VALUE="From ENV Config"
    ./gradlew clean bootRun`，并且应该产生与前面步骤相同的输出。
- en: 'Conveniently enough, we can even mix and match how we set the configurations.
    We can use the environment variable to configure the `spring.config.location`
    property and use it to load other property values from the external properties
    file, as we did in the previous recipe. Let''s try this by launching our application
    by executing `SPRING_CONFIG_LOCATION= file:/home/<username>/external.properties
    ./gradlew bootRun`. We should see the following in the logs:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 足够方便的是，我们甚至可以混合和匹配配置的设置方式。我们可以使用环境变量来配置`spring.config.location`属性，并使用它来加载外部属性文件中的其他属性值，就像我们在之前的菜谱中所做的那样。让我们通过执行`SPRING_CONFIG_LOCATION=file:/home/<username>/external.properties
    ./gradlew bootRun`来启动我们的应用程序。我们应该在日志中看到以下内容：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While using environment variables is very convenient, it does have maintenance
    overhead if the number of these variables gets to be too many. To help deal with
    this issue, it is good practice to use a method of delegation by setting the `SPRING_CONFIG_LOCATION`
    variable to configure the location of the environment-specific properties file,
    typically by loading them from a URL location.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用环境变量非常方便，但如果这些变量的数量变得太多，它确实会有维护开销。为了帮助解决这个问题，将`SPRING_CONFIG_LOCATION`变量设置为配置特定环境属性文件的位置是一种很好的做法，通常是通过从URL位置加载它们。
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you learned from the section on environment configuration hierarchy, Spring
    Boot offers multiple ways of providing the configuration properties. Each of these
    is managed via an appropriate `PropertySource` implementation. We looked at how
    to create a custom implementation of `PropertySource` when we were implementing
    `ApacheCommonsConfigurationPropertySource`. Spring Boot already provides a `SystemEnvironmentPropertySource`
    implementation for us to use out of the box. This even gets automatically registered
    with the default implementation of the environment interface: the `SystemEnvironment`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在环境配置层次结构部分所学，Spring Boot提供了多种提供配置属性的方式。这些方式中的每一种都通过适当的`PropertySource`实现来管理。当我们实现`ApacheCommonsConfigurationPropertySource`时，我们探讨了如何创建自定义的`PropertySource`实现。Spring
    Boot已经为我们提供了一个`SystemEnvironmentPropertySource`实现，我们可以直接使用。这个实现甚至会被自动注册到环境接口的默认实现中：`SystemEnvironment`。
- en: As the `SystemEnvironment` implementation provides a composite façade on top
    of a multitude of different `PropertySource` implementations, the overriding takes
    place seamlessly, simply because the `SystemEnvironmentPropertySource` class sits
    higher up in the list than the `application.properties` file one.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SystemEnvironment`实现为众多不同的`PropertySource`实现提供了一个组合外观，因此覆盖操作是无缝进行的，这仅仅是因为`SystemEnvironmentPropertySource`类在列表中的位置高于`application.properties`文件。
- en: An important aspect that you should notice is the use of `ALL_CAPS` with underscores
    (`_`) in order to separate the words instead of the traditional conventional `all.lower.cased`
    format with dots (`.`) separating the words used in Spring Boot to name the configuration
    properties. This is due to the nature of some operating systems, namely Linux
    and OS X, which prevent the use of dots (`.`) in the names and instead encourages
    the use of the `ALL_CAPS` underscore-separated notation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意的一个重要方面是，使用`ALL_CAPS`和下划线（`_`）来分隔单词，而不是使用传统的点（`.`）分隔的`all.lower.cased`格式来命名Spring
    Boot中的配置属性。这是由于某些操作系统的特性，尤其是Linux和OS X，它们禁止在名称中使用点（`.`），而鼓励使用`ALL_CAPS`下划线分隔的表示法。
- en: In situations where the usage of environment variables to specify or override
    the configuration properties is not desired, Spring provides us with the `-Dspring.getenv.ignore`
    system property, which can be set to true and prevents the usage of environment
    variables. You might want to change this setting to true if you see errors or
    exceptions in the log due to the running of your code on some application servers
    or a particular security policy configuration that might not allow access to environment
    variables.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在不希望使用环境变量来指定或覆盖配置属性的情况下，Spring为我们提供了一个`-Dspring.getenv.ignore`系统属性，可以将其设置为true，以防止使用环境变量。如果你在日志中看到由于你的代码在某些应用程序服务器或特定的安全策略配置中运行而导致的错误或异常，你可能希望将此设置更改为true，因为这些配置可能不允许访问环境变量。
- en: Externalizing an environmental configuration using Java system properties
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java系统属性外部化环境配置
- en: While environment variables can, on rare occasions, be hit or miss, the good
    old Java system properties can always be trusted to be there for you. In addition
    to using the environment variables and command-line arguments represented by the
    property names prefixed with a double dash (`--`), Spring Boot provides you with
    the ability to use the plain Java system properties to set or override the configuration
    properties.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管环境变量在罕见情况下可能会出现或错过，但古老的Java系统属性始终可以信赖它们会为你提供支持。除了使用以双横线（`--`）为前缀的属性名称表示的环境变量和命令行参数之外，Spring
    Boot还为你提供了使用纯Java系统属性来设置或覆盖配置属性的能力。
- en: This can be useful in a number of situations, particularly if your application
    is running in a container that sets certain values during startup via the system
    properties that you want to get access to, or if a property value is not set via
    a command-line `-D` argument, but rather in some library via code and by calling
    `System.setProperty(...)`, especially if property value is being accessed from
    inside a static method of sorts. While arguably these cases are rare, it takes
    only one to make you bend over backwards in an effort to try and integrate this
    value into your application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这在许多情况下都很有用，尤其是如果你的应用程序在一个容器中运行，该容器在启动时通过系统属性设置某些值，而你想要访问这些值，或者如果属性值不是通过命令行`-D`参数设置，而是在某个库中通过代码和调用`System.setProperty(...)`来设置，尤其是如果属性值是从某种静态方法内部访问时。虽然这些情况可能很少见，但只要有一个情况，就足以让你费尽心思尝试将这个值整合到你的应用程序中。
- en: In this recipe, we will use the same application executable that was used for
    the previous one, with the only difference being that we are using Java system
    properties instead of command-line arguments or environment variables to set our
    configuration properties at runtime.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用与之前相同的应用程序可执行文件，唯一的区别是我们使用Java系统属性而不是命令行参数或环境变量来在运行时设置我们的配置属性。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s continue our experiments by setting the `my.config.value` configuration
    property. Build the application by running `./gradlew clean bootJar` and start
    it by running `java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`
    so as to see the following in the logs:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过设置`my.config.value`配置属性来继续我们的实验。通过运行`./gradlew clean bootJar`来构建应用程序，并通过运行`java
    -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`来启动它，以便在日志中看到以下内容：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we want to be able to set the Java system property while running our application
    using the Gradle''s `bootRun` task, we will need to add this to the `applicationDefaultJvmArgs`
    configuration in the `build.gradle` file. Let''s add `-Dmy.config.value=Gradle`
    to this list and start the application by running `./gradlew clean bootRun`. We
    should see the following in the logs:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在运行应用程序时使用Gradle的`bootRun`任务设置Java系统属性，我们需要将此添加到`build.gradle`文件中的`applicationDefaultJvmArgs`配置。让我们将`-Dmy.config.value=Gradle`添加到这个列表中，并通过运行`./gradlew
    clean bootRun`来启动应用程序。我们应该在日志中看到以下内容：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we made the `applicationDefaultJvmArgs` setting to be shared with `launch.script`,
    rebuilding the application by running `./gradlew clean bootJar` and starting it
    by running `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar` should yield the same
    output in the logs as in the preceding step.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将`applicationDefaultJvmArgs`设置与`launch.script`共享，通过运行`./gradlew clean bootJar`重新构建应用程序，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`来启动它，应该会在日志中产生与前面步骤相同的输出。
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You might have already guessed that Java system properties are consumed by a
    similar mechanism that is used for environment variables, and you would be correct.
    The only real difference is the implementation of `PropertySource`. This time,
    a more generic `MapPropertySource` implementation is used by `StandardEnvironment`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，Java系统属性是通过与用于环境变量的类似机制消耗的，而且你的猜测是正确的。唯一的真正区别是`PropertySource`的实现。这次，`StandardEnvironment`使用了更通用的`MapPropertySource`实现。
- en: What you have also probably noticed is the need to launch our application using
    the `java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`
    command instead of just simply invoking the self-executing packaged JAR by itself.
    This is because, unlike the environment variables and command-line arguments,
    Java system properties have to be set on the Java executable ahead of everything
    else.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，需要使用`java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`命令来启动我们的应用程序，而不是简单地调用自执行打包JAR。这是因为，与环境变量和命令行参数不同，Java系统属性必须在所有其他内容之前设置在Java可执行文件上。
- en: We did manage to work around this need by effectively hardcoding the values
    in our `build.gradle` file, which, combined with the enhancements that we made
    to `launch.script`, allowed us embed the `my.config.value` property in the command
    line in the self-executing jar, as well as use it with the Gradle's `bootRun`
    task.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实通过在我们的`build.gradle`文件中有效地硬编码值来绕过了这个需求，这结合了我们为`launch.script`所做的增强，使我们能够将`my.config.value`属性嵌入到自执行jar的命令行中，以及使用Gradle的`bootRun`任务。
- en: The risk of using this approach with the configuration properties is that it
    will always override the values that we set in the higher layers of the configuration,
    such as `application.properties` and others. Unless you are explicitly constructing
    the Java executable command line and not using the self-launching capabilities
    of the packaged JAR, it is best not to use Java system properties and consider
    using the command-line arguments or environment variables instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法配置属性的风险是它将始终覆盖我们在配置的高层设置的值，例如`application.properties`和其他配置。除非你明确构造Java可执行命令行并且不使用打包JAR的自启动功能，否则最好不要使用Java系统属性，而是考虑使用命令行参数或环境变量。
- en: Externalizing an environmental config using JSON
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON外部化环境配置
- en: We have looked at a number of different ways to externally add or override the
    values of specific properties, either by using environment variables, system properties,
    or command-line arguments. All those options provide us with a great deal of flexibility,
    but with the exception of external property files, are all limited to setting
    one property at a time. When it comes to using property files, the syntax is not
    exactly the best at representing nested, hierarchical data structures, and can
    get a bit tricky. To avoid this situation, Spring Boot provides us with an ability
    to also pass, externally, JSON-encoded content containing an entire config hierarchy
    of settings.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了许多不同的方法来外部添加或覆盖特定属性的值，无论是通过使用环境变量、系统属性还是命令行参数。所有这些选项都为我们提供了大量的灵活性，但除了外部属性文件外，都限制于一次设置一个属性。当涉及到使用属性文件时，其语法并不完全适合表示嵌套的层次数据结构，可能会有些棘手。为了避免这种情况，Spring
    Boot为我们提供了一种能力，也可以外部传递包含整个配置设置层次结构的JSON编码内容。
- en: In this recipe, we will use the same application executable that was used for
    the previous one, with the only difference being using external JSON content to
    set our configuration properties at runtime.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用与之前相同的应用程序可执行文件，唯一的区别是使用外部JSON内容在运行时设置我们的配置属性。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s continue our experiments by setting the `my.config.value` configuration
    property. Build the application by running `./gradlew clean bootJar` and start
    it by running `java -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.application.json={"my":{"config":{"value":"From
    external JSON"}}}` so as to see the following in the logs:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过设置`my.config.value`配置属性来继续我们的实验。通过运行`./gradlew clean bootJar`来构建应用程序，并通过运行`java
    -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.application.json={"my":{"config":{"value":"From
    external JSON"}}}`来启动它，以便在日志中看到以下内容：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we want to be able to set the content using Java system properties, we can
    use `-Dspring.application.json` instead, assigning the same JSON content as the
    value.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要能够使用Java系统属性设置内容，我们可以使用`-Dspring.application.json`代替，将相同的JSON内容作为值分配。
- en: 'Alternatively, we can also rely on the `SPRING_APPLICATION_JSON` environment
    variable to pass the same JSON content in the following way:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们也可以依赖`SPRING_APPLICATION_JSON`环境变量以下述方式传递相同的JSON内容：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just like every other configuration approach we have looked at, the JSON content
    is consumed by a dedicated `EnvironmentPostProcessor` implementation. The only
    difference is the flattening of the JSON tree into a flat property map, to match
    the dot-separated properties naming style. In our case, the `my->config->value`
    nested map gets converted into a flat map with only one key, `my.config.value`,
    with the value of `From external JSON`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们所查看的每一种其他配置方法一样，JSON内容是由一个专门的`EnvironmentPostProcessor`实现消费的。唯一的区别是将JSON树扁平化为一个平面属性映射，以匹配点分隔的属性命名风格。在我们的例子中，`my->config->value`嵌套映射被转换为一个只有一个键的平面映射，键为`my.config.value`，值为`From
    external JSON`。
- en: The setting of the JSON content can come from ANY property source, available
    from the environment at the time of loading, which contains a key named `spring.application.json`
    with a value of valid JSON content, and is not only limited to being set by an
    Environment Variable or using the `SPRING_APPLICATION_JSON` name or Java System
    Property.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: JSON内容的设置可以来自任何在加载时从环境中可用的属性源，它包含一个名为`spring.application.json`的键，其值为有效的JSON内容，并且不仅限于通过环境变量设置或使用`SPRING_APPLICATION_JSON`名称或Java系统属性设置。
- en: This capability can be very useful to provide externally-defined, environment-specific
    configuration in bulk. The best way is to do so via setting the `SPRING_APPLICATION_JSON`
    environment variable on the machine instance using machine/image provisioning
    tools such as Chef, Puppet, Ansible, Packer, and so on. This enables you to store
    an entire configuration hierarchy in one JSON file externally, and then simply
    provision the correct content on the specific machine during provisioning time
    by just setting an Environment Variable. All applications running on that machine
    will automatically consume it upon startup.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能可以非常方便地批量提供外部定义的环境特定配置。最佳做法是通过在机器实例上使用机器/镜像配置工具（如Chef、Puppet、Ansible、Packer等）设置`SPRING_APPLICATION_JSON`环境变量来实现。这使您能够在外部存储整个配置层次结构在一个JSON文件中，然后在配置时间只需设置一个环境变量，就可以在特定的机器上简单地提供正确的内容。所有在该机器上运行的应用程序在启动时将自动消费它。
- en: Setting up Consul
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Consul
- en: So far, everything that we have been doing with the configuration was connected
    to the local set of data. In a real, large-scale enterprise environment, this
    is not always the case and quite frequently there is the desire to be able to
    make the configuration changes at large, across hundreds or even thousands of
    instances or machines.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的所有配置都与本地数据集相关联。在真实的大型企业环境中，情况并不总是如此，并且经常有在大量实例或机器上做出配置更改的愿望。
- en: There are a number of tools that exist to help you with this task, and in this
    recipe, we will take a look at one that, in my opinion, stands out from the group,
    giving you the ability to cleanly and elegantly configure the environment variables
    for a starting application using a distributed data store. The tool's name is
    **Consul**. It is an open source product from Hashicorp and is designed to discover
    and configure the services in a large, distributed infrastructure.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助您完成这项任务，在这个菜谱中，我们将探讨其中一个，我认为它在众多工具中脱颖而出，它能够使用分布式数据存储干净优雅地配置启动应用程序的环境变量。这个工具的名称是**Consul**。它是Hashicorp的开源产品，旨在发现和配置大型分布式基础设施中的服务。
- en: In this recipe, we will take a look at how to install and configure Consul and
    experiment with some key functionalities that it provides. This will give us the
    necessary familiarity for our next recipe, where we will be using Consul to provide
    the configuration values that are needed to start our application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何安装和配置Consul，并实验一些它提供的关键功能。这将为我们下一个菜谱提供必要的熟悉度，在那里我们将使用Consul来提供启动我们的应用程序所需的配置值。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Go to [https://consul.io/downloads.html](https://consul.io/downloads.html) and
    download the appropriate archive, depending on the operating system that you are
    using. Consul supports Windows, OS X, and Linux, so it should work for the majority
    of readers.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://consul.io/downloads.html](https://consul.io/downloads.html)下载适合您所使用的操作系统的相应存档。Consul支持Windows、OS
    X和Linux，因此它应该适用于大多数读者。
- en: If you are an OS X user, you can install Consul using Homebrew by running `brew
    install caskroom/cask/brew-cask` followed by `brew cask install consul`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是OS X用户，您可以通过运行`brew install caskroom/cask/brew-cask`然后运行`brew cask install
    consul`来使用Homebrew安装Consul。
- en: 'After the installation, we should be able to run `consul --version` and see
    the following output:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们应该能够运行`consul --version`并看到以下输出：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With Consul successfully installed, we should be able to start it by running
    the `consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul` command and
    our terminal window will display the following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Consul成功安装后，我们应该能够通过运行`consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul`命令来启动它，我们的终端窗口将显示以下内容：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With the Consul service running, we can verify that it contains one member
    by running the `consul members` command, and should see the following result:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Consul服务运行时，我们可以通过运行`consul members`命令来验证它包含一个成员，并应该看到以下结果：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While Consul can also provide discovery for services, health checks, distributed
    locks, and more, we are going to focus on the key/value service as this is what
    will be used to provide the configuration in the next recipe. So, let's put the
    `From Consul Config` value in the key/value store by executing the `curl -X PUT
    -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value` command.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然Consul也可以提供服务发现、健康检查、分布式锁等功能，但我们将重点关注键值服务，因为这是我们将在下一个菜谱中用于提供配置的服务。所以，让我们通过执行`curl
    -X PUT -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value`命令将`From
    Consul Config`值放入键值存储。
- en: If you are using Windows, you can get curl from [http://curl.haxx.se/download.html](http://curl.haxx.se/download.html).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows，您可以从[http://curl.haxx.se/download.html](http://curl.haxx.se/download.html)获取curl。
- en: 'We can also retrieve the data by running the `curl http://localhost:8500/v1/kv/bookpub/my/config/value`
    command and should see the following output:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过运行`curl http://localhost:8500/v1/kv/bookpub/my/config/value`命令来检索数据，并应该看到以下输出：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can delete this value by running the `curl -X DELETE http://localhost:8500/v1/kv/bookpub/my/config/value`
    command.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行`curl -X DELETE http://localhost:8500/v1/kv/bookpub/my/config/value`命令来删除此值。
- en: In order to modify the existing value and change it for something else, execute
    the `curl -X PUT -d 'newval' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=20`
    command.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修改现有值并将其更改为其他内容，请执行`curl -X PUT -d 'newval' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=20`命令。
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: A detailed explanation about how Consul works and all the possible options for
    its key/value service would take a book of its own, so here we will look only
    at the basic pieces. It is strongly recommended that you read Consul's documentation
    at [https://consul.io/intro/getting-started/services.html](https://consul.io/intro/getting-started/services.html).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Consul如何工作以及其键/值服务的所有可能选项的详细解释将需要一本书，所以在这里我们只看看基本的部分。强烈建议您阅读Consul的文档[https://consul.io/intro/getting-started/services.html](https://consul.io/intro/getting-started/services.html)。
- en: In *step 3*, we started the Consul agent in server mode. It acts as a main master
    node and, in real deployment, the local agents running on the individual instances
    will be using the server node to connect to and retrieve data from. For our test
    purposes, we will just use this server node as if it were a local agent.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们以服务器模式启动了Consul代理。它作为主主节点，在实际部署中，运行在各个实例上的本地代理将使用服务器节点来连接并检索数据。为了我们的测试目的，我们将只使用这个服务器节点，就像它是一个本地代理一样。
- en: The information displayed upon startup shows us that our node has started as
    a server node, establishing an HTTP service on port `8500` as well as the DNS
    and RPC services, if that's how one chooses to connect to it. We can also see
    that there is only one node in the cluster, ours, and we are the elected leader
    running in a healthy state.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时显示的信息告诉我们，我们的节点已作为服务器节点启动，在`8500`端口上建立HTTP服务，以及DNS和RPC服务，如果这是人们选择连接的方式。我们还可以看到集群中只有一个节点，那就是我们的节点，我们作为被选出的领导者运行在健康状态。
- en: As we will be using the convenient RESTful HTTP API via cURL, all of our requests
    will be using localhost on port `8500`. Being a RESTful API, it fully adheres
    to CRUD verb terminology, and to insert the data, we will use a `PUT` method on
    a `/v1/kv` endpoint in order to set the `bookpub/my/config/value` key.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将通过cURL使用方便的RESTful HTTP API，我们所有的请求都将使用localhost的`8500`端口。作为一个RESTful API，它完全遵循CRUD动词术语，为了插入数据，我们将使用`/v1/kv`端点的`PUT`方法来设置`bookpub/my/config/value`键。
- en: 'Retrieving the data is even more straightforward: we just make a `GET` request
    to the same `/v1/kv` service using the desired key. The same goes for `DELETE`,
    with the only difference being the method name.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据甚至更加简单：我们只需向相同的`/v1/kv`服务发送一个使用所需键的`GET`请求。对于`DELETE`也是如此，唯一的区别是方法名称。
- en: The update operation requires a bit more information in the URL, namely the
    `cas` parameter. The value of this parameter should be the `ModifyIndex` of the
    desired key, which can be obtained from the `GET` request. In our case, it has
    a value of 20.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作需要在URL中提供更多信息，即`cas`参数。此参数的值应该是所需键的`ModifyIndex`，这可以从`GET`请求中获得。在我们的例子中，它的值为20。
- en: Externalizing an environmental config using Consul and envconsul
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Consul和envconsul外部化环境配置
- en: In the previous recipe, we had our Consul service installed and experimented
    with its key/value capabilities to learn how we could manipulate the data in it
    in order to integrate Consul with our application and make the data extraction
    process seamless and non-invasive from an application standpoint.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们已经安装了Consul服务，并对其键/值功能进行了实验，以了解我们如何操作其中的数据，以便将Consul集成到我们的应用程序中，并使数据提取过程从应用程序的角度来看无缝且非侵入性。
- en: As we don't want our application to know anything about Consul and have to explicitly
    connect to it, even though such a possibility exists, we will employ another utility,
    also created as open source by Hashicorp, called **envconsul**. It will connect
    to the Consul service for us, extract the specified configuration key/value tree,
    and expose it as the environment variables to be used while also launching our
    application. Pretty cool, right?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望我们的应用程序了解任何关于Consul的信息，并且必须显式地连接到它，尽管存在这种可能性，我们将使用另一个实用程序，这个实用程序也是由Hashicorp创建的，开源的，称为**envconsul**。它将为我们连接到Consul服务，提取指定的配置键/值树，并在启动我们的应用程序的同时将其作为环境变量暴露出来。很酷，对吧？
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we get started with launching our application, which was created in the
    previous recipes, we need to install the envconsul utility.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动之前，在之前的菜谱中创建的应用程序，我们需要安装envconsul实用程序。
- en: Download the binary for your respective operating system from [https://github.com/hashicorp/envconsul/releases](https://github.com/hashicorp/envconsul/releases)
    and extract the executable to any directory of your choice, though it is better
    to put it somewhere that is in the PATH.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://github.com/hashicorp/envconsul/releases](https://github.com/hashicorp/envconsul/releases)下载您相应操作系统的二进制文件，并将其提取到您选择的任何目录中，尽管将其放在PATH中某个位置会更好。
- en: Once envconsul is extracted from the downloaded archive, we are ready to start
    using it so as to configure our application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从下载的存档中提取了envconsul，我们就可以开始使用它来配置我们的应用程序了。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: If you have not already added the value for the `my/config/value` key to Consul,
    let's add it by running `curl -X PUT -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有将`my/config/value`键的值添加到Consul中，让我们通过运行`curl -X PUT -d 'From Consul Config'
    http://localhost:8500/v1/kv/bookpub/my/config/value`来添加它。
- en: 'The first step is to make sure envconsul can connect to the Consul server and
    that it extracts the correct data based on our configuration key. Let''s execute
    a simple test by running the `envconsul --once --sanitize --upcase --prefix bookpub
    env` command. We should see the following in the output:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是确保envconsul可以连接到Consul服务器，并且根据我们的配置密钥提取正确数据。让我们通过运行`envconsul --once --sanitize
    --upcase --prefix bookpub env`命令来执行一个简单的测试。我们应该在输出中看到以下内容：
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After we have verified that envconsul is returning the correct data to us,
    we will use it to launch our `BookPub` application by running `envconsul --once
    --sanitize --upcase --prefix bookpub ./gradlew clean bootRun`. Once the application
    has started, we should see the following output in the logs:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们验证envconsul返回正确数据给我们之后，我们将使用它通过运行`envconsul --once --sanitize --upcase --prefix
    bookpub ./gradlew clean bootRun`来启动我们的`BookPub`应用程序。一旦应用程序启动，我们应该在日志中看到以下输出：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can do the same thing by building the self-starting executable JAR by running
    `./gradlew clean bootJar`, and start it by running `envconsul --once --sanitize
    --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar` to make
    sure we see the same output in the logs as in the preceding step. If you see `Gradle`
    instead of `From Consul Config`, make sure the `applicationDefaultJvmArgs` configuration
    in `build.gradle` does not have `-Dmy.config.value=Gradle` in it.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过运行`./gradlew clean bootJar`来构建自启动的可执行JAR文件，然后通过运行`envconsul --once --sanitize
    --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`来启动它，以确保我们在日志中看到与前一步骤相同的输出。如果你看到的是`Gradle`而不是`From
    Consul Config`，请确保`build.gradle`中的`applicationDefaultJvmArgs`配置中没有包含`-Dmy.config.value=Gradle`。
- en: 'Another marvelous ability of envconsul is not only to export the configuration
    key values as environment variables, but also to monitor for any changes and restart
    the application if the values in Consul change. Let''s launch our application
    by running `envconsul --sanitize --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`,
    and we should see the following value in the log:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: envconsul的另一个神奇能力不仅可以将配置键值导出为环境变量，还可以监视任何更改，并在Consul中的值更改时重新启动应用程序。让我们通过运行`envconsul
    --sanitize --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`来启动我们的应用程序，我们应该在日志中看到以下值：
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will now use the consul command to get the current `ModifyIndex` of our
    key and update its value to `From UpdatedConsul Config` by opening another terminal
    window and executing `curl http://localhost:8500/v1/kv/bookpub/my/config/value`,
    grabbing the `ModifyIndex` value, and using it to execute `curl -X PUT -d ''From
    UpdatedConsul Config'' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=<ModifyIndex
    Value>`. We should see our running application magically restart itself and our
    newly updated value displayed in the log at the end:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用consul命令获取我们键的当前`ModifyIndex`，并在另一个终端窗口中执行`curl http://localhost:8500/v1/kv/bookpub/my/config/value`，获取`ModifyIndex`值，并使用它来执行`curl
    -X PUT -d 'From UpdatedConsul Config' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=<ModifyIndex
    Value>`。我们应该看到我们的运行应用程序神奇地重新启动，并且我们的新更新值在日志的末尾显示：
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we just did was pretty sweet, right? Let's examine the magic going on behind
    the scenes in more detail. We will start by dissecting the command line and explaining
    what each argument control option does.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才做的事情很酷，对吧？让我们更详细地检查幕后发生的魔法。我们将从分析命令行并解释每个参数控制选项的作用开始。
- en: 'Our first execution command line was `envconsul --once --sanitize --upcase
    --prefix bookpub ./gradlew clean bootRun`, so let''s take a look at exactly what
    we did, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次执行的命令行是 `envconsul --once --sanitize --upcase --prefix bookpub ./gradlew
    clean bootRun`，让我们看看我们到底做了什么，如下所示：
- en: First, one might notice that there is no indication about which Consul node
    we should be connecting to. This is because there is an implicit understanding
    or an assumption that you already have a Consul agent running locally on `localhost:8500`.
    If this is not the case for whatever reason, you can always explicitly specify
    the Consul instance to connect via the `--consul localhost:8500` argument added
    to the command line.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，人们可能会注意到没有关于我们应该连接到哪个 Consul 节点的指示。这是因为有一个隐含的理解或假设，即你已经在本地 `localhost:8500`
    上运行了一个 Consul 代理。如果这不是出于任何原因的情况，你总是可以通过在命令行中添加 `--consul localhost:8500` 参数来显式指定要连接的
    Consul 实例。
- en: 'The `--prefix` option specifies the starting configuration key segment in which
    to look for the different values. When we were adding keys to Consul, we used
    the following key: `bookpub/my/config/value`. By specifying the `--prefix bookpub`
    option, we tell envconsul to strip the `bookpub` part of the key and use all the
    internal tree elements in `bookpub` to construct the environment variables. Thus,
    `my/config/value` becomes the environment variable.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--prefix` 选项指定了要查找不同值的起始配置密钥段。当我们向 Consul 添加密钥时，我们使用了以下密钥：`bookpub/my/config/value`。通过指定
    `--prefix bookpub` 选项，我们告诉 envconsul 移除密钥中的 `bookpub` 部分，并使用 `bookpub` 中的所有内部树元素来构建环境变量。因此，`my/config/value`
    成为环境变量。'
- en: The `--sanitize` option tells envconsul to replace all the invalid characters
    with underscores (`_`). So, if we were to only use `--sanitize`, we would end
    up with `my_config_value` as an environment variable.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--sanitize` 选项告诉 envconsul 将所有无效字符替换为下划线 (`_`)。所以，如果我们只使用 `--sanitize`，我们最终会得到
    `my_config_value` 作为环境变量。'
- en: The `--upcase` option, as you might already have guessed, changes the environment
    variable key to all upper case characters, so when combined with the `--sanitize` option,
    `my/config/value` key gets transformed into the `MY_CONFIG_VALUE` environment
    variable.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--upcase` 选项，正如你可能已经猜到的，将环境变量密钥更改为全部大写字母，因此当与 `--sanitize` 选项结合使用时，`my/config/value`
    密钥被转换为 `MY_CONFIG_VALUE` 环境变量。'
- en: The `--once` option indicates that we only want to externalize the keys as environment
    variables once and do not want to continuously monitor for changes in the Consul
    cluster. If a key in our prefix tree has changed its value, we re-externalize
    the keys as environment variables and restart the application.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--once` 选项表示我们只想将密钥一次外部化为环境变量，并且不想持续监控 Consul 集群中的变化。如果我们的前缀树中的某个密钥改变了其值，我们将重新外部化密钥作为环境变量并重新启动应用程序。'
- en: This last option, `--once`, provides a very useful choice of functionalities.
    If you are interested only in the initial bootstrapping of your application via
    the use of a Consul-shared configuration, then the keys will be set as environment
    variables, the application will be launched, and envconsul will consider its job
    done. However, if you would like to monitor the Consul cluster for changes to
    keys/values and, after the change has taken place, restart your application reflecting
    the new change, then remove the `--once` option and envconsul will restart the
    application once the change has occurred.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个选项 `--once` 提供了一些非常有用的功能选择。如果你只对通过使用 Consul 共享配置来启动你的应用程序感兴趣，那么密钥将被设置为环境变量，应用程序将被启动，envconsul
    将认为其任务已完成。然而，如果你希望监控 Consul 集群中密钥/值的变化，并在变化发生后重新启动应用程序以反映新的变化，那么请移除 `--once` 选项，envconsul
    将在变化发生后重新启动应用程序。
- en: Such behavior can be very useful and handy for things such as a near-instantaneous
    changes to the database connection configuration. Imagine that you need to do
    a quick failover from one database to another and your JDBC URL is configured
    via Consul. All you need to do is push a new JDBC URL value and envconsul will
    almost immediately detect this change and restart the application, telling it
    to connect to a new database node.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于诸如数据库连接配置的几乎即时更改等事情非常有用和方便。想象一下，你需要快速从一台数据库切换到另一台，并且你的 JDBC URL 通过 Consul
    进行配置。你所需要做的只是推送一个新的 JDBC URL 值，envconsul 将几乎立即检测到这种变化并重新启动应用程序，告诉它连接到新的数据库节点。
- en: Currently, this functionality is implemented by sending a traditional SIGTERM
    signal to an application running process, telling it to terminate and, once the
    process is exited, restart the application. This might not always be the desired
    behavior, especially if it takes some time for an application to start up and
    be capable of taking traffic. You don't want your entire cluster of web applications
    to be shut down, even if it will only be for a few minutes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，此功能通过向运行中的应用程序进程发送传统的SIGTERM信号来实现，告诉它终止，一旦进程退出，重新启动应用程序。这不一定总是期望的行为，特别是如果应用程序启动并能够处理流量需要一些时间的话。你不想你的整个Web应用程序集群被关闭，即使只是几分钟。
- en: To provide a better handling of this scenario, envconsul was enhanced to be
    able to send a number of standard signals that can be configured via a newly added
    `--kill-signal` option. Using this option, we can specify any of the SIGHUP, SIGTERM,
    SIGINT, SIGQUIT, SIGUSR1, or SIGUSR2 signals to be used instead of the default
    SIGTERM, to be sent to a running application process once the key/value changes
    have been detected.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地处理这种情况，envconsul被增强以能够发送一系列标准信号，这些信号可以通过新添加的`--kill-signal`选项进行配置。使用此选项，我们可以在检测到键/值变化后，指定任何SIGHUP、SIGTERM、SIGINT、SIGQUIT、SIGUSR1或SIGUSR2信号来代替默认的SIGTERM，发送给运行中的应用程序进程。
- en: The process signal handling in Java is not as clear and straightforward due
    to most of the behavior being very specific to a particular operating system and
    the JVM that is run atop it. Some of the signals in the list will terminate the
    application anyway or, in the case of SIGQUIT, the JVM will print Core Dump into
    the standard output. However, there are ways to configure the JVM, depending on
    the operating system, to let us use SIGUSR1 and SIGUSR2 instead of acting on those
    signals itself, but unfortunately that topic falls outside the scope of this book.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数行为都非常特定于特定的操作系统和在其上运行的JVM，Java中的进程信号处理并不清晰和直接。列表中的某些信号无论如何都会终止应用程序，或者在SIGQUIT的情况下，JVM会将核心转储打印到标准输出。然而，根据操作系统，我们可以配置JVM来让我们使用SIGUSR1和SIGUSR2而不是对这些信号本身进行操作，但不幸的是，这个主题超出了本书的范围。
- en: 'Here is a sample example of how to deal with **Signal Handlers**: [https://github.com/spotify/daemon-java](https://github.com/spotify/daemon-java),
    or see the Oracle Java documentation at [https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html)
    for a detailed explanation.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何处理**信号处理程序**的示例：[https://github.com/spotify/daemon-java](https://github.com/spotify/daemon-java)，或者查看Oracle
    Java文档中的[https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html)以获取详细说明。
