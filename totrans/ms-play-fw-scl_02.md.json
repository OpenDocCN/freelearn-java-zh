["```java\ncase class Artist(name: String, country: String)\n\nobject Artist {\n  val availableArtist = Seq(Artist(\"Wolfgang Amadeus Mozart\", \"Austria\"), \n    Artist(\"Ludwig van Beethoven\", \"Germany\"), \n    Artist(\"Johann Sebastian Bach\", \"Germany\"), \n    Artist(\"Frédéric François Chopin\", \"Poland\"), \n    Artist(\"Joseph Haydn\", \"Austria\"), \n    Artist(\"Antonio Lucio Vivaldi\", \"Italy\"), \n    Artist(\"Franz Peter Schubert\", \"Austria\"), \n    Artist(\"Franz Liszt\", \"Austria\"), \n    Artist(\"Giuseppe Fortunino Francesco Verdi\", \"Austria\")) \n\n  def fetch: Seq[Artist] = {\n    availableArtist \n  } \n\n  def fetchByName(name: String): Seq[Artist] = {\n    availableArtist.filter(a => a.name.contains(name)) \n  } \n\n  def fetchByCountry(country: String): Seq[Artist] = {\n    availableArtist.filter(a => a.country == country) \n  } \n\n  def fetchByNameOrCountry(name: String, country: String): Seq[Artist] = { \n    availableArtist.filter(a => a.name.contains(name) || a.country == country) \n  } \n\n  def fetchByNameAndCountry(name: String, country: String): Seq[Artist] = {\n    availableArtist.filter(a => a.name.contains(name) && a.country == country)\n  } \n} \n```", "```java\n@(artists: Seq[Artist])\n<!DOCTYPE html> \n\n<html>\n    <head>\n        <title>Action App</title>\n    </head>\n    <body>\n        <table>\n            <thead>\n                <tr>\n                    <th>Name</th>\n                    <th>Country</th>\n                    </tr>\n            </thead>\n            <tbody>\n            @artists.map { artist => \n                <tr>\n                    <td>@artist.name</td>\n                    <td>@artist.country</td>\n                </tr>\n            } \n            </tbody>\n        </table>\n    </body>\n</html>\n```", "```java\ndef listArtist = Action {\n  Ok(views.html.home(Artist.fetch))\n}\n```", "```java\nGET     /api/artist       controllers.Application.listArtist\n```", "```java\ntrait EssentialAction extends (RequestHeader => Iteratee[Array[Byte], Result]) with Handler {\n\n  def apply() = this\n\n}\n\nobject EssentialAction {\n  def apply(f: RequestHeader => Iteratee[Array[Byte], Result]): EssentialAction = new EssentialAction {\n    def apply(rh: RequestHeader) = f(rh)\n  }\n}\n```", "```java\n  def fetchArtistByName(name:String) = Action { \n     Ok(views.html.home(Artist.fetchByName(name))) \n  } \n```", "```java\nGET    /api/artist/:name       controllers.Application.fetchArtistByName(name)\n```", "```java\nGET    /api/artist/:name        controllers.Application.fetchArtistByName(name:String)\n```", "```java\ndef search(name: String, country: String) = Action { \n    val result = Artist.fetchByNameOrCountry(name, country) \n    if(result.isEmpty){\n      NoContent\n       } \n    else {\n      Ok(views.html.home(result))\n    }\n  }\n```", "```java\nGET    /api/search/artist        controllers.Application.search(name:String,country:String)     \n```", "```java\nGET    /api/search/artist    controllers.Application.search(name:String?=\"\",country:String?=\"\") \n```", "```java\ndef search2(name: Option[String], country: String) = Action { \n    val result = name match{ \n      case Some(n) => Artist.fetchByNameOrCountry(n, country) \n      case None => Artist.fetchByCountry(country) \n    } \n    if(result.isEmpty){\n      NoContent\n    } \n    else { \n      Ok(views.html.home(result)) \n    } \n  }\n```", "```java\nGET    /api/search2/artist    controllers.Application.search2(name:Option[String],country:String)\n```", "```java\n trait Action[A] extends EssentialAction {   \n\n  //Type of the request body. \n  type BODY_CONTENT = A \n\n  //Body parser associated with this action. \n  def parser: BodyParser[A] \n\n  //Invokes this action \n  def apply(request: Request[A]): Future[Result] \n\n       def apply(rh: RequestHeader): Iteratee[Array[Byte], Result] = parser(rh).mapM {\n      case Left(r) => \n\n Future.successful(r)\n case Right(a) => \n val request = Request(rh, a) \n\n Play.maybeApplication.map { app => \n play.utils.Threads.withContextClassLoader(app.classloader) {\n apply(request)\n         }\n }.getOrElse {\n         apply(request)\n }\n }(executionContext)\n\n  //The execution context to run this action in \n  def executionContext: ExecutionContext = play.api.libs.concurrent.Execution.defaultContext \n\n  //Returns itself, for better support in the routes file. \n  override def apply(): Action[A] = this \n\n  override def toString = { \n    \"Action(parser=\"+ parser + \")\" \n  } \n\n}\n```", "```java\ndef subscribe = Action { \n    request => \n        Ok(\"received \" + request.body) \n  } \n```", "```java\nPOST    /subscribe         controllers.AppController.subscribe \n```", "```java\ncurl 'http://localhost:9000/subscribe' -H 'Content-Type: text/plain;charset=UTF-8' --data-binary 'userId@gmail.com' \n```", "```java\nreceived AnyContentAsText(userId@gmail.com)\n```", "```java\nfinal def apply(block: R[AnyContent] => Result): Action[AnyContent] = apply(BodyParsers.parse.anyContent)(block) \n```", "```java\ndef anyContent: BodyParser[ AnyContent] = BodyParser(\"anyContent\") { request => \n      import play.api.libs.iteratee.Execution.Implicits.trampoline \n      request.contentType.map(_.toLowerCase(Locale.ENGLISH)) match { \n        case _ if request.method == HttpVerbs.GET || request.method == HttpVerbs.HEAD => { \n          Play.logger.trace(\"Parsing AnyContent as empty\") \n          empty(request).map(_.right.map(_ => AnyContentAsEmpty)) \n        } \n        case Some(\"text/plain\") => { \n          Play.logger.trace(\"Parsing AnyContent as text\") \n          text(request).map(_.right.map(s => AnyContentAsText(s))) \n        } \n        case Some(\"text/xml\") | Some(\"application/xml\") | Some(ApplicationXmlMatcher()) => { \n          Play.logger.trace(\"Parsing AnyContent as xml\") \n          xml(request).map(_.right.map(x => AnyContentAsXml(x))) \n         } \n        case Some(\"text/json\") | Some(\"application/json\") => { \n          Play.logger.trace(\"Parsing AnyContent as json\") \n          json(request).map(_.right.map(j => AnyContentAsJson(j))) \n        } \n        case Some(\"application/x-www-form-urlencoded\") => { \n          Play.logger.trace(\"Parsing AnyContent as urlFormEncoded\") \n          urlFormEncoded(request).map(_.right.map(d => AnyContentAsFormUrlEncoded(d))) \n        } \n        case Some(\"multipart/form-data\") => { \n          Play.logger.trace(\"Parsing AnyContent as multipartFormData\") \n          multipartFormData(request).map(_.right.map(m => AnyContentAsMultipartFormData(m))) \n        } \n        case _ => { \n          Play.logger.trace(\"Parsing AnyContent as raw\") \n          raw(request).map(_.right.map(r => AnyContentAsRaw(r))) \n           }\n      }\n     }\n```", "```java\ndef subscribe = Action {\n    request => \n      val reqBody: AnyContent = request.body \n      val textContent: Option[String] = reqBody.asText \n      textContent.map { \n        emailId => \n          Ok(\"added \" + emailId + \" to subscriber's list\") \n      }.getOrElse { \n        BadRequest(\"improper request body\")\n      } \n  } \n```", "```java\ndef subscribe = Action(parse.text) { \n    request => \n      Ok(\"added \" + request.body + \" to subscriber's list\") \n  } \n```", "```java\n{\"emailId\": \"userId@gmail.com\", \" interval\": \"month\"} \n```", "```java\n       request => \n      val reqData: JsValue = request.body \n      val emailId = (reqData \\ \"emailId\").as[String] \n      val interval = (reqData \\ \"interval\").as[String] \n      Ok(s\"added $emailId to subscriber's list and will send updates every $interval\") \n  } \n```", "```java\ncurl 'http://localhost:9000/subscribe' -H 'Content-Type: text/json' --data-binary '{\"emailId\": \"userId@gmail.com\", \"interval\": \"month\"}' \n```", "```java\nimport java.io.File \n\n  def createProfile = Action(parse.multipartFormData) {\n    request => \n      val formData = request.body.asFormUrlEncoded\n      val email: String = formData.get(\"email\").get(0)\n      val name: String = formData.get(\"name\").get(0)\n      val userId: Long = User(email, name).save\n      request.body.file(\"displayPic\").map {\n        picture => \n          val path = \"/socialize/user/\" \n          if (!picture.filename.isEmpty) {\n            picture.ref.moveTo(new File(path + userId + \".jpeg\"))\n          }\n          Ok(\"successfully added user\")\n      }.getOrElse {\n           BadRequest(\"failed to add user\")\n      }\n  }\n```", "```java\ncase class Subscription(emailId: String, interval: String) \n```", "```java\nval parseAsSubscription = parse.using {\n    request => \n      parse.json.map {\n        body => \n          val emailId:String = (body \\ \"emailId\").as[String] \n          val fromDate:Long = (body \\ \"fromDate\").as[Long] \n          Subscription(emailId, fromDate)\n      }\n  }\n\n  implicit val subWrites = Json.writes[Subscription]\n  def getSub = Action(parseAsSubscription) {\n    request => \n      val subscription: Subscription = request.body\n      Ok(Json.toJson(subscription))\n   } \n```", "```java\ndef subscribe = Action(parse.tolerantJson) {\n    request => \n      val reqData: JsValue = request.body\n      val emailId = (reqData \\ \"email\").as[String]\n      val interval = (reqData \\ \"interval\").as[String]\n  Ok(s\"added $emailId to subscriber's list and will send updates every $interval\") \n    } \n```", "```java\ndef plainResult = Action {\n  Result( \n    header = ResponseHeader(200, Map(CONTENT_TYPE -> \"text/plain\")), \n    body = Enumerator(\"This is the response from plainResult method\".getBytes())\n  )\n}\n```", "```java\nval TODO = Action {\n    NotImplemented[play.api.templates.Html](views.html.defaultpages.todo()) \n  } \n```", "```java\ndef getUserImage(userId: Long) = Action {\n    val path: String = s\"/socialize/user/$userId.jpeg\"\n    val img = new File(path)\n    if (img.exists()) {\n      Ok.sendFile( \n        content = img, \n        inline = true\n      )\n     }\n    else\n      NoContent\n  } \n```", "```java\ndef listArtist = Action { \n     Ok(views.html.home(Artist.fetch)) \n  }\n```", "```java\ndef save = Action(parse.text) { \n    request => \n      Status(200)(\"Got: \" + request.body) \n  } \n```", "```java\ntrait ActionBuilder[+R[_]] extends ActionFunction[Request, R] { \n  self => \n\n  final def apply[A](bodyParser: BodyParser[A])(block: R[A] => \n    Result): Action[A] = async(bodyParser) { req: R[A] => \n    Future.successful(block(req)) \n  } \n\n  final def async[A](bodyParser: BodyParser[A])(block: R[A] => Future[Result]): Action[A] = composeAction(new Action[A] { \n    def parser = composeParser(bodyParser) \n    def apply(request: Request[A]) = try { \n      invokeBlock(request, block) \n    } catch { \n      // NotImplementedError is not caught by NonFatal, wrap it \n      case e: NotImplementedError => throw new RuntimeException(e) \n      // LinkageError is similarly harmless in Play Framework, since automatic reloading could easily trigger it \n      case e: LinkageError => throw new RuntimeException(e) \n    } \n    override def executionContext = ActionBuilder.this.executionContext \n  }) \n\n... \n\n}  \n```", "```java\ndef getReport(fileName:String ) = Action.async { \n     Future { \n      val file:File = new File(fileName) \n      if (file.exists()) { \n        val info = file.lastModified() \n        Ok(s\"lastModified on ${new Date(info)}\") \n      } \n      else \n        NoContent \n    } \n  } \n```", "```java\ndef getReport(fileName: String) = Action.async { \n\n    val mayBeFile = Future { \n      new File(fileName) \n    } \n    val timeout = play.api.libs.concurrent.Promise.timeout(\"Past max time\", 10, TimeUnit.SECONDS) \n    Future.firstCompletedOf(Seq(mayBeFile, timeout)).map { \n      case f: File => \n        if (f.exists()) {\n          val info = f.lastModified()\n          Ok(s\"lastModified on ${new Date(info)}\")\n        } \n        else\n          NoContent\n      case t: String => InternalServerError(t)\n    }\n  }\n```", "```java\ntrait Rendering {\n\n   object render { \n\n    //Tries to render the most acceptable result according to the request's Accept header value. \n    def apply(f: PartialFunction[MediaRange, Result])(implicit request: RequestHeader): Result = { \n      def _render(ms: Seq[MediaRange]): Result = ms match {\n        case Nil => NotAcceptable \n        case Seq(m, ms @ _*) => \n          f.applyOrElse(m, (m: MediaRange) => _render(ms)) \n      } \n\n      // \"If no Accept header field is present, then it is assumed that the client accepts all media types.\" \n      val result = \n        if (request.acceptedTypes.isEmpty) _render(Seq(new MediaRange(\"*\", \"*\", Nil, None, Nil))) \n        else _render(request.acceptedTypes) \n      result.withHeaders(VARY -> ACCEPT) \n    } \n\n    /**Tries to render the most acceptable result according to the request's Accept header value. \n      * This function can be used if you want to do asynchronous processing in your render function. \n     */ \n    def async(f: PartialFunction[MediaRange, Future[Result]])(implicit request: RequestHeader): Future[Result] = { \n      def _render(ms: Seq[MediaRange]): Future[Result] = ms match { \n        case Nil => Future.successful(NotAcceptable) \n         case Seq(m, ms @ _*) => \n           f.applyOrElse(m, (m: MediaRange) => _render(ms)) \n      } \n\n      // \"If no Accept header field is present, then it is assumed that the client accepts all media types.\" \n      val result = \n        if (request.acceptedTypes.isEmpty) _render(Seq(new MediaRange(\"*\", \"*\", Nil, None, Nil))) \n        else _render(request.acceptedTypes) \n      result.map(_.withHeaders(VARY -> ACCEPT)) \n     } \n  } \n}\n```", "```java\ndef getConfig = Action {\n    implicit request => \n      val xmlResponse: Node = <metadata> \n        <company>TinySensors</company> \n        <batch>md2907</batch> \n      </metadata> \n\n      val jsonResponse = Json.obj(\"metadata\" -> Json.arr( \n        Json.obj(\"company\" -> \"TinySensors\"), \n         Json.obj(\"batch\" -> \"md2907\")) \n      ) \n      render { \n         case Accepts.Xml() => Ok(xmlResponse) \n        case Accepts.Json() => Ok(jsonResponse) \n      } \n  } \n```", "```java\ntrait RequestExtractors extends AcceptExtractors {\n\n  //Convenient extractor allowing to apply two extractors. \n  object & { \n    def unapply(request: RequestHeader): Option[(RequestHeader, RequestHeader)] = Some((request, request)) \n  } \n\n}\n\n//Define a set of extractors allowing to pattern match on the Accept HTTP header of a request \ntrait AcceptExtractors {\n\n  //Common extractors to check if a request accepts JSON, Html, etc. \n  object Accepts { \n    import play.api.http.MimeTypes \n    val Json = Accepting(MimeTypes.JSON) \n    val Html = Accepting(MimeTypes.HTML) \n    val Xml = Accepting(MimeTypes.XML) \n    val JavaScript = Accepting(MimeTypes.JAVASCRIPT) \n  } \n\n}\n\n//Convenient class to generate extractors checking if a given mime type matches the Accept header of a request. \ncase class Accepting(val mimeType: String) {\n  def unapply(request: RequestHeader): Boolean = request.accepts(mimeType) \n  def unapply(mediaRange: play.api.http.MediaRange): Boolean = mediaRange.accepts(mimeType) \n}\n```", "```java\nval AcceptsPNG = Accepting(\"image/png\") \n```", "```java\ndef fooBar = Action { \n    implicit request => \n      val xmlResponse: Node = <metadata> \n        <company>TinySensors</company> \n        <batch>md2907</batch> \n      </metadata> \n\n      val jsonResponse = Json.obj(\"metadata\" -> Json.arr( \n        Json.obj(\"company\" -> \"TinySensors\"), \n        Json.obj(\"batch\" -> \"md2907\")) \n      ) \n\n      render { \n        case Accepts.Xml() => Ok(xmlResponse) \n        case Accepts.Json() & Accepts.JavaScript() => Ok(jsonResponse) \n      }\n  }\n```", "```java\nimport org.joda.time.DateTime \nimport org.joda.time.format.DateTimeFormat\nimport play.api.mvc._\nimport play.api.http.HeaderNames._ \nimport play.api.libs.concurrent.Execution.Implicits.defaultContext \n\nobject HeadersFilter {\n  val noCache = Filter { \n    (nextFilter, rh) => \n      nextFilter(rh) map { \n        case result: Result => addNoCacheHeaders(result) \n      } \n  } \n\n  private def addNoCacheHeaders(result: Result): Result = { \n    result.withHeaders(PRAGMA -> \"no-cache\", \n      CACHE_CONTROL -> \"no-cache, no-store, must-revalidate, max-age=0\", \n      EXPIRES -> serverTime) \n  } \n\n  private def serverTime = { \n    val now = new DateTime() \n    val dateFormat = DateTimeFormat.forPattern( \n      \"EEE, dd MMM yyyy HH:mm:ss z\") \n    dateFormat.print(now) \n  } \n} \n```", "```java\n    object Global extends WithFilters(HeadersFilter.noCache) { \n      // ... \n    }\n    ```", "```java\n    object Global extends GlobalSettings {\n      override def doFilter(action: EssentialAction): EssentialAction = HeadersFilter.noCache(action) \n    }\n    ```", "```java\n    object Filter {\n      def apply(filter: (RequestHeader => Future[Result], RequestHeader) => Future[Result]): Filter = new Filter { \n        def apply(f: RequestHeader => Future[Result])(rh: RequestHeader): Future[Result] = filter(f, rh) \n      } \n    }\n    ```", "```java\n    object Filters {\n      def apply(h: EssentialAction, filters: EssentialFilter*) = h match { \n        case a: EssentialAction => FilterChain(a, filters.toList) \n        case h => h \n      } \n    }\n    ```", "```java\n    object FilterChain {\n      def apply[A](action: EssentialAction, filters: List[EssentialFilter]): EssentialAction = new EssentialAction { \n        def apply(rh: RequestHeader): Iteratee[Array[Byte], Result] = { \n          val chain = filters.reverse.foldLeft(action) { (a, i) => i(a) } \n          chain(rh) \n        } \n      } \n    }\n    ```", "```java\nobject Action extends ActionBuilder[Request] {\n  def invokeBlock[A](request: Request[A], block: (Request[A]) => Future[Result]) = block(request) \n}\n```", "```java\nimport play.api.mvc._\nimport scala.concurrent.Future\n\nobject TrackAction extends ActionBuilder[Request] {\n  override protected def invokeBlock[A](request: Request[A], block: (Request[A]) => Future[Result]) = { \n    persistReq(request) \n    block(request) \n  } \n\n  private def persistReq[A](request: Request[A]) = { \n    ...  \n  } \n} \n```", "```java\ndef viewAdminProfile(id: Long) = TrackAction {\n    request => \n      ... \n  } \n\ndef updateAdminProfile(id: Long) = TrackAction(parse.json) { \n    request => \n      ... \n  } \n```", "```java\ncase class TrackAction[A](action: Action[A]) extends Action[A] { \n\n  def apply(request: Request[A]): Future[Result] = { \n    persistReq(request) \n    action(request) \n  } \n\n  private def persistReq(request: Request[A]) = { \n    …  \n    } \n\n  lazy val parser = action.parser \n}\n```", "```java\ndef viewAdminProfile(id: Long) = TrackAction {\n    Action {request => \n        … \n  } \n} \n\ndef updateAdminProfile(id: Long) = TrackAction { \n    Action(parse.json) {\trequest => \n        … \n   } \n   } \n```", "```java\nobject TrackingAction extends ActionBuilder[Request] { \n  def invokeBlock[A](request: Request[A], block: (Request[A]) => Future[Result]) = { \n    block(request) \n  } \n  override def composeAction[A](action: Action[A]) = new TrackAction(action) \n}\n```", "```java\ndef viewAdminProfile(id: Long) = TrackingAction {\n    request => \n      ... \n  } \n\ndef updateAdminProfile(id: Long) = TrackingAction(parse.json) { \n    request => \n      ... \n    }\n```", "```java\nclass WrappedRequest[A](request: Request[A]) extends Request[A] { \n     def id = request.id \n    def tags = request.tags \n    def body = request.body \n    def headers = request.headers \n    def queryString = request.queryString \n    def path = request.path \n    def uri = request.uri \n    def method = request.method \n    def version = request.version \n    def remoteAddress = request.remoteAddress \n    def secure = request.secure \n   } \n```", "```java\nclass TimedRequest[A](val time: DateTime, request: Request[A]) extends WrappedRequest[A](request) \n```", "```java\ndef timedAction[A](action: Action[A]) = Action.async(action.parser) {\n  request => \n    val time = new DateTime()\n    val newRequest = new AppRequest(time, request)\n    action(newRequest)\n}\n```", "```java\ndef getUserList = timedAction {\n    Action {\n      request => \n        val users= User.getAll\n        Ok(Json.toJson(users))\n    }\n  }\n```", "```java\ndef timedAction[A](action: Action[A]) = Action.async(action.parser) {\n  request => \n    val time = new DateTime()\n    val newRequest = new AppRequest[A](time, request)\n    request.headers.get(USER_AGENT).collect {\n      case agent if isCompatibleBrowser(agent) => \n        action(newRequest)\n      }.getOrElse{\n     Future.successful(Ok(views.html.main()))\n  }\n}\n```", "```java\ndef timedAction[A](action: Action[A]) = Action.async(action.parser) { \n   request => \n    val time = new DateTime() \n    val newRequest = new AppRequest(time, request) \n    action(newRequest).map(_.withHeaders(\"processTime\" -> new DateTime().minus(time.getMillis).getMillis.toString())) \n}\n```", "```java\nclass UserRequest[A](val user: User, request: Request[A]) extends WrappedRequest[A](request) \n```", "```java\ndef UserAction(userId: Long) = new ActionBuilder[UserRequest] { \n  def invokeBlock[A](request: Request[A], block: (UserRequest[A]) => Future[Result]) = { \n      User.findById(userId).map { user:User => \n         block(new UserRequest(user, request)) \n      } getOrElse { \n        Future.successful(Redirect(views.html.login)) \n      } \n    } \n  } \n```", "```java\ndef initiateChat(userId:Long,chatWith:Long) = UserRequest{ \n    request=> \n      val status:Boolean = ChatClient.initiate(request.user,chatWith) \n       if(status){ \n        Ok \n      }else{ \n         Unauthorized \n      } \n  } \n```", "```java\n    trait Controller extends Results with BodyParsers with HttpProtocol with Status with HeaderNames with ContentTypes with RequestExtractors with Rendering { \n\n      //Provides an empty `Action` implementation: the result is a standard 'Not implemented yet' result page. \n      val TODO = Action { \n         NotImplemented[play.api.templates.Html](views.html.defaultpages.todo()) \n      } \n\n      //Retrieves the session implicitly from the request. \n      implicit def session(implicit request: RequestHeader) = request.session \n\n      //Retrieve the flash scope implicitly from the request. \n      implicit def flash(implicit request: RequestHeader) = request.flash \n\n      implicit def lang(implicit request: RequestHeader) = { \n        play.api.Play.maybeApplication.map { implicit app => \n          val maybeLangFromCookie = request.cookies.get(Play.langCookieName).flatMap(c => Lang.get(c.value)) \n            maybeLangFromCookie.getOrElse(play.api.i18n.Lang.preferred(request.acceptLanguages)) \n        }.getOrElse(request.acceptLanguages.headOption.getOrElse(play.api.i18n.Lang.defaultLang)) \n      } \n    }\n    ```", "```java\n    def foo = Action {\n        implicit request => \n        … \n    }\n    ```", "```java\n    JsResultException(errors:List((,List(ValidationError(error.expected.jsstring,WrappedArray())))))] \n    ```", "```java\n    val emailId = (body\\\"emailId\"). asOpt[String]\n    ```"]