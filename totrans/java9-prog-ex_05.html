<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Extending the Game - Run Parallel, Run Faster</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we will extend the Mastermind game. As it is now, it can guess the secret that was hidden and also hide the pegs. The test code can even do both at the same time. It can play against itself leaving us only with the fun of programming. What it cannot do is make use of all the processors that we have in today's notebooks and servers. The code runs synchronous and utilizes only a single processor core.</p>
<p class="calibre2">We will alter the code extending the guessing algorithm to slice up the guessing into subtasks and execute the code in parallel. During this, we will get acquainted with Java concurrent programming. This will be a huge topic with many subtle corners and caveats lurking in the dark. We will get into those details that are the most important and will form a firm base for further studies whenever you need concurrent programs.</p>
<p class="calibre2">As the outcome of the game is the same as it was, only faster, we have to assess what faster is. To do that, we will utilize a new feature introduced in Java 9: microbenchmarking harness.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre14">
<li class="calibre15">The meaning of processes, threads and fibers</li>
<li class="calibre15">Multithreading in Java</li>
<li class="calibre15">Issues with multithread programming and how to avoid them</li>
<li class="calibre15">Locking, synchronization, and blocking queues</li>
<li class="calibre15">Microbenchmarking</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to make Mastermind parallel</h1>
            

            <article>
                
<p class="calibre2">The old algorithm was to go through all the variations and try to find a guess that matches the current state of the table. Assuming that the currently examined guess is the secret, will we get the same answers for the guesses that are already on the table as the answers are actually on the table? If yes, then the current guess can be the secret, and it is just as good a guess as any other guesses.</p>
<p class="calibre2">A more complex approach can implement the min-max algorithm (<a href="https://en.wikipedia.org/wiki/Minimax" class="calibre6"><span>https://en.wikipedia.org/wiki/Minimax</span></a>). This algorithm does not simply get the next possible guess but also looks at all the possible guesses and selects the one that shortens the outcome of the game the most. If there is a guess that can be followed by three more guesses in the worst case, and there is another for which this number is only two, then min-max will choose the latter. It is a good exercise for the interested readers. In the case of the six colors and four columns for the pegs, the min-max algorithm solves the game in no more than 5 steps. The simple algorithm we implemented also solves the game in 5 steps. However, we do not go in that direction.</p>
<p class="calibre2">Instead, we want to have a version of the game that utilizes more than one processor. How can youÂ transform the algorithm into a parallel one? There is no simple answer to this. When you have an algorithm, you can analyze the calculations and parts of the algorithm, and you can try to find dependencies. If there is some calculation <em class="calibre12">B</em> that needs the data, which is the result of another calculation <em class="calibre12">A</em>, then it is obvious that <em class="calibre12">A</em> can only be performed when <em class="calibre12">B</em> is ready. If there are parts of the algorithm that do not depend on the outcome of the others, then they can be executed in parallel.</p>
<p class="calibre2">For example, the quick-sort has two major tasks: partitioning and then sorting of the two parts. It is fairly obvious that the partitioning has to finish before we start sorting the two partitioned parts. However, the sorting tasks of the two parts do not depend on each other, they can be done independently. You can give them to two different processors. One will be happy sorting the part containing the smaller elements; the other one will carry the heavier, larger ones.</p>
<p class="calibre2">If you turn the pages back to <a href="part0076.html" class="calibre6"><span>Chapter 3</span></a>, <em class="calibre12">Optimizing the Sort - Making Code Professional</em> where we implemented quick-sort in a non-recursive way, you can see that we scheduled sorting tasks into a stack and then performed the sorting by fetching the elements from the stack in a <kbd class="calibre11">while</kbd> loop. Instead of executing the sort right there in the core of the loop, we could pass the task to an asynchronous thread to perform it and go back for the next waiting task. We just do not know how. Yet. That is why we are here in this chapter.</p>
<p class="calibre2">Processors, threads, and processes are complex and abstract things and they are hard to imagine. Different programmers have different techniques to imagine parallel processing and algorithms. I can tell you how I do it but it is not a guarantee that this will work for you. Others may have different techniques in their mind. As a matter of fact, I just realized that as I write this, I have actually never told this to anyone before. It may seem childish, but anyway, here it goes.</p>
<p class="calibre2">When I imagine algorithms, I imagine people. One processor is one person. This helps me overcome the freaking fact that a processor can make billions of calculations in a second. I actually imagine a bureaucrat wearing a brown suit and doing the calculations. When I create a code for a parallel algorithm, I imagine many of them working behind their desks. They work alone and they do not talk. It is important that they do not talk to each other. They are very formal. When there is a need for information exchange, they stand up with a piece of paper they have written something on, and they bring it to each other. Sometimes, they need a piece of paper for their work. Then they stand up, go to the place where the paper is, take it, bring it back to their desk, and go on working. When they are ready, they go back and bring the paper back. If the paper is not there when they need it, they queue up and wait until someone who has the paper brings it there.</p>
<p class="calibre2">How does it help with Mastermind?</p>
<p class="calibre2">I imagine a boss who is responsible for the guesses. There is a table on the wall in the office with the previous guesses and the results for each row. The boss is too lazy to come up with new guesses so he gives this task to subordinates. When a subordinate comes up with a guess, the boss checks whether the guess is valid or not. He does not trust the subordinates, and if the guess is good, he makes it as an official guess, putting it on the table along with the result.</p>
<p class="calibre2">The subordinates deliver the guesses written on small post-it notes, and they put them in a box on the table of the boss. The boss looks at the box from time to time, and if there is a note, the boss takes it. If the box is full and a subordinate wants to put a paper there, the subordinate stops and waits until the boss takes at least one note so that there is some room in the box for a new note. If the subordinates queue up to deposit guesses in the box, they all wait for their time.</p>
<p class="calibre2">The subordinates should be coordinated; otherwise, they will just come up with the same guesses. Each of them should have an interval of guesses. For example, the first one should check the guesses from 1234 up until 2134, the second should check from 2134 up until 3124, and so on, if we denote the colors with numbers.</p>
<p class="calibre2">Will this structure work? Common sense says that it will. However, bureaucrats, in this case, are metaphors and metaphors are not exact. Bureaucrats are human, even when they do not seem like it much more than threads or processors. They sometimes behave extremely strangely, doing things that normal humans don't really do often. However, we can still use this metaphor if it helps us imagine how parallel algorithms work.</p>
<p class="calibre2">We can imagine that the boss goes on holiday and does not touch the heap of paper piling up on the table. We can imagine that some of the workers are producing results much faster than the others. As this is only imagination, the speedup can be 1000 times (think of a time-lapse video). Imagining these situations may help us discover special behavior that rarely happens, but may cause problems. As the threads work in parallel, many times subtle differences may influence the general behavior greatly.</p>
<p class="calibre2">In some early version, as I coded the parallel Mastermind algorithm, the bureaucrats started working and filled the box of the boss with guesses before the boss could put any of them on the table. As there were no guesses on the table, the bureaucrats simply found all possible variations in their interval being a possibly good guess. The boss gained nothing by the help of the parallel helpers; they had to select the correct ones from all possible guesses, while the guessers were just idle.</p>
<p class="calibre2">Another time, the bureaucrats were checking guesses against the table while the boss was putting a guess on one of them created beforehand. And some of the bureaucrats freaked out saying that it is not possible to check a guess against a table if someone is changing it. More precisely, the code executing in one thread, threw <kbd class="calibre11">ConcurrentModificationException</kbd> when the <kbd class="calibre11">List</kbd> of the table was modified.</p>
<p class="calibre2">Another time, I tried to avoid the too fast work of bureaucrats, and I limited the size of the box where they could put their papers containing the guesses. When the boss finally found the secret, and the game finished, the boss told the bureaucrats that they could go home. The boss did that by creating a small paper with the instruction: you can go home, and put it on the tables of the bureaucrats. What did the bureaucrats do? Kept waiting for the box to have space for the paper! (Until the process was killed. This is kind of equivalent on Mac OS and on Linux as ending the process from the task manager on Windows.)</p>
<p class="calibre2">Such coding errors happen and, to avoid as many as possible, we have to do at least two things. Firstly, we have to understand how Java multithreading works and secondly, have a code as clean as possible. For the second, we will clean up the code even more and then we will look at how the parallel algorithm described earlier can be implemented in Java, running on the JVM instead of utilizing bureaucrats.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Refactoring</h1>
            

            <article>
                
<p class="calibre2">When we finished the previous chapter, we had the classes of the Mastermind game designed and coded in a nice and perfectly object oriented way that did not break any of the <em class="calibre12">OO</em> principles. Did we? Absurd. There is no code, except some trivial examples, that cannot be made to look nicer or better. Usually, when we develop code and finish the coding, it looks great. It works, the tests all run, and documentation is ready. From the professional point of view, it really is perfect. Well, it is good enough. The big question that we have not tested yet is maintainability. What is the cost to alter the code?</p>
<p class="calibre2">That is not an easy question, especially because it is not a definite one. Alter to what? What is the modification that is to be made to the code? We do not know that when we create the code in the first place. If the modification is to fix a bug, then it is obvious that we did not know that beforehand. If we knew, we would not have introduced the bug in the first place. If this is a new feature, then there is a possibility that the function was foreseen. However, usually it is not the case. When a developer tries to predict the future, and what features the program will need in the future, theyÂ usually fail. It is the task of the customer to know the business. Features needed are driven by the business in case of professional software development. After all, that is what it means to be professional.</p>
<p class="calibre2">Even though we do not exactly know what needs to be altered later in the code, there are certain things that may give hints to experienced software developers. Usually, the OO code is easier to maintain than the ad-hoc code, and there are code smells that one can spot. For example, take a look at the following code lines:</p>
<pre class="calibre20">
while (guesser.guess() != Row.none) { <br class="title-page-name"/>    while (guesser.nextGuess() != Guesser.none) { <br class="title-page-name"/>        public void addNewGuess(Row row) { <br class="title-page-name"/>            Color[] guess = super.nextGuess();
</pre>
<p class="calibre2">We may sense the odor of something strange. (Each of these lines is in the code of the application as we finished it in <a href="part0111.html" class="calibre6"><span>Chapter 4</span></a>, <em class="calibre12">Mastermind - Creating a Game</em>.) The return value of the <kbd class="calibre11">guess</kbd> method is compared to <kbd class="calibre11">Row.none</kbd>, which is a <kbd class="calibre11">Row</kbd>. Then, we compare the return value of <kbd class="calibre11">nextGuess</kbd> to <kbd class="calibre11">Guesser.none</kbd>, which should be a <kbd class="calibre11">Guesser</kbd>. When we add a new guess to something, we actually add a <kbd class="calibre11">Row</kbd>. Finally, we can realize that <kbd class="calibre11">nextGuess</kbd> returns a guess that is not an object with its own declared class. A <kbd class="calibre11">guess</kbd> is just an array of colors.</p>
<p class="calibre2">Should we introduce another layer of abstraction creating a <kbd class="calibre11">Guess</kbd> class? Will it make the code more maintainable? Or will it only make the code more complex? It is usually true that the less code lines we have, the less possibility we have for bugs. However, sometimes, the lack of abstraction will make the code complex and tangled. What is the case in this situation? How can we decide that generally?</p>
<p class="calibre2">The more experience you have, the easier you will tell by looking at the code and acutely knowing what modifications you want to make. Many times, you will not bother making the code more abstract, and many other times, you will create new classes without hesitation. When in doubt, do create the new classes and see what comes out. The important thing is not to ruin the already existing functionality. You can do that only if you have sufficient unit tests.</p>
<p class="calibre2">When you want to introduce some new functionality or fix a bug, but the code is not appropriate, you will have to modify it first. When you modify the code so that the functionality does not change, the process is named <strong class="calibre1">refactoring</strong>. You change a small part of the code in a limited time, and then you build it. If it compiles and all unit tests run, then you can go on. The hint is to run the build frequently. It is like building a new road near an existing one. Once in every few miles, you should meet the old line. Failing to do so, you will end up somewhere in the middle of the desert in a totally wrong direction, and all you can do is return to the starting pointâyour old to-be-refactored code. Effort wasted.</p>
<p class="calibre2">It is not only the safety that advises us to run the build frequently, it is also time limitation. Refactoring does not directly deliver revenue. The functionality of the program is tied directly to income. Nobody will pay us for infinite refactoring work. Refactoring has to stop some time and it is usually not the time when there is nothing to be refactored any more. The code will never be perfect, but you may stop when it is good enough. And, many times, programmers are never satisfied with the quality of the code, and when they are stopped by some external factor (usually called project manager), the code should compile and tests should run so that the new feature and bug fixing can be performed on the actual code base.</p>
<p class="calibre2">Refactoring is a huge topic and there are many techniques that can be followed during such an activity. It is so complex that there is a whole book about it by Martin Fowler (<a href="http://martinfowler.com/books/refactoring.html" class="calibre6"><span>http://martinfowler.com/books/refactoring.html</span></a>).</p>
<p class="calibre2">In our case, the modification we want to apply to our code is to implement a parallel algorithm. The first thing we will modify is the <kbd class="calibre11">ColorManager</kbd>. When we wanted to print guesses and rows on the terminal, we had to implement some bad tricks. Why not have color implementations that can be printed? We can have a class that extends the original <kbd class="calibre11">Color</kbd> class and has a method that returns something that represents that color. Do you have any candidate name for that method? It is the <kbd class="calibre11">toString</kbd> method. It is implemented in the <kbd class="calibre11">Object</kbd> class and any class can freely override it. When you concatenate an object to a string, automatic type conversion will call this method to convert the object to <kbd class="calibre11">String</kbd>. By the way, it is an old trick to use <kbd class="calibre11">""+object</kbd> instead of <kbd class="calibre11">object.toString()</kbd> to avoid <kbd class="calibre11">null</kbd> pointer exception. Needless to say, we do not use tricks. The <kbd class="calibre11">toString</kbd> method is also invoked by the IDEs when the debugger wants to display the value of some object, so it is generally recommended to implement <kbd class="calibre11">toString</kbd> if for nothing else, then to ease development. If we have a <kbd class="calibre11">Color</kbd> class that implements <kbd class="calibre11">toString</kbd>, then the <kbd class="calibre11">PrettyPrintRow</kbd> class becomes fairly straightforward and tricks less:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> public class PrettyPrintRow { <br class="title-page-name"/>  <br class="title-page-name"/>     public static String pprint(Row row) { <br class="title-page-name"/>         String string = ""; <br class="title-page-name"/>         PrintableRow pRow = new PrintableRow(row); <br class="title-page-name"/>         for (int i = 0; i &lt; pRow.nrOfColumns(); i++) { <br class="title-page-name"/>             string += pRow.pos(i); <br class="title-page-name"/>         } <br class="title-page-name"/>         string += " "; <br class="title-page-name"/>         string += pRow.full(); <br class="title-page-name"/>         string += "/"; <br class="title-page-name"/>         string += pRow.partial(); <br class="title-page-name"/>         return string; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<div class="packttip">We removed the problem from the printing class, but you may argue that the issue is still there, and you are right. Many times, when there is a problem in a class design, the way to the solution to move the problem from the class to another. If it is still a problem there, then you may split the design more and more and, at the last stage, you will realize that what you have is an issue and not a problem.</div>
<p class="calibre2">To implement a <kbd class="calibre11">LetteredColor</kbd> class is also straightforward:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind.lettered; <br class="title-page-name"/>  <br class="title-page-name"/> import packt.java9.by.example.mastermind.Color; <br class="title-page-name"/>  <br class="title-page-name"/> public class LetteredColor extends Color { <br class="title-page-name"/>  <br class="title-page-name"/>     private final String letter; <br class="title-page-name"/>     public LetteredColor(String letter){ <br class="title-page-name"/>         this.letter = letter; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public String toString(){ <br class="title-page-name"/>         return letter; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">Again, the problem was pushed forward. But, in reality, this is not a problem. It is an OO design. Printing is not responsible for assigning <kbd class="calibre11">String</kbd> to colors for their representation. And the color implementation itself is also not responsible for that. The assignment has to be performed where the color is made, and then the <kbd class="calibre11">String</kbd> has to be passed to the constructor of the <kbd class="calibre11">LetteredColor</kbd> class. The <kbd class="calibre11">color</kbd> instances are created in <kbd class="calibre11">ColorManager</kbd> so we have to implement this in the <kbd class="calibre11">ColorManager</kbd> class. Or not? What does <kbd class="calibre11">ColorManager</kbd> do? It creates the colors and...</p>
<p class="calibre2">When you come to an explanation or description of a class that lists the functionalities, you may immediately see that the <strong class="calibre1">single responsibility principle</strong> was ignored. <kbd class="calibre11">ColorManager</kbd> should manage the colors. Managing is providing a way to get the colors in a definite order and getting the first and the next when we know one color. We should implement the other responsibilityâthe creation of a color in a separate class.</p>
<p class="calibre2">A class that has the sole functionality to create an instance of another class is called factory. That is almost the same as using the <kbd class="calibre11">new</kbd> operator but unlike <kbd class="calibre11">new</kbd>, the factories can be used more flexibly. We will see that immediately. The <kbd class="calibre11">ColorFactory</kbd> interface contains a single method, as follows:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> public interface ColorFactory { <br class="title-page-name"/>     Color newColor(); <br class="title-page-name"/> }
</pre>
<p class="calibre2">Interfaces that define only one method are named functional interfaces because their implementation can be provided as a lambda expression at the place where you would use an object that is an instance of a class which implements the functional interface. The <kbd class="calibre11">SimpleColorFactory</kbd> implementation creates the following <kbd class="calibre11">Color</kbd> objects:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> public class SimpleColorFactory implements ColorFactory { <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public Color newColor() { <br class="title-page-name"/>         return new Color(); <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">It is very much like how we create an interface, and then an implementation, instead of just writing <kbd class="calibre11">new Color()</kbd> in the code in <kbd class="calibre11">ColorManager</kbd>. <kbd class="calibre11">LetteredColorFactory</kbd> is a bit more interesting:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind.lettered; <br class="title-page-name"/>  <br class="title-page-name"/> import packt.java9.by.example.mastermind.Color; <br class="title-page-name"/> import packt.java9.by.example.mastermind.ColorFactory; <br class="title-page-name"/>  <br class="title-page-name"/> public class LetteredColorFactory implements ColorFactory { <br class="title-page-name"/>  <br class="title-page-name"/>     private final String letters = "0123456789ABCDEFGHIJKLMNOPQRSTVWXYZabcdefghijklmnopqrstvwxzy"; <br class="title-page-name"/>     private int counter = 0; <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public Color newColor() { <br class="title-page-name"/>         Color color = new LetteredColor(letters.substring(counter, counter + 1)); <br class="title-page-name"/>         counter++; <br class="title-page-name"/>         return color; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">Now, here we have the functionality that assigns <kbd class="calibre11">String</kbd>s to the <kbd class="calibre11">Color</kbd> objects when they are created. It is very important that the <kbd class="calibre11">counter</kbd> variable that keeps track of the already created colors is not <kbd class="calibre11">static</kbd>. The similar variable in the previous chapter was <kbd class="calibre11">static</kbd> and it meant that it could run out of characters as ever-newer <kbd class="calibre11">ColorManager</kbd>s created too many colors. It actually did happen to me during the unit test execution when the tests each created <kbd class="calibre11">ColorManager</kbd>s and new <kbd class="calibre11">Color</kbd> instances, and the printing code tried to assign new letters to the new colors. The tests were running in the same JVM under the same classloader and the unfortunate <kbd class="calibre11">static</kbd> variable had no clue when it could just start counting from zero for the new tests. The drawback is that somebody, somewhere, has to instantiate the factory and it is not the <kbd class="calibre11">ColorManager</kbd>. <kbd class="calibre11">ColorManager</kbd> already has a responsibility and it is not to create a color factory. The <kbd class="calibre11">ColorManager</kbd> has to get the <kbd class="calibre11">ColorFactory</kbd> in its constructor:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> import java.util.HashMap; <br class="title-page-name"/> import java.util.List; <br class="title-page-name"/> import java.util.Map; <br class="title-page-name"/>  <br class="title-page-name"/> public class ColorManager { <br class="title-page-name"/>     final protected int nrColors; <br class="title-page-name"/>     final protected Map&lt;Color, Color&gt; successor = new HashMap&lt;&gt;(); <br class="title-page-name"/>     private Color first; <br class="title-page-name"/>     private final ColorFactory factory; <br class="title-page-name"/>  <br class="title-page-name"/>     public ColorManager(int nrColors, ColorFactory factory) { <br class="title-page-name"/>         this.nrColors = nrColors; <br class="title-page-name"/>         this.factory = factory; <br class="title-page-name"/>         createOrdering(); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     private Color[] createColors() { <br class="title-page-name"/>         Color[] colors = new Color[nrColors]; <br class="title-page-name"/>         for (int i = 0; i &lt; colors.length; i++) { <br class="title-page-name"/>             colors[i] = factory.newColor(); <br class="title-page-name"/>         } <br class="title-page-name"/>         return colors; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     private void createOrdering() { <br class="title-page-name"/>         Color[] colors = createColors(); <br class="title-page-name"/>         first = colors[0]; <br class="title-page-name"/>         for (int i = 0; i &lt; nrColors - 1; i++) { <br class="title-page-name"/>             successor.put(colors[i], colors[i + 1]); <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public Color firstColor() { <br class="title-page-name"/>         return first; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public boolean thereIsNextColor(Color color) { <br class="title-page-name"/>         return successor.containsKey(color); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public Color nextColor(Color color) { <br class="title-page-name"/>         return successor.get(color); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public int getNrColors() { <br class="title-page-name"/>         return nrColors; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<div class="packtinfobox">You may also notice that I could not resist refactoring the <kbd class="calibre22">createColors</kbd> method into two methods to follow the single responsibility principle.</div>
<p class="calibre2">Now, the code that creates <kbd class="calibre11">ColorManager</kbd> has to create a factory and pass it to the constructor. For example, the unit test's <kbd class="calibre11">ColorManagerTest</kbd> class will contain the following method:</p>
<pre class="calibre20">
@Test<br class="title-page-name"/> public void thereIsAFirstColor() { <br class="title-page-name"/>     ColorManager manager  <br class="title-page-name"/>          = new ColorManager(NR_COLORS, Color::new); <br class="title-page-name"/>     Assert.assertNotNull(manager.firstColor()); <br class="title-page-name"/> }
</pre>
<p class="calibre2">This is the simplest way ever to implement a factory defined by a functional interface. Just name the class and reference the <kbd class="calibre11">new</kbd> operator like it was a method by creating a method reference.</p>
<p class="calibre2">The next thing we will refactor is the <kbd class="calibre11">Guess</kbd> class, which, actually, we did not have so far. A <kbd class="calibre11">Guess</kbd> class contains the pegs of the guess and can calculate the number of full (color as well as position) and partial (color present but in wrong position) matches, and can also calculate the next <kbd class="calibre11">Guess</kbd> that comes after this guess. This functionality was implemented in the <kbd class="calibre11">Guesser</kbd> class so far, but this is not really the functionality for how we select the guesses when checking the already made guesses on the table. If we follow the pattern we set up for the colors, we may implement this functionality in a separate class named <kbd class="calibre11">GuessManager</kbd>, but as for now, it is not needed. Again, this is not black and white.</p>
<p class="calibre2">It is important to note that a <kbd class="calibre11">Guess</kbd>Â object can only be made at once. If it is on the table, the player is not allowed to change it. If we have a <kbd class="calibre11">Guess</kbd> that is not yet on the table, it is still just a <kbd class="calibre11">Guess</kbd> identified by the colors and orders of the pegs. A <kbd class="calibre11">Guess</kbd> object never changes after it was created. Such objects are easy to use in multithread programs and are called immutable objects:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> import java.util.Arrays; <br class="title-page-name"/> import java.util.HashSet; <br class="title-page-name"/> import java.util.Set; <br class="title-page-name"/>  <br class="title-page-name"/> public class Guess { <br class="title-page-name"/>     final static public Guess none = new Guess(new Color[0]); <br class="title-page-name"/>     final private Color[] colors; <br class="title-page-name"/>     private boolean uniquenessWasNotCalculated = true; <br class="title-page-name"/>     private boolean unique; <br class="title-page-name"/>  <br class="title-page-name"/>     public Guess(Color[] colors) { <br class="title-page-name"/>         this.colors = Arrays.copyOf(colors, colors.length); <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The constructor is creating a copy of the array of colors that were passed. As a <kbd class="calibre11">Guess</kbd> is immutable, this is extremely important. If we just keep the original array, any code outside of the <kbd class="calibre11">Guess</kbd> class could alter the elements of the array, essentially changing the content of <kbd class="calibre11">Guess</kbd> that is not supposed to be changing:</p>
<pre class="calibre20">
public Color getColor(int i) { <br class="title-page-name"/>         return colors[i]; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public int nrOfColumns() { <br class="title-page-name"/>         return colors.length; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     /** <br class="title-page-name"/>      * Calculate the next guess and return a new Guess object. <br class="title-page-name"/>      * The guesses are ordered in the order of the colors as <br class="title-page-name"/>      * specified by the color manager. <br class="title-page-name"/>      * <br class="title-page-name"/>      * @param manager that specifies the order of the colors <br class="title-page-name"/>      *                can return the next color after one color. <br class="title-page-name"/>      * @return the guess that comes after this guess. <br class="title-page-name"/>      */ <br class="title-page-name"/>     public Guess nextGuess(ColorManager manager) { <br class="title-page-name"/>         final Color[] colors = Arrays.copyOf( <br class="title-page-name"/>                                     this.colors, nrOfColumns()); <br class="title-page-name"/>  <br class="title-page-name"/>         int i = 0; <br class="title-page-name"/>         boolean guessFound = false; <br class="title-page-name"/>         while (i &lt; colors.length &amp;&amp; !guessFound) { <br class="title-page-name"/>             if (manager.thereIsNextColor(getColor(i))) { <br class="title-page-name"/>                 colors[i] = manager.nextColor(colors[i]); <br class="title-page-name"/>                 guessFound = true; <br class="title-page-name"/>             } else { <br class="title-page-name"/>                 colors[i] = manager.firstColor(); <br class="title-page-name"/>                 i++; <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>         if (guessFound) { <br class="title-page-name"/>             return new Guess(colors); <br class="title-page-name"/>         } else { <br class="title-page-name"/>             return Guess.none; <br class="title-page-name"/>         } <br class="title-page-name"/>     }
</pre>
<p class="calibre2">In this method, we start to calculate the next <kbd class="calibre11">Guess</kbd> starting with the color array that is contained in the actual object. We need a work array that is modified, so we will copy the original. The final new object can, this time, use the array we use during the calculation, so that will need a separate constructor that does not create a copy. It is possible extra code, but we should consider making that only if we see that that is the bottleneck in the code and we are not satisfied with the actual performance.</p>
<p class="calibre2">The next method just checks if the passed <kbd class="calibre11">Guess</kbd> has the same number of colors as the actual one. This is just a safety check used by the next two methods that calculate the matches:</p>
<pre class="calibre20">
private void assertCompatibility(Guess guess) { <br class="title-page-name"/>         if (nrOfColumns() != guess.nrOfColumns()) { <br class="title-page-name"/>             throw new IllegalArgumentException("Cannot compare different length guesses"); <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     /** <br class="title-page-name"/>      * Count the number of colors that are present on the guess <br class="title-page-name"/>      * but not on the pos where they are in the other guess. <br class="title-page-name"/>      * If the same color is on multiple pos it is counted <br class="title-page-name"/>      * for each pos once. For example the secret is <br class="title-page-name"/>      * &lt;pre&gt; <br class="title-page-name"/>      *     RGRB <br class="title-page-name"/>      * &lt;/pre&gt; <br class="title-page-name"/>      * and the guess is <br class="title-page-name"/>      * &lt;pre&gt; <br class="title-page-name"/>      *     YRPR <br class="title-page-name"/>      * &lt;/pre&gt; <br class="title-page-name"/>      * then this method will return 2. <br class="title-page-name"/>      * <br class="title-page-name"/>      * @param guess is the actual guess that we evaluate <br class="title-page-name"/>      * @return the number of good colors not in pos <br class="title-page-name"/>      */ <br class="title-page-name"/>     public int nrOfPartialMatches(Guess guess) { <br class="title-page-name"/>         assertCompatibility(guess); <br class="title-page-name"/>         int count = 0; <br class="title-page-name"/>         for (int i = 0; i &lt; nrOfColumns(); i++) { <br class="title-page-name"/>             for (int j = 0; j &lt; nrOfColumns(); j++) { <br class="title-page-name"/>                 if (i != j &amp;&amp; <br class="title-page-name"/>                         guess.getColor(i) == this.getColor(j)) { <br class="title-page-name"/>                     count++; <br class="title-page-name"/>                 } <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>         return count; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     /** <br class="title-page-name"/>      * Count the number of colors that are correct and are in pos. <br class="title-page-name"/>      * <br class="title-page-name"/>      * @param guess is the actual guess that we evaluate <br class="title-page-name"/>      * @return the number of colors that match in pos <br class="title-page-name"/>      */ <br class="title-page-name"/>     public int nrOfFullMatches(Guess guess) { <br class="title-page-name"/>         assertCompatibility(guess); <br class="title-page-name"/>         int count = 0; <br class="title-page-name"/>         for (int i = 0; i &lt; nrOfColumns(); i++) { <br class="title-page-name"/>             if (guess.getColor(i) == this.getColor(i)) { <br class="title-page-name"/>                 count++; <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>         return count; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The <kbd class="calibre11">isUnique</kbd> method checks if there is any color more than once in the <kbd class="calibre11">Guess</kbd>. As the <kbd class="calibre11">Guess</kbd> is immutable, it may not happen that a <kbd class="calibre11">Guess</kbd> is unique one time and not unique at another time. This method should return the same result whenever it is called on a specific object. Because of that, it is possible to cache the result. This method does this, saving the return value to an instance variable.</p>
<p class="calibre2">You may say that this is premature optimization. Yes, it is. I decided to do it for one reason. It is demonstration, and based on that, you can try to modify the <kbd class="calibre11">nextGuess</kbd> method to do the same:</p>
<pre class="calibre20">
     /** <br class="title-page-name"/>      * @return true if the guess does not <br class="title-page-name"/>      *         contain any color more than once <br class="title-page-name"/>      */ <br class="title-page-name"/>     public boolean isUnique() { <br class="title-page-name"/>         if (uniquenessWasNotCalculated) { <br class="title-page-name"/>             final Set&lt;Color&gt; alreadyPresent = new HashSet&lt;&gt;(); <br class="title-page-name"/>             unique = true; <br class="title-page-name"/>             for (Color color : colors) { <br class="title-page-name"/>                 if (alreadyPresent.contains(color)) { <br class="title-page-name"/>                     unique = false; <br class="title-page-name"/>                     break; <br class="title-page-name"/>                 } <br class="title-page-name"/>                 alreadyPresent.add(color); <br class="title-page-name"/>             } <br class="title-page-name"/>             uniquenessWasNotCalculated = false; <br class="title-page-name"/>         } <br class="title-page-name"/>         return unique; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">Methods that return the same result for the same arguments are called idempotent. Caching the return value for such a method can be very important if the method is called many times and the calculation is using a lot of resources. When the method has arguments, the result caching is not simple. The object method has to remember the result for all arguments that were already calculated, and this storage has to be effective. If it takes more resources to find the stored result than the calculation of it, then the use of cache not only uses more memory but also slows down the program. If the method is called for several arguments during the lifetime of the object, then the storage memory may just grow too large. Some of the elements have to be purgedâthose that will not be needed anymore in the future. However, we cannot know which elements of the cache are not needed, so we will have to guess.</p>
<p class="calibre2">As you can see, caching can get complex very fast and, to do that professionally, it is almost always better to use some readily available cache implementation. The caching we use here is only the tip of the iceberg. Or, it is even only the sunshine glimpsing on it.</p>
<p class="calibre2">The rest of the class is fairly standard and something we have talked about in detailâa good check of your knowledge is to understand how the <kbd class="calibre11">equals</kbd>, <kbd class="calibre11">hashCode</kbd>, and <kbd class="calibre11">toString</kbd> methods are implemented this way. I implemented the <kbd class="calibre11">toString</kbd> method to help me during debugging, but it is also used in the following example output:</p>
<pre class="calibre20">
     @Override <br class="title-page-name"/>     public boolean equals(Object other) { <br class="title-page-name"/>         if (this == other) return true; <br class="title-page-name"/>         if (other == null || !(other instanceof Guess)) <br class="title-page-name"/>                                               return false; <br class="title-page-name"/>         Guess guess = (Guess) other; <br class="title-page-name"/>         return Arrays.equals(colors, guess.colors); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public int hashCode() { <br class="title-page-name"/>         return Arrays.hashCode(colors); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public String toString() { <br class="title-page-name"/>         if (this == none) { <br class="title-page-name"/>             return "none"; <br class="title-page-name"/>         } else { <br class="title-page-name"/>             String s = ""; <br class="title-page-name"/>             for (int i = colors.length - 1; i &gt;= 0; i--) { <br class="title-page-name"/>                 s += colors[i]; <br class="title-page-name"/>             } <br class="title-page-name"/>             return s; <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">This is mainly the modification that I needed while I developed the parallel algorithm. Now, the code is fairly up-to-date and described to focus on the main topic of this chapter: how to execute code in Java in parallel.</p>
<p class="calibre2">The parallel execution of the code in Java is done in threads. You may know that there is a <kbd class="calibre11">Thread</kbd> object in Java runtime, but without understanding what a thread in the computer is, it makes no sense. In the following subsections, we will learn what these threads are, how to start a new thread, how to synchronize data exchange between threads, and finally put all this together and implement the Mastermind parallel guessing algorithm.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Processes</h1>
            

            <article>
                
<p class="calibre2">When you start your computer, the program that starts is the <strong class="calibre1">operating system</strong> (<strong class="calibre1">OS</strong>). The OS controls the machine hardware and the programs that you can run on the machine. When you start a program, the OS creates a new process. It means that the OS allocates a new entry in a table (array) where itÂ <span>administers</span> the processes and fills in the parameters that it knows, and needs to know, about the process. For example, itÂ <span>registers</span> what memory segment the process is allowed to use, what the ID of the process is, and which user started from which other process. You cannot start a process just out of thin air. When you double-click on an EXE file, you actually tell the file explorer, which is a program running as a process, to start the EXE file as a separate process. The explorer calls the system via some API and kindly asks the OS to do that. The OS will register the explorer process as the parent of the new process. The OS does not actually start the process, but creates all the data that it needs to start it and, when there is some free CPU resource, then the process gets started, and then it gets paused very soon. You will not notice it because the OS will start it again and again and is always pausing the process repeatedly. It needs to do it to provide run possibilities to all processes. That way, we experience all processes running at the same time. In reality, processes do not run at the same time on a single processor, but they get time slots to run often.</p>
<p class="calibre2">If you have more than one CPU in the machine, then processes can actually run at the same time, as many CPUs as there are. As the integration gets more advanced today, desktop computers have CPUs that contain multiple cores that function almost like separate CPUs. On my machine, I have four cores, each capable of executing two threads simultaneously; so, my Mac is almost like an 8 CPU machine.</p>
<p class="calibre2">Processes have separate memories. They are allowed to use one part of the memory and if a process tries to use another part that does not belong to it, the processor will stop doing so. The OS will kill the process.</p>
<div class="packttip">Just imagine how frustrated the developers of the original UNIX could have been that they named the program to stop a process to kill, and stopping a process is called killing it. It is like medieval ages when they cut off the hand of a felon. You touch the wrong part of the memory and get killed. I would not like to be a process.</div>
<p class="calibre2">The memory handling by the operating system is very complex in addition to separating the processes from each other. When there is not enough memory, the OS writes part of the memory to disk freeing up the memory and reloading that part when it is needed again. This is a very complex, low-level implemented and highly optimized algorithm that is the responsibility of the OS.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Threads</h1>
            

            <article>
                
<p class="calibre2">When I said that the OS executes the processes in time slots, I was not absolutely precise. Every process has one or more threads, and threads are executed. A thread is the smallest execution managed by an external scheduler. Older operating systems did not have the notion of a thread and were executing processes. As a matter of fact, the first thread implementations were simply duplications of processes that were sharing the memory.</p>
<p class="calibre2">You may hear the terminology, lightweight processâit means a thread.</p>
<p class="calibre2">The important thing is that the threads do not have their own memory. They use the memory of the process. In other words, the threads that run in the same process have undistinguished access to the same memory segment. It is an extremely powerful possibility to implement parallel algorithms that make use of the multiple cores in the machine, but at the same time, it may lead to bugs.</p>
<div class="packtfigure"><img class="image-border32" src="../images/00044.jpeg"/></div>
<p class="calibre2">Imagine that two threads increment the same long variable. The increment first calculates the incremented value of the lower 32 bits and then the upper, if there were any overflow bits. These are two or more steps that may be interrupted by the OS. It may happen that one thread increments the lower 32 bits, remembers that there is something to do to the upper 32 bits, starts the calculation, but has no time to store the result before it gets interrupted. Then, another thread increments the lower 32 bits, the upper 32 bits, and then the first thread just saves the upper 32 bits that it calculated. The result gets garbled. On an older 32-bit Java implementation, it was extremely easy to demonstrate this effect. On a 64-bit Java implementation, all the 64 bits are loaded into registers and saved back to the memory in one step so it is not that easy to demonstrate multithread issues, but it does not mean that there are none.</p>
<p class="calibre2">When a thread is paused and another thread is started, the operating system has to perform a context switch. It means that, among other things, the CPU registers have to be saved and then set to the value that they should have for the other thread. A context switch is always saving the state of the thread and loading the previously saved state of the thread to be started. This is on a CPU register level. This context switch is time consuming; therefore, the more context switches that are done, the more CPU resource is used for the thread administration instead of letting them run. On the other hand, if there are not enough switches, some threads may not get enough time slots to execute, and the program hangs.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Fibers</h1>
            

            <article>
                
<p class="calibre2">Java does not have fibers, but as there are some libraries that support fiber handlings, it is worth mentioning. A fiber is a finer unit than a thread. A program code executing in a thread may decide to give up the execution and tell the fiber manager to just execute some other fiber. What is the point and why is it better than using another thread? The reason is that this way, fibers can avoid part of the context switch. Â A context switch cannot be avoided totally because a different part of the code that starts to execute it may use the CPU registers in a totally different way. As it is the same thread, the context switching is not the task of the OS, but the application.</p>
<p class="calibre2">The OS does not know if the value of a register is used or not. There are bits in the registers, and no one can tell seeing only the processor state whether those bits are relevant for the current code execution or just happen to be there in that way. The program generated by a compiler does know which registers are important and which are those that can just be ignored. This information changes from place to place in the code, but when there is a need for a switch, the fiber passes the information of what is needed to be switched at that point to the code that does the switching.</p>
<p class="calibre2">The compiler calculates this information, but Java does not support fibers in the current version. The tools that implement fibers in Java analyze and modify the byte code of the classes to do this after the compilation phase.</p>
<div class="packttip">Golang's goroutines are fibers and that is why you can easily start many thousand goroutines in Go, but you better limit the number of threads in Java to a lower number. They are not the same things.</div>
<p class="calibre2">As the terminology lightweight process is fading out and used by less and less fibers, many times are referred to as lightweight threads.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">java.lang.Thread</h1>
            

            <article>
                
<p class="calibre2">As everything in Java (well, almost) is object, if we want to start a new thread, we will need a class that represents the thread. This class is <kbd class="calibre11">java.lang.Thread</kbd> built into the JDK. When you start a Java code, the JVM automatically creates a few <kbd class="calibre11">Thread</kbd> objects and uses them to run different tasks that are needed by it. If you start up <strong class="calibre1">VisualVM</strong>, you can select the <span>Threads</span> tab of any JVM process and see the actual threads that are in the JVM. For example, the VisualVM as I started it has 29 live threads. One of them is the thread named <kbd class="calibre11">main</kbd>. This is the one that starts to execute the <kbd class="calibre11">main</kbd> method (surprise!). The <kbd class="calibre11">main</kbd> thread started most of the other threads. When we want to write a multithread application, we will have to create new <kbd class="calibre11">Thread</kbd> objects and start them. The simplest way to do that is <kbd class="calibre11">new Thread()</kbd>, and then calling the <kbd class="calibre11">start</kbd> method on the thread. It will start a new Thread that will just finish immediately as we did not give it anything to do. The <kbd class="calibre11">Thread</kbd> class, as it is in the JDK, does not do our business logic. The following are the two ways to specify the business logic:</p>
<ul class="calibre14">
<li class="calibre15">Creating a class that implements the <kbd class="calibre11">Runnable</kbd> interface</li>
<li class="calibre15">Creating a class that extends the <kbd class="calibre11">Thread</kbd> class and overrides the <kbd class="calibre11">run</kbd> method</li>
</ul>
<p class="calibre2">The following block of code is a very simple demonstration program:</p>
<pre class="calibre20">
public class ThreadIntermingling { <br class="title-page-name"/>     static class MyThread extends Thread { <br class="title-page-name"/>         private final String name; <br class="title-page-name"/>         MyThread(String name){ <br class="title-page-name"/>             this.name = name; <br class="title-page-name"/>         } <br class="title-page-name"/>         @Override <br class="title-page-name"/>         public void run(){ <br class="title-page-name"/>             for(int i = 1 ; i &lt; 1000 ; i ++ ){ <br class="title-page-name"/>                 System.out.print(name + " " + i+ ", "); <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>     public static void main(String[] args){ <br class="title-page-name"/>         Thread t1 = new MyThread("t1"); <br class="title-page-name"/>         Thread t2 = new MyThread("t2"); <br class="title-page-name"/>         t1.start(); <br class="title-page-name"/>         t2.start(); <br class="title-page-name"/>         System.out.print("started "); <br class="title-page-name"/>  <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">The preceding code creates two threads and starts them one after the other. When the start method is called, it schedules the thread object to be executed and then returns. As a result, the new thread will soon start executing asynchronously while the calling thread continues its execution. The two threads, and the <kbd class="calibre11">main</kbd> thread, run parallel in the following example and create an output that looks something like this:</p>
<pre class="calibre20">
started t2 1, t2 2, t2 3, t2 4, t2 5, t2 6, t2 7, t2 8, t1 1, t2 9, t2 10, t2 11, t2 12,...
</pre>
<p class="calibre2">The actual output changes from run to run. There is no definite order of the execution or how the threads get access to the single screen output. There is not even guarantee that in each and every execution, the message <kbd class="calibre11">started</kbd> is printed before any of the thread messages.</p>
<p class="calibre2">To get a better understanding of this, we will have to look at the state diagram of threads. A Java Thread can be in one of the following states:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">NEW</kbd></li>
<li class="calibre15"><kbd class="calibre11">RUNNABLE</kbd></li>
<li class="calibre15"><kbd class="calibre11">BLOCKED</kbd></li>
<li class="calibre15"><kbd class="calibre11">WAITING</kbd></li>
<li class="calibre15"><kbd class="calibre11">TIMED_WAITING</kbd></li>
<li class="calibre15"><kbd class="calibre11">TERMINATED</kbd></li>
</ul>
<p class="calibre2">These states are defined in the <kbd class="calibre11">enumThread.State</kbd>. When you create a new thread object, it is in the <kbd class="calibre11">NEW</kbd> state. At this moment, the thread is nothing special, it is just an object but the operating system execution-scheduling does not know about it. In some sense, it is only a piece of memory allocated by the JVM.</p>
<p class="calibre2">When the start method is invoked, the information about the thread is passed to the operating system and the OS schedules the thread so it can be executed by it when there is an appropriate time slot. Doing this is a resourceful action and that is the reason why we do not create and, especially, do not start new Thread objects only when it is needed. Instead of creating new Threads, we will keep the existing threads for a while, even if they are not needed at the moment, and reuse an existing one if there is one suitable.</p>
<p class="calibre2">A thread in the OS can also be in a running state as well as runnable when the OS schedules and executes it at the moment. Java JDK API does not distinguish between the two for good reason. It would be useless. When a thread is in the <kbd class="calibre11">RUNNABLE</kbd> state asking if it is actually running from the thread itself, it will result in an obvious answer: if the code just returned from the <kbd class="calibre11">getState</kbd> method implemented in the <kbd class="calibre11">Thread</kbd> class, then it runs. If it were not running, it would not have returned from the call in the first place. If the <kbd class="calibre11">getState</kbd> method was called from another thread, then the result about the other thread by the time the method returns would be meaningless. The OS may have stopped, or started, the queried thread several times until then.</p>
<p class="calibre2">A thread is in a <kbd class="calibre11">BLOCKED</kbd> state when the code executing in the thread tries to access some resource that is not currently available. To avoid constant polling of resources, the operating system provides effective notification mechanism so the threads get back to the <kbd class="calibre11">RUNNABLE</kbd> state when the resource they need becomes available.</p>
<p class="calibre2">A thread is in the <kbd class="calibre11">WAIT</kbd> or <kbd class="calibre11">TIMED_WAITING</kbd> state when it waits for some other thread or lock. <kbd class="calibre11">TIMED_WAITING</kbd> is the state when the waiting started calling a version of a method that has timeout.</p>
<p class="calibre2">Finally, the <kbd class="calibre11">TERMINATED</kbd> state is reached when the thread finishes its execution. If you append the following lines to the end of our previous example, then you will get a <kbd class="calibre11">TERMINATED</kbd> printout and also an exception thrown up to the screen complaining about illegal thread state, which is because you cannot start an already terminated thread:</p>
<pre class="calibre20">
System.out.println(); <br class="title-page-name"/>System.out.println(t1.getState()); <br class="title-page-name"/>System.out.println(); <br class="title-page-name"/>t1.start();
</pre>
<p class="calibre2">Instead of extending the <kbd class="calibre11">Thread</kbd> class to define what to execute asynchronously, we can create a class that implements <kbd class="calibre11">Runnable</kbd>. Doing that is more in line with the OO programming approach. The something that we implement in the class is not a functionality of a thread. It is more of a something that can be executed. It is something that can just run.</p>
<p class="calibre2">If this execution is asynchronous in a different thread, or it is executed in the same thread that was calling the run method, is a different concern that has to be separated. If we do it that way, we can pass the class to a <kbd class="calibre11">Thread</kbd> object as a constructor argument. Calling <kbd class="calibre11">start</kbd> on the <kbd class="calibre11">Thread</kbd> object will start the run method of the object we passed. This is not the gain. The gain is that we can also pass the <kbd class="calibre11">Runnable</kbd> object to an <kbd class="calibre11">Executor</kbd> (dreadful name, huhh!). <kbd class="calibre11">Executor</kbd> is an interface, and implementations execute <kbd class="calibre11">Runnable</kbd> (and also <kbd class="calibre11">Callable</kbd>, see later) objects in <kbd class="calibre11">Thread</kbd>s in an efficient way. Executors usually have a pool of <kbd class="calibre11">Thread</kbd> objects that are prepared, and in the <kbd class="calibre11">BLOCKED</kbd> state. When the <kbd class="calibre11">Executor</kbd> has a new task to execute, it gives it to one of the <kbd class="calibre11">Thread</kbd> objects and releases the lock that is blocking the thread. The <kbd class="calibre11">Thread</kbd> gets into the <kbd class="calibre11">RUNNABLE</kbd> state, executes the <kbd class="calibre11">Runnable</kbd>, and gets blocked again. It does not terminate and thus can be reused to execute another <kbd class="calibre11">Runnable</kbd> later. That way, <kbd class="calibre11">Executor</kbd>s avoid the resource consuming process of thread registration into the operating system.</p>
<div class="packttip">Professional application code never creates a new <kbd class="calibre22">Thread</kbd>. Application code uses some framework to handle the parallel execution of the code or uses <kbd class="calibre22">Executor</kbd>s provided by some <kbd class="calibre22">ExecutorService</kbd> to start <kbd class="calibre22">Runnable</kbd> or <kbd class="calibre22">Callable</kbd> objects.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Pitfalls</h1>
            

            <article>
                
<p class="calibre2">We have already discussed many of the problems that we may face when developing parallel program. In this section, we will summarize them with the usual terminology used for the problems. Terminology is not only interesting, but it is also important when you talk with colleagues to easily understand each other.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Deadlocks</h1>
            

            <article>
                
<p class="calibre2">Deadlock is the most infamous parallel programming pitfall, and for this reason, we will start with this one. To describe the situation, we will follow the metaphor of bureaucrats.</p>
<p class="calibre2">The bureaucrat has to stamp a paper he has in his hand. To do that, he needs the stamp, and he also needs the inkpad. First, he goes to the drawer where the stamp is and takes it. Then, he walks to the drawer where the inkpad is and takes the inkpad. He inks the stamp, pushes on the paper. Then, he puts the stamp back to its place and then the inkpad back in its place. Everything is nice, we are on cloud 9.</p>
<p class="calibre2">What happens if another bureaucrat takes the inkpad first and then the stamp second? They may soon end up as one bureaucrat with the stamp in hand waiting for the inkpad and another one with the inkpad in hand waiting for the stamps. And, they may just stay there, frozen forever, and then more and more start to wait for these locks, the papers never get stamped, and the whole system sinks into anarchy.</p>
<p class="calibre2">To avoid such situations, the locks have to be ordered and the locks should always be acquired in the order. In the preceding example, the simple agreement that the inkpad is acquired first and the stamp second solves the problem. Whoever acquired the stamp can be sure that the inkpad is free or will soon be free.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Race conditions</h1>
            

            <article>
                
<p class="calibre2">We talk about race conditions when the result of a calculation may be different based on the speed and CPU access of the different parallel running threads. Let's take a look at the following two code lines:</p>
<pre class="calibre20">
    void method1(){ <br class="title-page-name"/>1       a = b; <br class="title-page-name"/>2       b = a+1; <br class="title-page-name"/>        } <br class="title-page-name"/>    void method2(){ <br class="title-page-name"/>3       c = b; <br class="title-page-name"/>4       b = c+2; <br class="title-page-name"/>        }
</pre>
<p class="calibre2">If the value of <kbd class="calibre11">b</kbd> at the start of the execution is 0, and two different threads execute the two methods, then the order of the lines can be 1234, 1324, 1342, 3412, 3142, or 3142. Any execution order of the four lines may happen which assures that 1 runs before 2 and 3 runs before 4, but no other restrictions. The outcome, the value of <kbd class="calibre11">b</kbd>, is either 1 or 2 at the end of the execution of the segments, which may not be good and what we wanted when coding.</p>
<p class="calibre2">Note that the implementation of the parallel Mastermind game also has something like this. The actual guesses very much depend on the speed of the different threads, but this is irrelevant from the final result point of view. We may have different guesses in different runs and that way the algorithm is not deterministic, but we are guaranteed to find the final solution.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Overused locks</h1>
            

            <article>
                
<p class="calibre2">In many situations, it may happen that the threads are waiting on a lock, which protects a resource from concurrent access. If the resource cannot be used by multiple threads simultaneously, and there are more threads than can be served, then the threads are starving. However, in many cases, the resource can be organized in a way so that the threads can get access to some of the services that the resource provides, and the locking structure can be less restrictive. In that case, the lock is overused and the situation can be mended without allocating more resource for the threads. It may be possible to use several locks that control the access to the different functionality of the resource.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Starving</h1>
            

            <article>
                
<p class="calibre2">Starving is the situation when several threads are waiting for a resource trying to acquire a lock and some threads get access to the lock only after extremely long time or never. When the lock is released and there are threads waiting for it, then one of the threads can get the lock. There is usually no guarantee that a thread gets the lock if it waits long enough. Such a mechanism would require intensive administration of the threads, sorting them in the waiting queue. As locking should be a low latency and high performance action, even a few CPU clock cycles are significant; therefore, the locks do not provide this type of fair access by default. Not wasting time with fairness in thread scheduling is a good approach, in case the locks have one thread waiting. The main goal of locks is not scheduling the waiting threads, but rather preventing parallel access to resources.</p>
<p class="calibre2">It is like in a shop. If there is somebody at the cashier, you wait. It is a lock built in implicitly. It is not a problem if people do not queue up for the cashier, so long as long there is almost always one free. However, when there are several queues built up in front of the cashiers, then having no queue and waiting order will certainly lead to some very long waiting order for someone who is slow to get access to the cashier. Generally, the solution of fairness and creating queue of waiting threads (customers) is not a good solution. The good solution is to eliminate the situation that leads to waiting queues. You can employ more cashiers, or you can do something totally different that makes the peak load smaller. In a shop, you can give discount to drive customers who come in at off-peak hours. In programming, several techniques can be applied, usually, depending on the actual business we code and fair scheduling of locks is usually a workaround.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ExecutorService</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">ExecutorService</kbd> is an interface in the JDK. An implementation of the interface can execute a <kbd class="calibre11">Runnable</kbd> or <kbd class="calibre11">Callable</kbd> class in an asynchronous way. The interface only defines the API for the implementation and does not require that the invocation is asynchronous but, in reality, that is the main point implementing such a service. Invoking the <kbd class="calibre11">run</kbd> method of a <kbd class="calibre11">Runnable</kbd> interface in a synchronous way is simply calling a method. We do not need a special class for that.</p>
<p class="calibre2">The <kbd class="calibre11">Runnable</kbd> interface defines one <kbd class="calibre11">run</kbd> method. It has no arguments returns no value and does not throw any exception. The <kbd class="calibre11">Callable</kbd> interface is parameterized and the only method it defines, <kbd class="calibre11">call</kbd>, has no argument but returns a generic value and may also throw <kbd class="calibre11">Exception</kbd>. In our code, we will implement <kbd class="calibre11">Runnable</kbd> if we just want to run something, and <kbd class="calibre11">Callable</kbd> when we want to return something. Both of these interfaces are functional interfaces, therefore, they are good candidates to be implemented using lambda.</p>
<p class="calibre2">To have an instance of an implementation of an <kbd class="calibre11">ExecutorService</kbd>, we can use the utility class <kbd class="calibre11">Executors</kbd>. Many times when there is an <kbd class="calibre11">XYZ</kbd> interface in the JDK, there can be an <kbd class="calibre11">XYZs</kbd> (plural) utility class that provides factory for the implementations of the interface. If we want to start the <kbd class="calibre11">t1</kbd> task many times, we can do so without creating a new <kbd class="calibre11">Thread</kbd>. We should use the following executor service:</p>
<div class="title-page-name">
<pre class="calibre20">
public class ThreadIntermingling { <br class="title-page-name"/>      static class MyThread implements Runnable { <br class="title-page-name"/>          private final String name; <br class="title-page-name"/>   <br class="title-page-name"/>          MyThread(String name) { <br class="title-page-name"/>              this.name = name; <br class="title-page-name"/>          } <br class="title-page-name"/>   <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void run() { <br class="title-page-name"/>              for (int i = 1; i &lt; 1000; i++) { <br class="title-page-name"/>                  System.out.print(name + " " + i + ", "); <br class="title-page-name"/>              } <br class="title-page-name"/>          } <br class="title-page-name"/>      } <br class="title-page-name"/>      public static void main(String[] args) <br class="title-page-name"/>                throws InterruptedException, ExecutionException { <br class="title-page-name"/>          ExecutorService es = Executors.newFixedThreadPool(2); <br class="title-page-name"/>          Runnable t1 = new MyThread("t1"); <br class="title-page-name"/>          Runnable t2 = new MyThread("t2"); <br class="title-page-name"/>          Future&lt;?&gt; f1 = es.submit(t1); <br class="title-page-name"/>          Future&lt;?&gt; f2 = es.submit(t2); <br class="title-page-name"/>          System.out.print("started "); <br class="title-page-name"/>          f1.get(); <br class="title-page-name"/>          f2.get(); <br class="title-page-name"/>          System.out.println(); <br class="title-page-name"/>          f1 = es.submit(t1); <br class="title-page-name"/>          es.shutdown(); <br class="title-page-name"/>      } <br class="title-page-name"/>  }
</pre></div>
<p class="calibre2">This time, we do not get any exception. Instead, the <kbd class="calibre11">t1</kbd> task runs second time. In this example, we are using a fixed size thread pool that has two <kbd class="calibre11">Thread</kbd>s. As we want to start only two threads simultaneously, it is enough. There are implementations that grow and shrink the size of the pool dynamically. Fixed size pool should be used when we want to limit the number of the threads or we know from some other information source the number of the a-priory threads. In this case, it is a good experiment to change the size of the pool to one and see that the second task will not start in this case until the first one finishes. The service will not have another thread for <kbd class="calibre11">t2</kbd> and will have to wait until the one and only <kbd class="calibre11">Thread</kbd> in the pool is freed.</p>
<p class="calibre2">When we submit the task to the service, it returns even if the task cannot currently be executed. The tasks are put in a queue and will start execution as soon as there is enough resource to start them. The submit method returns a <kbd class="calibre11">Future</kbd> object, as we can see in the preceding sample.</p>
<p class="calibre2">It is like a service ticket. You bring your car to the repair mechanic, and you get a ticket. You are not required to stay there until the car is fixed, but at any time, you can ask if the car is ready. All you need is the ticket. You can also decide to wait until the car is ready. A <kbd class="calibre11">Future</kbd> object is also something like that. You do not get the value that you need. It will be calculated asynchronously. However, there is a <kbd class="calibre11">Future</kbd> promise that it will be there and your ticket to access the object you need is the <kbd class="calibre11">Future</kbd> object.</p>
<p class="calibre2">When you have a <kbd class="calibre11">Future</kbd> object, you can call the <kbd class="calibre11">isDone</kbd> method to see if it is ready. You can start waiting for it to call <kbd class="calibre11">get</kbd> with, or without, some timeout. You can also cancel the task executing it, but in that case, the outcome may be questionable. Just like, in case of your car, if you decide to cancel the task, you may get back your car with the motor disassembled. Similarly, cancelling a task that is not prepared for it may lead to resource loss, opened and inaccessible database connection (this is a painful memory for me, even after 10 years), or just a garbled unusable object. Prepare your tasks to be cancelled or do not cancel them.</p>
<p class="calibre2">In the preceding example, there is no return value for <kbd class="calibre11">Future</kbd> because we submitted a <kbd class="calibre11">Runnable</kbd> object and not a <kbd class="calibre11">Callable</kbd> one. In that case the value passed to the <kbd class="calibre11">Future</kbd> is not to be used. It is usually <kbd class="calibre11">null</kbd>, but that is nothing to lean on.</p>
<p class="calibre2">The final and most important thing that many developers miss, even me, after not writing multithread Java API using code for years, is shutting down the <kbd class="calibre11">ExecutorService</kbd>. The <kbd class="calibre11">ExecutorService</kbd> is created and it has <kbd class="calibre11">Thread</kbd>Â elements. The JVM stops when all non-daemon threads are stopped. It ain't over till the fat lady sings.</p>
<div class="packtinfobox">A thread is a daemon thread if it was set to be daemon (invoking <kbd class="calibre22">setDaemon(true)</kbd>) before it was started. A thread is automatically daemon of the starting thread is a daemon thread. Daemon threads are stopped by the JVM when all other threads are finished and the JVM wants to finish. Some of the threads the JVM executes itself are daemon threads, but it is likely that there is no practical use of creating daemon threads in an application program.</div>
<p class="calibre2">Not shutting down the service simply prevents the JVM from stopping. The code will hang after the <kbd class="calibre11">main</kbd> method finishes. To tell the <kbd class="calibre11">ExecutorService</kbd> that there is no need for the threads it has, we will have to <kbd class="calibre11">shutdown</kbd> the service. The call will only start the shutdown and return immediately. In this case, we do not want to wait. The JVM does anyway. If we need to wait, we will have to call <kbd class="calibre11">awaitTermination</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ForkJoinPool</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">ForkJoinPool</kbd> is a special <kbd class="calibre11">ExecutorService</kbd> that has methods to execute <kbd class="calibre11">ForkJoinTask</kbd> objects. These classes are very handy when the task that we want to perform can be split into many small tasks and then the results, when they are available, aggregated. Using this executor, we need not care about the size of the thread pool and shutting down the executor. The size of the thread pool is adjusted to the number of processors on the given machine to have optimal performance. As the <kbd class="calibre11">ForkJoinPool</kbd> is a special <kbd class="calibre11">ExecutorService</kbd> that is designed for short running tasks, it does not expect any task to be there longer or being needed when there are no more tasks to run. Therefore, it is executed as a daemon thread; when the JVM shuts down, the <kbd class="calibre11">ForkJoinPool</kbd> automatically stops and the lady does not sing any more.</p>
<p class="calibre2">To create a task, the programmer should extend either <kbd class="calibre11">RecursiveTask</kbd> or <kbd class="calibre11">RecursiveAction</kbd>. The first one is to be used when there is some return value from the task, the second when there is no computed value returned. They are called recursive because many times, these tasks split the problem they have to solve smaller problems and invoke these tasks asynchronously through the fork-join API.</p>
<p class="calibre2">A typical problem to be solved using this API is the quick-sort. In the <a href="part0076.html" class="calibre6"><span>Chapter 3</span></a>, <em class="calibre12">Optimizing the Sort - Making Code Professional</em> we created two versions of the quick-sort algorithm. One using recursive calls and one without using it. We can also create a new one, which, instead of calling itself recursively, schedule the task to be executed, perhaps by another processor. The scheduling is the task of the <kbd class="calibre11">ForkJoinPool</kbd> implementation of <kbd class="calibre11">ExecutorService</kbd>.</p>
<p class="calibre2">You may revisit the code of <kbd class="calibre11">Qsort.java</kbd> in <a href="part0076.html" class="calibre6"><span>Chapter 3</span></a>, <em class="calibre12">Optimizing the Sort - Making Code Professional</em>. Here is the version that is using <kbd class="calibre11">ForkJoinPool</kbd>:</p>
<pre class="calibre20">
public class FJQuickSort&lt;E&gt; { <br class="title-page-name"/>     final private Comparator&lt;E&gt; comparator; <br class="title-page-name"/>     final private Swapper swapper; <br class="title-page-name"/>  <br class="title-page-name"/>     public FJQuickSort(Comparator&lt;E&gt; comparator, Swapper swapper){ <br class="title-page-name"/>         this.comparator = comparator; <br class="title-page-name"/>         this.swapper = swapper; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public void qsort(SortableCollection&lt;E&gt; sortable, <br class="title-page-name"/>                       int start, int end) { <br class="title-page-name"/>         ForkJoinPool pool = new ForkJoinPool(); <br class="title-page-name"/>         pool.invoke(new RASort(sortable,start,end)); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     private class RASort extends RecursiveAction { <br class="title-page-name"/>  <br class="title-page-name"/>         final SortableCollection&lt;E&gt; sortable; <br class="title-page-name"/>         final int start, end; <br class="title-page-name"/>  <br class="title-page-name"/>         public RASort(SortableCollection&lt;E&gt; sortable, <br class="title-page-name"/>                       int start, int end) { <br class="title-page-name"/>             this.sortable = sortable; <br class="title-page-name"/>             this.start = start; <br class="title-page-name"/>             this.end = end; <br class="title-page-name"/>         } <br class="title-page-name"/>  <br class="title-page-name"/>         public void compute() { <br class="title-page-name"/>             if (start &lt; end) { <br class="title-page-name"/>                 final E pivot = sortable.get(start); <br class="title-page-name"/>                 final Partitioner&lt;E&gt; partitioner =  <br class="title-page-name"/>                          new Partitioner&lt;&gt;(comparator, swapper); <br class="title-page-name"/>                 int cutIndex = partitioner.partition( <br class="title-page-name"/>                                    sortable, start, end, pivot); <br class="title-page-name"/>                 if (cutIndex == start) { <br class="title-page-name"/>                     cutIndex++; <br class="title-page-name"/>                 } <br class="title-page-name"/>                 RecursiveAction left =  <br class="title-page-name"/>                    new RASort(sortable, start, cutIndex - 1); <br class="title-page-name"/>                 RecursiveAction right =  <br class="title-page-name"/>                    new RASort(sortable, cutIndex, end); <br class="title-page-name"/>                 invokeAll(left,right); <br class="title-page-name"/>                 left.join(); <br class="title-page-name"/>                 right.join(); <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>     }
</pre>
<p class="calibre2">Whenever you can split your tasks into subtasks similar to the way it was done in the preceding quick-sort example, I recommend that you use <kbd class="calibre11">ForkJoinPool</kbd> as an <kbd class="calibre11">ExecutorService</kbd>. You can find good documentation on the API and the use on the JavaDoc documentation of Oracle.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Variable access</h1>
            

            <article>
                
<p class="calibre2">Now that we can start threads and create code that runs parallel, it is time to talk a little bit about how these threads can exchange data between each other. At first glimpse, it seems fairly simple. The threads use the same shared memory; therefore, they all can read and write all the variables that the Java access protection allows them. This is true, except that some threads may just decide not to read the memory. After all, if they have just recently read the value of some variable, why read it again from the memory to the registers if it was not modified? Who would have modified them? Let's see the following short example:</p>
<pre class="calibre20">
package packt.java9.by.example.thread; <br class="title-page-name"/>  <br class="title-page-name"/> public class VolatileDemonstration implements Runnable { <br class="title-page-name"/>     private Object o = null; <br class="title-page-name"/>     private static final Object NON_NULL = new Object(); <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public void run() { <br class="title-page-name"/>         while( o == null ); <br class="title-page-name"/>         System.out.println("o is not null"); <br class="title-page-name"/>     } <br class="title-page-name"/>     public static void main(String[] args) <br class="title-page-name"/>                            throws InterruptedException { <br class="title-page-name"/>         VolatileDemonstration me = new VolatileDemonstration(); <br class="title-page-name"/>         new Thread(me).start(); <br class="title-page-name"/>         Thread.sleep(1000); <br class="title-page-name"/>         me.o = NON_NULL; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">What will happen? You may expect that the code starts up, starts the new thread, and one minute, when the <kbd class="calibre11">main</kbd> thread sets the object to something not <kbd class="calibre11">null</kbd>, will it stop? It will not.</p>
<p class="calibre2">It may stop on some Java implementations, but in most of them, it will just keep spinning. The reason for that is that the JIT compiler optimizes the code. It sees that the loop does nothing and also that the variable will just never be non-null. It is allowed to assume that because the variables not declared <kbd class="calibre11">volatile</kbd> are not supposed to be modified by any other thread, the JIT is eligible to optimize. If we declare the <kbd class="calibre11">Object o</kbd> variable to be <kbd class="calibre11">volatile</kbd> (with the <kbd class="calibre11">volatile</kbd> keyword), then the code will stop.</p>
<div class="packttip">In case you try to remove the call to sleep, the code will also stop. This, however, does not fix the issue. The reason is that JIT optimization kicks in only after about 5000 loops of the code execution. Before that, the code runs naive and stops before the optimization will eliminate the extra and regularly not needed access to the non-volatile variable.</div>
<p class="calibre2">If this is so gruesome, then why don't we declare all variables to be volatile? Why does Java not do that for us? The answer is speed, and to understand it deeper, we will use our metaphor, the office, and the bureaucrat.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The CPU heartbeat</h1>
            

            <article>
                
<p class="calibre2">These days CPUs run on 2 to 4 GHz frequency processors. It means that a processor gets 2 to 4 times 10<sup class="calibre29">9</sup> clock signals to do something every second. A processor cannot do any atomic operation faster than this, and also there is no reason to create a clock that is faster than what a processor can follow. It means that a CPU performs a simple operation, such as incrementing a register in half or quarter of a nanosecond. This is the heartbeat of the processor, and if we think of the bureaucrat as humans, who they are, then it is equivalent to one second, approximately, if and as their heartbeat.</p>
<p class="calibre2">Processors have registers and caches on the chip on different levels, L1, L2, and sometimes L3; there is memory, SSD, disk, network, and tapes that may be needed to retrieve data.</p>
<p class="calibre2">Accessing data that is in the L1 cache is approximately 0.5ns. You can grab a paper that is on your deskâhalf of a second. L2 cache is 7ns. This is a paper in the drawer. You have to push the chair a bit back, bend it in a sitting position, pull out the drawer, take the paper, push the drawer back, and raise and put the paper on the desk; it takes 10 seconds, give or take.</p>
<p class="calibre2">Main memory read is 100ns. The bureaucrat stands up, goes to the shared file at the wall, he waits while other bureaucrats are pulling their papers or putting theirs back, selects the drawer, pulls it out, takes the paper, and walks back to the desk. This is two minutes. This is volatile variable access every time you write a single word on a document and it has to be done twice. Once to read, and once to write, even if you happen to know that the next thing you will do is just fill another field of the form on the same paper.</p>
<p class="calibre2">Modern architectures, where there are no multiple CPUs but rather single CPUs with multiple cores, are a bit faster. One core may check the other core's caches to see if there was any modification on the same variable, but this speeds the volatile access to 20ns or so, which is still a magnitude slower than nonvolatile.</p>
<p class="calibre2">Although the rest is less focused on multithread programming, it is worth mentioning here, because it gives good understanding on the different time magnitudes.</p>
<p class="calibre2">Reading a block from an SSD (4K block usually) is 150,000ns. In human speed, that is a little bit more than 5 days. Reading or sending something to a server over the network on the Gb local Ethernet is 0.5ms, which is like waiting for almost a month for the metaphoric bureaucrat. If the data over the network is on a spinning magnetic disk, then seek time adds up (the time until the disk rotates so that the part of the magnetic surface gets under the reading head) to 20ms. It is, approximately, a year in human terms.</p>
<p class="calibre2">If we send a network packet over the Atlantic on the Internet, it is approximately is 150ms. It is like 14 years, and this was only one single package; if we want to send data over the ocean, it may be seconds that count up to historic times, thousands of years. If we count one minute for a machine to boot, it is equivalent to the time span of our whole civilization.</p>
<p class="calibre2">We should consider these numbers when we want to understand what the CPU is doing most of the time: it waits. Additionally, it also helps cool your nerves when you think about the speed of a real-life bureaucrat. They are not that slow after all, if we consider their heartbeat, which implies the assumption that they have a heart. However, let's go back to real life, CPUs, and L1, L2 caches and volatile variables.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Volatile variables</h1>
            

            <article>
                
<p class="calibre2">Let's modify the declaration of the <kbd class="calibre11">o</kbd> variable in our sample code as follows:</p>
<pre class="calibre20">
private volatile Object o = null;
</pre>
<p class="calibre2">The preceding code runs fine and stops after a second or so. Any Java implementation has to guarantee that multiple threads can access <kbd class="calibre11">volatile</kbd> fields and the value of the field is consistently updated. This does not mean that volatile declaration will solve all synchronization issues, but guarantees that the different variables and their value change relations are consistent. For example, let's consider we have the following two fields incremented in a method:</p>
<pre class="calibre20">
private volatile int i=0,j=0; <br class="title-page-name"/>  <br class="title-page-name"/> public void method(){ <br class="title-page-name"/>     i++; j++; <br class="title-page-name"/> }
</pre>
<p class="calibre2">In the preceding code, reading <kbd class="calibre11">i</kbd> and <kbd class="calibre11">j</kbd> from another thread will never result an <kbd class="calibre11">i&gt;j</kbd>. Without the volatile declaration, the compiler is free to reorganize the execution of the increment operations if it needs and thus, it will not guarantee that an asynchronous thread reads consistent values.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Synchronized block</h1>
            

            <article>
                
<p class="calibre2">Declaring variables are not the only tool to ensure the consistency between threads. There are other tools in the Java language and one of them is the synchronized block. The <kbd class="calibre11">synchronized</kbd> keyword is part of the language and it can be used in front of a method or a program block inside a method.</p>
<p class="calibre2">Every object in the Java program has a monitor that can be locked and unlocked by any running thread. When a thread locks a monitor, it is said that that thread holds the lock, and no two threads can hold the lock of a monitor at a time. If a thread tries to lock a monitor that is already locked, it gets <kbd class="calibre11">BLOCKED</kbd> until the monitor is released. A synchronized block starts with the <kbd class="calibre11">synchronized</kbd> keyword, and then an object instance specified between parentheses and the block comes. The following small program demonstrates the <kbd class="calibre11">synchronized</kbd> block:</p>
<pre class="calibre20">
public class SynchronizedDemo implements Runnable { <br class="title-page-name"/>     public static final int N = 1000; <br class="title-page-name"/>     public static final int MAX_TRY = 1_000_000; <br class="title-page-name"/>  <br class="title-page-name"/>     private final char threadChar; <br class="title-page-name"/>     private final StringBuffer sb; <br class="title-page-name"/>     public SynchronizedDemo(char threadChar, StringBuffer sb) { <br class="title-page-name"/>         this.threadChar = threadChar; <br class="title-page-name"/>         this.sb = sb; <br class="title-page-name"/>     } <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public void run() { <br class="title-page-name"/>         for (int i = 0; i &lt; N; i++) { <br class="title-page-name"/>             synchronized (sb) { <br class="title-page-name"/>                 sb.append(threadChar); <br class="title-page-name"/>                 sleep(); <br class="title-page-name"/>                 sb.append(threadChar); <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>     private void sleep() { <br class="title-page-name"/>         try { <br class="title-page-name"/>             Thread.sleep(1); <br class="title-page-name"/>         } catch (InterruptedException ignored) {} <br class="title-page-name"/>     } <br class="title-page-name"/>     public static void main(String[] args) { <br class="title-page-name"/>         boolean failed = false; <br class="title-page-name"/>         int tries = 0; <br class="title-page-name"/>         while (!failed &amp;&amp; tries &lt; MAX_TRY) { <br class="title-page-name"/>             tries++; <br class="title-page-name"/>             StringBuffer sb = new StringBuffer(4 * N); <br class="title-page-name"/>             new Thread(new SynchronizedDemo('a', sb)).start(); <br class="title-page-name"/>             new Thread(new SynchronizedDemo('b', sb)).start(); <br class="title-page-name"/>             failed = sb.indexOf("aba") != -1 || <br class="title-page-name"/>                      sb.indexOf("bab") != -1; <br class="title-page-name"/>         } <br class="title-page-name"/>         System.out.println(failed ?  <br class="title-page-name"/>               "failed after " + tries + " tries" : "not failed"); <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">The code starts two different threads. One of the threads appends <kbd class="calibre11">aa</kbd> to the <kbd class="calibre11">StringBuffer</kbd>. The other one appends <kbd class="calibre11">bb</kbd>. This appending is done in two separate steps with a sleep in between. The sleep is needed to avoid JIT that optimizes the two separate steps into one. Each thread executes the <kbd class="calibre11">append</kbd> 1000 times each time appending <kbd class="calibre11">a</kbd> or <kbd class="calibre11">b</kbd> two times. As the two <kbd class="calibre11">append</kbd>s one after the other are inside a <kbd class="calibre11">synchronized</kbd> block it cannot happen that an <kbd class="calibre11">aba</kbd> or <kbd class="calibre11">bab</kbd> sequence gets into the <kbd class="calibre11">StringBuffer</kbd>. While one thread executes the synchronized block, the other thread cannot execute it.</p>
<p class="calibre2">If I remove the synchronized block, then the JVM I used to test Java HotSpot (TM) 64-Bit Server VM (build 9-ea+121, mixed mode) prints out the failure with a try-count around a few hundreds.</p>
<p class="calibre2">It clearly demonstrates what the synchronization means, but it draws our attention to another important phenomena. The error occurs only around every few hundred thousand executions only. It is extremely rare, even though this example was furnished to demonstrate such a mishap. If a bug appears so rare, it is extremely hard to reproduce and, even more, to debug and fix. Most of the synchronization errors manifest in mysterious ways and their fixing usually is the result of meticulous code review rather than debugging. Therefore, it is extremely important to clearly understand the true nature of Java multithread behavior before starting commercial multithread application.</p>
<p class="calibre2">The <kbd class="calibre11">synchronized</kbd> keyword can also be used in front of a method. In this case, the object to acquire the lock of is the object. In case of a <kbd class="calibre11">static</kbd> method, the synchronization is done on the whole class.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Wait and notify</h1>
            

            <article>
                
<p class="calibre2">There are five methods implemented in the class <kbd class="calibre11">Object</kbd> that can be used to get further synchronization functionality: <kbd class="calibre11">wait</kbd> withÂ three different timeout argument signature, <kbd class="calibre11">notify</kbd>, and <kbd class="calibre11">notifyAll</kbd>. To call <kbd class="calibre11">wait</kbd>, the calling thread should have the lock of the <kbd class="calibre11">Object</kbd> on which <kbd class="calibre11">wait</kbd> is invoked. It means that you can only invoke <kbd class="calibre11">wait</kbd> from inside a synchronized block, and when it is called, the thread gets <kbd class="calibre11">BLOCKED</kbd> and releases the lock. When another thread calls <kbd class="calibre11">notify</kbd> all on the same <kbd class="calibre11">Object</kbd>, the thread gets into the <kbd class="calibre11">RUNNABLE</kbd> state. It cannot continue execution immediately as it cannot get the lock on the object. The lock is held at that moment by the thread that just called <kbd class="calibre11">notifyAll</kbd>. However, sometime after the other thread releases, the lock gets out of the <kbd class="calibre11">synchronized</kbd> block, and the waiting thread continues the execution.</p>
<p class="calibre2">If there are more threads waiting on an object, all of them get out of the <kbd class="calibre11">BLOCKED</kbd> state. The <kbd class="calibre11">notify</kbd> method wakes only one of the waiting threads. There is no guarantee which thread is awakened.</p>
<p class="calibre2">The typical use of <kbd class="calibre11">wait</kbd>, <kbd class="calibre11">notify</kbd>, and <kbd class="calibre11">notifyAll</kbd> is when one or more threads are creating <kbd class="calibre11">Object</kbd>s that are consumed by other thread, or threads. The storage where the objects travel between the threads is some kind of queue. The consumer waits until there is something to read from the queue, and the producer puts the objects into the queue one after the other. The producer notifies the consumers when it stores something into the queue. If there is no room left in the queue, the producer has to stop and wait until the queue has some space. In this case, the producer calls the <kbd class="calibre11">wait</kbd> method. To wake the producer up, the consumer calls <kbd class="calibre11">notifyAll</kbd> when it reads something.</p>
<p class="calibre2">The consumer consumes the objects from the queue in a loop and calls <kbd class="calibre11">wait</kbd> only if there is nothing to be read from the queue. When the producer calls <kbd class="calibre11">notifyAll</kbd>, and there is no consumer waiting, the notification is just ignored. It flies away, but this is not a problem; consumers are not waiting. When the consumer consumes an object and calls <kbd class="calibre11">notifyAll</kbd> and there is no producer waiting, the situation is the same. It is not a problem.</p>
<p class="calibre2">It cannot happen that the consumer consumes, calls <kbd class="calibre11">notifyAll</kbd>, and after the notification was flying in the air not finding any waiting producer, a producer starts to wait. This cannot happen because the whole code is in a <kbd class="calibre11">synchronized</kbd> block and it ensures that no producer is in the critical section. This is the reason why <kbd class="calibre11">wait</kbd>, <kbd class="calibre11">notify</kbd>, and <kbd class="calibre11">notifyAll</kbd> can only be invoked when the lock of the <kbd class="calibre11">Object</kbd> class is acquired.</p>
<p class="calibre2">If there are many consumers, which are executing the same code and are equivalently good in consuming the objects, then it is an optimization to call <kbd class="calibre11">notify</kbd> instead of <kbd class="calibre11">notifyAll</kbd>. In that case, <kbd class="calibre11">notifyAll</kbd> will just awake all consumer threads and all, but the lucky one will recognize that they were woken up but somebody else already got away with the bait.</p>
<p class="calibre2">I recommend that you practice at least once to implement a blocking queue that can be used to pass <kbd class="calibre11">Object</kbd>s between threads. However, never use that code in production: starting with Java 1.5, there are implementations of the <kbd class="calibre11">BlockingQueue</kbd> interface. Use one that fits your needs. We will too, in our example code.</p>
<div class="packttip">Feel lucky that you can code in Java 9. I started using Java professionally when it was 1.4 and once I had to implement a blocking queue. Life gets just better and easier all the time with Java.</div>
<p class="calibre2">In professional code, we usually avoid using <kbd class="calibre11">synchronized</kbd> methods or blocks and <kbd class="calibre11">volatile</kbd> fields as well as the <kbd class="calibre11">wait</kbd> and <kbd class="calibre11">notify</kbd> methods, <kbd class="calibre11">notifyAll</kbd> too, if possible. We can use asynchronous communication between threads, or pass the whole multithreading to the framework for handling. <kbd class="calibre11">Synchronized</kbd> and <kbd class="calibre11">volatile</kbd> cannot be avoided in some special cases when the performance of the code is important, or we cannot find a better construct. Sometimes, the direct synchronization on specific code and data structures is more efficient than the approach delivered by JDK classes. It is to note, however, that those classes also use these low-level synchronization constructs, so it is not magic how they work; and to develop yourself, you can look into the code of the JDK classes before you want to implement your own version. You will realize that it is not that simple to implement these queues; the code of the classes is not complex and compound without reason. If you find the code simple, it means that you are senior enough to know what not to reimplement. Or, perhaps, you do not even realize what code you read.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Lock</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">Lock</kbd>s are built in Java; every <kbd class="calibre11">Object</kbd> has a lock that a thread may acquire when it enters a <kbd class="calibre11">synchronized</kbd> block. We discussed that already. In some programming code, there are situations when this kind of structure is not optimal.</p>
<p class="calibre2">In some situations, the structure of locks may be lined up to avoid deadlock. It may be needed to acquire lock <em class="calibre12">A</em> before <em class="calibre12">B</em> and to acquire <em class="calibre12">B</em> before C<em class="calibre12">.</em> However, <em class="calibre12">A</em> should be released as soon as possible, not to prevent access to resource protected by lock <em class="calibre12">D</em>, but also needing lock <em class="calibre12">A</em> before it. In complex and highly parallel structures, the locks are structured many times into trees where accessing a resource a thread should climb down along the tree to a leaf representing the resource. In this climbing, the thread gets hold of a lock on a node, then a lock on a node below it, and then releases the lock above, just like a real climber descending (or climbing up if you imagine the tree with the leafs at the top, which is more realistic, nevertheless graphs usually show trees upside down).</p>
<p class="calibre2">You cannot leave a <kbd class="calibre11">synchronized</kbd> block remaining in another that is inside the first one. Synchronized blocks are nested. The <kbd class="calibre11">java.util.concurrent.Lock</kbd> interface defines methods to handle that situation and the implementations are also there in the JDK to be used in our code. When you have a lock, you can call the methods lock and unlock. The actual order is in your hand and you can write the following line of code to get the locking sequence:</p>
<pre class="calibre20">
a.lock(); b.lock(); a.unlock(); c.lock()
</pre>
<p class="calibre2">The freedom, however, comes with responsibility as well. The locks and unlocks are not tied to the execution sequence of the code, like in case of synchronized block, and it may be very easy to create code that in some case just loses a lock not unlocking it rendering some resource unusable. The situation is similar to a memory leak: you will allocate (lock) something and forget to release (unlock) it. After a while, the program will run out of resource.</p>
<p class="calibre2">My personal recommendation is to avoid using locks if possible and use higher-level constructs and asynchronous communications between threads, such as blocking queues.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Condition</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">java.util.concurrent.Condition</kbd> interface in functionality is similar to the built-in <kbd class="calibre11">wait, notify</kbd>, and <kbd class="calibre11">notifyAll</kbd>. Any implementation of <kbd class="calibre11">Lock</kbd> should create new <kbd class="calibre11">Condition</kbd> objects and return as a result to the invocation of the <kbd class="calibre11">newCondition</kbd> method. When the thread has a <kbd class="calibre11">Condition</kbd>, it can call <kbd class="calibre11">await</kbd>, <kbd class="calibre11">signal</kbd>, and <kbd class="calibre11">signalAll</kbd> when the thread has the lock that created the condition object.</p>
<p class="calibre2">The functionality is very similar to the methods of <kbd class="calibre11">Object</kbd> mentioned. However, the big difference is that you can create many <kbd class="calibre11">Condition</kbd>Â  for a single <kbd class="calibre11">Lock</kbd> and they will work independent of each other, but not independent of the <kbd class="calibre11">Lock</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ReentrantLock</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">ReentrantLock</kbd> is the simplest implementation of the interface lock in the JDK. There are two ways to create this type of lock: with and without fairness policy. If the <kbd class="calibre11">ReentrantLock(Boolean fair)</kbd> constructor is called with the true argument, then the lock will be assigned to the thread that is waiting for the lock the longest time in case there are many threads waiting. This will avoid a thread made to wait for infinite time and starving.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ReentrantReadWriteLock</h1>
            

            <article>
                
<p class="calibre2">This class is an implementation of <kbd class="calibre11">ReadWriteLock</kbd>. <kbd class="calibre11">ReadWriteLock</kbd> is a lock that can be used for parallel read access and exclusive write access. It means that several threads can read the resource protected by the lock, but when a thread writes the resource, no other thread can get access to it, not even read during that period. A <kbd class="calibre11">ReadWriteLock</kbd> is simply two <kbd class="calibre11">Lock</kbd> objects returned by the <kbd class="calibre11">readLock</kbd> and <kbd class="calibre11">writeLock</kbd> methods. To get read access on <kbd class="calibre11">ReadWriteLock</kbd>, the code has to invoke <kbd class="calibre11">myLock.readLock().lock()</kbd>, and to get access to write lock, <kbd class="calibre11">myLock.writeLock().lock()</kbd>. Acquiring one of the locks and releasing it in the implementation is coupled with the other lock. To acquire a write lock, no thread should have an active read lock, for example.</p>
<p class="calibre2">There are several intricacies in the use of the different lock. For example, you can acquire a read lock, but you cannot get a write lock so long as you have the read lock. You have to release the read lock first to acquire a write lock. This is just one of the simple details, but this is the one that novice programmers have trouble with many times. Why is it implemented this way? Why should the program get a write lock, which is more expensiveâin sense of higher probability locking other threadsâwhen it still is not sure that it wants to write the resource? The code wants to read it and. based on the content. it may later decide that it wants to write it.</p>
<p class="calibre2">The issue is not with the implementation. The developers of the library decided this rule, not because they just liked it that way or because they were aware of parallel algorithms and deadlock possibilities. When two threads have read lock and each decides to upgrade the lock to write lock, then they would intrinsically create a deadlock. Each would hold the read lock waiting for the write and none of them would get it ever.</p>
<p class="calibre2">On the other end, you can downgrade a write lock to a read lock without risking that in the meantime somebody acquires a write lock and modifies the resource.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Atomic classes</h1>
            

            <article>
                
<p class="calibre2">Atomic classes enclose primitive values into objects and provide atomic operations on them. We discussed race conditions and volatile variables. For example, if we have an <kbd class="calibre11">int</kbd> variable to be used as a counter and we want to assign a unique value to objects that we work with, we can increment the value and use the result as a unique ID. However, when multiple threads use the same code, we cannot be sure about the value we read after the increment. It may happen that another thread also incremented the value in the meantime. To avoid that, we will have to enclose the increment and the assignment of the incremented value to an object into a <kbd class="calibre11">synchronized</kbd> block. This can also be done using <kbd class="calibre11">AtomicInteger</kbd>.</p>
<p class="calibre2">If we have a variable of <kbd class="calibre11">AtomicInteger</kbd>, then calling <kbd class="calibre11">incrementAndGet</kbd> increments the value of <kbd class="calibre11">int</kbd> enclosed in the class and returns the incremented value. Why do it instead of using synchronized block? The first answer is that if the functionality is there in the JDK, then using it is less line than implementing it again. Developers maintaining the code you create are expected to know the JDK libraries but have to study your code, and this takes time and time is money.</p>
<p class="calibre2">The other reason is that these classes are highly optimized and, many times, they implement the features using platform specific native code that greatly over performs the version we can implement using synchronized blocks. Worrying about performance too early is not good, but parallel algorithms and synchronization between threads are usually used when performance is crucial; thus, there is a good chance that the performance of the code using the atomic classes is important.</p>
<p class="calibre2">In the <kbd class="calibre11">java.util.concurrent.atomic</kbd> package, there are several classes, <kbd class="calibre11">AtomicInteger</kbd>, <kbd class="calibre11">AtomicBoolean</kbd>, <kbd class="calibre11">AtomicLong</kbd>, and <kbd class="calibre11">AtomicReference</kbd> among them. They all provide methods that are specific to the encapsulated value.</p>
<p class="calibre2">The method, which is implemented by every atomic class, is <kbd class="calibre11">compareAndSet</kbd>. This is a conditional value-setting operation that has the following format:</p>
<pre class="calibre20">
boolean compareAndSet(expectedValue, updateValue);
</pre>
<p class="calibre2">When it is applied on an atomic class, it compares the actual value with the one <kbd class="calibre11">expectedValue</kbd>, and if they are the same, then it sets the value to <kbd class="calibre11">updateValue</kbd>. If the value was updated, the method returns <kbd class="calibre11">true</kbd> and it does all this in an atomic action.</p>
<div class="packttip">You may ask the question that if this method is in all of these classes, why is there no <kbd class="calibre22">Interface</kbd> defining this method? The reason for this is that the argument types are different based on the encapsulated type, and these types are primitives. As primitives cannot be used as generic types, not even a generic interface can be defined. In case of <kbd class="calibre22">AtomicXXXArray</kbd>, the method has an extra first argument, which is the index of the array element handled in the call.</div>
<p class="calibre2">The variables encapsulated are handled the same way as volatile, as far as the reordering is concerned, but there are special methods that loosen the conditions a bit to be used when possible, and performance is key.</p>
<p class="calibre2">The general advice is to consider using atomic classes, if there is one usable, and you will find yourself creating a synchronized block for check-and-set, atomic increment, or addition operations.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">BlockingQueue</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">BlockingQueue</kbd> is an interface that extends the standard <kbd class="calibre11">Queue</kbd> interface with methods that are suitable to be used by multithread applications. Any implementation of this interface provides methods that allow different threads to put element into the queue, pull elements off the queue, and wait for elements that are in the queue.</p>
<p class="calibre2">When there is a new element that is to be stored in the queue, you can <kbd class="calibre11">add</kbd> it, <kbd class="calibre11">offer</kbd> it, or <kbd class="calibre11">put</kbd> it. These are the name of the methods that store elements and they do the same thing, but a bit differently. The <kbd class="calibre11">add</kbd> element throws an exception if the queue is full and there is no room for the element. The <kbd class="calibre11">offer</kbd> element does not throw exception but returns either <kbd class="calibre11">true</kbd> or <kbd class="calibre11">false</kbd>, based on the success. If it can store the element in the queue, it returns <kbd class="calibre11">true</kbd>. There is also a version of <kbd class="calibre11">offer</kbd> that specifies a timeout. That version of the method waits, and returns only <kbd class="calibre11">false</kbd> if it cannot store the value into the queue during the period. The <kbd class="calibre11">put</kbd> element is the dumbest version; it waits until it can do its job.</p>
<p class="calibre2">When talking about available room in a queue, do not get puzzled and mix it with general Java memory management. If there is no more memory, and the garbage collector can also not release any, you will certainly get <kbd class="calibre11">OutOfMemoryError</kbd>. Exception is thrown by <kbd class="calibre11">add</kbd>, and <kbd class="calibre11">false</kbd> is returned by <kbd class="calibre11">offer</kbd>, when the queue limits are reached. Some of the <kbd class="calibre11">BlockingQueue</kbd> implementations can limit the number of elements that can be stored at a time in a queue. If that limit is reached, then the queue is full and cannot accept more elements.</p>
<p class="calibre2">Fetching elements from a <kbd class="calibre11">BlockingQueue</kbd> implementation also has four different ways. In this direction, the special case is when the queue is empty. In that case, <kbd class="calibre11">remove</kbd> throws an exception instead of returning the element, <kbd class="calibre11">poll</kbd> returns <kbd class="calibre11">null</kbd> if there is no element, and <kbd class="calibre11">take</kbd> just waits until it can return an element.</p>
<p class="calibre2">Finally, there are two methods inherited from the interface <kbd class="calibre11">Queues</kbd> that do not consume the element from the queue only <em class="calibre12">look at</em>. The <kbd class="calibre11">element</kbd> return the head of the queue and throws an exception if the queue is empty, and <kbd class="calibre11">peek</kbd> returns <kbd class="calibre11">null</kbd> if there is no element in the queue. The following table summarizes the operations borrowed from the documentation of the interface:</p>
<table class="MsoTableGrid">
<tbody class="calibre8">
<tr class="calibre9">
<td class="calibre10"/>
<td class="calibre10"><strong class="calibre1">Throws exception</strong></td>
<td class="calibre10"><strong class="calibre1">Special value</strong></td>
<td class="calibre10"><strong class="calibre1">Blocks</strong></td>
<td class="calibre10"><strong class="calibre1">Times out</strong></td>
</tr>
<tr class="calibre9">
<td class="calibre10"><strong class="calibre1">Insert</strong></td>
<td class="calibre10"><kbd class="calibre32">add(e)</kbd></td>
<td class="calibre10"><kbd class="calibre32">offer(e)</kbd></td>
<td class="calibre10"><kbd class="calibre32">put(e)</kbd></td>
<td class="calibre10"><kbd class="calibre32">offer(e, time, unit)</kbd></td>
</tr>
<tr class="calibre9">
<td class="calibre10"><strong class="calibre1">Remove</strong></td>
<td class="calibre10"><kbd class="calibre32">remove()</kbd></td>
<td class="calibre10"><kbd class="calibre32">poll()</kbd></td>
<td class="calibre10"><kbd class="calibre32">take()</kbd></td>
<td class="calibre10"><kbd class="calibre32">poll(time, unit)</kbd></td>
</tr>
<tr class="calibre9">
<td class="calibre10"><strong class="calibre1">Examine</strong></td>
<td class="calibre10"><kbd class="calibre32">element()</kbd></td>
<td class="calibre10"><kbd class="calibre32">peek()</kbd></td>
<td class="calibre10"><kbd class="calibre32">not applicable</kbd></td>
<td class="calibre10"><kbd class="calibre32">not applicable</kbd></td>
</tr>
</tbody>
</table>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">LinkedBlockingQueue</h1>
            

            <article>
                
<p class="calibre2">This is an implementation of the <kbd class="calibre11">BlockingQueue</kbd> interface, which is backed up by a linked list. The size of the queue is not limited by default (to be precise, it is <kbd class="calibre11">Integer.MAX_VALUE</kbd>) but it can optionally be limited in a constructor argument. The reason to limit the size in this implementation is to aid the use when the parallel algorithm performs better with limited size queue, but the implementation does not have any restriction on the size.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">LinkedBlockingDeque</h1>
            

            <article>
                
<p class="calibre2">This is the simplest implementation of the <kbd class="calibre11">BlockingQueue</kbd> and also its subinterface <kbd class="calibre11">BlockingDeque</kbd>. As we discussed in the previous chapter, a <kbd class="calibre11">Deque</kbd> is a double-ended queue that has <kbd class="calibre11">add</kbd>, <kbd class="calibre11">remove</kbd>, <kbd class="calibre11">offer</kbd>, and so on, type of methods in the form of <kbd class="calibre11">xxxFirst</kbd> and <kbd class="calibre11">xxxLast</kbd> to do the act with one or the other end of the queue. The <kbd class="calibre11">Deque</kbd> interface defines <kbd class="calibre11">getFirst</kbd> and <kbd class="calibre11">getLast</kbd> instead of consistently naming <kbd class="calibre11">elementFirst</kbd> and <kbd class="calibre11">elementLast</kbd>, so this is something you should get used to. After all, the IDEs help with automatic code completion so this should not be a really big problem.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ArrayBlockingQueue</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">ArrayBlockingQueue</kbd> implements the <kbd class="calibre11">BlockingQueue</kbd> interface, hence the Queue interface. This implementation manages a queue with fixed size elements. The storage in the implementation is an array and the elements are handled in a <em class="calibre12">FIFO</em> manner: first-in first-out. This is the class that we will also use in the parallel implementation of Mastermind for the communication between the boss and the subordinated bureaucrats.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">LinkedTransferQueue</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">TransferQueue</kbd> interface is extending <kbd class="calibre11">BlockingQueue</kbd> and the only implementation of it in the JDK is <kbd class="calibre11">LinkedTransferQueue</kbd>. A <kbd class="calibre11">TransferQueue</kbd> comes handy when a thread wants to hand over some data to another thread and needs to be sure that some other thread takes the element. This <kbd class="calibre11">TransferQueue</kbd> has a method transfer that puts an element on the queue but does not return until some other thread <kbd class="calibre11">remove</kbd>s (or <kbd class="calibre11">poll</kbd>s) it. That way the producing thread can be sure that the object put on the queue is in the hands of another processing thread and does not wait in the queue. The method <kbd class="calibre11">transfer</kbd> also has a format <kbd class="calibre11">tryTransfer</kbd> in which you can specify some timeout value. If the method times out the element is not put into the queue.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">IntervalGuesser</h1>
            

            <article>
                
<p class="calibre2">We discussed the different Java language elements and JDK classes that are all available to implement parallel algorithms. Now, we will see how to use these approaches to implement the parallel guesser for the Masterrmind game.</p>
<p class="calibre2">The class that performs the creation of the guesses is named <kbd class="calibre11">IntervalGuesser</kbd>. It creates the guesses between a start and an end guess and sends them to a <kbd class="calibre11">BlockingQueue</kbd>. The class implements <kbd class="calibre11">Runnable</kbd> so it can run in a separate <kbd class="calibre11">Thread</kbd>. The purist implementation will separate the <kbd class="calibre11">Runnable</kbd> functionality from the interval guessing, but as the whole class is hardly more than 50 lines, it is forgivable sin implementing the two functionalities in a single class.</p>
<pre class="calibre20">
public class IntervalGuesser extends UniqueGuesser implements Runnable { <br class="title-page-name"/>     private final Guess start; <br class="title-page-name"/>     private final Guess end; <br class="title-page-name"/>     private Guess lastGuess; <br class="title-page-name"/>     private final BlockingQueue&lt;Guess&gt; guessQueue; <br class="title-page-name"/>  <br class="title-page-name"/>     public IntervalGuesser(Table table, Guess start, Guess end, BlockingQueue&lt;Guess&gt; guessQueue) { <br class="title-page-name"/>         super(table); <br class="title-page-name"/>         this.start = start; this.end = end; <br class="title-page-name"/>         this.lastGuess = start; <br class="title-page-name"/>         this.guessQueue = guessQueue; <br class="title-page-name"/>         nextGuess = start; <br class="title-page-name"/>     } <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public void run() { <br class="title-page-name"/>         Guess guess = guess(); <br class="title-page-name"/>         try { <br class="title-page-name"/>             while (guess != Guess.none) { <br class="title-page-name"/>                 guessQueue.put(guess); <br class="title-page-name"/>                 guess = guess(); <br class="title-page-name"/>             } <br class="title-page-name"/>         } catch (InterruptedException ignored) { <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>     @Override <br class="title-page-name"/>     protected Guess nextGuess() { <br class="title-page-name"/>         Guess guess; <br class="title-page-name"/>         guess = super.nextGuess(); <br class="title-page-name"/>         if (guess.equals(end)) { <br class="title-page-name"/>             guess = Guess.none; <br class="title-page-name"/>         } <br class="title-page-name"/>         lastGuess = guess; <br class="title-page-name"/>         return guess; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public String toString() { <br class="title-page-name"/>         return "[" + start + "," + end + "]"; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">The implementation is very simple as most of the functionality is already implemented in the abstract <kbd class="calibre11">Guesser</kbd> class. The more interesting code is the one that invoked the <kbd class="calibre11">IntervalGuesser</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ParallelGamePlayer</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">ParallelGamePlayer</kbd> class implements the <kbd class="calibre11">Player</kbd> interface that defines the <kbd class="calibre11">play</kbd> method:</p>
<pre class="calibre20">
@Override <br class="title-page-name"/> public void play() { <br class="title-page-name"/>     Table table = new Table(NR_COLUMNS, manager); <br class="title-page-name"/>     Secret secret = new RandomSecret(manager); <br class="title-page-name"/>     Guess secretGuess = secret.createSecret(NR_COLUMNS); <br class="title-page-name"/>     Game game = new Game(table, secretGuess); <br class="title-page-name"/>     final IntervalGuesser[] guessers = createGuessers(table); <br class="title-page-name"/>     startAsynchronousGuessers(guessers); <br class="title-page-name"/>     final Guesser finalCheckGuesser = new UniqueGuesser(table); <br class="title-page-name"/>     try { <br class="title-page-name"/>         while (!game.isFinished()) { <br class="title-page-name"/>             final Guess guess = guessQueue.take(); <br class="title-page-name"/>             if (finalCheckGuesser.guessMatch(guess)) { <br class="title-page-name"/>                 game.addNewGuess(guess); <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>     } catch (InterruptedException ie) { <br class="title-page-name"/>  <br class="title-page-name"/>     } finally { <br class="title-page-name"/>         stopAsynchronousGuessers(guessers); <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">This method creates a Table, a <kbd class="calibre11">RandomSecret</kbd> that creates the guess used as a secret in a random way, a <kbd class="calibre11">Game</kbd> object, <kbd class="calibre11">IntervalGuesser</kbd>s, and a <kbd class="calibre11">UniqueGuesser</kbd>. The <kbd class="calibre11">IntervalGuesser</kbd>s are the bureaucrats; the <kbd class="calibre11">UniqueGuesser</kbd> is the boss who crosschecks the guesses that the <kbd class="calibre11">IntervalGuesser</kbd>s create. The method starts off the asynchronous guessers and then reads the guesses in a loop from them and puts them on the table if they are OK until the game finishes. At the end of the method, in the <kbd class="calibre11">finally</kbd> block, the asynchronous guessers are stopped.</p>
<p class="calibre2">The start and the stop method for the asynchronous guessers use <kbd class="calibre11">ExecutorService</kbd>.</p>
<pre class="calibre20">
private ExecutorService executorService; <br class="title-page-name"/>  <br class="title-page-name"/> private void startAsynchronousGuessers( <br class="title-page-name"/>                                   IntervalGuesser[] guessers) { <br class="title-page-name"/>     executorService = Executors.newFixedThreadPool(nrThreads); <br class="title-page-name"/>     for (IntervalGuesser guesser : guessers) { <br class="title-page-name"/>         executorService.execute(guesser); <br class="title-page-name"/>     } <br class="title-page-name"/> } <br class="title-page-name"/>  <br class="title-page-name"/>private void stopAsynchronousGuessers( <br class="title-page-name"/>                                   IntervalGuesser[] guessers) { <br class="title-page-name"/>     executorService.shutdown(); <br class="title-page-name"/>     guessQueue.drainTo(new LinkedList&lt;&gt;()); <br class="title-page-name"/> }
</pre>
<p class="calibre2">The code is quite straightforward. The only thing that may need mention is that the queue of the guesses is drained into a collection that we do not use afterward. This is needed to help any <kbd class="calibre11">IntervalGuesser</kbd> that is waiting with a suggested guess in hand, trying to put it into the queue. When we drain the queue, the guesser thread returns from the method put in the <kbd class="calibre11">guessQueue.put(guess);</kbd> line in <kbd class="calibre11">IntervalGuesser</kbd> and can catch the interrupt. The rest of the code does not contain anything that would be radically different from what we have already seen and you can find it on GitHub.</p>
<p class="calibre2">The last question that we still want to discuss in this chapter is how much speed did we gain making the code parallel?</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Microbenchmarking</h1>
            

            <article>
                
<p class="calibre2">Microbenchmarking is measuring the performance of a small code fragment. When we want to optimize our code, we will have to measure it. Without measurement, code optimization is like shooting blindfolded. You will not hit the target, but you likely will shoot somebody else.</p>
<p class="calibre2">Shooting is a good metaphor because you should usually not do it, but when you really have to then you have no choice. If there is no performance issue and the software meets the requirements, then any optimization, including speed measurement, is a waste of money. This does not mean that you are encouraged to write slow and sloppy code. When we measure performance, we will compare it against a requirement, and the requirement is usually on the user level. Something like, the response time of the application should be less than 2 seconds. To do such a measurement, we usually create load tests in a test environment and use different profiling tools that tell us what is consuming the most time and where we should optimize. Many times, it is not only Java code, but configuration optimization, using larger database connection pool, more memory, and similar things.</p>
<p class="calibre2">Microbenchmarking is a different story. It is about the performance of a small Java code fragment and, as such, closer to the Java programming.</p>
<p class="calibre2">It is rarely used, and before starting to do a microbenchmark for real commercial environment, we will have to think twice. Microbenchmark is a luring tool to optimize something small without knowing if it is worth optimizing that code. When we have a huge application that has several modules run on several servers, how can we be sure that improving some special part of the application drastically improves the performance? Will it pay back in increased revenue that generates so much profit that will cover the cost we burned into the performance testing and development? Statistically, almost sure that such an optimization including microbenchmarking will not pay off.</p>
<div class="packtinfobox">Once I was maintaining the code of a senior's colleague. He created a highly optimized code to recognize configuration keywords that were present in a file. He created a program structure that represented a decision tree based on the characters in the key string. If there was a keyword in the configuration file that was misspelled, the code threw an exception at the very first character where it could decide that the keyword could not be correct.<br class="calibre23"/>
To insert a new keyword, it needed to get through the code structure to find the occasion in the code where the new keyword was first different from already existing ones and extend the deeply nested if/else structures. To read the list of the handled keywords was possible from the comments that listed all the keywords that he did not forget to document. The code was working blazingly fast, probably saving a few milliseconds of the servlet application startup time. The application was started up only after system maintenance every few month.<br class="calibre23"/>
You feel the irony, don't you? Seniority is not always the number of years. Lucky ones can save their inner child.</div>
<p class="calibre2">So when to use microbenchmarking? I can see two areas:</p>
<ul class="calibre14">
<li class="calibre15">You identified the code segment that eats most of the resources in your application and the improvement can be tested by microbenchmarks</li>
<li class="calibre15">You cannot identify the code segment that will eat most of the resources in an application but you suspect it</li>
</ul>
<p class="calibre2">The first is the usual case. The second is when you develop a library, and you just do not know all the applications that will use it. In this case, you will try to optimize the part that you think is the most crucial for most of the imagined, suspected applications. Even in that case, it is better to take some sample applications that are created by users of your library and collect some statistics about the use.</p>
<p class="calibre2">Why should we talk about microbenchmarking in details? What are the pitfalls? Benchmarking is an experiment. The first programs I wrote was a TI calculator code and I can just count the number of steps the program made to factor two large (10 digits those days) prime numbers. Even at that time, I was using an old Russian stopwatch to measure the time, being lazy to calculate the number of steps. Experiment and measurement was easier.</p>
<p class="calibre2">Today, you cannot calculate the number of steps the CPU makes even if you wanted. There are so many small factors that may change the performance of the applications that are out of control of the programmer, which makes it impossible to calculate the steps. We have the measurement left for us, and we will gain all the problems of measurements.</p>
<p class="calibre2">What is the biggest problem? We are interested in something, say <em class="calibre12">X</em>, and we usually cannot measure that. So, we will measure <em class="calibre12">Y</em> instead and hope that the values of <em class="calibre12">Y</em> and <em class="calibre12">X</em> are coupled together. We want to measure the length of the room, but instead we measure the time it takes for the laser beam to travel from one end to the other. In this case, the length <em class="calibre12">X</em> and the time <em class="calibre12">Y</em> are strongly coupled. Many times, <em class="calibre12">X</em> and <em class="calibre12">Y</em> only correlate more or less. Most of the times, when people do measurement, the <em class="calibre12">X</em> and <em class="calibre12">Y</em> values have no relation to each other at all. Still, people put their money and more on decisions backed by such measurements.</p>
<p class="calibre2">Microbenchmarking is no different. The first question is how to measure the execution time? Small code runs short times and <kbd class="calibre11">System.currentTimeMillis()</kbd> may just return the same value when the measurement starts and when it ends, because we are still in the same millisecond. Even if the execution is 10ms, the error of the measurement is still at least 10% purely because of the quantization of the time as we measure. Luckily, there is <kbd class="calibre11">System.nanoTime()</kbd>. But is there? Just because the name says it returns the number of nanoseconds from a specific start time, it does not necessarily mean it really can.</p>
<p class="calibre2">It very much depends on the hardware and the implementation of the method in the JDK. It is called nano because this is the precision that we cannot certainly reach. If it was microseconds, then some implementation may be limited by the definition, even if on the specific hardware, there is a more precise clock. However, this is not only the precision of an available hardware clock; it is about the precision of the hardware.</p>
<p class="calibre2">Let's remember the heartbeat of the bureaucrats, and the time needed to read something from memory. Calling a method, such as <kbd class="calibre11">System.nanoTime(),</kbd> is like asking the bellboy in a hotel to run down from the second floor to the lobby and peek out to look at the clock on the tower on the other side of the road, come back, and tell seconds precision what the time was it when we asked. Nonsense. We should know the precision of the clock on the tower and the speed of the bellboy running from the floor to the lobby and back. This is a bit more than just calling <kbd class="calibre11">nanoTime</kbd>. This is what a microbenchmarking harness does for us.</p>
<p class="calibre2">The <strong class="calibre1">Java Microbenchmarking Harness</strong> (<strong class="calibre1">JMH</strong>) is available for some time as a library. It is developed by Oracle and used to tune the performance of some core JDK classes, and with Java 9, these performance measurements and results become part of the distributed JDK. This is good news for those who develop Java platform for new hardware, but also for developers, because it means that the JMH is and will be supported by Oracle.</p>
<p class="calibre2">"<em class="calibre12">JMH is a Java harness to build, run, and analyze nano/micro/milli/macro benchmarks written in Java and other languages targeting the JVM.</em>" (quote from the official site of JMH, <a href="http://openjdk.java.net/projects/code-tools/jmh/" class="calibre6">http://openjdk.java.net/projects/code-tools/jmh/</a>).</p>
<p class="calibre2">You can run <kbd class="calibre11">jmh</kbd> as a separate project independent from the actual project you measure, or you can just store the measurement code in a separate directory. The harness will compile against the production class files and will execute the benchmark. The easiest way, as I see, is to use the Gradle plugin to execute JMH. You can store the benchmark code in a directory called <kbd class="calibre11">jmh</kbd> (the same level as <kbd class="calibre11">main</kbd>Â and <kbd class="calibre11">test</kbd>) and create a <kbd class="calibre11">main</kbd> that can start the benchmark.</p>
<p class="calibre2">The Gradle build script is extended with the following lines:</p>
<pre class="calibre20">
buildscript { <br class="title-page-name"/>     repositories { <br class="title-page-name"/>         jcenter() <br class="title-page-name"/>     } <br class="title-page-name"/>     dependencies { <br class="title-page-name"/>         classpath "me.champeau.gradle:jmh-gradle-plugin:0.2.0" <br class="title-page-name"/>     } <br class="title-page-name"/> } <br class="title-page-name"/> apply plugin: "me.champeau.gradle.jmh" <br class="title-page-name"/>  <br class="title-page-name"/> jmh { <br class="title-page-name"/>     jmhVersion = '1.13' <br class="title-page-name"/>     includeTests = true <br class="title-page-name"/> }
</pre>
<p class="calibre2">And the microbenchmark class is as follows:</p>
<pre class="calibre20">
public class MicroBenchmark { <br class="title-page-name"/>     public static void main(String... args) <br class="title-page-name"/>                              throws IOException, RunnerException { <br class="title-page-name"/>         Options opt = new OptionsBuilder() <br class="title-page-name"/>                 .include(MicroBenchmark.class.getSimpleName()) <br class="title-page-name"/>                 .forks(1) <br class="title-page-name"/>                 .build(); <br class="title-page-name"/>         new Runner(opt).run(); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @State(Scope.Benchmark) <br class="title-page-name"/>     public static class ThreadsAndQueueSizes { <br class="title-page-name"/>         @Param(value = {"1", "4", "8"}) <br class="title-page-name"/>         String nrThreads; <br class="title-page-name"/>         @Param(value = { "-1","1", "10", "100", "1000000"}) <br class="title-page-name"/>         String queueSize; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Benchmark <br class="title-page-name"/>     @Fork(1) <br class="title-page-name"/>     public void playParallel(ThreadsAndQueueSizes t3qs) throws InterruptedException { <br class="title-page-name"/>         int nrThreads = Integer.valueOf(t3qs.nrThreads); <br class="title-page-name"/>         int queueSize = Integer.valueOf(t3qs.queueSize); <br class="title-page-name"/>         new ParallelGamePlayer(nrThreads, queueSize).play(); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Benchmark <br class="title-page-name"/>     @Fork(1) <br class="title-page-name"/>     public void playSimple(){ <br class="title-page-name"/>         new SimpleGamePlayer().play(); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/> }
</pre>
<p class="calibre2"><kbd class="calibre11">ParallelGamePlayer</kbd> is created to play the game with -1, 1, 4, and 8 <kbd class="calibre11">IntervalGuesser</kbd> threads, and in each case, there is a test running with a queue of length 1, 10, 100, and 1 million. These are 16 test executions. When the number of threads is negative, then the constructor uses <kbd class="calibre11">LinkedBlockingDeque</kbd>. There is another separate measurement that measures the nonparallel player. The test was executed with unique guesses and secrets (no color used more than once) and ten colors and six columns.</p>
<p class="calibre2">When the harness starts, it does all the calibrations automatically and runs the tests for many iterations to let the JVM start up. You may recall the code that just never stopped unless we used the <kbd class="calibre11">volatile</kbd> modifier in for the variable that was used to signal the code to stop. That happened because the JIT compiler optimized the code. This is done only when the code was already run a few thousand times. The harness makes these executions to warm up the code and ensure that the measurement is done when JVM is at full speed.</p>
<p class="calibre2">Running this benchmark takes approximately 15 minutes on my machine. During the execution, it is recommended to stop all other processes and let the benchmark use all available resources. If there is anything using resources during the measurement, then it will be reflected in the result.</p>
<pre class="calibre20">
Benchmark     (nrThreads)  (queueSize) Score   Error <br class="title-page-name"/>playParallel            1           -1 15,636 &amp;pm; 1,905 <br class="title-page-name"/>playParallel            1            1 15,316 &amp;pm; 1,237 <br class="title-page-name"/>playParallel            1           10 15,425 &amp;pm; 1,673 <br class="title-page-name"/>playParallel            1          100 16,580 &amp;pm; 1,133 <br class="title-page-name"/>playParallel            1      1000000 15,035 &amp;pm; 1,148 <br class="title-page-name"/>playParallel            4           -1 25,945 &amp;pm; 0,939 <br class="title-page-name"/>playParallel            4            1 25,559 &amp;pm; 1,250 <br class="title-page-name"/>playParallel            4           10 25,034 &amp;pm; 1,414 <br class="title-page-name"/>playParallel            4          100 24,971 &amp;pm; 1,010 <br class="title-page-name"/>playParallel            4      1000000 20,584 &amp;pm; 0,655 <br class="title-page-name"/>playParallel            8           -1 24,713 &amp;pm; 0,687 <br class="title-page-name"/>playParallel            8            1 24,265 &amp;pm; 1,022 <br class="title-page-name"/>playParallel            8           10 24,475 &amp;pm; 1,137 <br class="title-page-name"/>playParallel            8          100 24,514 &amp;pm; 0,836 <br class="title-page-name"/>playParallel            8      1000000 16,595 &amp;pm; 0,739 <br class="title-page-name"/>playSimple            N/A          N/A 18,613 &amp;pm; 2,040
</pre>
<p class="calibre2">The actual output of the program is a bit more verbose; it was edited for printing purposes. The <kbd class="calibre11">Score</kbd> column shows how many times the benchmark can run in a second. The <kbd class="calibre11">Error</kbd> shows that the measurement shows less than 10% scattering.</p>
<p class="calibre2">The fastest performance we have is when the algorithm runs on eight threads, which is the number of threads the processor can independently handle on my machine. It is interesting that limiting the size of the queue did not help the performance. I actually expected it to be different. Using a one million length array as a blocking queue has a huge overhead and this is not a surprise that, in this case, the execution is slower than when we have only 100 elements in the queue. The unlimited linked list-based queue handling, on the other hand, fairly fast and clearly shows that the extra speed at the limited queue for 100 elements does not come from the fact that the limit does not allow the <kbd class="calibre11">IntervalThreads</kbd> to run too far.</p>
<p class="calibre2">When we start one thread, then we expect similar results, as when we run the serial algorithm. The fact that the serial algorithm beats the parallel algorithm running on one thread is not a surprise. The thread creation and the communication between the main thread and the extra one thread have overhead. The overhead is significant, especially when the queue is unnecessarily large.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, you learned a lot of things. First of all, we refactored the code to be ready for further development that uses parallel guessing. We got acquainted with processes and threads, and we even mentioned fibers. After that, we looked at how Java implements threads and how to create code that runs on multiple threads. Additionally, we saw the different means that Java provides to programmers needing parallel programs, starting threads, or just starting some tasks in already existing threads.</p>
<p class="calibre2">Perhaps the most important part of this chapter that you should remember is the metaphor of bureaucrats and the different speeds. This is extremely important when you want to understand the performance of concurrent applications. And I hope that this is a catchy picture, which is easy to remember.</p>
<p class="calibre2">There was a huge topic about the different synchronization means that Java provides, and you have also learned about the pitfalls that programmers can fall into when programming concurrent applications.</p>
<p class="calibre2">Last but not least, we created the concurrent version of the Mastermind guesser and also measured that it is indeed faster than the version that uses only one processor (at least on my machine). We used the Java Microbenchmark Harness with the Gradle build tool and discussed, a bit, how to perform microbenchmarking.</p>
<p class="calibre2">This was a long chapter and not an easy one. I may tend to think that this is the most complex and most theoretical one. If you understood half of it at first read, you can be proud. On the other hand, be aware that this is only a good base to start experimenting with concurrent programming and there is a long way to being senior and professional in this area. And, it is not an easy one. But first of all, be proud of yourself at the end of this chapter.</p>
<p class="calibre2">In the following chapters we will learn more about web and web programming. In the very next chapter we will develop our little game so that it can run in a server and the player can play with it using a web browser. This will establish the basic knowledge for web programming. Later we will build on this developing web based service applications, reactive programming and all the tools and areas that will make a professional Java developer.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>