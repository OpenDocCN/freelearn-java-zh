<html><head></head><body>
<div id="_idContainer047" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-122"><a id="_idTextAnchor171" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-123" class="calibre6"><a id="_idTextAnchor172" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Reflection</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">The Reflection API is a powerful and versatile tool that enables developers to access the inner workings of Java programs. </span><span class="kobospan" id="kobo.3.2">In this chapter, we will explore the various capabilities of reflection, such as field access, method invocation, and proxy usage. </span><span class="kobospan" id="kobo.3.3">Reflection allows developers to inspect and manipulate classes and objects at runtime, providing a dynamic gateway into JVM internals. </span><span class="kobospan" id="kobo.3.4">Throughout this chapter, we will delve into the nuances of reflective field interactions, the intricacies of dynamically invoking methods, and the strategic deployment of proxies to enhance code flexibility. </span><span class="kobospan" id="kobo.3.5">Join us on a journey into the heart of Java’s reflective capabilities, where the seemingly unchangeable becomes adaptable, and the boundaries of static code are stretched to accommodate the dynamic requirements of </span><span><span class="kobospan" id="kobo.4.1">advanced applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we’ll explore the </span><span><span class="kobospan" id="kobo.6.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.7.1">Overview </span><span><span class="kobospan" id="kobo.8.1">of reflection</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.9.1">Exploring </span><span><span class="kobospan" id="kobo.10.1">practical reflection</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.11.1">Proxy</span></span></li>
</ul>
<h1 id="_idParaDest-124" class="calibre6"><a id="_idTextAnchor173" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.12.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.13.1">To follow along with this chapter, you will require </span><span><span class="kobospan" id="kobo.14.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><span class="kobospan" id="kobo.15.1">Java 21</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.16.1">Git</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.17.1">Maven</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.18.1">Any </span><span><span class="kobospan" id="kobo.19.1">preferred IDE</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.20.1">This chapter’s GitHub repository, found </span><span><span class="kobospan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10" class="calibre4 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.22.1">https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10</span></span></a></li>
</ul>
<h1 id="_idParaDest-125" class="calibre6"><a id="_idTextAnchor174" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.23.1">Overview of reflection</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">Reflection, a fundamental feature of the Java programming language, bestows upon developers the ability to inspect and manipulate the structure, behavior, and metadata of classes and objects at</span><a id="_idIndexMarker527" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.25.1"> runtime. </span><span class="kobospan" id="kobo.25.2">This dynamic capability might open a Pandora’s box of possibilities, allowing programmers to transcend the confines of static code and respond to the evolving needs of their applications. </span><span class="kobospan" id="kobo.25.3">Why is reflection so crucial to </span><span><span class="kobospan" id="kobo.26.1">Java development?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">Reflection in Java finds practical use in specialized scenarios, such as framework and library development, empowering </span><a id="_idIndexMarker528" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.28.1">developers to create flexible and extensible code. </span><span class="kobospan" id="kobo.28.2">It plays a pivotal role in </span><strong class="bold"><span class="kobospan" id="kobo.29.1">dependency injection</span></strong><span class="kobospan" id="kobo.30.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.31.1">DI</span></strong><span class="kobospan" id="kobo.32.1">) containers, </span><strong class="bold"><span class="kobospan" id="kobo.33.1">object-relational mapping</span></strong><span class="kobospan" id="kobo.34.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.35.1">ORM</span></strong><span class="kobospan" id="kobo.36.1">) frameworks, and testing frameworks, enabling dynamic class </span><a id="_idIndexMarker529" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.37.1">instantiation and configuration. </span><span class="kobospan" id="kobo.37.2">Reflection is also essential in serialization and deserialization libraries, GUI development tools, and Java’s core libraries, contributing to the dynamic loading and manipulation of objects and classes. </span><span class="kobospan" id="kobo.37.3">While it may not be a daily tool for most developers, reflection proves its worth in enhancing code reusability and adaptability in specific domains, making it an invaluable asset in the </span><span><span class="kobospan" id="kobo.38.1">Java ecosystem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">At its core, reflection plays a pivotal role in achieving introspection, enabling programs to examine and adapt to their structure. </span><span class="kobospan" id="kobo.39.2">It becomes particularly valuable when dealing with frameworks, libraries, and tools that must operate generically and flexibly, accommodating various types and structures dynamically. </span><span class="kobospan" id="kobo.39.3">Reflection facilitates the retrieval of class information, method signatures, and field details, offering a level of dynamism essential for scenarios where a deep understanding of the code base at runtime </span><span><span class="kobospan" id="kobo.40.1">is paramount.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">Moreover, reflection fuels the development of tools such as IDEs, debuggers, and application servers, providing them with the means to analyze and manipulate Java code in a manner that transcends the constraints of compile-time knowledge. </span><span class="kobospan" id="kobo.41.2">By offering a programmatic interface to class information and facilitating dynamic instantiation, reflection lays the groundwork for sophisticated frameworks and </span><span><span class="kobospan" id="kobo.42.1">runtime environments.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">While reflection is a distinctive feature of Java, similar concepts exist in other programming languages. </span><span class="kobospan" id="kobo.43.2">For example, languages such as Python, C#, and Ruby also embrace reflective capabilities to varying extents. </span><span class="kobospan" id="kobo.43.3">In Python, the </span><strong class="source-inline"><span class="kobospan" id="kobo.44.1">inspect</span></strong><span class="kobospan" id="kobo.45.1"> module allows for runtime introspection, while C# incorporates reflection for dynamic type discovery and invocation. </span><span class="kobospan" id="kobo.45.2">Understanding reflection in the broader context of programming languages provides developers with a versatile skill set that can be applied across different technological landscapes. </span><span class="kobospan" id="kobo.45.3">As we delve deeper into this chapter, we will unravel the intricacies of Java’s Reflection API, exploring its nuances and applications that make it a cornerstone of dynamic and </span><span><span class="kobospan" id="kobo.46.1">adaptable programming.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.47.1">While the Java Reflection </span><a id="_idIndexMarker530" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.48.1">API empowers developers with dynamic capabilities, it has a set of trade-offs that should be carefully considered. </span><span class="kobospan" id="kobo.48.2">Understanding these trade-offs is crucial for making informed decisions about when to leverage reflection and when to seek </span><span><span class="kobospan" id="kobo.49.1">alternative approaches:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.50.1">Performance overhead</span></strong><span class="kobospan" id="kobo.51.1">: One of the</span><a id="_idIndexMarker531" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.52.1"> primary trade-offs associated with reflection is its performance overhead. </span><span class="kobospan" id="kobo.52.2">Reflective operations, such as accessing fields, invoking methods, or creating instances dynamically, are generally slower than their non-reflective counterparts. </span><span class="kobospan" id="kobo.52.3">Reflection involves runtime type checking and method resolution, which can incur additional computational costs. </span><span class="kobospan" id="kobo.52.4">Consequently, in performance-critical applications or situations where rapid execution is paramount, relying excessively on reflection may lead to </span><span><span class="kobospan" id="kobo.53.1">suboptimal performance.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.54.1">Compile-time safety</span></strong><span class="kobospan" id="kobo.55.1">: Reflection bypasses some of Java’s compile-time checks. </span><span class="kobospan" id="kobo.55.2">Since reflection allows for dynamic access to classes, fields, and methods, the compiler cannot catch certain errors until runtime. </span><span class="kobospan" id="kobo.55.3">This lack of compile-time safety increases the likelihood of runtime exceptions, making the code more error-prone. </span><span class="kobospan" id="kobo.55.4">When using reflection, developers must be vigilant in handling potential issues such as missing classes, methods, or </span><span><span class="kobospan" id="kobo.56.1">type mismatches.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.57.1">Code readability and maintenance</span></strong><span class="kobospan" id="kobo.58.1">: Reflective code can be more challenging to read and maintain. </span><span class="kobospan" id="kobo.58.2">The absence of explicit type information in reflective operations makes the code less self-documenting, and it may be harder for developers to understand the program’s structure and behavior. </span><span class="kobospan" id="kobo.58.3">It can increase complexity and reduce maintainability, especially in larger code bases where reflection </span><span><span class="kobospan" id="kobo.59.1">is pervasive.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.60.1">Security concerns</span></strong><span class="kobospan" id="kobo.61.1">: Reflection can introduce security risks, especially in environments where security is a top priority, such as web applications. </span><span class="kobospan" id="kobo.61.2">By dynamically accessing and manipulating classes and methods, reflective code can potentially violate access controls and security constraints. </span><span class="kobospan" id="kobo.61.3">Careful consideration and validation are necessary to ensure that reflective operations do not compromise the</span><a id="_idIndexMarker532" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.62.1"> integrity and security of </span><span><span class="kobospan" id="kobo.63.1">the application.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.64.1">Platform dependence</span></strong><span class="kobospan" id="kobo.65.1">: Reflection might be platform-dependent, and certain reflective operations may behave differently on different JVM implementations. </span><span class="kobospan" id="kobo.65.2">It can introduce challenges in writing portable and cross-platform code. </span><span class="kobospan" id="kobo.65.3">Developers should be cautious when relying on reflection in scenarios where platform independence is a </span><span><span class="kobospan" id="kobo.66.1">critical requirement.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">While reflection provides powerful mechanisms for dynamic code manipulation, developers should weigh</span><a id="_idIndexMarker533" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.68.1"> its advantages against these trade-offs. </span><span class="kobospan" id="kobo.68.2">It is essential to use review judiciously, considering factors such as performance requirements, code maintainability, and security implications to balance flexibility and the potential drawbacks associated with </span><span><span class="kobospan" id="kobo.69.1">reflective programming.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">From a framework perspective, reflection is often intertwined with a broader set of processes to dynamically understand and interact with the structure of Java classes and objects. </span><span class="kobospan" id="kobo.70.2">Let’s break down the reflection process within a framework, considering a hypothetical scenario illustrated in </span><span><span class="kobospan" id="kobo.71.1">this step-by-step:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.72.1">Framework initialization and reflection engine loading</span></strong><span class="kobospan" id="kobo.73.1">: The process begins with the initialization of the framework. </span><span class="kobospan" id="kobo.73.2">At this stage, the framework’s core components, including the reflection engine, are loaded into the runtime environment (Ruime). </span><span class="kobospan" id="kobo.73.3">The reflection engine is how the framework dynamically interacts with and manipulates classes </span><span><span class="kobospan" id="kobo.74.1">and objects.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.75.1">Code compilation and annotation processing</span></strong><span class="kobospan" id="kobo.76.1">: Developers write code that includes annotations and reflection-related elements. </span><span class="kobospan" id="kobo.76.2">This code undergoes the standard Java compilation process. </span><span class="kobospan" id="kobo.76.3">During compilation, the Java compiler reads the source code, processes annotations, and </span><span><span class="kobospan" id="kobo.77.1">generates bytecode.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.78.1">Loading classes into Ruime</span></strong><span class="kobospan" id="kobo.79.1">: Ruime, the runtime environment, is responsible for loading the compiled classes into memory. </span><span class="kobospan" id="kobo.79.2">As part of this process, the reflection engine within Ruime gains awareness of the available classes and </span><span><span class="kobospan" id="kobo.80.1">their structure.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.81.1">Reflection engine reads annotations</span></strong><span class="kobospan" id="kobo.82.1">: The reflection engine, now aware of the loaded classes, begins to scan for annotations within these classes. </span><span class="kobospan" id="kobo.82.2">Annotations are metadata that provides additional information about the code and plays a crucial role in reflective frameworks. </span><span class="kobospan" id="kobo.82.3">The reflection engine reads and interprets these</span><a id="_idIndexMarker534" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.83.1"> annotations to dynamically understand how to interact with the </span><span><span class="kobospan" id="kobo.84.1">annotated elements.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.85.1">Dependency tree generation</span></strong><span class="kobospan" id="kobo.86.1">: The reflection engine generates a dependency tree based on information gathered from annotations and other reflective elements. </span><span class="kobospan" id="kobo.86.2">This tree outlines the relationships between classes, methods, and fields, providing a dynamic blueprint of the program’s structure. </span><span class="kobospan" id="kobo.86.3">The tree serves as a guide for the framework to navigate and manipulate the code </span><span><span class="kobospan" id="kobo.87.1">at runtime.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.88.1">Execution of dynamic code</span></strong><span class="kobospan" id="kobo.89.1">: The framework can now dynamically execute code with the dependency tree in place. </span><span class="kobospan" id="kobo.89.2">It could involve creating instances of classes, invoking methods, or accessing fields based on runtime information gathered through reflection. </span><span class="kobospan" id="kobo.89.3">The framework leverages the reflective capabilities to adapt its behavior dynamically, responding to the specific conditions encountered </span><span><span class="kobospan" id="kobo.90.1">during runtime.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.91.1">As JVM initializes, the reflection engine loads, setting the stage for a code compilation ballet. </span><span class="kobospan" id="kobo.91.2">Annotations, the silent choreographers, guide the reflection engine through loaded classes. </span><span class="kobospan" id="kobo.91.3">In JVM memory, a dependency tree emerges, a blueprint of the runtime structure. </span><span class="kobospan" id="kobo.91.4">This ethereal map becomes the key to dynamic execution, where the framework adapts in real time. </span><span class="kobospan" id="kobo.91.5">Arrows trace the fluid path from class loading to execution, encapsulating the transformative essence of reflective frameworks. </span><span class="kobospan" id="kobo.91.6">Behold the graphic ode to </span><span><span class="kobospan" id="kobo.92.1">dynamic prowess:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer046">
<span class="kobospan" id="kobo.93.1"><img alt="Figure 10.1: The Java perspective using reflection" src="image/B22030_10_01.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.94.1">Figure 10.1: The Java perspective using reflection</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">As we conclude this part, the intricacies of reflection within a framework unfold like a well-choreographed performance. </span><span class="kobospan" id="kobo.95.2">The journey from framework initialization to dynamic code execution, guided by the reflection engine and annotated insights, paints a vivid picture of adaptability </span><a id="_idIndexMarker535" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.96.1">and versatility. </span><span class="kobospan" id="kobo.96.2">Now, armed with an understanding of reflection’s role in shaping runtime dynamics, we transition seamlessly into the next section, where theory transforms into practice. </span><span class="kobospan" id="kobo.96.3">Brace yourself for a hands-on exploration of the Reflection API, where we will delve into real-world scenarios, demonstrating how to leverage reflection for field access, method invocation, and the strategic use of proxies. </span><span class="kobospan" id="kobo.96.4">Through practical examples, we will bridge the conceptual foundations laid in this chapter with tangible applications, empowering you to wield reflection as a powerful tool in your Java development arsenal. </span><span class="kobospan" id="kobo.96.5">Get ready to witness the Reflection API in action, breathing life into the theoretical constructs we’ve explored </span><span><span class="kobospan" id="kobo.97.1">th</span><a id="_idTextAnchor175" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.98.1">us far.</span></span></p>
<h1 id="_idParaDest-126" class="calibre6"><a id="_idTextAnchor176" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.99.1">Exploring practical reflection</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.100.1">In this hands-on</span><a id="_idIndexMarker536" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.101.1"> section, we delve into the practical application of Java’s Reflection API by creating a versatile </span><strong class="source-inline"><span class="kobospan" id="kobo.102.1">Mapper</span></strong><span class="kobospan" id="kobo.103.1"> interface. </span><span class="kobospan" id="kobo.103.2">We aim to implement methods that dynamically convert objects of a given class to and from </span><strong class="source-inline"><span class="kobospan" id="kobo.104.1">Map&lt;String, Object&gt;</span></strong><span class="kobospan" id="kobo.105.1">. </span><span class="kobospan" id="kobo.105.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.106.1">Mapper</span></strong><span class="kobospan" id="kobo.107.1"> interface serves as a blueprint for a generic solution, allowing us to flex the muscles of reflection in a </span><span><span class="kobospan" id="kobo.108.1">real-world scenario.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.109.1">Let’s begin with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.110.1">Mapper</span></strong></span><span><span class="kobospan" id="kobo.111.1"> interface:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.112.1">
public interface Mapper {    &lt;T&gt; Map&lt;String, Object&gt; toMap(T entity);
    &lt;T&gt; T toEntity(Map&lt;String, Object&gt; map);
}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.113.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.114.1">toMap</span></strong><span class="kobospan" id="kobo.115.1"> method is designed to convert an object of type </span><strong class="source-inline"><span class="kobospan" id="kobo.116.1">T</span></strong><span class="kobospan" id="kobo.117.1"> into a map, where each key-value pair represents a field name and its corresponding value. </span><span class="kobospan" id="kobo.117.2">Conversely, the </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">toEntity</span></strong><span class="kobospan" id="kobo.119.1"> method reverses this process, reconstructing an object of type </span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">T</span></strong><span class="kobospan" id="kobo.121.1"> from a </span><span><span class="kobospan" id="kobo.122.1">given map.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.123.1">Now, armed with the theory from the previous part, we’ll put reflection into practice to implement these methods. </span><span class="kobospan" id="kobo.123.2">Our journey will involve dynamically inspecting class structures, accessing </span><a id="_idIndexMarker537" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.124.1">fields, and creating instances at runtime. </span><span class="kobospan" id="kobo.124.2">Through hands-on coding exercises, we aim to demystify the power of reflection and showcase its practical utility in building flexible and </span><span><span class="kobospan" id="kobo.125.1">adaptable solutions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.126.1">So, buckle up for an engaging session where we bridge the gap between theory and application, crafting a dynamic </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">Mapper</span></strong><span class="kobospan" id="kobo.128.1"> interface that transforms objects into maps and back again using the magic of reflection. </span><span class="kobospan" id="kobo.128.2">Let’s dive into the fascinating world of practical reflection and witness the code </span><span><span class="kobospan" id="kobo.129.1">in action!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.130.1">In the ever-evolving landscape of technology, seamless migration between different paradigms often requires bridging conventions. </span><span class="kobospan" id="kobo.130.2">A common challenge arises with varying naming conventions, such as Java’s camel case and certain databases’ snake case preferences. </span><span class="kobospan" id="kobo.130.3">To tackle this, we introduce the </span><strong class="source-inline"><span class="kobospan" id="kobo.131.1">Column</span></strong><span class="kobospan" id="kobo.132.1"> annotation, allowing developers to define custom column names during </span><span><span class="kobospan" id="kobo.133.1">object-to-map conversion.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.134.1">Let’s take a closer look at the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">Column</span></strong></span><span><span class="kobospan" id="kobo.136.1"> annotation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.137.1">
@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)
public @interface Column {
    String value() default "";
}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.138.1">This annotation, applicable to fields (</span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">ElementType.FIELD</span></strong><span class="kobospan" id="kobo.140.1">), carries a </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">value</span></strong><span class="kobospan" id="kobo.142.1"> attribute. </span><span class="kobospan" id="kobo.142.2">If provided, this attribute allows developers to specify a custom column name; otherwise, the field name is used by default. </span><span class="kobospan" id="kobo.142.3">This flexibility enables a seamless mapping between Java objects and database structures, accommodating diverse </span><span><span class="kobospan" id="kobo.143.1">naming conventions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.144.1">Additionally, to mark a class as eligible for parsing, we introduce the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.145.1">Entity</span></strong></span><span><span class="kobospan" id="kobo.146.1"> annotation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.147.1">
@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)
public @interface Entity {
}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.148.1">Applied to the class level (</span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">ElementType.TYPE</span></strong><span class="kobospan" id="kobo.150.1">), this annotation signals that the class can undergo parsing</span><a id="_idIndexMarker538" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.151.1"> operations. </span><span class="kobospan" id="kobo.151.2">These annotations, when combined, empower developers to annotate their Java classes selectively, tailoring the conversion process based on the specific requirements of </span><span><span class="kobospan" id="kobo.152.1">each class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.153.1">We introduce the </span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">Appends</span></strong><span class="kobospan" id="kobo.155.1"> annotation to enhance flexibility and customization within our </span><strong class="source-inline"><span class="kobospan" id="kobo.156.1">Mapper</span></strong><span class="kobospan" id="kobo.157.1"> framework. </span><span class="kobospan" id="kobo.157.2">This annotation, along with its companion </span><strong class="source-inline"><span class="kobospan" id="kobo.158.1">Append</span></strong><span class="kobospan" id="kobo.159.1"> annotation, provides a means to define default values for entities, enriching the object-to-map </span><span><span class="kobospan" id="kobo.160.1">conversion process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.161.1">Let’s delve into the definitions of </span><span><span class="kobospan" id="kobo.162.1">these annotations:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.163.1">
@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)
public @interface Appends {
    Append[] value();
}
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Repeatable(Appends.class)
public @interface Append {
    String key();
    String value();
}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.164.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.165.1">Appends</span></strong><span class="kobospan" id="kobo.166.1"> annotation, applied at the class level (</span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">ElementType.TYPE</span></strong><span class="kobospan" id="kobo.168.1">), holds an array of </span><strong class="source-inline"><span class="kobospan" id="kobo.169.1">Append</span></strong><span class="kobospan" id="kobo.170.1"> annotations. </span><span class="kobospan" id="kobo.170.2">Each </span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">Append</span></strong><span class="kobospan" id="kobo.172.1"> annotation, in turn, allows developers to specify a key-value pair, indicating the default values to be appended during the object-to-map </span><span><span class="kobospan" id="kobo.173.1">conversion process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">Append</span></strong><span class="kobospan" id="kobo.176.1"> annotation is marked as repeatable (</span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">@Repeatable(Appends.class)</span></strong><span class="kobospan" id="kobo.178.1">) to simplify the specification of multiple append values on a </span><span><span class="kobospan" id="kobo.179.1">single entity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.180.1">In the dynamic landscape of Java development, seamlessly converting objects to maps and vice versa is a powerful feature, especially when navigating diverse naming conventions or</span><a id="_idIndexMarker539" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.181.1"> dealing with data migration scenarios. </span><span class="kobospan" id="kobo.181.2">Implementing the </span><strong class="source-inline"><span class="kobospan" id="kobo.182.1">toEntity</span></strong><span class="kobospan" id="kobo.183.1"> method within the </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.185.1"> class marks a pivotal point in our journey through </span><span><span class="kobospan" id="kobo.186.1">reflection-driven mapping.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.187.1">This method bridges the map representation of an object and its reconstitution as a fully realized entity. </span><span class="kobospan" id="kobo.187.2">Through the lens of Java reflection, we embark on a step-by-step exploration, unraveling the intricacies of reconstructing an object from a map of its properties. </span><span class="kobospan" id="kobo.187.3">The following code shows the implementation </span><span><span class="kobospan" id="kobo.188.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">toEntity</span></strong></span><span><span class="kobospan" id="kobo.190.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.191.1">
@Overridepublic &lt;T&gt; T toEntity(Map&lt;String, Object&gt; map) {
    Objects.requireNonNull(map, "map is required");
    // Step 1: Obtain the fully qualified class name from the map
    T entity = getEntity(map.get(ENTITY_ENTRY).toString());
    // Step 2: Retrieve the class type of the entity
    Class&lt;?&gt; type = entity.getClass();
    // Step 3: Iterate over the declared fields of the class
    for (Field field : type.getDeclaredFields()) {
        // Step 4: Determine the key associated with the field using 
        // @Column annotation 
        String key = Optional.ofNullable(field.getAnnotation(Column.
</span><span class="kobospan1" id="kobo.191.2">          class))
                .map(Column::value)
                .filter(Predicate.not(String::isBlank))
                .orElse(field.getName());
        // Step 5: Retrieve the corresponding value from the map
        Optional&lt;Object&gt; value = Optional.ofNullable(map.get(key));
        // Step 6: Set the value in the object using reflection
        value.ifPresent(v -&gt; setValue(entity, field, v));
    }
    // Step 7: Return the reconstructed entity
    return entity;
}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.192.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.193.1">toEntity</span></strong><span class="kobospan" id="kobo.194.1"> method</span><a id="_idIndexMarker540" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.195.1"> reconstructs an entity from a map, dynamically mapping fields using reflection. </span><span class="kobospan" id="kobo.195.2">It ensures a non-null map, instantiates the entity using the provided class name, and iterates through the fields. </span><span class="kobospan" id="kobo.195.3">Key determination involves </span><strong class="source-inline"><span class="kobospan" id="kobo.196.1">@Column</span></strong><span class="kobospan" id="kobo.197.1"> annotations or field names. </span><span class="kobospan" id="kobo.197.2">Values are retrieved from the map and set in the object using reflection. </span><span class="kobospan" id="kobo.197.3">The method returns the reconstructed entity, exemplifying a concise and dynamic object </span><span><span class="kobospan" id="kobo.198.1">restoration process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.199.1">Here’s </span><span><span class="kobospan" id="kobo.200.1">an explanation:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.201.1">Map validation</span></strong></span><span><span class="kobospan" id="kobo.202.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.203.1">
Objects.requireNonNull(map, "map is required");</span></pre><p class="calibre3"><span class="kobospan" id="kobo.204.1">The method begins by ensuring that the input </span><strong class="source-inline"><span class="kobospan" id="kobo.205.1">map</span></strong><span class="kobospan" id="kobo.206.1"> instance is not null, throwing a </span><strong class="source-inline"><span class="kobospan" id="kobo.207.1">NullPointerException</span></strong><span class="kobospan" id="kobo.208.1"> exception with the specified error message if </span><span><span class="kobospan" id="kobo.209.1">it is.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.210.1">Entity instantiation</span></strong></span><span><span class="kobospan" id="kobo.211.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.212.1">
T entity = getEntity(map.get(ENTITY_ENTRY).toString());</span></pre><p class="calibre3"><span class="kobospan" id="kobo.213.1">Using the fully qualified class name stored in the map, the </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">getEntity</span></strong><span class="kobospan" id="kobo.215.1"> method is called to </span><a id="_idIndexMarker541" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.216.1">dynamically instantiate an object of type </span><strong class="source-inline"><span class="kobospan" id="kobo.217.1">T</span></strong><span class="kobospan" id="kobo.218.1"> (</span><span><span class="kobospan" id="kobo.219.1">the entity).</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.220.1">Class-type retrieval</span></strong></span><span><span class="kobospan" id="kobo.221.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.222.1">
Class&lt;?&gt; type = entity.getClass();</span></pre><p class="calibre3"><span class="kobospan" id="kobo.223.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">getClass</span></strong><span class="kobospan" id="kobo.225.1"> method is employed to obtain the runtime class of </span><span><span class="kobospan" id="kobo.226.1">the entity.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.227.1">Field iteration</span></strong></span><span><span class="kobospan" id="kobo.228.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.229.1">
for (Field field : type.getDeclaredFields()) {</span></pre><p class="calibre3"><span class="kobospan" id="kobo.230.1">The method iterates over the declared fields of </span><span><span class="kobospan" id="kobo.231.1">the class.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.232.1">Column </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.233.1">key determination</span></strong></span><span><span class="kobospan" id="kobo.234.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.235.1">
String key = Optional.ofNullable(field.getAnnotation(Column.class))        .map(Column::value)        .filter(Predicate.not(String::isBlank))        .orElse(field.getName());</span></pre><p class="calibre3"><span class="kobospan" id="kobo.236.1">For each field, it determines the key associated with it. </span><span class="kobospan" id="kobo.236.2">If the </span><strong class="source-inline"><span class="kobospan" id="kobo.237.1">Column</span></strong><span class="kobospan" id="kobo.238.1"> annotation is present, it uses the specified column name; otherwise, it defaults to the </span><span><span class="kobospan" id="kobo.239.1">field name.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.240.1">Value retrieval </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.241.1">and assignment</span></strong></span><span><span class="kobospan" id="kobo.242.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.243.1">
Optional&lt;Object&gt; value = Optional.ofNullable(map.get(key));value.ifPresent(v -&gt; setValue(entity, field, v));</span></pre><p class="calibre3"><span class="kobospan" id="kobo.244.1">It retrieves the corresponding value from the map using the determined key. </span><span class="kobospan" id="kobo.244.2">If a value is present, it utilizes the </span><strong class="source-inline"><span class="kobospan" id="kobo.245.1">setValue</span></strong><span class="kobospan" id="kobo.246.1"> method to set the value in the object </span><span><span class="kobospan" id="kobo.247.1">using reflection.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.248.1">Reconstructed entity</span></strong></span><span><span class="kobospan" id="kobo.249.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.250.1">
return entity;</span></pre><p class="calibre3"><span class="kobospan" id="kobo.251.1">Finally, the </span><a id="_idIndexMarker542" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.252.1">reconstructed entity is returned, now populated with values from the map based on the </span><span><span class="kobospan" id="kobo.253.1">reflection process.</span></span></p></li> </ul>
<p class="calibre3"><span class="kobospan" id="kobo.254.1">This method demonstrates the dynamic reconstruction of an object using reflection, considering the custom annotations (</span><strong class="source-inline"><span class="kobospan" id="kobo.255.1">@Column</span></strong><span class="kobospan" id="kobo.256.1">) for field-to-key mapping. </span><span class="kobospan" id="kobo.256.2">It showcases the flexibility of </span><strong class="source-inline"><span class="kobospan" id="kobo.257.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.258.1"> in adapting to diverse class structures during the object-to-map </span><span><span class="kobospan" id="kobo.259.1">conversion reversal.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.260.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.261.1">toMap</span></strong><span class="kobospan" id="kobo.262.1"> method within the </span><strong class="source-inline"><span class="kobospan" id="kobo.263.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.264.1"> class is critical in exploring dynamic mapping using Java reflection. </span><span class="kobospan" id="kobo.264.2">This method takes an object of type </span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">T</span></strong><span class="kobospan" id="kobo.266.1"> as input and dynamically converts it into a </span><strong class="source-inline"><span class="kobospan" id="kobo.267.1">Map&lt;String, Object&gt;</span></strong><span class="kobospan" id="kobo.268.1"> instance. </span><span class="kobospan" id="kobo.268.2">Let’s unravel the intricacies of this method step </span><span><span class="kobospan" id="kobo.269.1">by step:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.270.1">
@Overridepublic &lt;T&gt; Map&lt;String, Object&gt; toMap(T entity) {
    Objects.requireNonNull(entity, "entity is required");
    // Step 1: Initialize the map to store key-value pairs
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    // Step 2: Retrieve the class type of the entity
    Class&lt;?&gt; type = entity.getClass();
    map.put(ENTITY_ENTRY, type.getName());
    // Step 3: Iterate over the declared fields of the class
    for (Field field : type.getDeclaredFields()) {
        // Step 4: Set accessibility to true to allow access to 
        // private fields 
        field.setAccessible(true);
        // Step 5: Check for the presence of the @Column annotation
        Optional&lt;Column&gt; column = Optional.ofNullable(field.
</span><span class="kobospan1" id="kobo.270.2">          getAnnotation(Column.class));
        if (column.isPresent()) {
            // Step 6: Determine the key associated with the field 
            // using @Column annotation
            String key = column.map(Column::value)
                    .filter(Predicate.not(String::isBlank))
                    .orElse(field.getName());
            // Step 7: Retrieve the field value using reflection and 
            // add it to the map 
            Object value = getValue(entity, field);
            map.put(key, value);
        }
    }
    // Step 8: Process @Append annotations at the class level and add 
    // default values to the map 
    Append[] appends = type.getAnnotationsByType(Append.class);
    for (Append append : appends) {
        map.put(append.key(), append.value());
    }
    // Step 9: Return the resulting map
    return map;
}</span></pre>
<ul class="calibre15">
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.271.1">Explanation</span></strong></span><span><span class="kobospan" id="kobo.272.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.273.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">toMap</span></strong><span class="kobospan" id="kobo.275.1"> method utilizes reflection to dynamically convert Java objects into </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">Map&lt;String, Object&gt;</span></strong><span class="kobospan" id="kobo.277.1">. </span><span class="kobospan" id="kobo.277.2">It ensures non-null input, explores fields with </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">@Column</span></strong><span class="kobospan" id="kobo.279.1"> annotations, and </span><a id="_idIndexMarker543" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.280.1">maps their values. </span><span class="kobospan" id="kobo.280.2">Class-level </span><strong class="source-inline"><span class="kobospan" id="kobo.281.1">@Append</span></strong><span class="kobospan" id="kobo.282.1"> annotations contribute default key-value pairs. </span><span class="kobospan" id="kobo.282.2">This concise method exemplifies the efficiency of reflection for dynamic </span><span><span class="kobospan" id="kobo.283.1">object-to-map transformations.</span></span></p></li>
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.284.1">Input validation</span></strong></span><span><span class="kobospan" id="kobo.285.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.286.1">
Objects.requireNonNull(entity, "entity is required");</span></pre><p class="calibre3"><span class="kobospan" id="kobo.287.1">The method begins by ensuring that the input </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">entity</span></strong><span class="kobospan" id="kobo.289.1"> instance is not null, throwing a </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">NullPointerException</span></strong><span class="kobospan" id="kobo.291.1"> exception with the specified error message if </span><span><span class="kobospan" id="kobo.292.1">it is.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.293.1">Map initialization</span></strong></span><span><span class="kobospan" id="kobo.294.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.295.1">
Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></pre><p class="calibre3"><span class="kobospan" id="kobo.296.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.297.1">HashMap</span></strong><span class="kobospan" id="kobo.298.1"> instance is</span><a id="_idIndexMarker544" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.299.1"> initialized to store the key-value pairs representing the properties of </span><span><span class="kobospan" id="kobo.300.1">the object.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.301.1">Class-type retrieval</span></strong></span><span><span class="kobospan" id="kobo.302.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.303.1">
Class&lt;?&gt; type = entity.getClass();map.put(ENTITY_ENTRY, type.getName());</span></pre><p class="calibre3"><span class="kobospan" id="kobo.304.1">The method retrieves the runtime class of the entity and stores its fully qualified name in the map using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.305.1">ENTITY_ENTRY</span></strong></span><span><span class="kobospan" id="kobo.306.1"> key.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.307.1">Field iteration</span></strong></span><span><span class="kobospan" id="kobo.308.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.309.1">
for (Field field : type.getDeclaredFields()) {</span></pre><p class="calibre3"><span class="kobospan" id="kobo.310.1">The method iterates over the declared fields of </span><span><span class="kobospan" id="kobo.311.1">the class.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.312.1">Accessibility setting</span></strong></span><span><span class="kobospan" id="kobo.313.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.314.1">
field.setAccessible(true);</span></pre><p class="calibre3"><span class="kobospan" id="kobo.315.1">The accessibility of the field is set to </span><strong class="source-inline"><span class="kobospan" id="kobo.316.1">true</span></strong><span class="kobospan" id="kobo.317.1">, enabling access to </span><span><span class="kobospan" id="kobo.318.1">private fields.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.319.1">Column </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.320.1">annotation check</span></strong></span><span><span class="kobospan" id="kobo.321.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.322.1">
Optional&lt;Column&gt; column = Optional.ofNullable(field.getAnnotation(Column.class));if (column.isPresent()) {</span></pre><p class="calibre3"><span class="kobospan" id="kobo.323.1">For each field, it checks for the presence of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">Column</span></strong></span><span><span class="kobospan" id="kobo.325.1"> annotation.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.326.1">Column </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.327.1">key determination</span></strong></span><span><span class="kobospan" id="kobo.328.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.329.1">
String key = column.map(Column::value)        .filter(Predicate.not(String::isBlank))        .orElse(field.getName());</span></pre><p class="calibre3"><span class="kobospan" id="kobo.330.1">If the </span><strong class="source-inline"><span class="kobospan" id="kobo.331.1">Column</span></strong><span class="kobospan" id="kobo.332.1"> annotation is present, it determines the key associated with the field. </span><span class="kobospan" id="kobo.332.2">It uses the </span><a id="_idIndexMarker545" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.333.1">specified column name or defaults to the </span><span><span class="kobospan" id="kobo.334.1">field name.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.335.1">Value retrieval </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.336.1">and assignment</span></strong></span><span><span class="kobospan" id="kobo.337.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.338.1">
Object value = getValue(entity, field);map.put(key, value);</span></pre><p class="calibre3"><span class="kobospan" id="kobo.339.1">It retrieves the field value using the </span><strong class="source-inline"><span class="kobospan" id="kobo.340.1">getValue</span></strong><span class="kobospan" id="kobo.341.1"> method and adds the key-value pair to </span><span><span class="kobospan" id="kobo.342.1">the map.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.343.1">@Append </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.344.1">annotation processing</span></strong></span><span><span class="kobospan" id="kobo.345.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.346.1">
Append[] appends = type.getAnnotationsByType(Append.class);for (Append append : appends) {    map.put(append.key(), append.value());}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.347.1">It processes </span><strong class="source-inline"><span class="kobospan" id="kobo.348.1">@Append</span></strong><span class="kobospan" id="kobo.349.1"> annotations at the class level, adding default key-value pairs to </span><span><span class="kobospan" id="kobo.350.1">the map.</span></span></p></li> <li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.351.1">Resulting map</span></strong></span><span><span class="kobospan" id="kobo.352.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.353.1">
return map;</span></pre><p class="calibre3"><span class="kobospan" id="kobo.354.1">Finally, the resulting map, representing the object’s properties, </span><span><span class="kobospan" id="kobo.355.1">is returned.</span></span></p></li> </ul>
<p class="calibre3"><span class="kobospan" id="kobo.356.1">This </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">toMap</span></strong><span class="kobospan" id="kobo.358.1"> method exemplifies the adaptability of reflection in dynamically mapping object properties to a map. </span><span class="kobospan" id="kobo.358.2">It showcases how annotations and field-level details are harnessed to create a versatile and extensible mapping mechanism within the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">ReflectionMapper</span></strong></span><span><span class="kobospan" id="kobo.360.1"> class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.361.1">In our exploration of reflection-based mapping techniques, we’ll turn our attention to practical examples using two distinct entities: </span><strong class="source-inline"><span class="kobospan" id="kobo.362.1">Pet</span></strong><span class="kobospan" id="kobo.363.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.364.1">Fruit</span></strong><span class="kobospan" id="kobo.365.1">. </span><span class="kobospan" id="kobo.365.2">These entities are adorned with annotations that </span><a id="_idIndexMarker546" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.366.1">provide valuable insights into the dynamic capabilities of </span><strong class="source-inline"><span class="kobospan" id="kobo.367.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.368.1">. </span><span class="kobospan" id="kobo.368.2">Let’s delve into each entity, examining their structures and the annotations that will guide our </span><span><span class="kobospan" id="kobo.369.1">mapping journey:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.370.1">
@Entitypublic class Pet {
    @Column
    private String name;
    @Column
    private int age;
    // Constructors, getters, and setters...
</span><span class="kobospan1" id="kobo.370.2">}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.371.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.372.1">Pet</span></strong><span class="kobospan" id="kobo.373.1"> entity is a simple </span><strong class="bold"><span class="kobospan" id="kobo.374.1">Plain Old Java Object</span></strong><span class="kobospan" id="kobo.375.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.376.1">POJO</span></strong><span class="kobospan" id="kobo.377.1">) representing a pet. </span><span class="kobospan" id="kobo.377.2">It’s marked with the </span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">@Entity</span></strong><span class="kobospan" id="kobo.379.1"> annotation, signifying</span><a id="_idIndexMarker547" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.380.1"> its eligibility for reflection-based mapping. </span><span class="kobospan" id="kobo.380.2">Each field, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.381.1">name</span></strong><span class="kobospan" id="kobo.382.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.383.1">age</span></strong><span class="kobospan" id="kobo.384.1">, is tagged with </span><strong class="source-inline"><span class="kobospan" id="kobo.385.1">@Column</span></strong><span class="kobospan" id="kobo.386.1">, indicating their inclusion in the mapping process. </span><span class="kobospan" id="kobo.386.2">This straightforward structure serves as an excellent starting point for understanding how the </span><strong class="source-inline"><span class="kobospan" id="kobo.387.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.388.1"> class dynamically handles object-to-map conversion and </span><span><span class="kobospan" id="kobo.389.1">vice versa.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.390.1">The next step is the </span><strong class="source-inline"><span class="kobospan" id="kobo.391.1">Fruit</span></strong><span class="kobospan" id="kobo.392.1"> entity which has additional settings than the </span><span><span class="kobospan" id="kobo.393.1">previous class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.394.1">
@Entity@Append(key = "type", value = "Fruit")
@Append(key = "category", value = "Natural")
public class Fruit {
    @Column
    private String name;
    public Fruit(String name) {
        this.name = name;
    }
    @Deprecated
    public Fruit() {
    }
    public String name() {
        return name;
    }
    // Additional methods...
</span><span class="kobospan1" id="kobo.394.2">}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.395.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.396.1">Fruit</span></strong><span class="kobospan" id="kobo.397.1"> entity, on the other hand, not only carries the </span><strong class="source-inline"><span class="kobospan" id="kobo.398.1">@Entity</span></strong><span class="kobospan" id="kobo.399.1"> annotation but also leverages the </span><strong class="source-inline"><span class="kobospan" id="kobo.400.1">@Append</span></strong><span class="kobospan" id="kobo.401.1"> annotation at the class level. </span><span class="kobospan" id="kobo.401.2">This introduces default key-value pairs (</span><strong class="source-inline"><span class="kobospan" id="kobo.402.1">"type": "Fruit"</span></strong><span class="kobospan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.404.1">"category": "Natural"</span></strong><span class="kobospan" id="kobo.405.1">) during the mapping process. </span><span class="kobospan" id="kobo.405.2">The class showcases flexibility by including both a deprecated and non-deprecated </span><a id="_idIndexMarker548" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.406.1">constructor, highlighting how the </span><strong class="source-inline"><span class="kobospan" id="kobo.407.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.408.1"> class adapts to different </span><span><span class="kobospan" id="kobo.409.1">entity structures.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.410.1">In the upcoming sections, we will execute the </span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.412.1"> class on instances of these entities, unveiling the power of reflection in handling diverse class structures and annotations. </span><span class="kobospan" id="kobo.412.2">Through this practical application, we aim to provide a comprehensive understanding of how reflection can be harnessed for dynamic object-to-map conversion and reconstruction. </span><span class="kobospan" id="kobo.412.3">Let the mapping journey with </span><strong class="source-inline"><span class="kobospan" id="kobo.413.1">Pet</span></strong><span class="kobospan" id="kobo.414.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">Fruit</span></strong></span><span><span class="kobospan" id="kobo.416.1"> commence!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.417.1">To validate the practical application of the </span><strong class="source-inline"><span class="kobospan" id="kobo.418.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.419.1"> class on our diverse entities, we’ve devised a comprehensive </span><strong class="source-inline"><span class="kobospan" id="kobo.420.1">MapperTest</span></strong><span class="kobospan" id="kobo.421.1"> class. </span><span class="kobospan" id="kobo.421.2">This series of tests demonstrates the mapper’s ability to seamlessly convert entities to maps and reconstruct entities </span><a id="_idIndexMarker549" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.422.1">from maps, showcasing the flexibility and adaptability of reflection in dynamic </span><span><span class="kobospan" id="kobo.423.1">mapping scenarios:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.424.1">
class MapperTest {    private Mapper mapper;
    @BeforeEach
    public void setUp() {
        this.mapper = new ReflectionMapper();
    }
    @Test
    public void shouldConvertToMap() {
        // Test for converting Pet entity to map
        Pet ada = Pet.of("Ada", 8);
        Map&lt;String, Object&gt; map = mapper.toMap(ada);
        assertThat(map)
                .isNotNull()
                .isNotEmpty()
                .containsKeys("_entity", "name", "age")
                .containsEntry("name", "Ada")
                .containsEntry("age", 8)
                .containsEntry("_entity", Pet.class.getName());
    }
    @Test
    public void shouldConvertEntity() {
        // Test for converting map to Pet entity
        Map&lt;String, Object&gt; map = Map.of("_entity", Pet.class.
</span><span class="kobospan1" id="kobo.424.2">          getName() , "name", "Ada", "age", 8);
        Pet pet = mapper.toEntity(map);
        assertThat(pet).isNotNull()
                .isInstanceOf(Pet.class)
                .matches(p -&gt; p.name().equals("Ada"))
                .matches(p -&gt; p.age() == 8);
    }
    @Test
    public void shouldConvertEntityRepeatable() {
        // Test for converting Fruit entity with repeatable 
        // annotations to map 
        Fruit fruit = new Fruit("Banana");
        Map&lt;String, Object&gt; map = this.mapper.toMap(fruit);
        assertThat(map).isNotNull().isNotEmpty()
                .containsEntry("type", "Fruit")
                .containsEntry("category", "Natural")
                .containsEntry("name", "Banana")
                .containsEntry("_entity", Fruit.class.getName());
    }
}</span></pre>
<ul class="calibre15">
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.425.1">shouldConvertToMap</span></strong></span><span><span class="kobospan" id="kobo.426.1">:</span></span><ul class="calibre18"><li class="calibre14"><span class="kobospan" id="kobo.427.1">This test ensures that the </span><strong class="source-inline1"><span class="kobospan" id="kobo.428.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.429.1"> class can successfully convert a </span><strong class="source-inline1"><span class="kobospan" id="kobo.430.1">Pet</span></strong><span class="kobospan" id="kobo.431.1"> entity into </span><span><span class="kobospan" id="kobo.432.1">a map</span></span></li><li class="calibre14"><span class="kobospan" id="kobo.433.1">It verifies</span><a id="_idIndexMarker550" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.434.1"> specific keys’ presence and corresponding values in the </span><span><span class="kobospan" id="kobo.435.1">generated map</span></span></li></ul></li>
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.436.1">shouldConvertEntity</span></strong></span><span><span class="kobospan" id="kobo.437.1">:</span></span><ul class="calibre18"><li class="calibre14"><span class="kobospan" id="kobo.438.1">In this test, a map representing a </span><strong class="source-inline1"><span class="kobospan" id="kobo.439.1">Pet</span></strong><span class="kobospan" id="kobo.440.1"> entity is converted back into the original entity </span><span><span class="kobospan" id="kobo.441.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.442.1">ReflectionMapper</span></strong></span></li><li class="calibre14"><span class="kobospan" id="kobo.443.1">Assertions validate the correctness of the reconstructed </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.444.1">Pet</span></strong></span><span><span class="kobospan" id="kobo.445.1"> object</span></span></li></ul></li>
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.446.1">shouldConvertEntityRepeatable</span></strong></span><span><span class="kobospan" id="kobo.447.1">:</span></span><ul class="calibre18"><li class="calibre14"><span class="kobospan" id="kobo.448.1">This test focuses on converting a </span><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">Fruit</span></strong><span class="kobospan" id="kobo.450.1"> entity, which includes repeatable annotations, into </span><span><span class="kobospan" id="kobo.451.1">a map</span></span></li><li class="calibre14"><span class="kobospan" id="kobo.452.1">It verifies the presence of default key-value pairs and entity-specific values in the </span><span><span class="kobospan" id="kobo.453.1">resulting map</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.454.1">Through these tests, we aim to illustrate how the </span><strong class="source-inline"><span class="kobospan" id="kobo.455.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.456.1"> class seamlessly handles various entities, annotations, and object-to-map conversions, emphasizing the practical utility of reflection in dynamic mapping scenarios. </span><span class="kobospan" id="kobo.456.2">Let the testing commence, revealing the prowess of reflection </span><span><span class="kobospan" id="kobo.457.1">in action!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.458.1">In this section, we delved deep into the intricate world of reflection, unraveling its potential in dynamic object-to-map conversions through the lens of the </span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.460.1"> class. </span><span class="kobospan" id="kobo.460.2">We explored the reflection’s flexibility and adaptability, showcasing its prowess in handling diverse entity structures and annotations. </span><span class="kobospan" id="kobo.460.3">As we conclude this segment, we stand at the threshold of another fascinating realm—dynamic proxies. </span><span class="kobospan" id="kobo.460.4">The upcoming section will usher us into the world of </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">MapperRepository</span></strong><span class="kobospan" id="kobo.462.1">, where</span><a id="_idIndexMarker551" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.463.1"> we will harness the power of dynamic proxies to switch between entities and their map representations seamlessly. </span><span class="kobospan" id="kobo.463.2">Brace yourself for exploring the dynamic and versatile landscape of proxies as we unveil their role in enhancing </span><span><span class="kobospan" id="kobo.464.1">r</span><a id="_idTextAnchor177" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.465.1">eflection capabilities.</span></span></p>
<h1 id="_idParaDest-127" class="calibre6"><a id="_idTextAnchor178" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.466.1">Proxy</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.467.1">Dynamic proxies in Java are indispensable</span><a id="_idIndexMarker552" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.468.1"> tools that enable the creation of objects at runtime, implementing one or more interfaces, and intercepting method invocations. </span><span class="kobospan" id="kobo.468.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.469.1">MapperRepository</span></strong><span class="kobospan" id="kobo.470.1"> class introduces us to the profound utility of dynamic proxies, where their application becomes paramount in seamlessly switching between entities and their corresponding </span><span><span class="kobospan" id="kobo.471.1">map representations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.472.1">Dynamic proxies stand as veritable champions in the arsenal of Java’s runtime capabilities, offering a trove of advantages that elevate code’s adaptability, flexibility, and conciseness. </span><span class="kobospan" id="kobo.472.2">Their inherent adaptability allows for creating proxy instances on the fly, accommodating diverse interfaces at runtime, and facilitating seamless integration in scenarios where object structures are only known at runtime. </span><span class="kobospan" id="kobo.472.3">The ability to intercept method invocations empowers dynamic proxies to inject custom logic seamlessly, enhancing functionalities without compromising the integrity of core operations. </span><span class="kobospan" id="kobo.472.4">This interception mechanism enables </span><a id="_idIndexMarker553" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.473.1">cleaner </span><strong class="bold"><span class="kobospan" id="kobo.474.1">separation of concerns</span></strong><span class="kobospan" id="kobo.475.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.476.1">SoC</span></strong><span class="kobospan" id="kobo.477.1">) and contributes to reduced boilerplate code, promoting maintainability. </span><span class="kobospan" id="kobo.477.2">In the forthcoming exploration of </span><strong class="source-inline"><span class="kobospan" id="kobo.478.1">MapperRepository</span></strong><span class="kobospan" id="kobo.479.1">, dynamic proxies emerge as the linchpin, embodying the ethos of adaptability and efficiency in the dynamic </span><span><span class="kobospan" id="kobo.480.1">mapping landscape:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.481.1">Adaptability and flexibility</span></strong><span class="kobospan" id="kobo.482.1">: Dynamic proxies offer unparalleled adaptability, allowing us to create proxy instances for diverse interfaces at runtime. </span><span class="kobospan" id="kobo.482.2">This adaptability becomes crucial when dealing with scenarios where the structure of objects or interfaces is not known until runtime. </span><span class="kobospan" id="kobo.482.3">In the context of </span><strong class="source-inline1"><span class="kobospan" id="kobo.483.1">MapperRepository</span></strong><span class="kobospan" id="kobo.484.1">, dynamic proxies empower us to handle multiple entity types without a priori knowledge, fostering a more flexible and </span><span><span class="kobospan" id="kobo.485.1">extensible design.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.486.1">Interception of method invocations</span></strong><span class="kobospan" id="kobo.487.1">: One of the key advantages of dynamic proxies is their ability to intercept method calls. </span><span class="kobospan" id="kobo.487.2">This interception mechanism allows one to perform actions before and after method execution. </span><span class="kobospan" id="kobo.487.3">In the realm of mapping entities to maps and vice versa, this interception becomes instrumental. </span><span class="kobospan" id="kobo.487.4">It enables</span><a id="_idIndexMarker554" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.488.1"> us to seamlessly inject conversion logic, enhancing the mapping process without altering the core logic </span><span><span class="kobospan" id="kobo.489.1">of entities.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.490.1">Reduced boilerplate code</span></strong><span class="kobospan" id="kobo.491.1">: Dynamic proxies significantly reduce the need for boilerplate code. </span><span class="kobospan" id="kobo.491.2">They allow us to centralize cross-cutting concerns, such as logging or validation, by encapsulating these concerns within the proxy. </span><span class="kobospan" id="kobo.491.3">In the context of </span><strong class="source-inline1"><span class="kobospan" id="kobo.492.1">MapperRepository</span></strong><span class="kobospan" id="kobo.493.1">, this leads to cleaner, more concise code for the conversion between entities and maps, promoting maintainability </span><span><span class="kobospan" id="kobo.494.1">and readability.</span></span><p class="calibre3"><span class="kobospan" id="kobo.495.1">However powerful, the utilization of dynamic proxies in Java does not come without its set of considerations and trade-offs. </span><span class="kobospan" id="kobo.495.2">One of the primary trade-offs lies in the performance overhead incurred by the dynamic nature of proxies, as the interception of method calls and the runtime creation of proxy instances can introduce a slight execution delay compared to direct method calls. </span><span class="kobospan" id="kobo.495.3">Additionally, reliance on interface-based proxies restricts their application to scenarios involving interfaces, posing limitations in scenarios where class-based proxies may be more fitting. </span><span class="kobospan" id="kobo.495.4">Recognizing these trade-offs is paramount, as it allows for informed decision-making when implementing dynamic proxies, especially in performance-sensitive contexts. </span><span class="kobospan" id="kobo.495.5">Despite these considerations, the benefits offered by dynamic proxies, such as enhanced flexibility and reduced boilerplate code, often outweigh these trade-offs, reinforcing their indispensable role in dynamic and adaptable </span><span><span class="kobospan" id="kobo.496.1">Java applications.</span></span></p></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.497.1">Performance overhead</span></strong><span class="kobospan" id="kobo.498.1">: While dynamic proxies provide immense flexibility, their dynamic nature introduces a performance overhead. </span><span class="kobospan" id="kobo.498.2">The interception of method calls and the creation of proxy instances at runtime can lead to slightly slower execution compared to direct method calls. </span><span class="kobospan" id="kobo.498.3">Careful consideration is required when applying dynamic proxies in </span><span><span class="kobospan" id="kobo.499.1">performance-critical scenarios.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.500.1">Limitations on class-based proxies</span></strong><span class="kobospan" id="kobo.501.1">: Dynamic proxies in Java are interface-based, limiting their application to scenarios involving interfaces. </span><span class="kobospan" id="kobo.501.2">Class-based proxies are not as</span><a id="_idIndexMarker555" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.502.1"> prevalent, and certain scenarios may require alternative solutions or compromises. </span><span class="kobospan" id="kobo.502.2">Understanding these limitations is crucial for making informed decisions in design </span><span><span class="kobospan" id="kobo.503.1">and implementation.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">In the ever-evolving landscape of Java, </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">MapperRepository</span></strong><span class="kobospan" id="kobo.506.1"> emerges as a pivotal interface, seamlessly intertwining the capabilities of reflection and dynamic proxies. </span><span class="kobospan" id="kobo.506.2">This interface serves as a gateway to the dynamic world of object-to-map conversions and vice versa, harnessing the intrinsic power of reflection to navigate and manipulate entities </span><span><span class="kobospan" id="kobo.507.1">at runtime:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.508.1">
public interface MapperRepository {    &lt;T&gt; T entity(Map&lt;String, Object&gt; map);
    &lt;T&gt; Map&lt;String, Object&gt; map(T entity);
}</span></pre>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.509.1">Interface description</span></strong></span><span><span class="kobospan" id="kobo.510.1">:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.511.1">entity</span></strong><span class="kobospan" id="kobo.512.1">: This method takes a map representing an object’s properties and dynamically reconstructs an object of type </span><strong class="source-inline1"><span class="kobospan" id="kobo.513.1">T</span></strong><span class="kobospan" id="kobo.514.1"> at runtime. </span><span class="kobospan" id="kobo.514.2">Leveraging reflection, it navigates through the map, creating a dynamic proxy entity that adapts to the structure of the </span><span><span class="kobospan" id="kobo.515.1">provided map.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.516.1">map</span></strong><span class="kobospan" id="kobo.517.1">: Conversely, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.518.1">map</span></strong><span class="kobospan" id="kobo.519.1"> method accepts an entity of type </span><strong class="source-inline1"><span class="kobospan" id="kobo.520.1">T</span></strong><span class="kobospan" id="kobo.521.1"> and dynamically generates a map representing its properties. </span><span class="kobospan" id="kobo.521.2">Through reflection and dynamic proxies, this method navigates the entity’s structure, creating a map that encapsulates the key-value pairs of </span><span><span class="kobospan" id="kobo.522.1">its properties.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.523.1">The true prowess of </span><strong class="source-inline"><span class="kobospan" id="kobo.524.1">MapperRepository</span></strong><span class="kobospan" id="kobo.525.1"> lies in its symbiotic relationship with reflection. </span><span class="kobospan" id="kobo.525.2">When reconstructing entities from maps, reflection allows the dynamic exploration of the object’s structure, identifying fields, methods, and annotations. </span><span class="kobospan" id="kobo.525.3">This exploration and dynamic proxies enable seamless adaptation to varying entity types, rendering </span><strong class="source-inline"><span class="kobospan" id="kobo.526.1">MapperRepository</span></strong><span class="kobospan" id="kobo.527.1"> a versatile tool for </span><span><span class="kobospan" id="kobo.528.1">dynamic mappings.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.529.1">On the reverse journey, when converting entities to maps, reflection plays a pivotal role in introspecting the object’s structure. </span><span class="kobospan" id="kobo.529.2">Information gleaned through reflection guides the creation of a map that accurately represents the object’s properties. </span><span class="kobospan" id="kobo.529.3">Dynamic proxies enhance this process by intercepting method invocations, allowing for custom logic injection, and providing a dynamic approach to </span><span><span class="kobospan" id="kobo.530.1">object-to-map conversion.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.531.1">As our journey into </span><a id="_idIndexMarker556" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.532.1">dynamic proxies and reflection with </span><strong class="source-inline"><span class="kobospan" id="kobo.533.1">MapperRepository</span></strong><span class="kobospan" id="kobo.534.1"> unfolds, we step into the implementation arena by introducing the </span><strong class="source-inline"><span class="kobospan" id="kobo.535.1">MapperInvocationHandler</span></strong><span class="kobospan" id="kobo.536.1"> class. </span><span class="kobospan" id="kobo.536.2">This implementation, serving as the </span><strong class="source-inline"><span class="kobospan" id="kobo.537.1">InvocationHandler</span></strong><span class="kobospan" id="kobo.538.1"> class for dynamic proxies, bridges the abstract realm of dynamic mappings defined in </span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">MapperRepository</span></strong><span class="kobospan" id="kobo.540.1"> to the concrete operations facilitated by the underlying </span><strong class="source-inline"><span class="kobospan" id="kobo.541.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.542.1"> class. </span><span class="kobospan" id="kobo.542.2">Let’s delve into the simplicity and power encapsulated within this handler, unlocking the potential for robust, customizable </span><span><span class="kobospan" id="kobo.543.1">dynamic mappings:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.544.1">
public class MapperInvocationHandler implements InvocationHandler {    private Mapper mapper = new ReflectionMapper();
    @Override
    public Object invoke(Object proxy, Method method, Object[] params) 
      throws Throwable {
        String name = method.getName();
        switch (name) {
            case "entity":
                Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) 
                  params[0];
                Objects.requireNonNull(map, "map is required");
                return mapper.toEntity(map);
            case "map":
                Object entity = params[0];
                Objects.requireNonNull(entity, "entity is required");
                return mapper.toMap(entity);
        }
        if(method.isDefault()) {
            return InvocationHandler.invokeDefault(proxy, method, 
              params);
        }
        throw new UnsupportedOperationException("The proxy is not 
          supported for the method: " + method);
    }
}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.545.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.546.1">MapperInvocationHandler</span></strong><span class="kobospan" id="kobo.547.1"> class, implementing </span><strong class="source-inline"><span class="kobospan" id="kobo.548.1">InvocationHandler</span></strong><span class="kobospan" id="kobo.549.1">, mediates dynamic mappings. </span><span class="kobospan" id="kobo.549.2">It uses a </span><strong class="source-inline"><span class="kobospan" id="kobo.550.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.551.1"> instance to convert maps to entities or entities to </span><a id="_idIndexMarker557" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.552.1">maps based on method calls. </span><span class="kobospan" id="kobo.552.2">The handler supports default methods and ensures a smooth connection between dynamic proxies and the underlying </span><span><span class="kobospan" id="kobo.553.1">mapping logic:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.554.1">Dynamic method routing</span></strong><span class="kobospan" id="kobo.555.1">: The </span><strong class="source-inline1"><span class="kobospan" id="kobo.556.1">invoke</span></strong><span class="kobospan" id="kobo.557.1"> method dynamically routes method calls based on their names. </span><span class="kobospan" id="kobo.557.2">For the </span><strong class="source-inline1"><span class="kobospan" id="kobo.558.1">entity</span></strong><span class="kobospan" id="kobo.559.1"> method, it extracts the map from the provided parameters and delegates the operation to </span><strong class="source-inline1"><span class="kobospan" id="kobo.560.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.561.1"> for entity reconstruction. </span><span class="kobospan" id="kobo.561.2">Conversely, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.562.1">map</span></strong><span class="kobospan" id="kobo.563.1"> method, it extracts the entity and delegates it to </span><strong class="source-inline1"><span class="kobospan" id="kobo.564.1">ReflectionMapper</span></strong><span class="kobospan" id="kobo.565.1"> for </span><span><span class="kobospan" id="kobo.566.1">map creation.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.567.1">Handling default methods</span></strong><span class="kobospan" id="kobo.568.1">: The handler accounts for default methods in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.569.1">MapperRepository</span></strong><span class="kobospan" id="kobo.570.1"> interface. </span><span class="kobospan" id="kobo.570.2">If a default method is invoked, it gracefully delegates the call </span><span><span class="kobospan" id="kobo.571.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.572.1">InvocationHandler.invokeDefault</span></strong></span><span><span class="kobospan" id="kobo.573.1">.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.574.1">Exception handling</span></strong><span class="kobospan" id="kobo.575.1">: In cases where an unsupported method is encountered, an </span><strong class="source-inline1"><span class="kobospan" id="kobo.576.1">UnsupportedOperationException</span></strong><span class="kobospan" id="kobo.577.1"> exception is thrown, providing clear feedback on the limitations of the dynamic proxy in handling </span><span><span class="kobospan" id="kobo.578.1">certain operations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.579.1">One of the standout features of this implementation lies in its potential for customizability. </span><span class="kobospan" id="kobo.579.2">Extending</span><a id="_idIndexMarker558" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.580.1"> the logic within each method case makes it feasible to check annotation parameters, opening the door to many customization possibilities. </span><span class="kobospan" id="kobo.580.2">This approach transforms </span><strong class="source-inline"><span class="kobospan" id="kobo.581.1">MapperRepository</span></strong><span class="kobospan" id="kobo.582.1"> into a robust and adaptable tool, ready to cater to diverse mapping scenarios through the lens </span><span><span class="kobospan" id="kobo.583.1">of reflection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.584.1">In exploring dynamic proxies and reflection within the realm of </span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">MapperRepository</span></strong><span class="kobospan" id="kobo.586.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.587.1">MapperInvocationHandler</span></strong><span class="kobospan" id="kobo.588.1"> emerges as a linchpin, seamlessly connecting abstract mappings to concrete operations. </span><span class="kobospan" id="kobo.588.2">Its dynamic method routing and the ability to handle default methods make it a powerful orchestrator of dynamic mappings. </span><span class="kobospan" id="kobo.588.3">The simplicity of the implementation belies its potential for customization, offering a pathway to inspect annotation parameters and tailor the mapping process to diverse scenarios. </span><span class="kobospan" id="kobo.588.4">As we conclude this chapter, </span><strong class="source-inline"><span class="kobospan" id="kobo.589.1">MapperInvocationHandler</span></strong><span class="kobospan" id="kobo.590.1"> is a testament to the symbiotic relationship between dynamic proxies and reflection, showcasing their combined might in creating adaptable, customizable, and dynamic mapping solutions in Java. </span><span class="kobospan" id="kobo.590.2">The upcoming practical application will illuminate how this implementation transforms abstract concepts into a toolset that empowers developers to navigate the intricate landsca</span><a id="_idTextAnchor179" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.591.1">pe of dynamic </span><span><span class="kobospan" id="kobo.592.1">mappings easily.</span></span></p>
<h1 id="_idParaDest-128" class="calibre6"><a id="_idTextAnchor180" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.593.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">On our exploration of dynamic proxies and reflection, amalgamating these powerful Java features as </span><strong class="source-inline"><span class="kobospan" id="kobo.595.1">MapperInvocationHandler</span></strong><span class="kobospan" id="kobo.596.1"> marks a pivotal moment in our journey. </span><span class="kobospan" id="kobo.596.2">The ability to dynamically route method calls and the potential for customization through annotation parameters underscore the versatility encapsulated within this implementation. </span><span class="kobospan" id="kobo.596.3">Yet, this is merely a precursor to the next chapter, where we dive into the sophisticated realm of Java annotation processing. </span><span class="kobospan" id="kobo.596.4">Building upon the foundation of dynamic mappings, the annotation processor promises to elevate our capabilities further, offering a structured and compile-time approach to harnessing metadata within our code. </span><span class="kobospan" id="kobo.596.5">Join us in the upcoming chapter as we unveil the intricate world of Java annotation processing, where compile-time reflection becomes a cornerstone in crafting efficient, robust, and intelligentl</span><a id="_idTextAnchor181" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.597.1">y processed </span><span><span class="kobospan" id="kobo.598.1">Java applications.</span></span></p>
<h1 id="_idParaDest-129" class="calibre6"><a id="_idTextAnchor182" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.599.1">Questions</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.600.1">Answer the following questions to test your knowledge of </span><span><span class="kobospan" id="kobo.601.1">this chapter:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.602.1">What is the primary purpose of the MapperInvocationHandler class in the context of </span><span><span class="kobospan" id="kobo.603.1">dynamic proxies?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.604.1">Handling </span><span><span class="kobospan" id="kobo.605.1">database connections</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.606.1">Routing method calls for </span><span><span class="kobospan" id="kobo.607.1">dynamic mappings</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.608.1">Implementing complex </span><span><span class="kobospan" id="kobo.609.1">business logic</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.610.1">Parsing </span><span><span class="kobospan" id="kobo.611.1">XML configurations</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.612.1">Which feature makes dynamic proxies adaptable in scenarios where object structures are not known </span><span><span class="kobospan" id="kobo.613.1">until runtime?</span></span><ol class="calibre17"><li class="alphabets"><span><span class="kobospan" id="kobo.614.1">Method overloading</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.615.1">Interface-based implementation</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.616.1">Dynamic </span><span><span class="kobospan" id="kobo.617.1">method routing</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.618.1">Static </span><span><span class="kobospan" id="kobo.619.1">method invocation</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.620.1">How does the </span><strong class="source-inline1"><span class="kobospan" id="kobo.621.1">MapperInvocationHandler</span></strong><span class="kobospan" id="kobo.622.1"> class demonstrate customizability in the dynamic </span><span><span class="kobospan" id="kobo.623.1">mapping process?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.624.1">It uses hardcoded values for </span><span><span class="kobospan" id="kobo.625.1">method calls.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.626.1">It leverages external libraries </span><span><span class="kobospan" id="kobo.627.1">for mapping.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.628.1">It inspects annotation parameters and adapts the </span><span><span class="kobospan" id="kobo.629.1">mapping logic.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.630.1">It enforces strict immutability in </span><span><span class="kobospan" id="kobo.631.1">mapped entities.</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.632.1">What is the primary purpose of reflection </span><span><span class="kobospan" id="kobo.633.1">in Java?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.634.1">Compile-time </span><span><span class="kobospan" id="kobo.635.1">code optimization</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.636.1">Dynamic exploration and manipulation of </span><span><span class="kobospan" id="kobo.637.1">object structures</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.638.1">Secure encryption of </span><span><span class="kobospan" id="kobo.639.1">sensitive data</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.640.1">Asynchronous </span><span><span class="kobospan" id="kobo.641.1">event handling</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.642.1">In the context of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.643.1">MapperRepository</span></strong><span class="kobospan" id="kobo.644.1"> interface, how does reflection contribute to </span><span><span class="kobospan" id="kobo.645.1">dynamic mappings?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.646.1">It ensures type safety in </span><span><span class="kobospan" id="kobo.647.1">method calls.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.648.1">It provides a secure </span><span><span class="kobospan" id="kobo.649.1">encryption mechanism.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.650.1">It dynamically routes </span><span><span class="kobospan" id="kobo.651.1">method calls.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.652.1">It enforces strict immutability in </span><span><span class="kobospan" id="kobo.653.1">mapped entities.</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-130" class="calibre6"><a id="_idTextAnchor183" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.654.1">Answers</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.655.1">Here are the answers to this </span><span><span class="kobospan" id="kobo.656.1">chapter’s questions:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.657.1">B. </span><span class="kobospan" id="kobo.657.2">Routing method calls for </span><span><span class="kobospan" id="kobo.658.1">dynamic mappings</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.659.1">C. </span><span class="kobospan" id="kobo.659.2">Dynamic </span><span><span class="kobospan" id="kobo.660.1">method routing</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.661.1">C. </span><span class="kobospan" id="kobo.661.2">It inspects annotation parameters and adapts the </span><span><span class="kobospan" id="kobo.662.1">mapping logic.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.663.1">B. </span><span class="kobospan" id="kobo.663.2">Dynamic exploration and manipulation of </span><span><span class="kobospan" id="kobo.664.1">object structures</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.665.1">C. </span><span class="kobospan" id="kobo.665.2">It dynamically routes </span><span><span class="kobospan" id="kobo.666.1">method calls.</span></span></li>
</ol>
</div>
</body></html>