<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functional Data Structures</h1>
                </header>
            
            <article>
                
<p class="mce-root">Programming largely deals with data manipulation. Different styles of programming will treat data structures, and data itself, differently. For example, imperative programming treats data as mutable information stored in memory. We will see how the treatment of functional programming differs from that of imperative programming.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li style="font-weight: 400">Collections framework</li>
<li style="font-weight: 400">The algebraic approach</li>
<li style="font-weight: 400">Effect types</li>
<li style="font-weight: 400">Data structures in different programming languages</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collections framework</h1>
                </header>
            
            <article>
                
<p>When discussing data structures, it is only natural to start with collections. Collections are data structures that abstract away multiplicity. This means that whenever you have more than one item of a particular kind, and you want to run a number of operations on this data, you will need a proper abstraction—an abstraction that will establish the rules of the game you play when you encounter multiplicity.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It transpires that you will need to deal with abstraction of this nature <span>in nearly every programming project</span>. When you are dealing with strings, you frequently need to represent them as a collection of characters. Whenever you have a database application, and you have some queries in relation to this database, you need to present multiple results of these queries as collections. Whenever you are dealing with a text file, you may want to represent it as a list of lines. This happens rather frequently, for example, when dealing with configuration files. We specify our configuration entries as strings on separate lines. For example, the following is how we may represent a server connection configuration:</p>
<pre class="mce-root" style="padding-left: 30px">host=192.168.12.3<br/>port=8888<br/>username=root<br/>password=qwerty</pre>
<p>Or, for example, you may want to communicate data with a web API. Most modern web APIs communicate data in the form of JSON or XML. These are structured ways of representing data and, if you observe them closely, you will notice that they follow a pattern; for example, an XML file is composed of a tree of multiple nodes, and a JSON object may contain more than one entry.</p>
<p>So, whenever you are working on a programming project, it is very likely that you will need to deal with some kind of abstraction over multiplicity. You require a collections framework. Because collections are so ubiquitous, it is only natural that modern programming languages include a collection framework in their core library. This is why looking at a language's collections framework is an easy way to see the philosophy of the language and its approach to programming in general.</p>
<p>In this section, we will compare the collection frameworks of Java and Scala. Java represents a traditional, imperative approach to programming, and, hence, its collection framework also reflects this approach. On the other hand, Scala represents a functional, declarative approach to programming. Its collection framework is built and structured according to the philosophy of functional and declarative programming.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imperative collections</h1>
                </header>
            
            <article>
                
<p>Let's have a look at how collections are understood within the framework of an imperative programming language, while also looking at Java's abstraction of a list. Its API documentation is available at <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html.">https://docs.oracle.com/javase/8/docs/api/java/util/List.html</a>. This interface only has a limited number of methods defined. The first thing that we need to pay attention to here is mutability. Immediately, we see methods such as <kbd>add</kbd> and <kbd>remove</kbd>. This implies that this interface is supposed to be implemented by a mutable collection that is supposed to implement the operations that add or remove data from it. You should be aware that methods can throw an <kbd>UnsupportedOperationException</kbd>, which means that certain collections may implement this interface; however, they will not implement these two operations. Later in the book, we will see that functional programming does not welcome exceptions of this kind as they are a type of side effect and here, it is especially obvious why. One of the essential principles of object-oriented programming is polymorphism, which means that you can place an interface on top of a class and, from there, you are able to interact with this class according to this interface, without caring about the internal implementation. An interface is supposed to be a protocol of interaction with an object; it is supposed to specify which behavior it supports, and throwing an exception if a behavior is not supported is a rather clumsy move on the part of Java, since you need to bear in mind that certain behavior is not supported, even though the interface declares that it is. This further taxes the programmer's mind and, hence, it can lead to bugs.</p>
<p>Another peculiarity we should observe is that other methods defined here are quite low level. You have the ability to add to the collection and to remove from the collection. It is assumed that whatever you need to do with the collection, you will be able to do so with the help of these and other low-level methods that the interface provides. This is realized by writing an imperative algorithm that specifies how exactly to perform a necessary operation given the low-level primitives provided by the language. This, in turn, means that you must be skilled with algorithms to write effective Java programs, because the use of algorithms is the only option open to you.</p>
<p>In fact, it has long been a tradition in computer science and programming to focus extensively on algorithms. The data has been perceived as some kind of mutable information written in a certain medium, and the task of the programmer is to specify a sequence of steps to modify this data as per requirements. Hence, one of the first things people learn in computer science is sorting algorithms such as Bubble Sort.</p>
<p class="mce-root"/>
<p>Algorithms are certainly necessary. Under the hood of any computer program, algorithms are precisely what do the job. However, they are not the best way for humans to read, understand, and write programs. They are not the best way for humans to design programs since, due to their counter-intuitiveness, they can be error-prone.</p>
<p>Now, let's have a look at functional collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional collections</h1>
                </header>
            
            <article>
                
<p>It's quite a different picture in functional languages. Let's have a look at the same abstraction, the List, in Scala's library. Its API documentation is available at <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html">https://www.scala-lang.org/api/current/scala/collection/immutable/List.html</a>. It contains many more methods than can be found in Java's List. In contrast to the Java List interface, Scala's List abstraction is immutable. This means that once you have created a list, you are not able to modify it. All the modifications to the list can be implemented by just creating a modified copy of the list. This concept is referred to as structural sharing. This means that the objects that are members of the list are not copied, just that the structure of the list is recreated. Therefore, you do not need to worry about memory leaks because only the structure is newly created. The objects that are the members of the list are not recreated.</p>
<p>There is also an abundance of declarative methods – high-level primitives, for example, <kbd>filter</kbd>, <kbd>map</kbd>, and <kbd>flatMap</kbd>. In contrast to Java, these methods specify fairly high-level operations. In the previous chapter, we saw how it can be pretty tedious to define a filter operation in Java. In contrast, in Scala, it is sufficient to specify the name of the operation that you need to perform, and you don't need to worry about how this operation is implemented. This seems like the right moment to draw parallels with the <kbd>goto</kbd> statement. It is a remarkable property of modern programming languages; the programs that you can express with <kbd>goto</kbd> can also be expressed with the help of several control structures. In the same way, all collection programs can be expressed using around a dozen declarative high-level methods. You don't need to specify how to create a loop with <kbd>goto</kbd> every time you need a loop. Similarly, it is not necessary to specify collection operations such as <kbd>filter</kbd> if they can be named and implemented in a language's core library.</p>
<p>While Java and imperative languages focus on algorithmic reasoning, functional languages, such as Scala, focus on algebraic reasoning. This means they view data transformations as algebraic expressions. Data can be viewed as operands of some algebra, and it can be combined with other data and transformed to get new data with the help of high-level operators. Hence, programs are no longer defined <span>algorithmically</span>, but in terms of mathematical expressions; expressions that compute some value based on their input.</p>
<p class="mce-root"/>
<p>When programming in a declarative language, it is no longer necessary to be an expert in algorithms, as was the case with imperative languages such as Java. This is the case because all the algorithms that you may need are already implemented in the language's core library. Of course, when you call a declarative method, such as <kbd>filter</kbd>, on a Scala collection, an algorithm is executed under the hood. The beauty of this approach is that you do not need to be aware of this at all. You're provided with a high-level building block, and you need to express your program in terms of these building blocks. You do not need to worry about how the blocks are created.</p>
<p>There are a number of benefits compared to the imperative approach. You do not need to deal with algorithms that are hard to read and prone to bugs. Everything you need is already implemented on a language level. This means that the implementation is used in a number of projects based on that language. Therefore, you can be sure that what you are using is tested extensively, thereby greatly reducing your chances of writing bug-prone code.</p>
<p>Instead of focusing on low-level operations, you can focus on describing your program in high-level terms. Consider the example of filtering that we saw in <a href="485603d0-9f5e-4644-bd73-c46a8a317448.xhtml" target="_blank">Chapter 1</a><span>, The </span><em>Declarative Programming Style</em>. It is much easier to read the declarative code because you see the word <kbd>filter</kbd> at once, and this single word means an entire operation. In the case of Java, we have a loop and manipulation over two collections to get the same job done, and it is not at all obvious what the code stands for. This is why declarative programs are much better to read for humans.</p>
<p>Let's have a look at another example – mapping. Mapping is a process of transforming a collection element-wise. This means that you take a collection as an input and generate another collection by transforming every element of the original collection in some way. For example, if you have a list of integers, you can map this list by a function that squares each individual number. If you have the numbers <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>3</kbd> in the collection, you will get a new collection with the numbers <kbd>1</kbd>, <kbd>4</kbd>, and <kbd>9</kbd>.</p>
<p>Let's do this operation in Java in an imperative way. First, let's define the collections we are going to map:</p>
<pre>List&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();<br/>numbers.add(1);<br/>numbers.add(2);<br/>numbers.add(3);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Next, we will create a new collection we are going to write our results to. Then, we will iterate over every element of the original collection, we will apply the required function to these, and then add them to the result collection:</p>
<pre>List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();<br/>for (Integer n: numbers)<br/>  result.add(n * n);</pre>
<p>Now, let's look at how this is done with Scala:</p>
<pre>val numbers = List(1, 2, 3)<br/>val result  = numbers.map(n =&gt; n * n)<br/>println(result)  // List(1, 4, 9)</pre>
<p>In Scala, we simply call the built-in primitive method <kbd>map</kbd> on the collection we need to map. Here, we can also see the role that is played by the lambda functions here. We are able to specify that mapping function as a lambda function, as an argument to the <kbd>map</kbd> method. In Java, lambda functions are only supported starting from version 8, hence, this style would have been impossible in that language <span>until recently</span>. The general pattern here is that we often need to abstract away an entire computation. We need to embed one computation in another. This can be done with a lambda function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Algebraic approach</h1>
                </header>
            
            <article>
                
<p>Functional and declarative programming can also be very well conceptualized as an algebraic style.  For our purposes, an algebraic approach can be regarded as a certain language of mathematical expressions—a language that consists of two major elements: operators and operands. Operands can be taken to mean data, the information that you want to manipulate, while operators can be taken to mean their behavior as an how this data is utilized.</p>
<p>Consider the expression <kbd>1 + 2</kbd>. Here, numbers <kbd>1</kbd> and <kbd>2</kbd> are operands. They represent some numeric data. The <kbd>+</kbd> symbol is an operator that binds them together. It has certain semantics associated with it, that of adding one number to another. But it is important to remember that the symbolic structure of the expression and its semantics are two separate things. You can take the expression as specified previously and assign a different meaning to the numbers <kbd>1</kbd> and <kbd><em>2</em></kbd> and to the symbol <kbd>+</kbd>, and the semantics of the expression will be entirely different.</p>
<p class="mce-root"/>
<p>This line of reasoning can be applied to declarative programs. For example, consider the following snippet in Scala:</p>
<pre style="padding-left: 30px">val result  = numbers.map(n =&gt; n * n)</pre>
<p>It can be rewritten with the Scala infix notation as follows:</p>
<pre style="padding-left: 30px">val result  = numbers map (n =&gt; n * n)</pre>
<p>This is because Scala supports a syntactic sugar that is allowed to call Scala methods as infix operators. The point here is that you can read the <kbd>map</kbd> function as an operator. The operator that binds its operands <span>together </span>specifies what to do with them. The first operand is the collection we are mapping, while the second operand is the lambda function you are mapping it with.</p>
<p>The behavior of the program is expressed here as operators that bind their operands <span>together, while </span>the execution of the program is taken to mean a computation of some value, and not an execution of an algorithm.</p>
<p>One advantage here is the absence of the notion of change. In algebra, time is effectively removed from the equation. Consider the implementation of map functionality in Java. It is algorithmic, which means that you explain about it in time, as follows:</p>
<ol>
<li>Take the first element of the collection.</li>
<li>Then, apply a function to this element.</li>
<li>Then, insert it into the resulting collection.</li>
<li>Repeat the same process with the second element, and then the third, and so on.</li>
</ol>
<p>Notice the presence of time in the preceding description. You clearly have a notion of what happens first and what happens after that.</p>
<p>Let's have a look at the Scala implementation of that functionality. In Scala, you specify what you need the program to do as an algebraic expression, as a binding of two operators, the collection and the lambda function, by the operator <kbd>map</kbd>. This expression no longer has a time dimension associated with it. You simply write down a mathematical expression and leave it to your language to assign some semantics to it.</p>
<p>Be aware that the <kbd>map</kbd> function in Scala is implemented with the help of algorithms and that it probably works just like it does in Java. However, for all intents and purposes, you can forget about this in most of the programs you will be writing. You can think of this program as a different paradigm, a paradigm of symbolically expressing what you want to do.</p>
<p class="mce-root"/>
<p>This paradigm separates the semantics from the structure of your program. When I say structure, I mean the symbols involved in describing the program; the symbols as in the collection you are mapping, the lambda function you are mapping it by, and the map as an operator. All of these entities are referred to with the help of symbols you write. By semantics, I mean the actions performed by the computer when it processes this expression, how it understands this expression, and how it runs this expression.</p>
<p>Thinking about programs this way allows you to treat them as mathematical expressions and work with them as with data structures—the symbolic structures of the expressions. This is in contrast to the algorithmic approach, which is so popular in traditional imperative programming, as we have seen with the example involving Java.</p>
<p>The advantage here is that it is easier to use symbolic logic to explain programs that are expressed as mathematical expressions and not algorithms. Second, in a proper declarative program, there is no dimension of time, which removes a whole class of bugs. Of course, you should remember all of this is an abstraction. You can fairly say that it is an illusion. Under the hood, algorithms still matter; time still exists. However, in the declarative style, you leverage the principle of abstraction. You abstract away the time and the algorithms. This is comparable to how, when your program operates with a high-level language such as Java, you do not need to think about the byte code or the low-level processor instructions it compiles to. This low-level code still exists, it still matters, but, to all intents and purposes, you can forget about it. The same thing happens with algorithms being abstracted away with the declarative and algebraic styles.</p>
<p>Treating programs as mathematical expressions is facilitated by techniques that abstract away side effects. These rely on data structures specific to purely functional programming. Let's now have look at such data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Effect types</h1>
                </header>
            
            <article>
                
<p>Previously, we discussed collections as an example of imperative and declarative data structures. However, the functional and declarative styles also contain some data structures specific to them.</p>
<p>Collections abstract away multiplicity. Functional languages such as Scala, Haskell, and others bring in some other data structures that abstract away side effects. We can refer to them as effect types.</p>
<p>We have argued that pure algebraic and declarative approaches remove time from the equation. This is advantageous because time taxes the programmer's mind. Functional programming takes this idea further by removing side effects from your programs. They also burden the mind as you also need to take them into account and handle them properly.</p>
<p>Previously, we discussed an example of how a Java list interface throws exceptions. We argued that it is pretty bad because it increases the mental load on a programmer's mind, since they need to constantly keep in mind that there are cases in which an exception can be thrown and they should account for these cases. In functional programming, this is not acceptable. Functional programming aspires to remove all side effects from the equation.</p>
<p>We will see in detail later in the book how this is done but, for now, let's have a look at the <kbd>Try</kbd> structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Try</h1>
                </header>
            
            <article>
                
<p>The <kbd>Try</kbd> data structure is present in one form or another in many programming languages. It may contain one of two values. One possibility is an arbitrary type of value <kbd>A</kbd>, while the second is an exception. This data structure can be returned as the result of a computation that can result in an error. This way, you no longer need to throw an exception. You can just return <kbd>Try[A]</kbd> when your method may result in an error. In Scala, the square bracket after the type name stands for type parameters, so <kbd>Try[A]</kbd> means the type <kbd>Try</kbd> with the type parameter <kbd>A</kbd>.</p>
<p>For instance, consider an example where we have a function that divides one number by another. However, in the event that the second number is zero, we throw an exception:</p>
<pre style="padding-left: 30px">def division(n1: Double, n2: Double): Double =<br/>  if (n2 == 0) throw new RuntimeException("Division by zero!")<br/>  else n1 / n2</pre>
<p>When we call the method, in certain cases it may result in an exception – a side effect we may not be aware of or have forgotten:</p>
<pre style="padding-left: 30px">println(division(1, 0))  // throws java.lang.RuntimeException: Division by zero!</pre>
<p>The program will crash at this point. However, if we wrap it in <kbd>Try</kbd>, we can prevent the program from crashing:</p>
<pre style="padding-left: 30px">def pureDivision(n1: Double, n2: Double): Try[Double] =<br/>  Try { division(n1, n2) }<br/>println(pureDivision(1, 0))  // Failure(java.lang.RuntimeException:  <br/> Division by zero!)</pre>
<p>Because the return type clearly specifies the possibility of an error, this possibility no longer needs to be kept in mind. Since an error is now represented as a data structure, it does not disrupt the program when it happens. Here, we can see a representation of phenomena as data. Representing phenomena as data is called <strong>reification</strong>, and we will see later in the book how important this concept is in pure functional programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option</h1>
                </header>
            
            <article>
                
<p>Another example of a data structure that is characteristic of functional languages is an <kbd>Option</kbd>. An <kbd>Option</kbd> can either contain a value or be empty. You can think of it as an abstraction of the notion of the null pointer in Java or C++. The advantage here is that the programmer no longer needs to remember that some methods return a null. The methods that may, or may not, result in a value will return an <kbd>Option[A]</kbd> to signify this possibility, just as in the case of <kbd>Try</kbd>.</p>
<p>For example, consider a method that returns the name of the user by their ID. Some IDs won't map to a user. Hence, we can model the scenario where we can't return a user that does not exist as follows:</p>
<pre>def getUserName(id: Int): Option[String] =<br/>  if (Set(1, 2, 3).contains(id)) Some(s"User-$id")<br/>  else None</pre>
<p>That is, if the user ID is <kbd>1</kbd>, <kbd>2</kbd> or <kbd>3</kbd>, we surmise that the user is present in the database, otherwise they are not. We explicitly include the information about whether the user is present as the <kbd>Option</kbd> type. That is, we don't just return the user's name, but also the information about whether they are present or not.</p>
<p>The advantage here is that you won't be able to access the user's name without first checking whether they were found or not:</p>
<pre>getUserName(1) match { // "User-1"<br/>  case Some(x) =&gt; println(x)<br/>  case None =&gt; println("User not found")<br/>}</pre>
<p>Here, the result of <kbd>getUserName</kbd>is not a raw <kbd>String</kbd> but a <kbd>String </kbd>wrapped in an <kbd>Option</kbd>. So, we first analyze the <kbd>Option</kbd> with the pattern matching statement before obtaining the result.</p>
<p>The preceding example outputs <kbd>User-1</kbd> to the console. However, this example outputs <kbd>User not found</kbd>:</p>
<pre>getUserName(10) match { // "User not found"<br/>  case Some(x) =&gt; println(x)<br/>  case None =&gt; println("User not found")<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data structures in different programming languages</h1>
                </header>
            
            <article>
                
<p>From the preceding discussion, you may conclude that there is a substantial difference between a functional and comparative approach to programming. While imperative programming is focused on algorithms, declarative programming is focused on the phenomena produced by these algorithms.</p>
<p>Imperative programming allows you to produce phenomena with the help of algorithms. Declarative programming names the phenomena you may need and then allows you to call them by name. This abstracts away all the details of the inner workings of the phenomena.</p>
<p>This is reflected in the separation between the approaches to data structures in different languages. Imperative programming languages, such as C++ or Java, will have their data structures, specifically, collections, implemented in a low-level manner. Typically, they will be mutable and will have some very basic primitive methods defined therein. Whatever you want to express, you will need to express it algorithmically with the help of these primitives.</p>
<p>Functional programming languages, such as Scala or Haskell, will usually have immutable <span>data structures</span>. They focus on the phenomena and the high-level behavior you need to get things done. Examples of high-level behavior include mapping <span>values of a certain type onto values of another type</span>, and filtering <span>certain values out of a collection of values</span>.</p>
<p>In general, it is much easier to program with purely functional and declarative programming collections. They provide you with lots of building blocks with which to build your programs.</p>
<p>However, in certain circumstances, it may be desirable for you to use imperative data structures. Lower-level programming styles may be desirable if you want to craft your algorithms instead of relying on off-the-shelf implementations. The circumstances in question may be high-performance operations, for example.</p>
<p>In the gaming industry, if you are designing a performance-demanding game, it may be possible in certain sections of the game that you will need to write your operations yourself in order to meet performance requirements. Also, it is possible that you may need to employ such low-level approaches in the case of micro-controller programming or situations where you have limited computational resources and you need to take full advantage of what you have.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this section, we had a look at how different programming styles define data structures and their approach to building programs using these data structures. We have seen how imperative programming relies heavily on algorithms and low-level operations. You have learned about basic mutable data structures and basic operations to mutate the data structures, as well as how to compose algorithms in your programming language of choice with the help of these data structures.</p>
<p>In contrast, in the declarative style, the focus shifts from algorithms to mathematical expressions. The collections data structures are usually immutable. You have a lot of high-level operations defined on these data structures. You use these operations in order to express the program, not with algorithms, but as a set of algebraic expressions.</p>
<p>Collections are one of the main aspects of almost any program. Hence, most of the modern programming languages support them out of the box, and, looking at the collections framework, it is possible to say what approach and philosophy that programming language follows.</p>
<p>In addition to collections, there are other data structures that are specific to functional programming. These data structures will be covered in detail in the later chapters of this book. For now, it is worth observing that data structures such as <kbd>Try</kbd> or <kbd>Option</kbd> are needed to abstract away side effects that may occur in your program.</p>
<p>Some of these functional programming-specific data structures aim at bringing side effects into the purely functional paradigm. With these structures, you can work with side effects while maintaining referential transparency. In the next chapter, we will have a look at the problem of side effects in details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the general approach you take when writing an imperative collections-based application?</li>
<li>What is the general approach you take when writing a functional collections-based application?</li>
<li>Why is it not necessary to be trained in algorithm reasoning when dealing with functional data structures (in the majority of cases)?</li>
<li>What is the algebraic approach to programming?</li>
<li>What are the benefits of adopting an algebraic style?</li>
<li>What is the purpose of effect types such as <kbd>Option</kbd> or <kbd>Try</kbd> ?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><em>Learning Scala Programming</em> by Vikash Sharma and the section entitled <em>Getting familiar with Scala collections</em> (<a href="https://www.packtpub.com/application-development/learning-scala-programming">https://www.packtpub.com/application-development/learning-scala-programming</a>).</p>


            </article>

            
        </section>
    </body></html>