<html><head></head><body>
		<div id="_idContainer011">
			<h1 class="chapter-number" id="_idParaDest-21"><a id="_idTextAnchor020"/>1</h1>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Building RESTful APIs</h1>
			<p>RESTful APIs are crucial in modern cloud apps for seamless data exchange, enabling interoperability, scalability, and efficient communication between services. Spring Boot simplifies RESTful authoring by providing a framework for quick, efficient development, auto-configuration, and <span class="No-Break">integrated tools.</span></p>
			<p>In this chapter, you will acquire the skills to create RESTful services and consume them seamlessly from other applications. You will also learn how to create automated tests for your RESTful APIs using the features provided by Spring Boot and other <span class="No-Break">popular tools.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main recipes:</span></p>
			<ul>
				<li>Creating a <span class="No-Break">RESTful API</span></li>
				<li>Defining responses and the data model exposed by <span class="No-Break">the API</span></li>
				<li>Managing errors in a <span class="No-Break">RESTful API</span></li>
				<li>Testing a <span class="No-Break">RESTful API</span></li>
				<li>Using OpenAPI to document our <span class="No-Break">RESTful API</span></li>
				<li>Consuming a RESTful API from another Spring Boot application <span class="No-Break">using FeignClient</span></li>
				<li>Consuming a RESTful API from another Spring Boot application <span class="No-Break">using RestClient</span></li>
				<li>Mocking a <span class="No-Break">RESTful API</span></li>
			</ul>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Technical requirements</h1>
			<p>To complete this chapter’s recipes, you will need a computer with any OS (I use Ubuntu on Windows Subsystem for Linux – WSL), an editor such as Visual Studio Code (<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>) or IntelliJ Idea (<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a>), and Java OpenJDK 17 <span class="No-Break">or higher.</span></p>
			<p>There are multiple distributions of Java from different vendors – if you already have one installed, you can continue using it; if you need to install one, you can use Eclipse Adoptium <span class="No-Break">distribution (</span><a href="https://adoptium.net/"><span class="No-Break">https://adoptium.net/</span></a><span class="No-Break">).</span></p>
			<p>If you use Visual Studio Code, I recommend installing Extension Pack for Java (<a href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack">https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack</a>) and Spring Boot Extension <span class="No-Break">Pack (</span><a href="https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack</span></a><span class="No-Break">).</span></p>
			<p>If you don’t have a tool to perform HTTP requests, you could use curl (<a href="https://curl.se/">https://curl.se/</a>) or <span class="No-Break">Postman (</span><a href="https://www.postman.com/"><span class="No-Break">https://www.postman.com/</span></a><span class="No-Break">).</span></p>
			<p>Finally, you can download the complete project on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span></a><span class="No-Break">.</span></p>
			<p>You will need a git client to download the code from the book’s GitHub <span class="No-Break">repository (</span><a href="https://git-scm.com/downloads"><span class="No-Break">https://git-scm.com/downloads</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Creating a RESTful API</h1>
			<p>A <strong class="bold">RESTful API</strong> is a standardized way for software components<a id="_idIndexMarker000"/> to communicate over the internet using HTTP methods and URLs. You should learn it because it’s fundamental for modern web and cloud application development. It promotes scalable, flexible, and stateless communication, enabling developers to design efficient and widely compatible systems. Understanding RESTful APIs is crucial for building and <span class="No-Break">integrating services.</span></p>
			<p>When I was a child I played with football-player cards, exchanging cards that I had multiples of with my friends. My children, some decades later, still play this game. Throughout this chapter, you will create a system to manage a football card-trading game, with teams, players, albums, and cards. In this recipe, you will create<a id="_idIndexMarker001"/> a RESTful API exposing <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) <strong class="bold">operations</strong> on <span class="No-Break">football players.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Getting ready</h2>
			<p>To create a RESTful API, Spring Boot provides a great tool named Spring Initializr. You can open this tool in your browser using <a href="https://start.spring.io/">https://start.spring.io/</a>. We’ll use this tool to create a Spring Boot project with all dependencies. This tool is also well integrated into code editors such as VSCode and IntelliJ (<span class="No-Break">Premium edition).</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>How to do it...</h2>
			<p>Let’s create a RESTful project<a id="_idIndexMarker002"/> using Spring Initializr and create our first endpoint with typical <span class="No-Break">HTTP operations:</span></p>
			<ol>
				<li>Open <a href="https://start.spring.io">https://start.spring.io</a> in your browser<a id="_idIndexMarker003"/> and you’ll see the <span class="No-Break">following screen:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer008">
					<img alt="Figure 1.1: Spring Initializr" src="image/B21646_01_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: Spring Initializr</p>
			<p class="list-inset">Spring Initilizr allows you to configure the project and generates the structure with the necessary files and dependencies, which you can use as a starting point for your application. On this start page, set up the <span class="No-Break">following configuration:</span></p>
			<ul>
				<li>In the <strong class="bold">Project</strong> section, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Maven</strong></span></li>
				<li>In the <strong class="bold">Language</strong> section, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Java</strong></span></li>
				<li>In the <strong class="bold">Spring Boot</strong> section, select the latest stable version – at the time of writing this book, this <span class="No-Break">is </span><span class="No-Break"><strong class="bold">3.1.4</strong></span></li>
				<li>In the <strong class="bold">Dependencies</strong> section, select <span class="No-Break"><strong class="bold">Spring Web</strong></span></li>
				<li>Do the following<a id="_idIndexMarker004"/> in the <strong class="bold">Project </strong><span class="No-Break"><strong class="bold">Metadata</strong></span><span class="No-Break"> section:</span><ul><li>For <strong class="bold">Group</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">com.packt</strong></span></li><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">football</strong></span></li><li>The <strong class="bold">Name</strong> and <strong class="bold">Package name</strong> will be autogenerated from previous fields, so keep them <span class="No-Break">as is</span></li><li>In the <strong class="bold">Description</strong> field, type a description of this project, such as <strong class="source-inline">Demo project for Spring Boot </strong><span class="No-Break"><strong class="source-inline">3 Coobook</strong></span></li><li>For <strong class="bold">Packaging</strong>, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Jar</strong></span></li><li>For <strong class="bold">Java</strong>, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">21</strong></span></li></ul></li>
			</ul>
			<ol>
				<li value="2">Once you have configured the preceding options, you can choose the options for <strong class="bold">Generate</strong>, <strong class="bold">Explore</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="bold">Share…</strong></span><span class="No-Break">:</span><ul><li>If you click <strong class="bold">Explore</strong>, you can explore the project before <span class="No-Break">downloading it.</span></li><li>If you click <strong class="bold">Share</strong>, a URL is generated that you can share with other people. For instance, our configuration will produce this <span class="No-Break">URL: </span><a href="https://start.spring.io/"><span class="No-Break">https://start.spring.io/#!type=maven-project</span>
&amp;language=java&amp;platformVersion=3.1.3&amp;packaging=jar&amp;jvmVersion=1 <span class="No-Break">7&amp;groupId=compackt&amp;artifactId=football&amp;name=football&amp;description=Demo%20project%20for%20Spring%20Boot%203%20</span>
Cookbook&amp;packageName=com.packt.football&amp;dependencies=web</a>. If you open it, it will configure all of the options as shown in <span class="No-Break"><em class="italic">Figure 1.1</em></span><span class="No-Break">.</span></li><li>If you click <strong class="bold">Generate</strong>, it will download a ZIP file of the project structure. Click this <span class="No-Break">option now.</span></li></ul></li>
				<li>Unzip the file. You now <a id="_idIndexMarker005"/>have the basic project structure, but you don’t have any API. If you try to run the application, you will receive an HTTP 404 Not <span class="No-Break">Found response.</span></li>
				<li>In the <strong class="source-inline">src/main/java/com/packt/football</strong> folder, create a file named <strong class="source-inline">PlayerController.java</strong> with the following content to create a <span class="No-Break">RESTful endpoint:</span><pre class="source-code">
package com.packt.football;
import java.util.List;
import org.springframework.web.bind.annotation.*;
<strong class="bold">@RequestMapping("/players") @RestController</strong>
public class PlayerController {
   @GetMapping
   public List&lt;String&gt; listPlayers() {
      return List.of("Ivana ANDRES", "Alexia PUTELLAS");
   }
}</pre></li>				<li>To run it, open a terminal in the project root folder and execute the <span class="No-Break">following command:</span><pre class="source-code">
./mvnw spring-boot:run</pre><p class="list-inset">This command will build your project and start the application. By default, the web container listens on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">8080</strong></span><span class="No-Break">.</span></p></li>				<li>Execute an HTTP request to see the results. You can open <strong class="source-inline">http://localhost:8080/players</strong> in a browser or use a tool such as curl to perform <span class="No-Break">the request:</span><pre class="source-code">
curl http://localhost:8080/players</pre><p class="list-inset">You will have a list of players returned by <span class="No-Break">the controller.</span></p></li>				<li>Enhance your RESTful endpoint by adding more verbs. In the <strong class="source-inline">PlayerController.java</strong> file, do <span class="No-Break">the following:</span><ul><li>Implement a POST request to create <span class="No-Break">a player:</span><pre class="source-code">
<strong class="bold">@PostMapping</strong>
public String createPlayer(<strong class="bold">@RequestBody</strong> String name) {
     return "Player " + name + " created";
}</pre></li><li>Add another GET request<a id="_idIndexMarker006"/> to return <span class="No-Break">one player:</span><pre class="source-code"><strong class="bold">@GetMapping("/{name}")</strong>
public String readPlayer(<strong class="bold">@PathVariable</strong> String name) {
     return name;
}</pre></li><li>Add a DELETE request to delete <span class="No-Break">one player:</span><pre class="source-code"><strong class="bold">@DeleteMapping("/{name}")</strong>
public String deletePlayer(<strong class="bold">@PathVariable</strong> String name) {
     return "Player " + name + " deleted";
}</pre></li><li>Implement a PUT request to update <span class="No-Break">a player:</span><pre class="source-code"><strong class="bold">@PutMapping("/{name}")</strong>
public String updatePlayer(<strong class="bold">@PathVariable</strong> String name, @RequestBody String newName) {
     return "Player " + name + " updated to " + newName;
}</pre></li></ul></li>				<li>Execute your application again as explained in <em class="italic">step 5</em> and test your endpoint. Perform a GET request by entering the following command into <span class="No-Break">your terminal:</span><pre class="source-code">
curl http://localhost:8080/players/Ivana%20ANDRES</pre><p class="list-inset">And you will receive <span class="No-Break">this output:</span></p><pre class="source-code">Ivana ANDRES</pre><p class="list-inset">Perform a POST request<a id="_idIndexMarker007"/> <span class="No-Break">using curl:</span></p><pre class="source-code">curl --header "Content-Type: application/text" --request POST
--data 'Itana BONMATI' http://localhost:8080/players</pre><p class="list-inset">And you will receive <span class="No-Break">this output:</span></p><pre class="source-code"><strong class="bold">Player Itana BONMATI created</strong></pre><p class="list-inset">Perform a PUT request <span class="No-Break">using curl:</span></p><pre class="source-code">curl --header "Content-Type: application/text" --request PUT
--data 'Aitana BONMATI' http://localhost:8080/players/Itana%20BONMATI</pre><p class="list-inset">And you will receive <span class="No-Break">this output:</span></p><pre class="source-code">Player Itana BONMATI updated to Aitana BONMATI</pre><p class="list-inset">Perform a <span class="No-Break">DELETE request:</span></p><pre class="source-code">curl --header "Content-Type: application/text" --request DELETE http://localhost:8080/players/Aitana%20BONMATI</pre><p class="list-inset">And you will receive <span class="No-Break">this output:</span></p><pre class="source-code">Player Aitana BONMATI deleted</pre></li>			</ol>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>How it works...</h2>
			<p>By adding the Spring Web<a id="_idIndexMarker008"/> dependency to our project, Spring Boot automatically embeds a Tomcat server in the application. <strong class="bold">Tomcat</strong> is an open source web server<a id="_idIndexMarker009"/> and servlet container developed by the Apache Software Foundation. It’s one of the most popular choices for hosting Java-based web applications and services. You can run the application right after downloading it from <strong class="source-inline">start.spring.io</strong> and it listens on port <strong class="source-inline">8080</strong>, which is the default port for Tomcat. However, as there is no mapping configured in the application, it always responds with a 404 Not <span class="No-Break">Found error.</span></p>
			<p>By adding the <strong class="bold">@RestController</strong> annotation to the <strong class="source-inline">PlayerController</strong> class, we<a id="_idIndexMarker010"/> are informing Spring Boot that it should register the <strong class="source-inline">PlayerController</strong> class in dependency containers as an implementation class. By adding <strong class="bold">@RequestMapping</strong>, we inform the web container <a id="_idIndexMarker011"/>to map HTTP requests to their handler, in this case, the <strong class="source-inline">PlayerController</strong> class. As we applied these at a class level, we configured all requests in this class with the <span class="No-Break"><strong class="source-inline">players</strong></span><span class="No-Break"> prefix.</span></p>
			<p>The last step is mapping requests to their handling methods. This is performed by using <span class="No-Break">mapping annotations:</span></p>
			<ul>
				<li><strong class="source-inline">@GetMapping</strong>: Maps a GET request to <span class="No-Break">a method</span></li>
				<li><strong class="source-inline">@PostMapping</strong>: Maps a POST request to <span class="No-Break">a method</span></li>
				<li><strong class="source-inline">@PutMapping</strong>: Maps a PUT request to <span class="No-Break">a method</span></li>
				<li><strong class="source-inline">@DeleteMethod</strong>: Maps a DELETE request to <span class="No-Break">a method</span></li>
			</ul>
			<p>These mapping annotations are a specialization of <strong class="source-inline">@RequestMapping</strong>, as they inform the web container how to map a request to its handler, in this case, using the <span class="No-Break">annotated method.</span></p>
			<p>Keep in mind that you can only have one of these mapping types per controller (i.e., one <strong class="source-inline">GetMapping</strong> or <strong class="source-inline">PostMapping</strong>) unless you provide more configuration to refine the mapping. In this example, you can see there are two instances of <strong class="source-inline">@GetMapping</strong>, but <strong class="source-inline">readPlayer</strong> is annotated with an additional element and thus is mapped with its class prefix, <strong class="source-inline">players</strong>, plus a name. That means all GET requests with <strong class="source-inline">/players/anything</strong> will be mapped to <span class="No-Break">this method.</span></p>
			<p>As of now, that additional information is not yet configured in the method. To use all this additional HTTP request information in your method, you can use the <span class="No-Break">following annotations:</span></p>
			<ul>
				<li><strong class="bold">@PathVariable</strong>: This will map one part of the HTTP request<a id="_idIndexMarker012"/> path to the method argument. For instance, <strong class="source-inline">@GetMapping("/{name}") public String readPlayer(@PathVariable String name)</strong> maps the last part of the path to the <strong class="source-inline">name</strong> <span class="No-Break">method argument.</span></li>
				<li><strong class="bold">@RequestBody</strong>: This will map the request body <a id="_idIndexMarker013"/>to the <span class="No-Break">method argument.</span></li>
				<li><strong class="bold">@RequestHeader</strong>: This will map request headers<a id="_idIndexMarker014"/> to the <span class="No-Break">method argument.</span></li>
				<li><strong class="bold">@RequestParam</strong>: You can use this to map requests<a id="_idIndexMarker015"/> params, such as query string parameters, form data, or parts in <span class="No-Break">multipart requests.</span></li>
			</ul>
			<p>Just by decorating our classes with previous annotations, Spring Boot is able to set up the web application container to manage the requests. There are some annotations not yet covered, but we covered<a id="_idIndexMarker016"/> the basics to create our <span class="No-Break">RESTful APIs.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>There’s more...</h2>
			<p>Even if the RESTful endpoint we just created is very simple, I intentionally added these methods – <strong class="source-inline">GET</strong> by default, <strong class="source-inline">GET</strong> with an identifier, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>. This choice is rooted in the fact that it aligns with the most prevalent semantics for performing CRUD and List operations on <span class="No-Break">a resource.</span></p>
			<p>In the context of our resource being football <em class="italic">players</em>, we have the <span class="No-Break">following operations:</span></p>
			<ul>
				<li><strong class="source-inline">GET</strong> by default usually returns a list of resources, in our case, <span class="No-Break">all players</span></li>
				<li><strong class="source-inline">GET</strong> with an identifier returns a <span class="No-Break">specific player</span></li>
				<li><strong class="source-inline">POST</strong> creates a <span class="No-Break">new resource</span></li>
				<li><strong class="source-inline">PUT</strong> updates <span class="No-Break">a resource</span></li>
				<li><strong class="source-inline">DELETE</strong> deletes <span class="No-Break">a resource</span></li>
			</ul>
			<p>Also, the HTTP status code responses are very important in the semantics of RESTful operations. In this recipe, the responses are not managed in the standard way. In the following recipes, we will expand on this and learn how Spring Boot can facilitate the proper handling <span class="No-Break">of responses.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>See also</h2>
			<p>If you want to learn more<a id="_idIndexMarker017"/> about API design, you can visit the <span class="No-Break">following pages:</span></p>
			<ul>
				<li><a href="https://swagger.io/resources/articles/best-practices-in-api-design/"><span class="No-Break">https://swagger.io/resources/articles/best-practices-in-api-design/</span></a></li>
				<li><a href="https://learn.microsoft.com/azure/architecture/best-practices/api-design"><span class="No-Break">https://learn.microsoft.com/azure/architecture/best-pra<span id="_idTextAnchor029"/>ctices/api-design</span></a></li>
			</ul>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/>Defining responses and the data model exposed by the API</h1>
			<p>In the previous recipe, we<a id="_idIndexMarker018"/> created a very <a id="_idIndexMarker019"/>simple RESTful API. To<a id="_idIndexMarker020"/> develop a RESTful API that provides a positive user experience for its consumers, it is essential to incorporate both standard response codes and a consistent data model. In this recipe, we will enhance the previous RESTful API by returning standard response codes and creating a data model for our <span class="No-Break">players endpoint.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Getting ready</h2>
			<p>You can use the project generated in the previous recipe or download the sample from the GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span></a><span class="No-Break">.</span></p>
			<p>You can find the code to start this exercise in the <span class="No-Break"><strong class="source-inline">chapter1/recipe1-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>How to do it...</h2>
			<p>In this recipe, we will create a folder structure to contain different types of classes for our project. We will define a data model to expose in our RESTful API, along with a service to provide the operations needed by <span class="No-Break">the API.</span></p>
			<p>Note that all of the content created in the following steps will be under the <strong class="source-inline">src/main/java/com/packt/football</strong> folder or one of the subfolders you will create when required. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a folder <a id="_idIndexMarker021"/>named <strong class="source-inline">model</strong>. Then in this<a id="_idIndexMarker022"/> folder, create a file named <strong class="source-inline">Player.java</strong> with the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker023"/></span><span class="No-Break"> content:</span><pre class="source-code">
public record Player(String id, int jerseyNumber, String name, String position,     LocalDate dateOfBirth) {
}</pre></li>				<li>Create a folder named <strong class="source-inline">exceptions</strong>. In this folder, create <span class="No-Break">two files:</span><ul><li>The first, <strong class="source-inline">AlreadyExistsException.java</strong>, should have the <span class="No-Break">following content:</span><pre class="source-code">
package com.packt.football.exceptions;
public class AlreadyExistsException extends RuntimeException {
     public AlreadyExistsException(String message) {
          super(message);
     }
}</pre></li><li>And the second, <strong class="source-inline">NotFoundException.java</strong>, should contain <span class="No-Break">this content:</span><pre class="source-code">package com.packt.football.exceptions;
public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
          super(message);
     }
}</pre></li></ul></li>				<li>Create another folder named <strong class="source-inline">services</strong>, and in this folder, create a class named <strong class="source-inline">FootballService</strong>. This class manages<a id="_idIndexMarker024"/> all operations needed<a id="_idIndexMarker025"/> by our RESTful API. Do the following<a id="_idIndexMarker026"/> in <span class="No-Break">this file:</span><ul><li>Create the <span class="No-Break">class first:</span><pre class="source-code">
@Service
public class FootballService {
}</pre></li></ul><p class="list-inset">This class will manage the data in a <strong class="source-inline">Map</strong>, keeping all players <span class="No-Break">in memory.</span></p><ul><li>Now let’s define a <strong class="source-inline">Map&lt;String, Player&gt;</strong> field and initialize it. (I just created two entries for brevity, but in the GitHub repo, you will find <span class="No-Break">many more):</span><pre class="source-code">private final Map&lt;String, Player&gt; players = Map.ofEntries(
      Map.entry("1884823", new Player("1884823", 5, "Ivana ANDRES", "Defender", LocalDate.of(1994, 07, 13))),
      Map.entry("325636", new Player("325636", 11, "Alexia PUTELLAS", "Midfielder", LocalDate.of(1994, 02, 04
))));</pre></li><li>Define the operations required by our <span class="No-Break">RESTful API:</span><ul><li>Start by listing <span class="No-Break">the players:</span></li></ul><pre class="source-code">public List&lt;Player&gt; listPlayers() {
     return players.values().stream()
            .collect(Collectors.toList());
}</pre><ul><li>Then return a player (do note that if the player doesn’t exist, it will throw <span class="No-Break">an exception):</span></li></ul><pre class="source-code">public Player getPlayer(String id) {
     Player player = players.get(id);
      if (player == null)
          throw new NotFoundException("Player not found");
   return player;
}</pre><ul><li>Add a new player (do note that<a id="_idIndexMarker027"/> if the player already<a id="_idIndexMarker028"/> exists, it will throw<a id="_idIndexMarker029"/> <span class="No-Break">an exception):</span></li></ul><pre class="source-code">public Player addPlayer(Player player) {
     if (players.containsKey(player.id())) {
         throw new AlreadyExistsException("The player already exists");
     } else {
         players.put(player.id(), player);
         return player;
     }
}</pre><ul><li>Update a player (note that if the player doesn’t already exist, it will throw <span class="No-Break">an exception):</span></li></ul><pre class="source-code">public Player updatePlayer(Player player) {
     if (!players.containsKey(player.id())) {
         throw new NotFoundException("The player does not
exist");
     } else {
         players.put(player.id(), player);
        return player;
     }
}</pre><ul><li>Delete a player (note that if the player doesn’t exist, it will continue <span class="No-Break">without errors):</span></li></ul><pre class="source-code">public void deletePlayer(String id) {
    if (players.containsKey(id)) {
         players.remove(id);
    }
}</pre></li></ul></li>				<li>Next, in the <strong class="source-inline">PlayerController</strong> class, modify<a id="_idIndexMarker030"/> the controller to use<a id="_idIndexMarker031"/> our new service and expose the newly<a id="_idIndexMarker032"/> created <span class="No-Break">data model:</span><ul><li>Add a <strong class="source-inline">FootballService</strong> field and create a constructor in the <strong class="source-inline">PlayerController</strong> class with an argument of type <strong class="source-inline">FootballService</strong> to <span class="No-Break">initialize it:</span><pre class="source-code">
@RequestMapping("/players")
@RestController
public class PlayerController {
    private FootballService footballService;
    public PlayerController(FootballService footballService) {
        this.footballService = footballService;
    }
}</pre></li><li>Create the operations to manage<a id="_idIndexMarker033"/> the players. We will use<a id="_idIndexMarker034"/> our recently created service to manage<a id="_idIndexMarker035"/> that functionality. As explained in the previous recipe, we will decorate our class methods to manage the RESTful endpoint methods and will invoke the services of our <strong class="source-inline">Football</strong> <span class="No-Break">service class:</span><pre class="source-code">@GetMapping
public List&lt;Player&gt; listPlayers() {
     return footballService.listPlayers();
}
@GetMapping("/{id}")
public Player readPlayer(@PathVariable String id) {
     return footballService.getPlayer(id);
}
@PostMapping
public void createPlayer(@RequestBody Player player) {
    footballService.addPlayer(player);
}
@PutMapping("/{id}")
public void updatePlayer(@PathVariable String id,
                         @RequestBody Player player) {
    footballService.updatePlayer(player);
}
@DeleteMapping("/{id}")
public void deletePlayer(@PathVariable String id) {
    footballService.deletePlayer(id);
}</pre></li></ul></li>				<li>In the <strong class="source-inline">application</strong> root folder, open a terminal<a id="_idIndexMarker036"/> and execute the <a id="_idIndexMarker037"/>following command<a id="_idIndexMarker038"/> to run <span class="No-Break">the application:</span><pre class="source-code">
./mvnw spring-boot:run</pre></li>				<li>Test the application by executing the following <strong class="source-inline">curl</strong> command to get all of <span class="No-Break">the players:</span><pre class="source-code">
<strong class="bold">curl http://localhost:8080/players</strong>
[{"id":"325636","jerseyNumber":11,"name":"Alexia PUTELLAS","position":"Midfielder","dateOfBirth":"1994-02- 04"},{"id":"1884823","jerseyNumber":5,"name":"Ivana ANDRES","position":"Defender","dateOfBirth":"1994-07-13"}]</pre></li>			</ol>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>How it works...</h2>
			<p>In this recipe, we defined a new record type named <strong class="source-inline">Player</strong>. Spring Boot automatically serializes that object into a response body that can be sent to the client in a format such as JSON <span class="No-Break">or XML.</span></p>
			<p>Spring Boot uses a message converter to perform this serialization. The choice of message converter and the serialization format depends on the Accept header in the client’s request. By default, Spring Boot serializes the response <span class="No-Break">as JSON.</span></p>
			<p class="callout-heading">About records</p>
			<p class="callout">The <strong class="bold">record</strong> feature was introduced <a id="_idIndexMarker039"/>in Java 16. Java records provide a convenient way to declare classes that are simple data carriers, automatically generating methods such as the <strong class="source-inline">equals()</strong>, <strong class="source-inline">hashCode()</strong>, and <strong class="source-inline">toString()</strong> constructors based on the record components. This feature aims to simplify the creation of classes that primarily encapsulate data. Spring Boot 3 uses Java 17 <span class="No-Break">or higher.</span></p>
			<p>If you have special serialization<a id="_idIndexMarker040"/> requirements you can configure<a id="_idIndexMarker041"/> your own message converter<a id="_idIndexMarker042"/> by implementing your <strong class="source-inline">WebMvcConfigurer</strong> and overriding the method <strong class="source-inline">configureMessageConverters</strong>. You can find more<a id="_idIndexMarker043"/> information in the Spring Framework <span class="No-Break">documentation: </span><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List"><span class="No-Break">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List</span></a><span class="No-Break">).</span></p>
			<p>Spring Boot’s default handling<a id="_idIndexMarker044"/> of HTTP status codes can be summarized <span class="No-Break">as follows:</span></p>
			<ul>
				<li>When the execution occurs without generating exceptions, it responds with an HTTP <span class="No-Break">200 status.</span></li>
				<li>If a method is not implemented by the endpoint, it will return a <strong class="bold">405 Method not </strong><span class="No-Break"><strong class="bold">allowed </strong></span><span class="No-Break">error.</span></li>
				<li>If trying to get a resource that doesn’t exist, for instance, a path that is not managed by the application, it will return <strong class="bold">404 </strong><span class="No-Break"><strong class="bold">Not found</strong></span><span class="No-Break">.</span></li>
				<li>If the request is not valid, it will return <strong class="bold">400 </strong><span class="No-Break"><strong class="bold">Bad Request</strong></span><span class="No-Break">.</span></li>
				<li>In the event of an exception, it yields an <strong class="bold">HTTP 500 Internal </strong><span class="No-Break"><strong class="bold">Server error</strong></span><span class="No-Break">.</span></li>
				<li>There are other operations related to security, which we will discuss in later chapters, that may<a id="_idIndexMarker045"/> return <strong class="bold">401 Unauthorized</strong> or <span class="No-Break"><strong class="bold">403 Forbidden</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>This behavior can be enough in some scenarios, but if you want to provide proper semantics to your RESTful API, you should return a 404 status code when a resource is not found. Check the next recipe to learn how to handle <span class="No-Break">these scenarios.</span></p>
			<p>Note that the <strong class="source-inline">FootballService</strong> class is annotated with <strong class="bold">@Service</strong>. That registers the class as a Spring<a id="_idIndexMarker046"/> bean and hence it is available in the Inversion-of-Control container. When a Spring Boot application<a id="_idIndexMarker047"/> starts, it scans<a id="_idIndexMarker048"/> for classes annotated<a id="_idIndexMarker049"/> with various stereotypes, such as <strong class="source-inline">@Service</strong>, <strong class="source-inline">@Controller</strong>, <strong class="source-inline">@Bean</strong>, and others. As there is a dependency in the <strong class="source-inline">PlayerController</strong> class for <strong class="source-inline">FootballService</strong>, when Spring Boot instantiates the <strong class="source-inline">PlayerController</strong>,<a id="_idTextAnchor034"/> it passes an instance of <span class="No-Break"><strong class="source-inline">FootballService</strong></span><span class="No-Break"> class.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor035"/>Managing errors in a RESTful API</h1>
			<p>In the previous recipe, we enhanced<a id="_idIndexMarker050"/> our RESTful API by using complex data<a id="_idIndexMarker051"/> structures. However, the application was not able to manage some common errors or return standard response codes. In this recipe, l we will enhance the previous RESTful API by managing common errors and returning consistent response codes following <span class="No-Break">the standards.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Getting ready</h2>
			<p>You can use the project generated in the previous recipe or download the sample from the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span></a><span class="No-Break">.</span></p>
			<p>You can find the code to start this exercise in the <span class="No-Break"><strong class="source-inline">chapter1/recipe1-3/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor037"/>How to do it...</h2>
			<p>In this recipe, we will modify the RESTful API created in the previous recipe to handle the exceptions that can be raised by our application and we’ll return the most appropriate HTTP <span class="No-Break">response code.</span></p>
			<p>All content created in the following steps will be under the <strong class="source-inline">src/main/java/com/packt/football</strong> folder or one of the subfolders you will create. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>If you try to retrieve a non-existing player or create the same player twice, it will throw an exception. The result will be an HTTP 500 <span class="No-Break">server error:</span><pre class="source-code">
curl http://localhost:8080/players/99999
{"timestamp":"2023-09- 16T23:18:41.906+00:00","status":500,"error":"Internal Server Error","path":"/players/99999"}</pre></li>				<li>To manage this error more<a id="_idIndexMarker052"/> consistently, we will add a new <strong class="source-inline">notFoundHandler</strong> method<a id="_idIndexMarker053"/> in the <strong class="source-inline">PlayerController</strong> class to manage <span class="No-Break"><strong class="source-inline">NotFoundException</strong></span><span class="No-Break"> errors:</span><pre class="source-code">
@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Not found")
@ExceptionHandler(NotFoundException.class)
public void notFoundHandler() {
}</pre></li>				<li>Next, we’ll add another method named <strong class="source-inline">alreadyExistsHandler</strong> to manage <span class="No-Break"><strong class="source-inline">AlreadyExistsException</strong></span><span class="No-Break"> errors:</span><pre class="source-code">
@ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "Already exists")
@ExceptionHandler(AlreadyExistsException.class) public void alreadyExistsHandler() {
}</pre></li>				<li>In the <strong class="source-inline">application</strong> root folder, open a terminal and execute the following command to run <span class="No-Break">the application:</span><pre class="source-code">
./mvnw spring-boot:run</pre></li>				<li>Test the application by executing the following <span class="No-Break">curl commands:</span><ul><li>Execute this command to get a player that does <span class="No-Break">not exist:</span><pre class="source-code">
<strong class="bold">curl http://localhost:8080/players/99999</strong>
{"timestamp":"2023-09- 16T23:21:39.936+00:00","status":404,"error":"Not
Found","path":"/players/99999"}</pre></li><li>Note that by returning an <strong class="source-inline">HTTP 404 Not Found</strong> response, our application adheres to standard RESTful API semantics. HTTP 404 means that you tried to get a resource that does not exist, in our case, <span class="No-Break">player 9999.</span></li><li>Let’s verify that<a id="_idIndexMarker054"/> our application<a id="_idIndexMarker055"/> manages the <strong class="source-inline">AlreadyExistsException</strong> as expected. Execute the following request to create a <span class="No-Break">player twice:</span><pre class="source-code">data="{'id': '8888', 'jerseyNumber':6, 'name':'Cata COLL',"
data=${data}" 'position':'Goalkeeper', "
data=${data}" 'dateOfBirth': '2001-04-23'}"
curl --header "Content-Type: application/json" --request POST \
 --data $data  http://localhost:8080/players</pre></li></ul><p class="list-inset">The first time it will work with no errors and will return the <strong class="source-inline">HTTP 200</strong> code. The second time it will return an <strong class="source-inline">HTTP </strong><span class="No-Break"><strong class="source-inline">400</strong></span><span class="No-Break"> code.</span></p></li>			</ol>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor038"/>How it works...</h2>
			<p>As we learned in the previous recipe, Spring Boot manages the HTTP status code for the most common cases. In this recipe, we demonstrated how to manage other scenarios that are specific to our application logic and require consistent HTTP <span class="No-Break">status codes.</span></p>
			<p>To provide proper semantics to the RESTful API, you should return a <strong class="source-inline">404</strong> status code when a resource is not found. In some scenarios, it could make sense to change the signature of <strong class="source-inline">FootballService</strong> to return a null value in case it doesn’t find a player. However, if the controller returns a null the response<a id="_idIndexMarker056"/> will be <strong class="source-inline">HTTP 200</strong> anyway. To avoid this behavior, we added the <strong class="bold">@ExceptionHandler</strong> annotation to add a handler method to manage a specific type of exception, and the <strong class="bold">@ResponseStatus</strong> annotation to manage the HTTP<a id="_idIndexMarker057"/> status code to return in that specific <span class="No-Break">method handler.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/>There’s more...</h2>
			<p>It is possible to control the response codes more explicitly in your code. Instead of using your data model directly in the controller, you can return <strong class="source-inline">ResponseEntity</strong>, which allows you to specify the status code explicitly. The following is an example of how you can implement <strong class="source-inline">getPlayer</strong> in <span class="No-Break">this way:</span></p>
			<pre class="source-code">
@GetMapping("/{id}")
public ResponseEntity&lt;Player&gt; readPlayer(@PathVariable String id) 
{
  try {
          Player player = footballService.getPlayer(id);
          return new ResponseEntity&lt;&gt;(player, HttpStatus.OK);
     } catch (NotFoundException e) {
          return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);
      }
}</pre>			<p>Another alternative is having a global handler for all controllers by using a class annotated with <strong class="source-inline">@ControllerAdvice</strong>, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
package com.packt.football;
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(NotFoundException.class)
     public ResponseEntity&lt;String&gt;
handleGlobalException(NotFoundException ex) {
        return new ResponseEntity&lt;String&gt;(ex.getMessage(), HttpStatus.NOT_FOUND);
    }
}</pre>			<p>In this way, you can have consistent error-handling for all your RESTful endpoints in <span class="No-Break">your application.</span></p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Testing a RESTful API</h1>
			<p>Testing the application<a id="_idIndexMarker058"/> manually can be tiring, especially when dealing with challenging scenarios that are hard to validate. Additionally, it lacks scalability in terms of development productivity. Hence, I highly recommend applying <span class="No-Break">automated testing.</span></p>
			<p>By default, Spring Boot includes the <em class="italic">Testing starter</em> that provides the basic components for unit and integration testing. In this recipe, we’ll learn how to implement a unit test for our <span class="No-Break">RESTful API.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Getting ready</h2>
			<p>In this recipe, we’ll create unit tests for the RESTful API created in the previous recipe. I prepared a working version in case you haven’t completed i<a id="_idTextAnchor042"/>t yet. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. You can find the code to start this recipe in the <span class="No-Break"><strong class="source-inline">chapter1/recipe1-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/>How to do it...</h2>
			<p>Let’s add some tests to our RESTful API that will validate our application whenever we <span class="No-Break">change it:</span></p>
			<ol>
				<li>We’ll start by creating a new test class for our RESTful controller in the <strong class="source-inline">src/test</strong> folder. Let’s name the new class <strong class="source-inline">PlayerControllerTest</strong> and annotate it with <strong class="source-inline">@WebMvcTest</strong> <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">@WebMvcTest</strong>(value = PlayerController.class)
public class PlayerControllerTest {
}</pre></li>				<li>Now, define a field of type <strong class="source-inline">MockMvc</strong> and annotate it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">@Autowired</strong></span><span class="No-Break">:</span><pre class="source-code">
@Autowired
private MockMvc mvc;</pre></li>				<li>Then, create another field of type <strong class="source-inline">FootballService</strong> and annotate it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@MockBean</strong></span><span class="No-Break">.</span></li>
				<li>We are ready now to write<a id="_idIndexMarker059"/> our <span class="No-Break">first test:</span><ol><li class="upper-roman">Let’s create a method to validate when our RESTful API returns the players. Name the new <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">testListPlayers</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
<strong class="bold">@Test</strong>
public void testListPlayers() throws Exception {
}</pre><p class="list-inset">Importantly, note that it should be annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Test</strong></span><span class="No-Break">.</span></p><ol><li class="upper-roman" value="2">The first thing to do in the test is configure <strong class="source-inline">FootballService</strong>. The following lines configure <strong class="source-inline">FootballService</strong> to return a list of two players when invoking the <span class="No-Break"><strong class="source-inline">listPlayers</strong></span><span class="No-Break"> method:</span></li></ol><pre class="source-code">Player player1 = new Player("1884823", 5, "Ivana ANDRES", "Defender", LocalDate.of(1994, 07, 13));
Player player2 = new Player("325636", 11, "Alexia PUTELLAS", "Midfielder", LocalDate.of(1994, 02, 04));
List&lt;Player&gt; players = List.of(player1, player2);
<strong class="bold">given(footballService.listPlayers()).willReturn(players);</strong></pre><ol><li class="upper-roman" value="3">Next, we’ll use the <strong class="source-inline">mvc</strong> field created in <em class="italic">step 2</em> to emulate the HTTP calls and validate it’s behaving <span class="No-Break">as expected:</span></li></ol><pre class="source-code">MvcResult result = mvc.perform(MockMvcRequestBuilders                 .get("/players")                .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(MockMvcResultMatchers                     .jsonPath("$", hasSize(2)))
                .andReturn();</pre><p class="list-inset">The preceding code performs a GET request<a id="_idIndexMarker060"/> that accepts application/JSON content. The expected result is OK, meaning any HTTP status code between 200 and 299. The expected result is a JSON array with two elements. Finally, we save the result in the <span class="No-Break"><strong class="source-inline">result</strong></span><span class="No-Break"> variable.</span></p><ol><li class="upper-roman" value="4">As we saved the result in the <strong class="source-inline">result</strong> variable, we can perform additional validations. For instance, we can validate that the returned array of players is exactly <span class="No-Break">as expected:</span></li></ol><pre class="source-code">String json = result.getResponse().getContentAsString();
ObjectMapper mapper = new ObjectMapper();
mapper.registerModule(new JavaTimeModule());
List&lt;Player&gt; returnedPlayers = mapper.readValue(json,
                mapper.getTypeFactory().constructCollectionType(List.class, Player.class));
<strong class="bold">assertArrayEquals</strong>(players.toArray(), returnedPlayers.toArray());</pre></li>				<li>Now, we can test that the application<a id="_idIndexMarker061"/> manages the errors as expected. Let’s test what happens when we request a player that does <span class="No-Break">not exist:</span><ol><li class="upper-roman">Create a new method named <strong class="source-inline">testReadPlayer_doesnt_exist</strong> in the <strong class="source-inline">PlayerControllerTest</strong> class. Remember to annotate it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Test</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
@Test
public void testReadPlayer_doesnt_exist() throws Exception {
}</pre><ol><li class="upper-roman" value="2">Let’s arrange the <strong class="source-inline">getPlayer</strong> method of the <strong class="source-inline">FootballService</strong> class to throw a <strong class="source-inline">NotFoundException</strong> when trying to get the player <strong class="source-inline">1884823</strong>. For that, use the <span class="No-Break">following code:</span></li></ol><pre class="source-code">String id = "1884823";
<strong class="bold">given</strong>(footballService.getPlayer(id))
       .<strong class="bold">willThrow</strong>(new NotFoundException("Player not found"));</pre><ol><li class="upper-roman" value="3">Now we can use the <strong class="source-inline">mvc</strong> field defined in <em class="italic">step 2</em> to simulate the request and then validate it behaves <span class="No-Break">as expected:</span></li></ol><pre class="source-code"><strong class="bold">mvc.perform</strong>(MockMvcRequestBuilders.get("/players/" + id).accept(MediaType.APPLICATION_JSON))
      .<strong class="bold">andExpect(status().isNotFound())</strong>;</pre></li>				<li>To execute the tests, use the <span class="No-Break">following command:</span><pre class="source-code">
mvn test</pre><p class="list-inset">The <strong class="source-inline">test</strong> goal is also executed<a id="_idIndexMarker062"/> anytime you execute the <strong class="source-inline">package</strong> or <strong class="source-inline">install</strong> goals unless you explicitly disable the <span class="No-Break">test execution.</span></p><p class="list-inset">Usually, you can also execute the tests from your <span class="No-Break">favorite IDE.</span></p></li>			</ol>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor044"/>How it works...</h2>
			<p>By default, Spring Initializr includes a dependency for <strong class="source-inline">spring-boot-starter-test</strong>. This dependency provides all the necessary components to create tests. Let’s describe the elements used in <span class="No-Break">this recipe:</span></p>
			<ul>
				<li><strong class="source-inline">@WebMvcTest</strong>: When you apply this annotation to a testing class, it disables Spring Boot default autoconfiguration and applies only the relevant configuration for MVC tests. That means that it doesn’t register classes annotated with <strong class="source-inline">@Service</strong> as <strong class="source-inline">FootballService</strong>, but it registers classes annotated with <strong class="source-inline">@RestController</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">PlayerController</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@MockBean</strong>: As our <strong class="source-inline">FootballService</strong> class is not autoconfigured because we use <strong class="source-inline">@WebMvcTest</strong>), we can register our own implementation of <strong class="source-inline">FootballService</strong>. The <strong class="source-inline">@MockBean</strong> annotation allows us to mock the implementation of <strong class="source-inline">FootballService</strong>, replacing any previous <span class="No-Break">bean registration.</span></li>
				<li><strong class="source-inline">given</strong>: This method stubs a method and allows us to specify the behavior. For instance, using <strong class="source-inline">thenReturn</strong> sets the return value when the method specified by <strong class="source-inline">given</strong> <span class="No-Break">is called.</span></li>
				<li><strong class="source-inline">MockMvc</strong>: This simulates the behavior of the web server and allows you to test your controllers without having to deploy the application. When performing simulated requests, it returns <strong class="source-inline">ResultActions</strong> that provides methods to validate that the controller behaves as expected, for instance, the <span class="No-Break"><strong class="source-inline">andExpect</strong></span><span class="No-Break"> method.</span></li>
			</ul>
			<p>In this recipe, we used<a id="_idIndexMarker063"/> other JUnit utilities, such as <strong class="source-inline">assertArrayEquals</strong> to compare the elements of two arrays. The utilities offered by JUnit and other testing libraries are very extensive and we won’t cover them all in detail in this book. However, I’ll explain the testing utilities the first time I introduce them as we <span class="No-Break">go through.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor045"/>There’s more...</h2>
			<p>You can write tests for the rest of the methods exposed by our RESTful API as an exercise. I also prepared some tests for this RESTful API myself. You can find them in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a> – the final version is in the <span class="No-Break"><strong class="source-inline">chapter1/recipe1-4/end</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor046"/>See also</h2>
			<p>In this book, I apply the <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>) principles when <span class="No-Break">writing</span><span class="No-Break"><a id="_idIndexMarker064"/></span><span class="No-Break"> tests:</span></p>
			<ul>
				<li><strong class="bold">Arrange</strong>: In this step, you prepare the class you want to test by setting up the conditions needed for the “act” step <span class="No-Break">to run</span></li>
				<li><strong class="bold">Act</strong>: In this step, you perform the action you <span class="No-Break">are testing</span></li>
				<li><strong class="bold">Assert</strong>: In this step, you verify that the expected<a id="_idIndexMarker065"/> results <span class="No-Break">were achieved</span></li>
			</ul>
			<p>There is also the <strong class="bold">Arrange-Act-Assert-Clean</strong> (<strong class="bold">AAAC</strong>) variant that adds a last step<a id="_idIndexMarker066"/> to clean up any change done by the test. Ideally, that last step should not be necessary as we can mock any component or service that handles a state that requires being <span class="No-Break">cleaned up.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor047"/>Using OpenAPI to document our RESTful API</h1>
			<p>Now that we have a RESTful API, we can create<a id="_idIndexMarker067"/> a consumer application. We could<a id="_idIndexMarker068"/> create an application and just perform HTTP requests. That would require that we provide the consumers with the source code of our application and that they understand it. But what if they are developing their application in a different language and they don’t know Java and Spring Boot? For this reason, OpenAPI was created. OpenAPI is a standard to document RESTful APIs and can be used to generate client applications. It’s widely adopted and is supported by different languages and frameworks. Spring Boot’s support for OpenAPI <span class="No-Break">is excellent.</span></p>
			<p>In this recipe, we’ll learn how to add OpenAPI support to our RESTful API and consume it using the tools provided <span class="No-Break">by OpenAPI.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor048"/>Getting ready</h2>
			<p>In this recipe, we will enhance the RESTful API created in the previous recipe. If you haven’t completed the previous recipe, you can find a working version in the book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></p>
			<p>You can find the code to start this exercise in the <span class="No-Break"><strong class="source-inline">chapter1/recipe1-5/start</strong></span><span class="No-Break"> folder.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">OpenAPI 3.0 is the new name of Swagger<a id="_idIndexMarker069"/> after it was donated by SmartBear to the OpenAPI Initiative. You will likely find a lot of documentation still using the name <em class="italic">Swagger</em> when referring <span class="No-Break">to OpenAPI.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor049"/>How to do it...</h2>
			<p>Let’s document our RESTful API<a id="_idIndexMarker070"/> with OpenAPI and start testing<a id="_idIndexMarker071"/> from the nice OpenAPI <span class="No-Break">user interface:</span></p>
			<ol>
				<li>Open the <strong class="source-inline">pom.xml</strong> file of RESTful API project and add the SpringDoc OpenAPI Starter WebMVC UI dependency, <strong class="source-inline">org.springdoc:springdoc-openapi-starter-webmvc-ui</strong>. To add the dependency, insert the following XML into the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">dependencies&gt;</strong></span><span class="No-Break"> element:</span><pre class="source-code">
&lt;dependencies&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
      &lt;artifactId&gt;springdoc-openapi-starter-webmvc- ui&lt;/artifactId&gt;
      &lt;version&gt;2.2.0&lt;/version&gt;
   &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></li>			</ol>
			<p class="callout-heading">Important</p>
			<p class="callout">For brevity, I removed the other dependencies from the code snippet, but you should keep all of them in <span class="No-Break">your code.</span></p>
			<ol>
				<li value="2">Now you can execute this application and open the following URL in your browser: <strong class="source-inline">http://localhost:8080/v3/api-docs</strong>. It returns the description of your RESTful API in OpenAPI format. You can also open <strong class="source-inline">http://localhost:8080/swagger-ui/index.html</strong> for a nice user interface to interact with <span class="No-Break">your API.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer009">
					<img alt="Figure 1.2: Open API (Swagger) UI for our RESTful API" src="image/B21646_01_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: Open API (Swagger) UI for our RESTful API</p>
			<ol>
				<li value="3">As you can see, it exposes<a id="_idIndexMarker072"/> all the RESTful operations defined<a id="_idIndexMarker073"/> in the application and the data model used, in this case, <strong class="source-inline">Player</strong>. Now you can use the browser to execute any of the <span class="No-Break">operations available.</span></li>
			</ol>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor050"/>How it works...</h2>
			<p>The <strong class="source-inline">org.springdoc:springdoc-openapi-starter-webmvc-ui</strong> dependency examines the application at runtime to generate the description of the endpoints available. The core of OpenAPI is the service definition that can be found at http://localhost:8080/v3/api-docs. That is a JSON document that follows the OpenAPI schema and describes the RESTful endpoints hosted in the application. An endpoint is a combination of a path, HTTP method, parameters, responses, and <span class="No-Break">data schemas.</span></p>
			<p>The other interesting feature provided<a id="_idIndexMarker074"/> by the OpenAPI dependency<a id="_idIndexMarker075"/> is a nice UI that uses the OpenAPI schema to provide a basic interaction with the service. It can replace <strong class="source-inline">curl</strong> to test the RESTful service as it’s not necessary to remember all <span class="No-Break">possible arguments.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor051"/>Consuming a RESTful API from another Spring Boot application using FeignClient</h1>
			<p>Now that we have a RESTful API<a id="_idIndexMarker076"/> and it’s properly<a id="_idIndexMarker077"/> documented, we can create a consumer application. There are many tools to generate the client code from the OpenAPI specification, but in this project, we will create the client code manually for <span class="No-Break">learning purposes.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor052"/>Getting ready</h2>
			<p>We will enhance the RESTful API created in the previous recipe. If you haven’t completed that yet, you can find a working version in the book’s GitHub repo <span class="No-Break">at </span><a href="http://ebay.co.uk"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></p>
			<p>You can find the code to start this exercise in the <span class="No-Break"><strong class="source-inline">chapter1/recipe1-6/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>We will create a new Spring Boot application using the Spring Initializr tool <span class="No-Break">again (</span><a href="https://start.spring.io"><span class="No-Break">https://start.spring.io</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor053"/>How to do it...</h2>
			<p>We’ll create a Spring Boot application consuming the Football RESTful API created in the <span class="No-Break">previous recipe:</span></p>
			<ol>
				<li>First, we’ll create a new Spring Boot<a id="_idIndexMarker078"/> application. Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same<a id="_idIndexMarker079"/> parameters as in the <em class="italic">Creating a RESTful API</em> recipe, except for changing the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">albums</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">OpenFeign</strong></span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer010">
					<img alt="Figure 1.3: Spring Initializr for consumer application" src="image/B21646_01_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: Spring Initializr for consumer application</p>
			<ol>
				<li value="2">Generate the project to download the ZIP file. Extract the project and <span class="No-Break">open </span><span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break">.</span></li>
				<li>Create a record named <strong class="source-inline">Player</strong> and add the <span class="No-Break">following code:</span><pre class="source-code">
public record Player(String id, Integer jerseyNumber,
                     String name, String position,
                     LocalDate dateOfBirth) {
}</pre></li>				<li>Create an interface<a id="_idIndexMarker080"/> named <strong class="source-inline">FootballClient</strong> and add<a id="_idIndexMarker081"/> the <span class="No-Break">following code:</span><pre class="source-code">
<strong class="bold">@FeignClient(name = "football", url = "http://localhost:8080")</strong>
public interface FootballClient {
<strong class="bold">    @RequestMapping(method = RequestMethod.GET,</strong>
<strong class="bold">                    value = "/players")</strong>
    List&lt;Player&gt; getPlayers();
}</pre></li>				<li>Create a controller named <strong class="source-inline">AlbumsController.java</strong> with the <span class="No-Break">following code:</span><pre class="source-code">
@RestController
@RequestMapping("/albums")
public class AlbumsController {
<strong class="bold">     private final FootballClient footballClient;</strong>
     public AlbumsController(FootballClient footballClient) {
          this.footballClient = footballClient;
     }
     @GetMapping("/players")
     public List&lt;Player&gt; getPlayers() {
          return <strong class="bold">footballClient.getPlayers();</strong>
     }
}</pre><p class="list-inset">Modify the <strong class="source-inline">AlbumsApplication</strong> application<a id="_idIndexMarker082"/> class by adding<a id="_idIndexMarker083"/> the <strong class="source-inline">@EnableFeignClients</strong> <span class="No-Break">annotation:</span></p><pre class="source-code"><strong class="bold">@EnableFeignClients</strong>
@SpringBootApplication
public class AlbumsApplication {
}</pre></li>				<li>Now execute the application by executing the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
./mvnw spring-boot:run \
-Dspring-boot.run.arguments=-- server.port=8081</pre><p class="list-inset">The additional parameter is to run this application listening on port <strong class="source-inline">8081</strong>, instead of the default <strong class="source-inline">8080</strong>. The other application is listening on port <strong class="source-inline">8080</strong>, hence we need to avoid <span class="No-Break">port conflicts.</span></p></li>				<li>Then test <span class="No-Break">the application:</span><pre class="source-code">
curl http://localhost:8081/albums/players</pre><p class="list-inset">You will receive a response similar <span class="No-Break">to this:</span></p><pre class="source-code">[{"id":"1884823","jerseyNumber":5,"name":"Ivana ANDRES","position":"Defender","dateOfBirth":"1994-07- 13"},{"id":"325636","jerseyNumber":11,"name":"Alexia PUTELLAS","position":"Midfielder","dateOfBirth":"1994-02-04"}]</pre></li>			</ol>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>How it works...</h2>
			<p>Feign is a <strong class="bold">declarative</strong> web service<a id="_idIndexMarker084"/> client framework that simplifies making HTTP requests<a id="_idIndexMarker085"/> to RESTful web services. You create a Feign client by defining an <strong class="bold">interface</strong> that specifies the HTTP requests you want to make to a particular service. The methods in this interface are annotated with annotations similar to <strong class="source-inline">@RequestMapping</strong>, such as <strong class="source-inline">@GetMapping</strong>, <strong class="source-inline">@PostMapping</strong>, and <strong class="source-inline">@PutMapping</strong>, to specify the HTTP method and the URL path. Indeed, the annotations are the same as those used in the <span class="No-Break">server-side application.</span></p>
			<p>You can inject the Feign client interface into your Spring components and use it to make HTTP requests. Spring Cloud Feign will automatically generate and execute the HTTP requests based on the interface definition. By decorating the application class with <strong class="source-inline">@EnableFeignClients</strong>, it scans the application for interfaces with the <strong class="source-inline">@FeignClient</strong> annotation and generates <span class="No-Break">the client.</span></p>
			<p>In the controller, we can then use the Feign client simply via Spring Boot <span class="No-Break">dependency injection.</span></p>
			<p>Do note that we passed an additional parameter, <strong class="source-inline">-Dspring-boot.run.arguments=--</strong> <strong class="source-inline">server.port=8081</strong>, to execute the client application. The reason is that the RESTful API is already using port <strong class="source-inline">8080</strong> so we need to execute the client application in a <span class="No-Break">different port.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor055"/>There’s more...</h2>
			<p>There are other options than Feign to perform the requests. I decided to use Feign due to its great integration with Spring Cloud components, such as Eureka Server. We will see in the following recipes how to integrate with Spring Cloud and how it can do load balancing on the <span class="No-Break">client side.</span></p>
			<p>Most of the code on the client side in this recipe can be automatically generated using IDE integrations or standalone tools. These tools are especially useful to maintain the client-side code in sync with the server descriptions. These tools use OpenAPI descriptions exposed by the RESTful API to generate the <span class="No-Break">client code:</span></p>
			<ul>
				<li><span class="No-Break">OpenAPITools: </span><a href="https://github.com/OpenAPITools/openapi-generator"><span class="No-Break">https://github.com/OpenAPITools/openapi-generator</span></a></li>
				<li><span class="No-Break">swagger-codegen: </span><a href="https://github.com/swagger-api/swagger-codegen"><span class="No-Break">https://github.com/swagger-api/swagger-codegen</span></a></li>
			</ul>
			<p>Both projects provide a command-line tool and a Maven plugin to generate <span class="No-Break">client-side code.</span></p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor056"/>Consuming a RESTful API from another Spring Boot application using RestClient</h1>
			<p>In this recipe, we’ll use a new<a id="_idIndexMarker086"/> component introduced in Spring Framework 6.1 and available in Spring Boot since version 3.2. In the previous recipe, we created a FeignClient by creating an interface in the client application and defining the same methods available in the target service. By using the RestClient component, we will have a fluent API that offers an abstraction over HTTP libraries. It allows converting from Java objects to HTTP requests, and the other way round, the creation of objects from the <span class="No-Break">HTTP responses.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor057"/>Getting ready</h2>
			<p>We will enhance the RESTful API created in the <em class="italic">Using OpenAPI to document our RESTful API</em> recipe. If you haven’t completed it yet, you can find a working version in the book’s GitHub repo <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></p>
			<p>You can find the code to start this exercise in the <span class="No-Break"><strong class="source-inline">chapter1/recipe1-7/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>We will create a new Spring Boot application using the Spring Initializr tool <span class="No-Break">again (</span><a href="https://start.spring.io"><span class="No-Break">https://start.spring.io</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>How to do it...</h2>
			<p>We’ll create a new Spring Boot<a id="_idIndexMarker087"/> application using the Spring Initializr tool that will consume the RESTful API created in the <em class="italic">Using OpenAPI to document our RESTful </em><span class="No-Break"><em class="italic">API</em></span><span class="No-Break"> recipe:</span></p>
			<ol>
				<li>Let’s start by creating a new Spring Boot application using the Spring Initializr tool. To do this, open <a href="https://start.spring.io">https://start.spring.io</a> in your browser and use the same parameters as in the <em class="italic">Creating a RESTful API</em> recipe, except for changing the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">albums</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <span class="No-Break"><strong class="bold">Spring Web</strong></span></li></ul></li>
				<li>Now, create a configuration class named <strong class="source-inline">AlbumsConfiguration</strong> in which we define a <span class="No-Break"><strong class="source-inline">RestClient</strong></span><span class="No-Break"> bean:</span><pre class="source-code">
<strong class="bold">@Configuration</strong>
public class AlbumsConfiguration {
    @Value("${football.api.url:http://localhost:8080}")
    String baseURI;
    @Bean
    <strong class="bold">RestClient</strong> restClient() {
        return <strong class="bold">RestClient.create(baseURI)</strong>;
    }
}</pre><p class="list-inset">Note that we defined a field with the <strong class="source-inline">@Value</strong> annotation to configure the URL of the <span class="No-Break">remote server.</span></p></li>				<li>Next, create a service class named <strong class="source-inline">FootballClientService</strong>. This class will use the Spring Boot container to inject the <strong class="source-inline">RestClient</strong> bean in <span class="No-Break">the constructor:</span><pre class="source-code">
@Service
public class FootballClientService {
    private RestClient restClient;
    public FootballClientService(<strong class="bold">RestClient restClient</strong>) {
        this.restClient = restClient;
    }
}</pre></li>				<li>Now, you can use the <strong class="source-inline">RestClient</strong> to retrieve<a id="_idIndexMarker088"/> the data from the remote RESTful API. You can create a method named <strong class="source-inline">getPlayers</strong> <span class="No-Break">as follows:</span><pre class="source-code">
public List&lt;Player&gt; getPlayers() {
    return <strong class="bold">restClient</strong>.get().uri("/players").retrieve()
       .body(new ParameterizedTypeReference&lt;List&lt;Player&gt;&gt;(){ });
}</pre></li>				<li>Next, you can create another method to get just a single player from the remote <span class="No-Break">RESTful API:</span><pre class="source-code">
public Optional&lt;Player&gt; getPlayer(String id) {
    return restClient.get().uri("/players/{id}", id)
       .exchange((request, response) -&gt; {
           if (response.getStatusCode().equals(HttpStatus.NOT_FOUND)) {
              return Optional.empty();
           }
           return Optional.of(response.bodyTo(Player.class));
      });
}</pre></li>				<li>Finally, you can create an Album RESTful API using the <strong class="source-inline">FootballClientService</strong> service. I created a sample version that you can find in the book’s <span class="No-Break">GitHub repository.</span></li>
			</ol>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor059"/>How it works...</h2>
			<p>In this recipe, we didn’t create any additional<a id="_idIndexMarker089"/> type to replicate the remote RESTful API. Instead, we used the <strong class="source-inline">RestClient</strong> to perform requests using the Fluent API style, that is, using the result of a method to chain a call to another method. This Fluent API design is easier to read, that’s why it’s <span class="No-Break">named “Fluent”.</span></p>
			<p>Let’s analyze what we did in the <span class="No-Break"><strong class="source-inline">getPlayer</strong></span><span class="No-Break"> method:</span></p>
			<ul>
				<li>We started by calling the <strong class="source-inline">get</strong> method, which returns an object that can be used to set the request’s properties, such as the URI, the headers, and other request parameters. We just set the remote address by using the <strong class="source-inline">uri</strong> method. Note that this address is appended to the base address defined in the <span class="No-Break"><strong class="source-inline">AlbumsConfiguration</strong></span><span class="No-Break"> class.</span></li>
				<li>When we called the <strong class="source-inline">exchange</strong> method, the RestClient performed the call to the remote RESTful API. Then, the method exchange provides a handler to manage <span class="No-Break">the response.</span></li>
				<li>In the response handler, we control what happens if the player is not found, in which case we return an empty object. Otherwise, we use the <strong class="source-inline">bodyTo</strong> method, which allows passing a type to be used to deserialize the response. In this example, we used the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> class.</span></li>
			</ul>
			<p>The code for <strong class="source-inline">getPlayers</strong> is very similar to <strong class="source-inline">getPlayer</strong>; the main difference is that the result is a <strong class="source-inline">List</strong> of players. To specify this, it was necessary to use the <strong class="source-inline">ParameterizedTypeReference</strong> class to pass a generic type. To capture the generic type, it’s necessary to define a subclass of <strong class="source-inline">ParameterizedTypeReference</strong>, which we did by defining an anonymous inline class. That’s why we added the new <strong class="source-inline">ParameterizedTypeReference&lt;List&lt;Player&gt;&gt;(){ }</strong>, including the curly braces <strong class="source-inline">{ }</strong> at <span class="No-Break">the end.</span></p>
			<p>In this recipe, we used the <strong class="source-inline">@Value</strong> annotation in the <strong class="source-inline">AlbumsConfiguration</strong> class. This annotation allows us to inject values from external sources, for instance from configuration files or environment variables. The value <strong class="source-inline">"${football.api.url:http://localhost:8080}"</strong> means that it will try to get the <strong class="source-inline">footbal.api.url</strong> configuration property first. If it’s not defined, it will take the default <span class="No-Break">value, </span><span class="No-Break"><strong class="source-inline">http://localhost:8080</strong></span><span class="No-Break">.</span></p>
			<p>You will see that the format of the properties will change depending on whether they are defined in the <strong class="source-inline">application.properties</strong> file or the <strong class="source-inline">application.yml</strong> file. In the <strong class="source-inline">application.properties</strong> file, you will see the full property in a single line. That <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">football.api.url=http://localhost:8080</strong></span><span class="No-Break">.</span></p>
			<p>On the other hand, the <strong class="source-inline">application.yml</strong> file can nest the properties, so you will see <span class="No-Break">the following:</span></p>
			<pre class="source-code">
football:
  api:
    url: http://locahost:8080</pre>			<p>In this book, I’ll use the <strong class="source-inline">application.yml</strong> file in most of the cases, but<a id="_idIndexMarker090"/> you will encounter the <strong class="source-inline">application.properties</strong> format as well, such as when using the <span class="No-Break">environment variables.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor060"/>Mocking a RESTful API</h1>
			<p>The main drawback of using a remote service<a id="_idIndexMarker091"/> as we did in the previous recipes is that you need the remote service running when you test your client application. To tackle this scenario, you can <strong class="bold">mock</strong> a remote server. By <em class="italic">mock</em>, I mean simulating the behavior of a component or service, in this case, the <span class="No-Break">remote service.</span></p>
			<p>Mocking a remote dependency in a test can be useful for several reasons. One of the main reasons is that it allows you to test your code in isolation, without having to worry about the behavior of the remote dependency. This can be especially useful if the remote dependency is unreliable or slow, or if you want to test your code in different scenarios that are difficult to reproduce with the <span class="No-Break">remote dependency.</span></p>
			<p>In this recipe, we’ll learn how to use Wiremock to mock the remote <strong class="source-inline">Football</strong> service in our Albums application during the <span class="No-Break">testing execution.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor061"/>Getting ready</h2>
			<p>In this recipe, we’ll create the tests for the application we built in the <em class="italic">Consuming a RESTful API from another Spring Boot application using RestClient</em> recipe. If you haven’t completed that recipe yet, I have prepared a working version of the recipe that can be found in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter1/recipe1-8/start</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>How to do it...</h2>
			<p>We’ll add the Wiremock dependency to our project and then we’ll be able to create isolated tests for our <span class="No-Break">Albums application:</span></p>
			<ol>
				<li>The first thing to do is to add the Wiremock dependency to the Albums project. To do so, open the <strong class="source-inline">pom.xml</strong> file and add the <span class="No-Break">following dependency:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt;
    &lt;artifactId&gt;wiremock-standalone&lt;/artifactId&gt;
    &lt;version&gt;3.0.1&lt;/version&gt;
    <strong class="bold">&lt;scope&gt;test&lt;/scope&gt;</strong>
&lt;/dependency&gt;</pre></li>				<li>Now, we can create a test class<a id="_idIndexMarker092"/> for our <strong class="source-inline">FootballClientService</strong>. Let’s name the test class <strong class="source-inline">FootballClientServiceTest</strong>. We’ll use the <strong class="source-inline">@SpringBootTest</strong> annotation to pass a property with the remote <span class="No-Break">server address:</span><pre class="source-code">
<strong class="bold">@SpringBootTest</strong>(properties = { "<strong class="bold">football.api.url=http://localhost:7979</strong>" })
public class FootballClientServiceTests {
}</pre></li>				<li>Then, we need to set up a Wiremock server in the test. Add the following content to the <span class="No-Break"><strong class="source-inline">FootballClientServiceTest</strong></span><span class="No-Break"> class:</span><pre class="source-code">
private static WireMockServer wireMockServer;
<strong class="bold">@BeforeAll</strong>
static void init() {
    wireMockServer = new WireMockServer(<strong class="bold">7979</strong>);
    wireMockServer.start();
    WireMock.configureFor(<strong class="bold">7979</strong>);
}</pre></li>				<li>Now, we can declare a <strong class="source-inline">FootballClientService</strong> field that will be injected by Spring Boot. Annotate it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Autowired</strong></span><span class="No-Break">:</span><pre class="source-code">
@Autowired
FootballClientService footballClientService;</pre></li>				<li>Then, write a test to validate the <span class="No-Break"><strong class="source-inline">getPlayer</strong></span><span class="No-Break"> method.</span><ol><li class="upper-roman">Name the <span class="No-Break">test </span><span class="No-Break"><strong class="source-inline">getPlayerTest</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
<strong class="bold">@Test</strong>
public void getPlayerTest() {</pre><ol><li class="upper-roman" value="2">Let’s start first by arranging<a id="_idIndexMarker093"/> the result of the remote service. Add the following code to <span class="No-Break">the test:</span></li></ol><pre class="source-code">WireMock.stubFor(WireMock.get(WireMock.urlEqualTo("/players/325636"))
          .willReturn(WireMock.aResponse()
          .withHeader("Content-Type", "application/json")
          .withBody("""
                  {
                      "id": "325636",
                      "jerseyNumber": 11,
                      "name": "Alexia PUTELLAS",
                      "position": "Midfielder",
                      "dateOfBirth": "1994-02-04"
                   }
                   """)));</pre><ol><li class="upper-roman" value="3">Next, call the <strong class="source-inline">getPlayer</strong> method. This method<a id="_idIndexMarker094"/> depends on the <span class="No-Break">remote service:</span></li></ol><pre class="source-code">Optional&lt;Player&gt; player = footballClientService.<strong class="bold">getPlayer</strong>("325636");</pre><ol><li class="upper-roman" value="4">And then validate <span class="No-Break">the results:</span></li></ol><pre class="source-code">Player expectedPlayer =new Player("325636", 11, "Alexia PUTELLAS", "Midfielder", LocalDate.of(1994, 2, 4));
assertEquals(expectedPlayer, player.get());</pre></li>				<li>As an exercise, you can create tests for the rest of methods of the <strong class="source-inline">FootballClientService</strong> class and also other scenarios, such as simulating different responses from the remote server. You can find a few more tests prepared in the book’s <span class="No-Break">GitHub repository.</span></li>
			</ol>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>How it works...</h2>
			<p>Wiremock is a library for API mock testing. It can run as an independent tool or as a library, as we did in this recipe. Wiremock is necessary for tests only, and for that reason, we configured the <strong class="source-inline">scope</strong> dependency as <strong class="source-inline">test</strong>. There is a known incompatibility with Spring Boot version 3.2.x. Spring Boot uses Jetty 12, while Wiremock depends on Jetty 11. To avoid that incompatibility we used the <strong class="source-inline">wiremock-standalone</strong> artifact instead of the <strong class="source-inline">wiremock</strong> artifact, as it includes all <span class="No-Break">required dependencies.</span></p>
			<p>The Wiremock project is not part of the Spring Boot framework, however, it is a popular option for mocking services in <span class="No-Break">Spring projects.</span></p>
			<p>In this recipe, we used the <strong class="source-inline">@SpringBootTest</strong> annotation as it uses the SpringBoot context and allows passing custom environment variables with the <strong class="source-inline">properties</strong> field. We used the properties to pass the address of the remote server where we configured Wiremock. We used a different server address to avoid conflicts with the real remote server in case it was running on the machine for <span class="No-Break">whatever reason.</span></p>
			<p>We also used <strong class="source-inline">@BeforeAll</strong> to run the Wiremock server initialization before each test was executed. In that initialization, we configured the Wiremock server to listen on port <strong class="source-inline">7979</strong>, matching the configuration passed in the <span class="No-Break"><strong class="source-inline">properties</strong></span><span class="No-Break"> field.</span></p>
			<p>With <strong class="source-inline">StubFor</strong> we configured the desired behavior for the remote server: when receiving a <strong class="source-inline">GET</strong> request for <strong class="source-inline">/players/325636</strong>, it should return a JSON with the mocked player. The rest is just normal<a id="_idIndexMarker095"/> test validation to make sure the result is <span class="No-Break">as expected.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor064"/>See also</h2>
			<p>You c<a id="_idTextAnchor065"/>an find more information<a id="_idIndexMarker096"/> about Wiremock on the project web page <span class="No-Break">at </span><a href="https://www.wiremock.io/"><span class="No-Break">https://www.wiremock.io/</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>