- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Discovering the Java Platform for Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many years ago, motivated by the lack of a suitable **Application Programming
    Interface** (**API**) design, something extraordinary began to happen. In the
    early days of using the **World Wide Web** (**WWW**), the direction of application
    development was a bit shrouded in fog. In one direction, there was a strong need
    in the industry to process a large number of database transactions or develop
    specific proprietary hardware and software. On the other hand, it was not clear
    what kind of applications might be needed to move the demand forward and how such
    an application should be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will prepare the ground for understanding the value of
    design patterns from a memory utilization perspective. We will do so by covering
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The rise of Java and brief historical facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Java platform works under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Java memory area allocation and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How allocated heap is maintained with garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the first program on the platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The threading nature of the Java platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the core Java APIs and their values for software design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the importance of the Java Platform Module System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering new helpful platform enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Java concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a good understanding of memory allocation
    on the Java platform, platform guarantees, core APIs, and more. Together with
    the content of the previous chapter, these topics will form a well-prepared foundation
    so that you can start with design patterns with full awareness of their benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter are available on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Knocking on Java’s door
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early 1990s, a small team at Sun Microsystems was formed in order to
    discover new horizons. The team started with the consideration of extending the
    C++ features available in those days. One of the goals was to introduce a new
    generation of software for a small smart device. The introduction of software
    reusability was a part of this. Small smart devices such as set-top boxes did
    not have much memory and had to use their resources wisely. The memory, among
    other things, such as its complexity, error-prone programs, and probably James
    Gosling’s language extension attempt, later led to the rejection of the C++ idea.
    Instead of struggling with C++, a new language called **Oak** was created in lieu.
    Due to the trademark issue, the newly created language Oak was renamed Java.
  prefs: []
  type: TYPE_NORMAL
- en: The first public Java version 1.0a.2, together with HotJava Browser, was announced
    at the SunWorld conference in 1995 by John Gage, the director of science at Sun
    Microsystems. He was involved in re-directing the Java language from being a language
    for small hardware devices to being a platform for WWW applications. In these
    early days, Java was used as part of a website using a technology known as an
    applet. Java applets were small sandboxes, defined by the frame with limited access
    and the capability to execute Java bytecode on the local **Java Virtual Machine**
    (**JVM**). Applets resided on a web browser or as a standalone application; they
    were a very powerful tool that supported one of the basic Java principles, **Write
    Once, Run Anywhere** (**WORA**). However, due to many issues (such as security
    and stability), the applet technology was marked for removal (Java SE 17).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java platform consists of three main parts (*Figure 2**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.1 \uFEFF– Java Development Kit architecture](img/B18884_02_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Java Development Kit architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'These parts are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java SE (Standard Edition) Runtime** **Environment** (**JRE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java SE Development** **Kit** (**JDK**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start an exciting journey through the platform itself and each part.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the model and functionality of the Java platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'History has shown us that the intended direction can evolve or change: Java
    is a nice example and is no exception. From its original purpose, it has moved
    from a platform for smart devices to a platform for entire web solutions, but
    its development did not stop there. Over the years, Java has become one of the
    most widely used languages for application development. This can be taken as a
    side effect of basic hardware independence. It dramatically developed an available
    set of tools and received a very positive response from a vibrant community.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us review each part of the platform (from *Figure 2**.1*) individually as
    it will boost our understanding of writing code.
  prefs: []
  type: TYPE_NORMAL
- en: The JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JDK is a software development environment that provides the tools and libraries
    needed to develop and analyze Java applications. The JDK provides a collection
    of basic libraries, functions, and programs needed to compile written code into
    bytecode. The JDK contains the JRE required to run the application. The JDK also
    provides some very useful tools, such as the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jlink`: This helps generate a custom JRE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jshell`: This is a handy **Read-Evaluate-Print-Loop** (**REPL**) tool to try
    the Java language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jcmd`: This is a utility to send a diagnostic command to the active JVM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javac`: This is the Java compiler, which reads an input file with the `.java`
    suffix and produces a Java class file with the `.``class` suffix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java`: This executes a JRE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Others: Located in the JDK `bin` directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is written (*Example 2.1*) and stored in a `.java` file and compiled
    using the `javac` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.1 – Simple Java program as an executable class that can also be run
    directly without a compilation step since Java SE 11 (*Reference 26*)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, it is possible to create and compile a class with bytecode inside (*Example
    2.2*). Run the file using the `java` command to run the JRE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.2 – Bytecode example from a compiled program displayed by the Java
    program
  prefs: []
  type: TYPE_NORMAL
- en: The JRE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JRE is part of the JDK, or it can be distributed as a standalone program
    for the target operating system. To run a file with a `.class` extension or a
    **Java Archive** (**JAR**) file, the target system is required to contain the
    appropriate version of the JRE. Unlike the JDK, the JRE only contains a minimal
    collection of components needed to run the program, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Core libraries and property files: for example, `rt.jar` and `charset.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java extension files: Additional libraries that may reside in the `lib` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security-related files: Certificates, policies, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system-specific tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JRE includes a JVM and precisely two types of compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Compiler**: Fast loading without optimization. It is designed to run
    the instructions to obtain a result very quickly. Commonly used for standalone
    programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server Compiler**: Loaded code goes through additional checks to ensure code
    stability. There is also an effort to produce highly optimized machine code to
    deliver better performance. It supports better statistics in order to run machine
    code optimization executed by the **Just-in-Time** (**JIT**) compiler (*Figure
    2**.2*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the JDK and the JRE contain the JVM (*Reference 6*). The JVM is platform-dependent.
    This means that every system platform requires the use of a dedicated version.
    Fine, but what does the JVM really do, and how?
  prefs: []
  type: TYPE_NORMAL
- en: Although there are multiple versions of the JVM, even from multiple vendors,
    the JVM itself is defined by a specification that must be followed. The reference
    implementation is represented by OpenJDK. In fact, OpenJDK is a collection of
    several smaller open source projects that may even have different development
    dynamics, but the OpenJDK release contains planned versions of each.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Key parts of the JVM](img/B18884_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Key parts of the JVM
  prefs: []
  type: TYPE_NORMAL
- en: The OpenJDK JVM implementation (*Figure 2**.2*) includes a JIT compiler called
    **HotSpot** (*Reference 7*). HotSpot is part of the JVM and its responsibility
    is runtime compilation. In other words, the JIT compiler translates or compiles
    the provided bytecode into a native system instruction at runtime. This process
    is sometimes called **dynamic translation**. Due to these JVM dynamic translation
    capabilities, Java applications are sometimes referred to as system platform-independent
    and the WORA acronym is used. This statement needs to be abstracted slightly because
    a JVM system implementation is required to translate the bytecode into a native
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the JVM JIT compiler, it includes a garbage collector with various
    algorithms, a class loader, a Java memory implementation model, and a **Java Native
    Interface** (**JNI**) with libraries (as shown in *Figure 2**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: Every JVM provider must follow the specifications. This guarantees that the
    bytecode will not only be created accordingly but also executed and correctly
    converted into machine instructions. This means that different vendors may provide
    different JVM implementations with slightly different metrics or optimizations,
    such as garbage collector dynamics. These vendors include IBM, Azul, Oracle, and
    so on. The diversity of vendors can be considered one of the main moving factors
    for the Java platform's evolution. New features are extended or modified through
    the **JDK Enhancement Proposal** (**JEP**), where each vendor can contribute or
    get a very detailed overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the JVM’s responsibilities to remember are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiating classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program instruction execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JVM defines several different areas used by each program (*Example 2.2*).
    Let’s look at each of them one by one, area by area (*Figure 2**.2*). This can
    boost our understanding of the value of design patterns and their approaches,
    such as the Builder or Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Simplified schema of program compilation and execution](img/B18884_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Simplified schema of program compilation and execution
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with written text, representing a program stored in a `.java`
    file. The file will be compiled (*Figures 2.3*) and run (*Figure 2**.4*) and threads
    are started. Startup starts the system process in which the JRE is running and
    the JVM is running as part of the JRE.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.4 – Threads\uFEFF that started behind the scene event for a Program.java\
    \ execution example (Java Flight Recorder)](img/B18884_02_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Threads that started behind the scene event for a Program.java
    execution example (Java Flight Recorder)
  prefs: []
  type: TYPE_NORMAL
- en: With a general idea of the flow, let’s start by loading classes into memory.
  prefs: []
  type: TYPE_NORMAL
- en: The class-loader loader area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The class loader subsystem is located in **Random-Access Memory** (**RAM**)
    and is responsible for loading classes into memory. The load step consists of
    the sub-line steps and the first run of the class at runtime. Linking is the process
    of preparing a class or interface for a runtime environment, which may include
    internal dependencies, for example. The platform provides internal functions or
    customized ones; to manage all these capabilities, the platform provides dedicated
    class loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BOOTPATH` (property).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib/ext` directory, which is a part of the JRE installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` method and runs the classes from the served class or module path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassLoader` and may be used to define custom classes dynamically loading
    processes to the JVM. It is possible to use a user-defined class destination.
    Classes can reside on the network, be encrypted inside files, or be downloaded
    across the network and generated on the fly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class loaders work in sequence. The sequence is represented by a hierarchy.
    This means that every child must refer to its parents. This automatically defines
    the search order of the binary classes.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is present in RAM, the Java platform takes action to make the class
    available to the runtime environment. The Java platform runs several processes
    behind the scenes to move relevant class data to other areas, such as the stack,
    heap, and so on. Let’s look at the stack area next.
  prefs: []
  type: TYPE_NORMAL
- en: The stack area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The stack area (*Figure 2**.2*) is reserved for each thread at runtime. This
    is a small area for storing method references. When a thread executes a method,
    one entry for that method is created and moved to the top of the stack. This kind
    of item is called a stack frame, which has a reference to a field of local variables,
    a stack of operands, and a constant pool to identify the appropriate method. The
    stack frame is removed when the method is executed normally – that is, without
    causing any exceptions. This means that local primitive variables such as `boolean`,
    `byte`, `short`, `char`, `int`, `long`, `float`, and `double` are also stored
    here, so they are not visible to the second thread. Each thread can pass a copy,
    but this does not share the origin.
  prefs: []
  type: TYPE_NORMAL
- en: The heap area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heap is the allocated memory where all instances of the class and array
    are located. The heap is allocated at startup and is shared among all JVM-initiated
    threads. Allocated memory is automatically recovered by the automated management
    system process, also known as **Garbage Collection** (**GC**). A local variable
    can contain a reference to objects. The referenced object is located in a heap.
  prefs: []
  type: TYPE_NORMAL
- en: The method area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The method area is shared across all JVM-initiated threads. The area is allocated
    during the JVM startup time. It contains runtime data for each class, such as
    a constant pool, field and method data, the code for constructors, and methods.
    Probably the most unfamiliar term mentioned is the constant pool. The constant
    pool is created during the process of loading the class into the method area.
    It contains the initial values of string and primitive constants, the names of
    the reference classes and other data needed to properly execute the loaded class,
    the constants known at compile time, and field references that must be resolved
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Program counter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Program Counter** (**PC**) register is another important reserved area
    in memory. It contains a list of created program counters. A PC record is created
    at the beginning of each thread and contains the address of the currently executed
    instruction by a specific thread. The address points back to the method area.
    The only exception is the native method, which leaves the address undefined.
  prefs: []
  type: TYPE_NORMAL
- en: The native method stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A native method stack record is initiated for each individual thread. Its function
    is to provide access to native methods through the JNI. The JNI operates with
    the underlying system resources. Improper usage may turn into two exceptional
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: The first exception appears when a thread requires more stack space. In this
    case, a `StackOverflowError` error is thrown and the program crashes, executed
    with a state higher than 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second case represents an attempt to add more entries to the stack. The
    program results in an `OutOfMemoryError` error. It is caused by an attempt to
    dynamically expand already fully allocated memory space. The memory is insufficient
    and it is not possible to allocate a new stack for the newly intended thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have examined all the areas required to load and execute a program and we
    will get acquainted with the areas where the data is located and how they are
    interconnected. It is slowly becoming clear that in order to achieve stability
    and maintainability of the program at runtime, it is necessary to design the software
    in a way that reflects the potential limitations, as the reserved areas correspond
    to the individual areas.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at how the Java platform provides available memory
    space for each newly created object.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing GC and the Java memory model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned the JIT compiler as part of the JVM earlier (*Figure 2**.2*). Just
    to refresh on the JIT compiler, it is responsible for translating the bytecode
    into system-specific native instructions. These instructions deal with the basic
    memory and I/O resources available to the program. To properly organize these
    instructions, the Java platform requires a set of rules that guarantee the program,
    called bytecode, which must be translated by the JIT compiler at runtime to the
    same end. Because the Java platform does not use physical memory directly, but
    rather virtual and cached views, it is very important that the memory management
    is transparent. The model must provide the required guarantees and is known as
    the **Java Memory** **Model** (**JMM**).
  prefs: []
  type: TYPE_NORMAL
- en: The JMM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JMM describes how threads interact with each other through access to allocated
    memory – the heap (*Figure 2**.2*). The execution of a single-threaded program
    may seem obvious because the instructions are processed in a certain order without
    external influence and the thread is in isolation. In the case of a single thread
    (see the `main` method in *Example 2.2* and the `main` thread in *Figure 2**.4*),
    the run areas are modified each time the instruction is executed; there is no
    surprise. The situation changes when the program starts multiple threads. The
    JMM enforces its guarantees of reliable Java program execution. The JMM defines
    a set of rules for possible instruction order changes and execution restrictions
    caused by sharing objects in memory between different threads. The fact that the
    JMM strictly follows these rules forces JIT optimization without fear of code
    instability (maintaining a consistent state).
  prefs: []
  type: TYPE_NORMAL
- en: The rules can easily be reformulated and each action can be changed as long
    as the execution of the thread does not violate the program order. Basically,
    this means that the program remains in a consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: Object locks or releases are governed by the order of the program and each thread
    shares a corresponding memory view of the modified data. The memory view represents
    the portion of allocated physical memory represented by the heap because each
    object created is located inside the heap.
  prefs: []
  type: TYPE_NORMAL
- en: One of the important guarantees of the JMM is known as happens-before. It states
    that one action always happens before another in order to maintain the order of
    the program. To better understand this rule, it is necessary to describe how system
    memory works and briefly introduce the general types of memory and how the CPU
    fits into the process of reading values and executing machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start with the CPU. Each CPU contains its own instruction register. The
    machine code compiled by the JIT compiler has a reference to an available set
    of instructions. The CPU contains an internal cache used to store a copy of data
    from the main RAM. The CPU communicates with the reserved RAM. One CPU can run
    multiple platform threads (depending on the type of CPU) at the same time. The
    result of this embodiment modifies the state of the RAM in the thread stack or
    heap. The dedicated RAM for the running Java application is then copied to the
    CPU cache and used by the CPU registry (*Figure 2**.5*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – CPU and memory interaction](img/B18884_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – CPU and memory interaction
  prefs: []
  type: TYPE_NORMAL
- en: 'Those who are attentive may have already noticed that due to memory differentiation,
    the program can face unpredictable difficulties caused by looking at the program’s
    memory. When multiple threads try to update or read specific values of variables
    without careful handling, this can result in one of the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A racing condition**: This occurs when two threads attempt to access the
    same value in an unsynchronized manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value update visibility**: A variable update that is shared between multiple
    threads has not been propagated to the main memory, so other threads get the old
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To address these challenges, let’s analyze a real access to variables. What
    is already known is that each value is located within the allocated RAM heap.
    It seems obvious that updating the status of each variable may cause some penalties,
    as each instruction has to take a whole journey (*Figure 2**.5*). In most cases,
    this is also not necessary. A good example is the implementation of an isolated
    method (*Example 2.2*). However, there are cases where the actual value of a variable
    is required from memory, for which the Java platform has introduced the `volatile`
    keyword. Using the `volatile` keyword before a variable gives the variable a guarantee
    that when another thread requests a value, it checks its current value in the
    main memory. This means that using the `volatile` keyword provides a guarantee
    of happens-before and each thread sees its true value. It is fair to note that
    because using `volatile` provides a certain level of memory synchronization, it
    should be used wisely. Its use is associated with performance limitations caused
    by main memory access.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to sharing variable values across multiple threads is to use
    the `synchronized` keyword. Its use gives the method or variable a guarantee that
    each participant, the thread, will be informed about the approaches. Obviously,
    the main disadvantage of using `synchronized` is that all threads will be informed
    about access to the method or variables, which in turn, will cause a decrease
    in performance due to memory synchronization. As with `volatile`, `synchronized`
    guarantees happens-before.
  prefs: []
  type: TYPE_NORMAL
- en: The JMM is bright and fresh; we stated that each new object is located in the
    heap (*Figure 2**.2*). We are familiar with the big picture of the JRE architecture,
    and we know that most Java programs seem to be multi-threaded – there is a set
    of rules that the Java platform follows so that the process forces the correct
    order of programs to achieve consistency.
  prefs: []
  type: TYPE_NORMAL
- en: GC and automatic memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the Java platform may give the impression that the underlying memory
    is unlimited, this is not true and we will examine it next. So far, we have looked
    at how variable visibility works across multiple threads and how values are referenced
    in physical memory. The JMM is just one part of the whole story – let’s continue
    the investigation.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that the Java platform uses an automatic memory management process
    to maintain the allocated memory for the heap. Part of the process is a program
    that runs in the background of the daemon thread. It is called the garbage collector
    (*Reference 5*) and runs silently behind the scenes, reclaiming and compacting
    unused memory. This is one of the advantages of the dynamic allocation of objects
    in the heap. Another perhaps less obvious advantage is the ability to work with
    recursive data structures, such as lists or maps.
  prefs: []
  type: TYPE_NORMAL
- en: GC was invented around 1959 by John McCarthy. The goal was to simplify manual
    memory management in Lisp. Since then, GC has undergone massive development and
    various GC techniques have been invented (*Reference 1*). Even after the development
    of various GC approaches, the security rule remains the most important. The GC
    should never regain a repository of live objects that contain active references.
  prefs: []
  type: TYPE_NORMAL
- en: Although the developer does not have to bother with memory reclamation, it can
    be very useful to understand the underlying process to avoid unexpected application
    failures because system memory is limited in one way or another. The reason remains
    that even if the GC is in place, it is possible to create code that never loads
    the object, which means that the application may crash with an `OutOfMemoryError`
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the GC process is to keep the heap nice and shiny, ready to allocate
    a new object. The heap area is divided into smaller segments as shown in *Figure
    2**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Simplified heap structure divided into promotion segments](img/B18884_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Simplified heap structure divided into promotion segments
  prefs: []
  type: TYPE_NORMAL
- en: It is a known fact that most objects will be allocated and placed in Eden’s
    memory and will not survive the second round of cleanup. After performing Minor
    GC, all surviving objects are moved to one of the surviving spaces (denoted by
    **S0** and **S1**). The secondary GC round also checks the **S0** and **S1** fields
    and spreads them among the others at a time when one of the survival sites may
    be empty. The object survived; many Minor GCs have been moved to the **Old generation**.
    The heap also contains a permanent section. The permanent section contains the
    metadata required by the JVM to describe classes, static methods, and private
    variables, and is populated at runtime. This area was formerly known as the **Permanent
    generation** (**Permgen**). It was separated from the main heap memory, was not
    loaded, and had to be configured. This disadvantage often led to application instability
    due to insufficient memory requirements. Java SE 8 introduced MetaSpace, which
    replaced the Permgen concept. MetaSpace has solved the problem of space configuration
    because it can grow automatically and in addition, garbage can be collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'GC works essentially in two steps, described as Minor and Major GC. These steps
    are a proposal for building on the basis of durability – that is, long-term references:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minor GC**: This happens when there is no reference to the object, the object
    is marked as unreachable, the Young generation area is reclaimed, and the memory
    can be compacted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Major/Full GC**: An object that has survived several Minor GCs and has been
    moved to an Old generation heap area. After a long time, it does not refer to
    any other object, no other object refers to it, and it is ready to be deleted.
    Full GC is less common than Minor GC and there is a long pause (stop-the-world).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GC process can be simplified with three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, GC marks unreachable objects (*Figure 2**.7*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The first collection marking step identifies unused objects
    in the heap](img/B18884_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The first collection marking step identifies unused objects in
    the heap
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second step, the links are removed and the space is left free as it
    was (*Figure 2**.8*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Freeing memory by deleting marked objects](img/B18884_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Freeing memory by deleting marked objects
  prefs: []
  type: TYPE_NORMAL
- en: 'The third step is called compacting (*Figure 2**.9*). It reorganizes the memory
    into larger parts, so when a program tries to allocate a larger object, space
    is ready for it. This makes memory allocation for all objects much faster not
    only due to the free space but also eliminates the need to scan a free memory
    frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Compacting freed memory to be able to allocate bigger objects
    in frames](img/B18884_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Compacting freed memory to be able to allocate bigger objects in
    frames
  prefs: []
  type: TYPE_NORMAL
- en: 'With a fresh awareness of the tasks of the JMM and GC, there is another important
    concept related to both. The concept of reference types is a way to tell the platform
    how to handle a specific allocated part of the heap space – more specifically,
    how to help the platform’s internal analytical processes. Reference types have
    been added to help GC to evaluate the purpose of variables. This means speeding
    up the decision of whether to collect the variable or not. The concept of a reference
    type is a neat tool, along with a design pattern, and previously renewed themes
    make even more sense. The goal of every program is to run as fast as possible.
    This means that even the waste collection process causes pauses, so it must be
    as fast as possible. Hence, internal platform processes must also be as fast as
    possible. So, regardless of the GC algorithm used, when the dataset is small,
    the process will be much faster. There’s also a place for reference types to help
    keep the allocated memory fresh and clean. The platform offers the following types,
    sorted by their resilience to GC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strong references**: The most common type of reference – not required to
    be specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var obj = new WeakReference<Object>();` – and it’s a signal to the GC algorithm
    to reclaim memory during the next GC cycle. This is mostly used during a program
    initiation phase or caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OutOfMemoryError` error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phantom reference**: This represents the weakest type of reference. This
    team is collected as soon as possible, which means there is no further analysis
    or promotion to another level. A variable of this type is reclaimed immediately
    when the GC cycle runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before embarking on the Java API journey, let’s quickly summarize our newly
    acquired knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: References play an important role in the GC process. They tell garbage collectors
    how to handle a particular variable. The Java memory model provides the required
    guarantees as to how the value of a variable is read, updated, or deleted. We
    examined how values are stored in allocated memory, memory segmentation, and their
    relationship to the underlying system. All this new information helps us with
    better software design and API usage.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the core Java APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JDK provides a set of tools for creating, compiling, and running the required
    Java program. We learned how this program uses basic resources to provide the
    desired result. We have also examined a number of limitations that we must take
    into account when designing this kind of program. The JDK provides tools for software
    designers by making an internal collection of classes grouped into APIs available.
    The previous section explored how the JDK can be extended with external APIs that
    can be added on demand (discussed earlier in *The* *JRE* section).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the most important basic APIs we use for design
    patterns in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Java is an object-oriented language with many other features and extensions.
    The official basic Java API can be found in the `java. *` package (as listed in
    *Table 2.1*).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sub-package** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `java.io.*` | Related to system I/O through data streams, serialization,
    and filesystems |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.*` | Automatically imported fundamental classes for the Java language
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.math.*` | Classes related to the arbitrary precision arithmetic for
    integers (`BigInteger`) and decimals (`BigDecimal`) |'
  prefs: []
  type: TYPE_TB
- en: '| `java.net.*` | APIs related to network protocols and communication |'
  prefs: []
  type: TYPE_TB
- en: '| `java.nio.*` | An overview of buffer definitions as data containers and other
    non-blocking packages |'
  prefs: []
  type: TYPE_TB
- en: '| `java.security.*` | Classes and interfaces for the Java security framework
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.text.*` | Provides classes for handling formatted messages with texts,
    numbers, and dates |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.*` | APIs for calendars, dates, times, instants, and durations
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.*` | Serves as a collection framework, string parsing, scanning
    classes, random number generator, Base64 encoders and decoders, and some miscellaneous
    utilities, among other things |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – java.* packages available in Java 17 SE
  prefs: []
  type: TYPE_NORMAL
- en: Every newly created class can automatically access public classes and interfaces
    that reside in the `java.lang.*` package from the `java.base` module. As everything
    is an object, it implies that each class has an `Object` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types and wrappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java also provides a set of primitive types (*Reference 4*) called literals
    (*Table 2.2*). One difference between a literal and an `Object` instance is that
    each literal has a well-defined size in memory. In contrast, the size of the `Object`
    instance may vary depending on demand. The literal type of Java is signed, which
    is quite useful to remember if you are dealing with data buffering operations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Size** | **Literal name** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 bit (*) | `boolean` | `true` or `false` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 byte | `byte` | -128 to 127 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 bytes | `short` | -32,768 to 32,767 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 bytes | `char` | \u0000 to \uffff |'
  prefs: []
  type: TYPE_TB
- en: '| 4 bytes | `int` | -2^31 to 2^31-1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 bytes | `float` | -3.4e38 to 3.4e38 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 bytes | `long` | -2^63 to 2^63-1 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 bytes | `double` | -1.7e308 to 1.7e308 |'
  prefs: []
  type: TYPE_TB
- en: Table 2.2 – Primitive types with their sizes; (*) boolean size is not precisely
    defined
  prefs: []
  type: TYPE_NORMAL
- en: The primitive types reside in the stack area (refer to *Figure 2**.2*) and each
    literal contains a wrapper object (*Figure 2**.10*).
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.10 – Data type wrapper inheritance\uFEFF with the literals with\
    \ String type associations](img/B18884_02_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Data type wrapper inheritance with the literals with String type
    associations
  prefs: []
  type: TYPE_NORMAL
- en: 'The envelope is initiated around literal values. This means that the literal
    is stored in the stack area and the wrapper object is located inside the heap.
    The cover provides additional features. Take the `Integer` class as an example,
    which provides the following methods: `byteValue`, `doubleValue`, and `toString`.
    These methods can be called within a specific design pattern to achieve the desired
    goal and avoid unnecessary memory contamination. This is in comparison to literals
    that only provide a native implementation of a value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java platform automatically addresses the literal to the appropriate wrapper
    class and the like. This fact not only has a bright side but also has a dark side,
    known as an autoboxing issue (*Example 2.3*). This happens exactly when the primitive
    type is cast to a wrapper type. This can lead to very frequent waste collection,
    which can mean an enormous number of stop-the-world events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.3 – Auto-casting example where a new Integer wrapper is created under
    the hood
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with literal numbers, it is useful to keep in mind that a literal
    with a smaller byte size (*Table 2.2*) can be automatically assigned to a literal
    with a larger size (*Example 2.4*). The other way around, it causes a compilation
    error due to the precisely allocated byte size in the memory stack area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.4 – Literal automatic casting
  prefs: []
  type: TYPE_NORMAL
- en: We have checked the numbering and how automatic submission works on the Java
    platform. A Boolean literal is `true` or `false` and is represented in memory
    as 1 bit.
  prefs: []
  type: TYPE_NORMAL
- en: The last of the specific literals not yet mentioned is `char` and its cover
    character. Let’s take a closer look because it’s also related to the essential
    `String` object.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the String API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` instance is not literal. A string is represented as an object in
    Java. It is defined by a sequence of characters. It is almost impossible to avoid
    using a string to write any program. In addition to the fact that a Java executable
    requires a `String` field as input to the `main` method, variable names are also
    represented as a string. The string is immutable in Java. This means that any
    operation, such as concatenation, on its value will create a new string. More
    precisely, it is not possible to change its current value. A string is the base
    class of the Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: A common way to store a string value is to use a String Pool. The String Pool
    only stores intrinsic values (*Figure 2**.11*). This means that it is only possible
    to have one different constant value present. This approach makes the pool more
    efficient in terms of memory, including time-consuming string operations.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.11 – The String Pool is a part of the heap memory and a String object\
    \ resides in the heap \uFEFFlike other objects](img/B18884_02_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The String Pool is a part of the heap memory and a String object
    resides in the heap like other objects
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also store strings directly in the heap using the `String` constructor
    – for example, `new String`. In this case, the link is not to an equivalent value
    that is already present in the String Pool (represented by `t3` in *Example 2.5*)
    because it is located in a different heap memory space. If you force a search
    in pool strings, you can use the `intern` method (`t4` in *Example 2.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.5 – Comparing different ways of assigning String values
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `+` operator on String classes can turn into a very inefficient use
    of concatenation or program maintainability. To prevent String contamination,
    the Java platform provides the `StringBuilder` class as part of its APIs. `StringBuilder`
    prevents temporary values from being stored and only stores the result created
    by executing its internal `toString` method, which creates a new `String` object
    in the heap space (*Example 2.6*). `StringBuilder` also introduces the implementation
    and use of the creational design pattern within the Java SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.6 – StringBuilder creates a new String object by default in the heap
    space
  prefs: []
  type: TYPE_NORMAL
- en: We found out how String objects are created and in which heap memory they are
    stored. This newly acquired information can strengthen us in making decisions
    by choosing a suitable design pattern or a combination of them to avoid misuse
    of memory. Because the string is under the hood of an array of characters, primitive
    type `char[]`, the array is not primitive – in fact, it is an object. Let’s examine
    this concept a little more closely because it is also essential for the Java language
    and platform.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the Java collections framework better, first, we will look at
    an important concept, arrays. In Java, an array is represented by a sequence of
    the same type of positional index elements. Fields are index-based. Any attempt
    at runtime to get an element from a non-existent position results in `ArrayIndexOutOfBoundsException`.
    The array field is allocated as an object and stored in heap space. This means
    that in the case of insufficient space, an `OutOfMemoryError` exception is thrown.
    Each array requires a defined size due to memory allocation. Simple field allocation
    with literals is relatively memory-efficient (*Example 2.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.8 – Multiple array allocation approaches
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays allow us to store elements that implement interface classes or a range
    of abstract classes. The field variable declaration does not create or assign
    a new field; the variable contains a field reference (*Example 2.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.9 – Array initiation, assignment, and verification
  prefs: []
  type: TYPE_NORMAL
- en: The use of the field is often neglected due to its potentially precise requirements
    and limited auxiliary methods. However, it can help enforce the open-closed principle,
    which assumes code maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: The field is more often replaced by collection or map structures, which provide
    additional helper methods. Let us explore the topic more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering a collection framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike fields, advanced collections provide an automatic resizing feature. This
    means that the required base representation will be copied and the previous version
    will become eligible for GC. The Java collections framework includes `List` (*Table
    2.3*), `Set` (*Table 2.4*), `Queue` (*Table 2.5*), and `Map` interfaces with several
    implementations (*Figure 2**.12*). Implementations may vary by vendor, but all
    must conform to basic specifications.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.12 – Dependencies between Java collection\uFEFFs framework interfaces](img/B18884_02_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Dependencies between Java collections framework interfaces
  prefs: []
  type: TYPE_NORMAL
- en: The implications of the collection are located in the `java.base` module and
    its `java.util` package. The package contains the most common implementation,
    with the known behavior of time complexity. Space complexity is not very relevant,
    as the framework comes with automatic resizing features. Time complexity can play
    a more important role in selection when it comes to design patterns, as this can
    significantly penalize the response of the proposed program. To assess the time
    complexity of O-notation, O-notation is used to highlight the upper limit and
    the worst-case program must be used to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: To evaluate the impact of time complexity, we can go through some nice examples,
    such as the importance of choosing the right data structure. Let us start with
    the list structures (*Table 2.3*), which allow access to each element using an
    index.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Contains** | **Add** | **Get** | **Remove** | **Data structure**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList` | O(n) | O(1) | O(1) | O(n) | Array |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkedList` | O(n) | O(1) | O(n) | O(1) | Linked List |'
  prefs: []
  type: TYPE_TB
- en: Table 2.3 – Selected List interface implementations with their time complexities
    sorted by the actions offered
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm sometimes requires you to verify the presence of an element in
    the data structure and add or remove a new one. For these cases, let us look at
    the implementation of the `Set` interface (*Table 2.4*).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Contains** | **Add** | **Remove** | **Data structure** |'
  prefs: []
  type: TYPE_TB
- en: '| `HashSet` | O(1) | O(1) | O(1) | Hash Table |'
  prefs: []
  type: TYPE_TB
- en: '| `TreeSet` | O(log n) | O(log n) | O(log n) | Red-Black tree |'
  prefs: []
  type: TYPE_TB
- en: Table 2.4 – Selected Set interface implementation sorted by their offered actions
    and time complexity
  prefs: []
  type: TYPE_NORMAL
- en: The last interface provided by the collection group is `Queue` (*Figure 2**.12*).
    This data structure is very useful when you only need to work with the first or
    last element (*Table 2.5*).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Peak** | **Offer** | **Poll** | **Size** | **Data structure**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PriorityQueue` | O(1) | O(log n) | O(log n) | O(1) | Priority Heap |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayDequeue` | O(1) | O(1) | O(1) | O(1) | Array |'
  prefs: []
  type: TYPE_TB
- en: Table 2.5 – Selected Queue interface implementations with the actions offered
    and their time complexities
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to implementing a `Map` interface, it is important to remember
    what kind of map implementation type is considered. A map represents the structure
    of a key-value pair. Both the key and the values are descendants of the `Object`
    class. Apart from the fact that no literals can be used in the definition or initiation
    of the map, the correct implementation of the `hashCode` and `equals` object methods
    is required. This requirement is based on the need to identify the correct bucket
    to resolve potential map collisions. This kind of collision can lead to unexpected
    time complexity that deviates from our expectations (*Table 2.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Contains Key** | **Get** **by Key** | **Remove** **by Key**
    | **Data structure** |'
  prefs: []
  type: TYPE_TB
- en: '| `HashMap` | O(1) | O(1) | O(1) | Hash table |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkedHashMap` | O(1) | O(1) | O(1) | Hash table, linked list |'
  prefs: []
  type: TYPE_TB
- en: Table 2.6 – Selected Map interface implementations with time complexities by
    the actions provided
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework uses a heavily behavioral iterator design pattern
    to traverse through the considered elements. Those who have a keen eye must have
    already noticed that none of these functions of a collection framework would be
    possible without a proper mathematical basis. One of the main reasons for using
    design patterns is to map or create the right structures used by business logic.
    Let us take a brief look at some basic math features.
  prefs: []
  type: TYPE_NORMAL
- en: Math APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java reveals basic mathematical functions by providing a static implementation
    of the final `Math` class. Final means that this class cannot be extended, which
    includes reluctant changes or replacements of basic functions. The `Math` class
    (*Example 2.10*) is located in the `java.lang` package, which means that it is
    directly available without the need to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.10 – Using common math functions provided by the Math class
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `Math` class uses the `random` method, it only gets a `double`
    result. The `Random` class is in the `java.util` package and provides more customizable
    capabilities not only for types but also for the required ranges (*Example 2.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.11 – Generating a random number in a range (0 – upper bound)
  prefs: []
  type: TYPE_NORMAL
- en: The Java `Math` class is also used here, similar to virtually any required calculation
    that is beyond the capabilities of standard mathematical operators. Using the
    `Math` class methods can be helpful when functional programming approaches are
    being followed.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about and demonstrated the key principles
    (APIE) of **Object-Oriented Programming** (**OOP**). In recent decades, the Java
    platform has evolved with the demands of the business and development community.
    The platform has responded to this challenge by implementing an API that uses
    the composition of tree functions to provide the desired result. This is in contrast
    to the traditional loop approach with a collection of imperative commands. This
    approach caused the larger code base to meet the desired goal.
  prefs: []
  type: TYPE_NORMAL
- en: From Java SE 8 onward, the platform provides an API for streaming (*Reference
    15*). It is in the `java.util.stream` package and has nothing to do with Java
    data streams represented by input and errors (`System.out`, `System.in`, and `System.err`).
    The Stream API introduces the ability to apply operations to a sequence of elements.
    There are two types of intermediate operations that can edit or check data, as
    well as terminal operations. The terminal operation may provide a single result
    or void. Intermediate operations can be concatenated, but terminal operations
    terminate the stream. The sequence of elements is lazily evaluated and can also
    be performed in parallel. By default, performing a parallel stream uses the common
    **Fork/Join Framework** executor service. The fork-join model can be considered
    a parallel design pattern that was formulated in the early 1960s (*Reference 17*).
  prefs: []
  type: TYPE_NORMAL
- en: Although the platform allows you to program functional types, OOP concepts remain,
    followed by strong type requirements. This provides the Stream API with the security
    that the original element type remains or must be enforced correctly by an intermediate
    or terminal operation – otherwise, the platform will cause a compilation error.
    As a reminder, none of these functions would be possible without the introduction
    of generic types in Java SE 5\. Generics (*Reference 4*) allow us to parameterize
    a class or interface by a type flag to keep compilation safe (*Reference 2*).
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate or terminal operations are implementations of anonymous functions
    or functional interfaces. They represent a small block of code, formally called
    a lambda. Let’s explain the concept of lambda a little more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lambdas and functional interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lambda concept was introduced to enable element operations. Lambdas basically
    treat data as a code or function as a method. Lambdas rely on the concept of anonymous
    classes – that is, a class with only one method that performs an action. Java
    contains a collection of already implemented functional interfaces or ready-to-use
    functions. Classes are annotated with the `@FunctionalInterface` annotation, which
    is a tag available from Java SE 8\. It tells the platform that a particular interface
    contains only one abstract method that can be used to instantiate anonymous classes,
    as shown in *Table 2.7*. This also means that the interface may contain some default
    or static functions that belong to the class.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Input** **argument** | **Return** **type** | **Abstract** **method**
    | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Supplier<T>` | - | T | `get` | Returns a value of type <T> |'
  prefs: []
  type: TYPE_TB
- en: '| `Consumer<T>` | T | - | `accept` | Consumes a value of type <T> |'
  prefs: []
  type: TYPE_TB
- en: '| `Function<T, R>` | T | R | `apply` | Consumes a value of type <T> and applies
    a transformation with return type <R> |'
  prefs: []
  type: TYPE_TB
- en: '| `Predicate<T>` | T | Boolean | `test` | Consumes an input of type <T> and
    returns a Boolean result |'
  prefs: []
  type: TYPE_TB
- en: Table 2.7 – Basic functional interfaces available in the JDK since Java SE 8
  prefs: []
  type: TYPE_NORMAL
- en: Using functional interfaces in lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have discovered that each lambda expression is lazily loaded, which means
    the code is evaluated on demand, not at compile time, and may be closed by the
    terminal operation (*Example 2.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.12 – Converting elements of the List interface to the stream and applying
    a terminal operation for each Consumer type instance
  prefs: []
  type: TYPE_NORMAL
- en: 'We can chain the different intermediate functions together (*Example 2.13*)
    and close the stream with a terminal operation or pass the stream to another method
    or object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.13 – Advanced composition of named and anonymous functional interfaces
  prefs: []
  type: TYPE_NORMAL
- en: The lambda expression stream API plays an important role in the composition
    of the code. It can be imagined as a process line into which the input object
    enters and, thanks to a collection of adjustments, the expected result is returned
    or the action ends. Since the lambdas are evaluated lazily, this means that the
    process line has a switch. In other words, the Stream API can be considered one
    of the most important breakthroughs in syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips with the Java Module System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the main purposes of using a higher-order programming language such
    as Java is code reusability. A basic building block of the language is the concept
    of classes according to the principles of APIE. Java can localize these classes
    into groups defined by specific package names. The package concept encapsulates
    a group of classes. Classes can provide different levels of visibility to their
    internal fields and methods. Java specifies the following levels of visibility:
    `public`, default, `private`, and `protected`. Keywords are used to reduce visibility
    across different packages to manage their interactions. The way to share a package
    across an application domain is to keep it public – that is, visible to everyone.'
  prefs: []
  type: TYPE_NORMAL
- en: Java has been using the concept of class paths for many years. The class path
    is a special place where the Class Loader loads its classes. The loaded classes
    are then used at runtime (denoted as the **Class Loaders Subsystem** in *Figure
    2**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: However, this concept does not provide any guarantee for the stored package
    or class. This concept has been considered bad, fragile, and error-prone for many
    years. A good example is trying to package a JAR executable that contains different
    versions of libraries with similar package structures and class names. The class
    path does not differ and the class can be overwritten by different versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The breakthrough came with the release of Java SE 9\. JSR-376, formerly the
    core of the Jigsaw project (*Reference 3*), became a common part of the platform.
    JSR-376 implements the **Java Platform Module System** (**JPMS**) (*Example 2.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.14 – Listing the available JDK modules for a specific version
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the platform has been migrated in accordance with the modules
    (*Example 2.15*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.15 – Describing a java.logging module. The java.base module is automatically
    present, as it contains the core platform and language functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JMPS provides a strong package encapsulation concept that defines application
    interactions at the package level (*Example 2.16*). The application can be divided
    into modules that can only detect APIs or services. The JMPS supports package-level
    dependency building and increases the maintainability, reliability, and security
    of the application being developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.16 – Example of the module-info.class descriptor exposing a package
    for external usage
  prefs: []
  type: TYPE_NORMAL
- en: The use of the JPMS is not mandatory. The Java platform uses the JMPS, but if
    the application is not ready, unnamed modules can be used. In this case, all packages
    or classes will belong to this kind of unnamed module. In principle, an unnamed
    module reads each readable module or class from the class path without reflecting
    any package-level restrictions required by the JPMS. In this way, compatibility
    with previously developed applications is achieved and the software designer has
    no doubts about the malfunction of the code base – that is, the JPMS is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Although the JPMS has incredible potential for application sustainability, security,
    and reusability, it is often not used because it creates indirect pressure to
    properly configure the underlying JPMS and use a design pattern that enforces
    SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: When using the JMPS, the platform ensures that the developed application does
    not contain any cyclic dependencies. Behind the scenes, the JPMS creates an acyclic
    module graph (not a class path case).
  prefs: []
  type: TYPE_NORMAL
- en: By creating a module descriptor file, the platform provides a set of directives
    that can be used to expose certain parts of the module to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple example of a module to remove any doubt about the use
    of the JPMS (*Example 2.17*). Our discussion so far can overcome the initial difficulties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.17 – Folder structure of module example developed with OpenJDK 17
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an appropriate executable class, `ExampleMain.java`, and a module
    descriptor, `module-info.java` (*Example 2.18*). In this way, we tell the platform
    to use the JPMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.18 – Simple module example introduced by the file structure in Example
    2.17
  prefs: []
  type: TYPE_NORMAL
- en: 'The example shows how the project could be separated into modules that contain
    their own descriptors, `module-info.java` files (*Example 2.17*). This descriptor
    defines an interaction with other modules through dependencies or exposures of
    module internals. The JPMS ensures that the restrictions, including visibility,
    are maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.19 – Steps to compile Example 2.17 with outputs, together with the
    module descriptor check (Example 2.18) after the compiled result
  prefs: []
  type: TYPE_NORMAL
- en: The JPMS is a big change to the platform and although it opens a new horizon
    for software designers by providing the ability to define clarity in the package
    structure, it is not always well received or understood. This may be due to additional
    requirements that need to be taken into account when designing the system, which
    essentially relate to the knowledge of APIE or SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: The JPMS together with the Stream API, as well as lambdas, may be considered
    significant changes addressed by the Java SE 11 release – Java SE 11 being the
    next **Long-Time Support** (**LST**) release after version 8\. Let us dive a bit
    further into some of the changes from Java SE 11 to the next LST version presented
    by release 17.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of Java features from 11 to 17+
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This version update presents performance and optimization improvements. In this
    section, we will examine those that are very useful for the specific use of a
    design pattern and its structure. This equates to platform enhancements that improve
    code readability, platform usage, or syntax enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: The local variable syntax for lambda parameters (Java SE 11, JEP-323)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java has often been criticized for the amount of standard code in the use of
    a variable; Java SE 10 introduced a new keyword, `var`. The derivation of a local
    type variable lies behind this keyword. It essentially requires that the value
    type is taken from the newly created reference instance (*Example 2.20*). Using
    the stream `boxed` function shows a decorator pattern that wraps the stream value
    with the desired type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.20 – Use of local type inference in a lambda expression and stream
    shows the reduction of boilerplate code
  prefs: []
  type: TYPE_NORMAL
- en: Although a lambda already allowed an implicit type definition, for example,
    the use of annotation was not possible.
  prefs: []
  type: TYPE_NORMAL
- en: Switch expressions (Java SE 14, JEP-361)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software designers have long complained about several inconsistencies in the
    use of switch commands, such as a control flow problem. Although this enhancement
    is fully compatible with all controls, it introduces a new form of switch label,
    `case CONSTANT->`. The extension also allows more constants to be used, making
    the entire switch expression more compact. The last improvement is the ability
    of the switch expression to return its computed value (*Example 2.21*). This has
    a very positive impact on the implementation of the design pattern, because, for
    example, behavior types require a precise control flow (*Reference 8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.21 – Compact switch expression usage with a return control flow with
    a simple text block
  prefs: []
  type: TYPE_NORMAL
- en: Text blocks (Java SE 15, JEP-378)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many times, you need to create multiple lines with a specific format. Previous
    use of multiple escape sequences and characters was not as practical, as it could
    be unpredictable. Text block extension introduces a literal that allows you to
    represent a string in a predictable way (see the `System.out.printf` method in
    *Example 2.21*, as well as *Reference 9*).
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for instanceof (Java SE 16, JEP-394)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, it was necessary to retype a value type that had already been verified
    as positive for its type. This increased the code base and sometimes had a negative
    effect on the stability of the code, even when designing a pattern. This platform
    extension eliminates the need for a rear cast and the variable can be used directly
    with the correct type (*Example 2.22*, *Reference 10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.22 – Using instanceof with direct type methods
  prefs: []
  type: TYPE_NORMAL
- en: Records (Java SE 16, JEP-395)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `record` class type is very useful because its declaration is very simple
    and can carry all the data needed for the program’s business logic. Records carry
    immutable data. They provide an already implemented `hashCode` and `equals`. This
    means that the designed software does not have to provide additional code (*Example
    2.23*, *Reference 11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.23 – New record class type may have a very positive impact on code
    reduction, as it provides generated methods
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes (Java SE 17, JEP-409)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are very elegant enhancements to gain control over classes and interfaces,
    or class extensions and interface implementations (*Reference 12*). Closed classes
    give software designers wide access to the superclass without the need to extend
    it. They overcome the limitations of the widely used package access modifier,
    which previously required the full implementation of abstract methods. The example
    shows how to define an open class for an extension, the `non-sealed` keyword (*Example
    2.24*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.24 – The implementation of the interface methods is provided by the
    abstract class, NormalEngine
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed classes force control over possible extensions (*Example 2.25*) because
    they provide software with potential security against unwanted software design
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the compilation output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.25 – Sealed classes enforce control over the enhancements
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed classes also present some potential problems because the software designer
    must decide how the newly created classes will be used, indicating whether class
    extension is allowed, the keyword is unsealed (*Example 2.25*), or the final keyword
    (*Example 2.26*) is locked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.26 – It’s required to decide the class behavior and the Bus class
    example is locked for any extension
  prefs: []
  type: TYPE_NORMAL
- en: Although this may seem like a possible disadvantage, it provides greater clarity
    in software development in terms of maintainability and design patterns. This
    reduces potential unwanted interface or class errors.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 by default (Java SE 18, JEP-400)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, unclear encoding has caused issues. Encoding problems were not
    easy to detect and appeared unpredictably on different system platforms. This
    enhancement has unified everything and forced UTF-8 as the default encoding (*Reference
    13*).
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for switch (Java SE 18, Second Preview, JEP-420)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Improvements to `instanceof` fields (JEP-394) and switch case expressions (JEP-361)
    have made it even better to compress the code base and remove previously unnecessary
    if-else constructs by using `instanceof` on a very compact, command-oriented controlled
    command statement: type-served (E*xample 2.27*, *Reference 14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.27 – Compact switch statement with an implicit type match
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing the most important syntactic improvements, we can safely start
    to delve deeper into one of the main advantages of the platform. Yes, it is the
    concurrency framework.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Java concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, it was shown that even running a simple program
    (*Example 2.2* and *Figure 2**.3*) will cause multiple concretizations of threads
    (*Figure 2**.4*). This means that a program thread created by executing the `main`
    method did not create any other thread that belonged to that program. The Java
    platform is well-known and valuable for its ability to perform concurrent or parallel
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: We found out how and where initiated threads store their variables and why synchronizing
    objects located in the heap can lead to unwanted or unexpected program behavior.
    In this section, we will look at the possibilities of the main threads using the
    available CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation for software designers to consider using any concurrent design
    patterns may be the growing need for better application responsiveness or throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Although the platform already includes the `Thread` class and the `java.lang`
    package, Java concurrency features such as `java.util.concurrent` package, which
    is part of the `java.base` module.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look a bit closer.
  prefs: []
  type: TYPE_NORMAL
- en: From a basic thread to executors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic build element of the platform is the thread. A thread is represented
    by an instance of the `Thread` class. The object initiated by the `new` keyword
    still does not create a platform thread. The object provides a method named `start`
    that requires explicit use (*Example 2.28*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.28 – A simple program with a daemon thread that ends immediately after
    the JVM stops
  prefs: []
  type: TYPE_NORMAL
- en: Although it may appear that the platform can create an unrestricted `Thread`
    instance, this kind of statement is not valid. Each newly created thread instance
    not only takes up heap space or allocates a stack but is also connected to basic
    system threads (processing cycles) through Java runtime partitions (*Figure 2**.2*).
    This means that uncontrolled thread startup can cause a system error exception
    due to unavailable resources, insufficient memory, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of system threads created by the Java platform may vary,
    as it depends on the hardware as well as the JVM configuration. The Java `Thread`
    class might consider a wrapper for the `Runnable` interface, and the thread accepts
    its implementation. The `Runnable` interface is another functional interface and
    requires the implementation of a run method. Starting with the Java SE 8 `Runnable`
    interface, the instance can be passed to the executor service as an anonymous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform allows you to run a thread that can even survive the termination
    of the main program, which in many cases, is a reluctant condition and should
    be considered wisely, as it may block other core resources or stay running.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the JVM only terminates when all running threads
    are daemon ones (*Example 2.28*).
  prefs: []
  type: TYPE_NORMAL
- en: Because each thread newly created by the main program is non-daemon, by default,
    when the sample program is run without an explicit daemon flag, the JVM remains
    an active process until the base system destroys it.
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to manage uncontrolled thread creation and gives the software
    designer control over the program’s resources and behavior. Java SE 5 introduced
    the `ExecutorService` and `ThreadFactory` interfaces, where multiple implementations
    show using a similarly named creational design pattern factory. The `ThreadFactory`
    interface contains only one `newThread` method, which returns a `Thread` instance.
    This method logic can accommodate the creation of a new thread and set the group,
    thread priority, and daemon flag. It also eliminates the number of new thread
    calls. `ThreadFactory` can be serviced by `ExecutorService` (*Example 2.30*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most used executor static method names are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`newSingleThreadExecutor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newSingleThreadExecutor(ThreadFactory threadFactory)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newCachedThreadPool()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newCachedThreadPool(ThreadFactory threadFactory)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE 5 came up with a concept for the future, a `Future` interface with a
    generic type of `<T>`. The `Future` interface can be considered an asynchronous
    calculation that provides a result.
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform provides two different interfaces that can carry thread logic.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java platform provides a thread concept from the beginning represented
    by the `Runnable` interface and the `Thread` class (*Example 2.29*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.29 – Different approaches to providing the Runnable interface implementation
    to the executor service, implementation, and anonymous class
  prefs: []
  type: TYPE_NORMAL
- en: Business requirements, along with community expectations, have created a platform
    for reactive programming or the ability to perform multiple asynchronous payback
    tasks. As of Java SE 5, the platform provides a `Callable` interface. The `Callable`
    interface is considered a functional interface. It contains only one abstract
    method call with a required return type of `<T>`. Because the computation is uncertain,
    it can cause an exception that must be handled correctly. The `Callable` implementation
    can be sent to the executor and the started calculation is packed into a future
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Future` instance is the computational work that the base system performs
    in the background. The interface provides a `get` method (*Example 2.30*) that
    can be used to retrieve the result. Using this method pauses the current thread
    and waits until a result is available. Due to the current thread suspension, this
    method should be used wisely, as it can cause performance penalties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Example 2.30 – Different approaches to provide a Callable instance to the executor
    service as a realization or an anonymous class
  prefs: []
  type: TYPE_NORMAL
- en: This contrasts with the `Runnable` interface because the `Callable` interface
    provides a `Future` instance as a temporary result. The `Callable` exception handling
    request is also relevant because it can cause logic to be executed or the worker
    thread can be interrupted. In this case, it is necessary to transfer this to the
    interim result represented by the `Future` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have built a good knowledge base for understanding the
    internal Java platform. We learned about the differences between statically allocated
    arrays or methods compared to object instances. We examined the need for proper
    data synchronization and how Java memory management works and what guarantees
    the platform provides. We now understand the importance of heap memory, segmentation,
    and maintenance. We have also already discovered a few frequently used design
    patterns, which means that when we start implementing any design pattern or collection,
    we will be aware of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How fields or variables are handled by the platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific program error exit states and the reasons for them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core APIs provided by the Java platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize functional programming features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What new enhancements the Java platform provides to make employing design patterns
    easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to approach Java concurrency challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have built a solid knowledge base over the first two chapters. We will now
    begin to present pattern by pattern. The next chapter will take us on a journey
    through creational design patterns. Creational design patterns intensify our awareness
    of the code structure and how to create sustainable solutions. Let us roll.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which elements make up the Java platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does statically typed language mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the Java language literals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is responsible for memory reclamation in the Java memory management concept?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the collections in the Java collections framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of elements store `Map`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the time complexity of retrieving an element from `Set`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the time complexity of verifying an element’s existence in `ArrayList`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functional interface is used in the `filter` method of the Stream API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are elements evaluated in the Stream API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Garbage Collection Handbook: The Art of Automatic Memory Management*,
    Anthony Hosking, Eliot B. Moss, and Richard Jones, CRC Press, ISBN-13: 978-1420082791,
    ISBN-10: 9781420082791, 1996'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Generics: [https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JPMS (JSR 376): [https://openjdk.java.net/projects/jigsaw/spec/](https://openjdk.java.net/projects/jigsaw/spec/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Java tutorials: [https://docs.oracle.com/javase/tutorial/java](https://docs.oracle.com/javase/tutorial/java)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java GC basics: [https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JVM specification, Java SE 17 Edition: [https://docs.oracle.com/javase/specs/jvms/se17/html/index.html](https://docs.oracle.com/javase/specs/jvms/se17/html/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenJDK, HotSpot runtime overview: [https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html](https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JEP 361: Switch Expression: [https://openjdk.java.net/jeps/361](https://openjdk.java.net/jeps/361)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JEP 378: Text Blocks: [https://openjdk.java.net/jeps/378](https://openjdk.java.net/jeps/378)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JEP 394: Pattern matching for `instanceof`: [https://openjdk.java.net/jeps/394](https://openjdk.java.net/jeps/394)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 395:* *Records*: [https://openjdk.java.net/jeps/395](https://openjdk.java.net/jeps/395)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 409: Sealed* *Classes*: [https://openjdk.java.net/jeps/409](https://openjdk.java.net/jeps/409)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 400: UTF-8 by* *Default*: [https://openjdk.java.net/jeps/400](https://openjdk.java.net/jeps/400)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 420: Pattern Matching for switch (Second* *Preview)*: [https://openjdk.java.net/jeps/420](https://openjdk.java.net/jeps/420)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `java.util.stream` package: [https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 300: Launch Single-File Source-Code* *Programs*: [https://openjdk.java.net/jeps/330](https://openjdk.java.net/jeps/330)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A multiprocessor system design*. Fall Join Computer Conference, Melvin E.
    Conway (1963). pp. 139 -146.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Implementing Standard Design Patterns Using Java Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Design patterns are often classified into three well-known categories: creational,
    behavioral, and structural. This part will explore and demonstrate design patterns
    from each of these categories. It will show the types of challenges addressed
    by each design pattern with practical real-world examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18884_03.xhtml#_idTextAnchor093), *Working with Creational Design
    Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18884_04.xhtml#_idTextAnchor172), *Applying Structural Design
    Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18884_05.xhtml#_idTextAnchor255), *Behavioral Design Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
