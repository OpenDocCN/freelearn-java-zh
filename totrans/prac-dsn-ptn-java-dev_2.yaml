- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Discovering the Java Platform for Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Java平台的设计模式
- en: Many years ago, motivated by the lack of a suitable **Application Programming
    Interface** (**API**) design, something extraordinary began to happen. In the
    early days of using the **World Wide Web** (**WWW**), the direction of application
    development was a bit shrouded in fog. In one direction, there was a strong need
    in the industry to process a large number of database transactions or develop
    specific proprietary hardware and software. On the other hand, it was not clear
    what kind of applications might be needed to move the demand forward and how such
    an application should be maintained.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，由于缺乏合适的**应用程序编程接口**（**API**）设计，一些非凡的事情开始发生。在早期使用**万维网**（**WWW**）的时候，应用开发的走向有些模糊不清。一方面，行业对处理大量数据库事务或开发特定专有硬件和软件有强烈的需求。另一方面，不清楚需要什么样的应用程序来推动需求的发展，以及这样的应用程序应该如何维护。
- en: 'In this chapter, we will prepare the ground for understanding the value of
    design patterns from a memory utilization perspective. We will do so by covering
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从内存利用的角度为理解设计模式的价值做好准备。我们将通过以下主题来实现这一点：
- en: The rise of Java and brief historical facts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的兴起和简要历史事实
- en: How the Java platform works under the hood
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台内部的工作原理
- en: Exploring Java memory area allocation and management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Java内存区域分配和管理
- en: How allocated heap is maintained with garbage collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过垃圾收集维护分配的堆内存
- en: Running the first program on the platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在平台上运行第一个程序
- en: The threading nature of the Java platform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台的线程特性
- en: Examining the core Java APIs and their values for software design
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查核心Java API及其在软件设计中的价值
- en: Exploring the importance of the Java Platform Module System
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Java平台模块系统的重要性
- en: Discovering new helpful platform enhancements
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索新的有用平台增强功能
- en: Introducing Java concurrency
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Java并发
- en: By the end of the chapter, you will have a good understanding of memory allocation
    on the Java platform, platform guarantees, core APIs, and more. Together with
    the content of the previous chapter, these topics will form a well-prepared foundation
    so that you can start with design patterns with full awareness of their benefits.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对Java平台上的内存分配、平台保证、核心API等有良好的理解。结合上一章的内容，这些主题将形成一个良好的基础，以便你可以带着对设计模式益处的充分认识开始学习。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter are available on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在GitHub上找到，链接为[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02)。
- en: Knocking on Java’s door
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敲响Java的大门
- en: In the early 1990s, a small team at Sun Microsystems was formed in order to
    discover new horizons. The team started with the consideration of extending the
    C++ features available in those days. One of the goals was to introduce a new
    generation of software for a small smart device. The introduction of software
    reusability was a part of this. Small smart devices such as set-top boxes did
    not have much memory and had to use their resources wisely. The memory, among
    other things, such as its complexity, error-prone programs, and probably James
    Gosling’s language extension attempt, later led to the rejection of the C++ idea.
    Instead of struggling with C++, a new language called **Oak** was created in lieu.
    Due to the trademark issue, the newly created language Oak was renamed Java.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代初，Sun Microsystems的一个小团队成立，目的是探索新的领域。团队从考虑扩展当时可用的C++特性开始。其中一个目标是为小型智能设备引入新一代软件。软件的可重用性是这一目标的一部分。小型智能设备，如机顶盒，内存有限，必须明智地使用其资源。内存，以及其他因素，如复杂性、易出错的程序，以及可能詹姆斯·高斯林的语言扩展尝试，最终导致了C++想法的放弃。为了避免与C++的斗争，创造了一种新的语言，称为**Oak**。由于商标问题，新创建的语言Oak被更名为Java。
- en: The first public Java version 1.0a.2, together with HotJava Browser, was announced
    at the SunWorld conference in 1995 by John Gage, the director of science at Sun
    Microsystems. He was involved in re-directing the Java language from being a language
    for small hardware devices to being a platform for WWW applications. In these
    early days, Java was used as part of a website using a technology known as an
    applet. Java applets were small sandboxes, defined by the frame with limited access
    and the capability to execute Java bytecode on the local **Java Virtual Machine**
    (**JVM**). Applets resided on a web browser or as a standalone application; they
    were a very powerful tool that supported one of the basic Java principles, **Write
    Once, Run Anywhere** (**WORA**). However, due to many issues (such as security
    and stability), the applet technology was marked for removal (Java SE 17).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个公开的Java版本1.0a.2，连同HotJava浏览器，于1995年在SunWorld会议上由Sun Microsystems的科学总监John
    Gage宣布。他参与了将Java语言从小型硬件设备的语言重新定位为WWW应用程序的平台。在这些早期日子里，Java被用作网站的一部分，使用一种称为applet的技术。Java
    applet是小型沙盒，由具有有限访问权限的框架定义，并能够在本地**Java虚拟机**（**JVM**）上执行Java字节码。Applet位于网络浏览器中或作为独立应用程序；它们是支持Java的一个基本原则——**一次编写，到处运行**（**WORA**）的非常强大的工具。然而，由于许多问题（如安全和稳定性），applet技术被标记为移除（Java
    SE 17）。
- en: 'The Java platform consists of three main parts (*Figure 2**.1*):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台由三个主要部分组成（*图2.1*）：
- en: "![Figure 2.1 \uFEFF– Java Development Kit architecture](img/B18884_02_01.jpg)"
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – Java开发工具包架构](img/B18884_02_01.jpg)'
- en: Figure 2.1 – Java Development Kit architecture
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Java开发工具包架构
- en: 'These parts are the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分如下：
- en: A JVM
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JVM
- en: The **Java SE (Standard Edition) Runtime** **Environment** (**JRE**)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SE（标准版）运行时环境**（**JRE**）'
- en: The **Java SE Development** **Kit** (**JDK**)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SE开发工具包**（**JDK**）'
- en: Let us start an exciting journey through the platform itself and each part.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一段激动人心的旅程，通过平台本身及其各个部分。
- en: Exploring the model and functionality of the Java platform
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Java平台模型和功能
- en: 'History has shown us that the intended direction can evolve or change: Java
    is a nice example and is no exception. From its original purpose, it has moved
    from a platform for smart devices to a platform for entire web solutions, but
    its development did not stop there. Over the years, Java has become one of the
    most widely used languages for application development. This can be taken as a
    side effect of basic hardware independence. It dramatically developed an available
    set of tools and received a very positive response from a vibrant community.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 历史已经证明，预期的方向可以演变或改变：Java是一个很好的例子，也不例外。从其原始目的来看，它已经从智能设备的平台转变为整个Web解决方案的平台，但它的开发并没有停止在这里。多年来，Java已经成为应用开发中最广泛使用的语言之一。这可以被视为基本硬件独立性的副作用。它极大地发展了一套可用的工具，并得到了一个充满活力的社区的积极响应。
- en: Let us review each part of the platform (from *Figure 2**.1*) individually as
    it will boost our understanding of writing code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个回顾平台（从*图2.1*）的各个部分，这将有助于我们更好地理解编写代码。
- en: The JDK
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK
- en: 'The JDK is a software development environment that provides the tools and libraries
    needed to develop and analyze Java applications. The JDK provides a collection
    of basic libraries, functions, and programs needed to compile written code into
    bytecode. The JDK contains the JRE required to run the application. The JDK also
    provides some very useful tools, such as the following examples:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JDK是一个提供开发和分析Java应用程序所需工具和库的软件开发环境。JDK提供了一组基本库、函数和程序，用于将编写的代码编译成字节码。JDK包含运行应用程序所需的JRE。JDK还提供了一些非常实用的工具，例如以下示例：
- en: '`jlink`: This helps generate a custom JRE'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jlink`：这有助于生成自定义JRE'
- en: '`jshell`: This is a handy **Read-Evaluate-Print-Loop** (**REPL**) tool to try
    the Java language'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jshell`：这是一个方便的**读取-评估-打印-循环**（**REPL**）工具，用于尝试Java语言'
- en: '`jcmd`: This is a utility to send a diagnostic command to the active JVM'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jcmd`：这是一个实用程序，可以向活动的JVM发送诊断命令'
- en: '`javac`: This is the Java compiler, which reads an input file with the `.java`
    suffix and produces a Java class file with the `.``class` suffix'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`：这是一个Java编译器，它读取具有`.java`后缀的输入文件，并生成具有`.class`后缀的Java类文件'
- en: '`java`: This executes a JRE'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`：这执行JRE'
- en: 'Others: Located in the JDK `bin` directory'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他：位于JDK `bin`目录中
- en: 'The code is written (*Example 2.1*) and stored in a `.java` file and compiled
    using the `javac` command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被编写（*示例2.1*）并存储在`.java`文件中，使用`javac`命令进行编译：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 2.1 – Simple Java program as an executable class that can also be run
    directly without a compilation step since Java SE 11 (*Reference 26*)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.1 – 简单的 Java 程序作为一个可执行类，也可以直接运行而不需要编译步骤，因为 Java SE 11 (*参考 26*)
- en: 'Next, it is possible to create and compile a class with bytecode inside (*Example
    2.2*). Run the file using the `java` command to run the JRE:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以创建并编译一个包含字节码的类（*示例 2.2*）。使用 `java` 命令运行文件以运行 JRE：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 2.2 – Bytecode example from a compiled program displayed by the Java
    program
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.2 – 由 Java 程序显示的编译程序的字节码示例
- en: The JRE
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JRE
- en: 'The JRE is part of the JDK, or it can be distributed as a standalone program
    for the target operating system. To run a file with a `.class` extension or a
    **Java Archive** (**JAR**) file, the target system is required to contain the
    appropriate version of the JRE. Unlike the JDK, the JRE only contains a minimal
    collection of components needed to run the program, such as the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JRE 是 JDK 的一部分，或者它可以作为针对目标操作系统的独立程序进行分发。要运行扩展名为 `.class` 的文件或 **Java 归档**（**JAR**）文件，目标系统必须包含适当的
    JRE 版本。与 JDK 不同，JRE 只包含运行程序所需的最小组件集合，例如以下内容：
- en: 'Core libraries and property files: for example, `rt.jar` and `charset.jar`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心库和属性文件：例如，`rt.jar` 和 `charset.jar`
- en: 'Java extension files: Additional libraries that may reside in the `lib` folder'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 扩展文件：可能位于 `lib` 文件夹中的附加库
- en: 'Security-related files: Certificates, policies, and so on'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全相关文件：证书、策略等
- en: Font files
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体文件
- en: Operating system-specific tools
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于操作系统的工具
- en: 'The JRE includes a JVM and precisely two types of compilers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JRE 包含 JVM 和精确两种类型的编译器：
- en: '**Client Compiler**: Fast loading without optimization. It is designed to run
    the instructions to obtain a result very quickly. Commonly used for standalone
    programs.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端编译器**：快速加载而不进行优化。它旨在快速运行指令以获得结果。通常用于独立程序。'
- en: '**Server Compiler**: Loaded code goes through additional checks to ensure code
    stability. There is also an effort to produce highly optimized machine code to
    deliver better performance. It supports better statistics in order to run machine
    code optimization executed by the **Just-in-Time** (**JIT**) compiler (*Figure
    2**.2*).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器编译器**：加载的代码会经过额外的检查以确保代码稳定性。还有努力产生高度优化的机器代码以提供更好的性能。它支持更好的统计信息，以便运行由 **即时**（**JIT**）编译器执行的机器代码优化（*图
    2.2*）。'
- en: The JVM
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM
- en: Both the JDK and the JRE contain the JVM (*Reference 6*). The JVM is platform-dependent.
    This means that every system platform requires the use of a dedicated version.
    Fine, but what does the JVM really do, and how?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 和 JRE 都包含 JVM（*参考 6*）。JVM 是平台相关的。这意味着每个系统平台都需要使用专用版本。好吧，但 JVM 究竟做什么，以及如何做？
- en: Although there are multiple versions of the JVM, even from multiple vendors,
    the JVM itself is defined by a specification that must be followed. The reference
    implementation is represented by OpenJDK. In fact, OpenJDK is a collection of
    several smaller open source projects that may even have different development
    dynamics, but the OpenJDK release contains planned versions of each.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多个版本的 JVM，甚至来自多个供应商，但 JVM 本身是由一个必须遵循的规范定义的。参考实现由 OpenJDK 表示。实际上，OpenJDK 是几个较小的开源项目的集合，这些项目甚至可能具有不同的开发动态，但
    OpenJDK 发布包含每个计划的版本。
- en: '![Figure 2.2 – Key parts of the JVM](img/B18884_02_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – JVM 的关键部分](img/B18884_02_02.jpg)'
- en: Figure 2.2 – Key parts of the JVM
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – JVM 的关键部分
- en: The OpenJDK JVM implementation (*Figure 2**.2*) includes a JIT compiler called
    **HotSpot** (*Reference 7*). HotSpot is part of the JVM and its responsibility
    is runtime compilation. In other words, the JIT compiler translates or compiles
    the provided bytecode into a native system instruction at runtime. This process
    is sometimes called **dynamic translation**. Due to these JVM dynamic translation
    capabilities, Java applications are sometimes referred to as system platform-independent
    and the WORA acronym is used. This statement needs to be abstracted slightly because
    a JVM system implementation is required to translate the bytecode into a native
    instruction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK JVM 实现包括一个称为 **HotSpot**（*参考 7*）的 JIT 编译器。HotSpot 是 JVM 的一部分，其责任是运行时编译。换句话说，JIT
    编译器在运行时将提供的字节码转换为本地系统指令。这个过程有时被称为 **动态转换**。由于 JVM 的这些动态转换能力，Java 应用程序有时被称为系统平台无关，并使用
    WORA 这个缩写。这个陈述需要稍微抽象一下，因为需要 JVM 系统实现来将字节码转换为本地指令。
- en: In addition to the JVM JIT compiler, it includes a garbage collector with various
    algorithms, a class loader, a Java memory implementation model, and a **Java Native
    Interface** (**JNI**) with libraries (as shown in *Figure 2**.2*).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Every JVM provider must follow the specifications. This guarantees that the
    bytecode will not only be created accordingly but also executed and correctly
    converted into machine instructions. This means that different vendors may provide
    different JVM implementations with slightly different metrics or optimizations,
    such as garbage collector dynamics. These vendors include IBM, Azul, Oracle, and
    so on. The diversity of vendors can be considered one of the main moving factors
    for the Java platform's evolution. New features are extended or modified through
    the **JDK Enhancement Proposal** (**JEP**), where each vendor can contribute or
    get a very detailed overview.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the JVM’s responsibilities to remember are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Loading linking
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiating classes and interfaces
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program instruction execution
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JVM defines several different areas used by each program (*Example 2.2*).
    Let’s look at each of them one by one, area by area (*Figure 2**.2*). This can
    boost our understanding of the value of design patterns and their approaches,
    such as the Builder or Singleton pattern.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Simplified schema of program compilation and execution](img/B18884_02_03.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Simplified schema of program compilation and execution
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with written text, representing a program stored in a `.java`
    file. The file will be compiled (*Figures 2.3*) and run (*Figure 2**.4*) and threads
    are started. Startup starts the system process in which the JRE is running and
    the JVM is running as part of the JRE.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.4 – Threads\uFEFF that started behind the scene event for a Program.java\
    \ execution example (Java Flight Recorder)](img/B18884_02_04.jpg)"
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Threads that started behind the scene event for a Program.java
    execution example (Java Flight Recorder)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: With a general idea of the flow, let’s start by loading classes into memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The class-loader loader area
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The class loader subsystem is located in **Random-Access Memory** (**RAM**)
    and is responsible for loading classes into memory. The load step consists of
    the sub-line steps and the first run of the class at runtime. Linking is the process
    of preparing a class or interface for a runtime environment, which may include
    internal dependencies, for example. The platform provides internal functions or
    customized ones; to manage all these capabilities, the platform provides dedicated
    class loaders:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`BOOTPATH` (property).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib/ext` directory, which is a part of the JRE installation.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` method and runs the classes from the served class or module path.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassLoader` and may be used to define custom classes dynamically loading
    processes to the JVM. It is possible to use a user-defined class destination.
    Classes can reside on the network, be encrypted inside files, or be downloaded
    across the network and generated on the fly.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassLoader` 可以用来定义动态加载到 JVM 中的自定义类的过程。可以使用用户定义的类目标。类可以位于网络上，存储在文件中的加密状态，或者通过网络下载并在运行时生成。'
- en: Class loaders work in sequence. The sequence is represented by a hierarchy.
    This means that every child must refer to its parents. This automatically defines
    the search order of the binary classes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器按顺序工作。顺序由一个层次结构表示。这意味着每个子类必须引用其父类。这自动定义了二进制类的搜索顺序。
- en: When a class is present in RAM, the Java platform takes action to make the class
    available to the runtime environment. The Java platform runs several processes
    behind the scenes to move relevant class data to other areas, such as the stack,
    heap, and so on. Let’s look at the stack area next.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类存在于 RAM 中时，Java 平台会采取行动使该类可供运行时环境使用。Java 平台在幕后运行多个进程，将相关的类数据移动到其他区域，例如栈、堆等。接下来让我们看看栈区域。
- en: The stack area
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈区域
- en: The stack area (*Figure 2**.2*) is reserved for each thread at runtime. This
    is a small area for storing method references. When a thread executes a method,
    one entry for that method is created and moved to the top of the stack. This kind
    of item is called a stack frame, which has a reference to a field of local variables,
    a stack of operands, and a constant pool to identify the appropriate method. The
    stack frame is removed when the method is executed normally – that is, without
    causing any exceptions. This means that local primitive variables such as `boolean`,
    `byte`, `short`, `char`, `int`, `long`, `float`, and `double` are also stored
    here, so they are not visible to the second thread. Each thread can pass a copy,
    but this does not share the origin.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 栈区域（*图 2**.2*）在运行时为每个线程保留。这是一个用于存储方法引用的小区域。当一个线程执行一个方法时，为该方法创建一个条目并将其移动到栈顶。这种项目被称为栈帧，它引用局部变量的字段、操作数的栈和一个常量池以识别适当的方法。当方法正常执行时（即没有引发任何异常）会移除栈帧。这意味着局部原始变量，如
    `boolean`、`byte`、`short`、`char`、`int`、`long`、`float` 和 `double` 也存储在这里，因此它们对第二个线程不可见。每个线程可以传递一个副本，但这并不共享原始数据。
- en: The heap area
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆区域
- en: The heap is the allocated memory where all instances of the class and array
    are located. The heap is allocated at startup and is shared among all JVM-initiated
    threads. Allocated memory is automatically recovered by the automated management
    system process, also known as **Garbage Collection** (**GC**). A local variable
    can contain a reference to objects. The referenced object is located in a heap.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是所有类的实例和数组所在分配的内存。堆在启动时分配，并由所有 JVM 启动的线程共享。分配的内存由自动管理系统进程自动回收，也称为**垃圾回收**（**GC**）。局部变量可以包含对对象的引用。引用的对象位于堆中。
- en: The method area
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法区域
- en: The method area is shared across all JVM-initiated threads. The area is allocated
    during the JVM startup time. It contains runtime data for each class, such as
    a constant pool, field and method data, the code for constructors, and methods.
    Probably the most unfamiliar term mentioned is the constant pool. The constant
    pool is created during the process of loading the class into the method area.
    It contains the initial values of string and primitive constants, the names of
    the reference classes and other data needed to properly execute the loaded class,
    the constants known at compile time, and field references that must be resolved
    at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方法区域是所有由 JVM 启动的线程共享的。该区域在 JVM 启动时分配。它包含每个类的运行时数据，例如常量池、字段和方法数据、构造函数和方法的代码。提到的不太熟悉的概念可能是常量池。常量池是在将类加载到方法区域的过程中创建的。它包含字符串和原始常量的初始值、引用类的名称以及其他执行加载的类所需的数据，包括编译时已知的常量和必须在运行时解析的字段引用。
- en: Program counter
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序计数器
- en: The **Program Counter** (**PC**) register is another important reserved area
    in memory. It contains a list of created program counters. A PC record is created
    at the beginning of each thread and contains the address of the currently executed
    instruction by a specific thread. The address points back to the method area.
    The only exception is the native method, which leaves the address undefined.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序计数器**（**PC**）寄存器是内存中的另一个重要预留区域。它包含创建的程序计数器列表。每个线程的开始都会创建一个PC记录，包含特定线程当前执行的指令的地址。该地址指向方法区。唯一的例外是原生方法，它将地址设置为未定义。'
- en: The native method stack
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原生方法栈
- en: 'A native method stack record is initiated for each individual thread. Its function
    is to provide access to native methods through the JNI. The JNI operates with
    the underlying system resources. Improper usage may turn into two exceptional
    states:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个单独的线程启动一个原生方法栈记录。其功能是通过JNI提供对原生方法的访问。JNI与底层系统资源一起操作。不当使用可能导致两种异常状态：
- en: The first exception appears when a thread requires more stack space. In this
    case, a `StackOverflowError` error is thrown and the program crashes, executed
    with a state higher than 1.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个异常出现在线程需要更多栈空间时。在这种情况下，会抛出`StackOverflowError`错误，程序崩溃，执行状态高于1。
- en: The second case represents an attempt to add more entries to the stack. The
    program results in an `OutOfMemoryError` error. It is caused by an attempt to
    dynamically expand already fully allocated memory space. The memory is insufficient
    and it is not possible to allocate a new stack for the newly intended thread.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况代表尝试向栈中添加更多条目。程序结果是一个`OutOfMemoryError`错误。这是由于尝试动态扩展已完全分配的内存空间。内存不足，无法为新线程分配新的栈空间。
- en: We have examined all the areas required to load and execute a program and we
    will get acquainted with the areas where the data is located and how they are
    interconnected. It is slowly becoming clear that in order to achieve stability
    and maintainability of the program at runtime, it is necessary to design the software
    in a way that reflects the potential limitations, as the reserved areas correspond
    to the individual areas.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了加载和执行程序所需的所有区域，我们将了解数据所在区域及其相互关联的方式。逐渐变得明显的是，为了在运行时实现程序的可稳定性和可维护性，有必要以反映潜在限制的方式设计软件，因为预留区域对应于各个区域。
- en: Let’s take a closer look at how the Java platform provides available memory
    space for each newly created object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看Java平台是如何为每个新创建的对象提供可用内存空间的。
- en: Reviewing GC and the Java memory model
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾GC和Java内存模型
- en: We mentioned the JIT compiler as part of the JVM earlier (*Figure 2**.2*). Just
    to refresh on the JIT compiler, it is responsible for translating the bytecode
    into system-specific native instructions. These instructions deal with the basic
    memory and I/O resources available to the program. To properly organize these
    instructions, the Java platform requires a set of rules that guarantee the program,
    called bytecode, which must be translated by the JIT compiler at runtime to the
    same end. Because the Java platform does not use physical memory directly, but
    rather virtual and cached views, it is very important that the memory management
    is transparent. The model must provide the required guarantees and is known as
    the **Java Memory** **Model** (**JMM**).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到JIT编译器是JVM的一部分（*图2.2*）。为了刷新一下JIT编译器的概念，它负责将字节码转换为系统特定的原生指令。这些指令处理程序可用的基本内存和I/O资源。为了正确组织这些指令，Java平台需要一套规则来保证程序，即字节码，在运行时必须由JIT编译器转换为相同的最终状态。因为Java平台不直接使用物理内存，而是使用虚拟和缓存的视图，内存管理必须透明。该模型必须提供所需的保证，并被称为**Java内存模型**（**JMM**）。
- en: The JMM
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JMM
- en: The JMM describes how threads interact with each other through access to allocated
    memory – the heap (*Figure 2**.2*). The execution of a single-threaded program
    may seem obvious because the instructions are processed in a certain order without
    external influence and the thread is in isolation. In the case of a single thread
    (see the `main` method in *Example 2.2* and the `main` thread in *Figure 2**.4*),
    the run areas are modified each time the instruction is executed; there is no
    surprise. The situation changes when the program starts multiple threads. The
    JMM enforces its guarantees of reliable Java program execution. The JMM defines
    a set of rules for possible instruction order changes and execution restrictions
    caused by sharing objects in memory between different threads. The fact that the
    JMM strictly follows these rules forces JIT optimization without fear of code
    instability (maintaining a consistent state).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JMM描述了线程如何通过访问分配的内存（*图2.2*）相互交互。单线程程序的执行可能看起来很明显，因为指令以某种顺序处理，没有外部影响，线程是隔离的。在单线程的情况下（参见*示例2.2*中的`main`方法和*图2.4*中的`main`线程），每次执行指令时都会修改运行区域；没有惊喜。当程序启动多个线程时，情况就改变了。JMM强制执行其关于可靠Java程序执行的保证。JMM定义了一组规则，用于可能指令顺序更改和由不同线程之间在内存中共享对象引起的执行限制。JMM严格遵循这些规则的事实，使得JIT优化无需担心代码不稳定（保持一致状态）。
- en: The rules can easily be reformulated and each action can be changed as long
    as the execution of the thread does not violate the program order. Basically,
    this means that the program remains in a consistent state.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 规则可以很容易地重新表述，只要线程的执行不违反程序顺序，每个动作都可以更改。基本上，这意味着程序保持一致状态。
- en: Object locks or releases are governed by the order of the program and each thread
    shares a corresponding memory view of the modified data. The memory view represents
    the portion of allocated physical memory represented by the heap because each
    object created is located inside the heap.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的锁定或释放由程序顺序控制，每个线程共享修改数据的相应内存视图。内存视图表示由堆表示的已分配物理内存的部分，因为每个创建的对象都位于堆内。
- en: One of the important guarantees of the JMM is known as happens-before. It states
    that one action always happens before another in order to maintain the order of
    the program. To better understand this rule, it is necessary to describe how system
    memory works and briefly introduce the general types of memory and how the CPU
    fits into the process of reading values and executing machine instructions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JMM的一个重要保证被称为happens-before。它指出，为了保持程序顺序，一个动作总是发生在另一个动作之前。为了更好地理解这条规则，有必要描述系统内存的工作方式，并简要介绍内存的一般类型以及CPU如何适应读取值和执行机器指令的过程。
- en: Let us start with the CPU. Each CPU contains its own instruction register. The
    machine code compiled by the JIT compiler has a reference to an available set
    of instructions. The CPU contains an internal cache used to store a copy of data
    from the main RAM. The CPU communicates with the reserved RAM. One CPU can run
    multiple platform threads (depending on the type of CPU) at the same time. The
    result of this embodiment modifies the state of the RAM in the thread stack or
    heap. The dedicated RAM for the running Java application is then copied to the
    CPU cache and used by the CPU registry (*Figure 2**.5*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从CPU开始。每个CPU都包含自己的指令寄存器。JIT编译器编译的机器代码有一个对可用指令集的引用。CPU包含一个内部缓存，用于存储主RAM中的数据副本。CPU与保留的RAM进行通信。一个CPU可以同时运行多个平台线程（取决于CPU的类型）。这种实现的结果会修改线程堆栈或堆中的RAM状态。然后，运行Java应用程序的专用RAM被复制到CPU缓存中，并由CPU寄存器使用（*图2.5*）。
- en: '![Figure 2.5 – CPU and memory interaction](img/B18884_02_05.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – CPU和内存交互](img/B18884_02_05.jpg)'
- en: Figure 2.5 – CPU and memory interaction
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – CPU和内存交互
- en: 'Those who are attentive may have already noticed that due to memory differentiation,
    the program can face unpredictable difficulties caused by looking at the program’s
    memory. When multiple threads try to update or read specific values of variables
    without careful handling, this can result in one of the following problems:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察的人可能已经注意到，由于内存差异，程序可能会面临由查看程序内存引起的不可预测的困难。当多个线程试图在不加小心处理的情况下更新或读取变量的特定值时，这可能导致以下问题之一：
- en: '**A racing condition**: This occurs when two threads attempt to access the
    same value in an unsynchronized manner.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**：当两个线程以非同步方式尝试访问相同的值时，就会发生这种情况。'
- en: '**Value update visibility**: A variable update that is shared between multiple
    threads has not been propagated to the main memory, so other threads get the old
    value.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值更新可见性**：在多个线程之间共享的变量更新尚未传播到主内存，因此其他线程得到旧值。'
- en: To address these challenges, let’s analyze a real access to variables. What
    is already known is that each value is located within the allocated RAM heap.
    It seems obvious that updating the status of each variable may cause some penalties,
    as each instruction has to take a whole journey (*Figure 2**.5*). In most cases,
    this is also not necessary. A good example is the implementation of an isolated
    method (*Example 2.2*). However, there are cases where the actual value of a variable
    is required from memory, for which the Java platform has introduced the `volatile`
    keyword. Using the `volatile` keyword before a variable gives the variable a guarantee
    that when another thread requests a value, it checks its current value in the
    main memory. This means that using the `volatile` keyword provides a guarantee
    of happens-before and each thread sees its true value. It is fair to note that
    because using `volatile` provides a certain level of memory synchronization, it
    should be used wisely. Its use is associated with performance limitations caused
    by main memory access.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，让我们分析一个对变量的实际访问。已知的是，每个值都位于分配的RAM堆中。显然，更新每个变量的状态可能会带来一些惩罚，因为每个指令都必须走完整个旅程（*图2.5*）。在大多数情况下，这也不是必要的。一个很好的例子是隔离方法的实现（*示例2.2*）。然而，在某些情况下，需要从内存中获取变量的实际值，为此Java平台引入了`volatile`关键字。在变量前使用`volatile`关键字为变量提供了一个保证，即当另一个线程请求值时，它会检查主内存中的当前值。这意味着使用`volatile`关键字提供了一种happens-before的保证，并且每个线程都能看到其真实值。值得注意的是，由于使用`volatile`提供了一定程度的内存同步，因此应谨慎使用。它的使用与由主内存访问引起的性能限制相关。
- en: Another approach to sharing variable values across multiple threads is to use
    the `synchronized` keyword. Its use gives the method or variable a guarantee that
    each participant, the thread, will be informed about the approaches. Obviously,
    the main disadvantage of using `synchronized` is that all threads will be informed
    about access to the method or variables, which in turn, will cause a decrease
    in performance due to memory synchronization. As with `volatile`, `synchronized`
    guarantees happens-before.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程之间共享变量值的另一种方法是使用`synchronized`关键字。它的使用为方法或变量提供了一个保证，即每个参与者，即线程，都会被告知这些方法。显然，使用`synchronized`的主要缺点是所有线程都会被告知对方法或变量的访问，这反过来又会因为内存同步而导致性能下降。与`volatile`一样，`synchronized`保证了happens-before。
- en: The JMM is bright and fresh; we stated that each new object is located in the
    heap (*Figure 2**.2*). We are familiar with the big picture of the JRE architecture,
    and we know that most Java programs seem to be multi-threaded – there is a set
    of rules that the Java platform follows so that the process forces the correct
    order of programs to achieve consistency.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JMM是明亮且新鲜的；我们提到每个新对象都位于堆中（*图2.2*）。我们对JRE架构的大致情况很熟悉，我们知道大多数Java程序似乎是多线程的——Java平台遵循一组规则，以便进程强制程序的正确顺序以实现一致性。
- en: GC and automatic memory management
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC和自动内存管理
- en: Although the Java platform may give the impression that the underlying memory
    is unlimited, this is not true and we will examine it next. So far, we have looked
    at how variable visibility works across multiple threads and how values are referenced
    in physical memory. The JMM is just one part of the whole story – let’s continue
    the investigation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java平台可能给人留下底层内存无限的印象，但这并不正确，我们将在下一节中探讨这一点。到目前为止，我们已经探讨了变量在多个线程之间的可见性工作原理以及如何在物理内存中引用值。JMM只是整个故事的一部分——让我们继续调查。
- en: We already know that the Java platform uses an automatic memory management process
    to maintain the allocated memory for the heap. Part of the process is a program
    that runs in the background of the daemon thread. It is called the garbage collector
    (*Reference 5*) and runs silently behind the scenes, reclaiming and compacting
    unused memory. This is one of the advantages of the dynamic allocation of objects
    in the heap. Another perhaps less obvious advantage is the ability to work with
    recursive data structures, such as lists or maps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Java平台使用自动内存管理过程来维护堆分配的内存。这个过程的一部分是一个在守护线程后台运行的程序。它被称为垃圾回收器（*参考5*），在幕后默默运行，回收和压缩未使用的内存。这是堆中对象动态分配的一个优点。另一个可能不那么明显的优点是能够处理递归数据结构，例如列表或映射。
- en: GC was invented around 1959 by John McCarthy. The goal was to simplify manual
    memory management in Lisp. Since then, GC has undergone massive development and
    various GC techniques have been invented (*Reference 1*). Even after the development
    of various GC approaches, the security rule remains the most important. The GC
    should never regain a repository of live objects that contain active references.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收（GC）大约在1959年由约翰·麦卡锡发明。目标是简化Lisp中的手动内存管理。从那时起，GC经历了大规模的发展，并发明了各种GC技术（*参考1*）。即使在各种GC方法的发展之后，安全规则仍然是最重要的。GC永远不应该恢复包含活动引用的活对象存储库。
- en: Although the developer does not have to bother with memory reclamation, it can
    be very useful to understand the underlying process to avoid unexpected application
    failures because system memory is limited in one way or another. The reason remains
    that even if the GC is in place, it is possible to create code that never loads
    the object, which means that the application may crash with an `OutOfMemoryError`
    error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开发者不必担心内存回收，但了解底层过程可以非常有用，以避免意外的应用程序失败，因为系统内存总是有限的。原因在于，即使GC已经到位，仍然可能编写永远不会加载对象的代码，这意味着应用程序可能会因为`OutOfMemoryError`错误而崩溃。
- en: 'The goal of the GC process is to keep the heap nice and shiny, ready to allocate
    a new object. The heap area is divided into smaller segments as shown in *Figure
    2**.6*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: GC过程的目标是保持堆干净整洁，准备好分配新的对象。堆区域被划分为更小的段，如图*图2.6*所示：
- en: '![Figure 2.6 – Simplified heap structure divided into promotion segments](img/B18884_02_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 简化的堆结构分为晋升段](img/B18884_02_06.jpg)'
- en: Figure 2.6 – Simplified heap structure divided into promotion segments
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 简化的堆结构分为晋升段
- en: It is a known fact that most objects will be allocated and placed in Eden’s
    memory and will not survive the second round of cleanup. After performing Minor
    GC, all surviving objects are moved to one of the surviving spaces (denoted by
    **S0** and **S1**). The secondary GC round also checks the **S0** and **S1** fields
    and spreads them among the others at a time when one of the survival sites may
    be empty. The object survived; many Minor GCs have been moved to the **Old generation**.
    The heap also contains a permanent section. The permanent section contains the
    metadata required by the JVM to describe classes, static methods, and private
    variables, and is populated at runtime. This area was formerly known as the **Permanent
    generation** (**Permgen**). It was separated from the main heap memory, was not
    loaded, and had to be configured. This disadvantage often led to application instability
    due to insufficient memory requirements. Java SE 8 introduced MetaSpace, which
    replaced the Permgen concept. MetaSpace has solved the problem of space configuration
    because it can grow automatically and in addition, garbage can be collected.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，大多数对象将被分配并放置在伊甸园内存中，并且不会在第二次清理中存活。在执行Minor GC之后，所有存活的对象都被移动到其中一个存活空间（用**S0**和**S1**表示）。次要GC轮次也会检查**S0**和**S1**字段，并在其中一个存活位置可能为空的时候将它们分散到其他地方。对象存活了；许多Minor
    GC已经移动到**老年代**。堆还包含一个永久部分。永久部分包含JVM描述类、静态方法和私有变量所需的元数据，并在运行时填充。这个区域以前被称为**永久代**（**Permgen**）。它从主堆内存中分离出来，没有加载，并且需要配置。这个缺点经常由于内存需求不足而导致应用程序不稳定。Java
    SE 8引入了MetaSpace，取代了Permgen概念。MetaSpace解决了空间配置问题，因为它可以自动增长，此外，垃圾也可以被回收。
- en: 'GC works essentially in two steps, described as Minor and Major GC. These steps
    are a proposal for building on the basis of durability – that is, long-term references:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: GC基本上分为两个步骤，称为Minor和Major GC。这些步骤是基于持久性的建议 – 即，长期引用：
- en: '**Minor GC**: This happens when there is no reference to the object, the object
    is marked as unreachable, the Young generation area is reclaimed, and the memory
    can be compacted.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minor GC**：当没有引用到对象时，对象被标记为不可达，年轻代区域被回收，内存可以进行压缩。'
- en: '**Major/Full GC**: An object that has survived several Minor GCs and has been
    moved to an Old generation heap area. After a long time, it does not refer to
    any other object, no other object refers to it, and it is ready to be deleted.
    Full GC is less common than Minor GC and there is a long pause (stop-the-world).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Major/Full GC**：一个已经经历了几次Minor GC并移动到老年代堆区的对象。经过一段时间后，它不再引用任何其他对象，没有其他对象引用它，它准备被删除。Full
    GC比Minor GC少见，并且有一个较长的暂停（停止世界）。'
- en: 'The GC process can be simplified with three steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GC过程可以用三个步骤简化：
- en: 'In the first step, GC marks unreachable objects (*Figure 2**.7*):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中，GC标记不可达的对象（**图2.7**.7）：
- en: '![Figure 2.7 – The first collection marking step identifies unused objects
    in the heap](img/B18884_02_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 第一收集标记步骤识别堆中的未使用对象](img/B18884_02_07.jpg)'
- en: Figure 2.7 – The first collection marking step identifies unused objects in
    the heap
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 第一收集标记步骤识别堆中的未使用对象
- en: 'In the second step, the links are removed and the space is left free as it
    was (*Figure 2**.8*):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，移除链接，空间保持空闲，就像它之前一样（**图2.8**）：
- en: '![Figure 2.8 – Freeing memory by deleting marked objects](img/B18884_02_08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 通过删除标记对象释放内存](img/B18884_02_08.jpg)'
- en: Figure 2.8 – Freeing memory by deleting marked objects
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 通过删除标记对象释放内存
- en: 'The third step is called compacting (*Figure 2**.9*). It reorganizes the memory
    into larger parts, so when a program tries to allocate a larger object, space
    is ready for it. This makes memory allocation for all objects much faster not
    only due to the free space but also eliminates the need to scan a free memory
    frame:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步称为压缩（**图2.9**）。它将内存重新组织成更大的部分，因此当程序尝试分配更大的对象时，空间已经准备好。这使得所有对象的内存分配速度大大加快，不仅因为空闲空间，还消除了扫描空闲内存帧的需要：
- en: '![Figure 2.9 – Compacting freed memory to be able to allocate bigger objects
    in frames](img/B18884_02_09.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 压缩释放的内存以便在帧中分配更大的对象](img/B18884_02_09.jpg)'
- en: Figure 2.9 – Compacting freed memory to be able to allocate bigger objects in
    frames
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 压缩释放的内存以便在帧中分配更大的对象
- en: 'With a fresh awareness of the tasks of the JMM and GC, there is another important
    concept related to both. The concept of reference types is a way to tell the platform
    how to handle a specific allocated part of the heap space – more specifically,
    how to help the platform’s internal analytical processes. Reference types have
    been added to help GC to evaluate the purpose of variables. This means speeding
    up the decision of whether to collect the variable or not. The concept of a reference
    type is a neat tool, along with a design pattern, and previously renewed themes
    make even more sense. The goal of every program is to run as fast as possible.
    This means that even the waste collection process causes pauses, so it must be
    as fast as possible. Hence, internal platform processes must also be as fast as
    possible. So, regardless of the GC algorithm used, when the dataset is small,
    the process will be much faster. There’s also a place for reference types to help
    keep the allocated memory fresh and clean. The platform offers the following types,
    sorted by their resilience to GC:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在对JMM和GC的任务有了新的认识之后，还有一个与两者都相关的重要概念。引用类型的概念是一种告诉平台如何处理堆空间中特定分配部分的方式 – 更具体地说，如何帮助平台的内部分析过程。引用类型被添加以帮助GC评估变量的目的。这意味着加快是否收集变量的决策。引用类型的概念是一个整洁的工具，与设计模式相结合，以及之前更新的主题，使事情更有意义。每个程序的目标是尽可能快地运行。这意味着即使是垃圾收集过程也会导致暂停，所以它必须尽可能快。因此，内部平台过程也必须尽可能快。所以，无论使用哪种GC算法，当数据集较小时，过程会快得多。引用类型也有助于保持分配的内存新鲜和干净。平台提供了以下类型，按其抵抗GC的能力排序：
- en: '**Strong references**: The most common type of reference – not required to
    be specified.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强引用**：最常见的引用类型 – 不需要指定。'
- en: '`var obj = new WeakReference<Object>();` – and it’s a signal to the GC algorithm
    to reclaim memory during the next GC cycle. This is mostly used during a program
    initiation phase or caching.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OutOfMemoryError` error.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phantom reference**: This represents the weakest type of reference. This
    team is collected as soon as possible, which means there is no further analysis
    or promotion to another level. A variable of this type is reclaimed immediately
    when the GC cycle runs.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before embarking on the Java API journey, let’s quickly summarize our newly
    acquired knowledge.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: References play an important role in the GC process. They tell garbage collectors
    how to handle a particular variable. The Java memory model provides the required
    guarantees as to how the value of a variable is read, updated, or deleted. We
    examined how values are stored in allocated memory, memory segmentation, and their
    relationship to the underlying system. All this new information helps us with
    better software design and API usage.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Examining the core Java APIs
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JDK provides a set of tools for creating, compiling, and running the required
    Java program. We learned how this program uses basic resources to provide the
    desired result. We have also examined a number of limitations that we must take
    into account when designing this kind of program. The JDK provides tools for software
    designers by making an internal collection of classes grouped into APIs available.
    The previous section explored how the JDK can be extended with external APIs that
    can be added on demand (discussed earlier in *The* *JRE* section).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the most important basic APIs we use for design
    patterns in detail.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Java is an object-oriented language with many other features and extensions.
    The official basic Java API can be found in the `java. *` package (as listed in
    *Table 2.1*).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sub-package** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `java.io.*` | Related to system I/O through data streams, serialization,
    and filesystems |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.*` | Automatically imported fundamental classes for the Java language
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `java.math.*` | Classes related to the arbitrary precision arithmetic for
    integers (`BigInteger`) and decimals (`BigDecimal`) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `java.net.*` | APIs related to network protocols and communication |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `java.nio.*` | An overview of buffer definitions as data containers and other
    non-blocking packages |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `java.security.*` | Classes and interfaces for the Java security framework
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `java.text.*` | Provides classes for handling formatted messages with texts,
    numbers, and dates |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `java.time.*` | APIs for calendars, dates, times, instants, and durations
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `java.util.*` | Serves as a collection framework, string parsing, scanning
    classes, random number generator, Base64 encoders and decoders, and some miscellaneous
    utilities, among other things |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – java.* packages available in Java 17 SE
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Every newly created class can automatically access public classes and interfaces
    that reside in the `java.lang.*` package from the `java.base` module. As everything
    is an object, it implies that each class has an `Object` instance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新创建的类都可以自动访问位于`java.lang.*`包中的公共类和接口，这些类和接口位于`java.base`模块中。由于一切都是对象，这意味着每个类都有一个`Object`实例。
- en: Primitive data types and wrappers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始数据类型和包装类
- en: Java also provides a set of primitive types (*Reference 4*) called literals
    (*Table 2.2*). One difference between a literal and an `Object` instance is that
    each literal has a well-defined size in memory. In contrast, the size of the `Object`
    instance may vary depending on demand. The literal type of Java is signed, which
    is quite useful to remember if you are dealing with data buffering operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Java还提供了一组称为字面量的原始类型（*参考4*），称为字面量（*表2.2*）。字面量和`Object`实例之间的一个区别是，每个字面量在内存中都有一个定义良好的大小。相比之下，`Object`实例的大小可能根据需求而变化。Java的字面量类型是有符号的，如果你在处理数据缓冲操作，这将非常有用记住。
- en: '| **Size** | **Literal name** | **Range** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **字面量名称** | **范围** |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 bit (*) | `boolean` | `true` or `false` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1位(*) | `boolean` | `true`或`false` |'
- en: '| 1 byte | `byte` | -128 to 127 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 1字节 | `byte` | -128到127 |'
- en: '| 2 bytes | `short` | -32,768 to 32,767 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 2字节 | `short` | -32,768到32,767 |'
- en: '| 2 bytes | `char` | \u0000 to \uffff |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 2字节 | `char` | \u0000到\uffff |'
- en: '| 4 bytes | `int` | -2^31 to 2^31-1 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 4字节 | `int` | -2^31到2^31-1 |'
- en: '| 4 bytes | `float` | -3.4e38 to 3.4e38 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 4字节 | `float` | -3.4e38到3.4e38 |'
- en: '| 8 bytes | `long` | -2^63 to 2^63-1 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 8字节 | `long` | -2^63到2^63-1 |'
- en: '| 8 bytes | `double` | -1.7e308 to 1.7e308 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 8字节 | `double` | -1.7e308到1.7e308 |'
- en: Table 2.2 – Primitive types with their sizes; (*) boolean size is not precisely
    defined
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 – 原始类型及其大小；（*）布尔类型的大小未精确定义
- en: The primitive types reside in the stack area (refer to *Figure 2**.2*) and each
    literal contains a wrapper object (*Figure 2**.10*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型位于栈区（参见图2**.2*）并且每个字面量都包含一个包装对象（*图2**.10*）。
- en: "![Figure 2.10 – Data type wrapper inheritance\uFEFF with the literals with\
    \ String type associations](img/B18884_02_10.jpg)"
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 数据类型包装继承与字面量与String类型关联](img/B18884_02_10.jpg)'
- en: Figure 2.10 – Data type wrapper inheritance with the literals with String type
    associations
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 数据类型包装继承与字面量与String类型关联
- en: 'The envelope is initiated around literal values. This means that the literal
    is stored in the stack area and the wrapper object is located inside the heap.
    The cover provides additional features. Take the `Integer` class as an example,
    which provides the following methods: `byteValue`, `doubleValue`, and `toString`.
    These methods can be called within a specific design pattern to achieve the desired
    goal and avoid unnecessary memory contamination. This is in comparison to literals
    that only provide a native implementation of a value.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 封装围绕字面量值启动。这意味着字面量存储在栈区，而包装对象位于堆中。封面提供了额外的功能。以`Integer`类为例，它提供了以下方法：`byteValue`、`doubleValue`和`toString`。这些方法可以在特定的设计模式中调用以实现预期的目标并避免不必要的内存污染。这与仅提供值原生实现的字面量形成对比。
- en: 'The Java platform automatically addresses the literal to the appropriate wrapper
    class and the like. This fact not only has a bright side but also has a dark side,
    known as an autoboxing issue (*Example 2.3*). This happens exactly when the primitive
    type is cast to a wrapper type. This can lead to very frequent waste collection,
    which can mean an enormous number of stop-the-world events:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台自动将字面量分配给适当的包装类等。这一事实不仅有其光明的一面，也有其阴暗的一面，即所谓的自动装箱问题（*示例2.3*）。这正好发生在原始类型被转换为包装类型时。这可能导致非常频繁的垃圾回收，这可能意味着大量的停止世界事件：
- en: '[PRE2]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 2.3 – Auto-casting example where a new Integer wrapper is created under
    the hood
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.3 – 在幕后创建新的Integer包装器的自动装箱示例
- en: 'When working with literal numbers, it is useful to keep in mind that a literal
    with a smaller byte size (*Table 2.2*) can be automatically assigned to a literal
    with a larger size (*Example 2.4*). The other way around, it causes a compilation
    error due to the precisely allocated byte size in the memory stack area:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字面量数字时，记住一个具有较小字节大小的字面量（*表2.2*）可以自动分配给一个具有较大大小的字面量（*示例2.4*）。反过来，由于内存栈区中精确分配的字节大小，这会导致编译错误：
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 2.4 – Literal automatic casting
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.4 – 字面量自动装箱
- en: We have checked the numbering and how automatic submission works on the Java
    platform. A Boolean literal is `true` or `false` and is represented in memory
    as 1 bit.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The last of the specific literals not yet mentioned is `char` and its cover
    character. Let’s take a closer look because it’s also related to the essential
    `String` object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Working with the String API
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` instance is not literal. A string is represented as an object in
    Java. It is defined by a sequence of characters. It is almost impossible to avoid
    using a string to write any program. In addition to the fact that a Java executable
    requires a `String` field as input to the `main` method, variable names are also
    represented as a string. The string is immutable in Java. This means that any
    operation, such as concatenation, on its value will create a new string. More
    precisely, it is not possible to change its current value. A string is the base
    class of the Java platform.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: A common way to store a string value is to use a String Pool. The String Pool
    only stores intrinsic values (*Figure 2**.11*). This means that it is only possible
    to have one different constant value present. This approach makes the pool more
    efficient in terms of memory, including time-consuming string operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.11 – The String Pool is a part of the heap memory and a String object\
    \ resides in the heap \uFEFFlike other objects](img/B18884_02_11.jpg)"
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The String Pool is a part of the heap memory and a String object
    resides in the heap like other objects
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also store strings directly in the heap using the `String` constructor
    – for example, `new String`. In this case, the link is not to an equivalent value
    that is already present in the String Pool (represented by `t3` in *Example 2.5*)
    because it is located in a different heap memory space. If you force a search
    in pool strings, you can use the `intern` method (`t4` in *Example 2.5*):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 2.5 – Comparing different ways of assigning String values
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `+` operator on String classes can turn into a very inefficient use
    of concatenation or program maintainability. To prevent String contamination,
    the Java platform provides the `StringBuilder` class as part of its APIs. `StringBuilder`
    prevents temporary values from being stored and only stores the result created
    by executing its internal `toString` method, which creates a new `String` object
    in the heap space (*Example 2.6*). `StringBuilder` also introduces the implementation
    and use of the creational design pattern within the Java SDK:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 2.6 – StringBuilder creates a new String object by default in the heap
    space
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: We found out how String objects are created and in which heap memory they are
    stored. This newly acquired information can strengthen us in making decisions
    by choosing a suitable design pattern or a combination of them to avoid misuse
    of memory. Because the string is under the hood of an array of characters, primitive
    type `char[]`, the array is not primitive – in fact, it is an object. Let’s examine
    this concept a little more closely because it is also essential for the Java language
    and platform.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Introducing arrays
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the Java collections framework better, first, we will look at
    an important concept, arrays. In Java, an array is represented by a sequence of
    the same type of positional index elements. Fields are index-based. Any attempt
    at runtime to get an element from a non-existent position results in `ArrayIndexOutOfBoundsException`.
    The array field is allocated as an object and stored in heap space. This means
    that in the case of insufficient space, an `OutOfMemoryError` exception is thrown.
    Each array requires a defined size due to memory allocation. Simple field allocation
    with literals is relatively memory-efficient (*Example 2.8*):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 2.8 – Multiple array allocation approaches
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays allow us to store elements that implement interface classes or a range
    of abstract classes. The field variable declaration does not create or assign
    a new field; the variable contains a field reference (*Example 2.9*):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 2.9 – Array initiation, assignment, and verification
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The use of the field is often neglected due to its potentially precise requirements
    and limited auxiliary methods. However, it can help enforce the open-closed principle,
    which assumes code maintainability.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The field is more often replaced by collection or map structures, which provide
    additional helper methods. Let us explore the topic more closely.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Discovering a collection framework
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike fields, advanced collections provide an automatic resizing feature. This
    means that the required base representation will be copied and the previous version
    will become eligible for GC. The Java collections framework includes `List` (*Table
    2.3*), `Set` (*Table 2.4*), `Queue` (*Table 2.5*), and `Map` interfaces with several
    implementations (*Figure 2**.12*). Implementations may vary by vendor, but all
    must conform to basic specifications.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.12 – Dependencies between Java collection\uFEFFs framework interfaces](img/B18884_02_12.jpg)"
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Dependencies between Java collections framework interfaces
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The implications of the collection are located in the `java.base` module and
    its `java.util` package. The package contains the most common implementation,
    with the known behavior of time complexity. Space complexity is not very relevant,
    as the framework comes with automatic resizing features. Time complexity can play
    a more important role in selection when it comes to design patterns, as this can
    significantly penalize the response of the proposed program. To assess the time
    complexity of O-notation, O-notation is used to highlight the upper limit and
    the worst-case program must be used to obtain it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: To evaluate the impact of time complexity, we can go through some nice examples,
    such as the importance of choosing the right data structure. Let us start with
    the list structures (*Table 2.3*), which allow access to each element using an
    index.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Contains** | **Add** | **Get** | **Remove** | **Data structure**
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList` | O(n) | O(1) | O(1) | O(n) | Array |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `LinkedList` | O(n) | O(1) | O(n) | O(1) | Linked List |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: Table 2.3 – Selected List interface implementations with their time complexities
    sorted by the actions offered
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm sometimes requires you to verify the presence of an element in
    the data structure and add or remove a new one. For these cases, let us look at
    the implementation of the `Set` interface (*Table 2.4*).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Contains** | **Add** | **Remove** | **Data structure** |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `HashSet` | O(1) | O(1) | O(1) | Hash Table |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `TreeSet` | O(log n) | O(log n) | O(log n) | Red-Black tree |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: Table 2.4 – Selected Set interface implementation sorted by their offered actions
    and time complexity
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The last interface provided by the collection group is `Queue` (*Figure 2**.12*).
    This data structure is very useful when you only need to work with the first or
    last element (*Table 2.5*).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Peak** | **Offer** | **Poll** | **Size** | **Data structure**
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `PriorityQueue` | O(1) | O(log n) | O(log n) | O(1) | Priority Heap |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| `ArrayDequeue` | O(1) | O(1) | O(1) | O(1) | Array |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: Table 2.5 – Selected Queue interface implementations with the actions offered
    and their time complexities
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to implementing a `Map` interface, it is important to remember
    what kind of map implementation type is considered. A map represents the structure
    of a key-value pair. Both the key and the values are descendants of the `Object`
    class. Apart from the fact that no literals can be used in the definition or initiation
    of the map, the correct implementation of the `hashCode` and `equals` object methods
    is required. This requirement is based on the need to identify the correct bucket
    to resolve potential map collisions. This kind of collision can lead to unexpected
    time complexity that deviates from our expectations (*Table 2.6*):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Contains Key** | **Get** **by Key** | **Remove** **by Key**
    | **Data structure** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `HashMap` | O(1) | O(1) | O(1) | Hash table |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `LinkedHashMap` | O(1) | O(1) | O(1) | Hash table, linked list |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: Table 2.6 – Selected Map interface implementations with time complexities by
    the actions provided
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework uses a heavily behavioral iterator design pattern
    to traverse through the considered elements. Those who have a keen eye must have
    already noticed that none of these functions of a collection framework would be
    possible without a proper mathematical basis. One of the main reasons for using
    design patterns is to map or create the right structures used by business logic.
    Let us take a brief look at some basic math features.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Math APIs
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java reveals basic mathematical functions by providing a static implementation
    of the final `Math` class. Final means that this class cannot be extended, which
    includes reluctant changes or replacements of basic functions. The `Math` class
    (*Example 2.10*) is located in the `java.lang` package, which means that it is
    directly available without the need to import it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 2.10 – Using common math functions provided by the Math class
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `Math` class uses the `random` method, it only gets a `double`
    result. The `Random` class is in the `java.util` package and provides more customizable
    capabilities not only for types but also for the required ranges (*Example 2.11*):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 2.11 – Generating a random number in a range (0 – upper bound)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The Java `Math` class is also used here, similar to virtually any required calculation
    that is beyond the capabilities of standard mathematical operators. Using the
    `Math` class methods can be helpful when functional programming approaches are
    being followed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and Java
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about and demonstrated the key principles
    (APIE) of **Object-Oriented Programming** (**OOP**). In recent decades, the Java
    platform has evolved with the demands of the business and development community.
    The platform has responded to this challenge by implementing an API that uses
    the composition of tree functions to provide the desired result. This is in contrast
    to the traditional loop approach with a collection of imperative commands. This
    approach caused the larger code base to meet the desired goal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: From Java SE 8 onward, the platform provides an API for streaming (*Reference
    15*). It is in the `java.util.stream` package and has nothing to do with Java
    data streams represented by input and errors (`System.out`, `System.in`, and `System.err`).
    The Stream API introduces the ability to apply operations to a sequence of elements.
    There are two types of intermediate operations that can edit or check data, as
    well as terminal operations. The terminal operation may provide a single result
    or void. Intermediate operations can be concatenated, but terminal operations
    terminate the stream. The sequence of elements is lazily evaluated and can also
    be performed in parallel. By default, performing a parallel stream uses the common
    **Fork/Join Framework** executor service. The fork-join model can be considered
    a parallel design pattern that was formulated in the early 1960s (*Reference 17*).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Although the platform allows you to program functional types, OOP concepts remain,
    followed by strong type requirements. This provides the Stream API with the security
    that the original element type remains or must be enforced correctly by an intermediate
    or terminal operation – otherwise, the platform will cause a compilation error.
    As a reminder, none of these functions would be possible without the introduction
    of generic types in Java SE 5\. Generics (*Reference 4*) allow us to parameterize
    a class or interface by a type flag to keep compilation safe (*Reference 2*).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate or terminal operations are implementations of anonymous functions
    or functional interfaces. They represent a small block of code, formally called
    a lambda. Let’s explain the concept of lambda a little more closely.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lambdas and functional interfaces
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lambda concept was introduced to enable element operations. Lambdas basically
    treat data as a code or function as a method. Lambdas rely on the concept of anonymous
    classes – that is, a class with only one method that performs an action. Java
    contains a collection of already implemented functional interfaces or ready-to-use
    functions. Classes are annotated with the `@FunctionalInterface` annotation, which
    is a tag available from Java SE 8\. It tells the platform that a particular interface
    contains only one abstract method that can be used to instantiate anonymous classes,
    as shown in *Table 2.7*. This also means that the interface may contain some default
    or static functions that belong to the class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Input** **argument** | **Return** **type** | **Abstract** **method**
    | **Description** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `Supplier<T>` | - | T | `get` | Returns a value of type <T> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| `Consumer<T>` | T | - | `accept` | Consumes a value of type <T> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| `Function<T, R>` | T | R | `apply` | Consumes a value of type <T> and applies
    a transformation with return type <R> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| `Predicate<T>` | T | Boolean | `test` | Consumes an input of type <T> and
    returns a Boolean result |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: Table 2.7 – Basic functional interfaces available in the JDK since Java SE 8
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Using functional interfaces in lambda expressions
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have discovered that each lambda expression is lazily loaded, which means
    the code is evaluated on demand, not at compile time, and may be closed by the
    terminal operation (*Example 2.12*):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 2.12 – Converting elements of the List interface to the stream and applying
    a terminal operation for each Consumer type instance
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'We can chain the different intermediate functions together (*Example 2.13*)
    and close the stream with a terminal operation or pass the stream to another method
    or object:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example 2.13 – Advanced composition of named and anonymous functional interfaces
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The lambda expression stream API plays an important role in the composition
    of the code. It can be imagined as a process line into which the input object
    enters and, thanks to a collection of adjustments, the expected result is returned
    or the action ends. Since the lambdas are evaluated lazily, this means that the
    process line has a switch. In other words, the Stream API can be considered one
    of the most important breakthroughs in syntax.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips with the Java Module System
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the main purposes of using a higher-order programming language such
    as Java is code reusability. A basic building block of the language is the concept
    of classes according to the principles of APIE. Java can localize these classes
    into groups defined by specific package names. The package concept encapsulates
    a group of classes. Classes can provide different levels of visibility to their
    internal fields and methods. Java specifies the following levels of visibility:
    `public`, default, `private`, and `protected`. Keywords are used to reduce visibility
    across different packages to manage their interactions. The way to share a package
    across an application domain is to keep it public – that is, visible to everyone.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Java has been using the concept of class paths for many years. The class path
    is a special place where the Class Loader loads its classes. The loaded classes
    are then used at runtime (denoted as the **Class Loaders Subsystem** in *Figure
    2**.2*).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: However, this concept does not provide any guarantee for the stored package
    or class. This concept has been considered bad, fragile, and error-prone for many
    years. A good example is trying to package a JAR executable that contains different
    versions of libraries with similar package structures and class names. The class
    path does not differ and the class can be overwritten by different versions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The breakthrough came with the release of Java SE 9\. JSR-376, formerly the
    core of the Jigsaw project (*Reference 3*), became a common part of the platform.
    JSR-376 implements the **Java Platform Module System** (**JPMS**) (*Example 2.14*):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 2.14 – Listing the available JDK modules for a specific version
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the platform has been migrated in accordance with the modules
    (*Example 2.15*):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example 2.15 – Describing a java.logging module. The java.base module is automatically
    present, as it contains the core platform and language functionalities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'The JMPS provides a strong package encapsulation concept that defines application
    interactions at the package level (*Example 2.16*). The application can be divided
    into modules that can only detect APIs or services. The JMPS supports package-level
    dependency building and increases the maintainability, reliability, and security
    of the application being developed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example 2.16 – Example of the module-info.class descriptor exposing a package
    for external usage
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The use of the JPMS is not mandatory. The Java platform uses the JMPS, but if
    the application is not ready, unnamed modules can be used. In this case, all packages
    or classes will belong to this kind of unnamed module. In principle, an unnamed
    module reads each readable module or class from the class path without reflecting
    any package-level restrictions required by the JPMS. In this way, compatibility
    with previously developed applications is achieved and the software designer has
    no doubts about the malfunction of the code base – that is, the JPMS is disabled.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Although the JPMS has incredible potential for application sustainability, security,
    and reusability, it is often not used because it creates indirect pressure to
    properly configure the underlying JPMS and use a design pattern that enforces
    SOLID principles.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: When using the JMPS, the platform ensures that the developed application does
    not contain any cyclic dependencies. Behind the scenes, the JPMS creates an acyclic
    module graph (not a class path case).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: By creating a module descriptor file, the platform provides a set of directives
    that can be used to expose certain parts of the module to the outside world.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple example of a module to remove any doubt about the use
    of the JPMS (*Example 2.17*). Our discussion so far can overcome the initial difficulties:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 2.17 – Folder structure of module example developed with OpenJDK 17
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an appropriate executable class, `ExampleMain.java`, and a module
    descriptor, `module-info.java` (*Example 2.18*). In this way, we tell the platform
    to use the JPMS:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 2.18 – Simple module example introduced by the file structure in Example
    2.17
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The example shows how the project could be separated into modules that contain
    their own descriptors, `module-info.java` files (*Example 2.17*). This descriptor
    defines an interaction with other modules through dependencies or exposures of
    module internals. The JPMS ensures that the restrictions, including visibility,
    are maintained:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Output:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example 2.19 – Steps to compile Example 2.17 with outputs, together with the
    module descriptor check (Example 2.18) after the compiled result
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The JPMS is a big change to the platform and although it opens a new horizon
    for software designers by providing the ability to define clarity in the package
    structure, it is not always well received or understood. This may be due to additional
    requirements that need to be taken into account when designing the system, which
    essentially relate to the knowledge of APIE or SOLID principles.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The JPMS together with the Stream API, as well as lambdas, may be considered
    significant changes addressed by the Java SE 11 release – Java SE 11 being the
    next **Long-Time Support** (**LST**) release after version 8\. Let us dive a bit
    further into some of the changes from Java SE 11 to the next LST version presented
    by release 17.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of Java features from 11 to 17+
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This version update presents performance and optimization improvements. In this
    section, we will examine those that are very useful for the specific use of a
    design pattern and its structure. This equates to platform enhancements that improve
    code readability, platform usage, or syntax enhancements.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The local variable syntax for lambda parameters (Java SE 11, JEP-323)
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java has often been criticized for the amount of standard code in the use of
    a variable; Java SE 10 introduced a new keyword, `var`. The derivation of a local
    type variable lies behind this keyword. It essentially requires that the value
    type is taken from the newly created reference instance (*Example 2.20*). Using
    the stream `boxed` function shows a decorator pattern that wraps the stream value
    with the desired type:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 2.20 – Use of local type inference in a lambda expression and stream
    shows the reduction of boilerplate code
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Although a lambda already allowed an implicit type definition, for example,
    the use of annotation was not possible.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Switch expressions (Java SE 14, JEP-361)
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software designers have long complained about several inconsistencies in the
    use of switch commands, such as a control flow problem. Although this enhancement
    is fully compatible with all controls, it introduces a new form of switch label,
    `case CONSTANT->`. The extension also allows more constants to be used, making
    the entire switch expression more compact. The last improvement is the ability
    of the switch expression to return its computed value (*Example 2.21*). This has
    a very positive impact on the implementation of the design pattern, because, for
    example, behavior types require a precise control flow (*Reference 8*):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example 2.21 – Compact switch expression usage with a return control flow with
    a simple text block
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Text blocks (Java SE 15, JEP-378)
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many times, you need to create multiple lines with a specific format. Previous
    use of multiple escape sequences and characters was not as practical, as it could
    be unpredictable. Text block extension introduces a literal that allows you to
    represent a string in a predictable way (see the `System.out.printf` method in
    *Example 2.21*, as well as *Reference 9*).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for instanceof (Java SE 16, JEP-394)
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, it was necessary to retype a value type that had already been verified
    as positive for its type. This increased the code base and sometimes had a negative
    effect on the stability of the code, even when designing a pattern. This platform
    extension eliminates the need for a rear cast and the variable can be used directly
    with the correct type (*Example 2.22*, *Reference 10*):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 2.22 – Using instanceof with direct type methods
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Records (Java SE 16, JEP-395)
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `record` class type is very useful because its declaration is very simple
    and can carry all the data needed for the program’s business logic. Records carry
    immutable data. They provide an already implemented `hashCode` and `equals`. This
    means that the designed software does not have to provide additional code (*Example
    2.23*, *Reference 11*):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 2.23 – New record class type may have a very positive impact on code
    reduction, as it provides generated methods
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes (Java SE 17, JEP-409)
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are very elegant enhancements to gain control over classes and interfaces,
    or class extensions and interface implementations (*Reference 12*). Closed classes
    give software designers wide access to the superclass without the need to extend
    it. They overcome the limitations of the widely used package access modifier,
    which previously required the full implementation of abstract methods. The example
    shows how to define an open class for an extension, the `non-sealed` keyword (*Example
    2.24*):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Example 2.24 – The implementation of the interface methods is provided by the
    abstract class, NormalEngine
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed classes force control over possible extensions (*Example 2.25*) because
    they provide software with potential security against unwanted software design
    changes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the compilation output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Example 2.25 – Sealed classes enforce control over the enhancements
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed classes also present some potential problems because the software designer
    must decide how the newly created classes will be used, indicating whether class
    extension is allowed, the keyword is unsealed (*Example 2.25*), or the final keyword
    (*Example 2.26*) is locked:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 2.26 – It’s required to decide the class behavior and the Bus class
    example is locked for any extension
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Although this may seem like a possible disadvantage, it provides greater clarity
    in software development in terms of maintainability and design patterns. This
    reduces potential unwanted interface or class errors.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 by default (Java SE 18, JEP-400)
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, unclear encoding has caused issues. Encoding problems were not
    easy to detect and appeared unpredictably on different system platforms. This
    enhancement has unified everything and forced UTF-8 as the default encoding (*Reference
    13*).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for switch (Java SE 18, Second Preview, JEP-420)
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Improvements to `instanceof` fields (JEP-394) and switch case expressions (JEP-361)
    have made it even better to compress the code base and remove previously unnecessary
    if-else constructs by using `instanceof` on a very compact, command-oriented controlled
    command statement: type-served (E*xample 2.27*, *Reference 14*):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Example 2.27 – Compact switch statement with an implicit type match
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing the most important syntactic improvements, we can safely start
    to delve deeper into one of the main advantages of the platform. Yes, it is the
    concurrency framework.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Java concurrency
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, it was shown that even running a simple program
    (*Example 2.2* and *Figure 2**.3*) will cause multiple concretizations of threads
    (*Figure 2**.4*). This means that a program thread created by executing the `main`
    method did not create any other thread that belonged to that program. The Java
    platform is well-known and valuable for its ability to perform concurrent or parallel
    tasks.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: We found out how and where initiated threads store their variables and why synchronizing
    objects located in the heap can lead to unwanted or unexpected program behavior.
    In this section, we will look at the possibilities of the main threads using the
    available CPUs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The motivation for software designers to consider using any concurrent design
    patterns may be the growing need for better application responsiveness or throughput.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Although the platform already includes the `Thread` class and the `java.lang`
    package, Java concurrency features such as `java.util.concurrent` package, which
    is part of the `java.base` module.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Let us look a bit closer.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: From a basic thread to executors
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic build element of the platform is the thread. A thread is represented
    by an instance of the `Thread` class. The object initiated by the `new` keyword
    still does not create a platform thread. The object provides a method named `start`
    that requires explicit use (*Example 2.28*):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 2.28 – A simple program with a daemon thread that ends immediately after
    the JVM stops
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Although it may appear that the platform can create an unrestricted `Thread`
    instance, this kind of statement is not valid. Each newly created thread instance
    not only takes up heap space or allocates a stack but is also connected to basic
    system threads (processing cycles) through Java runtime partitions (*Figure 2**.2*).
    This means that uncontrolled thread startup can cause a system error exception
    due to unavailable resources, insufficient memory, and so on.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of system threads created by the Java platform may vary,
    as it depends on the hardware as well as the JVM configuration. The Java `Thread`
    class might consider a wrapper for the `Runnable` interface, and the thread accepts
    its implementation. The `Runnable` interface is another functional interface and
    requires the implementation of a run method. Starting with the Java SE 8 `Runnable`
    interface, the instance can be passed to the executor service as an anonymous
    function.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform allows you to run a thread that can even survive the termination
    of the main program, which in many cases, is a reluctant condition and should
    be considered wisely, as it may block other core resources or stay running.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the JVM only terminates when all running threads
    are daemon ones (*Example 2.28*).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Because each thread newly created by the main program is non-daemon, by default,
    when the sample program is run without an explicit daemon flag, the JVM remains
    an active process until the base system destroys it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to manage uncontrolled thread creation and gives the software
    designer control over the program’s resources and behavior. Java SE 5 introduced
    the `ExecutorService` and `ThreadFactory` interfaces, where multiple implementations
    show using a similarly named creational design pattern factory. The `ThreadFactory`
    interface contains only one `newThread` method, which returns a `Thread` instance.
    This method logic can accommodate the creation of a new thread and set the group,
    thread priority, and daemon flag. It also eliminates the number of new thread
    calls. `ThreadFactory` can be serviced by `ExecutorService` (*Example 2.30*).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most used executor static method names are as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '`newSingleThreadExecutor()`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newSingleThreadExecutor(ThreadFactory threadFactory)`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newCachedThreadPool()`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newCachedThreadPool(ThreadFactory threadFactory)`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE 5 came up with a concept for the future, a `Future` interface with a
    generic type of `<T>`. The `Future` interface can be considered an asynchronous
    calculation that provides a result.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform provides two different interfaces that can carry thread logic.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Executing tasks
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java platform provides a thread concept from the beginning represented
    by the `Runnable` interface and the `Thread` class (*Example 2.29*):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Example 2.29 – Different approaches to providing the Runnable interface implementation
    to the executor service, implementation, and anonymous class
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Business requirements, along with community expectations, have created a platform
    for reactive programming or the ability to perform multiple asynchronous payback
    tasks. As of Java SE 5, the platform provides a `Callable` interface. The `Callable`
    interface is considered a functional interface. It contains only one abstract
    method call with a required return type of `<T>`. Because the computation is uncertain,
    it can cause an exception that must be handled correctly. The `Callable` implementation
    can be sent to the executor and the started calculation is packed into a future
    result.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Future` instance is the computational work that the base system performs
    in the background. The interface provides a `get` method (*Example 2.30*) that
    can be used to retrieve the result. Using this method pauses the current thread
    and waits until a result is available. Due to the current thread suspension, this
    method should be used wisely, as it can cause performance penalties:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Example 2.30 – Different approaches to provide a Callable instance to the executor
    service as a realization or an anonymous class
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: This contrasts with the `Runnable` interface because the `Callable` interface
    provides a `Future` instance as a temporary result. The `Callable` exception handling
    request is also relevant because it can cause logic to be executed or the worker
    thread can be interrupted. In this case, it is necessary to transfer this to the
    interim result represented by the `Future` interface.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have built a good knowledge base for understanding the
    internal Java platform. We learned about the differences between statically allocated
    arrays or methods compared to object instances. We examined the need for proper
    data synchronization and how Java memory management works and what guarantees
    the platform provides. We now understand the importance of heap memory, segmentation,
    and maintenance. We have also already discovered a few frequently used design
    patterns, which means that when we start implementing any design pattern or collection,
    we will be aware of the following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: How fields or variables are handled by the platform
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of memory management
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific program error exit states and the reasons for them
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core APIs provided by the Java platform
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize functional programming features
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What new enhancements the Java platform provides to make employing design patterns
    easier
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to approach Java concurrency challenges
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have built a solid knowledge base over the first two chapters. We will now
    begin to present pattern by pattern. The next chapter will take us on a journey
    through creational design patterns. Creational design patterns intensify our awareness
    of the code structure and how to create sustainable solutions. Let us roll.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which elements make up the Java platform?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does statically typed language mean?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the Java language literals?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is responsible for memory reclamation in the Java memory management concept?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the collections in the Java collections framework?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of elements store `Map`?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the time complexity of retrieving an element from `Set`?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the time complexity of verifying an element’s existence in `ArrayList`?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functional interface is used in the `filter` method of the Stream API?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are elements evaluated in the Stream API?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Garbage Collection Handbook: The Art of Automatic Memory Management*,
    Anthony Hosking, Eliot B. Moss, and Richard Jones, CRC Press, ISBN-13: 978-1420082791,
    ISBN-10: 9781420082791, 1996'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Generics: [https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JPMS (JSR 376): [https://openjdk.java.net/projects/jigsaw/spec/](https://openjdk.java.net/projects/jigsaw/spec/)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Java tutorials: [https://docs.oracle.com/javase/tutorial/java](https://docs.oracle.com/javase/tutorial/java)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java GC basics: [https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JVM specification, Java SE 17 Edition: [https://docs.oracle.com/javase/specs/jvms/se17/html/index.html](https://docs.oracle.com/javase/specs/jvms/se17/html/index.html)'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenJDK, HotSpot runtime overview: [https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html](https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JEP 361: Switch Expression: [https://openjdk.java.net/jeps/361](https://openjdk.java.net/jeps/361)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JEP 378: Text Blocks: [https://openjdk.java.net/jeps/378](https://openjdk.java.net/jeps/378)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JEP 394: Pattern matching for `instanceof`: [https://openjdk.java.net/jeps/394](https://openjdk.java.net/jeps/394)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 395:* *Records*: [https://openjdk.java.net/jeps/395](https://openjdk.java.net/jeps/395)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 409: Sealed* *Classes*: [https://openjdk.java.net/jeps/409](https://openjdk.java.net/jeps/409)'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 400: UTF-8 by* *Default*: [https://openjdk.java.net/jeps/400](https://openjdk.java.net/jeps/400)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 420: Pattern Matching for switch (Second* *Preview)*: [https://openjdk.java.net/jeps/420](https://openjdk.java.net/jeps/420)'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `java.util.stream` package: [https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 300: Launch Single-File Source-Code* *Programs*: [https://openjdk.java.net/jeps/330](https://openjdk.java.net/jeps/330)'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A multiprocessor system design*. Fall Join Computer Conference, Melvin E.
    Conway (1963). pp. 139 -146.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Implementing Standard Design Patterns Using Java Programming'
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Design patterns are often classified into three well-known categories: creational,
    behavioral, and structural. This part will explore and demonstrate design patterns
    from each of these categories. It will show the types of challenges addressed
    by each design pattern with practical real-world examples.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18884_03.xhtml#_idTextAnchor093), *Working with Creational Design
    Patterns*'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18884_04.xhtml#_idTextAnchor172), *Applying Structural Design
    Patterns*'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18884_05.xhtml#_idTextAnchor255), *Behavioral Design Patterns*'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
