<html><head></head><body>
		<div id="_idContainer084">
			<h1 id="_idParaDest-231"><em class="italic"><a id="_idTextAnchor230"/>Chapter 10</em>: Managing Data in a Database</h1>
			<p>This chapter explains and demonstrates how to manage – that is, insert, read, update, and delete – data in a database using a Java application. It also provides a short introduction to <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) and basic database operations, including how to connect to a database, how to create a database structure, how to write a database expression using SQL, and how to execute these expressions.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Creating a database</li>
				<li>Creating a database structure</li>
				<li>Connecting to a database</li>
				<li>Releasing the connection</li>
				<li><strong class="bold">Create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations on data</li>
				<li>Using a shared library JAR file to access a database</li>
			</ul>
			<p>By the end of the chapter, you will be able to create and use a database for storing, updating, and retrieving data as well as create and use a shared library.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with either a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or code editor you prefer</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">,</em> <em class="italic">Getting Started with Java 17</em>. The files with the code examples for this chapter are available on GitHub (<a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a>) in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch10_database</strong> folder, and in the <strong class="source-inline">database</strong> folder, as a separate project of the shared library. </p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/>Creating a database</h1>
			<p><strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) is a Java functionality that allows you to access and modify <a id="_idIndexMarker1140"/>data in a database. It is supported by the JDBC API (which includes the <strong class="source-inline">java.sql</strong>, <strong class="source-inline">javax.sql</strong>, and <strong class="source-inline">java.transaction.xa</strong> packages) and the database-specific class that implements an interface <a id="_idIndexMarker1141"/>for database access (called a <strong class="bold">database driver</strong>), which is provided by each database vendor.</p>
			<p>Using JDBC means <a id="_idIndexMarker1142"/>writing Java code that manages data in a database using the interfaces and classes of the JDBC API and a database-specific driver, which knows how to establish a connection with the particular database. Using this connection, an application can then issue requests written in SQL.</p>
			<p>Naturally, we are <a id="_idIndexMarker1143"/>only referring to the databases that understand SQL here. They are called relational or tabular <strong class="bold">database management systems</strong> (<strong class="bold">DBMSs</strong>) and make up the vast majority of the currently used DBMSs – although some alternatives (for example, a navigational database and NoSQL) are used too.</p>
			<p>The <strong class="source-inline">java.sql</strong> and <strong class="source-inline">javax.sql</strong> packages <a id="_idIndexMarker1144"/>are included in the <strong class="bold">Java Platform Standard Edition</strong> (<strong class="bold">Java SE</strong>). The <strong class="source-inline">javax.sql</strong> package contains the <strong class="source-inline">DataSource</strong> interface that supports the statement’s pooling, distributed transactions, and rowsets. </p>
			<p>Creating a database involves the following eight steps:</p>
			<ol>
				<li>Install the database by following the vendor instructions.</li>
				<li>Open the PL/SQL terminal and create a database user, a database, a schema, tables, views, stored procedures, and anything else that is necessary to support the data model of the application.</li>
				<li>Add to this application the dependency on a <strong class="source-inline">.jar</strong> file with the database-specific driver.</li>
				<li>Connect to the database from the application.</li>
				<li>Construct the SQL statement.</li>
				<li>Execute the SQL statement.</li>
				<li>Use the result of the execution as your application requires.</li>
				<li>Release (that is, close) the database connection and any other resources that were opened in the process.</li>
			</ol>
			<p><em class="italic">Steps 1</em> to <em class="italic">3</em> are performed <a id="_idIndexMarker1145"/>only once during the database setup and before the application is run. <em class="italic">Steps 4</em> to <em class="italic">8</em> are performed by the application repeatedly as needed. In fact, <em class="italic">Steps 5</em> to <em class="italic">7</em> can be repeated multiple times with the same database connection.</p>
			<p>For our example, we are going to use the PostgreSQL database. You will first need to perform <em class="italic">Steps 1</em> to <em class="italic">3</em> by yourself using the database-specific instructions. To create the database for our demonstration, we use the following PL/SQL commands:</p>
			<p class="source-code">create user student SUPERUSER;</p>
			<p class="source-code">create database learnjava owner student;</p>
			<p>These commands create a <strong class="source-inline">student</strong> user that can manage all aspects of the <strong class="source-inline">SUPERUSER</strong> database, and make the <strong class="source-inline">student</strong> user an owner of the <strong class="source-inline">learnjava</strong> database. We will use the <strong class="source-inline">student</strong> user to access and manage data from the Java code. In practice, for security considerations, an application is not allowed to create or change database tables and other aspects of the database structure.</p>
			<p>Additionally, it is a good practice to create another logical layer, called a <strong class="bold">schema</strong>, which can have its own set of users and permissions. This way, several schemas in the same database can be isolated, and each user (one of them is your application) can only access certain schemas. On an enterprise level, the common practice is to create synonyms for the database schema so that no application can access the original structure directly. However, we do not do this in this book for the sake of simplicity.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/>Creating a database structure</h1>
			<p>After the database is created, the following three SQL statements will allow you to create and <a id="_idIndexMarker1146"/>change the database structure. This is done through database entities, such as a table, function, or constraint:</p>
			<ul>
				<li>The <strong class="source-inline">CREATE</strong> statement <a id="_idIndexMarker1147"/>creates the database <a id="_idIndexMarker1148"/>entity.</li>
				<li>The <strong class="source-inline">ALTER</strong> statement <a id="_idIndexMarker1149"/>changes the database <a id="_idIndexMarker1150"/>entity.</li>
				<li>The <strong class="source-inline">DROP</strong> statement <a id="_idIndexMarker1151"/>deletes the database <a id="_idIndexMarker1152"/>entity.</li>
			</ul>
			<p>There are also various SQL statements that allow you to inquire about each database entity. Such statements are database-specific and, typically, they are only used in a database console. For example, in the PostgreSQL console, <strong class="source-inline">\d &lt;table&gt;</strong> can be used to describe a table, while <strong class="source-inline">\dt</strong> lists all the tables. Refer to your database documentation for more details. </p>
			<p>To create a table, you can execute the following SQL statement:</p>
			<pre class="source-code">CREATE TABLE tablename ( column1 type1, column2 type2, ... ); </pre>
			<p>The limitations for a table name, column names, and types of values that can be used depend on the particular database. Here is an example of a command that creates the <strong class="source-inline">person</strong> table in PostgreSQL:</p>
			<pre class="source-code">CREATE table person ( </pre>
			<pre class="source-code">   id SERIAL PRIMARY KEY, </pre>
			<pre class="source-code">   first_name VARCHAR NOT NULL, </pre>
			<pre class="source-code">   last_name VARCHAR NOT NULL, </pre>
			<pre class="source-code">   dob DATE NOT NULL );</pre>
			<p>The <strong class="source-inline">SERIAL</strong> keyword indicates <a id="_idIndexMarker1153"/>that this field is a sequential integer number that is generated by the database every time a new record is created. Additional options for generating sequential integers are <strong class="source-inline">SMALLSERIAL</strong> and <strong class="source-inline">BIGSERIAL</strong>; they differ by size and the range of possible values:</p>
			<pre class="source-code">SMALLSERIAL: 2 bytes, range from 1 to 32,767</pre>
			<pre class="source-code">SERIAL: 4 bytes, range from 1 to 2,147,483,647</pre>
			<pre class="source-code">BIGSERIAL: 8 bytes, range from 1 to 922,337,2036,854,775,807</pre>
			<p>The <strong class="source-inline">PRIMARY_KEY</strong> keyword <a id="_idIndexMarker1154"/>indicates that this is going to be the unique identifier of the record and will most probably be used in a search. The database creates an index for each primary key to make the search process faster. An index is a data structure that helps to accelerate data search in the table without having to check every table record. An index can include one or more columns of a table. If you request the description of the table, you will see all the existing indices.</p>
			<p>Alternatively, we can make a composite <strong class="source-inline">PRIMARY KEY</strong> keyword using a combination of <strong class="source-inline">first_name</strong>, <strong class="source-inline">last_name</strong>, and <strong class="source-inline">dob</strong>:</p>
			<pre class="source-code">CREATE table person ( </pre>
			<pre class="source-code">   first_name VARCHAR NOT NULL, </pre>
			<pre class="source-code">   last_name VARCHAR NOT NULL, </pre>
			<pre class="source-code">   dob DATE NOT NULL,</pre>
			<pre class="source-code">   PRIMARY KEY (first_name, last_name, dob) ); </pre>
			<p>However, there is a <a id="_idIndexMarker1155"/>chance that there are two people who will have the same name and were born on the same day, so such a composite prim is not a good idea.</p>
			<p>The <strong class="source-inline">NOT NULL</strong> keyword imposes <a id="_idIndexMarker1156"/>a constraint on the field: it cannot be empty. The database will raise an error for every attempt to create a new record with an empty field or delete the value from the existing record. We did not set the size of the columns of type <strong class="source-inline">VARCHAR</strong>, thus allowing these columns to store string values of any length.</p>
			<p>The Java object that matches such a record may be represented by the following <strong class="source-inline">Person</strong> class:</p>
			<pre class="source-code">public class Person {</pre>
			<pre class="source-code">  private int id;</pre>
			<pre class="source-code">  private LocalDate dob;</pre>
			<pre class="source-code">  private String firstName, lastName;</pre>
			<pre class="source-code">  public Person(String firstName, String lastName, </pre>
			<pre class="source-code">                                                LocalDate dob){</pre>
			<pre class="source-code">    if (dob == null) {</pre>
			<pre class="source-code">      throw new RuntimeException</pre>
			<pre class="source-code">                              ("Date of birth cannot be null");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    this.dob = dob;</pre>
			<pre class="source-code">    this.firstName = firstName == null ? "" : firstName;</pre>
			<pre class="source-code">    this.lastName = lastName == null ? "" : lastName;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public Person(int id, String firstName,</pre>
			<pre class="source-code">                  String lastName, LocalDate dob) {</pre>
			<pre class="source-code">    this(firstName, lastName, dob);</pre>
			<pre class="source-code">    this.id = id;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public int getId() { return id; }</pre>
			<pre class="source-code">  public LocalDate getDob() { return dob; }</pre>
			<pre class="source-code">  public String getFirstName() { return firstName;}</pre>
			<pre class="source-code">  public String getLastName() { return lastName; }</pre>
			<pre class="source-code">}</pre>
			<p>As you may <a id="_idIndexMarker1157"/>have noticed, there are two constructors in the <strong class="source-inline">Person</strong> class: with and without <strong class="source-inline">id</strong>. We will use the constructor that accepts <strong class="source-inline">id</strong> to construct an object based on the existing record, while the other constructor will be used to create an object before inserting a new record.</p>
			<p>Once created, the table can be deleted using the <strong class="source-inline">DROP</strong> command:</p>
			<p class="source-code">DROP table person;</p>
			<p>The existing table can also be changed using the <strong class="source-inline">ALTER</strong> SQL command; for example, we can add a column address:</p>
			<p class="source-code">ALTER table person add column address VARCHAR;</p>
			<p>If you are not sure whether such a column exists already, you can add <strong class="source-inline">IF EXISTS</strong> or <strong class="source-inline">IF NOT EXISTS</strong>:</p>
			<pre class="source-code">ALTER table person add column IF NOT EXISTS address VARCHAR;</pre>
			<p>However, this possibility exists only with PostgreSQL 9.6 and later versions.</p>
			<p>Another important <a id="_idIndexMarker1158"/>consideration to take note of during database table creation is whether another index (in addition to <strong class="source-inline">PRIMARY KEY</strong>) has to be added. For example, we can allow a case-insensitive search of first and last names by adding the following index:</p>
			<pre class="source-code">CREATE index idx_names on person ((lower(first_name), lower(last_name));</pre>
			<p>If the search speed improves, we leave the index in place; if not, it can be removed, as follows:</p>
			<pre class="source-code"> DROP index idx_names;</pre>
			<p>We remove it because an index has an overhead of additional writes and storage space.</p>
			<p>We also can remove a column from a table if we need to, as follows:</p>
			<pre class="source-code">ALTER table person DROP column address;</pre>
			<p>In our examples, we follow the naming convention of PostgreSQL. If you use a different database, we suggest that you look up its naming convention and follow it, so that the names you create align with those that are created automatically.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor234"/>Connecting to a database</h1>
			<p>So far, we have used a console to execute SQL statements. The same statements can be executed from <a id="_idIndexMarker1159"/>Java code using the JDBC API too. But, tables are created only once, so there is not much sense in writing a program for a one-time execution.</p>
			<p>Data management, however, is another matter. So, from now on, we will use Java code to manipulate data in a database. In order to do this, we first need to add the following dependency to the <strong class="source-inline">pom.xml</strong> file in the <strong class="source-inline">database</strong> project:</p>
			<pre class="source-code">&lt;dependency&gt; </pre>
			<pre class="source-code">    &lt;groupId&gt;org.postgresql&lt;/groupId&gt; </pre>
			<pre class="source-code">    &lt;artifactId&gt;postgresql&lt;/artifactId&gt; </pre>
			<pre class="source-code">    &lt;version&gt;42.3.2&lt;/version&gt; </pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>The <strong class="source-inline">example</strong> project also gets access to this dependency because, in the <strong class="source-inline">pom.xml</strong> file of the <strong class="source-inline">example</strong> project, we have the following dependency on the database <strong class="source-inline">.jar</strong> file:</p>
			<pre class="source-code">&lt;dependency&gt; </pre>
			<pre class="source-code">    &lt;groupId&gt;com.packt.learnjava&lt;/groupId&gt;</pre>
			<pre class="source-code">    &lt;artifactId&gt;database&lt;/artifactId&gt;</pre>
			<pre class="source-code">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; </pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>Make sure <a id="_idIndexMarker1160"/>to install the <strong class="source-inline">database</strong> project by executing the <strong class="source-inline">"mvn clean install"</strong> command in the <strong class="source-inline">database</strong> folder before running any of the examples.</p>
			<p>Now, we can create a database connection from the Java code, as follows:</p>
			<pre class="source-code">String URL = "jdbc:postgresql://localhost/learnjava";</pre>
			<pre class="source-code">Properties prop = new Properties();</pre>
			<pre class="source-code">prop.put( "user", "student" );</pre>
			<pre class="source-code">// prop.put( "password", "secretPass123" );</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code"> Connection conn = DriverManager.getConnection(URL, prop);</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The preceding code is just an example of how to create a connection using the <strong class="source-inline">java.sql.DriverManger</strong> class. The <strong class="source-inline">prop.put( "password", "secretPass123" )</strong> statement demonstrates how to provide a password for the connection using the <strong class="source-inline">java.util.Properties</strong> class. However, we did not set a password when we created the <strong class="source-inline">student</strong> user, so we do not need it. </p>
			<p>Many other values can be passed to <strong class="source-inline">DriverManager</strong> that configure the connection behavior. The name of the keys for the passed-in properties are the same for all major databases, but some <a id="_idIndexMarker1161"/>of them are database-specific. So, read your database vendor documentation for more details.</p>
			<p>Alternatively, for passing <strong class="source-inline">user</strong> and <strong class="source-inline">password</strong> only, we could use an overloaded <strong class="source-inline">DriverManager.getConnection(String url, String user, String password)</strong> version. It is a good practice to keep the password encrypted. We are not going to demonstrate how to do it, but there are plenty of guides available on the internet that you can refer to.</p>
			<p>Another way of connecting to a database is to use the <strong class="source-inline">javax.sql.DataSource</strong> interface. Its implementation is included in the same <strong class="source-inline">.jar</strong> file as the database driver. In the case of <strong class="source-inline">PostgreSQL</strong>, there are two classes that implement the <strong class="source-inline">DataSource</strong> interface:</p>
			<ul>
				<li><strong class="source-inline">org.postgresql.ds.PGSimpleDataSource</strong></li>
				<li><strong class="source-inline">org.postgresql.ds.PGConnectionPoolDataSource</strong></li>
			</ul>
			<p>We can use these classes instead of <strong class="source-inline">DriverManager</strong>. The following code is an example of creating a database connection using the <strong class="source-inline">PGSimpleDataSource</strong> class:</p>
			<pre class="source-code">PGSimpleDataSource source = new PGSimpleDataSource();</pre>
			<pre class="source-code">source.setServerName("localhost");</pre>
			<pre class="source-code">source.setDatabaseName("learnjava");</pre>
			<pre class="source-code">source.setUser("student");</pre>
			<pre class="source-code">//source.setPassword("password");</pre>
			<pre class="source-code">source.setLoginTimeout(10);</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    Connection conn = source.getConnection();</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>Using the <strong class="source-inline">PGConnectionPoolDataSource</strong> class allows you to create a pool of <strong class="source-inline">Connection</strong> objects in <a id="_idIndexMarker1162"/>memory, as follows:</p>
			<pre class="source-code">PGConnectionPoolDataSource source = new PGConnectionPoolDataSource();</pre>
			<pre class="source-code">source.setServerName("localhost");</pre>
			<pre class="source-code">source.setDatabaseName("learnjava");</pre>
			<pre class="source-code">source.setUser("student");</pre>
			<pre class="source-code">//source.setPassword("password");</pre>
			<pre class="source-code">source.setLoginTimeout(10);</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    PooledConnection conn = source.getPooledConnection();</pre>
			<pre class="source-code">    Set&lt;Connection&gt; pool = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">    for(int i = 0; i &lt; 10; i++){</pre>
			<pre class="source-code">        pool.add(conn.getConnection())</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>This is a preferred method because creating a <strong class="source-inline">Connection</strong> object takes time. Pooling allows you to do it upfront and then reuse the created objects when they are needed. After the connection is no longer required, it can be returned to the pool and reused. The pool size and other parameters can be set in a configuration file (such as <strong class="source-inline">postgresql.conf</strong> for PostgreSQL).</p>
			<p>However, you do not <a id="_idIndexMarker1163"/>need to manage the connection pool yourself. There <a id="_idIndexMarker1164"/>are several mature frameworks that can do it for you, such as HikariCP (<a href="https://github.com/brettwooldridge/HikariCP">https://github.com/brettwooldridge/HikariCP</a>), Vibur (<a href="http://www.vibur.org">http://www.vibur.org</a>), and Commons DBCP (<a href="https://commons.apache.org/proper/commons-dbcp">https://commons.apache.org/proper/commons-dbcp</a>) – these <a id="_idIndexMarker1165"/>are reliable and easy to use.</p>
			<p>Whatever method of creating a database connection we choose, we are going to hide it inside the <strong class="source-inline">getConnection()</strong> method and use it in all our code examples in the same way. With the object of the <strong class="source-inline">Connection</strong> class acquired, we can now access the database to add, read, delete, or modify the stored data.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor235"/>Releasing the connection</h1>
			<p>Keeping the database connection alive requires a significant number of resources, such as memory and CPU, so it is <a id="_idIndexMarker1166"/>a good idea to close the connection and release the allocated resources as soon as you no longer need them. In the case of pooling, the <strong class="source-inline">Connection</strong> object, when closed, is returned to the pool and consumes fewer resources.</p>
			<p>Before Java 7, a connection was closed by invoking the <strong class="source-inline">close()</strong> method in a <strong class="source-inline">finally</strong> block:</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    Connection conn = getConnection();</pre>
			<pre class="source-code">    //use object conn here</pre>
			<pre class="source-code">} finally { </pre>
			<pre class="source-code">    if(conn != null){</pre>
			<pre class="source-code">        try {</pre>
			<pre class="source-code">            conn.close();</pre>
			<pre class="source-code">        } catch (SQLException e) {</pre>
			<pre class="source-code">            e.printStackTrace();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    } </pre>
			<pre class="source-code">}</pre>
			<p>The code inside the <strong class="source-inline">finally</strong> block is always executed, whether the exception inside the <strong class="source-inline">try</strong> block is thrown or not. However, since Java 7, the <strong class="source-inline">try-with-resources</strong> construct also <a id="_idIndexMarker1167"/>does the job on any object that implements the <strong class="source-inline">java.lang.AutoCloseable</strong> or <strong class="source-inline">java.io.Closeable</strong> interface. Since the <strong class="source-inline">java.sql.Connection</strong> object does implement the <strong class="source-inline">AutoCloseable</strong> interface, we can rewrite the previous code snippet, as follows:</p>
			<pre class="source-code">try (Connection conn = getConnection()) {</pre>
			<pre class="source-code">    //use object conn here</pre>
			<pre class="source-code">} catch(SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}    </pre>
			<p>The <strong class="source-inline">catch</strong> clause is necessary because the <strong class="source-inline">AutoCloseable</strong> resource throws <strong class="source-inline">java.sql.SQLException</strong>.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor236"/>CRUD data</h1>
			<p>There are four <a id="_idIndexMarker1168"/>kinds of SQL statements that read or manipulate data in a database:</p>
			<ul>
				<li>The <strong class="source-inline">INSERT</strong> statement adds data to a database.</li>
				<li>The <strong class="source-inline">SELECT</strong> statement reads data from a database.</li>
				<li>The <strong class="source-inline">UPDATE</strong> statement changes data in a database.</li>
				<li>The <strong class="source-inline">DELETE</strong> statement deletes data from a database.</li>
			</ul>
			<p>Either one or several different clauses can be added to the preceding statements to identify the data that is requested (such as the <strong class="source-inline">WHERE</strong> clause) and the order in which the results have to be returned (such as the <strong class="source-inline">ORDER</strong> clause).</p>
			<p>The JDBC connection is represented by <strong class="source-inline">java.sql.Connection</strong>. This, among others, has the methods <a id="_idIndexMarker1169"/>required to create three types of objects that allow you to execute SQL statements that provide different functionality to the database side:</p>
			<ul>
				<li><strong class="source-inline">java.sql.Statement</strong>: This simply sends the statement to the database server for execution.</li>
				<li><strong class="source-inline">java.sql.PreparedStatement</strong>: This caches the statement with a certain execution path on the database server by allowing it to be executed multiple times with different parameters in an efficient manner.</li>
				<li><strong class="source-inline">java.sql.CallableStatement</strong>: This executes the stored procedure in the database.</li>
			</ul>
			<p>In this section, we are going to review how to do it in Java code. The best practice is to test the SQL statement in the database console before using it programmatically.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/>The INSERT statement</h2>
			<p>The <strong class="source-inline">INSERT</strong> statement <a id="_idIndexMarker1170"/>creates (populates) data in the database and <a id="_idIndexMarker1171"/>has the following format:</p>
			<pre class="source-code">INSERT into table_name (column1, column2, column3,...) </pre>
			<pre class="source-code">                values (value1, value2, value3,...); </pre>
			<p>Alternatively, when several records need to be added, you can use the following format:</p>
			<pre class="source-code">INSERT into table_name (column1, column2, column3,...) </pre>
			<pre class="source-code">                values (value1, value2, value3,... ), </pre>
			<pre class="source-code">                       (value21, value22, value23,...),</pre>
			<pre class="source-code">                       ...; </pre>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor238"/>The SELECT statement</h2>
			<p>The <strong class="source-inline">SELECT</strong> statement <a id="_idIndexMarker1172"/>has the following <a id="_idIndexMarker1173"/>format:</p>
			<pre class="source-code">SELECT column_name, column_name FROM table_name </pre>
			<pre class="source-code">                        WHERE some_column = some_value;</pre>
			<p>Alternatively, when all the columns need to be selected, you can use the following format:</p>
			<pre class="source-code">SELECT * from table_name WHERE some_column=some_value; </pre>
			<p>A more general definition of the <strong class="source-inline">WHERE</strong> clause is as follows:</p>
			<pre class="source-code">WHERE column_name operator value </pre>
			<pre class="source-code">Operator: </pre>
			<pre class="source-code">= Equal </pre>
			<pre class="source-code">&lt;&gt; Not equal. In some versions of SQL, != </pre>
			<pre class="source-code">&gt; Greater than </pre>
			<pre class="source-code">&lt; Less than </pre>
			<pre class="source-code">&gt;= Greater than or equal </pre>
			<pre class="source-code">&lt;= Less than or equal IN Specifies multiple possible values for a column </pre>
			<pre class="source-code">LIKE Specifies the search pattern </pre>
			<pre class="source-code">BETWEEN Specifies the inclusive range of values in a column </pre>
			<p>The construct’s <strong class="source-inline">column_name</strong> operator value can be combined using the <strong class="source-inline">AND</strong> and <strong class="source-inline">OR</strong> logical operators, and grouped by brackets, <strong class="source-inline">( )</strong>.</p>
			<p>For example, the following method brings all the first name values (separated by a whitespace character) from the <strong class="source-inline">person</strong> table:</p>
			<pre class="source-code">String selectAllFirstNames() {</pre>
			<pre class="source-code">    String result = "";</pre>
			<pre class="source-code">    Connection conn = getConnection();</pre>
			<pre class="source-code">    try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">      ResultSet rs = </pre>
			<pre class="source-code">        st.executeQuery("select first_name from person");</pre>
			<pre class="source-code">      while (rs.next()) {</pre>
			<pre class="source-code">          result += rs.getString(1) + " ";</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">    } catch (SQLException ex) {</pre>
			<pre class="source-code">        ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return result;</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">getString(int position)</strong> method of the <strong class="source-inline">ResultSet</strong> interface extracts the <strong class="source-inline">String</strong> value from position <strong class="source-inline">1</strong> (the first in the list of columns in the <strong class="source-inline">SELECT</strong> statement). There are similar getters for all primitive types: <strong class="source-inline">getInt(int position)</strong>, <strong class="source-inline">getByte(int position)</strong>, and more.</p>
			<p>It is also <a id="_idIndexMarker1174"/>possible to extract the value from the <strong class="source-inline">ResultSet</strong> object using the column name. In our case, it will be <strong class="source-inline">getString("first_name")</strong>. This method of getting values is especially useful when the <strong class="source-inline">SELECT</strong> statement is as follows:</p>
			<pre class="source-code">select * from person;</pre>
			<p>However, bear in <a id="_idIndexMarker1175"/>mind that extracting values from the <strong class="source-inline">ResultSet</strong> object using the column name is less efficient. The difference in performance, though, is very small and only becomes important when the operation takes place many times. Only the actual measuring and testing processes can tell whether the difference is significant to your application or not. Extracting values by column name is especially attractive because it provides better code readability, which pays off in the long run during application maintenance.</p>
			<p>There are many other useful methods in the <strong class="source-inline">ResultSet</strong> interface. If your application reads data from a database, we highly recommend that you read the official documentation (<a href="http://www.postgresql.org/docs">www.postgresql.org/docs</a>) of the <strong class="source-inline">SELECT</strong> statement and the <strong class="source-inline">ResultSet</strong> interface for the database version you are using.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor239"/>The UPDATE statement</h2>
			<p>The data <a id="_idIndexMarker1176"/>can be changed by the <strong class="source-inline">UPDATE</strong> statement, as follows:</p>
			<pre class="source-code">UPDATE table_name SET column1=value1,column2=value2,... WHERE clause;</pre>
			<p>We can <a id="_idIndexMarker1177"/>use this statement to change the first name in one of the records from the original value, <strong class="source-inline">John</strong>, to a new value, <strong class="source-inline">Jim</strong>:</p>
			<pre class="source-code">update person set first_name = 'Jim' where last_name = 'Adams';</pre>
			<p>Without the <strong class="source-inline">WHERE</strong> clause, all the records of the table will be affected.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor240"/>The DELETE statement</h2>
			<p>To remove records from <a id="_idIndexMarker1178"/>a table, use the <strong class="source-inline">DELETE</strong> statement, as follows:</p>
			<pre class="source-code">DELETE FROM table_name WHERE clause;</pre>
			<p>Without <a id="_idIndexMarker1179"/>the <strong class="source-inline">WHERE</strong> clause, all the records of the table are deleted. In the case of the <strong class="source-inline">person</strong> table, we can delete all the records using the following SQL statement:</p>
			<pre class="source-code">delete from person;</pre>
			<p>Additionally, this statement only deletes the records that have a first name of <strong class="source-inline">Jim</strong>:</p>
			<pre class="source-code">delete from person where first_name = 'Jim';</pre>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor241"/>Using statements</h2>
			<p>The <strong class="source-inline">java.sql.Statement</strong> interface offers <a id="_idIndexMarker1180"/>the following methods for executing SQL statements:</p>
			<ul>
				<li><strong class="source-inline">boolean execute(String sql)</strong>: This returns <strong class="source-inline">true</strong> if the executed statement <a id="_idIndexMarker1181"/>returns data (inside the <strong class="source-inline">java.sql.ResultSet</strong> object) that can be retrieved using the <strong class="source-inline">ResultSet getResultSet()</strong> method of the <strong class="source-inline">java.sql.Statement</strong> interface. Alternatively, it returns <strong class="source-inline">false</strong> if the executed statement does not return data (for the <strong class="source-inline">INSERT</strong> statement or the <strong class="source-inline">UPDATE</strong> statement) and the subsequent call to the <strong class="source-inline">int getUpdateCount()</strong> method of the <strong class="source-inline">java.sql.Statement</strong> interface returns the number of affected rows.</li>
				<li><strong class="source-inline">ResultSet executeQuery(String sql)</strong>: This returns data as a <strong class="source-inline">java.sql.ResultSet</strong> object (the SQL statement used with this method is usually a <strong class="source-inline">SELECT</strong> statement). The <strong class="source-inline">ResultSet getResultSet()</strong> method of the <strong class="source-inline">java.sql.Statement</strong> interface does not return data, while the <strong class="source-inline">int getUpdateCount()</strong> method of the <strong class="source-inline">java.sql.Statement</strong> interface returns <strong class="source-inline">-1</strong>.</li>
				<li><strong class="source-inline">int executeUpdate(String sql)</strong>: This returns the number of affected rows (the executed SQL statement is expected to be the <strong class="source-inline">UPDATE</strong> statement or the <strong class="source-inline">DELETE</strong> statement). The same number is returned by the <strong class="source-inline">int getUpdateCount()</strong> method of the <strong class="source-inline">java.sql.Statement</strong> interface; the subsequent call to the <strong class="source-inline">ResultSet getResultSet()</strong> method of the <strong class="source-inline">java.sql.Statement</strong> interface returns <strong class="source-inline">null</strong>.</li>
			</ul>
			<p>We will demonstrate how these three methods work on each of the statements: <strong class="source-inline">INSERT</strong>, <strong class="source-inline">SELECT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong>.</p>
			<h3>The execute(String sql) method</h3>
			<p>Let’s try <a id="_idIndexMarker1182"/>executing each of the statements; we’ll <a id="_idIndexMarker1183"/>start with the <strong class="source-inline">INSERT</strong> statement:</p>
			<pre class="source-code">String sql = </pre>
			<pre class="source-code">   "insert into person (first_name, last_name, dob) " +</pre>
			<pre class="source-code">                "values ('Bill', 'Grey', '1980-01-27')";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    System.out.println(st.execute(sql)); //prints: false</pre>
			<pre class="source-code">    System.out.println(st.getResultSet() == null); </pre>
			<pre class="source-code">                                                 //prints: true</pre>
			<pre class="source-code">    System.out.println(st.getUpdateCount()); //prints: 1</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames()); //prints: Bill</pre>
			<p>The preceding <a id="_idIndexMarker1184"/>code adds a new record to the <strong class="source-inline">person</strong> table. The returned <strong class="source-inline">false</strong> value indicates that there is no data returned by the <a id="_idIndexMarker1185"/>executed statement; this is why the <strong class="source-inline">getResultSet()</strong> method returns <strong class="source-inline">null</strong>. But, the <strong class="source-inline">getUpdateCount()</strong> method returns <strong class="source-inline">1</strong> because one record was affected (added). The <strong class="source-inline">selectAllFirstNames()</strong> method proves that the expected record was inserted.</p>
			<p>Now, let’s execute the <strong class="source-inline">SELECT</strong> statement, as follows:</p>
			<pre class="source-code">String sql = "select first_name from person";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    System.out.println(st.execute(sql));    //prints: true</pre>
			<pre class="source-code">    ResultSet rs = st.getResultSet();</pre>
			<pre class="source-code">    System.out.println(rs == null);             //prints: false</pre>
			<pre class="source-code">    System.out.println(st.getUpdateCount());    //prints: -1</pre>
			<pre class="source-code">    while (rs.next()) {</pre>
			<pre class="source-code">        System.out.println(rs.getString(1) + " "); </pre>
			<pre class="source-code">                                                 //prints: Bill</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The preceding <a id="_idIndexMarker1186"/>code selects all the first names <a id="_idIndexMarker1187"/>from the <strong class="source-inline">person</strong> table. The returned <strong class="source-inline">true</strong> value indicates that there is data returned by the executed statement. That is why the <strong class="source-inline">getResultSet()</strong> method does not return <strong class="source-inline">null</strong> but a <strong class="source-inline">ResultSet</strong> object instead. The <strong class="source-inline">getUpdateCount()</strong> method returns <strong class="source-inline">-1</strong> because no record was affected (changed). Since there was only one record in the <strong class="source-inline">person</strong> table, the <strong class="source-inline">ResultSet</strong> object contains only one result, and <strong class="source-inline">rs.getString(1)</strong> returns <strong class="source-inline">Bill</strong>.</p>
			<p>The following code uses the <strong class="source-inline">UPDATE</strong> statement to change the first name in all the records of the <strong class="source-inline">person</strong> table to <strong class="source-inline">Adam</strong>:</p>
			<pre class="source-code">String sql = "update person set first_name = 'Adam'";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    System.out.println(st.execute(sql));  //prints: false</pre>
			<pre class="source-code">    System.out.println(st.getResultSet() == null); </pre>
			<pre class="source-code">                                           //prints: true</pre>
			<pre class="source-code">    System.out.println(st.getUpdateCount());  //prints: 1</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames()); //prints: Adam</pre>
			<p>In the <a id="_idIndexMarker1188"/>preceding code, the returned <strong class="source-inline">false</strong> value indicates that <a id="_idIndexMarker1189"/>there is no data returned by the executed statement. This is why the <strong class="source-inline">getResultSet()</strong> method returns <strong class="source-inline">null</strong>. But, the <strong class="source-inline">getUpdateCount()</strong> method returns <strong class="source-inline">1</strong> because one record was affected (changed) since there was only one record in the <strong class="source-inline">person</strong> table. The <strong class="source-inline">selectAllFirstNames()</strong> method proves that the expected change was made to the record.</p>
			<p>The following <strong class="source-inline">DELETE</strong> statement execution deletes all records from the <strong class="source-inline">person</strong> table:</p>
			<pre class="source-code">String sql = "delete from person";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    System.out.println(st.execute(sql));  //prints: false</pre>
			<pre class="source-code">    System.out.println(st.getResultSet() == null); </pre>
			<pre class="source-code">                                           //prints: true</pre>
			<pre class="source-code">    System.out.println(st.getUpdateCount());  //prints: 1</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames());  //prints: </pre>
			<p>In the preceding code, the returned <strong class="source-inline">false</strong> value indicates that there is no data returned by the executed statement. That is why the <strong class="source-inline">getResultSet()</strong> method returns <strong class="source-inline">null</strong>. But, the <strong class="source-inline">getUpdateCount()</strong> method returns <strong class="source-inline">1</strong> because one record was affected (deleted) since there was only one record in the <strong class="source-inline">person</strong> table. The <strong class="source-inline">selectAllFirstNames()</strong> method proves that there are no records in the <strong class="source-inline">person</strong> table.</p>
			<h3>The executeQuery(String sql) method</h3>
			<p>In this <a id="_idIndexMarker1190"/>section, we will try to execute the <a id="_idIndexMarker1191"/>same statements (as a query) that we used when demonstrating the <strong class="source-inline">execute()</strong> method in the <em class="italic">The execute(String sql) method</em> section. We’ll start with the <strong class="source-inline">INSERT</strong> statement, as follows:</p>
			<pre class="source-code">String sql = </pre>
			<pre class="source-code">"insert into person (first_name, last_name, dob) " +</pre>
			<pre class="source-code">              "values ('Bill', 'Grey', '1980-01-27')";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    st.executeQuery(sql);         //PSQLException</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();         //prints: stack trace </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames()); //prints: Bill</pre>
			<p>The preceding code generates an exception with the <strong class="source-inline">No results were returned by the query</strong> message because the <strong class="source-inline">executeQuery()</strong> method expects to execute the <strong class="source-inline">SELECT</strong> statement. Nevertheless, the <strong class="source-inline">selectAllFirstNames()</strong> method proves that the expected record was inserted. </p>
			<p>Now, let’s execute the <strong class="source-inline">SELECT</strong> statement, as follows:</p>
			<pre class="source-code">String sql = "select first_name from person";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    ResultSet rs1 = st.executeQuery(sql);</pre>
			<pre class="source-code">    System.out.println(rs1 == null);     //prints: false</pre>
			<pre class="source-code">    ResultSet rs2 = st.getResultSet();</pre>
			<pre class="source-code">    System.out.println(rs2 == null);     //prints: false</pre>
			<pre class="source-code">    System.out.println(st.getUpdateCount()); //prints: -1</pre>
			<pre class="source-code">    while (rs1.next()) {</pre>
			<pre class="source-code">        System.out.println(rs1.getString(1)); //prints: Bill</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    while (rs2.next()) {</pre>
			<pre class="source-code">        System.out.println(rs2.getString(1)); //prints:</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The preceding <a id="_idIndexMarker1192"/>code selects all the first names from the <strong class="source-inline">person</strong> table. The returned <strong class="source-inline">false</strong> value indicates that <strong class="source-inline">executeQuery()</strong> always returns the <strong class="source-inline">ResultSet</strong> object, even when no record <a id="_idIndexMarker1193"/>exists in the <strong class="source-inline">person</strong> table. As you can see, there appear to be two ways of getting a result from the executed statement. However, the <strong class="source-inline">rs2</strong> object has no data, so, while using the <strong class="source-inline">executeQuery()</strong> method, make sure that you get the data from the <strong class="source-inline">ResultSet</strong> object.</p>
			<p>Now, let’s try to execute an <strong class="source-inline">UPDATE</strong> statement, as follows:</p>
			<pre class="source-code">String sql = "update person set first_name = 'Adam'";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    st.executeQuery(sql);           //PSQLException</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();           //prints: stack trace</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames()); //prints: Adam</pre>
			<p>The preceding <a id="_idIndexMarker1194"/>code generates an exception <a id="_idIndexMarker1195"/>with the <strong class="source-inline">No results were returned by the query</strong> message because the <strong class="source-inline">executeQuery()</strong> method expects to execute the <strong class="source-inline">SELECT</strong> statement. Nevertheless, the <strong class="source-inline">selectAllFirstNames()</strong> method proves that the expected change was made to the record. </p>
			<p>We are going to get the same exception while executing the <strong class="source-inline">DELETE</strong> statement:</p>
			<pre class="source-code">String sql = "delete from person";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    st.executeQuery(sql);           //PSQLException</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();           //prints: stack trace</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames()); //prints: </pre>
			<p>Nevertheless, the <strong class="source-inline">selectAllFirstNames()</strong> method proves that all the records of the <strong class="source-inline">person</strong> table were deleted.</p>
			<p>Our demonstration shows that <strong class="source-inline">executeQuery()</strong> should be used for <strong class="source-inline">SELECT</strong> statements only. The advantage of the <strong class="source-inline">executeQuery()</strong> method is that, when used for <strong class="source-inline">SELECT</strong> statements, it returns a not-null <strong class="source-inline">ResultSet</strong> object even when there is no data selected, which simplifies the code since there is no need to check the returned value for <strong class="source-inline">null</strong>.</p>
			<h3>The executeUpdate(String sql) method</h3>
			<p>We’ll <a id="_idIndexMarker1196"/>start demonstrating the <strong class="source-inline">executeUpdate()</strong> method with the <strong class="source-inline">INSERT</strong> statement:</p>
			<pre class="source-code">String sql = </pre>
			<pre class="source-code">"insert into person (first_name, last_name, dob) " +</pre>
			<pre class="source-code">               "values ('Bill', 'Grey', '1980-01-27')";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">   System.out.println(st.executeUpdate(sql)); //prints: 1</pre>
			<pre class="source-code">   System.out.println(st.getResultSet());  //prints: null</pre>
			<pre class="source-code">   System.out.println(st.getUpdateCount());  //prints: 1</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames()); //prints: Bill</pre>
			<p>As you <a id="_idIndexMarker1197"/>can see, the <strong class="source-inline">executeUpdate()</strong> method returns the number of affected (inserted, in this case) rows. The same number returns the <strong class="source-inline">int getUpdateCount()</strong> method, while the <strong class="source-inline">ResultSet getResultSet()</strong> method returns <strong class="source-inline">null</strong>. The <strong class="source-inline">selectAllFirstNames()</strong> method proves that the expected record was inserted.</p>
			<p>The <strong class="source-inline">executeUpdate()</strong> method can’t be used for executing the <strong class="source-inline">SELECT</strong> statement:</p>
			<pre class="source-code">String sql = "select first_name from person";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    st.executeUpdate(sql);    //PSQLException</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();     //prints: stack trace</pre>
			<pre class="source-code">}</pre>
			<p>The message <a id="_idIndexMarker1198"/>of the exception is <strong class="source-inline">A result was returned when none was expected</strong>.</p>
			<p>The <strong class="source-inline">UPDATE</strong> statement, on <a id="_idIndexMarker1199"/>the other hand, is executed by the <strong class="source-inline">executeUpdate()</strong> method just fine:</p>
			<pre class="source-code">String sql = "update person set first_name = 'Adam'";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">  System.out.println(st.executeUpdate(sql));  //prints: 1</pre>
			<pre class="source-code">  System.out.println(st.getResultSet());   //prints: null</pre>
			<pre class="source-code">    System.out.println(st.getUpdateCount());    //prints: 1</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames());    //prints: Adam</pre>
			<p>The <strong class="source-inline">executeUpdate()</strong> method returns the number of affected (updated, in this case) rows. The same number returns the <strong class="source-inline">int getUpdateCount()</strong> method, while the <strong class="source-inline">ResultSet getResultSet()</strong> method returns <strong class="source-inline">null</strong>. The <strong class="source-inline">selectAllFirstNames()</strong> method proves that the expected record was updated.</p>
			<p>The <strong class="source-inline">DELETE</strong> statement produces similar results:</p>
			<pre class="source-code">String sql = "delete from person";</pre>
			<pre class="source-code">Connection conn = getConnection();</pre>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">    System.out.println(st.executeUpdate(sql));  //prints: 1</pre>
			<pre class="source-code">    System.out.println(st.getResultSet());      //prints: null</pre>
			<pre class="source-code">    System.out.println(st.getUpdateCount());    //prints: 1</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(selectAllFirstNames());      //prints:</pre>
			<p>By now, you <a id="_idIndexMarker1200"/>have probably realized <a id="_idIndexMarker1201"/>that the <strong class="source-inline">executeUpdate()</strong> method is better suited for <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong> statements.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor242"/>Using PreparedStatement</h2>
			<p><strong class="source-inline">PreparedStatement</strong> is a subinterface of the <strong class="source-inline">Statement</strong> interface. This means that it can <a id="_idIndexMarker1202"/>be used anywhere that the <strong class="source-inline">Statement</strong> interface is used. The advantage of <strong class="source-inline">PreparedStatement</strong> is that it is cached in the database instead of being compiled every time it is invoked. This way, it is efficiently executed multiple times for different input values. It can be created by the <strong class="source-inline">prepareStatement()</strong> method using the same <strong class="source-inline">Connection</strong> object.</p>
			<p>Since the same SQL statement can be used for creating <strong class="source-inline">Statement</strong> and <strong class="source-inline">PreparedStatement</strong>, it is a good idea to use <strong class="source-inline">PreparedStatement</strong> for any SQL statement that is called multiple times because it performs better than the <strong class="source-inline">Statement</strong> interface on the database side. To do this, all we need to change are these two lines from the preceding code example:</p>
			<pre class="source-code">try (conn; Statement st = conn.createStatement()) { </pre>
			<pre class="source-code">     ResultSet rs = st.executeQuery(sql);</pre>
			<p>Instead, we can use the <strong class="source-inline">PreparedStatement</strong> class, as follows:</p>
			<pre class="source-code">try (conn; PreparedStatement st = conn.prepareStatement(sql)) { </pre>
			<pre class="source-code">     ResultSet rs = st.executeQuery();</pre>
			<p>To create the <strong class="source-inline">PreparedStatement</strong> object with parameters, you can substitute the input values <a id="_idIndexMarker1203"/>with the question mark symbol (<strong class="source-inline">?</strong>); for example, we can create the following method (see the <strong class="source-inline">Person</strong> class in the <strong class="source-inline">database</strong> project):</p>
			<pre class="source-code">private static final String SELECT_BY_FIRST_NAME = </pre>
			<pre class="source-code">            "select * from person where first_name = ?";</pre>
			<pre class="source-code">static List&lt;Person&gt; selectByFirstName(Connection conn, </pre>
			<pre class="source-code">                                     String searchName) {</pre>
			<pre class="source-code">    List&lt;Person&gt; list = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">    try (PreparedStatement st = </pre>
			<pre class="source-code">         conn.prepareStatement(SELECT_BY_FIRST_NAME)) {</pre>
			<pre class="source-code">       st.setString(1, searchName);</pre>
			<pre class="source-code">       ResultSet rs = st.executeQuery();</pre>
			<pre class="source-code">       while (rs.next()) {</pre>
			<pre class="source-code">           list.add(new Person(rs.getInt("id"),</pre>
			<pre class="source-code">                    rs.getString("first_name"),</pre>
			<pre class="source-code">                    rs.getString("last_name"),</pre>
			<pre class="source-code">                    rs.getDate("dob").toLocalDate()));</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">   } catch (SQLException ex) {</pre>
			<pre class="source-code">        ex.printStackTrace();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return list;</pre>
			<pre class="source-code">}</pre>
			<p>When it is used the first time, the database compiles the <strong class="source-inline">PreparedStatement</strong> object as a template and stores it. Then, when it is later used by the application again, the parameter value is passed to the template, and the statement is executed immediately without the overhead of compilation since it has been done already.</p>
			<p>Another advantage <a id="_idIndexMarker1204"/>of a prepared statement is that it is better protected from a SQL injection attack because values are passed in using a different protocol and the template is not based on the external input.</p>
			<p>If a prepared statement is used only once, it may be slower than a regular statement, but the difference may be negligible. If in doubt, test the performance and see whether it is acceptable for your application – the increased security could be worth it. </p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor243"/>Using CallableStatement</h2>
			<p>The <strong class="source-inline">CallableStatement</strong> interface (which extends the <strong class="source-inline">PreparedStatement</strong> interface) can be used to execute a stored procedure, although some <a id="_idIndexMarker1205"/>databases allow you to call a stored procedure using either a <strong class="source-inline">Statement</strong> or <strong class="source-inline">PreparedStatement</strong> interface. A <strong class="source-inline">CallableStatement</strong> object is created <a id="_idIndexMarker1206"/>by the <strong class="source-inline">prepareCall()</strong> method and can have parameters of three types:</p>
			<ul>
				<li><strong class="source-inline">IN</strong> for an input value</li>
				<li><strong class="source-inline">OUT</strong> for the result</li>
				<li><strong class="source-inline">IN OUT</strong> for either an input or an output value</li>
			</ul>
			<p>The <strong class="source-inline">IN</strong> parameter <a id="_idIndexMarker1207"/>can be set the same way as the parameters of <strong class="source-inline">PreparedStatement</strong>, while the <strong class="source-inline">OUT</strong> parameter <a id="_idIndexMarker1208"/>must be registered by the <strong class="source-inline">registerOutParameter()</strong> method of <strong class="source-inline">CallableStatement</strong>. </p>
			<p>It is worth noting that executing a stored procedure from Java programmatically is one of the least standardized areas. PostgreSQL, for example, does not support stored procedures directly, but they can be invoked as functions that have been modified for this purpose <a id="_idIndexMarker1209"/>by interpreting the <strong class="source-inline">OUT</strong> parameters as return values. Oracle, on the other hand, allows the <strong class="source-inline">OUT</strong> parameters as functions too.</p>
			<p>This is why the following differences between database functions and stored procedures can serve only as general guidelines and not as formal definitions:</p>
			<ul>
				<li>A function has a return value, but it does not allow <strong class="source-inline">OUT</strong> parameters (except for some databases) and can be used in a SQL statement.</li>
				<li>A stored procedure does not have a return value (except for some databases); it allows <strong class="source-inline">OUT</strong> parameters (for most databases) and can be executed using the JDBC <strong class="source-inline">CallableStatement</strong> interface.</li>
			</ul>
			<p>You can refer to the database documentation to learn how to execute a stored procedure. </p>
			<p>Since stored procedures are compiled and stored on the database server, the <strong class="source-inline">execute()</strong> method of <strong class="source-inline">CallableStatement</strong> performs better for the same SQL statement than the corresponding method of the <strong class="source-inline">Statement</strong> or <strong class="source-inline">PreparedStatement</strong> interface. This is one of the reasons why a lot of Java code is sometimes replaced by one or several stored procedures that even include business logic. However, there is no one right answer for every case and problem, so we will refrain from making specific recommendations, except to repeat the familiar mantra about the value of testing and the clarity of the code you are writing:</p>
			<pre class="source-code">String replace(String origText, String substr1, String substr2) {</pre>
			<pre class="source-code">    String result = "";</pre>
			<pre class="source-code">    String sql = "{ ? = call replace(?, ?, ? ) }";</pre>
			<pre class="source-code">    Connection conn = getConnection();</pre>
			<pre class="source-code">    try (conn; CallableStatement st = conn.prepareCall(sql)) {</pre>
			<pre class="source-code">        st.registerOutParameter(1, Types.VARCHAR);</pre>
			<pre class="source-code">        st.setString(2, origText);</pre>
			<pre class="source-code">        st.setString(3, substr1);</pre>
			<pre class="source-code">        st.setString(4, substr2);</pre>
			<pre class="source-code">        st.execute();</pre>
			<pre class="source-code">        result = st.getString(1);</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">        ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return result;</pre>
			<pre class="source-code">}</pre>
			<p>Now, we can call this method, as follows:</p>
			<pre class="source-code">String result = replace("That is original text",</pre>
			<pre class="source-code">                         "original text", "the result");</pre>
			<pre class="source-code">System.out.println(result);  //prints: That is the result</pre>
			<p>A stored <a id="_idIndexMarker1210"/>procedure can be without any parameters at all, with <strong class="source-inline">IN</strong> parameters only, with <strong class="source-inline">OUT</strong> parameters only, or with both. The result may be one or multiple values, or a <strong class="source-inline">ResultSet</strong> object. You can find the syntax of the SQL for function creation in your database documentation. </p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/>Using a shared library JAR file to access a database</h2>
			<p>In fact, we <a id="_idIndexMarker1211"/>have already started using <a id="_idIndexMarker1212"/>the <strong class="source-inline">database</strong> project JAR file to access the database driver, set as a dependency in the <strong class="source-inline">pom.xml</strong> file of the <strong class="source-inline">database</strong> project. Now, we are going to demonstrate how to use a JAR file of the <strong class="source-inline">database</strong> project JAR file to manipulate data in the database. An example of such usage is presented in the <strong class="source-inline">UseDatabaseJar</strong> class.</p>
			<p>To support CRUD operations, a database table often represents a class of objects. Each row of such a table contains properties of one object of a class. In the <em class="italic">Creating a database structure</em> section, we demonstrated an example of such mapping between the <strong class="source-inline">Person</strong> class <a id="_idIndexMarker1213"/>and the <strong class="source-inline">person</strong> table. To illustrate how to use a JAR file for data manipulation, we have created a <a id="_idIndexMarker1214"/>separate <strong class="source-inline">database</strong> project that has only one <strong class="source-inline">Person</strong> class. In addition to the properties shown in the <em class="italic">Creating a database structure</em> section, it has static methods for all CRUD operations. The following is the <strong class="source-inline">insert()</strong> method: </p>
			<pre class="source-code">static final String INSERT = "insert into person " +</pre>
			<pre class="source-code">  "(first_name, last_name, dob) values (?, ?, ?::date)";</pre>
			<pre class="source-code">static void insert(Connection conn, Person person) {</pre>
			<pre class="source-code">   try (PreparedStatement st = </pre>
			<pre class="source-code">                       conn.prepareStatement(INSERT)) {</pre>
			<pre class="source-code">            st.setString(1, person.getFirstName());</pre>
			<pre class="source-code">            st.setString(2, person.getLastName());</pre>
			<pre class="source-code">            st.setString(3, person.getDob().toString());</pre>
			<pre class="source-code">            st.execute();</pre>
			<pre class="source-code">   } catch (SQLException ex) {</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>The following is the <strong class="source-inline">selectByFirstName()</strong> method:</p>
			<pre class="source-code">private static final String SELECT = </pre>
			<pre class="source-code">          "select * from person where first_name = ?";</pre>
			<pre class="source-code">static List&lt;Person&gt; selectByFirstName(Connection conn, </pre>
			<pre class="source-code">                                    String firstName) {</pre>
			<pre class="source-code">   List&lt;Person&gt; list = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">   try (PreparedStatement st = conn.prepareStatement(SELECT)) {</pre>
			<pre class="source-code">        st.setString(1, firstName);</pre>
			<pre class="source-code">        ResultSet rs = st.executeQuery();</pre>
			<pre class="source-code">        while (rs.next()) {</pre>
			<pre class="source-code">            list.add(new Person(rs.getInt("id"),</pre>
			<pre class="source-code">                    rs.getString("first_name"),</pre>
			<pre class="source-code">                    rs.getString("last_name"),</pre>
			<pre class="source-code">                    rs.getDate("dob").toLocalDate()));</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">   } catch (SQLException ex) {</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return list;</pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker1215"/>following <a id="_idIndexMarker1216"/>is the <strong class="source-inline">updateFirstNameById()</strong> method:</p>
			<pre class="source-code">private static final String UPDATE = </pre>
			<pre class="source-code">      "update person set first_name = ? where id = ?";</pre>
			<pre class="source-code">public static void updateFirstNameById(Connection conn, </pre>
			<pre class="source-code">                           int id, String newFirstName) {</pre>
			<pre class="source-code">   try (PreparedStatement st = conn.prepareStatement(UPDATE)) {</pre>
			<pre class="source-code">            st.setString(1, newFirstName);</pre>
			<pre class="source-code">            st.setInt(2, id);</pre>
			<pre class="source-code">            st.execute();</pre>
			<pre class="source-code">   } catch (SQLException ex) {</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker1217"/>following <a id="_idIndexMarker1218"/>is the <strong class="source-inline">deleteById()</strong> method:</p>
			<pre class="source-code">private static final String DELETE = </pre>
			<pre class="source-code">                       "delete from person where id = ?";</pre>
			<pre class="source-code">public static void deleteById(Connection conn, int id) {</pre>
			<pre class="source-code">   try (PreparedStatement st = conn.prepareStatement(DELETE)) {</pre>
			<pre class="source-code">            st.setInt(1, id);</pre>
			<pre class="source-code">            st.execute();</pre>
			<pre class="source-code">   } catch (SQLException ex) {</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, all the preceding methods accept the <strong class="source-inline">Connection</strong> object as a parameter, instead of creating and destroying it inside each method. We decided to do it like so because it allows several operations to associate with each <strong class="source-inline">Connection</strong> object in case we would like them to be committed to the database together or to be rolled back if one of them fails (read about transaction management in the documentation of the database of your choice). Besides, the JAR file (generated by the <strong class="source-inline">database</strong> project) can be used <a id="_idIndexMarker1219"/>by different applications, so database <a id="_idIndexMarker1220"/>connection parameters are going to be application-specific, and that is why the <strong class="source-inline">Connection</strong> object has to be created in the application that uses the JAR file. The following code demonstrates such a usage (see the <strong class="source-inline">UseDatabaseJar</strong> class). </p>
			<p>Make sure you have executed the <strong class="source-inline">mvn clean install</strong> command in the <strong class="source-inline">database</strong> folder before running the following examples:</p>
			<pre class="source-code">1 try(Connection conn = getConnection()){</pre>
			<pre class="source-code">2    cleanTablePerson(conn);</pre>
			<pre class="source-code">3    Person mike = new Person("Mike", "Brown", </pre>
			<pre class="source-code">                             LocalDate.of(2002, 8, 14));</pre>
			<pre class="source-code">4    Person jane = new Person("Jane", "McDonald", </pre>
			<pre class="source-code">                             LocalDate.of(2000, 3, 21));</pre>
			<pre class="source-code">5    Person jill = new Person("Jill", "Grey", </pre>
			<pre class="source-code">                             LocalDate.of(2001, 4, 1));</pre>
			<pre class="source-code">6    Person.insert(conn, mike);</pre>
			<pre class="source-code">7    Person.insert(conn, jane);</pre>
			<pre class="source-code">8    Person.insert(conn, jane);</pre>
			<pre class="source-code">9    List&lt;Person&gt; persons = </pre>
			<pre class="source-code">           Person.selectByFirstName(conn, jill.getFirstName());</pre>
			<pre class="source-code">10   System.out.println(persons.size());      //prints: 0</pre>
			<pre class="source-code">11   persons = Person.selectByFirstName(conn, </pre>
			<pre class="source-code">                                          jane.getFirstName());</pre>
			<pre class="source-code">12   System.out.println(persons.size());      //prints: 2</pre>
			<pre class="source-code">13   Person person = persons.get(0);</pre>
			<pre class="source-code">14   Person.updateFirstNameById(conn, person.getId(),</pre>
			<pre class="source-code">                                          jill.getFirstName());</pre>
			<pre class="source-code">15   persons = Person.selectByFirstName(conn, </pre>
			<pre class="source-code">                                          jane.getFirstName());</pre>
			<pre class="source-code">16   System.out.println(persons.size());      //prints: 1 </pre>
			<pre class="source-code">17   persons = Person.selectByFirstName(conn, </pre>
			<pre class="source-code">                                          jill.getFirstName());</pre>
			<pre class="source-code">18   System.out.println(persons.size());      //prints: 1</pre>
			<pre class="source-code">19   persons = Person.selectByFirstName(conn, </pre>
			<pre class="source-code">                                          mike.getFirstName());</pre>
			<pre class="source-code">20   System.out.println(persons.size());      //prints: 1</pre>
			<pre class="source-code">21   for(Person p: persons){</pre>
			<pre class="source-code">22      Person.deleteById(conn, p.getId());</pre>
			<pre class="source-code">23   }</pre>
			<pre class="source-code">24   persons = Person.selectByFirstName(conn, </pre>
			<pre class="source-code">                                          mike.getFirstName());</pre>
			<pre class="source-code">25   System.out.println(persons.size());      //prints: 0</pre>
			<pre class="source-code">26 } catch (SQLException ex){</pre>
			<pre class="source-code">27       ex.printStackTrace();</pre>
			<pre class="source-code">28 }</pre>
			<p>Let’s walk <a id="_idIndexMarker1221"/>through the preceding code snippet. Lines <strong class="source-inline">1</strong> and <strong class="source-inline">26</strong> to <strong class="source-inline">28</strong> compose the <strong class="source-inline">try–catch</strong> block that disposes of the <strong class="source-inline">Connection</strong> object and catches all the exceptions that may happen inside this block during its execution.</p>
			<p>Line <strong class="source-inline">2</strong> was included <a id="_idIndexMarker1222"/>just to clean up the data from the <strong class="source-inline">person</strong> table before running the demo code. The following is the implementation of the <strong class="source-inline">cleanTablePerson()</strong>  method: </p>
			<pre class="source-code">void cleanTablePerson(Connection conn) {</pre>
			<pre class="source-code">   try (Statement st = conn.createStatement()) {</pre>
			<pre class="source-code">       st.execute("delete from person");</pre>
			<pre class="source-code">   } catch (SQLException ex) {</pre>
			<pre class="source-code">       ex.printStackTrace();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>In lines <strong class="source-inline">3</strong>, <strong class="source-inline">4</strong>, and <strong class="source-inline">5</strong>, we create three objects of the <strong class="source-inline">Person</strong> class, then in lines <strong class="source-inline">6</strong>, <strong class="source-inline">7</strong>, and <strong class="source-inline">8</strong>, we use them to insert records in the <strong class="source-inline">person</strong> table.</p>
			<p>In line <strong class="source-inline">9</strong>, we query the database for a record that has the first name taken from the <strong class="source-inline">jill</strong> object, and in line <strong class="source-inline">10</strong>, we print out the result count, which is <strong class="source-inline">0</strong> (because we did not insert such a record).</p>
			<p>In line <strong class="source-inline">11</strong>, we query the database for a record that has the first name set to <strong class="source-inline">Jane</strong>, and in line <strong class="source-inline">12</strong>, we print out the result count, which is <strong class="source-inline">2</strong> (because we did insert two records with such a value).</p>
			<p>In line <strong class="source-inline">13</strong>, we extract the first of the two objects returned by the previous query, and in line <strong class="source-inline">14</strong>, we update the corresponding record with a different value for the first name (taken from the <strong class="source-inline">jill</strong> object).</p>
			<p>In line <strong class="source-inline">15</strong>, we repeat the query for a record with the first name set to <strong class="source-inline">Jane</strong>, and in line <strong class="source-inline">16</strong>, we print out the result count, which is <strong class="source-inline">1</strong> this time (as expected, because we have changed the first name to <strong class="source-inline">Jill</strong> on one of the two records).</p>
			<p>In line <strong class="source-inline">17</strong>, we select all <a id="_idIndexMarker1223"/>the records with <a id="_idIndexMarker1224"/>the first name set to <strong class="source-inline">Jill</strong>, and in line <strong class="source-inline">18</strong>, we print out the result count, which is <strong class="source-inline">1</strong> this time (as expected, because we have changed the first name to <strong class="source-inline">Jill</strong> on one of the two records that used to have the first name value <strong class="source-inline">Jane</strong>).</p>
			<p>In line <strong class="source-inline">19</strong>, we select all the records with the name set to <strong class="source-inline">Mike</strong>, and in line <strong class="source-inline">20</strong>, we print out the result count, which is <strong class="source-inline">1</strong> (as expected, because we have created only one such record).</p>
			<p>In lines <strong class="source-inline">21</strong> to <strong class="source-inline">23</strong>, we delete all the retrieved records in a loop.</p>
			<p>That is why when we select all the records with the first name <strong class="source-inline">Mike</strong> in line <strong class="source-inline">24</strong> again, we get a result count equal to <strong class="source-inline">0</strong> in line <strong class="source-inline">25</strong> (as expected, because there is no such record anymore). </p>
			<p>At this point, when this code snippet is executed and the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">UseDatabseJar</strong> class is completed, all the changes in the database are saved automatically.</p>
			<p>That is how a JAR file (which allows modifying data in a database) can be used by any application that has this file as a dependency.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor245"/>Summary</h1>
			<p>In this chapter, we discussed and demonstrated how the data in a database can be populated, read, updated, and deleted from a Java application. A short introduction to the SQL language described how to create a database and its structure, how to modify it, and how to execute SQL statements, using <strong class="source-inline">Statement</strong>, <strong class="source-inline">PreparedStatement</strong>, and <strong class="source-inline">CallableStatement</strong>.</p>
			<p>Now, you can create and use a database for storing, updating, and retrieving data, and create and use a shared library. </p>
			<p>In the next chapter, we will describe and discuss the most popular network protocols, demonstrate how to use them, and how to implement client-server communication using the latest Java HTTP Client API. The protocols reviewed include the Java implementation of a communication protocol based on TCP, UDP, and URLs. </p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/>Quiz</h1>
			<ol>
				<li value="1">Select all the correct statements:<ol><li>JDBC stands for Java Database Communication.</li><li>The JDBC API includes the <strong class="source-inline">java.db</strong> package.</li><li>The JDBC API comes with Java installation.</li><li>The JDBC API includes the drivers for all major DBMSs.</li></ol></li>
				<li>Select all the correct statements:<ol><li>A database table can be created using the <strong class="source-inline">CREATE</strong> statement.</li><li>A database table can be changed using the <strong class="source-inline">UPDATE</strong> statement.</li><li>A database table can be removed using the <strong class="source-inline">DELETE</strong> statement.</li><li>Each database column can have an index.</li></ol></li>
				<li>Select all the correct statements:<ol><li>To connect to a database, you can use the <strong class="source-inline">Connect</strong> class.</li><li>Every database connection must be closed.</li><li>The same database connection may be used for many operations.</li><li>Database connections can be pooled.</li></ol></li>
				<li>Select all the correct statements:<ol><li>A database connection can be closed automatically using the <strong class="source-inline">try-with-resources</strong> construct.</li><li>A database connection can be closed using the <strong class="source-inline">finally</strong> block construct.</li><li>A database connection can be closed using the <strong class="source-inline">catch</strong> block.</li><li>A database connection can be closed without a <strong class="source-inline">try</strong> block.</li></ol></li>
				<li>Select all the correct statements:<ol><li>The <strong class="source-inline">INSERT</strong> statement includes a table name.</li><li>The <strong class="source-inline">INSERT</strong> statement includes column names.</li><li>The <strong class="source-inline">INSERT</strong> statement includes values.</li><li>The <strong class="source-inline">INSERT</strong> statement includes constraints.</li></ol></li>
				<li>Select all the correct statements:<ol><li>The <strong class="source-inline">SELECT</strong> statement must include a table name.</li><li>The <strong class="source-inline">SELECT</strong> statement must include a column name.</li><li>The <strong class="source-inline">SELECT</strong> statement must include the <strong class="source-inline">WHERE</strong> clause.</li><li>The <strong class="source-inline">SELECT</strong> statement may include the <strong class="source-inline">ORDER</strong> clause.</li></ol></li>
				<li>Select all the correct statements:<ol><li>The <strong class="source-inline">UPDATE</strong> statement must include a table name.</li><li>The <strong class="source-inline">UPDATE</strong> statement must include a column name.</li><li>The <strong class="source-inline">UPDATE</strong> statement may include the <strong class="source-inline">WHERE</strong> clause.</li><li>The <strong class="source-inline">UPDATE</strong> statement may include the <strong class="source-inline">ORDER</strong> clause.</li></ol></li>
				<li>Select all the correct statements:<ol><li>The <strong class="source-inline">DELETE</strong> statement must include a table name.</li><li>The <strong class="source-inline">DELETE</strong> statement must include a column name.</li><li>The <strong class="source-inline">DELETE</strong> statement may include the <strong class="source-inline">WHERE</strong> clause.</li><li>The <strong class="source-inline">DELETE</strong> statement may include the <strong class="source-inline">ORDER</strong> clause.</li></ol></li>
				<li>Select all the correct statements about the <strong class="source-inline">execute()</strong> method of the <strong class="source-inline">Statement</strong> interface:<ol><li>It receives a SQL statement.</li><li>It returns a <strong class="source-inline">ResultSet</strong> object.</li><li>The <strong class="source-inline">Statement</strong> object may return data after <strong class="source-inline">execute()</strong> is called.</li><li>The <strong class="source-inline">Statement</strong> object may return the number of affected records after <strong class="source-inline">execute()</strong> is called. </li></ol></li>
				<li>Select all the correct statements about the <strong class="source-inline">executeQuery()</strong> method of the <strong class="source-inline">Statement</strong> interface:<ol><li>It receives a SQL statement.</li><li>It returns a <strong class="source-inline">ResultSet</strong> object.</li><li>The <strong class="source-inline">Statement</strong> object may return data after <strong class="source-inline">executeQuery()</strong> is called.</li><li>The <strong class="source-inline">Statement</strong> object may return the number of affected records after <strong class="source-inline">executeQuery()</strong> is called.</li></ol></li>
				<li>Select all the correct statements about the <strong class="source-inline">executeUpdate()</strong> method of the <strong class="source-inline">Statement</strong> interface:<ol><li>It receives a SQL statement.</li><li>It returns a <strong class="source-inline">ResultSet</strong> object.</li><li>The <strong class="source-inline">Statement</strong> object may return data after <strong class="source-inline">executeUpdate()</strong> is called.</li><li>The <strong class="source-inline">Statement</strong> object returns the number of affected records after <strong class="source-inline">executeUpdate()</strong> is called.</li></ol></li>
				<li>Select all the correct statements about the <strong class="source-inline">PreparedStatement</strong> interface:<ol><li>It extends <strong class="source-inline">Statement</strong>.</li><li>An object of type <strong class="source-inline">PreparedStatement</strong> is created by the <strong class="source-inline">prepareStatement()</strong> method.</li><li>It is always more efficient than <strong class="source-inline">Statement</strong>.</li><li>It results in a template in the database being created only once.</li></ol></li>
				<li>Select all the correct statements about the <strong class="source-inline">CallableStatement</strong> interface:<ol><li>It extends <strong class="source-inline">PreparedStatement</strong>.</li><li>An object of type <strong class="source-inline">CallableStatement</strong> is created by the <strong class="source-inline">prepareCall()</strong> method.</li><li>It is always more efficient than <strong class="source-inline">PreparedStatement</strong>.</li><li>It results in a template in the database being created only once.</li></ol></li>
			</ol>
		</div>
	</body></html>