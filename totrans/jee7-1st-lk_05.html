<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;The Business Layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. The Business Layer</h1></div></div></div><p>Here we will begin with a presentation of improvements in the business layer and then, in a small project, we will try to put together some of the specifications seen previously. The topics to be covered include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enterprise JavaBeans 3.2</li><li class="listitem" style="list-style-type: disc">Putting all Java EE 7 specifications together</li></ul></div><div class="section" title="Enterprise JavaBeans 3.2"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Enterprise JavaBeans 3.2</h1></div></div></div><p>The Enterprise JavaBeans 3.2 <a id="id285" class="indexterm"/>Specification was developed under JSR 345. This section just gives you an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html</a>.</p><p>The business layer of an application is the part of the application that is located between the presentation layer and data access layer. The following diagram presents a simplified Java EE architecture. As you can see, the business layer acts as a bridge between the data access and the presentation layer.</p><div class="mediaobject"><img src="graphics/9235OT_05_01.jpg" alt="Enterprise JavaBeans 3.2"/></div><p>It implements business logic of the application. To do so, it can use some specifications such as Bean Validation for data validation, CDI for context and dependency injection, interceptors to intercept processing, and so on. As this layer can be located anywhere in the network and is expected to serve more than one user, it needs a minimum of non functional services such as security, transaction, concurrency, and remote access management. With EJBs, the Java EE platform provides to developers the possibility to implement this layer <a id="id286" class="indexterm"/>without worrying about different non functional services that are necessarily required.</p><p>In general, this specification does not initiate any new major feature. It continues the work started by the last version, making optional the implementation of certain features that became obsolete and adds slight modification to others.</p><div class="section" title="Pruning some features"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Pruning some features</h2></div></div></div><p>After the pruning process introduced by Java EE 6 from the perspective of removing obsolete features, support for some features has been made optional in Java EE 7 platform, and their description was moved to another document called <span class="emphasis"><em>EJB 3.2 Optional Features for Evaluation</em></span>. The features involved in this movement are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">EJB 2.1 and earlier Entity Bean Component Contract for Container-Managed Persistence</li><li class="listitem" style="list-style-type: disc">EJB 2.1 and earlier Entity Bean Component Contract for Bean-Managed Persistence</li><li class="listitem" style="list-style-type: disc">Client View of EJB 2.1 and earlier Entity Bean</li><li class="listitem" style="list-style-type: disc">EJB QL: Query Language for Container-Managed Persistence Query Methods</li><li class="listitem" style="list-style-type: disc">JAX-RPC-based Web Service Endpoints</li><li class="listitem" style="list-style-type: disc">JAX-RPC Web Service Client View</li></ul></div></div><div class="section" title="The latest improvements in EJB 3.2"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>The latest improvements in EJB 3.2</h2></div></div></div><p>For those who have had to use EJB 3.0 and EJB 3.1, you will notice that EJB 3.2 has brought, in fact, only minor changes to the specification. However, some improvements cannot be overlooked since they improve the testability of applications, simplify the development of session beans or Message-Driven Beans, and improve control over the management of the transaction and passivation of stateful beans.</p><div class="section" title="Session bean enhancement"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec33"/>Session bean enhancement</h3></div></div></div><p>A session bean is a type of EJB <a id="id287" class="indexterm"/>that allows us to implement business logic accessible to local, remote, or Web Service Client View. There are three types of session beans: <a id="id288" class="indexterm"/>
<span class="strong"><strong>stateless</strong></span> for processing without states, <span class="strong"><strong>stateful</strong></span> <a id="id289" class="indexterm"/>for <a id="id290" class="indexterm"/>processes that <a id="id291" class="indexterm"/>require the preservation of states between different <a id="id292" class="indexterm"/>calls of methods, and <span class="strong"><strong>singleton</strong></span> for sharing a <a id="id293" class="indexterm"/>single <a id="id294" class="indexterm"/>instance of an object between different clients.</p><p>The following code shows an example of a stateless session bean to save an entity in the database:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class ExampleOfSessionBean  {

    @PersistenceContext EntityManager em;
    
    public void persistEntity(Object entity){
        em.persist(entity);
    }
}</pre></div><p>Talking about improvements of session beans, we first note two changes in stateful session beans: the ability to execute life-cycle callback interceptor methods in a user-defined transaction context and the ability to manually disable passivation of stateful session beans.</p><p>It is possible to define a process that must be executed according to the lifecycle of an EJB bean (post-construct, pre-destroy). <a id="id295" class="indexterm"/>Due to the <code class="literal">@TransactionAttribute</code> annotation, you can perform processes related to the database during these phases and control how they impact your system. The following code retrieves an entity after being initialized and ensures that all changes made to the persistence context are sent to the database at the time of destruction of the bean. As you can see in the following code, <code class="literal">TransactionAttributeType</code> of <a id="id296" class="indexterm"/>
<code class="literal">init()</code> method is <code class="literal">NOT_SUPPORTED</code>; this means that the retrieved entity will not be included in the persistence context and any changes made to it will not be saved in the database:</p><div class="informalexample"><pre class="programlisting">@Stateful
public class StatefulBeanNewFeatures  {

    @PersistenceContext(type= PersistenceContextType.EXTENDED)
    EntityManager em;
    
    @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
    @PostConstruct
    public void init(){
         entity = em.find(...);
    }
    
    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    @PreDestroy
    public void destroy(){
        em.flush();
    }
}</pre></div><p>The following code demonstrates how to control passivation of the stateful bean. Usually, the session beans are removed from memory to be stored on the disk after a certain time of inactivity. This process requires data to be serialized, but during serialization all transient variables are skipped and restored to the default value of their data type, which is <code class="literal">null</code> for object, zero for <code class="literal">int</code>, and so on. To <a id="id297" class="indexterm"/>prevent the loss of this type of data, you can simply disable the passivation of stateful session beans by passing the <code class="literal">false</code> value to the <code class="literal">passivationCapable</code> <a id="id298" class="indexterm"/>attribute of the <a id="id299" class="indexterm"/>
<code class="literal">@Stateful</code> annotation.</p><div class="informalexample"><pre class="programlisting">@Stateful(passivationCapable = false)
public class StatefulBeanNewFeatures  {
   //...
}</pre></div><p>For the sake of simplicity, EJB 3.2 has relaxed the rules to define the default local or remote business interface of a session bean. The following code shows how a simple interface can be considered as local or remote depending on the case:</p><div class="informalexample"><pre class="programlisting">//In this example, yellow and green are local interfaces
public interface yellow { ... }
public interface green { ... }

@Stateless
public class Color implements yellow, green { ... }

//In this example, yellow and green are local interfaces
public interface yellow { ... }
public interface green { ... }


@Local
@Stateless
public class Color implements yellow, green { ... }

//In this example, yellow and green are remote interfaces
public interface yellow { ... }
public interface green { ... }


@Remote
@Stateless
public class Color implements yellow, green { ... }

//In this example, only the yellow interface is exposed as a remote interface
@Remote
public interface yellow { ... }
public interface green { ... }


@Stateless
public class Color implements yellow, green { ... }

//In this example, only the yellow interface is exposed as a remote interface
public interface yellow { ... }
public interface green { ... }

@Remote(yellow.class)
@Stateless
public class Color implements yellow, green { ... }</pre></div></div><div class="section" title="EJB Lite improvements"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec34"/>EJB Lite improvements</h3></div></div></div><p>Before EJB 3.1, the implementation <a id="id300" class="indexterm"/>of a Java EE application required the use of a full Java EE server with more than twenty specifications. This could be heavy enough for applications that only need some specification (as if you were asked to take a hammer to kill a fly). To adapt Java EE to this situation, <a id="id301" class="indexterm"/>JCP (Java Community Process) introduced the concept of profile and EJB Lite. Specifically, EJB Lite is a subset of EJBs, grouping essential capabilities for local transactional and secured processing. With this concept, it has become possible to make unit tests of an EJB application without using the Java EE server and it is also possible to use EJBs in web applications or Java SE effectively.</p><p>In addition to the features already present in EJB 3.1, the EJB 3.2 Specification has added support for local asynchronous session bean invocations and non persistent EJB Timer Service. This enriches the embeddable <code class="literal">EJBContainer</code>, web profiles, and augments the number of testable features in an embeddable <code class="literal">EJBContainer</code>. The following code shows an EJB packaged in a WAR archive that contains two methods. The <code class="literal">asynchronousMethod()</code> <a id="id302" class="indexterm"/>is an <a id="id303" class="indexterm"/>asynchronous method that allows you to compare the time gap between the end of a method call on the client side and the end of execution of the method on the server side. The <a id="id304" class="indexterm"/>
<code class="literal">nonPersistentEJBTimerService()</code> method demonstrates how to define a non persistent EJB Timer Service that will be executed every minute while the hour is one o'clock:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class EjbLiteSessionBean {
    
    @Asynchronous
    public void asynchronousMethod(){
        try{
          System.out.println("EjbLiteSessionBean - start : "+new Date());
          Thread.sleep(1000*10);
          System.out.println("EjbLiteSessionBean - end : "+new Date());        
        }catch(Exception ex){
            ex.printStackTrace();
        }
    }    
    
    @Schedule(persistent = false, minute = "*", hour = "1")
    public void nonPersistentEJBTimerService(){
        System.out.println("nonPersistentEJBTimerService method executed");
    }
}</pre></div></div><div class="section" title="Changes made to the TimerService API"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec35"/>Changes made to the TimerService API</h3></div></div></div><p>The EJB 3.2 Specification enhanced <a id="id305" class="indexterm"/>the <code class="literal">TimerService</code> API with a new method called <code class="literal">getAllTimers()</code>. This method gives <a id="id306" class="indexterm"/>you the ability to access all active timers in an EJB module. The following code demonstrates how to create different types of timers, access <a id="id307" class="indexterm"/>their information, and cancel them; it makes use of the <code class="literal">getAllTimers()</code> method:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class ChangesInTimerAPI implements ChangesInTimerAPILocal {

    @Resource
    TimerService timerService;
    public void createTimer(){
        //create a programmatic timer
        long initialDuration = 1000*5;
        long intervalDuration = 1000*60;
        String timerInfo = "PROGRAMMATIC TIMER";
        timerService.createTimer(initialDuration, intervalDuration, timerInfo);
    }
    
    @Timeout
    public void timerMethodForProgrammaticTimer(){
        System.out.println("ChangesInTimerAPI - programmatic timer : "+new Date());
    }
    
    @Schedule(info = "AUTOMATIC TIMER", hour = "*", minute = "*")
    public void automaticTimer(){
        System.out.println("ChangesInTimerAPI - automatic timer : "+new Date());
    }
    
    public void getListOfAllTimers(){
        Collection&lt;Timer&gt; alltimers = timerService.getAllTimers();
        
        for(Timer timer : alltimers){            
            System.out.println("The next time out : "+timer.getNextTimeout()+", "
                    + " timer info : "+timer.getInfo());
            timer.cancel();            
        }
    }
}</pre></div><p>In addition to this method, the specification <a id="id308" class="indexterm"/>has removed the restrictions that required the use of <code class="literal">javax.ejb.Timer</code> and <code class="literal">javax.ejb.TimerHandlereferences</code> only inside a bean.</p></div><div class="section" title="Harmonizing with JMS's novelties"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec36"/>Harmonizing with JMS's novelties</h3></div></div></div><p>A <span class="strong"><strong>Message-Driven Bean</strong></span> (<span class="strong"><strong>MDB</strong></span>) is <a id="id309" class="indexterm"/>a kind of a JMS Message listener allowing Java EE applications to process messages asynchronously. To define such a bean, simply decorate a simple POJO class with <a id="id310" class="indexterm"/>
<code class="literal">@MessageDriven</code> annotation and make it implement the <code class="literal">javax.jms.MessageListener</code> <a id="id311" class="indexterm"/>interface. This interface makes available to the MDB the <a id="id312" class="indexterm"/>
<code class="literal">onMessage</code> method that will be called each time a new message is posted in the queue associated with the bean. That's why you have to put inside this method the business logic for the processing of incoming messages. The following code gives an example of an MDB that notifies you when a new message arrives by writing in the console:</p><div class="informalexample"><pre class="programlisting">@MessageDriven(activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationType", 
                               propertyValue = "javax.jms.Queue"),
    @ActivationConfigProperty(propertyName = "destinationLookup", 
                              propertyValue = "jms/messageQueue")
})
public class MessageBeanExample implements MessageListener {
    
    public MessageBeanExample() {
    }
    
    @Override
    public void onMessage(Message message) {
        try{
          System.out.println("You have received a new message of type : "+message.getJMSType());
        }catch(Exception ex){
            ex.printStackTrace();
        }
    }
}</pre></div><p>Given the changes in JMS 2.0 Specification, the EJB 3.2 Specification has a revised list of JMS MDB activation properties to conform to the list of standard properties. These properties are: <code class="literal">destinationLookup</code>, <code class="literal">connectionFactoryLookup</code>, <code class="literal">clientId</code>, <code class="literal">subscriptionName</code>, and <code class="literal">shareSubscriptions</code>. In addition, it has added the ability in MDB to implement a no-method message listener, resulting in the exposure of all public methods of the bean as message listener methods.</p></div><div class="section" title="Other improvements"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec37"/>Other improvements</h3></div></div></div><p>As we said earlier, the EJB 3.1 <a id="id313" class="indexterm"/>Specification has given developers the opportunity to test EJB applications outside a full Java EE server. This was made possible through an embeddable <code class="literal">EJBContainer</code>. The following example demonstrates how to test an EJB using an embeddable <code class="literal">EJBContainer</code>:</p><div class="informalexample"><pre class="programlisting">@Test
public void testAddition(){            
    Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();  
    properties.put(EJBContainer.APP_NAME, "chapter05EmbeddableEJBContainer");
    properties.put(EJBContainer.MODULES, new File("target\\classes"));   
    EJBContainer container = javax.ejb.embeddable.EJBContainer.createEJBContainer(properties);
    try {
        NewSessionBean bean = (NewSessionBean) container.getContext().lookup("java:global/chapter05EmbeddableEJBContainer/NewSessionBean");
        int restult = bean.addition(10, 10);
        Assert.assertEquals(20, restult);
    } catch (NamingException ex) {
        Logger.getLogger(AppTest.class.getName()).log(Level.FINEST, null, ex);
    } finally {
       container.close();
    }
}</pre></div><p>Since the embeddable <code class="literal">EJBContainer</code> <a id="id314" class="indexterm"/>reference by maven was not up-to-date while writing this book (which caused the error "<code class="literal">No EJBContainer provider available</code>"), I directly addressed the <code class="literal">glassfish-embedded-static-shell.jar</code> file in the following way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Maven variable declaration:<div class="informalexample"><pre class="programlisting">&lt;properties&gt;
   &lt;glassfish.installed.embedded.container&gt;glassfish_dir\lib\embedded\glassfish-embedded-static-shell.jar&lt;/glassfish.installed.embedded.container&gt;
&lt;/properties&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Declaration of dependence:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;glassfish-embedded-static-shell&lt;/groupId&gt;
    &lt;artifactId&gt;glassfish-embedded-static-shell&lt;/artifactId&gt;
    &lt;version&gt;3.2&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;           
    &lt;systemPath&gt;${glassfish.installed.embedded.container}&lt;/systemPath&gt;
&lt;/dependency&gt;</pre></div></li></ul></div><p>During operation, the embeddable <code class="literal">EJBContainer</code> acquires resources that would normally be released at the end of the process to allow other applications to take advantage of the maximum power of the machine. In the previous version of the specification, a developer used the <a id="id315" class="indexterm"/>
<code class="literal">EJBContainer.close()</code> method in a <code class="literal">finally</code> block to perform this task. But, with the <code class="literal">try-with-resources</code> statement introduced in Java SE 7, EJB 3.2 added the implementation of the <a id="id316" class="indexterm"/>
<code class="literal">java.lang.AutoCloseable</code> interface in the <a id="id317" class="indexterm"/>
<code class="literal">EJBContainer</code> class to free the developer from a task that could easily be forgotten and have negative repercussions on the performance of a machine. Now, the embeddable <code class="literal">EJBContainer</code> will be automatically <a id="id318" class="indexterm"/>closed at the end of a statement, provided that it is declared as a resource in a <code class="literal">try-with-resources</code> statement. Thus, we no longer need a <code class="literal">finally</code> block like in the earlier example, which simplifies the code. The following example demonstrates how to take advantage of the <code class="literal">try-with-resources</code> <a id="id319" class="indexterm"/>statement while testing EJB with an embeddable <code class="literal">EJBContainer</code>:</p><div class="informalexample"><pre class="programlisting">@Test
public void testAddition(){
    //...           
    try(EJBContainer container = javax.ejb.embeddable.EJBContainer.createEJBContainer(properties);) {
         //...
    } catch (NamingException ex) {
       Logger.getLogger(AppTest.class.getName()).log(Level.FINEST, null, ex);
    }
}</pre></div><p>The final improvement of this specification concerns removal of the restriction on obtaining the current class loader when you want to access files or directories in the file system from a bean.</p></div></div></div></div>
<div class="section" title="Putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Putting it all together</h1></div></div></div><p>The example that will allow us to put together most of the APIs already studied since the first chapter, is an online preregistration site. In this example, we will not write any code. We limit ourselves to the presentation of an analysis of a problem that will help you understand how to use each of the pieces of code that are used to illustrate points in this book, in order to make a quality application based on the latest functionality of Java EE 7.</p><div class="section" title="Presenting the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Presenting the project</h2></div></div></div><p>The virtual enterprise software technology has received from a private university the order for creating an application to manage the preregistration of students online (candidate registration, validation of applications, and notifications of different candidates) and provide a real-time chat room for connected students. Furthermore, for statistical purposes, the system will allow the ministry of education access to certain information from a heterogeneous application.</p><p>The system called <code class="literal">ONPRINS</code> <a id="id320" class="indexterm"/>must be robust, efficient, and available 24 x 7 during periods of registration.</p><p>The business domain model in the following diagram represents the main objects of our system (the required application will be built based on these objects):</p><div class="mediaobject"><img src="graphics/9235OT_05_02.jpg" alt="Presenting the project"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p><span class="strong"><strong>Disclaimer</strong></span></p><p>These diagrams have been designed and built in Enterprise Architect, by Sparx Systems.</p></div></div></div><div class="section" title="Use Case Diagram (UCD)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Use Case Diagram (UCD)</h2></div></div></div><p>The following diagram represents all the features that will be supported by our system. We have three actors as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Candidate is any user wishing <a id="id321" class="indexterm"/>to preregister for a department. To this end, it has the ability to view the list of departments, select a department, and complete and submit the application form. Through a chat room, he/she can share his/her ideas with all candidates connected with respect to a given theme.</li><li class="listitem" style="list-style-type: disc">An Administrator is a special user who has the right to run the validation process of preregistration. It is this process that creates the students and sends e-mails to different candidates to let them know whether they have been selected or not.</li><li class="listitem" style="list-style-type: disc">The Ministry of Education is a secondary actor of the system; it seeks access to the number of preregistered students and the list of students during an academic year.<div class="mediaobject"><img src="graphics/9235OT_05_03.jpg" alt="Use Case Diagram (UCD)"/></div></li></ul></div></div><div class="section" title="Class diagram"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Class diagram</h2></div></div></div><p>The following class diagram <a id="id322" class="indexterm"/>shows all the main classes used for the realization of our online preregistration. This diagram also highlights the relationships that exist between different classes.</p><p>The <code class="literal">CandidateSessionBean</code> <a id="id323" class="indexterm"/>class is a bean that records the preregistration of <a id="id324" class="indexterm"/>candidates through <code class="literal">registerCandidate</code> method. It also provides methods for accessing all the registered candidates (<code class="literal">listOfCandidates</code>) and preregistered students (<code class="literal">listOfStudents</code>).</p><p>The <code class="literal">InscriptionValidationBean</code> <a id="id325" class="indexterm"/>class contains the <code class="literal">startValidationBatchJob</code> <a id="id326" class="indexterm"/>method which, as its name suggests, launches batch processing to validate the preregistration and notify different candidates. Batch processing presented here is the chunk type in which the <code class="literal">ValidationReader</code> <a id="id327" class="indexterm"/>class is used to read the data useful for validation, <a id="id328" class="indexterm"/>the <code class="literal">ValidationProcessor</code> class is used to validate the preregistration, and the <code class="literal">ValidationWriter</code> <a id="id329" class="indexterm"/>class is used to notify the candidate. This class also serves to create a student when the candidate is selected. As you can see, in order to send an e-mail, the <a id="id330" class="indexterm"/>
<code class="literal">ValidationWriter</code> class firstly sends a JMS message through <code class="literal">MsgSenderSessionBean</code> to the component responsible for sending the e-mail. This allows us to avoid blockages in <code class="literal">ValidationWriter</code> when there is a <a id="id331" class="indexterm"/>connection breakdown. Also, in the batch process, we have the listener <code class="literal">ValidationJobListener</code>, which enables us to record a certain amount of information in the validation table at the end of batch processing.</p><p>For the sake of simplicity and <a id="id332" class="indexterm"/>reusability, navigation between web pages during the preregistration of a candidate (<code class="literal">departmentList.xhtml</code>, <code class="literal">acceptanceConditions.xhtml</code>, <code class="literal">identificationInformation.xhtml</code>, <code class="literal">contactInformation.xhtml</code>, <code class="literal">medicalInformation.xhtml</code>, <code class="literal">schoolInformation.xhtml</code>, and <code class="literal">InformationValidation.xhtml</code>) will be made using the Faces Flow. On the other hand, the content of various pages will be structured with the Resource Library Contracts and communication in the chat room will be managed using WebSocket; it is for this reason <a id="id333" class="indexterm"/>that you have the <code class="literal">ChatServerEndPoint</code> class, which is the server endpoint for this communication.</p><p>The execution of the validation process <a id="id334" class="indexterm"/>of preregistration is made from the <code class="literal">inscriptionValidation.xhtml</code> facelet. In order to give the administrator a feedback on the progress of the validation process, the facelet will contain a progress bar updated in real time, which leads us once again to use the WebSocket protocol.</p><div class="mediaobject"><img src="graphics/9235OT_05_04.jpg" alt="Class diagram"/></div></div><div class="section" title="Component diagram"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Component diagram</h2></div></div></div><p>The following diagram shows the <a id="id335" class="indexterm"/>various components that constitute our system. As you can see, the exchange of data between the application of the ministry and <code class="literal">ONPRINS</code> will be through web services, which aims to make both systems completely independent from one another, while our system uses a connector to have access to user information stored on the <a id="id336" class="indexterm"/>ERP system of the university.</p><div class="mediaobject"><img src="graphics/9235OT_05_05.jpg" alt="Component diagram"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>As promised, in this chapter we presented the innovations introduced by EJBs, and then focused on the analysis and design of an application for online preregistration. In this exercise, we were able to look at practical cases allowing us to use almost all of the concepts already discussed (WebSocket and Faces Flow) and discover new concepts (web service, connector, and Java e-mail). In the next chapter, we will focus on these new concepts in order to try to answer the following question: when and how should we implement these concepts?</p></div></body></html>