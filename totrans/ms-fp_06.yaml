- en: Effect Types in Practice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的效果类型
- en: In the previous chapters, we saw that the general pattern for abstracting away
    side effects is to use effect types. This pattern allows you to reduce the mental
    load on your mind. The pattern states that we first define an effect type and
    then represent every occurrence of a particular side effect with this type. In
    this chapter, we will see more examples of real-world effect types and when to
    use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了抽象副作用的一般模式是使用效果类型。这种模式允许你减轻心理负担。该模式指出，我们首先定义一个效果类型，然后使用此类型表示特定副作用的所有发生。在本章中，我们将看到更多关于现实世界效果类型的示例以及何时使用它们。
- en: 'More precisely, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，我们将涵盖以下主题：
- en: '`Future`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`'
- en: '`Either`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either`'
- en: '`Reader`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reader`'
- en: Future
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来
- en: The first effect type we will be looking at is Future. This effect is frequently encountered
    in a wide range of projects, even in non-functional languages. If you have substantial
    experience in Java regarding writing concurrent and asynchronous applications,
    you probably already know about this type of effect.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个效果类型是未来。这种效果在广泛的项目中经常遇到，甚至在非功能语言中也是如此。如果你在Java中有关编写并发和异步应用程序的丰富经验，你可能已经了解这种类型的效果。
- en: First, let's take a look at the phenomenon that the effect type abstracts and
    the motivation behind why such an effect type may be needed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看效果类型抽象的现象以及为什么可能需要这种效果类型的动机。
- en: Motivation and the imperative example
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机和命令式示例
- en: Consider the following example. Say you are developing a calendar application
    to compose a user's daily schedule. This application allows the user to write
    their plans for the Future into the database. For example, if they have a meeting
    with somebody, they can create a separate entry in the database, specifying when and
    where it will take place.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。假设你正在开发一个日历应用程序来编写用户的日常日程。此应用程序允许用户将未来的计划写入数据库。例如，如果他们与某人有一个会议，他们可以在数据库中创建一个单独的条目，指定何时以及在哪里举行。
- en: They may also want to add a weather forecast integration into the app. They
    would like to warn their users whenever they have outdoor activities in unfavorable
    weather conditions. For example, an outdoor picnic party is undesirable in rainy
    weather. One way to help the user avoid such situations is to make the application
    contact a weather forecast server and see whether the weather on the given day
    is satisfying or not.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还可能希望将天气预报集成到应用程序中。他们希望在用户有户外活动且天气条件不利时提醒他们。例如，在雨天举办户外野餐派对是不受欢迎的。帮助用户避免这种情况的一种方法是通过使应用程序联系天气预报服务器，看看给定日期的天气是否令人满意。
- en: 'For any given event, this process can be done with the following algorithm:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的事件，这个过程可以用以下算法来完成：
- en: Retrieve an event from the database based on its ID
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据事件的ID从数据库中检索事件
- en: Retrieve the date and the place of the event
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索事件的时间和地点
- en: Contact a weather forecast server and provide it with the date and place we
    are interested in, and retrieve the weather forecast
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系天气预报服务器，并给它提供我们感兴趣的日期和地点，然后检索天气预报
- en: If the weather is bad, we can send a notification to the user
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果天气不好，我们可以向用户发送通知
- en: 'The preceding algorithm can be implemented as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述算法可以如下实现：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The methods are defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is one effect that can cause trouble in the preceding example. It takes
    time to connect to the database, and it takes even more time to contact the weather
    server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，有一个可能引起麻烦的效果。连接到数据库需要时间，而联系天气服务器则需要更多的时间。
- en: If we perform all of these operations sequentially from the application's main
    thread, as in the preceding example, we are risking blocking this thread. Blocking
    the main application thread means that the application will become unresponsive.
    One standard way to avoid this experience is to run all of these time-consuming
    computations in separate threads. However, it is quite common for asynchronous
    applications to specify every computation in a non-blocking manner. It is not
    common to have blocking methods; rather, every method is supposed to return an
    asynchronous primitive representing the computation immediately.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像前一个示例那样从应用程序的主线程顺序执行所有这些操作，我们就有阻塞这个线程的风险。阻塞主应用程序线程意味着应用程序将变得无响应。避免这种体验的一种标准方法是在单独的线程中运行所有这些耗时计算。然而，在异步应用程序中，通常以非阻塞方式指定每个计算。阻塞方法并不常见；相反，每个方法都应该立即返回一个表示计算的异步原语。
- en: 'The simplest implementation of this idea in Java is to run every computation
    in a separate thread:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，这种想法的最简单实现是在单独的线程中运行每个计算：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The three business logic methods get their own threads. The `thread` and `runThread`
    methods are defined as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 三个业务逻辑方法各自有自己的线程。`thread`和`runThread`方法定义如下：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can run this application as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式运行此应用程序：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, every subsequent computation is invoked at the end of every previous computation
    because the subsequent computation depends on the result of the computation that
    precedes it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个后续计算都在每个先前计算结束后调用，因为后续计算依赖于先前计算的结果。
- en: The code is hard to read, and the execution flow is difficult to follow. Therefore,
    it is smart to abstract away the sequential composition of these computations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码难以阅读，执行流程难以跟踪。因此，抽象出这些计算的顺序组合是明智的。
- en: Abstraction and the functional example
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象和函数式示例
- en: Let's look at a functional way of writing this example. In the functional world,
    one abstraction to deal with asynchronous computations is Future. Future has the
    following signature—`Future[A]`. This type represents a computation that runs
    in a separate thread and computes some result, which in our case is `A`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以函数式方式编写这个示例。在函数式世界中，处理异步计算的一个抽象是Future。Future具有以下签名——`Future[A]`。此类型表示在单独的线程中运行的计算，并计算一些结果，在我们的情况下是`A`。
- en: A common technique when dealing with Futures is to use callbacks to specify
    continuations of the computations. A continuation of a computation is an instruction
    on what to do after the computation has completed. A continuation has access to
    the result of the computation it continues. This is possible since it runs after
    the computation terminates.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`Future`时的一种常见技术是使用回调来指定计算的后续操作。计算的后续操作是在计算完成后要执行的指令。后续操作可以访问它所继续的计算的结果。这是可能的，因为它在计算终止后运行。
- en: 'In most implications of the `Future` data type, the callback pattern is present
    in one form or another. For example, in the Scala implementation of `Future`,
    you can specify the continuation of a function as a callback using the `onSuccess`
    method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数关于`Future`数据类型的用法中，回调模式以某种形式存在。例如，在Scala的`Future`实现中，你可以使用`onSuccess`方法将函数的后续操作指定为回调：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we can start the new Futures after the previous Futures
    terminate using the results they computed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们可以在先前的Future终止后使用它们计算的结果启动新的Future。
- en: Also, note the `implicit val` that we defined before running the Future. It
    brings into scope an implicit execution context for the Future. Future is an asynchronous
    computation that runs in a separate thread. Which thread does it run on, precisely?
    How do we control how many threads there are and whether or not the threads are
    reused? We need a specification of a threading strategy when running Futures.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们在运行Future之前定义的`implicit val`。它为Future引入了一个隐式的执行上下文。Future是一个在单独的线程中运行的异步计算。它确切地运行在哪个线程上？我们如何控制线程的数量以及是否重用线程？在运行Future时，我们需要一个线程策略的规范。
- en: In the Scala implementation of the Future type, we are using Scala's mechanism
    of implicits to bring the threading context in scope. However, in other languages,
    you should expect that similar controls of the Futures' threading strategy will
    exist.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Future类型的Scala实现中，我们使用Scala的隐式机制将线程上下文引入作用域。然而，在其他语言中，你应该期望存在类似的控制Future线程策略的方法。
- en: Composing Futures
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写未来
- en: A situation where we need to run one computation after another in an asynchronous
    manner is a frequent pattern. One way to solve this task is via callbacks, as
    we have seen previously. Every asynchronous computation is a separate entity and
    is started from a callback that's registered on another computation it depends
    upon.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在异步方式下依次运行多个计算的情况是一个常见的模式。解决这个任务的一种方法是通过回调，正如我们之前所看到的。每个异步计算都是一个独立的实体，并且从一个回调开始，该回调注册在它所依赖的另一个计算上。
- en: Another way of conceptualizing such a pattern is to treat Futures as composable
    entities. The concept in question is the ability to compose two Futures into one.
    The semantics of the combined `Future` is a sequential execution of the second
    `Future` after the first one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种构想这种模式的方式是将Futures视为可组合的实体。所涉及的概念是将两个Futures组合成一个的能力。组合的`Future`的语义是在第一个`Future`之后顺序执行第二个`Future`。
- en: So, given a Future for contacting the database and a `Future` for contacting
    the weather forecast server, we can create a `Future` that combines both sequentially,
    with the second one being able to use the result of the first one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定一个用于联系数据库的Future和一个用于联系天气预报服务器的Future，我们可以创建一个将两者顺序组合的Future，第二个Future能够使用第一个Future的结果。
- en: 'The sequential composition is facilitated using the `flatMap` method, which
    we are already familiar with from the previous chapter. So, our example can be
    implemented as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们已经在上一章中熟悉的`flatMap`方法，我们可以方便地进行顺序组合。因此，我们的示例可以这样实现：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `for` comprehension is shorthand for sequentially calling `flatMap`. This
    technique is called the **Monadic flow**, and is present in some functional languages,
    including Scala and Haskell. The preceding Scala code is syntactic sugar for the
    following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`推导式是顺序调用`flatMap`的简写。这种技术被称为**单调流**，存在于一些函数式语言中，包括Scala和Haskell。前面的Scala代码是以下代码的语法糖：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: flatMap generalized
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`flatMap`的推广'
- en: In the previous chapter, we have already seen `flatMap` in the context of the
    `Try` type. It was conceptualized as a continuation of a computational that may
    result in an error. We can extrapolate this conceptualization to the case of Futures.
    The same way as `flatMap` was a conceptualization of a continuation of an error-prone
    computation in the case of `Try`,  it is a continuation of an asynchronous computation
    in the case of Future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经看到了在`Try`类型上下文中`flatMap`的使用。它被构想为一个可能产生错误的计算的后继。我们可以将这种构想推广到Futures的情况。正如`flatMap`在`Try`的情况下被构想为一个可能产生错误的计算的后继一样，在Future的情况下，它是一个异步计算的后继。
- en: The role of the `flatMap` function is more or less the same in the case of any
    effect type you deal with. It is a continuation of a computation that produces
    a side effect with another computation that produces the same side effect, but
    requires the result of the first computation to proceed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`函数在处理任何效果类型时的作用大致相同。它是一个产生副作用并带有另一个产生相同副作用但需要第一个计算结果来继续的后继计算。'
- en: Similarly to the way we used it in the case of `Try` in the previous chapter,
    we can also define a signature of `flatMap` for Futures as follows—`(A => Future[B])
    => (Future[A] => Future[B])`. Another way to look at this `flatMap` function is
    that it is a lift. The `flatMap` lifts a function that produces the Future side
    effect and depends on some value, such as `(A => Future[B])`, to a function that
    does the same thing the original function did, but depends on the `Future[A]`
    (`Future[A] => Future[B]`) value. That is, the dependency is no longer available
    in a raw format, but is computed by another computation that produces the Future
    side effect.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在上一章中在`Try`的情况下使用它的方式，我们也可以为Futures定义一个`flatMap`的签名，如下所示—`(A => Future[B])
    => (Future[A] => Future[B])`。另一种看待这个`flatMap`函数的方式是，它是一个提升。`flatMap`将产生Future副作用并依赖于某些值（如`(A
    => Future[B])`）的函数提升为一个执行与原始函数相同操作但依赖于`Future[A]`（`Future[A] => Future[B]`）值的函数。也就是说，依赖不再以原始格式存在，而是由另一个产生Future副作用的计算来计算。
- en: It should be mentioned that Futures are not specific to functional programming.
    You can encounter them in lots of other languages, such as Java, JavaScript, Python,
    and many others. Asynchronous computations are so ubiquitous that it is natural
    that programmers devised a primitive to abstract their complexity away. However,
    in functional programming languages, such as Scala or Haskell, Future gets a functional
    twist to it, as we have seen previously.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到的是，Futures 并非仅限于函数式编程。你可以在许多其他语言中遇到它们，例如 Java、JavaScript、Python 以及许多其他语言。异步计算如此普遍，程序员设计出一种原始类型来抽象它们的复杂性是自然而然的。然而，在函数式编程语言，如
    Scala 或 Haskell 中，Future 获得了一种我们之前看到的功能性扭曲。
- en: Let's continue our exploration of side effects and what you can do with them
    by using an example with `Either`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个使用 `Either` 的例子来继续探索副作用以及你可以如何使用它们。
- en: Either
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Either
- en: '`Either` is an effect that is similar to the `Try` effect that we encountered
    in the previous chapters.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 是一种类似于我们在前几章中遇到过的 `Try` 效果。'
- en: 'If you remember, `Try` is a structure that can contain either of two values—an
    exception, or the result of the computation. Let''s briefly recall our division
    by zero example from the previous chapters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`Try` 是一个可以包含两个值之一的结构——一个异常或计算的结果。让我们简要回顾一下前几章中的除以零的例子：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, in the case of success, we create a `Success` data structure. In case
    of failure, we need to create an exception with a specific error message.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在成功的情况下，我们创建一个 `Success` 数据结构。在失败的情况下，我们需要创建一个带有特定错误信息的异常。
- en: Is it essential to create an exception here? The useful payload is the error
    message, after all. Exceptions are needed in cases where they are thrown with
    the `throw` statement. However, as we discussed in previous chapters, functional
    programming avoids such a side effect, rectifying it into an effect type instead.
    If we are not throwing an exception, then what is the point of explicitly creating
    and wrapping it in the `Failure` data structure? A more efficient way of doing
    things would be to return a raw error message such as a `String`, not an exception
    with this error message. However, when you look at the signature of the `Failure`
    data structure, you will see that it can only contain the subclasses of `Throwable`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里创建异常是必要的吗？毕竟，有用的负载是错误信息。异常在它们被 `throw` 语句抛出时是需要的。然而，正如我们在前几章中讨论的，函数式编程避免这种副作用，而是将其修正为效果类型。如果我们没有抛出异常，那么在
    `Failure` 数据结构中显式创建和包装它的意义何在？更有效的方法是返回一个原始的错误信息，例如一个 `String`，而不是带有这个错误信息的异常。然而，当你查看
    `Failure` 数据结构的签名时，你会发现它只能包含 `Throwable` 的子类。
- en: To be able to return a string instead of an exception in an erroneous case,
    we can use another data type: `Either`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在错误情况下返回一个字符串而不是异常，我们可以使用另一种数据类型：`Either`。
- en: '`Either` represents an alternative between two values. If `Try` is an alternative
    between an exception and a result, then `Either` is an alternative between two
    arbitrary types. It has two subclasses. So, a value with type `Either[A, B]` can
    be either `Right[B]` or `Left[A]`. Traditionally, the right case is reserved for
    the results of successful computations, and the left case is reserved for errors.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 表示两个值之间的一个选择。如果 `Try` 是异常和结果之间的一个选择，那么 `Either` 就是任意两种类型之间的一个选择。它有两个子类。因此，类型为
    `Either[A, B]` 的值可以是 `Right[B]` 或 `Left[A]`。传统上，右侧用于成功计算的结果，而左侧用于错误。'
- en: 'Let''s take a look at how our division by zero example can be improved with
    this new data structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个新的数据结构改进我们的除以零的例子：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We no longer need to wrap the error message in an exception. We can return our
    error message directly. The result type of the function is now `Either[String,
    Double]`, where `String` is the way we represent an error, and `Double` is the
    result type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要将错误信息包装在异常中。我们可以直接返回错误信息。函数的结果类型现在是 `Either[String, Double]`，其中 `String`
    是我们表示错误的方式，而 `Double` 是结果类型。
- en: It should be noted that the notion of an alternative can be taken further. `Either`
    is not the only data type that is used to abstract away alternatives. As you may
    have noticed, `Either` can be either of two values, but not both at the same time,
    or none.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，替代的概念可以进一步扩展。`Either` 不是唯一用于抽象替代的数据类型。正如你可能注意到的，`Either` 可以是两个值中的任意一个，但不能同时是两个，也不能是两者都不是。
- en: Whenever you have a use case where you have two values at the same time, or
    when you have an empty alternative, you may want to use other effect types that
    are tailored specifically to this use case. Libraries for functional programming
    for languages such as Scala or Haskell provide such types. In Scala, for example,
    the library called `cats` provides the data type `Ior`, which may contain two
    values at the same time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你有一个同时拥有两个值的用例，或者当你有一个空的选择时，你可能希望使用其他专门针对此用例的效果类型。为Scala或Haskell等语言提供的函数式编程库提供此类类型。例如，在Scala中，名为`cats`的库提供了可以同时包含两个值的`Ior`数据类型。
- en: One use case where we may want to have two values at the same time is for presenting
    warnings. If errors can be understood as fatal occurrences that terminate a computation
    without producing a result, warnings are notifications that tell you that something
    went wrong in the computation, but that it was able to terminate successfully.
    In such a scenario, you may want to have a data structure that can contain both
    the computed value and the generated warnings at the same time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望同时拥有两个值的用例之一是用于显示警告。如果错误可以理解为导致计算终止而没有产生结果的致命事件，那么警告就是通知你计算中出了问题，但它能够成功终止。在这种情况下，你可能需要一个可以同时包含计算值和生成的警告的数据结构。
- en: Errors and asynchronous computations are not the only domain tackled by effect
    types. Now, let's take a look at how the problem of dependency injection is solved
    in a purely functional way. Let's take a look at the `Reader` type.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和异步计算并不是效果类型所解决的唯一领域。现在，让我们看看如何以纯函数式的方式解决依赖注入的问题。让我们来看看`Reader`类型。
- en: Reader
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reader
- en: Dependency injection is a mechanism that defines how parts of your program should
    access other parts of the same program or external resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种机制，它定义了程序的部分应该如何访问同一程序的其他部分或外部资源。
- en: 'Let''s consider a scenario where dependency injection becomes relevant. For
    example, consider you are writing an application with a database for a bank. The
    application will include methods for reading and writing the objects of your business
    domain into the database. For example, you may have a method to create a new user
    and a method to create a new account for them. These methods depend on the connection
    to the database. One way to inject this dependency is to pass the database connection
    object into the methods as arguments:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个依赖注入变得相关的场景。例如，假设你正在编写一个银行为数据库编写应用程序。该应用程序将包括将你的业务域对象读入和写入数据库的方法。例如，你可能有一个创建新用户的方法和一个为他们创建新账户的方法。这些方法依赖于数据库连接。注入这种依赖的一种方法是将数据库连接对象作为参数传递给这些方法：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding types are defined as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类型定义如下：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, this clutters the signatures of the methods. Also, other methods that
    call the database, such as dependent methods, get cluttered because they need
    the database connection object to satisfy the dependency of the methods they call.
    For example, imagine a business logic method that creates a new user and an account
    for them at the same time:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会使方法的签名变得杂乱。此外，调用数据库的其他方法，如依赖方法，也会变得杂乱，因为它们需要数据库连接对象来满足它们所调用方法的依赖。例如，想象一个业务逻辑方法，它同时为用户创建一个新账户和一个账户：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is composed of two database calls, and since each of these calls depends
    on a database connection, this method must also depend on a database connection.
    Hence, you must provide a database connection as an argument to the business logic
    method. Providing the dependency as an argument is not very convenient as it brings
    the connection object into your focus. On the business logic layer, you want to
    focus on the business logic and not on the details of how the database connection
    works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它由两个数据库调用组成，并且由于每个调用都依赖于数据库连接，因此此方法也必须依赖于数据库连接。因此，你必须将数据库连接作为参数提供给业务逻辑方法。将依赖作为参数提供并不方便，因为它将连接对象引入了你的关注点。在业务逻辑层，你希望专注于业务逻辑，而不是数据库连接的工作细节。
- en: Functional solution
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式解决方案
- en: 'One solution that functional programming provides for the problem of dependency
    injection is that it can treat dependency requirement as a function defined with
    the dependency as an argument and then abstract this function away. If we want
    to do this, then first we have to define our database access methods as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程为依赖注入问题提供的一种解决方案是，它可以把依赖需求视为一个以依赖项作为参数定义的函数，然后抽象出这个函数。如果我们想这样做，那么首先我们必须定义我们的数据库访问方法如下：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The approach states that whenever we have a computation that depends on some
    external resource, we model this dependency as a function that accepts this resource
    as an argument. So, when we have a method that is supposed to create a user, it
    does not perform the computation itself. Rather, it returns a function that performs
    the computation, provided you supply it with the database connection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法表明，每当有一个依赖于某些外部资源的计算时，我们将这种依赖建模为一个接受此资源作为参数的函数。因此，当我们有一个应该创建用户的函数时，它本身并不执行计算。相反，它返回一个执行计算的函数，前提是你提供了数据库连接。
- en: 'Here''s how to express the business logic method in this setting:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置下，如何表达业务逻辑方法如下：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This approach is not very different from the approach of having an extra argument
    in the functions. However, this is the first step of the abstraction process,
    and this step is to bring focus onto the effect we are abstracting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与在函数中添加额外参数的方法并没有太大的不同。然而，这是抽象过程的第一个步骤，这个步骤是为了将注意力集中在我们要抽象的效果上。
- en: 'The second step is to abstract away these functions. One way to do this is
    to treat the functions as effects. This effect is used so that the computation
    represented by this function cannot be performed unless you provide it with its
    dependency—the argument of the function. Consider our already familiar example
    that has been rewritten with the help of the `Reader` effect type:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是抽象出这些函数。实现这一目标的一种方法是将这些函数视为效果。这个效果被用来确保除非你提供其依赖项——函数的参数，否则无法执行由这个函数表示的计算。考虑我们已熟悉的例子，这个例子在`Reader`效果类型的帮助下被重新编写：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Reader` can be defined as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`可以定义为如下：'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that the pattern of `flatMap` and the effect types are repeating
    again. Previously, we saw the side effects of asynchronous computation and errors.
    All of them were represented by separate data structures—`Future` and `Either`
    (and `Try`). Now, we can see an effect of dependency. That is, the effect is that
    the computation is unable to be executed unless a specific resource demand is
    satisfied. This effect, too, is modeled by its own effect type: `Reader`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`flatMap`模式和效果类型正在重复出现。之前，我们看到了异步计算和错误的副作用。所有这些都由单独的数据结构表示——`Future`和`Either`（以及`Try`）。现在，我们可以看到依赖的效果。也就是说，这种效果是计算无法执行，除非满足特定的资源需求。这种效果也由其自己的效果类型`Reader`来建模：
- en: As we stated previously, we provided the `flatMap` method for the `Reader` class.
    The meaning of this method is the same as in the cases of `Future` and `Try`.
    That is, to perform a continuation on a side effecting computation. This method
    can be used in the setting of a business logic method that relies on the `createUser`
    and `createAccount` methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，我们为`Reader`类提供了`flatMap`方法。这个方法的意义与`Future`和`Try`的情况相同。也就是说，对副作用计算执行后续操作。这个方法可以在依赖于`createUser`和`createAccount`方法的业务逻辑方法设置中使用。
- en: 'Notice that `Readers` are essentially functions. This means that you cannot
    run them until you provide the dependencies they require. To do so, you can call
    a method that is usually defined in the API of the `Reader` data structure. In
    our case, according to the definition of the preceding `Reader` class, this can
    be done as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Readers`本质上就是函数。这意味着你无法在没有提供它们所需的依赖项之前运行它们。为此，你可以调用通常定义在`Reader`数据结构API中的一个方法。在我们的例子中，根据前面定义的`Reader`类，可以这样操作：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were armed with the theoretical foundations of effects,
    what they are, and why they are needed. We took a look at some examples of effects
    types which are frequently encountered in practice. We have seen how the `Future`
    type abstracts away asynchronous computations. We also looked at the `Either`
    type, which is similar to `Try`, but allows alternative representations for errors.
    Finally, we covered the `Reader` effect type, which abstracts away the effect
    of dependency. We also saw that `flatMap` is a typical pattern among effect types,
    which abstracts away the sequential composition of side effecting computations,
    and the effects of which are rectified into effect types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们掌握了效果的理论基础，即它们是什么，以及为什么需要它们。我们查看了一些在实践中最常遇到的效果类型示例。我们看到了 `Future` 类型如何抽象处理异步计算。我们还研究了
    `Either` 类型，它类似于 `Try`，但允许对错误进行不同的表示。最后，我们介绍了 `Reader` 效果类型，它抽象处理了依赖效果。我们还看到 `flatMap`
    是效果类型中的一个典型模式，它抽象处理了副作用计算的顺序组合，并将这些效果修正为效果类型。
- en: In the next chapter, we'll have a look at how to generalize patterns of working
    with effect types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何泛化处理效果类型的工作模式。
- en: Questions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does the `Future` effect type `abstract`?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Future` 效果类型是如何进行抽象的？'
- en: Why do we need the `Either` effect type if we already have the `Try` effect
    type?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们已经有 `Try` 效果类型，为什么还需要 `Either` 效果类型？
- en: How does functional programming represent dependency injection?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程如何表示依赖注入？
- en: What role does the `flatMap` function play in all of the effect types we have
    encountered?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们遇到的所有效果类型中，`flatMap` 函数扮演着什么角色？
