- en: Effect Types in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we saw that the general pattern for abstracting away
    side effects is to use effect types. This pattern allows you to reduce the mental
    load on your mind. The pattern states that we first define an effect type and
    then represent every occurrence of a particular side effect with this type. In
    this chapter, we will see more examples of real-world effect types and when to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'More precisely, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Future`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Either`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first effect type we will be looking at is Future. This effect is frequently encountered
    in a wide range of projects, even in non-functional languages. If you have substantial
    experience in Java regarding writing concurrent and asynchronous applications,
    you probably already know about this type of effect.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at the phenomenon that the effect type abstracts and
    the motivation behind why such an effect type may be needed.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation and the imperative example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the following example. Say you are developing a calendar application
    to compose a user's daily schedule. This application allows the user to write
    their plans for the Future into the database. For example, if they have a meeting
    with somebody, they can create a separate entry in the database, specifying when and
    where it will take place.
  prefs: []
  type: TYPE_NORMAL
- en: They may also want to add a weather forecast integration into the app. They
    would like to warn their users whenever they have outdoor activities in unfavorable
    weather conditions. For example, an outdoor picnic party is undesirable in rainy
    weather. One way to help the user avoid such situations is to make the application
    contact a weather forecast server and see whether the weather on the given day
    is satisfying or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any given event, this process can be done with the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve an event from the database based on its ID
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the date and the place of the event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contact a weather forecast server and provide it with the date and place we
    are interested in, and retrieve the weather forecast
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the weather is bad, we can send a notification to the user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding algorithm can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is one effect that can cause trouble in the preceding example. It takes
    time to connect to the database, and it takes even more time to contact the weather
    server.
  prefs: []
  type: TYPE_NORMAL
- en: If we perform all of these operations sequentially from the application's main
    thread, as in the preceding example, we are risking blocking this thread. Blocking
    the main application thread means that the application will become unresponsive.
    One standard way to avoid this experience is to run all of these time-consuming
    computations in separate threads. However, it is quite common for asynchronous
    applications to specify every computation in a non-blocking manner. It is not
    common to have blocking methods; rather, every method is supposed to return an
    asynchronous primitive representing the computation immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest implementation of this idea in Java is to run every computation
    in a separate thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The three business logic methods get their own threads. The `thread` and `runThread`
    methods are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, every subsequent computation is invoked at the end of every previous computation
    because the subsequent computation depends on the result of the computation that
    precedes it.
  prefs: []
  type: TYPE_NORMAL
- en: The code is hard to read, and the execution flow is difficult to follow. Therefore,
    it is smart to abstract away the sequential composition of these computations.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction and the functional example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a functional way of writing this example. In the functional world,
    one abstraction to deal with asynchronous computations is Future. Future has the
    following signature—`Future[A]`. This type represents a computation that runs
    in a separate thread and computes some result, which in our case is `A`.
  prefs: []
  type: TYPE_NORMAL
- en: A common technique when dealing with Futures is to use callbacks to specify
    continuations of the computations. A continuation of a computation is an instruction
    on what to do after the computation has completed. A continuation has access to
    the result of the computation it continues. This is possible since it runs after
    the computation terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most implications of the `Future` data type, the callback pattern is present
    in one form or another. For example, in the Scala implementation of `Future`,
    you can specify the continuation of a function as a callback using the `onSuccess`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can start the new Futures after the previous Futures
    terminate using the results they computed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note the `implicit val` that we defined before running the Future. It
    brings into scope an implicit execution context for the Future. Future is an asynchronous
    computation that runs in a separate thread. Which thread does it run on, precisely?
    How do we control how many threads there are and whether or not the threads are
    reused? We need a specification of a threading strategy when running Futures.
  prefs: []
  type: TYPE_NORMAL
- en: In the Scala implementation of the Future type, we are using Scala's mechanism
    of implicits to bring the threading context in scope. However, in other languages,
    you should expect that similar controls of the Futures' threading strategy will
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A situation where we need to run one computation after another in an asynchronous
    manner is a frequent pattern. One way to solve this task is via callbacks, as
    we have seen previously. Every asynchronous computation is a separate entity and
    is started from a callback that's registered on another computation it depends
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of conceptualizing such a pattern is to treat Futures as composable
    entities. The concept in question is the ability to compose two Futures into one.
    The semantics of the combined `Future` is a sequential execution of the second
    `Future` after the first one.
  prefs: []
  type: TYPE_NORMAL
- en: So, given a Future for contacting the database and a `Future` for contacting
    the weather forecast server, we can create a `Future` that combines both sequentially,
    with the second one being able to use the result of the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequential composition is facilitated using the `flatMap` method, which
    we are already familiar with from the previous chapter. So, our example can be
    implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` comprehension is shorthand for sequentially calling `flatMap`. This
    technique is called the **Monadic flow**, and is present in some functional languages,
    including Scala and Haskell. The preceding Scala code is syntactic sugar for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: flatMap generalized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we have already seen `flatMap` in the context of the
    `Try` type. It was conceptualized as a continuation of a computational that may
    result in an error. We can extrapolate this conceptualization to the case of Futures.
    The same way as `flatMap` was a conceptualization of a continuation of an error-prone
    computation in the case of `Try`,  it is a continuation of an asynchronous computation
    in the case of Future.
  prefs: []
  type: TYPE_NORMAL
- en: The role of the `flatMap` function is more or less the same in the case of any
    effect type you deal with. It is a continuation of a computation that produces
    a side effect with another computation that produces the same side effect, but
    requires the result of the first computation to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the way we used it in the case of `Try` in the previous chapter,
    we can also define a signature of `flatMap` for Futures as follows—`(A => Future[B])
    => (Future[A] => Future[B])`. Another way to look at this `flatMap` function is
    that it is a lift. The `flatMap` lifts a function that produces the Future side
    effect and depends on some value, such as `(A => Future[B])`, to a function that
    does the same thing the original function did, but depends on the `Future[A]`
    (`Future[A] => Future[B]`) value. That is, the dependency is no longer available
    in a raw format, but is computed by another computation that produces the Future
    side effect.
  prefs: []
  type: TYPE_NORMAL
- en: It should be mentioned that Futures are not specific to functional programming.
    You can encounter them in lots of other languages, such as Java, JavaScript, Python,
    and many others. Asynchronous computations are so ubiquitous that it is natural
    that programmers devised a primitive to abstract their complexity away. However,
    in functional programming languages, such as Scala or Haskell, Future gets a functional
    twist to it, as we have seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue our exploration of side effects and what you can do with them
    by using an example with `Either`.
  prefs: []
  type: TYPE_NORMAL
- en: Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Either` is an effect that is similar to the `Try` effect that we encountered
    in the previous chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, `Try` is a structure that can contain either of two values—an
    exception, or the result of the computation. Let''s briefly recall our division
    by zero example from the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the case of success, we create a `Success` data structure. In case
    of failure, we need to create an exception with a specific error message.
  prefs: []
  type: TYPE_NORMAL
- en: Is it essential to create an exception here? The useful payload is the error
    message, after all. Exceptions are needed in cases where they are thrown with
    the `throw` statement. However, as we discussed in previous chapters, functional
    programming avoids such a side effect, rectifying it into an effect type instead.
    If we are not throwing an exception, then what is the point of explicitly creating
    and wrapping it in the `Failure` data structure? A more efficient way of doing
    things would be to return a raw error message such as a `String`, not an exception
    with this error message. However, when you look at the signature of the `Failure`
    data structure, you will see that it can only contain the subclasses of `Throwable`.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to return a string instead of an exception in an erroneous case,
    we can use another data type: `Either`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Either` represents an alternative between two values. If `Try` is an alternative
    between an exception and a result, then `Either` is an alternative between two
    arbitrary types. It has two subclasses. So, a value with type `Either[A, B]` can
    be either `Right[B]` or `Left[A]`. Traditionally, the right case is reserved for
    the results of successful computations, and the left case is reserved for errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how our division by zero example can be improved with
    this new data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to wrap the error message in an exception. We can return our
    error message directly. The result type of the function is now `Either[String,
    Double]`, where `String` is the way we represent an error, and `Double` is the
    result type.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the notion of an alternative can be taken further. `Either`
    is not the only data type that is used to abstract away alternatives. As you may
    have noticed, `Either` can be either of two values, but not both at the same time,
    or none.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have a use case where you have two values at the same time, or
    when you have an empty alternative, you may want to use other effect types that
    are tailored specifically to this use case. Libraries for functional programming
    for languages such as Scala or Haskell provide such types. In Scala, for example,
    the library called `cats` provides the data type `Ior`, which may contain two
    values at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: One use case where we may want to have two values at the same time is for presenting
    warnings. If errors can be understood as fatal occurrences that terminate a computation
    without producing a result, warnings are notifications that tell you that something
    went wrong in the computation, but that it was able to terminate successfully.
    In such a scenario, you may want to have a data structure that can contain both
    the computed value and the generated warnings at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Errors and asynchronous computations are not the only domain tackled by effect
    types. Now, let's take a look at how the problem of dependency injection is solved
    in a purely functional way. Let's take a look at the `Reader` type.
  prefs: []
  type: TYPE_NORMAL
- en: Reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a mechanism that defines how parts of your program should
    access other parts of the same program or external resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a scenario where dependency injection becomes relevant. For
    example, consider you are writing an application with a database for a bank. The
    application will include methods for reading and writing the objects of your business
    domain into the database. For example, you may have a method to create a new user
    and a method to create a new account for them. These methods depend on the connection
    to the database. One way to inject this dependency is to pass the database connection
    object into the methods as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding types are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this clutters the signatures of the methods. Also, other methods that
    call the database, such as dependent methods, get cluttered because they need
    the database connection object to satisfy the dependency of the methods they call.
    For example, imagine a business logic method that creates a new user and an account
    for them at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is composed of two database calls, and since each of these calls depends
    on a database connection, this method must also depend on a database connection.
    Hence, you must provide a database connection as an argument to the business logic
    method. Providing the dependency as an argument is not very convenient as it brings
    the connection object into your focus. On the business logic layer, you want to
    focus on the business logic and not on the details of how the database connection
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Functional solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One solution that functional programming provides for the problem of dependency
    injection is that it can treat dependency requirement as a function defined with
    the dependency as an argument and then abstract this function away. If we want
    to do this, then first we have to define our database access methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The approach states that whenever we have a computation that depends on some
    external resource, we model this dependency as a function that accepts this resource
    as an argument. So, when we have a method that is supposed to create a user, it
    does not perform the computation itself. Rather, it returns a function that performs
    the computation, provided you supply it with the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to express the business logic method in this setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This approach is not very different from the approach of having an extra argument
    in the functions. However, this is the first step of the abstraction process,
    and this step is to bring focus onto the effect we are abstracting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to abstract away these functions. One way to do this is
    to treat the functions as effects. This effect is used so that the computation
    represented by this function cannot be performed unless you provide it with its
    dependency—the argument of the function. Consider our already familiar example
    that has been rewritten with the help of the `Reader` effect type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Reader` can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the pattern of `flatMap` and the effect types are repeating
    again. Previously, we saw the side effects of asynchronous computation and errors.
    All of them were represented by separate data structures—`Future` and `Either`
    (and `Try`). Now, we can see an effect of dependency. That is, the effect is that
    the computation is unable to be executed unless a specific resource demand is
    satisfied. This effect, too, is modeled by its own effect type: `Reader`.
  prefs: []
  type: TYPE_NORMAL
- en: As we stated previously, we provided the `flatMap` method for the `Reader` class.
    The meaning of this method is the same as in the cases of `Future` and `Try`.
    That is, to perform a continuation on a side effecting computation. This method
    can be used in the setting of a business logic method that relies on the `createUser`
    and `createAccount` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `Readers` are essentially functions. This means that you cannot
    run them until you provide the dependencies they require. To do so, you can call
    a method that is usually defined in the API of the `Reader` data structure. In
    our case, according to the definition of the preceding `Reader` class, this can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were armed with the theoretical foundations of effects,
    what they are, and why they are needed. We took a look at some examples of effects
    types which are frequently encountered in practice. We have seen how the `Future`
    type abstracts away asynchronous computations. We also looked at the `Either`
    type, which is similar to `Try`, but allows alternative representations for errors.
    Finally, we covered the `Reader` effect type, which abstracts away the effect
    of dependency. We also saw that `flatMap` is a typical pattern among effect types,
    which abstracts away the sequential composition of side effecting computations,
    and the effects of which are rectified into effect types.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll have a look at how to generalize patterns of working
    with effect types.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the `Future` effect type `abstract`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we need the `Either` effect type if we already have the `Try` effect
    type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does functional programming represent dependency injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What role does the `flatMap` function play in all of the effect types we have
    encountered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
