<html><head></head><body>
		<div id="_idContainer077">
			<h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor120"/>Chapter 6</em>: Testing Microservices</h1>
			<p>In a rather simple definition, <strong class="bold">software testing</strong> is verifying that a produced software application is functioning as expected. Since the early days of programming languages and software development, good precedents have been set to ensure they are <strong class="bold">functioning as expected</strong>. Almost all programming languages (barring some scripting languages) have robust compilers to catch anomalies at compile time. Though compile-time checks are good to start with, they can't verify whether a software application will run just as expected at runtime. For peace of mind, software development teams perform various kinds of testing to verify that a software application will function as expected. And any testing exercise will increase manifold with an increase in the number of distributed components or, put simply, it's rather more easy to test a monolithic application than a distributed one. To save time and decrease the turnaround time to deliver a feature, it's efficient to automate testing at various levels. </p>
			<p>In this chapter, we will explore how we can automate testing at various levels of microservices. We will dive into the following topics:</p>
			<ul>
				<li>Understanding the testing pyramid</li>
				<li>Unit testing in the Micronaut framework</li>
				<li>Service testing in the Micronaut framework</li>
				<li>Integration testing using test containers</li>
			</ul>
			<p>By the end of this chapter, you will have handy knowledge of automating testing at various levels of microservices.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor121"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter are run on Windows 10 and macOS. Code examples covered in this chapter are available on the book's GitHub at <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06</a>.</p>
			<p>The following tools need to be installed and set up in the development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong> version 13 or above (we used Java 14)</li>
				<li><strong class="bold">Maven</strong>: It is optional and only required if you would like to use Maven as the build system. However, we recommend having Maven set up on any development machine. Instructions to download and install Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">Development IDE</strong>: Based on your preference, any Java-based IDE can be used, but for the purpose of writing this chapter, IntelliJ was used.</li>
				<li><strong class="bold">Git</strong>: Instructions to download and install it can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</li>
				<li><strong class="bold">PostgreSQL</strong>: Instructions to download and install it can be found at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</li>
				<li><strong class="bold">MongoDB</strong>: MongoDB Atlas provides a free online database-as-a-service offering of up to 512 MB storage. However, if a local database is preferred, then instructions to download and install it can be found at <a href="https://docs.mongodb.com/manual/administration/install-community/">https://docs.mongodb.com/manual/administration/install-community/</a>. We used a local installation to write this chapter.</li>
				<li><strong class="bold">REST client</strong>: Any HTTP REST client can be used. We used the Advanced REST Client Chrome plugin.</li>
				<li><strong class="bold">Docker</strong>: Instructions to download and install Docker can be found at <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>.</li>
			</ul>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor122"/>Understanding the testing pyramid</h1>
			<p>The testing <a id="_idIndexMarker470"/>pyramid is an easy concept to understand the relative notion of performance, expense, and robustness for the different kinds of testing. The following diagram shows various kinds of testing in the testing pyramid and how much effort is required:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_6.1_B16585.jpg" alt="Figure 6.1 – Test pyramid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Test pyramid</p>
			<p>As depicted in the preceding diagram, unit testing is fast, robust, and inexpensive whereas as we go towards the top of the pyramid, testing becomes sluggish, brittle, and expensive. Though all kinds of testing are required to fully verify whether the application is working as expected, a fine balance is critical to cut expenses and increase robustness and <a id="_idIndexMarker471"/>speed. Put simply, have a lot of unit tests, a number of service tests, and very few end-to-end tests. This will ensure quality at a greater speed and with less cost. </p>
			<p>In the next section, we will begin the automated testing journey with unit testing.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/>Unit testing in the Micronaut framework</h1>
			<p>In the<a id="_idIndexMarker472"/> object-oriented paradigm, an object can assume <a id="_idIndexMarker473"/>multiple behaviors. These behaviors are defined by their methods. Effective unit testing probes a single behavior of an object at a time. This doesn't translate to testing a method as a method can change its behavior by taking different execution paths (if the method has forked control flow). Therefore, essentially, a unit test will probe one execution path of a method at a time. Iteratively, we can add more unit tests to probe other execution paths in the same or other methods. This bottom-up approach relies on verifying behaviors at smaller, isolated levels so the application as a whole will work as expected. </p>
			<p>To perform a unit test, isolation is required. Essentially, we need to isolate the object's behavior (that we want to test) while ignoring the object's interaction with other objects/components within the system. To achieve this isolation, we have various mechanisms in unit testing:</p>
			<ul>
				<li><strong class="bold">Mocking</strong>: Mocking is an <a id="_idIndexMarker474"/>operation to create a test double in which a<a id="_idIndexMarker475"/> testing framework will create a mock/dummy object based on the class definition of the object (compile time). To isolate the subject object's interaction with other interacting objects, we can simply mock the interacting objects. When a unit test is executed for the subject object, it will skip interactions with other objects.</li>
				<li><strong class="bold">Spying</strong>: Using spying<a id="_idIndexMarker476"/> we create a test double by probing the actual instance of the object (runtime). A spy object will just be the same as the real object barring any stubs. Stubs are used to define a dummy invocation so that the spy object will execute normally but when an invocation matches a stub definition, then it will execute the dummy behavior defined by the stub.</li>
			</ul>
			<p>Though mocking and spying can help to isolate the behavior, sometimes the subject object may<a id="_idIndexMarker477"/> not be interacting with other objects so no<a id="_idIndexMarker478"/> test doubles are required. In the next section, we will begin with how to implement unit tests in the Micronaut framework using JUnit 5.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor124"/>Unit testing using JUnit 5</h2>
			<p>In order <a id="_idIndexMarker479"/>to<a id="_idIndexMarker480"/> learn how to implement unit tests in the Micronaut framework, we will resume the code base from <a href="B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Integrating Microservices Using</em> <em class="italic">the</em> <em class="italic">Event-Driven Architecture</em>. We will continue with the pet-owner microservice and make sure you have the following dependencies added to the project <strong class="source-inline">pom.xml</strong>:</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;scope&gt;test&lt;/scope&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;scope&gt;test&lt;/scope&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.test&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-test-junit5&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;scope&gt;test&lt;/scope&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p>By<a id="_idIndexMarker481"/> importing<a id="_idIndexMarker482"/> the preceding JUnit dependencies, we can leverage the JUnit and Micronaut test toolkit in the pet-owner microservice.</p>
			<p>Next, we will create a <strong class="source-inline">TestUtil</strong> class in <strong class="source-inline">com.packtpub.micronaut.util</strong> that can encapsulate some essential testing methods:</p>
			<p class="source-code">public final class TestUtil {</p>
			<p class="source-code">    public static &lt;T&gt; void equalsVerifier(Class&lt;T&gt; clazz) </p>
			<p class="source-code">     throws Exception {</p>
			<p class="source-code">        T domainObject1 = </p>
			<p class="source-code">         clazz.getConstructor().newInstance();</p>
			<p class="source-code">        assertThat(domainObject1.toString()).isNotNull();</p>
			<p class="source-code">        assertThat(domainObject1).isEqualTo(domainObject1);</p>
			<p class="source-code">        assertThat(domainObject1.hashCode()).isEqualTo(domainObject1.hashCode());</p>
			<p class="source-code">        // Test with an instance of another class</p>
			<p class="source-code">        Object testOtherObject = new Object();</p>
			<p class="source-code">        assertThat(domainObject1).isNotEqualTo(testOtherObject);</p>
			<p class="source-code">        assertThat(domainObject1).isNotEqualTo(null);</p>
			<p class="source-code">        // Test with an instance of the same class</p>
			<p class="source-code">        T domainObject2 = </p>
			<p class="source-code">         clazz.getConstructor().newInstance();</p>
			<p class="source-code">        assertThat(domainObject1).isNotEqualTo(domainObject2);</p>
			<p class="source-code">        /* HashCodes are equals because the objects are not persisted yet */</p>
			<p class="source-code">        assertThat(domainObject1.hashCode()).isEqualTo(domainObject2.hashCode());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In <strong class="source-inline">TestUtil</strong>, we <a id="_idIndexMarker483"/>have <a id="_idIndexMarker484"/>added the <strong class="source-inline">equalsVerifier()</strong> method, which can verify whether two objects are equal or not. This method takes a class type as an input parameter to assert different conditions on tested objects. </p>
			<p>In the next section, we will explore how to unit test a domain object.</p>
			<h3>Unit testing a domain object</h3>
			<p>A domain<a id="_idIndexMarker485"/> object<a id="_idIndexMarker486"/> is simply a <strong class="bold">POJO</strong> (<strong class="bold">plain old Java object</strong>) and we can create a basic test for an <strong class="source-inline">Owner</strong> class in<a id="_idIndexMarker487"/> the pet-owner microservice. In the followed code snippet, we are creating an <strong class="source-inline">OwnerTest</strong> class to assert the equality of two owner instances:  </p>
			<p class="source-code">public class OwnerTest {</p>
			<p class="source-code">    @Test</p>
			<p class="source-code">    public void equalsVerifier() throws Exception {</p>
			<p class="source-code">        TestUtil.equalsVerifier(Owner.class);</p>
			<p class="source-code">        Owner owner1 = new Owner();</p>
			<p class="source-code">        owner1.setId(1L);</p>
			<p class="source-code">        Owner owner2 = new Owner();</p>
			<p class="source-code">        owner2.setId(owner1.getId());</p>
			<p class="source-code">        assertThat(owner1).isEqualTo(owner2);</p>
			<p class="source-code">        owner2.setId(2L);</p>
			<p class="source-code">        assertThat(owner1).isNotEqualTo(owner2);</p>
			<p class="source-code">        owner1.setId(null);</p>
			<p class="source-code">        assertThat(owner1).isNotEqualTo(owner2);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">OnwerTest</strong> class contains a test method, <strong class="source-inline">equalsVerifier()</strong>. An annotation, <strong class="source-inline">org.junit.jupiter.api.Test</strong>, is used to mark it as a test method. To verify the expected<a id="_idIndexMarker488"/> behavior, we <a id="_idIndexMarker489"/>are using assert statements. Similarly, we can define test classes for other domain objects in the pet-owner microservice.</p>
			<p>In the next section, we will unit test a mapper object.</p>
			<h3>Unit testing a mapper object</h3>
			<p>Our mapper <a id="_idIndexMarker490"/>objects in the pet-owner microservice are simple <a id="_idIndexMarker491"/>and we can create a basic test for an <strong class="source-inline">OwnerMapper</strong> class using the <strong class="source-inline">@Test</strong> annotation. In the following code snippet, <strong class="source-inline">OwnerMapperTest</strong> is unit-testing the <strong class="source-inline">fromId()</strong> method in <strong class="source-inline">OwnerMapper</strong>: </p>
			<p class="source-code">public class OwnerMapperTest {</p>
			<p class="source-code">    private OwnerMapper;</p>
			<p class="source-code">    @BeforeEach</p>
			<p class="source-code">    public void setUp() {</p>
			<p class="source-code">        ownerMapper = new OwnerMapperImpl();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Test</p>
			<p class="source-code">    public void testEntityFromId() {</p>
			<p class="source-code">        Long id = 1L;</p>
			<p class="source-code">        assertThat(ownerMapper.fromId(id).getId()).</p>
			<p class="source-code">         isEqualTo(id);</p>
			<p class="source-code">        assertThat(ownerMapper.fromId(null)).isNull();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">OwnerMapperTest</strong> class <a id="_idIndexMarker492"/>contains a test method, <strong class="source-inline">testEntityFromId()</strong>. To <a id="_idIndexMarker493"/>verify the expected behavior we are using <strong class="source-inline">assert</strong> statements. Similarly, we can define test classes for other mapper objects in the pet-owner microservice.</p>
			<p>Hitherto, we wrote simple unit tests for domain and mapper objects that didn't require any test doubles. In the next section, we will explore how we can use mocking to create the desired test doubles. </p>
			<h3>Using mocks in unit testing</h3>
			<p>As we <a id="_idIndexMarker494"/>discussed <a id="_idIndexMarker495"/>before, mocking a testing framework will create a test double based on the class definition. These test doubles come in handy in unit testing an object where the object invokes methods on other objects.  </p>
			<p>In order to learn about mocking in unit testing, we will work on the <strong class="source-inline">VetService</strong> class in the <a id="_idIndexMarker496"/>pet-clinic microservice. Let's look at <strong class="source-inline">VetServiceImpl</strong> in <a id="_idIndexMarker497"/>the pet-clinic microservice: </p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class VetServiceImpl implements VetService {</p>
			<p class="source-code">    private final VetRepository;</p>
			<p class="source-code">    private final SpecialtyRepository;</p>
			<p class="source-code">    private final VetMapper;</p>
			<p class="source-code">    private final SpecialtyMapper;</p>
			<p class="source-code">    public VetServiceImpl(VetRepository, </p>
			<p class="source-code">     SpecialtyRepository, VetMapper, SpecialtyMapper </p>
			<p class="source-code">     specialtyMapper) {</p>
			<p class="source-code">        this.vetRepository = vetRepository;</p>
			<p class="source-code">        this.specialtyRepository = specialtyRepository;</p>
			<p class="source-code">        this.vetMapper = vetMapper;</p>
			<p class="source-code">        this.specialtyMapper = specialtyMapper;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">VetService</strong> instantiates <strong class="source-inline">VetRepository</strong>, <strong class="source-inline">SpecialtyRepository</strong>, <strong class="source-inline">VetMapper</strong>, and <strong class="source-inline">SpecialtyMapper</strong> in the constructor. These instantiated objects are then used in <strong class="source-inline">VetService</strong> methods. To unit test the <strong class="source-inline">VetService</strong> object, we would need to define mocks for some of these interacting objects. </p>
			<p>Let's create <strong class="source-inline">VetServiceTest</strong> to encapsulate unit tests for <strong class="source-inline">VetService</strong>. In this test class, we will mock some interacting objects using the <strong class="source-inline">@MockBean</strong> annotation:</p>
			<p class="source-code">@MicronautTest</p>
			<p class="source-code">class VetServiceTest {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private VetRepository;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private SpecialtyRepository;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private VetMapper;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private SpecialtyMapper;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private VetService;</p>
			<p class="source-code">    /** Mock beans */</p>
			<p class="source-code">    @MockBean(VetRepositoryImpl.class)</p>
			<p class="source-code">    VetRepository vetRepository() {</p>
			<p class="source-code">        return mock(VetRepository.class);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @MockBean(SpecialtyRepositoryImpl.class)</p>
			<p class="source-code">    SpecialtyRepository specialtyRepository() {</p>
			<p class="source-code">        return mock(SpecialtyRepository.class);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">VetServiceTest</strong> class<a id="_idIndexMarker498"/> is annotated with the <strong class="source-inline">@MicronautTest</strong> annotation. It<a id="_idIndexMarker499"/> runs the test class as an actual Micronaut application with the full application context, thereby avoiding the artificial separation between production code and test code. </p>
			<p>To inject the interacting objects, we are using <strong class="source-inline">@Inject</strong> annotations. <strong class="source-inline">@Inject</strong> injects a bean from the application context into the class. Furthermore, using the <strong class="source-inline">@MockBean</strong> annotation, we are overriding the runtime beans for <strong class="source-inline">VetRepository</strong> and <strong class="source-inline">SpecialtyRepository</strong>. <strong class="source-inline">@MockBean</strong> will replace the actual objects with mocked objects in the application context.</p>
			<p>We can<a id="_idIndexMarker500"/> easily use these test double mocks in writing a unit test for<a id="_idIndexMarker501"/> the <strong class="source-inline">VetService</strong> method: </p>
			<p class="source-code">@Test</p>
			<p class="source-code">public void saveVet() throws Exception {</p>
			<p class="source-code">    // Setup Specialty</p>
			<p class="source-code">    Long specialtyId = 100L;</p>
			<p class="source-code">    SpecialtyDTO = createSpecialtyDTO(specialtyId);</p>
			<p class="source-code">    Specialty = specialtyMapper.toEntity(specialtyDTO);</p>
			<p class="source-code">    // Setup VetDTO</p>
			<p class="source-code">    Long vetId = 200L;</p>
			<p class="source-code">    VetDTO = createVetDTO(vetId);</p>
			<p class="source-code">    vetDTO.setSpecialties(Set.of(specialtyDTO));</p>
			<p class="source-code">    Vet = vetMapper.toEntity(vetDTO);</p>
			<p class="source-code">    // Stubbing</p>
			<p class="source-code">    when(vetRepository.save(any(Vet.class))).thenReturn</p>
			<p class="source-code">     (vetId);</p>
			<p class="source-code">    when(specialtyRepository.findByName(anyString())).</p>
			<p class="source-code">      thenReturn(specialty);</p>
			<p class="source-code">    doNothing().when(vetRepository).saveVetSpecialty</p>
			<p class="source-code">     (anyLong(), anyLong());</p>
			<p class="source-code">    when(vetRepository.findById(anyLong())).thenReturn</p>
			<p class="source-code">     (vet);</p>
			<p class="source-code">    // Execution</p>
			<p class="source-code">    VetDTO savedVetDTO = vetService.save(vetDTO);</p>
			<p class="source-code">    verify(vetRepository, times(1)).save(any(Vet.class));</p>
			<p class="source-code">    verify(specialtyRepository, </p>
			<p class="source-code">     times(1)).findByName(anyString());</p>
			<p class="source-code">    verify(vetRepository, times(1)).saveVetSpecialty</p>
			<p class="source-code">     (anyLong(), anyLong());</p>
			<p class="source-code">    verify(vetRepository, times(1)).findById(anyLong());</p>
			<p class="source-code">    assertThat(savedVetDTO).isNotNull();</p>
			<p class="source-code">    assertThat(savedVetDTO.getId()).isEqualTo(vetId);</p>
			<p class="source-code">    assertThat(savedVetDTO.getSpecialties()).isNotEmpty();</p>
			<p class="source-code">    assertThat(savedVetDTO.getSpecialties().size()).</p>
			<p class="source-code">      isEqualTo(1);</p>
			<p class="source-code">    assertThat(savedVetDTO.getSpecialties().stream().</p>
			<p class="source-code">     findFirst().orElse(null).getId()).isEqualTo</p>
			<p class="source-code">     (specialtyId);</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker502"/>preceding <a id="_idIndexMarker503"/>code snippet, you can see how we are defining stubs for the mocked <strong class="source-inline">VetRepository</strong> and <strong class="source-inline">SpecialtyRepository</strong> classes. Usually, a mock stub takes the form of <strong class="source-inline">when(object.methodCall()).thenReturn(result)</strong>, except in the case of void method calls, where it is <strong class="source-inline">doNothing().when(object).methodCall()</strong>. </p>
			<p>Ideally, it's prudent to follow up mock stubs with <strong class="source-inline">verify()</strong> statements. <strong class="source-inline">verify()</strong> will confirm <a id="_idIndexMarker504"/>that, indeed, the desired method calls were made while <a id="_idIndexMarker505"/>executing the unit test. </p>
			<p>In the next section, we will explore another way of creating test doubles using spies. </p>
			<h3>Using spies in unit testing</h3>
			<p>As we<a id="_idIndexMarker506"/> discussed<a id="_idIndexMarker507"/> before, spying on a testing framework will create a test double based on the actual runtime object of the class. While mocking creates a full test double of the real object, with spying we can control whether the test double is partial or full. In a spied object, we can stub some method calls while keeping other method calls real. In such a scenario, the unit test will make dummy as well as real calls. Therefore, spying gives a bit more control over what we want to fake. </p>
			<p>In order to learn about spying in unit testing, we will work on the <strong class="source-inline">SpecialtyService</strong> class in the pet-clinic microservice. Let's look at <strong class="source-inline">SpecialtyServiceImpl</strong> in the pet-clinic microservice:</p>
			<p class="source-code">public class SpecialtyServiceImpl implements SpecialtyService {</p>
			<p class="source-code">    private final SpecialtyRepository;</p>
			<p class="source-code">    private final SpecialtyMapper;</p>
			<p class="source-code">    public SpecialtyServiceImpl(SpecialtyRepository </p>
			<p class="source-code">    specialtyRepository, SpecialtyMapper specialtyMapper) {</p>
			<p class="source-code">        this.specialtyRepository = specialtyRepository;</p>
			<p class="source-code">        this.specialtyMapper = specialtyMapper;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">SpecialtyService</strong> is instantiating <strong class="source-inline">SpecialtyRepository</strong> and <strong class="source-inline">SpecialtyMapper</strong> in the constructor. These instantiated objects are then used in <strong class="source-inline">SpecialtyService</strong> methods. To unit test the <strong class="source-inline">SpecialtyService</strong> object, we would need to define spies for some of these interacting objects. </p>
			<p>Let's create <strong class="source-inline">SpecialtyServiceTest</strong> for encapsulating unit tests for <strong class="source-inline">SpecialtyService</strong>. In this<a id="_idIndexMarker508"/> test class, we will spy some interacting objects using the <strong class="source-inline">@MockBean</strong> annotation <a id="_idIndexMarker509"/>and <strong class="source-inline">spy()</strong> method in JUnit:</p>
			<p class="source-code">@MicronautTest</p>
			<p class="source-code">class SpecialtyServiceTest {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private SpecialtyRepository;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private SpecialtyMapper;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private SpecialtyService;</p>
			<p class="source-code">    @MockBean(SpecialtyRepositoryImpl.class)</p>
			<p class="source-code">    SpecialtyRepository specialtyRepository() {</p>
			<p class="source-code">        return spy(SpecialtyRepository.class);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">SpecialtyServiceTest</strong> class is annotated with <strong class="source-inline">@MicronautTest</strong>, which runs the test class as an actual Micronaut application with the full application context. </p>
			<p>Using the <strong class="source-inline">@MockBean</strong> annotation, we are overriding the runtime bean for <strong class="source-inline">SpecialtyRepository</strong>. <strong class="source-inline">@MockBean</strong> will replace the actual object with the spied object in the application context. On the spied <strong class="source-inline">SpecialtyRepository</strong> object, we can easily define <a id="_idIndexMarker510"/>some stubs that will be executed in the test method<a id="_idIndexMarker511"/> instead of the actual invocation:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">public void saveSpecialty() throws Exception {</p>
			<p class="source-code">    // Setup Specialty</p>
			<p class="source-code">    Long specialtyId = 100L;</p>
			<p class="source-code">    SpecialtyDTO = createSpecialtyDTO(specialtyId);</p>
			<p class="source-code">    Specialty = specialtyMapper.toEntity(specialtyDTO);</p>
			<p class="source-code">    // Stubbing</p>
			<p class="source-code">    doReturn(100L).when(specialtyRepository).save(any</p>
			<p class="source-code">     (Specialty.class));</p>
			<p class="source-code">    doReturn(specialty).when(specialtyRepository).findById</p>
			<p class="source-code">     (anyLong());</p>
			<p class="source-code">    // Execution</p>
			<p class="source-code">    SpecialtyDTO savedSpecialtyDTO = </p>
			<p class="source-code">       specialtyService.save(specialtyDTO);</p>
			<p class="source-code">    verify(specialtyRepository, </p>
			<p class="source-code">      times(1)).save(any(Specialty.class));</p>
			<p class="source-code">    verify(specialtyRepository, </p>
			<p class="source-code">      times(1)).findById(anyLong());</p>
			<p class="source-code">    assertThat(savedSpecialtyDTO).isNotNull();</p>
			<p class="source-code">    assertThat(savedSpecialtyDTO.getId()).isEqualTo</p>
			<p class="source-code">       (specialtyId);</p>
			<p class="source-code">}</p>
			<p>In the preceding code snippet, you can see how we are defining stubs for the spied <strong class="source-inline">SpecialtyRepository</strong> instance. Usually, a spy stub takes the form of <strong class="source-inline">doReturn(result).when(object).methodCall()</strong>, except in the case of void method calls, where it is <strong class="source-inline">doNothing().when(object).methodCall()</strong>. </p>
			<p>Again, it's prudent to follow up spied stubs with <strong class="source-inline">verify()</strong> statements. These will confirm<a id="_idIndexMarker512"/> whether<a id="_idIndexMarker513"/> the desired method calls were made while executing the unit test.</p>
			<p>Hitherto, we have learned the various ways to unit test using mocks and spies. In the next section, we will explore how we can perform service testing in the Micronaut framework. </p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor125"/>Service testing in the Micronaut framework</h1>
			<p><strong class="bold">Service testing</strong> is<a id="_idIndexMarker514"/> the next level to unit testing. By <a id="_idIndexMarker515"/>testing all the endpoints in a microservice and repeating this process for all the other microservices, we can make sure that all the services are working as expected edge to edge. It raises the quality check to the next level. Having said that, as we discussed before, as we move up in the test pyramid, test cases become more brittle, expensive, and sluggish, therefore, we need to establish a fine balance of not testing too much on the higher levels. </p>
			<p>To learn how we can perform service testing in the Micronaut framework, we will continue with the pet-clinic microservice. In the following sections, we will go into testing all the REST endpoints of a service. We will use the <strong class="source-inline">@Order</strong> annotation to establish the order of execution of a test in the suite. An ordered test suite can help in starting from scratch and cleaning up at the end. In the following examples, we will create, get, update, and finally delete the resource. </p>
			<h3>Creating the test suite</h3>
			<p>To test <a id="_idIndexMarker516"/>the <strong class="source-inline">VetResource</strong> endpoints, let's<a id="_idIndexMarker517"/> create a <strong class="source-inline">VetResourceIntegrationTest</strong> class. This suite will encapsulate all the happy and unhappy integration tests: </p>
			<p class="source-code">@MicronautTest(transactional = false)</p>
			<p class="source-code">@Property(name = "micronaut.security.enabled", value = "false")</p>
			<p class="source-code">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</p>
			<p class="source-code">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</p>
			<p class="source-code">public class VetResourceIntegrationTest {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private VetMapper;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private VetRepository;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private SpecialtyRepository;</p>
			<p class="source-code">    @Inject @Client("/")</p>
			<p class="source-code">    RxHttpClient client;</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>There are a few things to ponder in the preceding code snippet:</p>
			<ul>
				<li><strong class="bold">@MicronautTest(transactional = false)</strong>: This annotation boots up the test suite as a real Micronaut application and <strong class="source-inline">transactional = false</strong> ensures that the suite runs without the transaction. </li>
				<li><strong class="bold">@Property(name = "micronaut.security.enabled", value = "false")</strong>: The <strong class="source-inline">@Property</strong> annotation overrides the application configuration. And in our case, we are disabling the security. </li>
				<li><strong class="bold">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</strong>: <strong class="source-inline">TestInstance.Lifecycle.PER_CLASS</strong> boots up the instance and keeps the application context for the whole suite. You can instantiate a test object and application context at the test method level using <strong class="source-inline">@TestInstance(TestInstance.Lifecycle.PER_METHOD)</strong>.</li>
				<li><strong class="bold">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</strong>: <strong class="source-inline">@TestMethodOrder annotation</strong> in JUnit is used to define the execution order of each test method in the test suite. </li>
				<li><strong class="bold">@Inject @Client</strong>: This annotation injects a reactive HTTP client (built in Micronaut) to perform RESTful calls to the resource endpoints.</li>
			</ul>
			<p>After<a id="_idIndexMarker518"/> setting up the test suite, we<a id="_idIndexMarker519"/> are good to perform service testing. In the next few sections, we will cover all the restful calls in the test methods.</p>
			<h3>Testing the create endpoint</h3>
			<p><strong class="source-inline">VetResource</strong> has <a id="_idIndexMarker520"/>a POST <a id="_idIndexMarker521"/>endpoint for creating a new <strong class="source-inline">Vet</strong>. It accepts <strong class="source-inline">VetDTO</strong> in the request body. Let's use the HTTP client to create a vet:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">@Order(1)</p>
			<p class="source-code">public void createVet() throws Exception {</p>
			<p class="source-code">    int databaseSizeBeforeCreate = </p>
			<p class="source-code">     vetRepository.findAll().size();</p>
			<p class="source-code">    VetDTO = vetMapper.toDto(vet);</p>
			<p class="source-code">    // Create the Vet</p>
			<p class="source-code">    HttpResponse&lt;VetDTO&gt; response = </p>
			<p class="source-code">     client.exchange(HttpRequest.POST("/api/vets", vetDTO), </p>
			<p class="source-code">     VetDTO.class).blockingFirst();</p>
			<p class="source-code">    assertThat(response.status().getCode()).isEqualTo</p>
			<p class="source-code">      (HttpStatus.CREATED.getCode());</p>
			<p class="source-code">    // Validate the Vet in the database</p>
			<p class="source-code">    List&lt;Vet&gt; vetList = (List&lt;Vet&gt;) </p>
			<p class="source-code">      vetRepository.findAll();</p>
			<p class="source-code">    assertThat(vetList).hasSize(databaseSizeBeforeCreate + </p>
			<p class="source-code">     1);</p>
			<p class="source-code">    Vet testVet = vetList.get(vetList.size() - 1);</p>
			<p class="source-code">    // Set id for further tests</p>
			<p class="source-code">    vet.setId(testVet.getId());</p>
			<p class="source-code">    assertThat(testVet.getFirstName()).isEqualTo</p>
			<p class="source-code">     (DEFAULT_FIRST_NAME);</p>
			<p class="source-code">    assertThat(testVet.getLastName()).isEqualTo</p>
			<p class="source-code">     (DEFAULT_LAST_NAME);</p>
			<p class="source-code">}</p>
			<p>In the preceding test, we are creating a <strong class="source-inline">VetDTO</strong> object and invoking the POST endpoint using the<a id="_idIndexMarker522"/> HTTP client. To make<a id="_idIndexMarker523"/> the reactive client return the observable and make a pseudo-synchronous call, we are using <strong class="source-inline">blockingFirst()</strong>. It blocks the thread until the observable emits an item, then returns the first item emitted by the observable. Finally, we are asserting to confirm the expected versus the actual behavior.</p>
			<h3>Testing the <strong class="source-inline">GET</strong> endpoint</h3>
			<p>In the proceeding test, we created a new vet in the POST endpoint service test. We can leverage <a id="_idIndexMarker524"/>just the persisted <a id="_idIndexMarker525"/>vet to test the <strong class="source-inline">GET </strong>endpoint: </p>
			<p class="source-code">@Test</p>
			<p class="source-code">@Order(3)</p>
			<p class="source-code">public void getAllVets() throws Exception {</p>
			<p class="source-code">    // Get the vetList w/ all the vets</p>
			<p class="source-code">    List&lt;VetDTO&gt; vets = client.retrieve(HttpRequest.GET</p>
			<p class="source-code">      ("/api/vets?eagerload=true"), </p>
			<p class="source-code">      Argument.listOf(VetDTO.class)).blockingFirst();</p>
			<p class="source-code">    VetDTO testVet = vets.get(vets.size() - 1);</p>
			<p class="source-code">    assertThat(testVet.getFirstName()).isEqualTo</p>
			<p class="source-code">      (DEFAULT_FIRST_NAME);</p>
			<p class="source-code">    assertThat(testVet.getLastName()).isEqualTo</p>
			<p class="source-code">      (DEFAULT_LAST_NAME);</p>
			<p class="source-code">}</p>
			<p class="source-code">@Test</p>
			<p class="source-code">@Order(4)</p>
			<p class="source-code">public void getVet() throws Exception {</p>
			<p class="source-code">    // Get the vet</p>
			<p class="source-code">    VetDTO testVet = </p>
			<p class="source-code">      client.retrieve(HttpRequest.GET("/api/vets/" + </p>
			<p class="source-code">      vet.getId()), VetDTO.class).blockingFirst();</p>
			<p class="source-code">    assertThat(testVet.getFirstName()).isEqualTo</p>
			<p class="source-code">      (DEFAULT_FIRST_NAME);</p>
			<p class="source-code">    assertThat(testVet.getLastName()).isEqualTo</p>
			<p class="source-code">      (DEFAULT_LAST_NAME);</p>
			<p class="source-code">}</p>
			<p>In the preceding tests, we are testing two endpoints, <strong class="source-inline">getVet()</strong> and <strong class="source-inline">getAllVets()</strong>. To make the<a id="_idIndexMarker526"/> reactive<a id="_idIndexMarker527"/> client return the results, we are using the <strong class="source-inline">blockingFirst()</strong> operator. While <strong class="source-inline">getAllVets()</strong> will return a list of vets, <strong class="source-inline">getVet()</strong> will return the desired vet object only.</p>
			<h3>Testing the update endpoint</h3>
			<p>To test <a id="_idIndexMarker528"/>the <strong class="source-inline">update</strong> endpoint, we<a id="_idIndexMarker529"/> will leverage the vet resource persisted in the created endpoint service test, therefore, use an order after the <strong class="source-inline">create</strong> and <strong class="source-inline">GET</strong> calls:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">@Order(6)</p>
			<p class="source-code">public void updateVet() throws Exception {</p>
			<p class="source-code">    int databaseSizeBeforeUpdate = </p>
			<p class="source-code">      vetRepository.findAll().size();</p>
			<p class="source-code">    // Update the vet</p>
			<p class="source-code">    Vet updatedVet = vetRepository.findById(vet.getId());</p>
			<p class="source-code">    updatedVet</p>
			<p class="source-code">        .firstName(UPDATED_FIRST_NAME)</p>
			<p class="source-code">        .lastName(UPDATED_LAST_NAME);</p>
			<p class="source-code">    VetDTO updatedVetDTO = vetMapper.toDto(updatedVet);</p>
			<p class="source-code">    @SuppressWarnings("unchecked")</p>
			<p class="source-code">    HttpResponse&lt;VetDTO&gt; response = </p>
			<p class="source-code">     client.exchange(HttpRequest.PUT("/api/vets", </p>
			<p class="source-code">       updatedVetDTO), VetDTO.class)</p>
			<p class="source-code">        .onErrorReturn(t -&gt; (HttpResponse&lt;VetDTO&gt;) </p>
			<p class="source-code">       ((HttpClientResponseException) </p>
			<p class="source-code">        t).getResponse()).blockingFirst();</p>
			<p class="source-code">    assertThat(response.status().getCode()).isEqualTo</p>
			<p class="source-code">      (HttpStatus.OK.getCode());</p>
			<p class="source-code">    // Validate the Vet in the database</p>
			<p class="source-code">    List&lt;Vet&gt; vetList = (List&lt;Vet&gt;) </p>
			<p class="source-code">     vetRepository.findAll();</p>
			<p class="source-code">    assertThat(vetList).hasSize(databaseSizeBeforeUpdate);</p>
			<p class="source-code">    Vet testVet = vetList.get(vetList.size() - 1);</p>
			<p class="source-code">    assertThat(testVet.getFirstName()).isEqualTo</p>
			<p class="source-code">      (UPDATED_FIRST_NAME);</p>
			<p class="source-code">    assertThat(testVet.getLastName()).isEqualTo</p>
			<p class="source-code">      (UPDATED_LAST_NAME);</p>
			<p class="source-code">}</p>
			<p>In the preceding test, we tested the <strong class="source-inline">updateVet()</strong> endpoint. We first fetched the persisted vet<a id="_idIndexMarker530"/> and then <a id="_idIndexMarker531"/>updated the first and last name before invoking the update endpoint. Finally, we asserted to confirm the actual behavior meets the expected behavior.</p>
			<h3>Testing the delete endpoint</h3>
			<p>To test<a id="_idIndexMarker532"/> the <strong class="source-inline">delete</strong> endpoint, we<a id="_idIndexMarker533"/> will leverage the vet resource persisted in the earlier endpoint calls. Therefore, we will use an order after the <strong class="source-inline">create</strong>, <strong class="source-inline">GET</strong>, and <strong class="source-inline">update</strong> calls:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">@Order(8)</p>
			<p class="source-code">public void deleteVet() throws Exception {</p>
			<p class="source-code">    int databaseSizeBeforeDelete = </p>
			<p class="source-code">     vetRepository.findAll().size();</p>
			<p class="source-code">    // Delete the vet</p>
			<p class="source-code">    @SuppressWarnings("unchecked")</p>
			<p class="source-code">    HttpResponse&lt;VetDTO&gt; response = </p>
			<p class="source-code">     client.exchange(HttpRequest.DELETE("/api/vets/"+ </p>
			<p class="source-code">     vet.getId()), VetDTO.class)</p>
			<p class="source-code">        .onErrorReturn(t -&gt; (HttpResponse&lt;VetDTO&gt;) </p>
			<p class="source-code">        ((HttpClientResponseException) </p>
			<p class="source-code">        t).getResponse()).blockingFirst();</p>
			<p class="source-code">    assertThat(response.status().getCode()).isEqualTo</p>
			<p class="source-code">     (HttpStatus.NO_CONTENT.getCode());</p>
			<p class="source-code">    // Validate the database is now empty</p>
			<p class="source-code">    List&lt;Vet&gt; vetList = (List&lt;Vet&gt;) </p>
			<p class="source-code">     vetRepository.findAll();</p>
			<p class="source-code">    assertThat(vetList).hasSize</p>
			<p class="source-code">      (databaseSizeBeforeDelete - 1);</p>
			<p class="source-code">}</p>
			<p>In the preceding test, we tested the <strong class="source-inline">deleteVet()</strong> endpoint. We are passing the previously persisted <strong class="source-inline">vetId</strong>. And after the successful service call, we are asserting to confirm the actual behavior meets the expected behavior by comparing the database size before and after the service call. </p>
			<p>The test orders in the suite ensure that we always start from scratch and leave it clean after finishing <a id="_idIndexMarker534"/>all the tests in <a id="_idIndexMarker535"/>the suite. There are pros and cons to this pattern for service testing compared to setting up and cleaning up at the test method level. You can pick and choose a pattern after analyzing the application requirements and whether to use suite setup and cleanup or at the test method level. </p>
			<p>In the next section, we will explore the exciting world of <strong class="source-inline">Testcontainers</strong> for integration testing. </p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Integration testing using Testcontainers</h1>
			<p><strong class="source-inline">Testcontainers</strong> is a <a id="_idIndexMarker536"/>Java library that elegantly<a id="_idIndexMarker537"/> marries the world of testing with Docker virtualization. Using the <strong class="source-inline">Testcontainers</strong> library, we can set up, instantiate, and inject any Docker container into the testing code. This approach opens up many avenues for performing integration testing. In the test suite or test method setup, we can boot up a Dockerized database, Kafka or email server or any integrating app, perform the integration tests, and destroy the Dockerized app in the cleanup. With this pattern, we are up close to the production environment while not impacting the environment with any after-testing side effects. </p>
			<p>To learn how we can use the <strong class="source-inline">Testcontainers</strong> library, we will experiment on the pet-clinic-reviews <a id="_idIndexMarker538"/>microservice that integrates with<a id="_idIndexMarker539"/> MongoDB. In the next section, we will begin setting up <strong class="source-inline">Testcontainers </strong>in the Micronaut application.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>Setting up the Testcontainers in the Micronaut application</h2>
			<p>To <a id="_idIndexMarker540"/>use <strong class="source-inline">Testcontainers</strong> in<a id="_idIndexMarker541"/> the pet-clinic-reviews microservice, add the following dependencies in the project <strong class="source-inline">pom.xml</strong>:</p>
			<p class="source-code">   &lt;!-- Test containers --&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;1.15.2&lt;/version&gt;</p>
			<p class="source-code">      &lt;scope&gt;test&lt;/scope&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;mongodb&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;1.15.2&lt;/version&gt;</p>
			<p class="source-code">      &lt;scope&gt;test&lt;/scope&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p>By importing a MongoDB flavored test container, we will be able to leverage the MongoDB Docker toolkit. After importing the required <strong class="source-inline">Testcontainers</strong> dependencies, let's set up an abstract class that can provide any app containers required by the integration tests:</p>
			<p class="source-code">public class AbstractContainerBaseTest {</p>
			<p class="source-code">    public static final MongoDBContainer </p>
			<p class="source-code">     MONGO_DB_CONTAINER;</p>
			<p class="source-code">    static {</p>
			<p class="source-code">        MONGO_DB_CONTAINER = new MongoDBContainer</p>
			<p class="source-code">          (DockerImageName.parse("mongo:4.0.10"));</p>
			<p class="source-code">        MONGO_DB_CONTAINER.start();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In <strong class="source-inline">AbstractContainerBaseTest</strong>, we configure and boot up a MongoDB instance in Docker <a id="_idIndexMarker542"/>statically. The static nature <a id="_idIndexMarker543"/>of this container will simplify access and avoid booting up too many instances at the test suite or test method level. <strong class="source-inline">Testcontainers</strong> elegantly, and with minimal code, pulls up a MongoDB Docker image, boots it up, and starts it.</p>
			<p>In the next section, we will write integration tests using <strong class="source-inline">Testcontainers</strong> for <strong class="source-inline">VetReviewRepository</strong>. </p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/>Writing integration tests using Testcontainers</h2>
			<p>In the <a id="_idIndexMarker544"/>preceding section, we covered<a id="_idIndexMarker545"/> how we can use <strong class="source-inline">Testcontainers</strong> to create a Dockerized MongoDB. We will proceed to test <strong class="source-inline">VetReviewRepository</strong> using the Docker MongoDB instance. Let's begin with the test suite and test method setups:</p>
			<p class="source-code">@Testcontainers</p>
			<p class="source-code">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</p>
			<p class="source-code">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</p>
			<p class="source-code">class VetReviewRepositoryIntegrationTest extends AbstractContainerBaseTest {</p>
			<p class="source-code">    private VetReviewRepository;</p>
			<p class="source-code">    @BeforeAll</p>
			<p class="source-code">    void init() {</p>
			<p class="source-code">        ApplicationContext context = </p>
			<p class="source-code">         ApplicationContext.run(</p>
			<p class="source-code">            PropertySource.of("test", Map.of</p>
			<p class="source-code">             ("mongodb.uri", </p>
			<p class="source-code">             MONGO_DB_CONTAINER.getReplicaSetUrl()))</p>
			<p class="source-code">        );</p>
			<p class="source-code">        vetReviewRepository = </p>
			<p class="source-code">         context.getBean(VetReviewRepository.class);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @BeforeEach</p>
			<p class="source-code">    public void initTest() {</p>
			<p class="source-code">        if (!MONGO_DB_CONTAINER.isRunning()) {</p>
			<p class="source-code">            MONGO_DB_CONTAINER.start();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>In the test<a id="_idIndexMarker546"/> suite setup, we are overriding the <a id="_idIndexMarker547"/>application properties for MongoDB. Furthermore, we are fetching the <strong class="source-inline">VetReviewRepository</strong> bean from the application context. This will make sure we are injecting the repository bean that is communicating with the Dockerized MongoDB. And, in the test method setup, we are ensuring that the MongoDB container is running before we execute the test method. Since we have set up at the test suite and test method level, let's jump ahead in writing an integration test: </p>
			<p class="source-code">@Test</p>
			<p class="source-code">@Order(1)</p>
			<p class="source-code">public void saveVetReview() {</p>
			<p class="source-code">    VetReview = new VetReview();</p>
			<p class="source-code">    String reviewId = UUID.randomUUID().toString();</p>
			<p class="source-code">    vetReview.setReviewId(reviewId);</p>
			<p class="source-code">    vetReview.setVetId(1L);</p>
			<p class="source-code">    vetReview.setRating(3D);</p>
			<p class="source-code">    vetReview.setDateAdded(LocalDate.now());</p>
			<p class="source-code">    vetReview.setComment("Good vet");</p>
			<p class="source-code">    vetReviewRepository.save(vetReview);</p>
			<p class="source-code">    VetReview savedVetReview = </p>
			<p class="source-code">       vetReviewRepository.findByReviewId(reviewId);</p>
			<p class="source-code">    assertThat(savedVetReview).isNotNull();</p>
			<p class="source-code">    assertThat(savedVetReview.getReviewId()).isEqualTo</p>
			<p class="source-code">       (reviewId);</p>
			<p class="source-code">}</p>
			<p>In <a id="_idIndexMarker548"/>the <strong class="source-inline">saveVetReview()</strong> test, we are creating<a id="_idIndexMarker549"/> a new vet review and invoking on <strong class="source-inline">VetReviewRepository</strong> to persist this vet review. Finally, we are asserting that the vet review was persisted successfully by fetching and comparing the values. We are using the <strong class="source-inline">@Order</strong> pattern in the test suite so later tests can ensure the cleanup. </p>
			<p>In this section, we explored how <strong class="source-inline">Testcontainers</strong> can simplify integration tests by spinning off<a id="_idIndexMarker550"/> Docker instances of the database<a id="_idIndexMarker551"/> or other service components. We implemented integration tests for <strong class="source-inline">VetReviewRepository</strong> by creating a MongoDB test container. </p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor129"/>Summary</h1>
			<p>We began this chapter with the testing pyramid and striking a fine balance in test automation with unit testing, service testing, and integration testing. We jumpstarted with some basics of unit testing, such as leveraging mocks and spies to write unit tests. We then dived into how we can write service tests to test various RESTful endpoints using a reactive HTTP client in the Micronaut framework. Finally, we explored the exciting world of test containers for integration testing. We wrote integration tests using <strong class="source-inline">Testcontainer</strong> to instantiate MongoDB in the test environment. </p>
			<p>This chapter provides you with a firm understanding of testing at various levels, such as unit, service, or integration in the Micronaut framework. After subtle yet nimble theoretical discussions, we followed up with good hands-on examples to enhance your practical skillset in automated testing in the Micronaut framework.</p>
			<p>In the next chapter, we will explore how we can handle microservice architecture concerns in the Micronaut framework.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor130"/>Questions</h1>
			<ol>
				<li>What is unit testing?</li>
				<li>What is mocking in unit testing?</li>
				<li>How can we mock in the Micronaut framework using JUnit?</li>
				<li>What is spying in unit testing?</li>
				<li>How can we spy in the Micronaut framework using JUnit? </li>
				<li>How can we write service tests in the Micronaut framework?</li>
				<li>What are test containers?</li>
				<li>How can you use test containers in the Micronaut framework?</li>
				<li>How do you write integration tests in the Micronaut framework?</li>
			</ol>
		</div>
	</body></html>