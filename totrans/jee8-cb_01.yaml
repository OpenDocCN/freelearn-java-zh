- en: New Features and Improvements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新功能和改进
- en: Java EE 8 is a big release, desired and anticipated by the global community
    for about four years. More than ever before, the whole platform is now even more
    robust, mature, and stable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8是一个重大的版本，全球社区期待了大约四年。现在，整个平台比以往任何时候都更加健壮、成熟和稳定。
- en: This chapter will cover the main APIs that we can highlight for Java EE 8\.
    Not that they are the only topics covered by this release—far from it—but they
    have a big role in the enterprise context and are worthy of a careful look inside.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍我们可以突出显示的Java EE 8的主要API。虽然它们并不是这个版本涵盖的唯一主题——远非如此——但在企业环境中它们起着重要作用，值得仔细研究。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Running your first Bean Validation 2.0 code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个Bean Validation 2.0代码
- en: Running your first CDI 2.0 code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个CDI 2.0代码
- en: Running your first JAX-RS 2.1 code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个JAX-RS 2.1代码
- en: Running your first JSF 2.3 code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个JSF 2.3代码
- en: Running your first JSON-P 1.1 code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个JSON-P 1.1代码
- en: Running your first JSON-B 1.0
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个JSON-B 1.0
- en: Running your first Servlet 4.0 code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个Servlet 4.0代码
- en: Running your first Security API 1.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个Security API 1.0
- en: Running your first MVC 1.0 code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个MVC 1.0代码
- en: Running your first Bean Validation 2.0 code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的第一个Bean Validation 2.0代码
- en: Bean Validation is a Java specification that basically helps you to protect
    your data. Through its API, you can validate fields and parameters, express constraints
    using annotations, and extend your customs' validation rules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation是一个Java规范，基本上帮助您保护您的数据。通过其API，您可以验证字段和参数，使用注解表达约束，并扩展您自定义的验证规则。
- en: It can be used both with Java SE and Java EE.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以与Java SE和Java EE一起使用。
- en: In this recipe, you will have a glimpse of Bean Validation 2.0\. It doesn't
    matter whether you are new to it or already using version 1.1; this content will
    help you get familiar with some of its new features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将一瞥Bean Validation 2.0。无论您是初学者还是已经在使用1.1版本，这些内容都将帮助您熟悉其一些新功能。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, you need to add the right Bean Validation dependency to your project,
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将正确的Bean Validation依赖项添加到您的项目中，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we need to create an object with some fields to be validated:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个包含一些待验证字段的对象：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we create a `test` class to validate those constraints:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`test`类来验证这些约束：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our `User` class uses three of the new constraints introduced by Bean Validation
    2.0:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`User`类使用了Bean Validation 2.0引入的三个新约束：
- en: '`@NotBlank`: Assures that the value is not null, empty, or an empty string
    (it trims the value before evaluation, to make sure there aren''t spaces).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotBlank`: 确保值不是null、空或空字符串（在评估之前会修剪值，以确保没有空格）。'
- en: '`@Email`: Allows only a valid email format. Forget those crazy JavaScript functions!'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Email`: 只允许有效的电子邮件格式。忘记那些疯狂的JavaScript函数吧！'
- en: '`@NotEmpty`: Ensures that a list has at least one item.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotEmpty`: 确保列表至少有一个项目。'
- en: '`@PositiveOrZero`: Guarantees that a number is equal or greater than zero.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PositiveOrZero`: 保证一个数字等于或大于零。'
- en: 'Then we create a `test` class (using JUnit) to test our validations. It first
    instantiates `Validator`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个`test`类（使用JUnit）来测试我们的验证。它首先实例化`Validator`：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Validator` is an API that validates beans according to the constraints defined
    for them.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validator`是一个API，根据为它们定义的约束来验证bean。'
- en: 'Our first `test` method tests a valid user, which is a `User` object that has:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个`test`方法测试了一个有效的用户，它是一个具有以下属性的`User`对象：
- en: Name not empty
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称不能为空
- en: Valid email
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的电子邮件
- en: '`profileId` list only with integers greater than zero:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`profileId`列表只包含大于零的整数：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, the validation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进行验证：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `validate()` method from `Validator` returns a set of constraint violations
    found, if any, or an empty set if there are no violations at all.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validator`的`validate()`方法返回找到的约束违规集（如果有），如果没有违规，则返回一个空集。'
- en: 'So, for a valid user it should return an empty set:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于一个有效的用户，它应该返回一个空集：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the other methods work with variations around this model:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法与此模型略有不同：
- en: '`invalidName()`: Uses an empty name'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidName()`: 使用一个空名称'
- en: '`invalidEmail()`: Uses a malformed email'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidEmail()`: 使用一个格式错误的电子邮件'
- en: '`invalidId()`: Adds some negative numbers to the list'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidId()`: 向列表中添加一些负数'
- en: 'Note that the `invalidId()` method adds two negative numbers to the list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`invalidId()`方法将两个负数添加到列表中：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, we expect two constraint violations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们预计会有两个约束违规：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In other words, `Validator` checks not only the constraints violated, but how
    many times they are violated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`Validator` 不仅检查违反的约束，还检查它们被违反的次数。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can check the Bean Validation 2.0 specification at [http://beanvalidation.org/2.0/spec/](http://beanvalidation.org/2.0/spec/)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [http://beanvalidation.org/2.0/spec/](http://beanvalidation.org/2.0/spec/)
    查看Bean Validation 2.0规范。
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-beanvalidation/](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-beanvalidation/)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该菜谱的完整源代码位于 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-beanvalidation/](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-beanvalidation/)
- en: Running your first CDI 2.0 code
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您的第一个 CDI 2.0 代码
- en: '**Context and Dependency Injection** (**CDI**) is certainly one of the most
    important APIs for the Java EE platform. In version 2.0, it also works with Java
    SE.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文和依赖注入**（**CDI**）无疑是 Java EE 平台最重要的 API 之一。在 2.0 版本中，它也支持 Java SE。'
- en: 'Nowadays, CDI has an impact on many other APIs in the Java EE platform. As
    said in an interview for *Java EE 8 – The Next Frontier* project:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CDI 对 Java EE 平台上的许多其他 API 都产生了影响。正如在 *Java EE 8 – The Next Frontier* 项目的一次采访中所说：
- en: '"If there was CDI by the time we created JSF, it would be made completely different."'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我们在创建 JSF 的时候就有 CDI，它将会变得完全不同。”
- en: – Ed Burns, JSF Spec Lead
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: – Ed Burns，JSF 规范负责人
- en: There is a lot of new features in CDI 2.0\. This recipe will cover Observer
    Ordering to give you a quick start.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 2.0 中有很多新特性。本菜谱将涵盖观察者排序，让您快速入门。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, you need to add the right CDI 2.0 dependency to your project. To make
    things easier at this point, we are going to use CDI SE, the dependency that allows
    you to use CDI without a Java EE server:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将正确的 CDI 2.0 依赖项添加到您的项目中。为了简化这一点，我们将使用 CDI SE，这是一个允许您在没有 Java EE 服务器的情况下使用
    CDI 的依赖项：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This recipe will show you one of the main features introduced by CDI 2.0: Ordered
    Observers. Now, you can turn the observers job into something predictable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将向您展示 CDI 2.0 引入的主要功能之一：有序观察者。现在，您可以将观察者的工作变成可预测的：
- en: 'First, let''s make an event to be observed:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个要观察的事件：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we build our observers and the server that will fire them:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们构建我们的观察者和将触发它们的服务器：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, don''t forget to add the `beans.xml` file into the `META-INF` folder:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了将 `beans.xml` 文件添加到 `META-INF` 文件夹中：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you run it, you should see a result like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行，您应该看到如下结果：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we are building a server to manage our event and observers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们正在构建一个服务器来管理我们的事件和观察者：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will give us all the resources needed to run the recipe as if it was a
    Java EE server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供运行菜谱所需的所有资源，就像它是一个 Java EE 服务器一样。
- en: 'Then we build an observer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们构建一个观察者：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we have three important topics:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三个重要的话题：
- en: '`@Observes`: This annotation is used to tell the server that it needs to watch
    the events fired with `MyEvent`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Observes`：此注解用于告诉服务器它需要观察使用 `MyEvent` 触发的事件'
- en: '`@Priority`: This annotation informs in which priority order this observer
    needs to run; it receives an `int` parameter, and the execution order is ascendant'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Priority`：此注解通知观察者需要运行的优先级顺序；它接收一个 `int` 参数，执行顺序是升序的'
- en: '`MyEvent event`: The event being observed'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyEvent event`：正在观察的事件'
- en: On the `thisEventBefore` method and `thisEventAfter`, we only changed the `@Priority`
    value and the server took care of running it in the right order.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `thisEventBefore` 方法和 `thisEventAfter` 中，我们只更改了 `@Priority` 的值，服务器负责按正确的顺序运行它。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The behavior would be exactly the same in a Java EE 8 server. You just wouldn''t
    need `SeContainerInitializer` and would need to change the dependencies to the
    following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 8 服务器中，行为将完全相同。您只需不需要 `SeContainerInitializer`，并且需要将依赖项更改为以下内容：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can stay tuned with everything related to the CDI Specification at [http://www.cdi-spec.org/](http://www.cdi-spec.org/)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过 [http://www.cdi-spec.org/](http://www.cdi-spec.org/) 了解与 CDI 规范相关的一切
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-cdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-cdi)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该菜谱的源代码位于 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-cdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-cdi)
- en: Running your first JAX-RS 2.1 code
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您的第一个 JAX-RS 2.1 代码
- en: JAX-RS is an API designed to give a portable and standard way for building RESTful
    web services in Java. This is one of the most used technologies for data transporting
    between different applications that uses some network (internet included) for
    communication.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS是一个API，旨在为Java提供一种便携和标准的方式来构建RESTful Web服务。这是在应用程序之间传输数据（包括互联网）时最常用的技术之一。
- en: One of the coolest features introduced by the 2.1 release is **Server-Sent Events**
    (**SSE**), which will be covered in this recipe. SSE is a specification created
    by HTML5 where it has established a channel between server and client, one way
    only from server to client. It is a protocol that transports a message containing
    some data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1版本引入的最酷的功能之一是**服务器发送事件**（**SSE**），它将在本菜谱中介绍。SSE是由HTML5创建的一个规范，其中在服务器和客户端之间建立了一个通道，单向从服务器到客户端。它是一种传输包含一些数据的消息的协议。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start by adding the right dependency to our project:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的项目中添加正确的依赖项开始：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You surely noticed that we are using Jersey here. Why? Because Jersey is the
    reference implementation for JAX-RS, which means that all JAX-RS specifications
    are first implemented through Jersey.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定注意到了我们在这里使用的是Jersey。为什么？因为Jersey是JAX-RS的参考实现，这意味着所有JAX-RS规范都是首先通过Jersey实现的。
- en: Moreover, with Jersey we can use Grizzly to start a small local server, which
    will be useful for this recipe, as we need just a few server features to show
    the SSE behavior.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用Jersey，我们可以使用Grizzly启动一个小型本地服务器，这对于这个菜谱很有用，因为我们只需要几个服务器功能来展示SSE行为。
- en: Further on in this book, we will use a full GlassFish to build more JAX-RS recipes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续内容中，我们将使用完整的GlassFish来构建更多的JAX-RS菜谱。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we create a class that will be our server:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个将成为我们服务器的类：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we create a JAX-RS endpoint to send the events to the clients:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个JAX-RS端点，将事件发送到客户端：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we create a client class to consume the events generated from the server:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个客户端类来消费从服务器生成的事件：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To try it out, you have to first run the `ServerMock` class and then the `ClientConsumer`
    class. If everything worked well, you should see something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试它，你首先需要运行`ServerMock`类，然后是`ClientConsumer`类。如果一切顺利，你应该会看到类似这样的内容：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These are the messages sent from the server to the client.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是从服务器发送到客户端的消息。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe is made up of three parts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱由三个部分组成：
- en: The server, represented by the `ServerMock` class
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器，由`ServerMock`类表示
- en: The SSE engine, represented by the `SseResource` class
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSE引擎，由`SseResource`类表示
- en: The client, represented by the `ClientConsumer` class
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端，由`ClientConsumer`类表示
- en: 'So once `ServerMock` is instantiated, it registers the `SseResource` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦`ServerMock`被实例化，它就会注册`SseResource`类：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then two key methods from `SseResource` take place. The first one adds messages
    to the server queue:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`SseResource`的两个关键方法开始执行。第一个方法将消息添加到服务器队列：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second one consumes this queue and sends the messages to the clients:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法消费这个队列并将消息发送到客户端：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this one has a media type `SERVER_SENT_EVENTS`, introduced in this
    version for this very purpose. And finally, we have our client. In this recipe,
    it is both posting and consuming messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个版本引入了一个媒体类型`SERVER_SENT_EVENTS`，正是为了这个目的。最后，我们有我们的客户端。在这个菜谱中，它既是发布消息也是消费消息。
- en: 'It consumes here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里消费：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It posts here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发布：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can stay tuned with everything related to JAX-RS at [https://github.com/jax-rs](https://github.com/jax-rs)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/jax-rs](https://github.com/jax-rs)上关注与JAX-RS相关的所有内容。
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jaxrs](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jaxrs)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱的源代码在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jaxrs](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jaxrs)
- en: Running your first JSF 2.3 code
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的第一个JSF 2.3代码
- en: '**JavaServer Faces** (**JSF**) is the Java technology made to simplify the
    process of building a UIs, despite how it''s made for the frontend and the UI
    is built in the backend.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaServer Faces**（**JSF**）是Java技术，旨在简化UI的构建过程，尽管它是为前端设计的，而UI是在后端构建的。'
- en: With JSF, you can build components and use (or reuse) them in the UI in an extensible
    way. You can also use other powerful APIs, such as CDI and Bean Validation, to
    improve your application and its architecture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSF，你可以构建组件并以可扩展的方式在UI中使用（或重用）它们。你还可以使用其他强大的API，如CDI和Bean验证，来改进你的应用程序及其架构。
- en: In this recipe, we will use the `Validator` and `Converter` interfaces with
    the new feature introduced by version 2.3, which is the possibility of using them
    with generic parameters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `Validator` 和 `Converter` 接口，以及版本 2.3 引入的新功能，即可以使用泛型参数使用它们。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'First, we need to add the dependencies needed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加所需的依赖项：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create a `User` class as the main object of our recipe:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `User` 类作为我们菜谱的主要对象：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we create a `UserBean` class to manage our UI:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个 `UserBean` 类来管理我们的 UI：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we implement the `Converter` interface with a `User` parameter:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 `User` 参数实现 `Converter` 接口：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we implement the `Validator` interface with a `User` parameter:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 `User` 参数实现 `Validator` 接口：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And then we create our UI using all of them:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用所有这些来创建我们的用户界面：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Don't forget to run it in a Java EE 8 server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 Java EE 8 服务器上运行它。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UserBean` class manages the communication between the UI and the server.
    Once you instantiate the `user` object, it is available for both of them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserBean` 类管理 UI 和服务器之间的通信。一旦实例化 `user` 对象，它对两者都是可用的。'
- en: That's why when you run it, the `Name | E-mail` is already filled (the `user` object
    is instantiated when the `UserBean` class is created by the server).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当您运行它时，`Name | E-mail` 已经填写（当服务器创建 `UserBean` 类时，`user` 对象被实例化）。
- en: 'We associated the `userAction()` method from the `UserBean` class to the `Validate` button
    of the UI:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `UserBean` 类中的 `userAction()` 方法关联到 UI 的 `Validate` 按钮上：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can create other methods in `UserBean` and do the same to empower your application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `UserBean` 中创建其他方法并执行相同的操作以增强您的应用程序。
- en: 'The whole core of our recipe is represented by just a single line in the UI:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们菜谱的整个核心在 UI 中只代表一行：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, our two implemented interfaces used here are `userConverter` and `userValidator`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里使用的两个实现接口是 `userConverter` 和 `userValidator`。
- en: Basically, the `UserConverter` class (with `getAsString` and `getAsObject` methods)
    converts an object to/from a string and vice versa, according to the logic defined
    by you.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`UserConverter` 类（具有 `getAsString` 和 `getAsObject` 方法）根据您定义的逻辑将对象转换为字符串或从字符串转换为对象，反之亦然。
- en: 'We have just mentioned it in the preceding code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的代码片段中提到了它：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The server uses the `userConverter` object, calls the `getAsString` method,
    and prints the result using the preceding expression language.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用 `userConverter` 对象，调用 `getAsString` 方法，并使用前面的表达式语言打印结果。
- en: Finally, the `UserValidator` class is automatically called when you submit the
    form, by calling its `validate` method, and applying the rules defined by you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您提交表单时，会自动调用 `UserValidator` 类，通过调用其 `validate` 方法并应用您定义的规则。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You could increase the validators by adding a Bean Validation on it and, for
    example, defining the `email` property from `User` with an `@Email` constraint.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加 Bean Validation 来增加验证器，例如，使用 `@Email` 约束定义 `User` 中的 `email` 属性。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can stay tuned with everything related to JSF at [https://javaserverfaces.github.io/](https://javaserverfaces.github.io/)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过 [https://javaserverfaces.github.io/](https://javaserverfaces.github.io/)
    跟踪与 JSF 相关的所有内容。
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsf](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsf)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱的源代码在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsf](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsf)
- en: Running your first JSON-P 1.1 code
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您的第一个 JSON-P 1.1 代码
- en: JSON-Pointer is the Java API for JSON processing. By processing,  we mean generating,
    transforming, parsing, and querying JSON strings and/or objects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-Pointer 是用于 JSON 处理的 Java API。我们所说的处理，是指生成、转换、解析和查询 JSON 字符串和/或对象。
- en: In this recipe, you will learn how to use JSON Pointer to get a specific value
    from a JSON message in a very easy way.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何以非常简单的方式使用 JSON Pointer 从 JSON 消息中获取特定的值。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s get our `dependency`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取我们的 `dependency`：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we define a JSON message to represent a `User` object:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个 JSON 消息来表示一个 `User` 对象：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we create a method to read it and print the values we want:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个方法来读取它并打印我们想要的值：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The execution of this code prints the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码会打印以下内容：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The JSON Pointer is a standard defined by the **Internet Engineering Task Force** (**IETF**)
    under **Request for Comments** (**RFC**) 6901\. The standard basically says that
    a JSON Pointer is a string that identifies a specific value in a JSON document.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Pointer 是由 **互联网工程任务组**（**IETF**）在 **请求评论**（**RFC**）6901 中定义的标准。该标准基本上说
    JSON Pointer 是一个字符串，用于标识 JSON 文档中的特定值。
- en: Without a JSON Pointer, you would need to parse the whole message and iterate
    through it until you find the desired value; probably lots of ifs, elses, and
    things like that.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 没有JSON Pointer，你需要解析整个消息并遍历它，直到找到所需值；可能需要很多 if、else 以及类似的东西。
- en: So, JSON Pointer helps you to decrease the written code dramatically by doing
    this kind of operation in a very elegant way.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JSON Pointer 通过以非常优雅的方式执行此类操作，帮助你显著减少编写代码的数量。
- en: See also
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: You can stay tuned with everything related to JSON-P at [https://javaee.github.io/jsonp/](https://javaee.github.io/jsonp/)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以关注与 JSON-P 相关的所有内容，请访问 [https://javaee.github.io/jsonp/](https://javaee.github.io/jsonp/)
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonp](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonp)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本菜谱的源代码位于 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonp](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonp)
- en: Running your first JSON-B code
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的第一个 JSON-B 代码
- en: JSON-B is an API for converting Java objects to/from JSON messages in a standardized
    way. It defines a default mapping algorithm to convert Java classes to JSON and
    still lets you customize your own algorithms.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-B 是一个 API，用于以标准化的方式将 Java 对象转换为 JSON 消息。它定义了一个默认的映射算法，将 Java 类转换为 JSON，同时仍然允许你自定义自己的算法。
- en: With JSON-B, Java EE now has a complete set of tools to work with JSON, such
    as JSON API, and JSON-P. No third-party frameworks are needed anymore (although
    you are still free to use them).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 JSON-B 的加入，Java EE 现在有一套完整的工具来处理 JSON，如 JSON API 和 JSON-P。不再需要第三方框架（尽管你仍然可以自由使用它们）。
- en: This quick recipe will show you how to use JSON-B to convert a Java object to
    and from a JSON message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本快速菜谱将展示如何使用 JSON-B 将 Java 对象转换为 JSON 消息，并从 JSON 消息中转换回来。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s add our dependencies to the project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中添加我们的依赖项：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create a `User` class as a model for our JSON message:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `User` 类作为我们 JSON 消息的模型：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, let''s create a class to use JSON-B to transform an object:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个类来使用 JSON-B 将对象进行转换：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The result printed is:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的结果是：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first line is the object transformed into a JSON string. The second is the
    same string converted into an object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是将对象转换为 JSON 字符串。第二行是将相同的字符串转换回对象。
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: It uses the getters and setters defined in the `User` class to transform both
    ways and that's why they are so important.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `User` 类中定义的获取器和设置器进行双向转换，这就是为什么它们如此重要的原因。
- en: See also
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: You can stay tuned with everything related to JSON-B at [http://json-b.net/](http://json-b.net/)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以关注与 JSON-B 相关的所有内容，请访问 [http://json-b.net/](http://json-b.net/)
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonb)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本菜谱的源代码位于 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-jsonb)
- en: Running your first Servlet 4.0 code
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的第一个 Servlet 4.0 代码
- en: Servlet 4.0 is one the of biggest APIs of Java EE 8\. Since the very beginning
    of the Java EE platform (the old J2EE), the Servlet specification has always played
    a key role.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 4.0 是 Java EE 8 中最大的 API 之一。自从 Java EE 平台（旧 J2EE）的诞生以来，Servlet 规范始终扮演着关键角色。
- en: The coolest additions of this version are surely HTTP/2.0 and Server Push. Both
    of them bring performance improvements to your application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本版本最酷的添加功能无疑是 HTTP/2.0 和服务器推送。两者都为你的应用程序带来了性能提升。
- en: This recipe will use Server Push to do one of the most basic tasks in a web
    page—loading an image.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将使用服务器推送来完成网页中最基本的任务之一——加载图片。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s add the dependencies that we need:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们需要的依赖项：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a servlet:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 servlet：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To try it, run the project in a Java EE 8 server and open this URL:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要尝试它，请在 Java EE 8 服务器上运行项目并打开此 URL：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We use the `PushBuilder` object to send an image to the client before it is
    requested by the `img src` tag. In other words, the browser doesn't need to do
    another request (what it usually does with `img src`) to have an image available
    for rendering.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`PushBuilder`对象在`img src`标签请求之前将图像发送到客户端。换句话说，浏览器不需要再进行另一个请求（它通常使用`img src`进行）来渲染图像。
- en: It might seem as if it doesn't make too much difference for a single image,
    but it would with dozens, hundreds, or thousands of images. Less traffic for your
    client and from your server. Better performance for all!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个图像来说，这似乎没有太大的区别，但如果是有数十、数百或数千个图像，那就大不相同了。减少客户端和服务器端的流量。对所有都带来更好的性能！
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you are using JSF, you can get the benefits from Server Push for free! You
    don't even need to rewrite a single line of your code, as JSF relies on the Server
    Push specification.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用JSF，您可以免费获得服务器推送的好处！您甚至不需要重写一行代码，因为JSF依赖于服务器推送规范。
- en: Just make sure that you run it under the HTTPS protocol, as HTTP/2.0 only works
    under it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保您在HTTPS协议下运行它，因为HTTP/2.0仅在此协议下工作。
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can stay tuned with everything related to the Servlet specification at [https://github.com/javaee/servlet-spec](https://github.com/javaee/servlet-spec)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以关注与Servlet规范相关的所有信息，请访问[https://github.com/javaee/servlet-spec](https://github.com/javaee/servlet-spec)
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-servlet)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个食谱的源代码位于[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-servlet)
- en: Running your first Security API code
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您的第一个Security API代码
- en: Security is one of the top concerns when you build an enterprise application.
    Luckily, the Java EE platform now has this API that handles many of the enterprise
    requirements in a standardized way.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建企业应用程序时，安全性是首要关注的问题之一。幸运的是，Java EE平台现在有一个API，可以以标准化的方式处理许多企业需求。
- en: In this recipe, you will learn how to define roles and give them the right authorization
    based on rules defined in the methods that manage sensitive data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何根据管理敏感数据的方法中定义的规则来定义角色并授予它们正确的授权。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We start by adding our dependencies to the project:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将项目依赖项添加到项目中：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We first create a `User` entity:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个`User`实体：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we create a class to store our security roles:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个类来存储我们的安全角色：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we create a stateful bean to manage our user operations:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个有状态的bean来管理我们的用户操作：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we need to create an executor for each role:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为每个角色创建一个执行器：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And finally, we create a test class to try our security rules.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个测试类来测试我们的安全规则。
- en: 'Our code uses three test methods: `asAdmin()`, `asOperator()`, and `asAnonymous()`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码使用了三个测试方法：`asAdmin()`、`asOperator()`和`asAnonymous()`。
- en: 'First, it tests `asAdmin()`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它测试`asAdmin()`：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then it tests `asOperator()`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它测试`asOperator()`：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And, finally it tests `asAnonymous()`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它测试`asAnonymous()`：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This class is huge! For the full source code, check the link at the end of the
    recipe.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常大！要查看完整的源代码，请查看食谱末尾的链接。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The whole point in this recipe is to do with the `@RolesAllowed`, `@RunsAs`,
    and `@PermitAll` annotations. They define what operations each role can do and
    what happens when a user tries an operation using the wrong role.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的整个重点在于`@RolesAllowed`、`@RunsAs`和`@PermitAll`注解。它们定义了每个角色可以执行的操作以及当用户尝试使用错误角色执行操作时会发生什么。
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What we did here is called **programmatic security;** that is, we defined the
    security rules and roles through our code (the program). There's another approach
    called **declarative security**, where you declare the rules and roles through
    application and server configurations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是称为**程序化安全**；也就是说，我们通过代码（程序）定义了安全规则和角色。还有一种称为**声明式安全**的方法，其中您通过应用程序和服务器配置声明规则和角色。
- en: One good step up for this recipe is if you evolve the roles management to a
    source outside the application, such as a database or a service.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱来说，一个很好的提升步骤是将角色管理扩展到应用程序之外，例如数据库或服务。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can stay tuned with everything related to Security API at [https://github.com/javaee-security-spec](https://github.com/javaee-security-spec)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以关注与Security API相关的所有信息，请访问[https://github.com/javaee-security-spec](https://github.com/javaee-security-spec)
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-security](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-security)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱的源代码在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-security](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-security)
- en: Running your first MVC 1.0 code
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的第一个 MVC 1.0 代码
- en: 'If you are following the news about Java EE 8, you may now be wondering: *why
    is MVC 1.0 here if it was dropped from the Java EE 8 umbrella?*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在关注 Java EE 8 的新闻，你现在可能想知道：*为什么 MVC 1.0 仍然存在，尽管它已经被从 Java EE 8 的伞下移除？*
- en: Yes, it is true. MVC 1.0 doesn't belong (anymore) to the Java EE 8 release.
    But it didn't reduce the importance of this great API and I'm sure it will change
    the way some other APIs work in future releases (for example, JSF).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是真的。MVC 1.0 已经不再属于 Java EE 8 版本。但这并没有减少这个伟大 API 的重要性，我相信它将在未来的版本中改变一些其他
    API 的工作方式（例如，JSF）。
- en: So why not cover it here? You will use it anyway.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不在这里介绍它呢？你无论如何都会用到它。
- en: This recipe will show you how to use a Controller (the C) to inject a Model
    (the M) into the View (the V). It also brings some CDI and JAX-RS to the party.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示如何使用 Controller（C）将 Model（M）注入到 View（V）中。它还引入了一些 CDI 和 JAX-RS 技术。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Add the proper dependencies to your project:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将适当的依赖项添加到你的项目中：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Start by creating a root for your JAX-RS endpoints:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先为你的 JAX-RS 端点创建一个根：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a `User` class (this will be your MODEL):'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `User` 类（这将是你的 MODEL）：
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, create a Session Bean, which will be injected later in your Controller:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个 Session Bean，稍后将在你的 Controller 中注入：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, create the Controller:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 Controller：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And finally, the web page (the View):'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是网页（View）：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run it on a Java EE 8 server and access this URL:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 8 服务器上运行它，并访问此 URL：
- en: '`http://localhost:8080/ch01-mvc/webresources/userController`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch01-mvc/webresources/userController`'
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main actor in this whole scenario is the `Models` class injected into the
    Controller:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 整个场景中的主要角色是注入到 Controller 中的 `Models` 类：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It''s a class from MVC 1.0 API that owns the responsibility, in this recipe,
    of letting the `User` object be available for the View layer. It''s injected (using
    CDI) and uses another injected bean, `userBean`, to do it:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它是 MVC 1.0 API 中的一个类，在这个菜谱中负责让 `User` 对象在 View 层可用。它通过 CDI 注入，并使用另一个注入的 Bean，`userBean`
    来实现：
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So, the View can easily access the values from the `User` object using expression
    language:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，View 可以轻松地通过表达式语言访问 `User` 对象的值：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can stay tuned with everything related to MVC specification at [https://github.com/mvc-spec](https://github.com/mvc-spec)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/mvc-spec](https://github.com/mvc-spec) 上关注与 MVC 规范相关的一切。
- en: The source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-mvc](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-mvc)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱的源代码在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-mvc](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter01/ch01-mvc)
