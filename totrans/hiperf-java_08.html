<html><head></head><body>
		<div id="_idContainer020">
			<h1 class="chapter-number" id="_idParaDest-144"><a id="_idTextAnchor143"/>8</h1>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Memory Leaks</h1>
			<p>Memory leaks occur as a result of improper<a id="_idIndexMarker358"/> memory management and can directly impact the performance of an application. These leaks occur when memory is improperly deallocated or when it is allocated but becomes inaccessible. Improper memory management not only negatively impacts performance but can also hinder scalability, result in system crashes due to <strong class="source-inline">OutOfMemoryError</strong>, and ruin the user experience. Many developers implicitly trust Java’s garbage collector (covered in <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>) to manage memory while their applications run; however, despite the garbage collector’s incredible capabilities, memory leaks are a <span class="No-Break">persistent issue.</span></p>
			<p>The garbage collector is not faulty; rather, memory leaks occur when the garbage collector is unable to reclaim memory that stores objects that are no longer needed by the application. Improper referencing is the primary culprit, and fortunately, we can avoid this. This chapter provides techniques, design patterns, coding examples, and best practices to avoid <span class="No-Break">memory leaks.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Proper referencing</span></li>
				<li>Listeners <span class="No-Break">and loaders</span></li>
				<li>Caching <span class="No-Break">and threads</span></li>
			</ul>
			<p>By the end of this chapter, you should have a comprehensive understanding of what can lead to memory leaks at runtime and the potential devastation they can inflict on our Java applications, and you will know how to prevent them purposefully and efficiently. You can gain confidence in implementing your own memory leak prevention strategy by experimenting with the sample <span class="No-Break">code provided.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter08</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Proper referencing</h1>
			<p>It is undeniable – memory leaks can result in a gradual decrease in resource availability and lead to sluggish systems and potential system crashes. The good news is that there are two major components that offer a solution. One component<a id="_idIndexMarker359"/> is the garbage collector that is part of the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>). It is highly capable and one of the shining characteristics of the Java language. The second, and more important, component is the developer. As Java developers, we have the power to minimize and even eliminate memory leaks by taking a purposeful approach to memory management in <span class="No-Break">our code.</span></p>
			<p>To support the developer component of the solution to eradicate memory leaks, this section will focus on how to properly reference objects so that they do not lead to memory leaks, how to identify memory leaks, and the strategies to <span class="No-Break">avoid them.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>An introduction to references</h2>
			<p>Perhaps the most important<a id="_idIndexMarker360"/> aspect of avoiding memory leaks is to use proper referencing. This should be encouraged, since it puts control in the developer’s hands. Java offers a great toolbox to aid our efforts in this area. Specifically, there are several types of references, each with its own purpose and associated garbage <span class="No-Break">collector behavior.</span></p>
			<p class="callout-heading">References</p>
			<p class="callout">In Java, references are pointers to memory locations and are a critical component of memory management and memory <span class="No-Break">leak mitigation.</span></p>
			<p>Let’s examine the various types of referencing in Java, strong, soft, weak, and phantom, so we can determine which method is the most appropriate for any given use case. Remember, our overall purpose is to have efficient memory management and avoid memory links to increase the overall <a id="_idIndexMarker361"/>performance of our <span class="No-Break">Java applications.</span></p>
			<h3>Strong references</h3>
			<p><strong class="bold">Strong referencing</strong> is the most important reference<a id="_idIndexMarker362"/> type for us to focus<a id="_idIndexMarker363"/> on. Not only is it the default reference type in Java, but it is also the most common source of memory leaks. Objects that have a strong reference type are not eligible for garbage collection. To create a strong reference, we simply use a variable to directly reference <span class="No-Break">an object.</span></p>
			<p>In the following example code, we create a strong reference to an object using the <strong class="source-inline">sampleCorgiObject</strong> variable. As long as that variable contains a reference to the <strong class="source-inline">SampleCorgiObject</strong> instance, we will have that object in memory and the garbage collector will not be able to deallocate <span class="No-Break">its memory:</span></p>
			<pre class="source-code">
public class CH8StrongReferenceExample {
  public static void main(String[] args) {
    SampleCorgiObject sampleCorgiObject = new SampleCorgiObject();
    System.out.println(sampleCorgiObject);
  }
  static class SampleCorgiObject {
    @Override
    public String toString() {
      return "This is a SampleCorigObject instance.";
    }
  }
}</pre>			<p>This is the default reference type in Java for a reason. The typical use case is when we have objects that we need the entire time our application is running, such as configuration properties. We should use strong referencing with caution, especially when the objects are large. A best practice is to set our references to <strong class="source-inline">null</strong> as soon as they are no longer needed. This will empower<a id="_idIndexMarker364"/> the garbage collector to deallocate<a id="_idIndexMarker365"/> <span class="No-Break">associated memory.</span></p>
			<h3>Soft references</h3>
			<p><strong class="bold">Soft references</strong> present a flexible memory<a id="_idIndexMarker366"/> management approach<a id="_idIndexMarker367"/> for high memory efficiency. This approach permits the JVM to collect the referred objects when the system runs low on available memory. The goal of soft references is to avoid <strong class="source-inline">OutOfMemoryError</strong> and system crashes. When we create soft references, those objects are retained in memory only when there is sufficient space. This makes soft referencing an ideal solution to cache <span class="No-Break">large objects.</span></p>
			<p>It is important to understand that the JVM collects these objects that have soft references to them only when necessary. The JVM’s garbage collector will collect everything else it can first and then, as a final effort, collect objects with soft references, and only then if the system is running out <span class="No-Break">of memory.</span></p>
			<p>To implement a soft reference, we use the <strong class="source-inline">SoftReference</strong> class that is a part of the <strong class="source-inline">java.lang-ref</strong> package. Let’s look at an example <span class="No-Break">in code.</span></p>
			<p>We start our application by importing <strong class="source-inline">SoftReference</strong>. Then, we create our class header and initially create <strong class="source-inline">MyBougieObject</strong>, using strong referencing by <strong class="source-inline">myBougieObject</strong>. We then wrap it with <strong class="source-inline">SoftReference&lt;MyBougieObject&gt;</strong> to establish the soft reference. Note that we set <strong class="source-inline">myBougieObject</strong> to null, which ensures that our <strong class="source-inline">MyBougieObject</strong> instance is only accessible through the soft reference <span class="No-Break">we created:</span></p>
			<pre class="source-code">
import java.lang.ref.SoftReference;
public class CH8SoftReferenceExample {
  public static void main(String[] args) {
    MyBougieObject myBougieObject = new MyBougieObject("Cached 
    Object");
    SoftReference&lt;MyBougieObject&gt; softReference = new 
    SoftReference&lt;&gt;(myBougieObject);
    myBougieObject = null;</pre>			<p>In the next section of code, we attempt<a id="_idIndexMarker368"/> to review <strong class="source-inline">myBougieObject</strong> from the soft <a id="_idIndexMarker369"/>reference. We use <strong class="source-inline">System.gc()</strong> to provide a way to observe the behavior of our software references under normal conditions and then simulate <span class="No-Break">memory pressure:</span></p>
			<pre class="source-code">
    MyBougieObject retrievedObject = softReference.get();
    if (retrievedObject != null) {
        System.out.println("Object retrieved from soft reference: " 
          + retrievedObject);
    } else {
      System.out.println("The Object has been garbage collected by the 
      JVM.");
    }
    System.gc();
    retrievedObject = softReference.get();
    if (retrievedObject != null) {
      System.out.println("Object is still available after requesting 
      GC: " + retrievedObject);
    } else {
      System.out.println("The Object has been garbage collected after 
      requesting GC.");
    }
  }
}</pre>			<p>This last section implies our <span class="No-Break"><strong class="source-inline">MyBougieObject</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
class MyBougieObject {
  private String name;
  public MyBougieObject(String name) {
    this.name = name;
  }
  @Override
  public String toString() {
    return name;
  }
}</pre>			<p>Here is what the output<a id="_idIndexMarker370"/> might look like. Of course, the results will depend on your<a id="_idIndexMarker371"/> system’s <span class="No-Break">available memory:</span></p>
			<pre class="console">
Object retrieved from soft reference: Cached Object
Object is still available after requesting GC: Cached Object</pre>			<h3>Weak references</h3>
			<p>So far, we have covered <strong class="bold">strong references</strong> that prevent garbage collection and <strong class="bold">soft references</strong> that allow garbage collection<a id="_idIndexMarker372"/> as a last-ditch effort to reclaim memory. <strong class="bold">Weak references</strong> are unique in that they permit garbage collection<a id="_idIndexMarker373"/> only if the weak reference is the only reference to the specific object. This approach can be especially useful when we want more flexibility in our memory <span class="No-Break">management solutions.</span></p>
			<p>A common use of weak references is in caching when we want objects to remain in memory but not prevent them from being reclaimed by JVM’s garbage collection when a system runs low on memory. To implement a weak reference, we use the <strong class="source-inline">WeakReference</strong> class that is a part of the <strong class="source-inline">java.lang-ref</strong> package. Let’s look at an example in code. We start our code with the necessary <strong class="source-inline">import</strong> statement and the class declaration. As you can see in the following code block, we wrap our <strong class="source-inline">CacheCorgiObject</strong> in <strong class="source-inline">WeakReference</strong>, which can initially be accessed via the weak reference. When we set the strong reference (<strong class="source-inline">cacheCorgiObject</strong>) to null, we call <strong class="source-inline">System.gc()</strong> to invoke the JVM’s garbage collector. Depending on your system’s memory, the object might<a id="_idIndexMarker374"/> be collected, as it is available. Following <a id="_idIndexMarker375"/>the garbage collection, we call <strong class="source-inline">weakCacheCorgiObject.get()</strong>, and <strong class="source-inline">null</strong> is returned if the object collection <span class="No-Break">took place</span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.lang.ref.WeakReference;
public class CH8WeakReferenceExample {
  public static void main(String[] args) {
    CacheCorgiObject cacheCorgiObject = new CacheCorgiObject();
    WeakReference&lt;CacheCorgiObject&gt; weakCacheCorgiObject = new 
    WeakReference&lt;&gt;(cacheCorgiObject);
    System.out.println("Cache corgi object before GC: " + 
    weakCacheCorgiObject.get());
    cacheCorgiObject = null;
    System.gc();
    System.out.println("Cache corgi object after GC: " + 
    weakCacheCorgiObject.get());
  }
}
class CacheCorgiObject {
@Override
  protected void finalize() {
    System.out.println("CacheCorgiObject is being garbage collected");
  }
}</pre>			<p>Here is a sample output<a id="_idIndexMarker376"/> from our program. Results <a id="_idIndexMarker377"/>will vary, depending on the system’s <span class="No-Break">available memory:</span></p>
			<pre class="console">
Cache corgi object before GC: CacheCorgiObject@7344699f
Cache corgi object after GC: null
CacheCorgiObject is being garbage collected</pre>			<h3>Phantom references</h3>
			<p>Our last type of reference is a <strong class="bold">phantom reference</strong>. This reference type <a id="_idIndexMarker378"/>does not permit direct<a id="_idIndexMarker379"/> retrieval of the referenced object; instead, it provides a method to determine whether the object has been finalized and reclaimed by the JVM garbage collector. This happens without preventing the object from <span class="No-Break">being collected.</span></p>
			<p>Implementation requires two classes from the <strong class="source-inline">java.lang.ref</strong> package – <strong class="source-inline">PhantomReference</strong> and <strong class="source-inline">ReferenceQueue</strong>. Our example code demonstrates the garbage collector determining whether an object with a phantom reference is reachable. This means that the object has been <strong class="bold">finalized</strong> and is ready for garbage collection. When this is the case, the reference is queued, and our application is able to <span class="No-Break">respond accordingly:</span></p>
			<pre class="source-code">
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
public class CH8PhantomReferenceExample {
  public static void main(String[] args) throws InterruptedException {
    ReferenceQueue&lt;VeryImportantResource&gt; queue = new 
    ReferenceQueue&lt;&gt;();
    VeryImportantResource resource = new VeryImportantResource();
    PhantomReference&lt;VeryImportantResource&gt; phantomResource = new 
    PhantomReference&lt;&gt;(resource, queue);
    resource = null;
    System.gc();
    while (true) {
      if (queue.poll() != null) {
        System.out.println("ImportantResource has been garbage 
        collected and its phantom reference is enqueued");
        break;
      }
    }
  }
}
class VeryImportantResource {
  @Override
  protected void finalize() throws Throwable {
    System.out.println("Finalizing VeryImportantResource");
    super.finalize();
  }
}</pre>			<p>Adopting the phantom reference<a id="_idIndexMarker380"/> approach enables us to invoke our own memory-cleaning<a id="_idIndexMarker381"/> actions, based on an object with a phantom reference’s collection. This approach does not interfere with the normal garbage <span class="No-Break">collection operations.</span></p>
			<p class="callout-heading">Using the finalize() method</p>
			<p class="callout">The <strong class="source-inline">finalize()</strong> method has been depreciated<a id="_idIndexMarker382"/> and is scheduled for removal from Java in a future release. It is used in the previous code example simply to demonstrate the phantom reference approach and does not suggest using <strong class="source-inline">finalize()</strong>. Consult the Java documentation for <span class="No-Break">additional information.</span></p>
			<p>Now that we have reviewed proper referencing, we should have an appreciation for how much developer intervention can solve the memory leak problem. Further, examination of the coding examples should lead to confidence in implementing proper referencing throughout our <span class="No-Break">Java applications.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>Memory leak identification</h2>
			<p>One of the most important<a id="_idIndexMarker383"/> things we should implement in our Java applications is the ability to identify memory leaks. Our goal is to create high-performance Java applications, and memory leaks are counter to that goal. In order to identify memory leaks, we need to understand what symptoms indicate that a memory leak exists. These symptoms include increased garbage collection activity, <strong class="source-inline">OutOfMemoryError</strong>, and progressive performance degradation. Let’s look at five methods to identify <span class="No-Break">memory leaks.</span></p>
			<p>One of the most important methods to identify memory leaks is to review our code to ensure that we follow best practices and avoid common pitfalls, such as failing to clear static collections, not removing <strong class="bold">listeners</strong> after use, and caches that grow out of control. We will cover listeners later in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>A second method involves using a tool that can reveal which of our application’s objects consumes the <span class="No-Break">most memory.</span></li>
				<li>A third method is to use a tool to generate a heap dump, which is a moment-in-time snapshot of all objects currently in memory. This can help you analyze and detect <span class="No-Break">potential issues.</span></li>
			</ul>
			<p>When reviewing object retention, look for unusual or unwanted patterns. Examples include when objects have a longer life cycle than expected or a large number of objects of a specific type that you do not expect to see large <span class="No-Break">numbers of.</span></p>
			<p>A fifth method to identify memory leaks is to continually and iteratively test and profile your application. Once you identify a memory leak, you implement a fix, and should <span class="No-Break">then retest.</span></p>
			<p>We can use tools to help<a id="_idIndexMarker384"/> us identify<a id="_idIndexMarker385"/> memory leaks, including <strong class="bold">JProfiler</strong>, <strong class="bold">YourKit</strong>, <strong class="bold">Java Flight Recorder</strong> (<strong class="bold">JFR</strong>),  <strong class="bold">VisualVM</strong>, and the Eclipse <strong class="bold">Memory Analyzer Tool </strong>(<strong class="bold">MAT</strong>). If you want to take memory leak<a id="_idIndexMarker386"/> identification <a id="_idIndexMarker387"/>seriously, you should research these tools to see how<a id="_idIndexMarker388"/> you can leverage <span class="No-Break">their capabilities.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Memory leak avoidance strategies</h2>
			<p>Proper object referencing, as detailed<a id="_idIndexMarker389"/> earlier in this chapter, is a primary strategy to avoid memory leaks in your Java applications. Identifying and fixing memory leaks is another strategy, albeit a reactive one. These two strategies are important and have already been covered. Let’s briefly look at some <span class="No-Break">additional strategies.</span></p>
			<p>A third memory leak avoidance strategy is to properly manage collection objects. It is not uncommon for objects to be put into collections and then ignored or forgotten. This can result in memory leaks. So, to avoid this, we should develop our applications so that they regularly remove objects that are no longer required by our application. Using weak references can help with this. We should also be careful when using static collections. This type of collection has its life cycle linked with the <span class="No-Break">class loader.</span></p>
			<p>We should also be mindful of how we implement caches. The use of caches can significantly improve an application’s performance but can also result in memory leaks. When implementing caches, we should use soft references, set finite cache size limits, and continuously monitor <span class="No-Break">cache usage.</span></p>
			<p>A fifth strategy is to continuously use a profiling tool and test your application. This strategy requires a never-ending dedication to detecting and removing memory leaks in your application. It is an important strategy that should not be <span class="No-Break">taken lightly.</span></p>
			<p>When we implement a set of memory leak avoidance strategies, we have a better chance of ensuring our applications have <span class="No-Break">high performance.</span></p>
			<p>Next, we will review how listeners and loaders can be used to help avoid <span class="No-Break">memory leaks.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Listeners and loaders</h1>
			<p>Several aspects of our Java applications can impact performance and, more specifically, result in memory leaks. Two<a id="_idIndexMarker390"/> of those aspects are <strong class="bold">listeners</strong> and <strong class="bold">loaders</strong>. This section<a id="_idIndexMarker391"/> looks specifically at <strong class="bold">event listeners</strong> and <strong class="bold">class loaders</strong> and includes strategies to mitigate the risks of using them, without sacrificing the power and efficiencies they can provide to our <span class="No-Break">Java applications.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Event listeners</h2>
			<p>Event listeners are used to allow objects<a id="_idIndexMarker392"/> to react to events. This approach is used heavily in interactive applications and is a critical component of event-driven programming. These listeners can result in a highly interactive application; however, if not properly managed, they can be the source of <span class="No-Break">memory leaks.</span></p>
			<p>To understand the issue better, it is important to note that event listeners must subscribe to event sources so that they can receive notifications that need to be acted upon (e.g., a button click, or a non-player character in a game entering a predefined zone). As you would expect, each event listener maintains references to the event sources they subscribe to. A problem arises when an event source is no longer needed but is referenced by one or more listeners; this prevents the garbage collector from collecting the <span class="No-Break">event source.</span></p>
			<p>Here are some best practices<a id="_idIndexMarker393"/> to avoid memory leaks when working with <span class="No-Break">event listeners:</span></p>
			<ul>
				<li>Use weak references, as detailed earlier in <span class="No-Break">this chapter.</span></li>
				<li>Explicitly deregister listeners from event sources <span class="No-Break">when applicable.</span></li>
				<li>Implement static nested classes for listeners because they do not have implicit references to outer class instances. This approach should be used instead of implementing non-static <span class="No-Break">inner classes.</span></li>
				<li>Align your event listener life cycles with those of their associated <span class="No-Break">event sources.</span></li>
			</ul>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Class loaders</h2>
			<p>Class loaders enable us to dynamically<a id="_idIndexMarker394"/> load classes, making<a id="_idIndexMarker395"/> them a key component of <strong class="bold">Java’s Runtime Environment</strong> (<strong class="bold">JRE</strong>). Class loaders offer great power and flexibility through the support of polymorphism and extensibility. When our applications load classes dynamically, it illustrates that Java does not need to know about these classes at compile time. With this powerful flexibility comes the potential for memory leaks, which we need to mitigate, if <span class="No-Break">not eliminate.</span></p>
			<p>The JVM has a class loading delegation model that involves several class <span class="No-Break">loader types:</span></p>
			<ul>
				<li>A <strong class="bold">bootstrap class loader</strong> that loads Java’s core <span class="No-Break">API</span><span class="No-Break"><a id="_idIndexMarker396"/></span><span class="No-Break"> classes.</span></li>
				<li>An <strong class="bold">extension class loader</strong> that loads classes from directories, as specified<a id="_idIndexMarker397"/> in the <span class="No-Break"><strong class="source-inline">java.ext.dirs</strong></span><span class="No-Break"> property.</span></li>
				<li>An <strong class="bold">application class loader</strong> that loads classes defined<a id="_idIndexMarker398"/> by the application. These are loaded <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">classpath</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Class loaders are necessary, and when<a id="_idIndexMarker399"/> the loaded classes are retained in memory for longer than necessary, they can introduce memory leaks. The culprits here are typically with static fields in classes holding reference to objects that should otherwise be collected by the garbage collector, objects of loaded classes that are referenced by objects that have long lifespans, and a cache that retains class instances without proper management. Here are a few strategies to mitigate <span class="No-Break">these risks:</span></p>
			<ul>
				<li>Use <span class="No-Break">weak references</span></li>
				<li>Minimize the use of <span class="No-Break">static fields</span></li>
				<li>Make sure that custom class loaders are available to the garbage collection when no <span class="No-Break">longer needed</span></li>
				<li>Monitor, profile, and refine <span class="No-Break">as needed</span></li>
			</ul>
			<p>When we have a thorough understanding of loaders and listeners as well as strategies to mitigate their associated risks, we improve our chances of minimizing memory leaks in our <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Caching and threads</h1>
			<p>This section explores caching strategies, thread management, and the effective use of Java concurrency utilities. These are important concepts to embrace as we continue our journey of developing high-performance Java applications. We will explore these concepts, the associated best practices, and techniques to mitigate the risk of memory leaks introduced by <span class="No-Break">their use.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Caching strategies</h2>
			<p>In programming, we use <strong class="bold">caching</strong> to temporarily store<a id="_idIndexMarker400"/> data in memory locations to permit rapid access. This allows us to repeatedly access the data without causing lag or system crashes. The benefits of caching include more responsible applications and less load on longer-term storage solutions, such as databases and database servers. Of course, there are pitfalls. If we do not properly manage our caches, we can introduce significant memory leaks into <span class="No-Break">our applications.</span></p>
			<p>There are multiple caching strategies for us to consider; two of them you should already be familiar with, as they were covered earlier in this chapter, albeit not specific to caching. The first familiar strategy is to use weak references. When we use weak references with caching, we allow garbage collection when memory runs low. The second familiar strategy is using soft references. This strategy enables higher retention priority during garbage <span class="No-Break">collection cycles.</span></p>
			<p>Another caching strategy is referred to as <strong class="bold">Least Recently Used</strong> (<strong class="bold">LRU</strong>), and as the name suggests, we remove<a id="_idIndexMarker401"/> the least accessed items first, as they are the least likely to be used by our <span class="No-Break">application again.</span></p>
			<p><strong class="bold">Time to Live</strong> (<strong class="bold">TTL</strong>) is another useful caching<a id="_idIndexMarker402"/> strategy. The TTL approach tracks cache insertion times and automatically expires items based on a prescribed amount <span class="No-Break">of time.</span></p>
			<p>One additional caching strategy is using <strong class="bold">size-based eviction</strong>. This strategy ensures that caches<a id="_idIndexMarker403"/> do not exceed the amount of memory you set as the maximum boundary. The boundary can be set in terms of memory usage or the total number <span class="No-Break">of items.</span></p>
			<p>When we implement caching, we should be mindful of introducing memory leaks due to poor implementation. This purposeful approach requires us to conduct capacity planning, establish an eviction policy for the LRU and TTL approaches, and monitor our system. This monitoring requires subsequent fine-tuning <span class="No-Break">and retesting.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Thread management</h2>
			<p>We use <strong class="bold">threads</strong> in our applications to facilitate<a id="_idIndexMarker404"/> multiple concurrent operations. This makes better use of modern CPUs and improves the responsiveness of our Java applications. When we manage our threads manually, we can introduce memory leaks due to the complexity and error-prone nature of <span class="No-Break">managing threads.</span></p>
			<p>We can create threads in Java by extending the <strong class="source-inline">Thread</strong> class, or even by implementing the <strong class="source-inline">Runnable</strong> interface. These methods are a direct and easy way to use threads; however, it is not a recommended approach for large systems because they directly create and utilize threads, resulting in significant overhead. Instead of the direct approach, consider using Java’s <strong class="bold">Executor</strong> framework to abstract thread<a id="_idIndexMarker405"/> management from the <span class="No-Break">main application.</span></p>
			<p>Some best practices<a id="_idIndexMarker406"/> for thread management include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Favor Executor over direct <span class="No-Break">thread creation</span></li>
				<li>Limit the number of thread pools you use to <span class="No-Break">a minimum</span></li>
				<li>Support thread interruptions in <span class="No-Break">your code</span></li>
				<li>Monitor and <span class="No-Break">refine consistently</span></li>
			</ul>
			<p>Let’s look at a simple example<a id="_idIndexMarker407"/> to demonstrate proper thread usage. We will use the <strong class="source-inline">Executor</strong> framework. As you will see, the following application creates a fixed thread pool to run a set of tasks. Each task simulates a real-world operation by sleeping for a defined amount of time. As you walk through the code, you will see that the <strong class="source-inline">Executor</strong> framework is efficiently used to <span class="No-Break">manage threads:</span></p>
			<pre class="source-code">
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class CH8ThreadManagementExample {
  public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(5);
    for (int i = 0; i &lt; 10; i++) {
      final int taskId = i;
      executor.submit(() -&gt; {
        System.out.println("Executing task " + taskId + " Thread: " + 
        Thread.currentThread().getName());
        try {
          TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Task " + taskId + " was interrupted");
        }
      });
    }
    executor.shutdown();
    try {
      if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
        executor.shutdownNow();
        System.out.println("Executor did not terminate in the 
        specified time.");
        if (!executor.awaitTermination(60, TimeUnit.SECONDS))
          System.err.println("Pool did not terminate");
      }
    } catch (InterruptedException ie) {
        executor.shutdownNow();
        Thread.currentThread().interrupt();
    }
    System.out.println("Finished all threads");
  }
}</pre>			<p>This sample application provides<a id="_idIndexMarker408"/> an efficient method of managing concurrency in a <span class="No-Break">Java application.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Java concurrency utilities</h2>
			<p>We are fortunate that the <strong class="source-inline">java.util.concurrent</strong> package contains<a id="_idIndexMarker409"/> a set of utilities we can use for <strong class="bold">concurrency</strong>. These utilities empower us to write <a id="_idIndexMarker410"/>thread-safe applications that are reliable and scalable. The utilities help us address common pitfalls and challenges in concurrent programming, including data consistency, life cycle management, <span class="No-Break">and synchronization.</span></p>
			<p>The advantages of using the concurrency utilities that are part of the <strong class="source-inline">java.util.concurrent</strong> package includes making our applications more reliable, making them perform at a higher level, and simplifying the programming effort. Let’s look at five specific <span class="No-Break">concurrency utilities.</span></p>
			<p>Our first concurrency utility is the <strong class="source-inline">Executor</strong> framework that we previously covered. Looking at this framework closely reveals that there are multiple types of Executor services, including the <strong class="source-inline">ScheduledExecutorService</strong> interface. This interface can be used to introduce an execution delay. The primary interface, <strong class="source-inline">ExecutorService</strong>, empowers us to manage thread termination and helps us track our <span class="No-Break">synchronous tasks.</span></p>
			<p><strong class="bold">Synchronizers</strong> are another set of utilities<a id="_idIndexMarker411"/> that help us synchronize threads. These methods include <strong class="source-inline">CountDownLatch</strong>, <strong class="source-inline">CyclicBarrier</strong>, <strong class="source-inline">Exchanger</strong>, <strong class="source-inline">Phaser</strong>, and <strong class="source-inline">Semaphore</strong>. If you need to improve your thread management in your Java application, these methods are worth reviewing in the <span class="No-Break">Java documentation.</span></p>
			<p>Three additional concurrency utilities are <strong class="bold">atomic variables</strong>, <strong class="bold">locks</strong>, and <strong class="bold">concurrent collections</strong>. Atomic variables provide<a id="_idIndexMarker412"/> an efficient method<a id="_idIndexMarker413"/> to perform a small operation<a id="_idIndexMarker414"/> on a single variable without the need for synchronization. This is available in <strong class="source-inline">java.util.concurrent.atomic package</strong>. Locks, available in the <strong class="source-inline">java.util.concurrent.locks</strong> package, allow us to lock threads and waits until a specific condition is met. Lastly, concurrent collections provide thread-safe collections that have full support <span class="No-Break">for concurrency.</span></p>
			<p>Now that we explored caching strategies, thread management, and the effective use of Java concurrency utility, you should<a id="_idIndexMarker415"/> be well-equipped to continue building high-performance <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor157"/>Summary</h1>
			<p>This chapter took a deep look at the complexities of managing memory effectively to help prevent memory leaks. These leaks must be avoided at all costs because they can degrade our systems, ruin the user experience, and even result in system crashes. We identified that memory leaks typically occur due to improper referencing, which inhibits the garbage collector’s ability to deallocate memory. We focused on proper referencing, listeners and loaders, and caching and threads. You should now be equipped and confident to implement efficient memory leak avoidance strategies in your <span class="No-Break">Java applications.</span></p>
			<p>In the next chapter, <em class="italic">Concurrency Strategies</em>, we will cover the concepts of threads, synchronization, volatile, atomic classes, locks, and so on. We will leverage the thread-related content covered in this chapter to give us a head start as we dive deeper into concurrency. Through a hands-on approach, you can gain insights into concurrency in Java and adopt strategies to help make your Java programs <span class="No-Break">highly performant.</span></p>
		</div>
	

		<div class="Content" id="_idContainer021">
			<h1 id="_idParaDest-159" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor158"/>Part 3: Concurrency and Networking</h1>
			<p>Concurrency and networking are essential for modern Java applications, especially those requiring high throughput and low latency. This part introduces advanced concurrency strategies to manage multiple threads efficiently. It also covers connection pooling techniques to optimize network performance and explores the intricacies of hypertext transfer protocols. By understanding and applying these concepts, you will create highly responsive and <span class="No-Break">scalable applications.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21942_09.xhtml#_idTextAnchor159"><em class="italic">Chapter 9</em></a>, <em class="italic">Concurrency Strategies</em><em class="italic"> and Models</em></li>
				<li><a href="B21942_10.xhtml#_idTextAnchor172"><em class="italic">Chapter 10</em></a>, <em class="italic">Connection Pooling</em></li>
				<li><a href="B21942_11.xhtml#_idTextAnchor189"><em class="italic">Chapter 11</em></a>, <em class="italic">Hypertext Transfer Protocols</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer022">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer023">
			</div>
		</div>
	</body></html>