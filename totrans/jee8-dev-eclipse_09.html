<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Asynchronous Programming with JMS</h1>
                
            
            <article>
                
<p class="calibre3">In the last chapter, we learned how to create web services in JEE. We learned to create both RESTful and SOAP-based web services. In this chapter, we will learn how to work with messaging systems in JEE. Thus far, we have seen examples of clients making requests to the JEE server and waiting till the server sends a response back. This is the synchronous model of programming. This model of programming may not be suitable when the server takes a long time to process requests. In such cases, a client might want to send a request to the server and return immediately without waiting for the response. The server would process the request and somehow make the result available to the client. Requests and responses in such scenarios are sent through messages. Furthermore, there is a message broker that makes sure that messages are sent to the appropriate recipients. This is also known as a <strong class="calibre5">message-oriented architecture</strong>. The following are some of the advantages of adopting a message-oriented architecture:</p>
<ul class="calibre10">
<li class="calibre11">It can greatly improve the scalability of the application. Requests are put in a queue at one end, and at the other end there could be many handlers listening to the queue and processing the requests. As the load increases, more handlers can be added, and when the load reduces, some of the handlers can be taken off.</li>
<li class="calibre11">Messaging systems can act as glue between disparate software applications. An application developed using PHP can put a JSON or XML message in a messaging system, which can be processed by a JEE application.</li>
<li class="calibre11">It can be used to implement an event-driven program. Events can be put as messages in a messaging system, and any number of listeners can process events at the other end.</li>
<li class="calibre11">It can reduce the impact of system outages in your application because messages are persisted till they are processed.</li>
</ul>
<p class="calibre3">There are many enterprise messaging systems, such as Apache ActiveMQ (<a href="http://activemq.apache.org/" class="calibre9"><span>http://activemq.apache.org/</span></a>), RabbitMQ (<a href="https://www.rabbitmq.com/" class="calibre9"><span>https://www.rabbitmq.com/</span></a>), and MSMQ (<a href="https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx" class="calibre9"><span>https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx</span></a>). The <strong class="calibre5">Java Messaging Service</strong><span class="calibre12"> </span><span class="calibre12">(</span><strong class="calibre5">JMS</strong>) specification provides a uniform interface for working with many different messaging systems. JMS is also a part of the overall Java EE specifications. Refer to <a href="https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ" class="calibre9">https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ</a> for an overview of JMS APIs.</p>
<p class="calibre3">There are two types of message containers in any messaging system:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Queue</strong>: This is used for point-to-point messaging. One message producer puts a message in a queue, and only one message consumer receives the message. There can be multiple listeners for a queue, but only one listener receives the message. However, the same listener doesn't necessarily get all the messages.</li>
<li class="calibre11"><strong class="calibre1">Topic</strong>: This is used in the publish-subscribe type of scenario. One message producer puts a message in a topic, and many subscribers receive the message. Topics are useful for broadcasting messages.</li>
</ul>
<p class="calibre3">We will cover<span class="calibre12"> the</span> following topics:</p>
<ul class="calibre10">
<li class="calibre11">Sending and receiving messages to and from queues and topics using JMS APIs</li>
<li class="calibre11">Creating JMS applications using JSP, JSF, and CDI beans</li>
<li class="calibre11">Consuming messages using MDBs (message-driven beans)</li>
</ul>
<p class="calibre3"><span class="calibre12">We will see examples of how to use queues and topics in this chapter. We will use a GlassFish Server, which has a built-in JMS provider. We will use JMS APIs to implement a use case in the <em class="calibre21">Course Management</em> application, the same application that we have been building in the other chapters of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Steps to send and receive messages using JMS</h1>
                
            
            <article>
                
<p class="calibre3">However, before we start using JMS APIs, let's take a look at the generic steps involved in using them. The following steps show how to send a message to a queue and receive it. Although the steps focus on queues, the steps for topics are similar, but with appropriate topic-related classes:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Look up <kbd class="calibre13">ConnectionFactory</kbd> using JNDI:</li>
</ol>
<pre class="calibre35">InitialContext ctx = new InitialContext(); 
QueueConnectionFactory connectionFactory = (QueueConnectionFactory)initCtx.lookup("jndi_name_of_connection_factory"); </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Create a JMS connection and start it:</li>
</ol>
<pre class="calibre35">QueueConnection con = connectionFactory.createQueueConnection(); 
con.start(); </pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Create a JMS session:</li>
</ol>
<pre class="calibre35">QueueSession session = con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE); </pre>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">Look up JMS <kbd class="calibre13">Queue</kbd>/<kbd class="calibre13">Topic</kbd>:</li>
</ol>
<pre class="calibre35">Queue queue = (Queue)initCtx.lookup("jndi_queue_name"); </pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">For sending messages, perform the following steps:<br class="title-page-name"/>
<ol class="calibre15">
<li value="1" class="calibre210">Create a sender:</li>
</ol>
</li>
</ol>
<pre class="calibre211">QueueSender sender = session.createSender(queue); </pre>
<ol class="calibre14">
<li value="1" class="calibre11">
<ol start="2" class="calibre15">
<li value="2" class="calibre11">Create the message. It can be of any of the following types: <kbd class="calibre13">TextMessage</kbd>/<kbd class="calibre13">ObjectMessage</kbd>/<kbd class="calibre13">MapMessage</kbd>/<kbd class="calibre13">BytesMessage</kbd>/<kbd class="calibre13">StreamMessage</kbd>:</li>
</ol>
</li>
</ol>
<pre class="calibre211">TextMessage textMessage = session.createTextMessage("Test Message");</pre>
<ol class="calibre14">
<li value="1" class="calibre11">
<ol start="3" class="calibre15">
<li value="3" class="calibre11">Send the message:</li>
</ol>
</li>
</ol>
<pre class="calibre211">sender.send(textMessage); </pre>
<ol class="calibre14">
<li value="1" class="calibre11">
<ol start="4" class="calibre15">
<li value="4" class="calibre11">Close the connection when no longer needed:</li>
</ol>
</li>
</ol>
<pre class="calibre211">con.close();</pre>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">For receiving messages, perform the following steps:
<ol class="calibre15">
<li value="1" class="calibre210">Create a receiver:</li>
</ol>
</li>
</ol>
<pre class="calibre211">//create a new session before creating the receiver. 
QueueReceiver receiver = session.createReceiver(queue); </pre>
<ol class="calibre14">
<li value="1" class="calibre11">
<ol start="2" class="calibre15">
<li value="2" class="calibre11">Register a message listener or call<span> the</span> <kbd class="calibre13">receive</kbd> method:</li>
</ol>
</li>
</ol>
<pre class="calibre211">receiver.setMessageListener(new MessageListener() { 
    @Override 
    public void onMessage(Message message) { 
        try { 
            String messageTxt = <br class="title-page-name"/>             ((TextMessage)message).getText(); 
            //process message 
        } catch (JMSException e) { 
            //handle exception 
        } 
    } 
}); </pre>
<ol class="calibre14">
<li value="1" class="calibre11">
<ol start="3" class="calibre15">
<li value="3" class="calibre11">Alternatively, you can use any variation of the receive method:</li>
</ol>
</li>
</ol>
<pre class="calibre211">Message message = receiver.receive(); //this blocks the thread till a message is received </pre>
<ul class="calibre10">
<li class="front-matter">
<ol start="4" class="calibre15">
<li value="4" class="calibre11">Or you can use this:</li>
</ol>
</li>
</ul>
<pre class="calibre211">Message message = receiver.receive(timeout); // with timeout</pre>
<ol class="calibre14">
<li value="1" class="calibre11">
<ol start="5" class="calibre15">
<li value="5" class="calibre11">Or<span> you can use this</span>:</li>
</ol>
</li>
</ol>
<pre class="calibre211">Message message = receiver.receiveNoWait(); //returns null if no message is available. </pre>
<p class="mce-root2">In a JEE application that uses EJB, it is recommended to use MDBs. We will see an example of MDBs later in this chapter.</p>
<ol start="7" class="calibre14">
<li value="7" class="calibre11">When done, close the connection. This stops message listeners too:</li>
</ol>
<pre class="calibre35">con.close(); </pre>
<p class="calibre3">Some of the steps can be skipped when JMS annotations are used or when MDBs are used to receive messages. We will see examples later.</p>
<p class="calibre3">Now, let's create a working example of sending and receiving messages using JMS. Make sure that you have installed<span class="calibre12"> the</span> GlassFish application server (refer to the <em class="calibre21">Installing the GlassFish Server</em> section in <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre21">Introducing JEE and Eclipse</em>) and configured it in Eclipse JEE (refer to the <em class="calibre21">Configuring the GlassFish Server in Eclipse</em> section in <a target="_blank" href="part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre21">Creating JEE Applications with EJB</em>). The use case that we will implement in this example is of adding a new course. Although this is not a strong use case for asynchronous processing, we will assume that this operation takes a long time and needs to be handled asynchronously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating queues and topics in GlassFish</h1>
                
            
            <article>
                
<p class="calibre3">Let's create one queue and one topic in GlassFish. Make sure that<span class="calibre12"> the</span> GlassFish Server is running. Open the GlassFish admin console. You can right-click the GlassFish Server instance configured in Eclipse (in<span class="calibre12"> the</span> <span class="calibre12">Servers</span> view) and select <span class="calibre12">GlassFish</span> | <span class="calibre12">View Admin Console</span>. This opens the admin console in the built-in Eclipse browser. If you want to open it outside Eclipse, in a browser, then browse to <kbd class="calibre13">http://localhost:4848/</kbd> (assuming the default GlassFish installation).</p>
<p class="mce-root">We will first create a JMS connection factory. In the admin console, go to<span class="calibre12"> the</span> <span class="calibre12">Resources</span> | <span class="calibre12">JMS Resources</span> | <span class="calibre12">Connection Factories</span> page. Click<span class="calibre12"> the</span> <span class="calibre12">New</span> button to create a new connection factory:</p>
<div class="mce-root1"><img src="../images/00199.jpeg" class="calibre212"/></div>
<div class="packt_figure1">Figure 10.1: Create a JMS connection factory</div>
<p class="calibre3">Enter <span class="calibre12">JNDI Name</span> of the factory as <kbd class="calibre13">jms/CourseManagementCF</kbd> and select <span class="calibre12">javax.jms.ConnectionFactory</span> as the <span class="calibre12">Resource Type</span>. Leave the default values for <span class="calibre12">Pool Settings</span>. Click <span class="calibre12">OK</span>.</p>
<p class="mce-root">To create queues and topics, go to<span class="calibre12"> the</span> <span class="calibre12">Resources</span> | <span class="calibre12">JMS Resources</span> | <span class="calibre12">Destination Resources</span> page. Click<span class="calibre12"> the </span><span class="calibre12">New</span> button:</p>
<div class="mce-root1"><img src="../images/00200.jpeg" class="calibre213"/></div>
<div class="packt_figure1">Figure 10.2: Create a JMS queue</div>
<p class="calibre3">Enter<span class="calibre12"> the</span> <span class="calibre12">JNDI Name</span> of the queue as <kbd class="calibre13">jms/courseManagementQueue</kbd>, <span class="calibre12">Physical Destination Name</span> as <kbd class="calibre13">CourseManagementQueue</kbd>, and select <span class="calibre12">javax.jms.Queue</span> as the <span class="calibre12">Resource Type</span>. Click <span class="calibre12">OK</span> to create the queue.</p>
<p class="calibre3">Similarly, create the topic by entering<span class="calibre12"> the</span> <span class="calibre12">JNDI Name</span> as <kbd class="calibre13">jms/courseManagementTopic</kbd>, <span class="calibre12">Physical Destination Name</span> as <kbd class="calibre13">CourseManagementTopic</kbd>, and select <span class="calibre12">javax.jms.Topic</span> as the <span class="calibre12">Resource Type</span>.</p>
<p class="mce-root">You should now have one queue and one topic configured in the <span class="calibre12">Destination Resources</span> page:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00201.jpeg" class="calibre214"/></div>
<div class="packt_figure1">Figure 10.3: Queue and topic created in GlassFish</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JEE project for a JMS application</h1>
                
            
            <article>
                
<p class="calibre3">We will see examples of using JMS APIs in three different ways.</p>
<p class="calibre3">In the first example, we will create a simple <kbd class="calibre13">addCourse.jsp</kbd> page, one JSP bean, and one <kbd class="calibre13">Service</kbd> class that actually performs JMS tasks.</p>
<p class="calibre3">In the second example, we will use JSF and managed beans. We will use JMS APIs in the managed beans. We will also see how to use JMS annotations in JSF managed beans.</p>
<p class="calibre3">In the last example, we will use MDBs to consume JMS messages.</p>
<p class="mce-root">Let's start with the first example, which uses JSP, bean, and JMS APIs. Create a web project by selecting <span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">Dynamic Web Project</span> or <span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">Other</span> and then <span class="calibre12">Web</span> | <span class="calibre12"><span class="calibre12">Dynamic Web Project</span></span>:</p>
<div class="mce-root1"><img src="../images/00202.jpeg" class="calibre215"/></div>
<div class="packt_figure1">Figure 10.4: Create a dynamic web project for a JMS app</div>
<p class="calibre3">Enter<span class="calibre12"> the</span> <span class="calibre12">Project name</span> as <kbd class="calibre13">CourseManagementJMSWeb</kbd>. Make sure that <span class="calibre12">Target runtime</span> is <span class="calibre12">GlassFish</span> . Click <span class="calibre12">Next</span>, and accept all<span class="calibre12"> the</span> default options. Click <span class="calibre12">Finish</span> to create the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JMS application using JSP and JSP bean</h1>
                
            
            <article>
                
<p class="calibre3">Let's first create a JSP that displays the form to enter course details. We will also create a JSP bean to process the form data. Right-click on<span class="calibre12"> the</span> <kbd class="calibre13">WebContent</kbd> folder under the project in<span class="calibre12"> the</span> <span class="calibre12">Project Explorer</span> view and select <span class="calibre12">New</span> | <span class="calibre12">JSP File</span>. Create the JSP file named <kbd class="calibre13">addCourse.jsp</kbd>.</p>
<p class="calibre3">We will now create <kbd class="calibre13">CourseDTO</kbd> and<span class="calibre12"> the</span> JSP bean called <kbd class="calibre13">CourseJSPBean</kbd>. Create<span class="calibre12"> the</span> <kbd class="calibre13">CourseDTO</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms.dto</kbd> package. Add<span class="calibre12"> the</span> <kbd class="calibre13">id</kbd>, <kbd class="calibre13">name</kbd>, and <kbd class="calibre13">credits</kbd> properties, and the getters and setters for them:</p>
<pre class="calibre25">import java.io.Serializable; 
public class CourseDTO implements Serializable { 
  private static final long serialVersionUID = 1L; 
  private int id; 
  private String name; 
  private int credits; 
   
  //getters and setters follow 
} </pre>
<p class="calibre3">Create <kbd class="calibre13">CourseJSPBean</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms.jsp.beans</kbd> package:</p>
<pre class="calibre25">import packt.jee.eclipse.jms.dto.CourseDTO; 
 
public class CourseJSPBean { 
   
  private CourseDTO course = new CourseDTO(); 
   
  public void setId(int id) { 
    course.setId(id); 
  } 
  public String getName() { 
    return course.getName(); 
  } 
  public void setName(String name) { 
    course.setName(name); 
  } 
  public int getCredits() { 
    return course.getCredits(); 
  } 
  public void setCredits(int credits) { 
    course.setCredits(credits); 
  } 
  public void addCourse() { 
    //TODO: send CourseDTO object to a JMS queue 
  } 
} </pre>
<p class="calibre3">We will implement the code to send<span class="calibre12"> the</span> <kbd class="calibre13">CourseDTO</kbd> object to the JMS queue later in<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> method. For now, add the following code to <kbd class="calibre13">addCourse.jsp</kbd>:</p>
<pre class="calibre25">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" 
    pageEncoding="UTF-8"%&gt; 
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" <br class="title-page-name"/> "http://www.w3.org/TR/html4/loose.dtd"&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF- <br class="title-page-name"/> 8"&gt; 
&lt;title&gt;Add Course&lt;/title&gt; 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;!-- Check if form is posted --&gt; 
  &lt;c:if test="${"POST".equalsIgnoreCase(pageContext.request.method) 
      &amp;&amp; pageContext.request.getParameter("submit") != null}"&gt; 
 
    &lt;!-- Create CourseJSPBean --&gt;   
    &lt;jsp:useBean id="courseService" class="packt.jee.eclipse.jms.jsp_beans.CourseJSPBean" <br class="title-page-name"/> scope="page"&gt;&lt;/jsp:useBean&gt; 
 
    &lt;!-- Set Bean properties with values from form submission --&gt; 
    &lt;jsp:setProperty property="name" name="courseService" <br class="title-page-name"/>     param="course_name"/&gt;    &lt;jsp:setProperty property="credits" name="courseService" <br class="title-page-name"/>     param="course_credits"/&gt; 
 
    &lt;!-- Call addCourse method of the bean --&gt; 
    ${courseService.addCourse()} 
    &lt;b&gt;Course detailed are sent to a JMS Queue. It will be <br class="title-page-name"/>     processed later&lt;/b&gt; 
  &lt;/c:if&gt; 
 
  &lt;h2&gt;New Course:&lt;/h2&gt; 
 
  &lt;!-- Course data input form --&gt; 
  &lt;form method="post"&gt; 
    &lt;table&gt; 
      &lt;tr&gt; 
        &lt;td&gt;Name:&lt;/td&gt; 
        &lt;td&gt; 
          &lt;input type="text" name="course_name"&gt; 
        &lt;/td&gt; 
      &lt;/tr&gt; 
      &lt;tr&gt; 
        &lt;td&gt;Credits:&lt;/td&gt; 
        &lt;td&gt; 
          &lt;input type="text" name="course_credits"&gt; 
        &lt;/td&gt; 
      &lt;/tr&gt; 
      &lt;tr&gt; 
        &lt;td colspan="2"&gt; 
          &lt;button type="submit" name="submit"&gt;Add&lt;/button&gt; 
        &lt;/td&gt; 
      &lt;/tr&gt; 
    &lt;/table&gt; 
  &lt;/form&gt; 
 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p class="calibre3">At the top of the JSP file, we check whether the form is submitted. If yes, we <span class="calibre12">then</span><span class="calibre12"> </span><span class="calibre12">create an instance of</span> <kbd class="calibre13">CourseJSPBean</kbd> <span class="calibre12">and set its properties with values from the form submission. Then, we call<span class="calibre12"> the</span> </span><kbd class="calibre13">addCourse</kbd> <span class="calibre12">method of the bean.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Executing addCourse.jsp</h1>
                
            
            <article>
                
<p class="mce-root">We still haven't added any code to put<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> object in the JMS queue. However, if you want to test the JSP and bean, add the project to the GlassFish server configured in Eclipse. To do this, right-click on the configured server in<span class="calibre12"> the</span> <span class="calibre12">Servers</span> view of Eclipse and select<span class="calibre12"> the</span> <span class="calibre12">Add and Remove...</span> option. Select the web project that we created and click on <span class="calibre12">Finish</span>. Make sure that the server is started and the status is <span class="calibre12">[Started, Synchronized]</span>:</p>
<div class="mce-root1"><img src="../images/00203.jpeg" class="calibre216"/></div>
<div class="packt_figure1">Figure 10.5: Status of GlassFish after adding web project</div>
<p class="calibre3">If the status is <span class="calibre12">Republish</span>, then right-click on the server and select<span class="calibre12"> the</span> <span class="calibre12">Publish</span> option. If the status is <span class="calibre12">Restart</span>, right-click on the server and select<span class="calibre12"> the</span> <span class="calibre12">Restart</span> option. You may not have to do this immediately after adding the project, but later when we make changes to the code, you may have to republish or restart the server, or both. So, keep an eye on the server status before you execute the code in Eclipse.</p>
<p class="calibre3">To execute <kbd class="calibre13">addCourse.jsp</kbd>, right-click on the file in either <span class="calibre12">Project Explorer</span> or the editor, and select<span class="calibre12"> the</span> <span class="calibre12">Run As</span> | <span class="calibre12">Run on Server</span> option. This will open the built-in Eclipse browser and open JSP in it. You should see the form for adding the course details. If you click<span class="calibre12"> the</span> <span class="calibre12">Submit</span> button, you should see the message that we added in JSP when the form is submitted.</p>
<p class="calibre3">Let's now add a class to send the course details to the JMS queue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing JMS queue sender class</h1>
                
            
            <article>
                
<p class="calibre3">Let's create<span class="calibre12"> the</span> <kbd class="calibre13">CourseQueueSender</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms</kbd> package with the following content:</p>
<pre class="calibre25">package packt.jee.eclipse.jms; 
 
//skipped imports 
 
public class CourseQueueSender { 
  private QueueConnection connection; 
  private QueueSession session; 
  private Queue queue; 
 
 
  public CourseQueueSender() throws Exception { 
    //Create JMS Connection, session, and queue objects 
    InitialContext initCtx = new InitialContext(); 
    QueueConnectionFactory connectionFactory = <br class="title-page-name"/>     (QueueConnectionFactory)initCtx. 
          lookup("jms/CourseManagemenCF"); 
    connection = connectionFactory.createQueueConnection(); 
    connection.start(); 
    session = connection.createQueueSession(false, <br class="title-page-name"/>     Session.AUTO_ACKNOWLEDGE); 
    queue = (Queue)initCtx.lookup("jms/courseManagementQueue"); 
     
  } 
 
  public void close() { 
    if (connection != null) { 
      try { 
        connection.close(); 
      } catch (JMSException e) { 
        e.printStackTrace(); 
      } 
    } 
  } 
  @Override 
  protected void finalize() throws Throwable { 
    close(); //clean up 
    super.finalize(); 
  } 
 
  public void sendAddCourseMessage (CourseDTO course) throws <br class="title-page-name"/>   Exception { 
    //Send CourseDTO object to JMS Queue 
    QueueSender sender = session.createSender(queue); 
    ObjectMessage objMessage = <br class="title-page-name"/>     session.createObjectMessage(course); 
    sender.send(objMessage); 
  } 
} </pre>
<p class="calibre3">In the constructor, we look up the JMS connection factory and create the connection. We then create a JMS session and lookup queue with the JNDI name that we used for creating the queue in a previous section.</p>
<p class="calibre3">Note that we did not specify any configuration properties when constructing <kbd class="calibre13">InitialContext</kbd>. This is because the code is executed in the same instance of the GlassFish Server that hosts the JMS provider. If you are connecting to a JMS provider hosted in a different GlassFish Server, then you will have to specify the configuration properties, particularly for the remote host, for example:</p>
<pre class="calibre25">Properties jndiProperties = new Properties(); 
jndiProperties.setProperty("org.omg.CORBA.ORBInitialHost", <br class="title-page-name"/> "&lt;remote_host&gt;"); 
//target ORB port. default is 3700 in GlassFish 
jndiProperties.setProperty("org.omg.CORBA.ORBInitialPort", <br class="title-page-name"/> "3700"); 
 
InitialContext ctx = new InitialContext(jndiProperties); </pre>
<p class="calibre3">The <kbd class="calibre13">CourseQueueSender.sendAddcourseMessage</kbd> method creates instances of <kbd class="calibre13">QueueSender</kbd> and <kbd class="calibre13">ObjectMessage</kbd>. Because the producer and the consumer of the message in this example are in Java, we use <kbd class="calibre13">ObjectMessage</kbd>. However, if you are to send a message to a messaging system where the message is going to be consumed by a non-Java consumer, then you could create JSON or XML from the Java object and send <kbd class="calibre13">TextMessage</kbd>. We have already seen how to serialize Java objects to JSON and XML using JAXB and JSON-B in <a target="_blank" href="part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre21">Creating Web Services</em>.</p>
<p class="calibre3">Now, let's modify<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> method in <kbd class="calibre13">CourseJSPBean</kbd> to use<span class="calibre12"> the</span> <kbd class="calibre13">CourseQueueSender</kbd> class to send JMS messages. Note that we could create an instance of <kbd class="calibre13">CourseQueueSender</kbd> in the bean class, <kbd class="calibre13">CouseJSPBean</kbd>, but the bean is created every time the page is requested. So, <kbd class="calibre13">CourseQueueSender</kbd> will be created frequently and the lookup for the JMS connection factory and the queue will also execute frequently, which is not necessary. Therefore, we will create an instance of <kbd class="calibre13">CourseQueueSender</kbd> and save it in the HTTP session. Then, we will modify<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> method to take <kbd class="calibre13">HttpServletRequest</kbd> as a parameter. We will also get the <kbd class="calibre13">HttpSession</kbd> object from the request:</p>
<pre class="calibre25">  public void addCourse(HttpServletRequest request) throws <br class="title-page-name"/>   Exception { 
    //get HTTP session 
    HttpSession session = request.getSession(true); 
     
    //look for instance of CourseQueueSender in Session 
    CourseQueueSender courseQueueSender = <br class="title-page-name"/>     (CourseQueueSender)session 
                        getAttribute("CourseQueueSender"); 
    if (courseQueueSender == null) { 
      //Create instance of CourseQueueSender and save in Session 
      courseQueueSender = new CourseQueueSender(); 
      session.setAttribute("CourseQueueSender", <br class="title-page-name"/>       courseQueueSender); 
    } 
 
    //TODO: perform input validation 
    if (courseQueueSender != null) { 
      try { 
        courseQueueSender.sendAddCourseMessage(course); 
      } catch (Exception e) { 
        e.printStackTrace(); 
        //TODO: log exception 
      } 
    } 
  } </pre>
<p class="calibre3">If we don't find the <kbd class="calibre13">CourseQueueSender</kbd> object in the session, then we will create one and save it in the session.</p>
<p class="calibre3">We need to modify the call to<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> method from <kbd class="calibre13">addcourse.jsp</kbd>. Currently, we do not pass any argument to the method. However, with the preceding changes to<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> method, we need to pass<span class="calibre12"> the</span> <kbd class="calibre13">HttpServletRequest</kbd> object to it. JSP has a built-in property called <kbd class="calibre13">pageContext</kbd> that provides access to the <kbd class="calibre13">HttpServletRequest</kbd> object. So, modify the code in <kbd class="calibre13">addCourse.jsp</kbd> where <kbd class="calibre13">courseService.addCourse</kbd> is called as follows:</p>
<pre class="calibre25">&lt;!-- Call addCourse method of the bean --&gt; 
${courseService.addCourse(pageContext.request)} </pre>
<p class="calibre3">We can test our code at this point, but although messages are sent to the queue, we haven't implemented any consumer to receive them from the queue. So, let's implement a JMS queue consumer for our <kbd class="calibre13">Course</kbd> queue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing JMS queue receiver class</h1>
                
            
            <article>
                
<p class="calibre3">Let's create<span class="calibre12"> the</span> <kbd class="calibre13">CourseQueueReceiver</kbd> class in the <kbd class="calibre13">packt.jee.eclipse.jms</kbd> package with the following content:</p>
<pre class="calibre25">public class CourseQueueReceiver { 
 
  private QueueConnection connection; 
  private QueueSession session; 
  private Queue queue; 
 
  private String receiverName; 
 
  public CourseQueueReceiver(String name) throws Exception{ 
 
    //save receiver name 
    this.receiverName = name; 
 
    //look up JMS connection factory 
    InitialContext initCtx = new InitialContext(); 
    QueueConnectionFactory connectionFactory = <br class="title-page-name"/> (QueueConnectionFactory)initCtx.lookup("jms/CourseManagemenCF"); 
 
    //create JMS connection 
    connection = connectionFactory.createQueueConnection(); 
    connection.start(); 
 
    //create JMS session 
    session = connection.createQueueSession(false, <br class="title-page-name"/>     Session.AUTO_ACKNOWLEDGE); 
    //look up queue 
    queue = (Queue)initCtx.lookup("jms/courseManagementQueue"); 
 
    topicPublisher = new CourseTopicPublisher(); 
 
    QueueReceiver receiver = session.createReceiver(queue); 
    //register message listener 
    receiver.setMessageListener(new MessageListener() { 
 
      @Override 
      public void onMessage(Message message) { 
        //we expect ObjectMessage here; of type CourseDTO 
        //skipping validation 
        try { 
          CourseDTO course = (CourseDTO) <br class="title-page-name"/>           ((ObjectMessage)message).getObject();          //process addCourse action. For example, save it in the <br class="title-page-name"/>           database          System.out.println("Received addCourse message for Course name - " + <br class="title-page-name"/>               course.getName() + " in Receiver " + receiverName); 
           
        } catch (Exception e) { 
          e.printStackTrace(); 
          //TODO: handle and log exception 
        } 
      } 
    }); 
  } 
 
  public void stop() { 
    if (connection != null) { 
      try { 
        connection.close(); 
      } catch (JMSException e) { 
        e.printStackTrace(); 
        //TODO: log exception 
      } 
    } 
  } 
}</pre>
<p class="calibre3">The code to look up the connection factory and the queue is similar to that in <kbd class="calibre13">CourseQueueSender</kbd>. Note that the constructor takes a <kbd class="calibre13">name</kbd> argument. We don't really need to use the JMS API, but we will use it as an identifier for instances of<span class="calibre12"> the</span> <kbd class="calibre13">CourseQueueReceiver</kbd> class. We register a message listener in the constructor, and in<span class="calibre12"> the</span> <kbd class="calibre13">onMessage</kbd> method of the listener class we get<span class="calibre12"> the</span> <kbd class="calibre13">CourseDTO</kbd> object from the message and print the message to the console. This message will appear in the GlassFish console in Eclipse when we execute the code. To keep the example simple, we have not implemented the code to save the <kbd class="calibre13">Course</kbd> information to the database, but you can do so using<span class="calibre12"> the</span> JDBC or JDO APIs we learned about in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>.</p>
<p class="calibre3">We need to instantiate<span class="calibre12"> the</span> <kbd class="calibre13">CourseQueueReceiver</kbd> class at application startup, so that it will start listening for the messages. One way to implement this is in a servlet that loads on startup.</p>
<p class="calibre3">Let's create <span class="calibre12">the</span> <kbd class="calibre13">JMSReceiverInitServlet</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms.servlet</kbd> package. We will mark this servlet to load at startup using annotations and instantiate <kbd class="calibre13">CourseQueueReceiver</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">init</kbd> method:</p>
<pre class="calibre25">package packt.jee.eclipse.jms.servlet; 
 
//skipped imports 
 
@WebServlet(urlPatterns="/JMSReceiverInitServlet", loadOnStartup=1) 
public class JMSReceiverInitServlet extends HttpServlet { 
  private static final long serialVersionUID = 1L; 
 
  private CourseQueueReceiver courseQueueReceiver = null; 
 
    public JMSReceiverInitServlet() { 
        super(); 
    } 
 
    @Override 
    public void init(ServletConfig config) throws ServletException <br class="title-page-name"/> { 
      super.init(config); 
      try { 
      courseQueueReceiver = new CourseQueueReceiver("Receiver1"); 
    } catch (Exception e) { 
      log("Error creating CourseQueueReceiver", e); 
    } 
    } 
 
    @Override 
    public void destroy() { 
      if (courseQueueReceiver != null) 
        courseQueueReceiver.stop(); 
      super.destroy(); 
    } 
} </pre>
<p class="mce-root">Publish the project again in the server and execute <kbd class="calibre13">addCourse.jsp</kbd> (see<span class="calibre12"> the</span> <em class="calibre21">Executing addCourse.jsp</em> section of this chapter). Switch to the <span class="calibre12">Console</span> view in Eclipse. You should see the message that we printed in<span class="calibre12"> the</span> <kbd class="calibre13">onMessage</kbd> method in <kbd class="calibre13">CourseQueueReceiver</kbd>:</p>
<div class="mce-root1"><img src="../images/00204.jpeg" class="calibre217"/></div>
<div class="packt_figure1">Figure 10.6: Example of a console message from the JMS receiver class</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding multiple queue listeners</h1>
                
            
            <article>
                
<p class="calibre3">Queues are meant for point-to-point communication, but this does not mean that there can't be more than one listener for a queue. However, only one listener gets the message. Furthermore, it is not guaranteed that the same listener will get the message every time. If you want to test this, add one more instance of <kbd class="calibre13">CourseQueueReceiver</kbd> in <kbd class="calibre13">JMSReceiverInitServlet</kbd>. Let's add the second instance with a different name, say <kbd class="calibre13">Receiver2</kbd>:</p>
<pre class="calibre25">@WebServlet(urlPatterns="/JMSReceiverInitServlet", loadOnStartup=1) 
public class JMSReceiverInitServlet extends HttpServlet { 
  private CourseQueueReceiver courseQueueReceiver = null; 
  private CourseQueueReceiver courseQueueReceiver1 = null; 
   
    @Override 
    public void init(ServletConfig config) throws ServletException 
{ 
      super.init(config); 
      try { 
        //first instance of CourseQueueReceiver 
      courseQueueReceiver = new CourseQueueReceiver("Receiver1"); 
      //create another instance of CourseQueueReceiver with a <br class="title-page-name"/>       different name 
      courseQueueReceiver1 = new CourseQueueReceiver("Receiver2"); 
       
    } catch (Exception e) { 
      log("Error creating CourseQueueReceiver", e); 
    } 
    } 
 
    @Override 
    public void destroy() { 
      if (courseQueueReceiver != null) 
        courseQueueReceiver.stop(); 
      if (courseQueueReceiver1 != null) 
        courseQueueReceiver1.stop(); 
      super.destroy(); 
    } 
 
    //rest of the code remains the same 
} </pre>
<p class="mce-root">Republish the project, execute <kbd class="calibre13">addCourse.jsp</kbd>, and add a few courses. Check the <span class="calibre12">Console</span> messages. You may see that some of the messages were received by <kbd class="calibre13">Receiver1</kbd> and the others by <kbd class="calibre13">Receiver2</kbd>:</p>
<div class="mce-root1"><img src="../images/00205.jpeg" class="calibre218"/></div>
<div class="packt_figure1">Figure 10.7: Console output showing multiple JMS receivers listening to a JMS queue</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing JMS topic publisher</h1>
                
            
            <article>
                
<p class="calibre3">Let's say that we want to inform a bunch of applications when a new course is added. Such use cases can be best implemented by a <strong class="calibre5">JMS topic</strong>. A topic can have many subscribers. When a message is added to the topic, all subscribers are sent the same message. This is unlike a queue, where only one queue listener gets a message.</p>
<p class="calibre3">Steps to publish messages to a topic and subscribe for messages are very similar to those for a queue, except for the different classes, and in some cases, different method names.</p>
<p class="calibre3">Let's implement a topic publisher, which we will use when the message for adding a course is successfully handled in the <kbd class="calibre13">onMessage</kbd> method of the listener class implemented in <kbd class="calibre13">CourseQueueReceiver</kbd>.</p>
<p class="calibre3">Create <kbd class="calibre13">CourseTopicPublisher</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms</kbd> package with the following content:</p>
<pre class="calibre25">package packt.jee.eclipse.jms; 
 
//skipped imports 
 
public class CourseTopicPublisher { 
  private TopicConnection connection; 
  private TopicSession session; 
  private Topic topic; 
 
  public CourseTopicPublisher() throws Exception { 
    InitialContext initCtx = new InitialContext(); 
    TopicConnectionFactory connectionFactory = <br class="title-page-name"/>     (TopicConnectionFactory)initCtx. 
        lookup("jms/CourseManagemenCF"); 
    connection = connectionFactory.createTopicConnection(); 
    connection.start(); 
    session = connection.createTopicSession(false, <br class="title-page-name"/>     Session.AUTO_ACKNOWLEDGE); 
    topic = (Topic)initCtx.lookup("jms/courseManagementTopic"); 
  } 
 
  public void close() { 
    if (connection != null) { 
      try { 
        connection.close(); 
      } catch (JMSException e) { 
        e.printStackTrace();. 
      } 
    } 
  } 
 
  public void publishAddCourseMessage (CourseDTO course) throws <br class="title-page-name"/>   Exception { 
    TopicPublisher sender = session.createPublisher(topic); 
    ObjectMessage objMessage = <br class="title-page-name"/>     session.createObjectMessage(course); 
    sender.send(objMessage); 
  } 
} </pre>
<p class="calibre3">The code is quite simple and self-explanatory. Let's now modify the queue receiver class that we implemented, <kbd class="calibre13">CourseQueueReceiver</kbd>, to publish a message to the topic from<span class="calibre12"> the</span> <kbd class="calibre13">onMessage</kbd> method, after the message from the queue is handled successfully:</p>
<pre class="calibre25">public class CourseQueueReceiver { 
 
  private CourseTopicPublisher topicPublisher; 
 
  public CourseQueueReceiver(String name) throws Exception{ 
 
    //code to lookup connection factory, create session, 
    //and look up queue remains unchanged. Skipping this code 
 
    //create topic publisher 
    topicPublisher = new CourseTopicPublisher(); 
 
    QueueReceiver receiver = session.createReceiver(queue); 
    //register message listener 
    receiver.setMessageListener(new MessageListener() { 
 
      @Override 
      public void onMessage(Message message) { 
        //we expect ObjectMessage here; of type CourseDTO 
        //Skipping validation 
        try { 
          //code to process message is unchanged. Skipping it 
 
          //publish message to topic 
          if (topicPublisher != null) 
            topicPublisher.publishAddCourseMessage(course); 
 
        } catch (Exception e) { 
          e.printStackTrace(); 
          //TODO: handle and log exception 
        } 
      } 
    }); 
  } 
 
  //remaining code is unchanged. Skipping it 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing JMS topic subscriber</h1>
                
            
            <article>
                
<p class="calibre3">We will now implement a topic subscriber class to receive messages published to the topic we created earlier. Create a <kbd class="calibre13">CourseTopicSubscriber</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms</kbd> package with the following content:</p>
<pre class="calibre25">package packt.jee.eclipse.jms; 
//skipping imports 
public class CourseTopicSubscriber { 
 
  private TopicConnection connection; 
  private TopicSession session; 
  private Topic topic; 
 
  private String subscriberName; 
 
  public CourseTopicSubscriber(String name) throws Exception{ 
 
    this.subscriberName = name; 
 
    InitialContext initCtx = new InitialContext(); 
    TopicConnectionFactory connectionFactory = <br class="title-page-name"/> (TopicConnectionFactory)initCtx.lookup("jms/CourseManagemenCF"); 
    connection = connectionFactory.createTopicConnection(); 
    connection.start(); 
    session = connection.createTopicSession(false, <br class="title-page-name"/>     Session.AUTO_ACKNOWLEDGE); 
    topic = (Topic)initCtx.lookup("jms/courseManagementTopic"); 
 
    TopicSubscriber subscriber = session.createSubscriber(topic); 
    subscriber.setMessageListener(new MessageListener() { 
 
      @Override 
      public void onMessage(Message message) { 
        //we expect ObjectMessage here; of type CourseDTO 
        //skipping validation 
        try { 
          CourseDTO course = (CourseDTO) <br class="title-page-name"/>           ((ObjectMessage)message).getObject();          //process addCourse action. For example, save it in <br class="title-page-name"/>           database          System.out.println("Received addCourse notification for <br class="title-page-name"/>           Course name - "              + course.getName() + " in Subscriber " + <br class="title-page-name"/>               subscriberName); 
 
        } catch (JMSException e) { 
          e.printStackTrace(); 
          //TODO: handle and log exception 
        } 
      } 
    }); 
  } 
 
  public void stop() { 
    if (connection != null) { 
      try { 
        connection.close(); 
      } catch (JMSException e) { 
        e.printStackTrace(); 
        //TODO: log exception 
      } 
    } 
  } 
} </pre>
<p class="calibre3">Again,<span class="calibre12"> the</span> JMS APIs to subscribe to a topic are similar to those in <kbd class="calibre13">CourseQueueReceiver</kbd>, but with different class names and method names. We also identify subscribers with names so that we know which instance of the class receives the message.</p>
<p class="calibre3">In the preceding example, we created the topic subscriber by calling <kbd class="calibre13">TopicSession.createSubscriber</kbd>. In this case, the subscriber will receive messages from the topic as long as the subscriber is active. If the subscriber becomes inactive and then active again, it loses messages published by the topic during that period. If you want to make sure that the subscriber receives all the messages, you need to create a durable subscription using <kbd class="calibre13">TopicSession.createDurableSubscriber</kbd>. Along with the topic name, this method takes the subscriber name as the second argument. Refer to <a href="https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-" class="calibre9">https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-</a> for more information.</p>
<p class="calibre3">We will create two instances of<span class="calibre12"> the</span> <kbd class="calibre13">CourseTopicSubscriber</kbd> class (so there will be two topic subscribers) in <kbd class="calibre13">JMSReceiverInitServlet</kbd>. These two instances will start listening for messages on application startup (the servlet is loaded on startup):</p>
<pre class="calibre25">@WebServlet(urlPatterns="/JMSReceiverInitServlet", loadOnStartup=1) 
public class JMSReceiverInitServlet extends HttpServlet { 
  private CourseQueueReceiver courseQueueReceiver = null; 
  private CourseTopicSubscriber courseTopicSubscriber = null; 
  private CourseQueueReceiver courseQueueReceiver1 = null; 
  private CourseTopicSubscriber courseTopicSubscriber1 = null; 
 
    @Override 
    public void init(ServletConfig config) throws ServletException <br class="title-page-name"/> { 
      super.init(config); 
      try { 
      courseQueueReceiver = new CourseQueueReceiver("Receiver1"); 
      courseQueueReceiver1 = new CourseQueueReceiver("Receiver2"); 
      courseTopicSubscriber = new <br class="title-page-name"/>       CourseTopicSubscriber("Subscriber1");      courseTopicSubscriber1 = new <br class="title-page-name"/>       CourseTopicSubscriber("Subscriber2"); 
 
    } catch (Exception e) { 
      log("Error creating CourseQueueReceiver", e); 
    } 
    } 
 
    //remaining code is unchanged. Skipping it 
} </pre>
<p class="mce-root">We now have two queue listeners and two topic listeners ready when the application starts. Republish the project, execute <kbd class="calibre13">addCourse.jsp</kbd>, and add a course. Check the messages in<span class="calibre12"> the</span> <span class="calibre12">Console</span> view of Eclipse. You will see that the message published in the topic is received by all subscribers, but the same message published in the queue is received by only one receiver:</p>
<div class="mce-root1"><img src="../images/00206.jpeg" class="calibre219"/></div>
<div class="packt_figure1">Figure 10.8: Console output showing multiple JMS receivers listening to JMS queue and topic</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JMS application using JSF and CDI beans</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will see how to create a JMS application using JSF and <strong class="calibre5">Component Dependency Injection</strong> (<strong class="calibre5"><span class="calibre12">CDI</span></strong>) beans. With CDI beans, we can reduce the code that we wrote using JMS APIs, because we can use annotations to inject objects such as the JMS connection factory, queue, and topic. Once we obtain references to these objects,<span class="calibre12"> the</span> steps to send or receive data are the same as those discussed in the previous section. Therefore, our examples in this section do not list the entire code. For the complete source code, download the source code for this chapter.</p>
<p class="calibre3">To prepare our project for using JSF, we need to create <kbd class="calibre13">web.xml</kbd> and add the JSF servlet definition and mapping in it. Right-click on the project and select<span class="calibre12"> the</span> <span class="calibre12">Java EE Tools</span> | <span class="calibre12">Generate Deployment Descriptor Stub</span> option. This creates <kbd class="calibre13">web.xml</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">WebContent/WEB-INF</kbd> folder. Add the following servlet definition and mapping (within<span class="calibre12"> the</span> <kbd class="calibre13">web-app</kbd> tag) in <kbd class="calibre13">web.xml</kbd>:</p>
<pre class="calibre25">  &lt;servlet&gt; 
    &lt;servlet-name&gt;JSFServelt&lt;/servlet-name&gt; 
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt; 
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 
  &lt;/servlet&gt; 
 
  &lt;servlet-mapping&gt; 
    &lt;servlet-name&gt;JSFServelt&lt;/servlet-name&gt; 
    &lt;url-pattern&gt;*.xhtml&lt;/url-pattern&gt; 
  &lt;/servlet-mapping&gt; </pre>
<p class="calibre3">For CDI beans to work, we need to create a <kbd class="calibre13">beans.xml</kbd> file in the <kbd class="calibre13">META-INF</kbd> folder. You will find<span class="calibre12"> the</span> <kbd class="calibre13">META-INF</kbd> folder under <span class="calibre12">the </span><kbd class="calibre13">WebContent</kbd> folder in the project in Eclipse. Let's create<span class="calibre12"> the</span> <kbd class="calibre13">bean.xml</kbd> file in <kbd class="calibre13">META-INF</kbd> with the following content:</p>
<pre class="calibre25"><span>&lt;</span><span>beans</span><span> </span><span>xmlns</span><span>=</span>"http://java.sun.com/xml/ns/javaee"<span> <br class="title-page-name"/></span><span>  </span><span>xmlns:xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br class="title-page-name"/></span><span><span>  </span></span>xsi:schemaLocation<span>=</span><span>"<br class="title-page-name"/></span><span>    </span>http://java.sun.com/xml/ns/javaee<br class="title-page-name"/><span>    </span>http://java.sun.com/xml/ns/javaee/beans_1_0.xsd"<span>&gt;<br class="title-page-name"/></span><span>&lt;/</span>beans<span>&gt;</span></pre>
<p class="calibre3">We will now create two CDI beans for the JSF page. The first one is <kbd class="calibre13">CourseManagedMsgSenderBean</kbd>. The second one is <kbd class="calibre13">CourseJSFBean</kbd>, which will be referenced from the JSF page.</p>
<p class="calibre3">Create<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagedMsgSenderBean</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms.jsf_bean</kbd> package with the following content:</p>
<pre class="calibre25">package packt.jee.eclipse.jms.jsf_bean;<br class="title-page-name"/><br class="title-page-name"/>import javax.enterprise.context.SessionScoped;<br class="title-page-name"/>import javax.inject.Named;<br class="title-page-name"/>//skipped other imports <br class="title-page-name"/><br class="title-page-name"/>@Named("courseMessageSender")<br class="title-page-name"/>@SessionScoped<br class="title-page-name"/>public class CourseManagedMsgSenderBean implements Serializable {<br class="title-page-name"/><br class="title-page-name"/>  @Resource(name = "jms/CourseManagementCF")<br class="title-page-name"/>  private QueueConnectionFactory connectionFactory;<br class="title-page-name"/>  @Resource(lookup = "jms/courseManagementQueue")<br class="title-page-name"/>  private Queue queue;<br class="title-page-name"/>  <br class="title-page-name"/>  QueueConnection connection;<br class="title-page-name"/>  QueueSession session;<br class="title-page-name"/>  Exception initException = null;<br class="title-page-name"/>  <br class="title-page-name"/>  @PostConstruct<br class="title-page-name"/>  public void init() {<br class="title-page-name"/>    try {<br class="title-page-name"/>      connection = connectionFactory.createQueueConnection();<br class="title-page-name"/>      connection.start();<br class="title-page-name"/>      session = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);<br class="title-page-name"/>    } catch (Exception e) {<br class="title-page-name"/>      initException = e;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  @PreDestroy<br class="title-page-name"/>  public void cleanup() {<br class="title-page-name"/>    if (connection != null) {<br class="title-page-name"/>      try {<br class="title-page-name"/>        connection.close();<br class="title-page-name"/>      } catch (JMSException e) {<br class="title-page-name"/>        e.printStackTrace();<br class="title-page-name"/>        //TODO: log exception<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void addCourse(CourseDTO courseDTO) throws Exception {<br class="title-page-name"/>    <br class="title-page-name"/>    if (initException != null)<br class="title-page-name"/>      throw initException;<br class="title-page-name"/>    <br class="title-page-name"/>    QueueSender sender = session.createSender(queue);<br class="title-page-name"/>    ObjectMessage objMessage = session.createObjectMessage(courseDTO);<br class="title-page-name"/>    sender.send(objMessage);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">Notice that the JMS connection factory and queue objects are injected using<span class="calibre12"> the</span> <kbd class="calibre13">@Resource</kbd> annotation. We have used<span class="calibre12"> the</span> <kbd class="calibre13">@PostConstruct</kbd> annotation to create a JMS a connection and a session and<span class="calibre12"> the</span> <kbd class="calibre13">@PreDestroy</kbd> annotation for the clean-up operation. The <kbd class="calibre13">addCourse</kbd> method is similar to the code that we already implemented in<span class="calibre12"> the</span> <kbd class="calibre13">CourseQueueSender</kbd> class in the previous section.</p>
<p class="calibre3">Let's now create<span class="calibre12"> the</span> <kbd class="calibre13">CourseJSFBean</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jms.jsf_bean</kbd> package with the following content:</p>
<pre class="calibre25">package packt.jee.eclipse.jms.jsf_bean;<br class="title-page-name"/><br class="title-page-name"/>import javax.enterprise.context.RequestScoped;<br class="title-page-name"/>import javax.inject.Inject;<br class="title-page-name"/>import javax.inject.Named;<br class="title-page-name"/><br class="title-page-name"/>import packt.jee.eclipse.jms.dto.CourseDTO;;<br class="title-page-name"/><br class="title-page-name"/>@Named("course")<br class="title-page-name"/>@RequestScoped<br class="title-page-name"/>public class CourseJSFBean {<br class="title-page-name"/>  private CourseDTO courseDTO = new CourseDTO();<br class="title-page-name"/>  <br class="title-page-name"/>  @Inject<br class="title-page-name"/>  private CourseManagedMsgSenderBean courseMessageSender;<br class="title-page-name"/><br class="title-page-name"/>  public String getName() {<br class="title-page-name"/>    return this.courseDTO.getName();<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setName(String name) {<br class="title-page-name"/>    this.courseDTO.setName(name); <br class="title-page-name"/>  }<br class="title-page-name"/>  public int getCredits() {<br class="title-page-name"/>    return this.courseDTO.getCredits();<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setCredits(int credits) {<br class="title-page-name"/>    this.courseDTO.setCredits(credits);;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void addCourse() throws Exception {<br class="title-page-name"/>    //skipping validation<br class="title-page-name"/>    //TODO: handle exception properly and show error message<br class="title-page-name"/>    courseMessageSender.addCourse(courseDTO);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">An instance of <kbd class="calibre13">CourseManagedMsgSenderBean</kbd> is injected into <kbd class="calibre13">CourseJSFBean</kbd> using<span class="calibre12"> the</span> <kbd class="calibre13">@Inject</kbd> annotation. The <kbd class="calibre13">addCourse</kbd> method simply calls the same named method in <kbd class="calibre13">CourseManagedMsgSenderBean</kbd>.</p>
<p class="calibre3">Finally, let's create <kbd class="calibre13">addCourse.xhtml</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">WebContents</kbd> folder with the following content:</p>
<pre class="calibre25">&lt;html  
  
 &gt; 
 
&lt;head&gt; 
  &lt;title&gt;Add Course&lt;/title&gt; 
&lt;/head&gt; 
 
 &lt;body&gt; 
  &lt;h2&gt;Course Details&lt;/h2&gt; 
 
  &lt;h:form&gt; 
    &lt;table&gt; 
      &lt;tr&gt; 
        &lt;td&gt;Name:&lt;/td&gt; 
        &lt;td&gt; 
          &lt;h:inputText id="course_name" value="#{course.name}"/&gt; 
        &lt;/td&gt; 
      &lt;/tr&gt; 
      &lt;tr&gt; 
        &lt;td&gt;Credits:&lt;/td&gt; 
        &lt;td&gt; 
          &lt;h:inputText id="course_credits" <br class="title-page-name"/>           value="#{course.credits}"/&gt; 
        &lt;/td&gt; 
      &lt;/tr&gt; 
      &lt;tr&gt; 
        &lt;td colspan="2"&gt; 
            &lt;h:commandButton value="Submit" <br class="title-page-name"/>             action="#{course.addCourse}"/&gt; 
        &lt;/td&gt; 
      &lt;/tr&gt; 
    &lt;/table&gt; 
  &lt;/h:form&gt; 
 
&lt;/body&gt; 
 
&lt;/html&gt; </pre>
<p class="calibre3">Form fields are bound to fields in <kbd class="calibre13">CourseJSFBean</kbd>. When<span class="calibre12"> the</span> <span class="calibre12">Submit</span> button is clicked,<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> method of the same bean is called, which puts a message in the JMS queue.</p>
<p class="calibre3">Republish the project and execute <kbd class="calibre13">addCourse.xhtml</kbd> by right-clicking it and selecting <span class="calibre12">Run As</span> | <span class="calibre12">Run on Server</span>. Add a course and see the message printed in the GlassFish <span class="calibre12">Console</span> view of Eclipse.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Consuming JMS messages using MDBs</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Message-driven beans</strong> (<strong class="calibre5">MDBs</strong>) make consuming JMS messages a lot easier. With just a couple of annotations and implementing the <kbd class="calibre13">onMessage</kbd> method, you can make any Java object a consumer of JMS messages. In this section, we will implement an MDB to consume messages from<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> queue. To implement MDBs, we need to create an EJB project. Select <span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">EJB Project</span> from the main menu:</p>
<div class="mce-root1"><img src="../images/00207.jpeg" class="calibre220"/></div>
<div class="packt_figure1">Figure 10.9: Create a EJB project to implement MDBs</div>
<p class="calibre3">Enter <span class="calibre12">Project name</span> as <kbd class="calibre13">CourseManagementEJB</kbd>. Click <span class="calibre12">Next</span>. Accept the default values on the subsequent pages and click <span class="calibre12">Finish</span> on the last page.</p>
<p class="calibre3">Right-click on the project and select<span class="calibre12"> the</span> <span class="calibre12">New</span> | <span class="calibre12">Message-Driven Bean</span> option. This opens the MDB creation wizard:</p>
<div class="mce-root1"><img src="../images/00208.jpeg" class="calibre221"/></div>
<div class="packt_figure1">Figure 10.10: MDB creation wizard – class file information</div>
<p class="calibre3">Enter <kbd class="calibre13">packt.jee.eclipse.jms.mdb</kbd> as <span class="calibre12">Java package</span> and <kbd class="calibre13">CourseMDB</kbd> as <span class="calibre12">Class name</span>. Keep <span class="calibre12">Destination type</span> as <span class="calibre12">Queue</span>.</p>
<p class="mce-root"><span class="calibre12">Destination name</span> is the physical destination name that we specified when creating the queue and is not the JNDI name:</p>
<div class="mce-root1"><img src="../images/00209.jpeg" class="calibre222"/></div>
<div class="packt_figure1">Figure 10.11: JMS queue physical destination name in the GlassFish admin console</div>
<p class="calibre3">Enter <kbd class="calibre13">CourseManagementQueue</kbd> as <span class="calibre12">Destination type</span>. Click <span class="calibre12">Next</span>. Accept the default values on the second page and click <span class="calibre12">Finish</span>. The wizard generates the following code:</p>
<pre class="calibre25">@MessageDriven( 
    activationConfig = { 
      @ActivationConfigProperty(propertyName = "destinationType", 
            propertyValue = "javax.jms.Queue"), 
      @ActivationConfigProperty(propertyName = "destination", 
            propertyValue = "CourseManagementQueue") 
    }, 
    mappedName = "jms/courseManagementQueue") 
public class CourseMDB implements MessageListener { 
 
    /** 
     * Default constructor. 
     */ 
    public CourseMDB() { 
        // TODO Auto-generated constructor stub 
    } 
 
  /** 
     * @see MessageListener#onMessage(Message) 
     */ 
    public void onMessage(Message message) { 
        System.out.println("addCourse message received in <br class="title-page-name"/>         CourseMDB"); 
 
    } 
 
} </pre>
<p class="calibre3">The class is annotated with <kbd class="calibre13">@MessageDriven</kbd> with <kbd class="calibre13">activationConfig</kbd> and the JMS destination parameters specified in the wizard. It also creates<span class="calibre12"> the</span> <kbd class="calibre13">onMessage</kbd> method. In this method, we just print the message that the MDB received for adding a course. To process <kbd class="calibre13">ObjectMessage</kbd> in this class, we will have to refactor<span class="calibre12"> the</span> <kbd class="calibre13">CourseDTO</kbd> class to a shared <kbd class="calibre13">.jar</kbd> between EJB and the web project. This is left to the readers as an exercise.</p>
<p class="calibre3">The JEE container creates a pool of MDB objects for a single MDB class. An incoming message can be handled by any one of the instances of MDB in the pool. This can help in building a scalable message processing application.</p>
<p class="calibre3"><span class="calibre12">If you want to test the MDB, add the project to the GlassFish Server configured in Eclipse. To do this, right-click on the configured server in the </span><span class="calibre12">Servers</span><span class="calibre12"> view of Eclipse and select the </span><span class="calibre12">Add and Remove...</span><span class="calibre12"> option. Select the <span class="calibre12">CourseManagementEJB</span> project that we created and click </span><span class="calibre12">Finish</span><span class="calibre12">. Make sure that the server is started and the status is </span><span class="calibre12">[Started, Synchronized]</span><span class="calibre12">. You also need to add the <span class="calibre12">CourseManagementJMSWeb</span> project to the server, because we have JSF and JSP pages to add a course in that project. Run <kbd class="calibre13">addCourse.xhtml</kbd> or <kbd class="calibre13">addCourse.jsp</kbd> from the <span class="calibre12">CourseManagementJMSWeb</span> project, add a course, and check the GlassFish console in Eclipse for messages printed from message receivers and the MDB we created in this section. However, note that either the MDB or one of the queue listeners we developed in <span class="calibre12">CourseManagementJMSWeb</span></span> will be receiving the message, and not all of the receivers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">A messaging system can be a powerful tool for integrating disparate applications. It provides an asynchronous model of programming. The client does not wait for the response from the server and the server does not necessarily process requests at the same time that the client sends them. A messaging system can also be useful for building scalable applications and batch processing. JMS provides uniform APIs to access different messaging systems.</p>
<p class="calibre3">In this chapter, we learned how to send and receive messages from queues and to publish and subscribe messages from topics. There are many different ways to use JMS APIs. We started with the basic JMS APIs and then learned how annotations can help reduce some of the code. We also learned how to use MDBs to consume messages.</p>
<p class="calibre3">In the next chapter, we will see some of the techniques and tools used for profiling CPU and memory usages in Java applications.</p>


            </article>

            
        </section>
    </body></html>