- en: 'Chapter 4: Best Practices for Design and Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developers reading this book have probably viewed the previous chapters
    as appetizers. If that's the case, with this chapter, we are moving on to the
    main course. While collecting requirements and designing the architecture are
    crucial steps (I cannot highlight this enough), anyone who comes from a development
    background will surely want to get their hands dirty with code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on how to implement the concepts that we have
    theorized so far in the source code. Of course, in the real world, the edges are
    not so smooth, and the architectural design (including **UML** or **C4** schemas)
    and requirements management will continue during the implementation phase. However,
    in this chapter, we will focus on some well-known techniques to translate those
    design ideas into working software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding **Domain Driven Design** (**DDD**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing **Test Driven Development** (**TDD**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring **Behavior Driven Development** (**BDD**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User story mapping and value slicing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies and examples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to model complex use cases into
    elegant software concepts and define domains, objects, and patterns. You will
    learn how to use TDD and BDD to conduct development activities and implement meaningful
    use cases with each release. You will understand the concept of **Minimum Viable
    Products** (**MVPs**) and the technique of value slicing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: But first, we'll start with DDD, which will provide a solid foundation to build
    upon.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Domain Driven Design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD takes its name from the book of the same name by Eric Evans (2003). The
    subtitle beautifully clarifies what the goal is—**Tackling complexity in the heart
    of software**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the domain model, ubiquitous language,
    layered architecture, DDD patterns, and bounded contexts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: DDD is a widely adopted modeling technique to build rich and expressive domains.
    It is considered to be behind modern approaches such as microservices development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind DDD is discovering how to model our software in a way that mirrors
    the problem we are facing in the real world. It is expected that if properly modeled,
    our software will be readable, will adhere to requirements, and will work properly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there is no magic recipe for that: DDD provides a toolkit of patterns,
    best practices, and ideas to implement this modeling. This approach works particularly
    well with complex domains, but it might be overkill for smaller and simpler projects.
    Additionally, it is true that DDD provides a lot of good ideas, and you might
    consider adopting it partially if that fits your needs. But first, let''s begin
    with some considerations about the completeness of the domain model.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The anemic domain model
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In his seminal paper about this domain model, Martin Fowler defines the **anemic
    domain model** as an antipattern, which defies any basic purpose of **object-oriented
    programming**. Of course, I cannot disagree with that at all. Nevertheless, this
    kind of modeling is far too widespread, as it's a kind of quick and dirty way
    to design an application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在他关于这种领域模型的经典论文中，Martin Fowler将**贫血领域模型**定义为一种反模式，它违背了面向对象编程的基本目的。当然，我完全同意这一点。然而，这种建模方式过于普遍，因为它是一种快速且简单的设计应用的方法。
- en: Essentially, in the anemic domain model, each object maps with its real-world
    counterpart, including fields and relationships. Those are, in a way, kinds of
    data objects. What's missing in the anemic domain model's objects is the behavior,
    meaning the specific actions that are logically associated with that particular
    concept in the real world. Usually, the objects in an anemic domain model have
    getter and setter methods, and not much more. All of the behavior is codified
    as part of specific service objects, operating across all of the other data objects
    through specific methods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在贫血领域模型中，每个对象都与其实际世界的对应物相对应，包括字段和关系。这些在某种程度上是数据对象。贫血领域模型的对象中缺失的是行为，即与该特定概念在现实世界中逻辑相关的特定动作。通常，贫血领域模型中的对象有获取器和设置器方法，没有更多。所有行为都被编码为特定服务对象的一部分，通过特定方法在所有其他数据对象上操作。
- en: The issue, here, is that the domain model is simply slipping away from object-oriented
    programming and toward an overengineered procedural model. This could be good
    enough in simple scenarios and, indeed, is common in **Create, Read, Update, and
    Delete** (**CRUD**) applications over a relational database, where you are, more
    or less, exposing tables directly as an application, with very limited business
    logic on top.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于领域模型正逐渐从面向对象编程滑向一个过度设计的程序模型。在简单场景下，这或许足够好，实际上，在基于关系数据库的**创建、读取、更新和删除**（**CRUD**）应用中，这种情况很常见，你几乎是将表格直接暴露为应用，并且在上层只有非常有限的业务逻辑。
- en: If the model is bigger, and it encompasses more complete business logic, this
    way of modeling starts to show some limits. The data objects become similar, and
    it's harder to group them and define relationships. The service objects have more
    and more methods, with growing complexity. You start to gain the cons of both
    the procedural and object-oriented methods. After all, you have very few (if any)
    of the pros of object-oriented modeling. DDD aims for the opposite—building rich
    and expressive object-oriented designs. Let's examine how to start modeling applications
    on DDD principles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型更大，并且包含了更完整的业务逻辑，这种建模方式开始显示出一些局限性。数据对象变得相似，难以将它们分组并定义关系。服务对象的方法越来越多，复杂性也在增长。你开始感受到程序和面向对象方法的缺点。毕竟，你几乎没有（如果有的话）面向对象建模的优点。DDD的目标正好相反——构建丰富且具有表现力的面向对象设计。让我们来看看如何根据DDD原则开始建模应用。
- en: Understanding ubiquitous language
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解通用语言
- en: Indeed, the very first concept of DDD is the principle of good collaboration.
    To define a good domain model, you have to use both technical language and business
    language.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，领域驱动设计（DDD）的第一个概念就是良好的协作原则。为了定义一个好的领域模型，你必须使用技术语言和业务语言。
- en: This means having a team composed of domain experts besides software developers.
    *But how will those kinds of people cooperate when they speak different languages?*
    You will require a lingua franca to ensure they work together.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着团队由领域专家和软件开发者组成。*但是当这些人使用不同的语言时，他们将如何合作呢？* 你将需要一个通用语来确保他们能够共同工作。
- en: The concept around the ubiquitous language is simple and brilliant, that is,
    to define a shared dictionary for a business (for instance, analysts, domain experts,
    or whoever you want to include) and developers to talk together with fewer misunderstandings.
    However, it's a kind of abstract concept, and there is no magic recipe to achieve
    it. You can think about it as a shared culture built into the team. Unfortunately,
    no one has defined a template document or a kind of diagram that can solve the
    ubiquitous language challenge for everybody.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语言的概念简单而巧妙，即定义一个业务（例如，分析师、领域专家或你希望包括的任何人）和开发者之间共享的字典，以便他们可以更少地产生误解地进行交流。然而，这是一个抽象的概念，没有神奇的配方可以实现它。你可以将其视为团队中内置的共享文化。不幸的是，没有人定义一个模板文档或某种图表，可以解决每个人的通用语言挑战。
- en: Indeed, what's advised in DDD's essential literature is to use UML diagrams
    (especially class diagrams) and written documents (no particular format is required).
    However, what's essential is how you get to the shared understanding of ubiquitous
    language, and there is probably only one way to do this—by working together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，DDD基本文献中建议使用UML图（特别是类图）和书面文档（不需要特定的格式）。然而，关键是如何达到对通用语言的共同理解，可能只有一种方法——通过共同工作。
- en: Ubiquitous language is all about how to name the concepts in your model properly.
    And by concepts, we are not necessarily referring to **Java** classes (as they
    are an implementation detail), nor to business processes (as, perhaps, they are
    not mapped one to one in our application). We are referring to something in the
    middle, that is, a model that is understandable and makes sense for a business
    and is translatable in meaningful ways into software artifacts by developers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语言的核心是如何恰当地命名模型中的概念。通过概念，我们不一定是指**Java**类（因为它们是实现细节），也不是指业务流程（因为，也许，它们在我们的应用程序中不是一对一映射的）。我们指的是中间的东西，即一个对业务有可理解性和意义，并且可以通过开发者以有意义的方式翻译成软件工件的模型。
- en: Of course, the model will comprehend objects, the relationships behind them,
    and the actions they perform. It is also essential for the team to share the meanings
    of each operation. Simply defining the name of each interaction might not solve
    any ambiguities. Once a shared understanding has been reached (it might be a recurrent
    effort with many cycles), then it must be strictly respected.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，模型将理解对象、它们背后的关系以及它们执行的操作。对于团队来说，共享每个操作的含义也是至关重要的。仅仅定义每个交互的名称可能无法解决任何歧义。一旦达成共同理解（可能是一个反复进行、包含多个循环的努力），就必须严格遵守。
- en: This includes using the naming consistently in code and in all of the other
    artifacts produced (such as analysis documents, test plans, and more), as well
    as referring to things with the right name in meetings and documenting this shared
    understanding in some way (as I said, the format is up to you). As we discussed
    earlier, ubiquitous language is all about creating a shared culture in a working
    team across different specialties.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括在代码和所有其他产生的工件（如分析文档、测试计划等）中一致地使用命名，以及在会议中用正确的名称指代事物，并以某种方式记录这种共同理解（正如我所说的，格式由你决定）。正如我们之前讨论的，通用语言的核心是创建一个跨不同专业的工作团队中的共享文化。
- en: The concept might appear abstract; nevertheless, it is essential and can be
    a useful tool even if you are not fully going with DDD. However, DDD also defines
    more concrete concepts, such as **layered architecture**, which we will look at
    in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可能看起来很抽象；然而，它是基本的，即使你不完全采用DDD，它也可以是一个有用的工具。然而，DDD还定义了更具体的概念，如**分层架构**，我们将在下一节中探讨。
- en: Getting familiar with layered architecture
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉分层架构
- en: When we start to define the conceptual model around our application, it's natural
    to wonder where this model practically fits in our implementation and how to keep
    it pure, regardless of the technology we are using. Think about persistence (the
    database), the **User Interface** (**UI**), and such. Those technologies probably
    have constructs that differ from our model. They might not even be object-oriented
    at all. And for sure, we don't want a change driven by technological reasons (such
    as the optimization of a query or a change in the UI) to affect our domain model.
    DDD tackles this concept directly by suggesting a layered architecture approach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始定义围绕我们应用程序的概念模型时，自然会想知道这个模型在实际实施中如何定位，以及如何保持其纯粹性，无论我们使用什么技术。考虑持久性（数据库）、**用户界面**（UI）等。这些技术可能具有与我们模型不同的结构。它们甚至可能根本不是面向对象的。当然，我们不希望技术原因（如查询优化或UI的变化）导致我们的领域模型受到影响。领域驱动设计（DDD）通过建议分层架构方法直接处理这个概念。
- en: Here, the idea is to partition the application code into different layers, loosely
    coupled to each other. Then, you implement your domain model into one of those
    layers, encapsulating the technological details in the other layers, each one
    with well-defined responsibilities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，想法是将应用程序代码划分为不同的层，它们之间松散耦合。然后，你将领域模型实现到这些层中的一层，将技术细节封装在其他层中，每一层都有明确的职责。
- en: 'A simple and common example of this is with the four layers divided, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单且常见的例子是将四个层次划分为以下部分：
- en: '![Figure 4.1 – Layered architecture'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 分层架构'
- en: '](img/Figure_4.01_B16354.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.01](img/Figure_4.01_B16354.jpg)'
- en: Figure 4.1 – Layered architecture
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 分层架构
- en: 'As you can see, the layered architecture is divided as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，分层架构被划分为以下几部分：
- en: '**Presentation Layer**: This layer includes all of the code required to present
    and collect the data for users. Additionally, this could include machine-to-machine
    interactions (such as in API calls).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这一层包括所有用于向用户展示和收集数据的代码。此外，这还可能包括机器到机器的交互（例如，在API调用中）。'
- en: '**Application Layer**: This layer is similar to what''s implemented in the
    **Backends for Frontends** pattern (we''ll cover this in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141),
    *Exploring Essential Java Architectural Patterns*). Essentially, this layer is
    a proxy, stateless and without business logic, which simply coordinates the interactions
    between the presentation layer and the rest of the application.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这一层类似于在**前后端分离模式**（我们将在[*第6章*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141)，*探索核心Java架构模式*中介绍）中实现的内容。本质上，这一层是一个代理，无状态且没有业务逻辑，它仅仅协调表示层与其他应用部分之间的交互。'
- en: The application layer can store session data and perform basic orchestration
    (such as aggregating or ordering calls to the underlying layers). In my opinion,
    this layer can be considered optional in some kinds of applications. The risk
    is that if you avoid it, it will couple the presentation layer tightly to the
    rest of the architecture. On the other hand, if you decide to adopt it, you should
    be mindful of the risk of sneaking in too much business logic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层可以存储会话数据并执行基本编排（例如，对底层层的调用进行聚合或排序）。在我看来，在某些类型的应用中，这一层可以被认为是可选的。风险是，如果你避免使用它，它将紧密地将表示层与其他架构部分耦合在一起。另一方面，如果你决定采用它，你应该注意过多引入业务逻辑的风险。
- en: '**Domain Layer**: This layer is, of course, the core of proper DDD. Here lies
    the whole business model, adherent to what we are representing, in terms of objects,
    their state, and their behavior. The domain layer exposes the functionalities
    of the higher levels and uses the underlying layer for technical matters.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域层**：当然，这一层是正确实现领域驱动设计（DDD）的核心。整个商业模式，包括我们所代表的对象、其状态和其行为，都位于这一层。领域层暴露了更高层的功能，并使用底层来处理技术问题。'
- en: '**Infrastructure Layer**: This layer is a supporting layer that deals with
    all of the other layers. It can be defined as the glue between the layers themselves
    and the technological layers providing functionalities. Here, a classic feature
    is persistence—objects in the domain layer use features exposed by the infrastructure
    layer, which deals with the database (or other persistent technology) using its
    native protocols and libraries.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施层**：这一层是一个支持层，处理所有其他层。它可以被定义为层与层之间的粘合剂，以及提供功能的科技层。在这里，一个经典的功能是持久性——领域层中的对象使用基础设施层暴露的功能，该层使用其本地的协议和库来处理数据库（或其他持久化技术）。'
- en: This organization might look familiar to you, as it's described in various forms
    and variants in the software area (you might find some similarities with the **Model-View-Controller**
    pattern, which we will examine in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141),
    *Exploring Essential Java Architectural Patterns*). However, do take into account
    that this is mostly a way to nicely group responsibilities. It doesn't necessarily
    mean that each layer should be deployed on its own, as a separate process or artifact.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织结构可能对你来说很熟悉，因为它在软件领域以各种形式和变体被描述（你可能会在[*第6章*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141)，*探索核心Java架构模式*中找到一些相似之处）。然而，请注意，这主要是一种将责任很好地分组的方法。这并不一定意味着每个层都应该单独部署，作为一个独立的过程或工件。
- en: 'Having discussed layered architecture, let''s focus on the heart of DDD: the
    **Domain Model** and its parts.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了分层架构之后，让我们集中讨论DDD的核心：**领域模型**及其部分。
- en: Learning about the domain model
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解领域模型
- en: The **Domain Model** is an elegant way to represent reality and implement it
    in an object-oriented way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域模型**是一种优雅地表示现实并在面向对象方式中实现它的方法。'
- en: Essentially, you can consider the domain model as the opposite of the anemic
    model that we looked at earlier. In the anemic model, the objects simply include
    data and very limited (or even absent) behavior. The domain model of DDD stresses
    the expressiveness of objects and their behavior.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以将领域模型视为我们之前所讨论的贫血模型的反面。在贫血模型中，对象仅仅包含数据，并且行为非常有限（甚至没有）。DDD 的领域模型强调对象的表达性和它们的行为。
- en: 'Put simply, the domain model is simply the concept of comprehending the data
    and behavior of an application. DDD implements this idea by defining the elements
    detailed in the following sections, as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，领域模型就是理解应用程序的数据和行为的概念。DDD 通过定义以下章节中详细说明的元素来实现这一想法，如图所示：
- en: '![Figure 4.2 – The domain model'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 领域模型'
- en: '](img/Figure_4.02_B16354.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.02_B16354.jpg)'
- en: Figure 4.2 – The domain model
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 领域模型
- en: We will discuss each of the sections next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论每个部分。
- en: Entities
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体
- en: The **entity** is a core concept of the domain model. Essentially, it is related
    to modeling objects that have an identity and a history throughout the life cycle
    of our use case. The keyword for defining an entity is **identity**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体**是领域模型的一个核心概念。本质上，它与建模在整个用例生命周期中具有身份和历史的对象相关。定义实体的关键字是**身份**。'
- en: 'If an object in our use case has a strong identity concept, it will probably
    map with entities. A classic example is a person: in many use cases (including
    the mobile payments example that we are carrying throughout this book), a person''s
    identity is strongly defined, regardless of the values contained in its representing
    objects. In other words, if I have a person object, made up of the classic name,
    surname, and other details, having two objects with the same name and surname
    does not necessarily mean I am referring to the same person.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用例中的对象具有强烈的身份概念，它很可能与实体相对应。一个经典的例子是个人：在许多用例中（包括我们在整本书中贯穿的移动支付示例），一个人的身份被强烈定义，无论其代表对象中包含的值如何。换句话说，如果我有一个由经典的名字、姓氏和其他细节组成的人对象，有两个具有相同名字和姓氏的对象并不一定意味着我指的是同一个人。
- en: Indeed, I often resort to specific identifying fields (such as a tax code or
    something specific to my application domain—perhaps an account number) to distinguish
    a person object from another one. Moreover, the identity concept will still be
    valid even if the object is persisted (and retrieved). In other words, if I persist
    (or passivate) an entity object somewhere (such as in a database), it should be
    clear that it will refer to the same person (in real life) when it's loaded again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我经常求助于特定的标识字段（例如税号或与我应用领域相关的东西——可能是一个账户号码）来区分一个人对象与另一个对象。此外，即使对象被持久化（和检索），身份概念仍然有效。换句话说，如果我在某个地方（例如数据库）持久化（或钝化）一个实体对象，那么当它再次被加载时，应该清楚它将指向同一个真实生活中的个人。
- en: 'As is clear, defining an entity is a cross-cutting concern between a business
    and the developers. It is much more than simply identifying a unique field distinguishing
    objects from one another. Consider bank accounts: they are usually identified
    by a standard code that is internationally recognized, at the very least, across
    Europe (IBAN code). However, you might find that a bank account changes the associated
    IBAN code (such as when a merger between different banks occurs). In this case,
    *do the two IBAN codes refer to the same account?* *Will the old account disappear
    and be replaced by a new one?* *Should I instead use a third identifier (such
    as a UUID) to bridge between the two entities and bypass the problem?*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，定义一个实体是业务和开发者之间的一个横切关注点。它远不止是简单地识别一个区分对象的唯一字段。考虑银行账户：它们通常由一个在国际上得到认可的标准化代码来识别，至少在欧洲是这样（IBAN
    代码）。然而，你可能会发现银行账户会更改相关的 IBAN 代码（例如，当不同银行之间的合并发生时）。在这种情况下，*两个 IBAN 代码是否指向同一个账户？*
    *旧账户会消失并被新账户取代吗？* *我应该使用第三个标识符（例如 UUID）来在两个实体之间建立桥梁并绕过这个问题吗？*
- en: Usually, the answer is that it depends. In this scenario, it depends on the
    domain around which your use case is modeled. The identity concept can also be
    different in the same application (in an extended way). Ultimately, an entity
    object is very much related to the point of view you are considering. However,
    for sure, it needs to be an object with a very well-defined identity, regardless
    of the value of its attributes, which links us to a different kind of object—**value
    objects**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，答案是这取决于情况。在这种情况下，这取决于你的用例所基于的领域。在同一个应用中（以扩展的方式），身份概念也可能不同。最终，实体对象与你的视角有很大关系。然而，可以肯定的是，它需要是一个具有非常明确身份的对象，无论其属性值如何，这使我们联系到不同类型的对象——**值对象**。
- en: Value objects
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值对象
- en: Conceptually, value objects complement entity objects. Simply put, in a value
    object, the data inside the fields of the object is more important than the object's
    identity. Value objects simply transport information, and they can be shared,
    copied, and reused with ease. A typical example of a value object is an address
    (such as a city, street name, or zip code). It doesn't matter what the identity
    of each one is; what does matter is the data inside.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，值对象补充了实体对象。简单来说，在值对象中，对象字段中的数据比对象的身份更重要。值对象只是传输信息，它们可以轻松地共享、复制和重用。值对象的典型例子是地址（如城市、街道名称或邮政编码）。每个对象的身份无关紧要；重要的是里面的数据。
- en: 'Value objects should be immutable. Because they are immutable, they are simpler
    to use. One common example is multithreading: multiple threads can access the
    same object instance concurrently, and there is no need for locks, nor any risk
    of inconsistent value (as the value cannot be changed). It''s the same with passing
    object instances to methods: you can be sure that whatever happens, the value
    of the object cannot be changed. Essentially, with immutable objects, the life
    cycle is just easier to manage.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象应该是不可变的。因为它们是不可变的，所以使用起来更简单。一个常见的例子是多线程：多个线程可以同时访问同一个对象实例，无需加锁，也不会有值不一致的风险（因为值不能被更改）。将对象实例传递给方法也是一样：你可以确信无论发生什么，对象的值都不会改变。本质上，使用不可变对象，生命周期更容易管理。
- en: Value objects are usually lighter and safer to manage than entity objects. Additionally,
    they can be part of an entity, that is, our person entity might have a link to
    an address value object. However, you should balance the usage of entities and
    value objects. If you only resort to value objects, you will probably fall into
    an anemic domain. There is still an important thing to discuss regarding object
    content, that is, *where can we put the behavior that doesn't belong to either
    entities or value objects?* The answer is **services**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象通常比实体对象更轻量级且更易于管理。此外，它们可以是实体的一部分，也就是说，我们的个人实体可能有一个链接到地址值对象的链接。然而，你应该平衡实体和值对象的使用。如果你只依赖值对象，你可能会陷入贫血领域。关于对象内容，还有一件重要的事情要讨论，那就是*我们可以将不属于实体或值对象的行为放在哪里？*
    答案是**服务**。
- en: Services
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: As mentioned earlier, entities and value objects are different in terms of identity.
    Instead, they share the grouping around a logical area, including data and behavior.
    In other words, both entities and value objects contain data (class attributes),
    the methods for manipulating it (getters and setters), and more sophisticated
    behavior (the business logic).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实体和值对象在身份方面是不同的。相反，它们在逻辑区域周围的分组上共享，包括数据和行为。换句话说，实体和值对象都包含数据（类属性）、操作它的方法（获取器和设置器）以及更复杂的行为（业务逻辑）。
- en: What's missing in this model is the cross-cutting behavior. Indeed, there are
    some actions that don't feel right when placed in a particular object. That's
    because those actions involve more than an object type, or they are simply ambiguous.
    It's important to not force those actions into an unrelated object, as this will
    impact the expressiveness of the model. Let's think about our mobile payment example
    again. *Should we put the peer-to-peer payment functionality in the sender or
    receiver account?*
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型缺少的是横切行为。确实，有些动作放在特定对象中感觉不合适。这是因为这些动作涉及到的不仅仅是对象类型，或者它们本身就是模糊的。重要的是不要将这些动作强加给无关的对象，因为这会影响模型的表达能力。让我们再次思考我们的移动支付示例。*我们应该将点对点支付功能放在发送者账户还是接收者账户中？*
- en: 'For all of these scenarios, you can define a **service**. A service explicitly
    maps actions that are directly linked to the domain as a whole, rather than to
    a specific object type. In this way, you can nicely group similar actions together
    without polluting entities or value objects with behavior that doesn''t belong
    there. It''s all about keeping the domain model rationally organized, which is
    also the goal of the next concept: the **aggregate**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些场景，你可以定义一个**服务**。服务明确地将与整个领域直接相关的动作映射出来，而不是映射到特定的对象类型。这样，你可以很好地将类似动作分组在一起，而不会污染实体或值对象，使其包含不属于那里的行为。这完全是关于保持领域模型合理组织，这也是下一个概念——**聚合**的目标。
- en: Aggregates
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合
- en: We mentioned the concept of **aggregates** in [*Chapter 2*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034),
    *Software Requirements – Collecting, Documenting, Managing*, when discussing event
    storming. It's worth saying that the whole idea of event storming is strictly
    related to DDD and one of the ways to put DDD into practice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034)“软件需求 - 收集、记录、管理”中提到了**聚合**的概念，当时在讨论事件风暴。值得一提的是，事件风暴的整个想法与领域驱动设计（DDD）密切相关，并且是实施DDD的一种方式。
- en: Let's return to the concept of aggregates; it's probably one of the most widely
    known ideas of DDD, and it's also widely used outside of DDD. Put simply, aggregates
    can be seen as transactional boundaries. The basic idea is to group a set of objects
    (that is, entities and/or value objects) by data changes. The objects in an aggregate
    are considered as a whole when it comes to changes to their internal status.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到聚合的概念；这可能是DDD最广为人知的思想之一，并且它也在DDD之外得到广泛应用。简单来说，聚合可以被视为事务边界。基本思想是按数据变化将一组对象（即实体和/或值对象）分组。在聚合中，当涉及到它们内部状态的变化时，这些对象被视为一个整体。
- en: An aggregate has an entry point object, called a **root entity**. Any change
    to any object part of the aggregate must be carried out through the root entity,
    which will then perform changes on the linked entities. That's from a technical
    point of view rather than a domain model point of view. What you are doing is
    invoking operations (or, even better, actions that are as meaningful in the real
    world as in the domain model) in the root entity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合有一个入口对象，称为**根实体**。对聚合中任何对象的任何更改都必须通过根实体进行，然后根实体将对相关实体执行更改。这更多是从技术角度而不是领域模型角度来说的。你所做的是在根实体中调用操作（或者更好的是，在现实世界和领域模型中都具有意义的动作）。
- en: This will also mean changing the linked objects under the hood. However, this
    is an implementation detail. From a logical standpoint, all of the interactions
    with objects in the aggregate are mediated by the root entity. For this reason,
    the aggregate is a core concept in DDD. It strictly maps the consistency of the
    model and can be easily translated into technical concepts such as database transactions.
    Aggregates can then be seen as a sort of **super object** made by the coordination
    of different objects. As such, the construction of an aggregate can become complex.
    For this reason, DDD introduces the **Factory pattern**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将意味着在底层更改相关对象。然而，这是一个实现细节。从逻辑角度来看，与聚合中对象的全部交互都由根实体介导。因此，聚合是DDD中的一个核心概念。它严格映射模型的完整性，可以轻松地转换为技术概念，如数据库事务。然后，聚合可以被视为由不同对象协调的**超级对象**。因此，聚合的构建可能会变得复杂。因此，DDD引入了**工厂模式**。
- en: Glancing at DDD patterns
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速浏览DDD模式
- en: DDD encompasses some patterns to provide support functionalities for the domain
    model, such as building and managing objects (such as entities and value objects).
    The factory pattern is the first pattern that we will look at.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: DDD包含一些模式，为领域模型提供支持功能，例如构建和管理对象（如实体和值对象）。工厂模式是我们将要探讨的第一个模式。
- en: Factory
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂
- en: The **factory** pattern is not a new concept. You can refer to the *Design Patterns*
    book by the Gang of Four, where this has been widely explained. Simply put, if
    you want to programmatically control the creation of an object (or a set of objects
    such as an aggregate), and not rely on the logic of a constructor, you can use
    the factory pattern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂**模式不是一个新概念。你可以参考四人帮的《设计模式》一书，其中对此有广泛的解释。简单来说，如果你想以编程方式控制对象的创建（或一组对象，如聚合），而不依赖于构造函数的逻辑，你可以使用工厂模式。'
- en: Factory is particularly useful to instantiate an aggregate. By invoking the
    factory pattern on the root element, you will coordinate the creation of the root
    itself and all of the other objects linked to the root (entities and value objects).
    Additionally, you can enforce transactionality on the creation of the objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式特别适用于实例化聚合。通过在根元素上调用工厂模式，你可以协调根本身的创建以及所有与根相关联的其他对象（实体和值对象）。此外，你还可以在对象的创建上强制执行事务性。
- en: If the creation of one of the objects fails, then you might want to abort the
    creation of the whole aggregate. The factory pattern can also be used to recreate
    objects from the database. In this scenario, rather than an instantiation from
    scratch, it's a retrieval of the existing root entity (and the linked subobjects).
    That's fine for addressing the retrieval of a known object (given its identity),
    *but how do you provide different kinds of lookups?* DDD suggests the usage of
    the **Repository pattern**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建一个对象失败，那么你可能想要取消整个聚合的创建。工厂模式也可以用来从数据库中重新创建对象。在这种情况下，它不是从头开始实例化，而是检索现有的根实体（以及相关的子对象）。这对于处理已知对象的检索（给定其标识）是可行的，*但是如何提供不同类型的查找呢？*
    领域驱动设计（DDD）建议使用**仓库模式**。
- en: Repository
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仓库
- en: A **repository**, in the DDD world, is a registry that is used to keep references
    to objects already instantiated (or persisted on a database). Simply put, a repository
    can be used to add, remove, and find objects. When used to find objects, typically,
    a repository acts as a bridge between the domain and the infrastructure layer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计（DDD）的世界里，**仓库**是一个注册表，用于保存已实例化（或已持久化到数据库中）的对象引用。简单来说，仓库可以用来添加、删除和查找对象。当用于查找对象时，通常，仓库充当领域层和基础设施层之间的桥梁。
- en: It helps to decouple the features and hide the implementation details of the
    persistence layer. You can retrieve objects using complex or vendor-specific queries
    in the infrastructure layer, and this is wrapped by an operation in the repository.
    It might even be that the infrastructure layer retrieves objects in different
    ways, such as invoking external web services rather than a database. Nothing will
    change from a repository point of view. The services exposed by the repository
    must have an explicit domain meaning, whereas the internal implementation might
    appear closer to the infrastructure logic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它有助于解耦功能并隐藏持久化层的实现细节。你可以在基础设施层使用复杂或供应商特定的查询来检索对象，这由仓库中的操作封装。甚至可能基础设施层以不同的方式检索对象，例如调用外部Web服务而不是数据库。从仓库的角度来看，这一切都不会改变。仓库公开的服务必须具有明确的领域意义，而内部实现可能看起来更接近基础设施逻辑。
- en: So far, in all of the concepts that we have examined, we have implicitly assumed
    that everything falls under one single domain model. Now, we will learn how to
    make different domains interact with each other by using the concept of a **Bounded
    Context**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们所考察的所有概念中，我们都隐含地假设一切都在一个单一的领域模型之下。现在，我们将学习如何通过使用**有限上下文**的概念，使不同的领域相互交互。
- en: Bounded Context
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限上下文
- en: It is common to identify a domain model using one application. That's a hard
    way to delimit the model boundaries. However, that's not always the case. When
    dealing with large applications, it could be that different models need to coexist.
    This is because a unified model is impractical (that is, too big or too complex),
    or because of the model's conflict (that is, an object has different meanings,
    depending on the point of view and the use cases touching it).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会使用一个应用程序来识别领域模型。这是一个界定模型边界的方法。然而，情况并不总是如此。当处理大型应用程序时，可能不同的模型需要共存。这是因为统一模型不切实际（即太大或太复杂），或者因为模型存在冲突（即一个对象根据观点和使用案例的不同而具有不同的含义）。
- en: In those scenarios, you might need to define a border around each domain model.
    A bounded context, then, is the area in which ubiquitous language is valid. If
    a bounded context can be seen as a country, with defined borders, ubiquitous language
    is the official (and only) language spoken of that country.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，你可能需要为每个领域模型定义一个边界。因此，有限上下文是普遍语言有效的区域。如果将有限上下文视为一个有明确边界的国家，那么普遍语言就是该国的官方（也是唯一）语言。
- en: Usually, a bounded context belongs to one team, and it has some well-defined
    coordinates, such as a portion of the code base and other subsets of related technologies
    (such as a defined set of tables of the database). Two different bounded contexts
    cannot share objects, nor call arbitrary methods of each other. The communication
    must follow well-defined interfaces. In order to support the cooperation between
    two different bounded contexts, a context map can be used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'A context map is a way to translate, when possible, concepts from one bounded
    context to another. There are some patterns suggested by DDD to realize context
    maps. These patterns include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared kernel**: This is when two bounded contexts share a subset of the
    domain model. While this technique is easy and intuitive, it can be hard to maintain,
    since the two teams managing the different bounded contexts must agree on any
    changes, and in any case, the risk of breaking functionalities in the other context
    is always present, so every change must be thoroughly tested (automatic is better).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer supplier**: This is similar, in a way, to the shared kernel approach,
    but the relationship here is asymmetrical. One of the two bounded contexts (the
    supplier) will own the interface, developing and maintaining the features, while
    the customer will simply ask for what is needed. This simplifies the synchronization
    a bit between the two teams. However, it can still create issues when priorities
    and milestones start to clash.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conformity**: This shares the customer-supplier type of relationship. The
    difference here is that the customer domain model completely adopts and imports
    a subset of the supplier domain model, as it did in the shared kernel approach.
    However, unlike shared kernel, the relationship stays asymmetric. This means that
    the customer cannot change (or ask for changes in) the shared model.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anti-corruption layer**: This is a different approach. In this case, there
    is a translator layer between the two domain objects. This layer acts as a demilitarized
    zone, preventing objects and behaviors from sneaking from one bounded context
    to another. This approach is commonly used when dealing with legacy applications,
    more than when two bounded contexts belong to the same application.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth noting that a proper DDD implementation is not easy to follow. There
    are several common errors that could slip into a DDD architectural design. The
    first and most common is the aforementioned anemic domain model, which is the
    most important reason why you would want to adopt something like DDD. However,
    it's also common to have some technology considerations slip into the domain model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: That's particularly true when it comes to the **persistent layer**. It is a
    common practice to design the domain in a way that mimics the database tables
    and relationships (in this case, we are using a relational database as a persistent
    backend). Last but not least, one common error is to design the domain model without
    engaging with domain experts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We could be tempted to design everything for the IT department, thinking we
    have a proper understanding of the world we would like to represent. Even if this
    is partially true, it's still worthwhile engaging with business experts, to better
    discuss the business jargon (please refer to the *Understanding ubiquitous language*
    section) and rely on their experience of the specific domain model.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: This section concludes our brief overview of DDD. As we have learned, DDD provides
    elegant ways in which to realize the ideas we have collected in the previous sections
    (including requirements and architectural designs) and put them into code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: This starts with the concept of ubiquitous language, which we discussed at the
    beginning of this section and is one of the big ideas of DDD, allowing common
    ground between all the stakeholders involved in the application development.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we moved on to the core concepts of DDD, such as the application
    *shape* (the layered architecture), the definition of objects and methods (the
    domain model and the encompassed objects), and the recommended practices (patterns)
    regarding how to address common concerns. A dedicated mention is needed for the
    concept of bounded contexts, which is a way to structure big applications into
    more than one *self-contained* model.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: As we will learn in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, DDD has some common ideas with microservices
    architectures.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at another common practice to drive the implementation
    of our design ideas—TDD.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Test Driven Development
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is a development technique based on a simple idea, that is, no code should
    exist without test coverage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In order to pursue this goal, TDD inverts our point of view. Instead of developing
    code, and then writing a unit test to cover its testing, you should start writing
    a test case. Of course, initially, the test case would intentionally fail while
    invocating empty or incomplete functions. However, you will have a clear goal,
    that is, your piece of code is complete when all tests are satisfied.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the end, you clearly define the boundaries of your software and
    the extent of its functions. Then, you run the tests, which will all fail. You
    keep developing the features, piece after piece, until all of the tests are satisfied.
    Finally, you move to the next piece of code (or class or package)—it's that simple.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this approach doesn't necessarily guarantee any particular quality
    or elegance in your code. Having a test pass does not imply that you are using
    good patterns or efficient solutions. In theory, you might as well simply hardcode
    the expected results to get a green light.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: However, this technique will have a very useful byproduct, that is, you can't
    forget (or purposefully avoid) to prove/test your code using test cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, there are several factors to take into account. First of all, some features
    might require external systems to work. You can test the interaction of such systems,
    simulating them with mocks, but of course, this will mean more code to write,
    more components (the mocks themselves), and a further degree of approximation
    (meaning that your test will be less representative of reality). Following this,
    you might need to test things that are less easy to automate, such as UIs and
    interactions with devices (for example, mobile devices). Yes, there are a number
    of solutions for this (such as automating browser navigation), but this will complicate
    things.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Let me highlight that, even if this will require a significant amount of effort,
    tests cannot be ditched. Testability is a crucial requirement, and it might also
    be a drive to rearchitect your code base, increasing modularity and simplifying
    it, in order to improve testability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you might have dependencies between the features. This means coordinating
    tests or, worse, having test results depend on the order in which they are running.
    Of course, this is not easy to maintain and, in general, is not a good idea.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In this specific case, you might want to properly structure your tests, in order
    to provide adequate setup and teardown phases, making everything simpler and reproducible
    and greatly increasing the quality of what you are testing. Then, you have to
    think about the granularity of the tests. It can be tempting to create one generic
    test and slip in as many hidden features as you can. On the other hand, if your
    tests are simply unit tests, covering every sub-function, you'll need to aggregate
    them in a meaningful way, in order to track down the advancements in implementing
    the features. In other words, shifting your point of view away from testing specific
    code sections toward testing application behavior.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: This is the idea behind BDD.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Behavior Driven Development
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BDD is a technique that extends the TDD approach while also using some DDD concepts.
    In particular, the workflow is the same as TDD, that is, write a test, run it
    (initially, it will fail), and implement the feature until the test succeeds.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: What changes is how the test is written. Instead of focusing on single functions
    (or, even better, relying on the developer to pick the right granularity), BDD
    defines the extent of each test a bit better. In particular, as highlighted in
    the name of the methodology, BDD tests are focused on the expected behavior, that
    is, the functionality implemented by each use case.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In this sense, it is an explicit suggestion to keep high-level functionalities,
    rather than method-by-method unit tests. BDD is also linked to DDD concepts. In
    particular, it is recommended that you use ubiquitous language as a way to specify
    each behavior. In this way, you have an explicit mapping between a business use
    case, expressed with ubiquitous language, translated into an automatic test case.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'BDD describes a way to define behaviors. In practice, each behavior is defined
    as a user story, with a structure given as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**As a**: This is a person or a role.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I want**: This is a specific functionality.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**So that**: This is when we can get some benefits from using that functionality.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provided that a number of scenarios are associated with the user story, each
    scenario is, essentially, an acceptance criterion, which can be easily translated
    into automated use cases:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: This is used for one or more initial conditions.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: This is used for when something happens.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then**: This is used for when one or more results are expected.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure is very self-explanatory. By using a similar template, and sticking
    to ubiquitous language, you will have a straightforward way in which to define
    use cases. It is a way that is meaningful for non-technical people and can be
    easily translated to automated use cases by technical people.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Walking backward, you implement code that will gradually cover the test cases,
    mapping to a behavior specification that will give direct feedback to the business
    on which use cases are complete.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This approach offers a structured way to understand what we are implementing
    and possibly select and prioritize the user story to approach as a development
    team. This is also the focus of the practice that we will look at in the next
    section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Comparing DDD, TDD, and BDD
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have rapidly discussed three different "Something-Driven Development"
    techniques. It must be clear that such practices should not necessarily be seen
    as alternatives, but they might have some complementarity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In particular, DDD relates more to the modeling of the application domain. In
    this sense, it can be observed from a more architectural point of view, defining
    how our application is modularized, the different layers, and even how different
    parts of our broader application (or, if you wish, different teams) should cooperate.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Once we have designed such layers and components, both TDD and BDD can be used
    as a way to drive our day-to-day development, ensuring we have the right testability
    and feature coverage requested within our code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, DDD is not a requirement for TDD or BDD, which can be seen
    as a simple technique that is also applicable to smaller applications, or to software
    architectures defined with approaches alternative to DDD. As you will often find
    in this book, those concepts can be viewed as tools, briefly introduced to give
    you an idea of their potentiality. It's up to you to then take what's needed for
    your specific project and combine it in a useful way.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Learning about user story mapping
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**User story mapping** is a way to put user stories into context, identify
    what it takes to implement them, and plan accordingly.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn what a user story is and how it can be used as
    a planning method, in order to choose what features to include in each release,
    following a meaningful pace.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The user story is the same concept that we saw as part of BDD. So, it describes
    a feature from the point of view of a specific persona (**As a**...), the functionalities
    required (**I want to**...), and the expected outcome (**So that**...).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: As you might observe, all pieces in the puzzle of those seemingly unrelated
    practices eventually start to match. User story mapping is often described as
    a **product backlog** on steroids.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss product backlogs in the next chapter. However, for now, consider
    them as lists of features to implement. Features are added as long as analysis
    occurs (or new requirements arise). These are then prioritized and picked by the
    development team to be implemented.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: User story mapping extends this approach by giving more dimensions to the product
    backlog, enriching the information related to each feature, and linking it to
    a broader vision of the product. User stories stay on top of the mapping. They
    describe the high-level features that a system should provide. User stories are
    organized in a horizontal line and ordered by both importance and the temporal
    sequence in which they happen, all from the user's point of view.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'For each user story, a list of tasks is provided. Essentially, these are the
    sub-features (also known as **activities**) that each user story encompasses.
    So, we are detailing each feature, but not yet coming to a level of detail that
    can be directly mapped into software (at least, not easily). Each task is then
    attached to a list of subtasks (or task details), which are easier to map to software
    features. This is what user story mapping looks like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – User story mapping](img/Figure_4.03_B16354.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – User story mapping
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing about this model is that you will not have to prioritize
    the tasks. You just need everything included there (sooner or later); however,
    you can prioritize the subtasks, gradually improving the completeness of each
    task, release after release.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: This model has a series of positive outcomes. First of all, as with BDD, you
    have a direct mapping between the subtask the development team is working on and
    the user story (or activity). Essentially, it gives visibility to the business
    regarding the finish line toward which we are rowing. Moreover, an interesting
    practice is applicable to this matrix of tasks and subtasks, namely, **value slicing**.
    This means picking what to implement for each release.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Given that you will have a finite number of resources (such as programmers,
    time, and whatever else is required to implement each subtask), you cannot, of
    course, deliver everything in one release. Well, you could, but it would be risky
    since you would have to wait a long time before receiving feedback and being able
    to test the software. We will elaborate more on the **release early, release often
    approach** (the well-known incremental product releases technique that is widely
    used in **Agile** and **DevOps**) in the next chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, what matters is that it is better to release value incrementally,
    by picking the subtasks that implement, at least partially, one or more tasks
    and then the related user stories. Here is what this would look like compared
    to *Figure 4.3*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Value slicing'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B16354.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Value slicing
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the approach here is oriented toward an MVP.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The MVP
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of MVP deserves some additional explanation. The term was created
    before the user story mapping technique and is an independent idea. It is also
    applicable to products that are different from the software code. The goal of
    the MVP is to maximize the value of the product (in terms of return of investment
    or, trivially, how useful, popular, and beneficial your product will be) while
    minimizing the risks and efforts required to build it. The perfect MVP requires
    a very low level of effort and risk to build, but it can become greatly popular
    and appreciated when used (and, optionally, sold).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of an MVP is to start getting feedback on the product from potential
    end users (usually, a subset of early adopters). Due to this, the MVP should contain
    a meaningful subset of features: not too many, to avoid wasting effort in case
    the product is not well received by customers, but just enough in order to represent
    what the complete product will be like. Early feedback, in the spirit of Agile
    development methodologies, could also be beneficial if some steering is required
    in the product direction, by stressing more on one aspect or another.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about user story mapping, which is the final technique
    we will explore in this chapter. In the next section, we will examine some examples
    of those approaches, as applied to our mobile payments use case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Case studies and examples
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As is easy to imagine, a complete and extensive example of DDD, TDD, BDD, and
    user story mapping, applied to our mobile payments case study, could easily take
    more than one book. For this reason, as we mentioned in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065),
    *Common Architecture Design Techniques*, unfortunately, we can only look at some
    highlights of those techniques used in our example. However, in this section,
    I think it is pretty useful to take a look at, even if to just practically visualize
    some concepts that might appear abstract so far.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The mobile payments domain model
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065), *Common Architecture
    Design Techniques*, we looked at the basic modeling of mobile payment objects
    based on the UML notation. To elaborate more on this, in DDD, you will mostly
    have the following concepts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The user is an entity. This concept is pretty straightforward, that is, the
    identity is very well defined, and each user has a well-defined life cycle (from
    registration to deletion).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment is an entity, too. Each user will want to keep track of exactly each
    transaction, including the time, the amount, the receiver, and more. It is also
    likely that there will be regulations for you to uniquely identify each payment
    transaction.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we've already mentioned, a peer-to-peer payment is out of place as a method,
    both in the sender and receiver entity. So, it is probably worth modeling a payment
    service that can also work as a bridge toward classical CRUD operations in the
    infrastructure layer.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the assumption that our application is operating on a global scale, you will
    need to manage transactions in different currencies. `ExchangeRate` is a typical
    example of a value object. It is immutable and composed of currency symbols and
    a number representing the exchange rate. It is a disposable object and can be
    easily shared between different payments, as no identity (nor state) is considered.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have defined (a very small subset of) the domain model of mobile payments,
    we are going to look at the layered architecture of this application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The layered architecture of mobile payments
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember the diagrams designed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*, and the C4 model
    drafted in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065), *Common
    Architecture Design Techniques*, you are already familiar with some of the technical
    components that implement our mobile payment architecture.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'There, the mapping between components was pretty much coarse-grained. This
    is because you would associate the mobile application with the **Presentation
    Layer**, the business logic with the **Domain Layer**, and so on. However, with
    DDD, we are progressing further with the analysis of our application. We are going
    one level down toward something similar to the **C4 Container** diagram (please
    refer to *Figure 3.8* in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065),
    *Common Architecture Design Techniques*) but from a different point of view. My
    idea of the layered architecture of our application looks similar to the following
    diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The DDD layered architecture'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.05_B16354.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – The DDD layered architecture
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, you might observe the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: All of the views in the **Presentation Layer** are a subset of the mobile application
    functionalities. You will probably have more functionalities in the real world.
    However, it's interesting to observe how some concepts of the **Domain Layer**
    (hence, the ubiquitous language) are echoed here. Yet, this is a pretty technical
    layer, so it does not strictly observe the ubiquitous language.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Application Layer** is a support area, decoupling the needs of the frontend
    with the services provided by the domain model in the **Domain Layer**. The relationship
    with the **Presentation Layer** is not one-to-one in this case, but that's up
    to you to decide according to your context. Additionally, this layer has a dependency
    on the **Domain Layer**.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `ExchangeRate` is not represented).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Infrastructure Layer** is the technological glue, providing services to
    other layers, and abstracting technology-specific details. So, in this case, you
    can see that **UserRepo** will mediate calls to IDM and other systems (for example,
    databases or CRMs), while **TransactionDataAdapter** abstracts calls to databases
    and legacy systems. Consider that in this scenario, there are no direct links
    between the **Presentation Layer** and the **Infrastructure Layer**, as everything
    is proxied by the **Application Layer**. However, that's not a strict requirement.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, I will share my views on how BDD could be applied to mobile
    payments.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: BDD of mobile payments
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we detailed in the *Exploring Behavior Driven Development* section, BDD
    starts with a user story. A basic user story for mobile payments could be the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**User Story**: Making a payment:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**As a** registered user.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I want** to make a payment to another user.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**So that** I can transfer money (and benefit from services or goods in exchange
    for that).'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might have gathered, this user story implies other user stories (such
    as **Registration of a user** and **Login**).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The next logical step is to enumerate some scenarios (or acceptance criteria)
    linked to that story:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Given** that I am registered.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I am logged in.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When** I select the payment feature.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then** I am redirected to the payment view.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Given** that I am at the payment view.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I am logged in.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I enter a valid recipient.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I enter a valid amount.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When** I click on the pay button.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then** a payment transaction is created.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** a notification is sent.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As demonstrated in the preceding examples, each user story usually corresponds
    to more than one acceptance criteria, which is then codified as a set of (possibly
    automated) test cases. Following this, you can start to iteratively implement
    features until each acceptance criteria is met, ultimately fully covering the
    related user story. Now, let's expand on this user story by means of user story
    mapping.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: User story mapping of mobile payments
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Learning about user story mapping* section, we discovered that the top-level
    element is the user story. So, we will start with the stories that we have just
    observed in the previous section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Take into account that while it can be considered as a task attached to each
    user story, the acceptance criterion is usually considered more like an orthogonal
    concept, to validate the implementation of each story. Usually, the attached tasks
    are simply more detailed features composing the story itself. Let''s view an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – User story mapping example'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.06_B16354.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – User story mapping example
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding (simplified) example, for each activity (mapping
    to a user story, as per the *BDD of mobile payments* section) there are one or
    more related tasks. Activities and tasks are ordered following a time (and priority)
    direction. Then, each task is attached to a list of subtasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a logical next step to plan how to group a set of subtasks as a release,
    progressively delivering value to the final customer (think about MVPs). We''ve
    described this approach as value slicing, which appears as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Value slicing example'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.07_B16354.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Value slicing example
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, we've represented a simple slicing
    of features as two releases. In the first release (**Release 1**), you will provide
    the bare minimum functionalities. It will be possible to create users, to **Sign
    in** (but not using a social account), and to **Make a payment** (but without
    receiving a notification).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: There will be no functionalities regarding lost passwords and payment disputes.
    In the second release (**Release 2**), no new features will be added to the registration
    activity, the **Lost password** task will be completed (being made of just one
    subtask), and the whole **Dispute a payment** task will be completed (in both
    its two subtasks).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: All of the other subtasks are part of the backlog, meaning they are yet to be
    planned (and more subtasks can then be added). Of course, each line representing
    a release is drawn together with business/product owners, which will define the
    priority and helps to aggregate subtasks in a meaningful way. With value slicing,
    we have completed the objectives of this chapter. Let's look at a quick recap
    of all the notions we have encountered.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a set of techniques to start transforming architecture
    principles into working software components. DDD is a pretty complete framework
    that is used to define objects and the way they interact with each other. It puts
    a number of clever ideas down on paper, such as layered architectures, patterns,
    and bounded contexts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we moved on to Test Driven Design and BDD. You now understand
    specific ways of structuring the development of new code and mapping it to business
    features. Finally, we looked at user story mapping as a way to pick functionalities
    to implement and link them to tasks and activities.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: All of these techniques will be better framed in the next chapter, where we
    will discuss **Agile** methodologies, which include some of the practices that
    we have just discussed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Anemic Domain Model* by Martin Fowler ([https://martinfowler.com/bliki/AnemicDomainModel.html](https://martinfowler.com/bliki/AnemicDomainModel.html))'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans ([https://www.domainlanguage.com/](https://www.domainlanguage.com/))'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design Quickly*, by Abel Avram and Floyd Marinescu, published
    by C4Media (2007)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10 Common DDD Mistakes to Avoid* by Jan Stenberg ([https://www.infoq.com/news/2015/07/ddd-mistakes/](https://www.infoq.com/news/2015/07/ddd-mistakes/))'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introducing BDD* by Dan North ([https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/))'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BDD in Action: Behavior-Driven Development for the Whole Software Lifecycle*,
    by John Ferguson Smart, published by Manning Publications (2004)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*User Story Mapping & Value Slicing* by Matt Takane and Ryan DeBeasi ([https://openpracticelibrary.com/practice/user-story-mapping/](https://openpracticelibrary.com/practice/user-story-mapping/))'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Top 5 Biggest Challenges when Building an MVP and how to Avoid Them* by Ilya
    Matanov ([https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757](https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757))'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The New User Story Backlog is a Map* by Jeff Patton ([https://www.jpattonassociates.com/the-new-backlog/](https://www.jpattonassociates.com/the-new-backlog/))'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
