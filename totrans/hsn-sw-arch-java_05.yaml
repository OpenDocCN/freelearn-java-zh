- en: 'Chapter 4: Best Practices for Design and Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developers reading this book have probably viewed the previous chapters
    as appetizers. If that's the case, with this chapter, we are moving on to the
    main course. While collecting requirements and designing the architecture are
    crucial steps (I cannot highlight this enough), anyone who comes from a development
    background will surely want to get their hands dirty with code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on how to implement the concepts that we have
    theorized so far in the source code. Of course, in the real world, the edges are
    not so smooth, and the architectural design (including **UML** or **C4** schemas)
    and requirements management will continue during the implementation phase. However,
    in this chapter, we will focus on some well-known techniques to translate those
    design ideas into working software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding **Domain Driven Design** (**DDD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing **Test Driven Development** (**TDD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring **Behavior Driven Development** (**BDD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User story mapping and value slicing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to model complex use cases into
    elegant software concepts and define domains, objects, and patterns. You will
    learn how to use TDD and BDD to conduct development activities and implement meaningful
    use cases with each release. You will understand the concept of **Minimum Viable
    Products** (**MVPs**) and the technique of value slicing.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we'll start with DDD, which will provide a solid foundation to build
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Domain Driven Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD takes its name from the book of the same name by Eric Evans (2003). The
    subtitle beautifully clarifies what the goal is—**Tackling complexity in the heart
    of software**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the domain model, ubiquitous language,
    layered architecture, DDD patterns, and bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: DDD is a widely adopted modeling technique to build rich and expressive domains.
    It is considered to be behind modern approaches such as microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind DDD is discovering how to model our software in a way that mirrors
    the problem we are facing in the real world. It is expected that if properly modeled,
    our software will be readable, will adhere to requirements, and will work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there is no magic recipe for that: DDD provides a toolkit of patterns,
    best practices, and ideas to implement this modeling. This approach works particularly
    well with complex domains, but it might be overkill for smaller and simpler projects.
    Additionally, it is true that DDD provides a lot of good ideas, and you might
    consider adopting it partially if that fits your needs. But first, let''s begin
    with some considerations about the completeness of the domain model.'
  prefs: []
  type: TYPE_NORMAL
- en: The anemic domain model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In his seminal paper about this domain model, Martin Fowler defines the **anemic
    domain model** as an antipattern, which defies any basic purpose of **object-oriented
    programming**. Of course, I cannot disagree with that at all. Nevertheless, this
    kind of modeling is far too widespread, as it's a kind of quick and dirty way
    to design an application.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, in the anemic domain model, each object maps with its real-world
    counterpart, including fields and relationships. Those are, in a way, kinds of
    data objects. What's missing in the anemic domain model's objects is the behavior,
    meaning the specific actions that are logically associated with that particular
    concept in the real world. Usually, the objects in an anemic domain model have
    getter and setter methods, and not much more. All of the behavior is codified
    as part of specific service objects, operating across all of the other data objects
    through specific methods.
  prefs: []
  type: TYPE_NORMAL
- en: The issue, here, is that the domain model is simply slipping away from object-oriented
    programming and toward an overengineered procedural model. This could be good
    enough in simple scenarios and, indeed, is common in **Create, Read, Update, and
    Delete** (**CRUD**) applications over a relational database, where you are, more
    or less, exposing tables directly as an application, with very limited business
    logic on top.
  prefs: []
  type: TYPE_NORMAL
- en: If the model is bigger, and it encompasses more complete business logic, this
    way of modeling starts to show some limits. The data objects become similar, and
    it's harder to group them and define relationships. The service objects have more
    and more methods, with growing complexity. You start to gain the cons of both
    the procedural and object-oriented methods. After all, you have very few (if any)
    of the pros of object-oriented modeling. DDD aims for the opposite—building rich
    and expressive object-oriented designs. Let's examine how to start modeling applications
    on DDD principles.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ubiquitous language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indeed, the very first concept of DDD is the principle of good collaboration.
    To define a good domain model, you have to use both technical language and business
    language.
  prefs: []
  type: TYPE_NORMAL
- en: This means having a team composed of domain experts besides software developers.
    *But how will those kinds of people cooperate when they speak different languages?*
    You will require a lingua franca to ensure they work together.
  prefs: []
  type: TYPE_NORMAL
- en: The concept around the ubiquitous language is simple and brilliant, that is,
    to define a shared dictionary for a business (for instance, analysts, domain experts,
    or whoever you want to include) and developers to talk together with fewer misunderstandings.
    However, it's a kind of abstract concept, and there is no magic recipe to achieve
    it. You can think about it as a shared culture built into the team. Unfortunately,
    no one has defined a template document or a kind of diagram that can solve the
    ubiquitous language challenge for everybody.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, what's advised in DDD's essential literature is to use UML diagrams
    (especially class diagrams) and written documents (no particular format is required).
    However, what's essential is how you get to the shared understanding of ubiquitous
    language, and there is probably only one way to do this—by working together.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language is all about how to name the concepts in your model properly.
    And by concepts, we are not necessarily referring to **Java** classes (as they
    are an implementation detail), nor to business processes (as, perhaps, they are
    not mapped one to one in our application). We are referring to something in the
    middle, that is, a model that is understandable and makes sense for a business
    and is translatable in meaningful ways into software artifacts by developers.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the model will comprehend objects, the relationships behind them,
    and the actions they perform. It is also essential for the team to share the meanings
    of each operation. Simply defining the name of each interaction might not solve
    any ambiguities. Once a shared understanding has been reached (it might be a recurrent
    effort with many cycles), then it must be strictly respected.
  prefs: []
  type: TYPE_NORMAL
- en: This includes using the naming consistently in code and in all of the other
    artifacts produced (such as analysis documents, test plans, and more), as well
    as referring to things with the right name in meetings and documenting this shared
    understanding in some way (as I said, the format is up to you). As we discussed
    earlier, ubiquitous language is all about creating a shared culture in a working
    team across different specialties.
  prefs: []
  type: TYPE_NORMAL
- en: The concept might appear abstract; nevertheless, it is essential and can be
    a useful tool even if you are not fully going with DDD. However, DDD also defines
    more concrete concepts, such as **layered architecture**, which we will look at
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with layered architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start to define the conceptual model around our application, it's natural
    to wonder where this model practically fits in our implementation and how to keep
    it pure, regardless of the technology we are using. Think about persistence (the
    database), the **User Interface** (**UI**), and such. Those technologies probably
    have constructs that differ from our model. They might not even be object-oriented
    at all. And for sure, we don't want a change driven by technological reasons (such
    as the optimization of a query or a change in the UI) to affect our domain model.
    DDD tackles this concept directly by suggesting a layered architecture approach.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the idea is to partition the application code into different layers, loosely
    coupled to each other. Then, you implement your domain model into one of those
    layers, encapsulating the technological details in the other layers, each one
    with well-defined responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple and common example of this is with the four layers divided, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.01_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Layered architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the layered architecture is divided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation Layer**: This layer includes all of the code required to present
    and collect the data for users. Additionally, this could include machine-to-machine
    interactions (such as in API calls).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Layer**: This layer is similar to what''s implemented in the
    **Backends for Frontends** pattern (we''ll cover this in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141),
    *Exploring Essential Java Architectural Patterns*). Essentially, this layer is
    a proxy, stateless and without business logic, which simply coordinates the interactions
    between the presentation layer and the rest of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application layer can store session data and perform basic orchestration
    (such as aggregating or ordering calls to the underlying layers). In my opinion,
    this layer can be considered optional in some kinds of applications. The risk
    is that if you avoid it, it will couple the presentation layer tightly to the
    rest of the architecture. On the other hand, if you decide to adopt it, you should
    be mindful of the risk of sneaking in too much business logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain Layer**: This layer is, of course, the core of proper DDD. Here lies
    the whole business model, adherent to what we are representing, in terms of objects,
    their state, and their behavior. The domain layer exposes the functionalities
    of the higher levels and uses the underlying layer for technical matters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure Layer**: This layer is a supporting layer that deals with
    all of the other layers. It can be defined as the glue between the layers themselves
    and the technological layers providing functionalities. Here, a classic feature
    is persistence—objects in the domain layer use features exposed by the infrastructure
    layer, which deals with the database (or other persistent technology) using its
    native protocols and libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This organization might look familiar to you, as it's described in various forms
    and variants in the software area (you might find some similarities with the **Model-View-Controller**
    pattern, which we will examine in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141),
    *Exploring Essential Java Architectural Patterns*). However, do take into account
    that this is mostly a way to nicely group responsibilities. It doesn't necessarily
    mean that each layer should be deployed on its own, as a separate process or artifact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having discussed layered architecture, let''s focus on the heart of DDD: the
    **Domain Model** and its parts.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the domain model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Domain Model** is an elegant way to represent reality and implement it
    in an object-oriented way.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, you can consider the domain model as the opposite of the anemic
    model that we looked at earlier. In the anemic model, the objects simply include
    data and very limited (or even absent) behavior. The domain model of DDD stresses
    the expressiveness of objects and their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, the domain model is simply the concept of comprehending the data
    and behavior of an application. DDD implements this idea by defining the elements
    detailed in the following sections, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The domain model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.02_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – The domain model
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss each of the sections next.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **entity** is a core concept of the domain model. Essentially, it is related
    to modeling objects that have an identity and a history throughout the life cycle
    of our use case. The keyword for defining an entity is **identity**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an object in our use case has a strong identity concept, it will probably
    map with entities. A classic example is a person: in many use cases (including
    the mobile payments example that we are carrying throughout this book), a person''s
    identity is strongly defined, regardless of the values contained in its representing
    objects. In other words, if I have a person object, made up of the classic name,
    surname, and other details, having two objects with the same name and surname
    does not necessarily mean I am referring to the same person.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, I often resort to specific identifying fields (such as a tax code or
    something specific to my application domain—perhaps an account number) to distinguish
    a person object from another one. Moreover, the identity concept will still be
    valid even if the object is persisted (and retrieved). In other words, if I persist
    (or passivate) an entity object somewhere (such as in a database), it should be
    clear that it will refer to the same person (in real life) when it's loaded again.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is clear, defining an entity is a cross-cutting concern between a business
    and the developers. It is much more than simply identifying a unique field distinguishing
    objects from one another. Consider bank accounts: they are usually identified
    by a standard code that is internationally recognized, at the very least, across
    Europe (IBAN code). However, you might find that a bank account changes the associated
    IBAN code (such as when a merger between different banks occurs). In this case,
    *do the two IBAN codes refer to the same account?* *Will the old account disappear
    and be replaced by a new one?* *Should I instead use a third identifier (such
    as a UUID) to bridge between the two entities and bypass the problem?*'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the answer is that it depends. In this scenario, it depends on the
    domain around which your use case is modeled. The identity concept can also be
    different in the same application (in an extended way). Ultimately, an entity
    object is very much related to the point of view you are considering. However,
    for sure, it needs to be an object with a very well-defined identity, regardless
    of the value of its attributes, which links us to a different kind of object—**value
    objects**.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conceptually, value objects complement entity objects. Simply put, in a value
    object, the data inside the fields of the object is more important than the object's
    identity. Value objects simply transport information, and they can be shared,
    copied, and reused with ease. A typical example of a value object is an address
    (such as a city, street name, or zip code). It doesn't matter what the identity
    of each one is; what does matter is the data inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value objects should be immutable. Because they are immutable, they are simpler
    to use. One common example is multithreading: multiple threads can access the
    same object instance concurrently, and there is no need for locks, nor any risk
    of inconsistent value (as the value cannot be changed). It''s the same with passing
    object instances to methods: you can be sure that whatever happens, the value
    of the object cannot be changed. Essentially, with immutable objects, the life
    cycle is just easier to manage.'
  prefs: []
  type: TYPE_NORMAL
- en: Value objects are usually lighter and safer to manage than entity objects. Additionally,
    they can be part of an entity, that is, our person entity might have a link to
    an address value object. However, you should balance the usage of entities and
    value objects. If you only resort to value objects, you will probably fall into
    an anemic domain. There is still an important thing to discuss regarding object
    content, that is, *where can we put the behavior that doesn't belong to either
    entities or value objects?* The answer is **services**.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, entities and value objects are different in terms of identity.
    Instead, they share the grouping around a logical area, including data and behavior.
    In other words, both entities and value objects contain data (class attributes),
    the methods for manipulating it (getters and setters), and more sophisticated
    behavior (the business logic).
  prefs: []
  type: TYPE_NORMAL
- en: What's missing in this model is the cross-cutting behavior. Indeed, there are
    some actions that don't feel right when placed in a particular object. That's
    because those actions involve more than an object type, or they are simply ambiguous.
    It's important to not force those actions into an unrelated object, as this will
    impact the expressiveness of the model. Let's think about our mobile payment example
    again. *Should we put the peer-to-peer payment functionality in the sender or
    receiver account?*
  prefs: []
  type: TYPE_NORMAL
- en: 'For all of these scenarios, you can define a **service**. A service explicitly
    maps actions that are directly linked to the domain as a whole, rather than to
    a specific object type. In this way, you can nicely group similar actions together
    without polluting entities or value objects with behavior that doesn''t belong
    there. It''s all about keeping the domain model rationally organized, which is
    also the goal of the next concept: the **aggregate**.'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned the concept of **aggregates** in [*Chapter 2*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034),
    *Software Requirements – Collecting, Documenting, Managing*, when discussing event
    storming. It's worth saying that the whole idea of event storming is strictly
    related to DDD and one of the ways to put DDD into practice.
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to the concept of aggregates; it's probably one of the most widely
    known ideas of DDD, and it's also widely used outside of DDD. Put simply, aggregates
    can be seen as transactional boundaries. The basic idea is to group a set of objects
    (that is, entities and/or value objects) by data changes. The objects in an aggregate
    are considered as a whole when it comes to changes to their internal status.
  prefs: []
  type: TYPE_NORMAL
- en: An aggregate has an entry point object, called a **root entity**. Any change
    to any object part of the aggregate must be carried out through the root entity,
    which will then perform changes on the linked entities. That's from a technical
    point of view rather than a domain model point of view. What you are doing is
    invoking operations (or, even better, actions that are as meaningful in the real
    world as in the domain model) in the root entity.
  prefs: []
  type: TYPE_NORMAL
- en: This will also mean changing the linked objects under the hood. However, this
    is an implementation detail. From a logical standpoint, all of the interactions
    with objects in the aggregate are mediated by the root entity. For this reason,
    the aggregate is a core concept in DDD. It strictly maps the consistency of the
    model and can be easily translated into technical concepts such as database transactions.
    Aggregates can then be seen as a sort of **super object** made by the coordination
    of different objects. As such, the construction of an aggregate can become complex.
    For this reason, DDD introduces the **Factory pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Glancing at DDD patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDD encompasses some patterns to provide support functionalities for the domain
    model, such as building and managing objects (such as entities and value objects).
    The factory pattern is the first pattern that we will look at.
  prefs: []
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **factory** pattern is not a new concept. You can refer to the *Design Patterns*
    book by the Gang of Four, where this has been widely explained. Simply put, if
    you want to programmatically control the creation of an object (or a set of objects
    such as an aggregate), and not rely on the logic of a constructor, you can use
    the factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Factory is particularly useful to instantiate an aggregate. By invoking the
    factory pattern on the root element, you will coordinate the creation of the root
    itself and all of the other objects linked to the root (entities and value objects).
    Additionally, you can enforce transactionality on the creation of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: If the creation of one of the objects fails, then you might want to abort the
    creation of the whole aggregate. The factory pattern can also be used to recreate
    objects from the database. In this scenario, rather than an instantiation from
    scratch, it's a retrieval of the existing root entity (and the linked subobjects).
    That's fine for addressing the retrieval of a known object (given its identity),
    *but how do you provide different kinds of lookups?* DDD suggests the usage of
    the **Repository pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **repository**, in the DDD world, is a registry that is used to keep references
    to objects already instantiated (or persisted on a database). Simply put, a repository
    can be used to add, remove, and find objects. When used to find objects, typically,
    a repository acts as a bridge between the domain and the infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: It helps to decouple the features and hide the implementation details of the
    persistence layer. You can retrieve objects using complex or vendor-specific queries
    in the infrastructure layer, and this is wrapped by an operation in the repository.
    It might even be that the infrastructure layer retrieves objects in different
    ways, such as invoking external web services rather than a database. Nothing will
    change from a repository point of view. The services exposed by the repository
    must have an explicit domain meaning, whereas the internal implementation might
    appear closer to the infrastructure logic.
  prefs: []
  type: TYPE_NORMAL
- en: So far, in all of the concepts that we have examined, we have implicitly assumed
    that everything falls under one single domain model. Now, we will learn how to
    make different domains interact with each other by using the concept of a **Bounded
    Context**.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common to identify a domain model using one application. That's a hard
    way to delimit the model boundaries. However, that's not always the case. When
    dealing with large applications, it could be that different models need to coexist.
    This is because a unified model is impractical (that is, too big or too complex),
    or because of the model's conflict (that is, an object has different meanings,
    depending on the point of view and the use cases touching it).
  prefs: []
  type: TYPE_NORMAL
- en: In those scenarios, you might need to define a border around each domain model.
    A bounded context, then, is the area in which ubiquitous language is valid. If
    a bounded context can be seen as a country, with defined borders, ubiquitous language
    is the official (and only) language spoken of that country.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a bounded context belongs to one team, and it has some well-defined
    coordinates, such as a portion of the code base and other subsets of related technologies
    (such as a defined set of tables of the database). Two different bounded contexts
    cannot share objects, nor call arbitrary methods of each other. The communication
    must follow well-defined interfaces. In order to support the cooperation between
    two different bounded contexts, a context map can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A context map is a way to translate, when possible, concepts from one bounded
    context to another. There are some patterns suggested by DDD to realize context
    maps. These patterns include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared kernel**: This is when two bounded contexts share a subset of the
    domain model. While this technique is easy and intuitive, it can be hard to maintain,
    since the two teams managing the different bounded contexts must agree on any
    changes, and in any case, the risk of breaking functionalities in the other context
    is always present, so every change must be thoroughly tested (automatic is better).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer supplier**: This is similar, in a way, to the shared kernel approach,
    but the relationship here is asymmetrical. One of the two bounded contexts (the
    supplier) will own the interface, developing and maintaining the features, while
    the customer will simply ask for what is needed. This simplifies the synchronization
    a bit between the two teams. However, it can still create issues when priorities
    and milestones start to clash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conformity**: This shares the customer-supplier type of relationship. The
    difference here is that the customer domain model completely adopts and imports
    a subset of the supplier domain model, as it did in the shared kernel approach.
    However, unlike shared kernel, the relationship stays asymmetric. This means that
    the customer cannot change (or ask for changes in) the shared model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anti-corruption layer**: This is a different approach. In this case, there
    is a translator layer between the two domain objects. This layer acts as a demilitarized
    zone, preventing objects and behaviors from sneaking from one bounded context
    to another. This approach is commonly used when dealing with legacy applications,
    more than when two bounded contexts belong to the same application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth noting that a proper DDD implementation is not easy to follow. There
    are several common errors that could slip into a DDD architectural design. The
    first and most common is the aforementioned anemic domain model, which is the
    most important reason why you would want to adopt something like DDD. However,
    it's also common to have some technology considerations slip into the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: That's particularly true when it comes to the **persistent layer**. It is a
    common practice to design the domain in a way that mimics the database tables
    and relationships (in this case, we are using a relational database as a persistent
    backend). Last but not least, one common error is to design the domain model without
    engaging with domain experts.
  prefs: []
  type: TYPE_NORMAL
- en: We could be tempted to design everything for the IT department, thinking we
    have a proper understanding of the world we would like to represent. Even if this
    is partially true, it's still worthwhile engaging with business experts, to better
    discuss the business jargon (please refer to the *Understanding ubiquitous language*
    section) and rely on their experience of the specific domain model.
  prefs: []
  type: TYPE_NORMAL
- en: This section concludes our brief overview of DDD. As we have learned, DDD provides
    elegant ways in which to realize the ideas we have collected in the previous sections
    (including requirements and architectural designs) and put them into code.
  prefs: []
  type: TYPE_NORMAL
- en: This starts with the concept of ubiquitous language, which we discussed at the
    beginning of this section and is one of the big ideas of DDD, allowing common
    ground between all the stakeholders involved in the application development.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we moved on to the core concepts of DDD, such as the application
    *shape* (the layered architecture), the definition of objects and methods (the
    domain model and the encompassed objects), and the recommended practices (patterns)
    regarding how to address common concerns. A dedicated mention is needed for the
    concept of bounded contexts, which is a way to structure big applications into
    more than one *self-contained* model.
  prefs: []
  type: TYPE_NORMAL
- en: As we will learn in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, DDD has some common ideas with microservices
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at another common practice to drive the implementation
    of our design ideas—TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Test Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is a development technique based on a simple idea, that is, no code should
    exist without test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: In order to pursue this goal, TDD inverts our point of view. Instead of developing
    code, and then writing a unit test to cover its testing, you should start writing
    a test case. Of course, initially, the test case would intentionally fail while
    invocating empty or incomplete functions. However, you will have a clear goal,
    that is, your piece of code is complete when all tests are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the end, you clearly define the boundaries of your software and
    the extent of its functions. Then, you run the tests, which will all fail. You
    keep developing the features, piece after piece, until all of the tests are satisfied.
    Finally, you move to the next piece of code (or class or package)—it's that simple.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this approach doesn't necessarily guarantee any particular quality
    or elegance in your code. Having a test pass does not imply that you are using
    good patterns or efficient solutions. In theory, you might as well simply hardcode
    the expected results to get a green light.
  prefs: []
  type: TYPE_NORMAL
- en: However, this technique will have a very useful byproduct, that is, you can't
    forget (or purposefully avoid) to prove/test your code using test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, there are several factors to take into account. First of all, some features
    might require external systems to work. You can test the interaction of such systems,
    simulating them with mocks, but of course, this will mean more code to write,
    more components (the mocks themselves), and a further degree of approximation
    (meaning that your test will be less representative of reality). Following this,
    you might need to test things that are less easy to automate, such as UIs and
    interactions with devices (for example, mobile devices). Yes, there are a number
    of solutions for this (such as automating browser navigation), but this will complicate
    things.
  prefs: []
  type: TYPE_NORMAL
- en: Let me highlight that, even if this will require a significant amount of effort,
    tests cannot be ditched. Testability is a crucial requirement, and it might also
    be a drive to rearchitect your code base, increasing modularity and simplifying
    it, in order to improve testability.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you might have dependencies between the features. This means coordinating
    tests or, worse, having test results depend on the order in which they are running.
    Of course, this is not easy to maintain and, in general, is not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: In this specific case, you might want to properly structure your tests, in order
    to provide adequate setup and teardown phases, making everything simpler and reproducible
    and greatly increasing the quality of what you are testing. Then, you have to
    think about the granularity of the tests. It can be tempting to create one generic
    test and slip in as many hidden features as you can. On the other hand, if your
    tests are simply unit tests, covering every sub-function, you'll need to aggregate
    them in a meaningful way, in order to track down the advancements in implementing
    the features. In other words, shifting your point of view away from testing specific
    code sections toward testing application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This is the idea behind BDD.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Behavior Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BDD is a technique that extends the TDD approach while also using some DDD concepts.
    In particular, the workflow is the same as TDD, that is, write a test, run it
    (initially, it will fail), and implement the feature until the test succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: What changes is how the test is written. Instead of focusing on single functions
    (or, even better, relying on the developer to pick the right granularity), BDD
    defines the extent of each test a bit better. In particular, as highlighted in
    the name of the methodology, BDD tests are focused on the expected behavior, that
    is, the functionality implemented by each use case.
  prefs: []
  type: TYPE_NORMAL
- en: In this sense, it is an explicit suggestion to keep high-level functionalities,
    rather than method-by-method unit tests. BDD is also linked to DDD concepts. In
    particular, it is recommended that you use ubiquitous language as a way to specify
    each behavior. In this way, you have an explicit mapping between a business use
    case, expressed with ubiquitous language, translated into an automatic test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'BDD describes a way to define behaviors. In practice, each behavior is defined
    as a user story, with a structure given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**As a**: This is a person or a role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I want**: This is a specific functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**So that**: This is when we can get some benefits from using that functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provided that a number of scenarios are associated with the user story, each
    scenario is, essentially, an acceptance criterion, which can be easily translated
    into automated use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: This is used for one or more initial conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: This is used for when something happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then**: This is used for when one or more results are expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure is very self-explanatory. By using a similar template, and sticking
    to ubiquitous language, you will have a straightforward way in which to define
    use cases. It is a way that is meaningful for non-technical people and can be
    easily translated to automated use cases by technical people.
  prefs: []
  type: TYPE_NORMAL
- en: Walking backward, you implement code that will gradually cover the test cases,
    mapping to a behavior specification that will give direct feedback to the business
    on which use cases are complete.
  prefs: []
  type: TYPE_NORMAL
- en: This approach offers a structured way to understand what we are implementing
    and possibly select and prioritize the user story to approach as a development
    team. This is also the focus of the practice that we will look at in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing DDD, TDD, and BDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have rapidly discussed three different "Something-Driven Development"
    techniques. It must be clear that such practices should not necessarily be seen
    as alternatives, but they might have some complementarity.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, DDD relates more to the modeling of the application domain. In
    this sense, it can be observed from a more architectural point of view, defining
    how our application is modularized, the different layers, and even how different
    parts of our broader application (or, if you wish, different teams) should cooperate.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have designed such layers and components, both TDD and BDD can be used
    as a way to drive our day-to-day development, ensuring we have the right testability
    and feature coverage requested within our code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, DDD is not a requirement for TDD or BDD, which can be seen
    as a simple technique that is also applicable to smaller applications, or to software
    architectures defined with approaches alternative to DDD. As you will often find
    in this book, those concepts can be viewed as tools, briefly introduced to give
    you an idea of their potentiality. It's up to you to then take what's needed for
    your specific project and combine it in a useful way.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about user story mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**User story mapping** is a way to put user stories into context, identify
    what it takes to implement them, and plan accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn what a user story is and how it can be used as
    a planning method, in order to choose what features to include in each release,
    following a meaningful pace.
  prefs: []
  type: TYPE_NORMAL
- en: The user story is the same concept that we saw as part of BDD. So, it describes
    a feature from the point of view of a specific persona (**As a**...), the functionalities
    required (**I want to**...), and the expected outcome (**So that**...).
  prefs: []
  type: TYPE_NORMAL
- en: As you might observe, all pieces in the puzzle of those seemingly unrelated
    practices eventually start to match. User story mapping is often described as
    a **product backlog** on steroids.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss product backlogs in the next chapter. However, for now, consider
    them as lists of features to implement. Features are added as long as analysis
    occurs (or new requirements arise). These are then prioritized and picked by the
    development team to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: User story mapping extends this approach by giving more dimensions to the product
    backlog, enriching the information related to each feature, and linking it to
    a broader vision of the product. User stories stay on top of the mapping. They
    describe the high-level features that a system should provide. User stories are
    organized in a horizontal line and ordered by both importance and the temporal
    sequence in which they happen, all from the user's point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each user story, a list of tasks is provided. Essentially, these are the
    sub-features (also known as **activities**) that each user story encompasses.
    So, we are detailing each feature, but not yet coming to a level of detail that
    can be directly mapped into software (at least, not easily). Each task is then
    attached to a list of subtasks (or task details), which are easier to map to software
    features. This is what user story mapping looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – User story mapping](img/Figure_4.03_B16354.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – User story mapping
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing about this model is that you will not have to prioritize
    the tasks. You just need everything included there (sooner or later); however,
    you can prioritize the subtasks, gradually improving the completeness of each
    task, release after release.
  prefs: []
  type: TYPE_NORMAL
- en: This model has a series of positive outcomes. First of all, as with BDD, you
    have a direct mapping between the subtask the development team is working on and
    the user story (or activity). Essentially, it gives visibility to the business
    regarding the finish line toward which we are rowing. Moreover, an interesting
    practice is applicable to this matrix of tasks and subtasks, namely, **value slicing**.
    This means picking what to implement for each release.
  prefs: []
  type: TYPE_NORMAL
- en: Given that you will have a finite number of resources (such as programmers,
    time, and whatever else is required to implement each subtask), you cannot, of
    course, deliver everything in one release. Well, you could, but it would be risky
    since you would have to wait a long time before receiving feedback and being able
    to test the software. We will elaborate more on the **release early, release often
    approach** (the well-known incremental product releases technique that is widely
    used in **Agile** and **DevOps**) in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, what matters is that it is better to release value incrementally,
    by picking the subtasks that implement, at least partially, one or more tasks
    and then the related user stories. Here is what this would look like compared
    to *Figure 4.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Value slicing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Value slicing
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the approach here is oriented toward an MVP.
  prefs: []
  type: TYPE_NORMAL
- en: The MVP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of MVP deserves some additional explanation. The term was created
    before the user story mapping technique and is an independent idea. It is also
    applicable to products that are different from the software code. The goal of
    the MVP is to maximize the value of the product (in terms of return of investment
    or, trivially, how useful, popular, and beneficial your product will be) while
    minimizing the risks and efforts required to build it. The perfect MVP requires
    a very low level of effort and risk to build, but it can become greatly popular
    and appreciated when used (and, optionally, sold).
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of an MVP is to start getting feedback on the product from potential
    end users (usually, a subset of early adopters). Due to this, the MVP should contain
    a meaningful subset of features: not too many, to avoid wasting effort in case
    the product is not well received by customers, but just enough in order to represent
    what the complete product will be like. Early feedback, in the spirit of Agile
    development methodologies, could also be beneficial if some steering is required
    in the product direction, by stressing more on one aspect or another.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about user story mapping, which is the final technique
    we will explore in this chapter. In the next section, we will examine some examples
    of those approaches, as applied to our mobile payments use case.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As is easy to imagine, a complete and extensive example of DDD, TDD, BDD, and
    user story mapping, applied to our mobile payments case study, could easily take
    more than one book. For this reason, as we mentioned in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065),
    *Common Architecture Design Techniques*, unfortunately, we can only look at some
    highlights of those techniques used in our example. However, in this section,
    I think it is pretty useful to take a look at, even if to just practically visualize
    some concepts that might appear abstract so far.
  prefs: []
  type: TYPE_NORMAL
- en: The mobile payments domain model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065), *Common Architecture
    Design Techniques*, we looked at the basic modeling of mobile payment objects
    based on the UML notation. To elaborate more on this, in DDD, you will mostly
    have the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is an entity. This concept is pretty straightforward, that is, the
    identity is very well defined, and each user has a well-defined life cycle (from
    registration to deletion).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment is an entity, too. Each user will want to keep track of exactly each
    transaction, including the time, the amount, the receiver, and more. It is also
    likely that there will be regulations for you to uniquely identify each payment
    transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we've already mentioned, a peer-to-peer payment is out of place as a method,
    both in the sender and receiver entity. So, it is probably worth modeling a payment
    service that can also work as a bridge toward classical CRUD operations in the
    infrastructure layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the assumption that our application is operating on a global scale, you will
    need to manage transactions in different currencies. `ExchangeRate` is a typical
    example of a value object. It is immutable and composed of currency symbols and
    a number representing the exchange rate. It is a disposable object and can be
    easily shared between different payments, as no identity (nor state) is considered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have defined (a very small subset of) the domain model of mobile payments,
    we are going to look at the layered architecture of this application.
  prefs: []
  type: TYPE_NORMAL
- en: The layered architecture of mobile payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember the diagrams designed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*, and the C4 model
    drafted in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065), *Common
    Architecture Design Techniques*, you are already familiar with some of the technical
    components that implement our mobile payment architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'There, the mapping between components was pretty much coarse-grained. This
    is because you would associate the mobile application with the **Presentation
    Layer**, the business logic with the **Domain Layer**, and so on. However, with
    DDD, we are progressing further with the analysis of our application. We are going
    one level down toward something similar to the **C4 Container** diagram (please
    refer to *Figure 3.8* in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065),
    *Common Architecture Design Techniques*) but from a different point of view. My
    idea of the layered architecture of our application looks similar to the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The DDD layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.05_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – The DDD layered architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, you might observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the views in the **Presentation Layer** are a subset of the mobile application
    functionalities. You will probably have more functionalities in the real world.
    However, it's interesting to observe how some concepts of the **Domain Layer**
    (hence, the ubiquitous language) are echoed here. Yet, this is a pretty technical
    layer, so it does not strictly observe the ubiquitous language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Application Layer** is a support area, decoupling the needs of the frontend
    with the services provided by the domain model in the **Domain Layer**. The relationship
    with the **Presentation Layer** is not one-to-one in this case, but that's up
    to you to decide according to your context. Additionally, this layer has a dependency
    on the **Domain Layer**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `ExchangeRate` is not represented).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Infrastructure Layer** is the technological glue, providing services to
    other layers, and abstracting technology-specific details. So, in this case, you
    can see that **UserRepo** will mediate calls to IDM and other systems (for example,
    databases or CRMs), while **TransactionDataAdapter** abstracts calls to databases
    and legacy systems. Consider that in this scenario, there are no direct links
    between the **Presentation Layer** and the **Infrastructure Layer**, as everything
    is proxied by the **Application Layer**. However, that's not a strict requirement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, I will share my views on how BDD could be applied to mobile
    payments.
  prefs: []
  type: TYPE_NORMAL
- en: BDD of mobile payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we detailed in the *Exploring Behavior Driven Development* section, BDD
    starts with a user story. A basic user story for mobile payments could be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Story**: Making a payment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**As a** registered user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I want** to make a payment to another user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**So that** I can transfer money (and benefit from services or goods in exchange
    for that).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might have gathered, this user story implies other user stories (such
    as **Registration of a user** and **Login**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next logical step is to enumerate some scenarios (or acceptance criteria)
    linked to that story:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given** that I am registered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I am logged in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When** I select the payment feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then** I am redirected to the payment view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Given** that I am at the payment view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I am logged in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I enter a valid recipient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** I enter a valid amount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When** I click on the pay button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then** a payment transaction is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And** a notification is sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As demonstrated in the preceding examples, each user story usually corresponds
    to more than one acceptance criteria, which is then codified as a set of (possibly
    automated) test cases. Following this, you can start to iteratively implement
    features until each acceptance criteria is met, ultimately fully covering the
    related user story. Now, let's expand on this user story by means of user story
    mapping.
  prefs: []
  type: TYPE_NORMAL
- en: User story mapping of mobile payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Learning about user story mapping* section, we discovered that the top-level
    element is the user story. So, we will start with the stories that we have just
    observed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take into account that while it can be considered as a task attached to each
    user story, the acceptance criterion is usually considered more like an orthogonal
    concept, to validate the implementation of each story. Usually, the attached tasks
    are simply more detailed features composing the story itself. Let''s view an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – User story mapping example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.06_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – User story mapping example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding (simplified) example, for each activity (mapping
    to a user story, as per the *BDD of mobile payments* section) there are one or
    more related tasks. Activities and tasks are ordered following a time (and priority)
    direction. Then, each task is attached to a list of subtasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a logical next step to plan how to group a set of subtasks as a release,
    progressively delivering value to the final customer (think about MVPs). We''ve
    described this approach as value slicing, which appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Value slicing example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.07_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Value slicing example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, we've represented a simple slicing
    of features as two releases. In the first release (**Release 1**), you will provide
    the bare minimum functionalities. It will be possible to create users, to **Sign
    in** (but not using a social account), and to **Make a payment** (but without
    receiving a notification).
  prefs: []
  type: TYPE_NORMAL
- en: There will be no functionalities regarding lost passwords and payment disputes.
    In the second release (**Release 2**), no new features will be added to the registration
    activity, the **Lost password** task will be completed (being made of just one
    subtask), and the whole **Dispute a payment** task will be completed (in both
    its two subtasks).
  prefs: []
  type: TYPE_NORMAL
- en: All of the other subtasks are part of the backlog, meaning they are yet to be
    planned (and more subtasks can then be added). Of course, each line representing
    a release is drawn together with business/product owners, which will define the
    priority and helps to aggregate subtasks in a meaningful way. With value slicing,
    we have completed the objectives of this chapter. Let's look at a quick recap
    of all the notions we have encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a set of techniques to start transforming architecture
    principles into working software components. DDD is a pretty complete framework
    that is used to define objects and the way they interact with each other. It puts
    a number of clever ideas down on paper, such as layered architectures, patterns,
    and bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we moved on to Test Driven Design and BDD. You now understand
    specific ways of structuring the development of new code and mapping it to business
    features. Finally, we looked at user story mapping as a way to pick functionalities
    to implement and link them to tasks and activities.
  prefs: []
  type: TYPE_NORMAL
- en: All of these techniques will be better framed in the next chapter, where we
    will discuss **Agile** methodologies, which include some of the practices that
    we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Anemic Domain Model* by Martin Fowler ([https://martinfowler.com/bliki/AnemicDomainModel.html](https://martinfowler.com/bliki/AnemicDomainModel.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans ([https://www.domainlanguage.com/](https://www.domainlanguage.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design Quickly*, by Abel Avram and Floyd Marinescu, published
    by C4Media (2007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10 Common DDD Mistakes to Avoid* by Jan Stenberg ([https://www.infoq.com/news/2015/07/ddd-mistakes/](https://www.infoq.com/news/2015/07/ddd-mistakes/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introducing BDD* by Dan North ([https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BDD in Action: Behavior-Driven Development for the Whole Software Lifecycle*,
    by John Ferguson Smart, published by Manning Publications (2004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*User Story Mapping & Value Slicing* by Matt Takane and Ryan DeBeasi ([https://openpracticelibrary.com/practice/user-story-mapping/](https://openpracticelibrary.com/practice/user-story-mapping/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Top 5 Biggest Challenges when Building an MVP and how to Avoid Them* by Ilya
    Matanov ([https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757](https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The New User Story Backlog is a Map* by Jeff Patton ([https://www.jpattonassociates.com/the-new-backlog/](https://www.jpattonassociates.com/the-new-backlog/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
