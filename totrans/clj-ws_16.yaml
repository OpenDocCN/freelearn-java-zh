- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is included to assist the students to perform the activities present
    in the book. It includes detailed steps that are to be performed by the students
    to complete and achieve the objectives of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Hello REPL!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 1.01: Performing Basic Operations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the REPL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Print the message `"I am not afraid of parentheses"` to motivate yourself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add 1, 2, and 3 and multiply the result by 10 minus 3, which corresponds to
    the following `infix` notation: (1 + 2 + 3) * (10 - 3):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the message `"Well done!"` to congratulate yourself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exit the REPL by pressing *Ctrl* + *D* or typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By completing this activity, you have written code that prints a message to
    the standard output. You have also performed some mathematical operations using
    the *prefix* notation and nested expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.02: Predicting the Atmospheric Carbon Dioxide Level'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite editor and a REPL window next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your editor, define two constants, `base-co2` and `base-year`, with the
    values 382 and 2006, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In your editor, write the code to define the `co2-estimate` function without
    forgetting to document it with the `doc-string` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may be tempted to write the function body in a single line, but nesting
    a lot of function calls decreases the readability of the code. It is also easier
    to reason about each step of the process by decomposing them in a `let` block.
    Write the body of the function using `let` to define the local binding, `year-diff`,
    which is the subtraction of 2006 from the `year` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your function by evaluating `(co2-estimate 2050)`. You should get `470`
    as the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look up the documentation of your function with `doc` and make sure that it
    has been defined correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this activity, we calculated the estimated level of CO2 parts per million
    for a given year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.03: The meditate Function v2.0'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite editor and a REPL window next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your editor, define a function with the name `meditate`, taking two arguments,
    `calmness-level` and `s`, without forgetting to write its documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the function body, start by writing an expression that prints the string,
    "`Clojure Meditate v2.0`":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Following the specification, write the first condition to test whether the calmness
    level is strictly inferior to 5\. Write the first branch of the conditional expression
    (the "then").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the second condition, which should be nested in the second branch of the
    first condition (the "else").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the third condition, which should be nested in the second branch of the
    second condition. It will check that `calmness-level` is exactly 10 and return
    the reverse of the `s` string when that is the case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your function by passing a string with different levels of calmness. The
    output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have been using the `and` operator to find out whether a number was between
    two other numbers, rewrite your function to remove it and only use the `<=` operator.
    Remember that `<=` can take more than two arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look up the `cond` operator in the documentation and rewrite your function
    to replace the nested conditions with `cond`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By completing this activity, you have written a documented function that takes
    multiple parameters, prints a message, and conditionally returns a transformation
    of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Data Types and Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 2.01: Creating a Simple In-Memory Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the helper functions. You can get the Hash Map by executing the
    `read-db` function with no arguments, and write to the database by executing the
    `write-db` function with a Hash Map as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by creating the `create-table` function. This function should take one
    parameter: the table name. It should add a new key (the table name) at the root
    of our Hash Map database, and the value should be another Hash Map containing
    two entries – an empty vector at the `data` key and an empty Hash Map at the `indexes`
    key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test that your `create-table` function works. The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create the next function: `drop-table`. The function should take one
    parameter as well: the table name. It should remove a table, including all its
    data and indexes from our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test that your `drop-table` function works. The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s move on to the `insert` function. This function should take three parameters:
    `table`, `record`, and `id-key`. The `record` parameter is a Hash Map, and `id-key`
    corresponds to a key in the record map that will be used as a unique index. For
    example, inserting a record in the `fruits` table would look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For now, we will not handle cases where a table does not exist or when an index
    key already exists in a given table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try to use a `let` block to divide the work of the `insert` function into multiple
    steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In a `let` statement, create a binding for the value of the database, retrieved
    with `read-db`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `let` statement, create a second binding for the new value of the
    database (after adding the record in the `data` vector):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `let` statement, retrieve the index at which the record was inserted
    by counting the number of elements in the `data` vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the body of the `let` statement, update the index at `id-key` and write
    the resulting map to the database with `write-db`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that your `insert` function works, try to use it multiple times to
    insert new records. The output should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `select-*` function that will return all the records of a table passed
    as a parameter. Given the three preceding records, the output should be similar
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `select-*-where` function that takes three arguments: `table-name`,
    `field`, and `field-value`. The function should use the index map to retrieve
    the index of the record in the data vector and return the element. Given the three
    preceding records, the output should be similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `insert` function to reject any index duplicate. When a record with
    `id-key` already exists in the `indexes` map, we should not modify the database
    and print an error message to the user. The output should be similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final output should be similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this activity, we have used our new knowledge about reading and updating
    both simple and deeply nested data structures to implement a simple in-memory
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Functions in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 3.01: Building a Distance and Cost Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining the `walking-speed` and `driving-speed` constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two other constants representing two locations with the coordinates
    `:lat` and `:lon`. You can use the previous example with Paris and Bordeaux or
    look up your own. You will be using them to test your distance and itinerary functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the distance function. It should take two parameters representing the
    two locations for which we need to calculate the distance. You can use a combination
    of sequential and associative destructuring right in the function parameters to
    disassemble the latitude and longitude from both locations. You can decompose
    the steps of the calculation in a `let` expression and use the `Math/cos` function
    to calculate the cosine and `Math/sqrt` to calculate the square root of a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a multimethod called `itinerary`. It will offer the flexibility of adding
    more types of transport in the future. It should use the value at `:transport`
    as a dispatch *value*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the itinerary function for the `:walking` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from` and
    `:to` keys from the `HashMap` parameter. You can use a `let` expression to decompose
    the calculations of the distance and duration. The distance should simply use
    the `distance` function you created before. To calculate the duration, you should
    use the `walking-speed` constant that you defined in *Step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `:driving` itinerary function, you could use a *dispatch table* that
    contains the vehicle associated with their costing function. Create a `vehicle-cost-fns`
    dispatch table. It should be a `HashMap` with the keys being the types of vehicles,
    and the values being cost calculation functions based on the distance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the itinerary function for the `:driving` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from`,
    `:to`, and `:vehicle` keys from the `HashMap` parameter. The driving distance
    and duration can be calculated similarly to the walking distance and duration.
    The cost can be calculated by retrieving the `cost` function from the dispatch
    table using the `:vehicle` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now try the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this activity, we've put in practice the destructuring and multimethod techniques
    that we have learned in this chapter by building a distance and cost calculator
    between two locations. In the future, you could imagine putting this code behind
    a web server and finishing building a fully blown itinerary calculation app!
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Mapping and Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 4.01: Using map and filter to Report Summary Information'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, set up a simple framework using the `->>` threading macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This defines the fundamental structure of our function, which we can sum up
    as follows: start with `users` and send it through a series of transformations.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first of these transformations will be to filter out all the users that
    don''t have the status we are looking for. We''ll use `filter` for that, naturally,
    and we''ll include a predicate that compares the `:status` field from each user
    with the `status` parameter that was passed into the function: `(filter #(= (:status
    %) status))`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that, our function now looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We know that we have the correct set of users. Now, we need to extract the
    field we''re interested in. The `field` parameter is a keyword, so we can use
    it as a function to extract the necessary data as we map over each user, like
    this: `(map field)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, our function looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the final step, we use `(apply max)` to find the needle in this haystack:
    the maximum value corresponding to `field`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete function looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activity 4.02: Arbitrary Tennis Rivalries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will be to set up the function and the `with-open` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside that, set up a `let` binding. The first binding will be to the `lazy-seq`
    returned by `csv/read-csv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `->>` chain, we also want to keep only the matches where our players
    are actually against each other. Like we did previously, we''ll use the set pattern
    to see whether the set "winner and loser in the match" is equal to the set of
    the two players we are looking for. We''ll also use `map` and `select-keys` to
    only keep the fields we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can already start gathering some data here, so we''ll make some more bindings
    in the same `let` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are simple filter calls that give us two lists of victories.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have all the bindings we need, so now it''s time to do some work with them
    inside the scope of the `let` statement. Everything can happen inside the map
    that we are going to return. Now that we have our three sequences, that is, `player-1-victories`,
    `player-2-victories`, and the overall `rivalry-seq`, it becomes easier to grab
    some of our summary data with calls to `count` and `first`. We''ll also write
    one more call to `filter` that inspects the score difference in the rivalry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may be surprised that we did not need to call `doall` in this solution.
    This is because `rivalry-seq` is fully realized by the call to `count`. The final
    code can be found at [https://packt.live/2Ri3904](https://packt.live/2Ri3904).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By completing this activity, we have produced the summary data for any two players
    who have actually played against each other.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Many to One: Reducing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 5.01: Calculating Elo Ratings for Tennis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the minimal `deps.edn` file you''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the corresponding namespace declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the overall structure of your function, we will follow the same patterns
    we''ve used so far: a `with-open` macro with some pre-processing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to outline the call to `reduce`. The `:match-count`, `:predictable-match-count`,
    and `:correct-predictions` fields are just counters that will need to be updated
    depending on whether each match is correctly predicted. The `:players` map will
    contain a key for each player; the values will be their Elo ratings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From here, it is just a question of applying logic that we''ve already developed.
    First, we extract and calculate, and then we update the accumulator. The body
    of the reducing function starts with some `let` bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`winner-rating` and `loser-rating` are extracted from the `:players` map in
    the accumulator. After we make our prediction regarding the match winner by calling
    `match-probability`, the remainder of the operations simply apply the consequences
    of whether our prediction was correct.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can finally update the accumulator. The following code goes inside
    the `let` expression above. This is what the reducing function will return. We
    use the `->` macro to thread the existing `acc` through a series of changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the entire function, when we put everything back together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be interesting to experiment with different values of `k` to see whether
    the precision of the predictions can be improved. This is why we keep track of
    `:correction-predictions` and `:predictable-match-count`. There are many other
    kinds of improvements that could be made: modifying the function to run on multiple
    CSV files (if the ratings started at the very beginning of the dataset, in 1877,
    we would expect the quality to improve); perhaps contextually adjusting `k` depending
    on the relative strength of the two players, or based on current winning and losing
    streaks; or attributing bonuses to players who win more in certain locations.
    You now have a framework for experimentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Recursion and Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 6.01: Generating HTML from Clojure Vectors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use `clojure.string` in our solution. It is not strictly necessary,
    but `clojure.string/join` is a very convenient function. Because `clojure.string`
    is a standard Clojure namespace, a `deps.edn` file containing only an empty map
    is sufficient for this activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are the smaller functions that we''ll use later in the main HTML-producing
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first one, `attributes`, takes `map` attribute names and values. We treat
    the map like a sequence and map over the `[key value]` pairs. The keys are Clojure
    keywords, so they need to be converted to strings with the name function. The
    key-value pair becomes a string, `key="value"`. Then, we use `clojure.string/join`
    to combine all the substrings into a single string, making sure that each attribute
    is separated from the others by some whitespace. If the input map, `m`, is empty,
    `clojure.string/join` will return an empty string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next functions are simple formatting tools for building different kinds
    of tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next set of helper functions are predicates that we will need since the
    main recursive function walks the tree of nested vectors. They all take the same
    kind of argument: the tree or subtree that we are analyzing.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to be able to distinguish between input vectors that have attributes
    and those that don''t. We do this by looking at the type of the second item in
    the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second item of a simple element like `[:h1 "Hello world"]` is a string,
    so `has-attributes?` would return `nil`. If the second item was another vector,
    the result would be the same. On `[:h1 {:class "title"} "Hello Universe"]`, `has-attributes?`
    would return `true`. Because `(map? nil)` returns `nil`, we don''t need to have
    a special case for single-item vectors. `(has-attributes? [:br])` simply returns
    `nil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `singleton?` function tests whether an element is a member of a small set
    of HTML elements that are not allowed to have closing tags. Naturally, we use
    a Clojure set to test this. First, though, we make sure that the current item
    is a vector because, sometimes, the current item will be a string (such as the
    second item in `[:h1 "Hello world"]`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These two predicates follow the same basic logic but build on the function we've
    already defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now it's time for the main recursive function. Like the predicates, it will
    take a tree as an argument, which can, of course, be the entire vector tree or
    a subtree. Like most recursive functions, there is a `cond` with several branches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the basic structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go through the various conditions one by one, before putting them all
    back together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `tree` is not truthy, it means there is nothing we can do, so we simply
    return `nil`. For the rest of the inputs, we won''t have to worry about getting
    `nil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `tree` is a string, we don''t want to transform it. It can be integrated
    into the output string as is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is why we needed the `singleton-with-attrs?` predicate. Now, all we need
    to do is match the singleton tree with the corresponding formatting function.
    Because singleton elements don''t have any content, no recursion is possible here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a simpler version of the previous condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we finally get to do some recursion! If an element has attributes, start
    making a string out of a list. That''s what `(apply str…)` is for. We''ll use
    `concat` to prepend the opening tag and the attributes, now formatted as a string,
    to a list that will be produced by `next` calls to `my-hiccup`, which will happen
    with the call to `map`. And, at the end of the list, we have the formatted closing
    tag. This is the classic case where we cannot use `recur:` the call to `(apply
    str (concat…))` cannot complete until all the underlying calls to `my-hiccup`
    have completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last condition follows the same pattern as the previous pattern. We could
    have made this a default condition instead of testing with `vector?`. If our input
    vector tree is malformed, the error indicating no matching case should put us
    on the right track for debugging. In production code, we could add an `:otherwise`
    condition that would throw an exception. You'll learn about exceptions in *Chapter
    9*, *Host Platform Interoperability with Java and JavaScript*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we reassemble `my-hiccup`, it looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you try the `my-hiccup` function in the REPL, you should be able to produce
    the string for a complete HTML page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.10: Final output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.10: Final output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to try different inputs and page structures. You can even copy the
    output string into a text file to load into your browser.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, we are now able to take any vector written with
    this syntax, including an arbitrary number of descendant vectors, and produce
    a single string containing correctly structured HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Recursion II: Lazy Sequences'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 7.01: Historical, Player-Centric Elo'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your project, which should be based on the code written for the last
    exercises in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solution follows the pattern established with `take-matches`. Let's start
    with the parameters. We need to define separate behaviors for matches played by
    the "focus player" and matches played between other players. The first thing we
    need is, of course, a way to identify the player, so we'll add a `player-slug`
    argument. This wasn't necessary in `take-matches` because there we treated all
    the matches the same, regardless of who played in them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `take-matches`, we had a `limit` argument to control how deeply we walked
    the tree. In this case, we need two different parameters, which we will call `focus-depth`
    and `opponent-depth`. Together, that gives us the following parameters for our
    new `focus-history` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `tree` parameter is, of course, the result of a call to `match-tree-by-player`,
    as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, the `f` argument will work the same way as in `take-matches`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Controlling the function''s movement through the tree will end up being a challenge.
    As usual, we will set up a `cond` form that will determine how the function reacts
    to the incoming data. The first two conditions are quite simple, and in fact,
    are nearly identical to the code in `take-matches`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only change from `take-matches` is that now we are using `focus-depth` instead
    of `limit`. The fact that we are using `focus-depth` here is important nonetheless.
    We are only concerned about `focus-depth` at this stage, and not `opponent-depth`,
    because if `focus-depth` is zero or one, the entire operation stops and in this
    case we no longer care about `opponent-depth`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final condition is where this function behaves differently from `take-matches`.
    It is also more complex, though perhaps not as much as you might think at first
    glance. To understand this, let''s look at the equivalent part of `take-matches`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we are placing `(f (first tree))` at the head of the current
    lazy seq. As such, we are connecting it onto the rest of the sequence, whose first
    item will be a vector containing the starting point for two more branch lazy seqs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All we need to do here, in order to introduce separate behaviors for the two
    possible cases, is to replace the calls to `take-matches` inside the two-item
    vector. Those two matches are the "parent" matches of the current match; that
    is, they are the matches played by the winner and loser before the current match.
    We need to test first to find which "parent" matches belong to the focus player
    and which belong to an opponent. For the focus player''s previous match, we call
    `focus-history`. For the opponent''s previous match we call `take-matches`. In
    other words, instead of just having two calls to `take-matches`, as above, we
    have two branching conditions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In both of these cases, whether we call `focus-history` or `take-matches`, we
    have to be careful to adjust the `tree` argument and the `focus-depth` arguments
    correctly. Remember that `tree` is always relative to the current two-item sequence
    composed of a match and a two-item vector, which is why we use `(first (second
    tree))` and `(second (second tree))`, that is, the first and the second of the
    two lazy sequences in the vector. While it would be tempting to assign these to
    `let` bindings to avoid repeating `(second tree)`, it is generally better in these
    cases to avoid "holding onto the head."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the complete function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's worth noting that this function is only slightly more complex than `take-matches`.
    As is often the case with recursive solutions, the code itself is rather simple.
    The difficulty is in choosing the best strategy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the function in action, from start to finish. First, we read in the
    data and generate the ratings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we build the lazy match tree for the player we''re interested in:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now we call our new function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The indentation in the results reveals a tree structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.10: The results of focus-history'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_07_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.10: The results of focus-history'
  prefs: []
  type: TYPE_NORMAL
- en: Matches played by Federer contain deeper sub-trees of the preceding matches.
    The data is ready to be passed to the frontend team, who will translate it into
    a beautiful visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Namespaces, Libraries and Leiningen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 8.01: Altering the Users List in an Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `clojure.string` namespace with `use` and the `:rename` keyword
    for the `replace` and `reverse` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a set of users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the underscore between honorifics and first names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `capitalize` function to capitalize each person''s initials in the
    user group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the user list by using the string''s `replace` and `capitalize` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import only the `print-table` function from the `clojure.pprint` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print a table with users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.23: Printing the table of users'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.23: Printing the table of users'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `clojure.set` namespace, excluding the `join` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and display a set of admins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `subset?` function on two sets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To print the final output, execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.24: Printing the final user table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.24: Printing the final user table'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we worked on two features. With the first feature, we capitalized
    usernames. With the second feature, we used `Clojure.set` functions to check whether
    any users were also admins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.02: Summing Up Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Leiningen application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert string arguments to integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add integers to calculate the sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the result as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.25: Printing the sum'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.25: Printing the sum'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete solution should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: In this activity, we created a new Leiningen project. This application accepted
    parameters from the command line. Numbers input into the command line were summed
    and the result was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.03: Building a Format-Converting Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `project.clj`, add the `cheshire` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to convert from hash to JSON. Inside the core namespace,
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Testing the `generate-json-from-hash` function in the REPL should give us the
    following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.26: Generating JSON from hash'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.26: Generating JSON from hash'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function to convert from JSON to hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Testing `generate-hash-from-json` in the REPL should give us the following
    result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.27: Generating hash from JSON'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.27: Generating hash from JSON'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `expectations` library to the testing profile defined for the project.
    In `project.clj`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `lein-expectations` plugin for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the test for the JSON functions. Inside the `json-parser/test/json_parser/core_test.clj`
    files, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling tests with the `qa` profile should give us the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.28: Executing the test profile'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.28: Executing the test profile'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add `lein-ancient` to user-wide profiles. In `~/.lein/profiles.clj`, add the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Checking for outdated dependencies should show the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.29: Checking for outdated dependencies'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.29: Checking for outdated dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we have created an application that performs a conversion
    from JSON format to Clojure data and back. In order to make sure that our application
    runs correctly, we created a testing profile where we included dependencies on
    the `expectations` library and a plugin. To make sure that the libraries in all
    our projects are not outdated, we included the `lein-ancient` plugin in our user-wide
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Host Platform Interoperability with Java and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 9.01: Book-Ordering Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the necessary namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a map to hold books by year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable for a file that stores orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the initial menu with options to order a book and list orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.53: Output for the initial menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_53.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.53: Output for the initial menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a menu to display books by year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.54: Output for available books by the year'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_54.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.54: Output for available books by the year'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the application''s `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to save data to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to save an order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to calculate the price of a book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to display an order confirmation message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.55: Order confirmation message'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_55.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.55: Order confirmation message'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function to display the bought order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.56: Displaying the purchased order'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_56.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.56: Displaying the purchased order'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function to read a single order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to check whether a file exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to load orders from a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a submenu to order a book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.57: Submenu for book order'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_57.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.57: Submenu for book order'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function to buy a book by year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.58: Function to buy books by year'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_58.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.58: Function to buy books by year'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function to show orders by year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a submenu to list orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.59: Creating submenu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_59.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.59: Creating submenu'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we created an application for ordering books and displaying
    orders. We used our new knowledge about I/O and Java to complete this activity.
  prefs: []
  type: TYPE_NORMAL
- en: Once you complete the activity, you should have an output similar to the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.60: Initial menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_60.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.60: Initial menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing years:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.61: Listing years'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_61.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.61: Listing years'
  prefs: []
  type: TYPE_NORMAL
- en: 'Books in one year:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.62: Books purchased in 2019'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_62.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.62: Books purchased in 2019'
  prefs: []
  type: TYPE_NORMAL
- en: 'Asking how many books to buy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.63: Asking for the numbers of books to be bought'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_63.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.63: Asking for the numbers of books to be bought'
  prefs: []
  type: TYPE_NORMAL
- en: 'Order confirmation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.64: Order confirmation message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_64.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.64: Order confirmation message'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing purchased books:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.65: Listing purchased books'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_65.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.65: Listing purchased books'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we used our knowledge of Java interoperability to create a
    command-line application. In the next section, we will learn how to use JavaScript
    in ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.02: Creating a Support Desk'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `jayq` and `cuerdas` libraries as dependencies in `project.clj`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `utils` function to filter the issues list by priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `utils` function to get the sorted issues list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `utils` function to get the sort message by issues count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `0` issues, the output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `3` issues, the output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `utils` function to delete issue from a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `utils` function called when sorting is finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add jQuery and jQuery UI to `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `jayq`, `cuerdas`, and `utils` to the core namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the priorities list as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define `app-state` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `counter` Rum component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the issue on `click` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the issue item in the Rum component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.66: Defining an issue item in a Rum component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_66.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.66: Defining an issue item in a Rum component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `reactive` issue items component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the reactive page `content` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the item components sortable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mount the page component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `mount` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `sortable` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The initial issues list will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.67: Initial issue list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_67.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.67: Initial issue list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues list after sorting will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.68: Issue list after sorting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_68.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.68: Issue list after sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues list after resolving three issues will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.69: Issue list after resolving issues'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_69.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.69: Issue list after resolving issues'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we created a support desk application. The application displays
    a list of issues. The issues can be sorted and resolved. We used JavaScript interoperability
    to add a sorting feature.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 10.01: Writing Tests for the Coffee-Ordering Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the testing namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create tests using the `clojure.test` library to display the orders messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the application using the `is` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tests using the `are` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create tests using the `clojure.test` library to check whether the file exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test whether the file does not exist:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test whether the file does exist:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create tests using the `clojure.test` library to save and load orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load empty orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load coffee orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.57: Output after saving and loading orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_57.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.57: Output after saving and loading orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create tests using the expectations library to display the orders message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create tests using the `Expectations` library to check whether the file exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create tests using the `Expectations` library to save and load orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save data to a file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save coffee orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save coffee data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.58: Testing using the Expectations library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_58.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.58: Testing using the Expectations library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create tests using the `Midje` library to display the orders messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create tests using the `Midje` library to checking whether the file exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create tests using the `Midje` library to load orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.59: Test for loading orders using the Midje library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_59.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.59: Test for loading orders using the Midje library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create tests using `test.check` to displaying the orders messages. Import the
    `test.check` namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test displaying the order function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create tests using `test.check` to check whether the file exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create tests using `test.check` to load orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.60: Using test.check to create tests for loading orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_60.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.60: Using test.check to create tests for loading orders'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we created a test suite for the coffee-ordering application.
    We wrote tests for utility functions using four unit testing libraries. We started
    with tests using `clojure.test`, followed by tests with `Expectations` and `Midje`.
    Finally, we wrote property-based tests using the `test.check` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.02: Support Desk Application with Tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the testing dependencies to the `project.clj` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the namespaces to the `core_test.cljs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create fixtures with issues in the application state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write tests for the sort message function using `cljs.test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write tests for the sort message function using `test.check`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write tests for the filter issues by priority function using `cljs.test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write tests to sort the issues list using `cljs.test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write tests to delete issues from the list using `cljs.test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write tests for the handle the sort function using `cljs.test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the command line to run the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the tests are run, they should show the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.61: Output after running the tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_61.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.61: Output after running the tests'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we added ClojureScript tests to a support desk application.
    We wrote unit tests using `cljs.test` and property-based tests using the `test.check`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 11.01: A Tennis CSV Macro'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one possibility for the expanded code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should be taken as a rough sketch for the final output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up your project. The `deps.edn` file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The namespace declaration of the `tennis_macro.clj` file should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The macro''s call signature should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the macro needs to be able to handle a variable number of forms, we
    use `& forms`, which will provide us with a list of forms inside the body of the
    macro.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `with-open` and  `->>` expressions and add the threaded function calls
    that never change. Don''t forget to use a gensym for the `reader` binding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It turns out that if `sc/cast-with` is supplied with an empty `map`, that is,
    no fields to change, it simply changes nothing. On the other hand, `select-keys`
    does the opposite: with no keys to preserve, it returns an empty `map`. It will
    require some more logic so that when no fields are provided, we get all the fields,
    rather than no fields at all. That''s why we haven''t included it yet.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use unquote-splice (`~@`) to insert the threaded forms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a way to conditionally apply `select-keys`, depending on whether or
    not there are fields to select or not. There are a lot of ways to solve this,
    but perhaps the simplest is to define a specialized version of `select-keys`.
    We''ll call it `maybe-select-keys`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This allows us to add a call to `map` that can be the same, regardless of the
    presence of fields to select or not:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Many other solutions to this part of the problem probably involve referring
    to fields more than once. In these cases, a gensym should be used:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the macro. Let''s try it with the `blowouts` function (this assumes that
    the CSV file has been copied into the project directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the most lopsided victories in the dataset. Our macro seems to work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we''ve obtained a list of all the players who have defeated Roger Federer
    (from 1991 to 2016):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is one question that should always be asked when writing a macro: could
    this be a function instead? The answer here is probably somewhere between "yes"
    and "maybe."'
  prefs: []
  type: TYPE_NORMAL
- en: One approach might be to write a function that simply extracts all the data
    from the CSV file. After passing through `doall`, any kind of transformation would
    be possible. With this solution, however, the benefits of lazy evaluation would
    be lost, which means that the entire CSV file would need to be loaded into memory.
    If one of the processing steps involves filtering out some of the matches, the
    macro solution would be more efficient because the filtering would occur before
    the entire file was read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach would be to use functional composition. The user would supply
    a series of functions that would be wrapped inside a single function called from
    inside the `with-open` macro. This approach would preserve the advantages of lazy
    evaluation. However, the supplied functions would have to be written in a precise
    way that might not be as clear. Here, we''ve been writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we would have to define a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: This might not be a deal-breaker. Everything depends on the intended use and
    the intended audience. Macros can often provide a very flexible interface, which
    can be an important factor in choosing to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you find yourself repeating code that cannot be easily encapsulated with
    functions, for whatever reason, writing a macro can often be the solution. In
    this case, as in *Exercise 11.04*, *Monitoring Functions* writing a macro is probably
    the least obtrusive way to simplify your code. Writing a macro is always a trade-off
    in terms of added complexity: as we said at the beginning of this chapter, macro
    code is hard to debug, and it can make the rest of your code harder to debug as
    well. But, as is often said, code you never need to debug is code you don''t have
    to write. So, if a solid macro can help you avoid writing many lines of code,
    it might be worth it.'
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 12.01: A DOM Whack-a-mole Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project with `lein figwheel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the new `packt-clj.dom-whackamole` directory and start a ClojureScript
    REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your browser, at `localhost:3449/index.html`, you should see the default
    Figwheel page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.26: Default Figwheel page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.26: Default Figwheel page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `dom-whackamole/src/packt-clj/dom-whackamole/core.cljs` in your editor
    or IDE. This is where you will write all the remaining code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the atoms that will determine the game''s state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of these are fairly self-explanatory. The `clock-interval` atom will be
    set to a JavaScript interval when the game starts. Defining `game-length-in-seconds`
    and then multiplying by 1,000 isn't necessary but it helps to make our code more
    readable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `moles` atom will be a vector of maps with `:status` and `:remaining-millis`
    fields. Why type out five identical maps when `repeat` can do the work for us?
    Later, we'll update the moles using their index in the vector, which is why we
    really want to have a vector here, and not a list. By itself, `repeat` would return
    a simple list. To avoid that, we use `(into [] …)` to be sure we have a real vector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another equally valid approach would be to wrap all of these items in a single
    atom that could be structured like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach would mean changing most of the functions involving data access
    but would not fundamentally change how the game is built.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generally, in more complex applications, the single atom approach would be preferable.
    The downside to this is that any change to the atom would cause all the components
    to update. If only one part of the multi-level map contained in the atom has changed,
    many of these updates would be useless. To avoid this, React-based ClojureScript
    frameworks all have some means for tracking changes to only one part of the application
    state atom. Rum, as well as Om and Reagent, calls these cursors. A cursor allows
    a component to listen to a particular part of the atom state, thus avoiding unnecessary
    re-renders when unrelated parts of the atom change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define functions for making changes to the application state atoms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first two functions are fairly straightforward. `activate-mole` uses `update`
    instead of `assoc` in order to test whether the mole is already activated or not.
    If it is already `:live`, we don''t want to change the number of remaining milliseconds
    back to 3,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These functions are the heart of the game's logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first function, `mole-countdown`, removes 100 from the `:remaining-millis`
    field of any active moles. To do this, it maps over the list of moles. If a mole
    is not `:live`, it is left alone. (We can't use `filter` here because we don't
    want to eliminate the inactive moles; we only want to ignore them.) If the mole
    is `:live`, we subtract 100 from the remaining time. If there is still time left,
    we just update the remaining time in the mole. If we've reached zero, though,
    we set the status back to `:waiting`. This is the case when the player has not
    clicked on the mole after 3 seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next function, `update-moles`, will be called on each 100-millisecond tick
    of the game clock. It calls `mole-countdown` and then checks whether there are
    enough active moles in the list. If there aren't two active moles, `activate-mole`
    is called with a random index between 0 and 4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might be surprised that we don't check to see whether the mole we are activating
    here is already `:live` or not. Because this check will happen every 100 milliseconds
    (and because the gameplay of Whack-a-mole doesn't require extreme precision),
    we can avoid doing so. If we try to activate an already active mole, nothing will
    happen (thanks to how we wrote `activate-mole`) and we can try again on the next
    clock tick.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `reset-moles` function will be called when the game clock gets to zero.
    All the moles hide when the game is over.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, the `whack!` function will actually be the click handler. It looks
    up the mole by its index and then calls `deactivite-mole` if the mole happens
    to be `:live`, in which case it also adds a point to the player's score.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's important to note here that all of these functions interact directly with
    the atoms. They all use `deref` (via the `@` reader macro) and not `rum/react`.
    All of this logic, so far, is independent of the Rum components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the game clock functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `clock-tick` function determines what happens every 100 milliseconds. Either
    the game is over (`millis-remaining` has reached zero) or it is still going. If
    the game is over, we reset the moles and change the game state back to `:waiting`.
    If not, we call `update-moles` to advance their internal time counters and then
    we advance the global `millis-remaining` atom.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `start-clock` function does just that. The first step here is to check for
    an existing interval and stop it. We definitely don't want more than one interval
    running at the same time. (If you notice the clock running at a very fast rate,
    that is probably what is happening.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our call to `swap!` is then just a call to `setInterval` with the `clock-tick`
    function and the 100-millisecond interval.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we''re ready to write our `start-game` function that will be called when
    the user clicks on the `Start` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s start writing some simple Rum components that just display the current
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `clock` and `score` views simply display those values. Since we don''t
    want to actually display milliseconds on the clock, we divide by 1,000\. And since
    we don''t want show times like 5.034, we round down using the `floor` method from
    the JavaScript `Math` library. (Don''t worry if you don''t know about this JavaScript
    library: displaying milliseconds works fine for this exercise.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a component for the `start-game` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `start-game-button` view observes the `game-state` atom and shows either
    a `Click to play!` button or an encouraging message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the mole views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A lot of important game logic is related to the moles, so we split out a separate
    `mole` component. Notice that `single-mole-view` does not have the `< rum/reactive`
    mixin. These views will get all of their props from their parent view. As a result,
    they do not need to react directly to changes in the atoms; they will receive
    the changes through their arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `single-mole-view` displays the state of the mole, `:waiting` or `:live`,
    and sets up the click handler. We've set up the `whack!` function to do nothing
    if the mole's status is `:waiting`, so we don't have to add any logic about that
    here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `moles-view` simply wraps the calls to `single-mole-view` in a `<div>` element
    and provides them with the appropriate data from the `moles` atom.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the base view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `app` view simply reunites all the previous views in a single while providing
    some additional presentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure that you the `app` view is mounted at the end of your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The call to `on-js-reload` ensures that your code is read again when the browser reloads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you can play the game!:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.27: Playing DOM Whack-a-mole'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.27: Playing DOM Whack-a-mole'
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Database Interaction and the Application Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 13.01: Persisting Historic Tennis Results and ELO Calculations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new project, begin with the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `src` directory, create the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Creating our connection pool in the database namespace is straightforward using `hikari`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our DDL should look similar to the following. Field data types may vary, although
    not significantly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Leveraging `clojure.java.jdbc`, we can apply the schema, taking care of the ordering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is perhaps one of the more creative aspects of the activity, meaning that
    there are many ways to solve the problem, with the following only being one of
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `parse` namespace, we begin by defining the accessors required to extract
    each of the fields we''re interested in:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each preceding definition is a map of `target-key` (that is, where we want to
    store the value in our data structure) to `accessor` (that is, a single-arity
    function that, given a row, will extract, format, and aggregate fields as required).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can then define a function that will perform the application of these accessors
    on any given row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some well-named helper functions can be defined to perform the extraction for
    each of our target structures, which are combined in a simple `parse-row` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can combine these into our historic function as follows, adding
    the relevant requires:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `reduce` function we''ve defined here begins by parsing the incoming row
    into the three target data structures we''re interested in: the players (`winning`
    and `losing`) as well as the match itself. We then check to ensure we''re only
    going to persist a player if we''ve not already seen it. We do this by checking
    against the `player-ids-seen` set using the appropriately named `helper` function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we use the thread-first macro to maintain our accumulator, adding new
    players/matches and maintaining the set of player IDs we've already processed,
    before extracting the `:data` portion of the map and returning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `ingest` namespace, a simple call to `parse/historic`, along with a
    destructure in our `let` binding, is enough to extract the players and matches
    we are going to insert into the `db` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having taken the `match_scores_1991-2016_unindexed_csv.csv` file and placed
    it in the `resources` directory, we can now ingest our historic data and perform
    a few sanity checks to see whether our `player` and `tennis_match` counts match
    those as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The SQL to extract all tennis matches in the `query` namespace is fairly straightforward;
    however, attention should be drawn to the `round_order desc`. Since `round_order`
    *decreases* as the tournament progresses, we must sort this into reverse order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Leveraging our functions from *Chapter 5*, *Many to One: Reducing*, our `elo`
    namespace starts off as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculating the ELO rating for all matches can be achieved as follows. First,
    we can define two helper functions, the first of which yields a tuple of expected
    outcomes.  Since probabilities must sum to 1, we can calculate one probability
    and then subtract it from 1 to get the other probability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then destructure the tuple in the body of our second helper function, which
    allows us to calculate the new ratings for each player returning an updated player
    data structure that is destructured in `calculate-all`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we destructure the result of the call to `calculate-new-ratings`,
    extracting the `winner` and `loser` IDs so that we can update the `current-player-ratings`
    data structure for the next iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `winner_id` and `loser_id` for the current match, we can look up their
    existing ratings in our accumulator (defaulting to `1000`) if they're not found.
    Next, we determine the expected outcomes using the function described previously.
    Once we have that, we can plug this into the `recalculate-rating` function and
    store the updated values in our accumulator for the next iteration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`current-player-rating` is effectively an in-memory cache; we would not want
    to persist ratings to the database only to look them up again.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is also more performant to do a single call to `jdbc/insert-multi!` in the
    `persist-all` function than it is to persist as we go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The SQL required to extract all names and ratings is straightforward. Bolting
    on a `result-set-fn` function that iterates over the results one at a time is
    straightforward and intuitive, if less performant than a raw SQL approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We begin by defining the maximum rating as the smallest integer, guaranteeing
    that it won't end up featuring in our final result!  A simple comparison of the
    existing highest rating with the candidate rating allows us to determine whether
    we update our accumulator using the conditional thread-first macro.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s confirm that the player with the highest ELO value matches
    what was expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Excellent! We've successfully built an application layer allowing us to ingest,
    query, and perform calculations on our large tennis results CSV dataset. Anyone
    new to the application should be able to grasp the purpose of it from the namespaces
    alone. The intention of each individual function, when taken in the context of
    the namespace, should also be clear.
  prefs: []
  type: TYPE_NORMAL
- en: 14\. HTTP with Ring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 14.01: Exposing Historic Tennis Results and ELO Calculations via REST'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependencies to `packt-clj.tennis` in the `deps.edn` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our namespace with the following `require` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The routes required to expose our player resources and the tennis matches they''ve
    taken part in are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `query` functions referenced are defined in the `query` namespace like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `run` function looks similar to that we''ve used before, leveraging the
    `wrap-format` and `wrap-params` middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can add the following route to our `players` context for ELO retrieval,
    along with the means to extract it from our `query` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new `tennis-matches` context, along with the new `query/tennis-match`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Optionally, if starting from a clean database, we can populate it with relevant
    data using the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After starting the web server, we can use a browser to retrieve the current
    ELOs for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.22: Printing Sampras'' current rating'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.22: Printing Sampras'' current rating'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Printing the current rating of `Djokovic`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.23: Printing Djokovic''s current rating'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.23: Printing Djokovic''s current rating'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We define our `tennis-match` creation route using `PUT` since we know the ID
    ahead of time. This is added to the `tennis-matches` context. We must query the
    ELO of the two players involved in the match, then create a new record for each
    of them with their updated ELO. This requires a new `ingest/tennis-match` and
    `elo/persist` functions, as shown. Note that the `elo/calculate-new-ratings` function
    should now be marked as public (`defn` rather than `defn-`) now that we require
    it outside of the `elo` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: (.stop app)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (def app (api/run))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (require '[clj-http.client :as http])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (http/put "http://localhost:8080/tennis-matches/2019-1-d643-s403-5"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{:body (pr-str {:tournament_year  2019,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: :tournament       "umag",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: :tournament_order 1,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: :round_order      5,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: :match_order      1,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: :winner_id        "d643",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: :loser_id         "s402"})})
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since Sampras lost our fictitious match, we see his ELO decrease slightly,
    while Djokovic''s has increased:![Figure 14.24: Printing Sampras'' rating'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_14_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.24: Printing Sampras'' rating'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are Djokovic''s ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.25: Printing Djokovic''s current rating'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_14_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.25: Printing Djokovic''s current rating'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, by completing this activity, we have made our application layer more widely
    available via a REST web service.
  prefs: []
  type: TYPE_NORMAL
- en: '15\. The Frontend: A ClojureScript UI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 15.01: Displaying a Grid of Images from the Internet'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command-line prompt, create a new Figwheel project using the following
    Leiningen command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the `packt-clj.images/` directory and type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.8: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_15_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.8: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `src/packt_clj/images/core.cljs` file in your preferred editor and
    modify the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The commonly used alias for Reagent is `r` instead of Reagent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `app-state` is made of two pieces of data: a vector of images that we fetched,
    initially an empty vector, and whether to display the author''s name, initially
    true.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s create a button that fetches images from the HTTP endpoint and updates
    the `:images` value of the `app-state`. We need two handlers: `fetch-images`,
    which updates `:images` in the `app` state with a vector of images, and `clear-images`,
    which updates `:images` in the `app` state with an empty vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here is the code for the `fetch-or-clear-button` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We apply the `btn` class to the button by using the `:button.btn` short Hiccup
    syntax. The `btn` class is defined in `resources/public/css/style.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s build an `image` component and an `image-grid` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last component is a button that hides or displays author names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add all the components as children of the `main` component. We renamed
    the `hello-world` function `app`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we render the main component (named `app` instead of `hello-world`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything went well, you should see a screen like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.9: Buttons to fetch and clear images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_15_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.9: Buttons to fetch and clear images'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the `Fetch Images` button, the images appear with authors''
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10: Fetching the images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_15_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.10: Fetching the images'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when you click on the `Hide author` button, the authors'' names disappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11: Hiding the authors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_15_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.11: Hiding the authors'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have created a single-page application that can load and clear images
    and text as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.02: Tennis Players with Ranking'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command-line prompt, create a new Figwheel project using the following
    Leiningen command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the `packt-clj.tennis/` directory and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.12: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_15_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.12: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `src/packt_clj/tennis/core.cljs` file in your preferred editor and
    modify the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`app-state` consists of the list of players and the details about the currently
    selected player.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start with an empty list of players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the code that fetches the ranking data from the server about a specific
    player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a player component that displays the name of a player and their ranking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a button that clears the current player and goes back to the
    list of all the players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s write the code for the list of players. We start by writing a component
    for an element of the list. The content is the name of the player. When we click
    on it, it fetches the ranking data about the selected player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now build the `player-list` component. It receives a vector of players and
    returns a `:div` that contains a player component for each player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the code for the function that fetches the players data from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need a function that clears the list of players by modifying `app-state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we add a button that either clears or fills the list of players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we write the `main` component. When the value associated to `:current-player`
    is not `nil`, we display the currently selected player. Otherwise, we display
    a list of players. This is the code for the main `app` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we render the main component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By completing the activities, we have seen how to organize the different components
    of a Reagent application: the CSS, HTML, and `cljs` files. Being able to iteratively
    modify the code and have the web page immediately update without any page refresh
    was helpful and time-saving. We learned how to store the state of the app in a
    ratom and access the state for the code of the Reagent components.'
  prefs: []
  type: TYPE_NORMAL
