- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: About
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于
- en: This section is included to assist the students to perform the activities present
    in the book. It includes detailed steps that are to be performed by the students
    to complete and achieve the objectives of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含在内，以帮助学生执行书中的活动。它包括学生要执行的详细步骤，以完成并实现书的目标。
- en: 1\. Hello REPL!
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 欢迎使用REPL！
- en: 'Activity 1.01: Performing Basic Operations'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.01：执行基本操作
- en: 'Solution:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 解答：
- en: Open the REPL.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开REPL。
- en: 'Print the message `"I am not afraid of parentheses"` to motivate yourself:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印消息`"我不怕括号"`来激励自己：
- en: '[PRE0]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add 1, 2, and 3 and multiply the result by 10 minus 3, which corresponds to
    the following `infix` notation: (1 + 2 + 3) * (10 - 3):'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将1、2和3相加，然后将结果乘以10减3，这对应于以下`infix`表示法：（1 + 2 + 3）*（10 - 3）：
- en: '[PRE1]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Print the message `"Well done!"` to congratulate yourself:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印消息`"做得好!"`来祝贺自己：
- en: '[PRE2]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Exit the REPL by pressing *Ctrl* + *D* or typing the following command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *D*或输入以下命令退出REPL：
- en: '[PRE3]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By completing this activity, you have written code that prints a message to
    the standard output. You have also performed some mathematical operations using
    the *prefix* notation and nested expressions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你已经编写了打印标准输出的消息的代码。你还使用*prefix*表示法和嵌套表达式执行了一些数学运算。
- en: 'Activity 1.02: Predicting the Atmospheric Carbon Dioxide Level'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.02：预测大气二氧化碳水平
- en: 'Solution:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 解答：
- en: Open your favorite editor and a REPL window next to it.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您最喜欢的编辑器和旁边的REPL窗口。
- en: 'In your editor, define two constants, `base-co2` and `base-year`, with the
    values 382 and 2006, respectively:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中，定义两个常量`base-co2`和`base-year`，分别具有值382和2006：
- en: '[PRE4]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In your editor, write the code to define the `co2-estimate` function without
    forgetting to document it with the `doc-string` parameter.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中，编写定义`co2-estimate`函数的代码，不要忘记使用`doc-string`参数对其进行文档化。
- en: 'You may be tempted to write the function body in a single line, but nesting
    a lot of function calls decreases the readability of the code. It is also easier
    to reason about each step of the process by decomposing them in a `let` block.
    Write the body of the function using `let` to define the local binding, `year-diff`,
    which is the subtraction of 2006 from the `year` parameter:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会想将函数体写在一行中，但嵌套大量的函数调用会降低代码的可读性。通过在`let`块中分解它们，也更容易推理每个步骤的过程。使用`let`来定义局部绑定`year-diff`，它是从`year`参数中减去2006的结果：
- en: '[PRE5]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Test your function by evaluating `(co2-estimate 2050)`. You should get `470`
    as the result:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过评估`(co2-estimate 2050)`来测试您的函数。你应该得到`470`作为结果：
- en: '[PRE6]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Look up the documentation of your function with `doc` and make sure that it
    has been defined correctly:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`doc`查找您函数的文档，并确保它已被正确定义：
- en: '[PRE7]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this activity, we calculated the estimated level of CO2 parts per million
    for a given year.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们计算了给定年份的二氧化碳百万分之一估计水平。
- en: 'Activity 1.03: The meditate Function v2.0'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.03：meditate函数v2.0
- en: 'Solution:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 解答：
- en: Open your favorite editor and a REPL window next to it.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您最喜欢的编辑器和旁边的REPL窗口。
- en: In your editor, define a function with the name `meditate`, taking two arguments,
    `calmness-level` and `s`, without forgetting to write its documentation.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中，定义一个名为`meditate`的函数，它接受两个参数`calmness-level`和`s`，不要忘记编写其文档。
- en: 'In the function body, start by writing an expression that prints the string,
    "`Clojure Meditate v2.0`":'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数体中，首先编写一个打印字符串`"Clojure Meditate v2.0"`的表达式：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Following the specification, write the first condition to test whether the calmness
    level is strictly inferior to 5\. Write the first branch of the conditional expression
    (the "then").
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据规范，编写第一个条件来测试平静度是否严格低于5。编写条件表达式的第一个分支（即"then"）。
- en: Write the second condition, which should be nested in the second branch of the
    first condition (the "else").
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写第二个条件，它应该嵌套在第一个条件的第二个分支中（即"else"）。
- en: 'Write the third condition, which should be nested in the second branch of the
    second condition. It will check that `calmness-level` is exactly 10 and return
    the reverse of the `s` string when that is the case:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写第三个条件，它应该嵌套在第二个条件的第二个分支中。它将检查`calmness-level`是否正好是10，并在这种情况下返回`s`字符串的反转：
- en: '[PRE9]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Test your function by passing a string with different levels of calmness. The
    output should be similar to the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递具有不同平静度的字符串来测试您的函数。输出应类似于以下内容：
- en: '[PRE10]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you have been using the `and` operator to find out whether a number was between
    two other numbers, rewrite your function to remove it and only use the `<=` operator.
    Remember that `<=` can take more than two arguments.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你一直在使用`and`运算符来确定一个数字是否在两个其他数字之间，重写你的函数以移除它，并仅使用`<=`运算符。记住`<=`可以接受超过两个参数。
- en: 'Look up the `cond` operator in the documentation and rewrite your function
    to replace the nested conditions with `cond`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档中查找`cond`运算符，并重写你的函数以用`cond`替换嵌套的条件：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By completing this activity, you have written a documented function that takes
    multiple parameters, prints a message, and conditionally returns a transformation
    of a string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你已经编写了一个文档化的函数，该函数接受多个参数，打印一条消息，并根据条件返回字符串的转换。
- en: 2\. Data Types and Immutability
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 数据类型和不可变性
- en: 'Activity 2.01: Creating a Simple In-Memory Database'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：创建一个简单的内存数据库
- en: 'Solution:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'First, create the helper functions. You can get the Hash Map by executing the
    `read-db` function with no arguments, and write to the database by executing the
    `write-db` function with a Hash Map as an argument:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建辅助函数。你可以通过不带参数执行`read-db`函数来获取哈希表，并通过执行带有哈希表作为参数的`write-db`函数来写入数据库：
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start by creating the `create-table` function. This function should take one
    parameter: the table name. It should add a new key (the table name) at the root
    of our Hash Map database, and the value should be another Hash Map containing
    two entries – an empty vector at the `data` key and an empty Hash Map at the `indexes`
    key:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建`create-table`函数。这个函数应该接受一个参数：表名。它应该在我们的哈希表数据库的根处添加一个新的键（表名），其值应该是一个包含两个条目的另一个哈希表——在`data`键处的空向量以及在`indexes`键处的空哈希表：
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Test that your `create-table` function works. The output should be as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试你的`create-table`函数是否正常工作。输出应该如下所示：
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create the next function: `drop-table`. The function should take one
    parameter as well: the table name. It should remove a table, including all its
    data and indexes from our database:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建下一个函数：`drop-table`。该函数也应该接受一个参数：表名。它应该从我们的数据库中删除一个表，包括其所有数据和索引：
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Test that your `drop-table` function works. The output should be as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试你的`drop-table`函数是否正常工作。输出应该如下所示：
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s move on to the `insert` function. This function should take three parameters:
    `table`, `record`, and `id-key`. The `record` parameter is a Hash Map, and `id-key`
    corresponds to a key in the record map that will be used as a unique index. For
    example, inserting a record in the `fruits` table would look like this:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续到`insert`函数。这个函数应该接受三个参数：`table`、`record`和`id-key`。`record`参数是一个哈希表，`id-key`对应于记录映射中的一个键，该键将用作唯一索引。例如，在`fruits`表中插入记录将看起来像这样：
- en: '[PRE17]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For now, we will not handle cases where a table does not exist or when an index
    key already exists in a given table.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们不会处理表不存在或索引键已存在于给定表中的情况。
- en: Try to use a `let` block to divide the work of the `insert` function into multiple
    steps.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试使用`let`块将`insert`函数的工作分成多个步骤。
- en: 'In a `let` statement, create a binding for the value of the database, retrieved
    with `read-db`:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一个`let`语句中，为使用`read-db`检索的数据库值创建一个绑定：
- en: '[PRE18]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same `let` statement, create a second binding for the new value of the
    database (after adding the record in the `data` vector):'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在同一个`let`语句中，为数据库的新值创建第二个绑定（在`data`向量中添加记录后）：
- en: '[PRE19]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same `let` statement, retrieve the index at which the record was inserted
    by counting the number of elements in the `data` vector:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在同一个`let`语句中，通过计算`data`向量中的元素数量来检索记录插入的索引：
- en: '[PRE20]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the body of the `let` statement, update the index at `id-key` and write
    the resulting map to the database with `write-db`:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`let`语句的主体中，更新`id-key`处的索引，并使用`write-db`将结果映射写入数据库：
- en: '[PRE21]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To verify that your `insert` function works, try to use it multiple times to
    insert new records. The output should look like this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证你的`insert`函数是否正常工作，尝试多次使用它来插入新的记录。输出应该看起来像这样：
- en: '[PRE22]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `select-*` function that will return all the records of a table passed
    as a parameter. Given the three preceding records, the output should be similar
    to this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`select-*`函数，该函数将返回作为参数传递的表的全部记录。给定前面的三个记录，输出应该类似于以下内容：
- en: '[PRE23]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a `select-*-where` function that takes three arguments: `table-name`,
    `field`, and `field-value`. The function should use the index map to retrieve
    the index of the record in the data vector and return the element. Given the three
    preceding records, the output should be similar to this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`select-*-where`函数，它接受三个参数：`table-name`、`field`和`field-value`。该函数应使用索引映射来检索记录在数据向量中的索引，并返回该元素。给定前面的三个记录，输出应类似于以下内容：
- en: '[PRE24]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Modify the `insert` function to reject any index duplicate. When a record with
    `id-key` already exists in the `indexes` map, we should not modify the database
    and print an error message to the user. The output should be similar to this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`insert`函数以拒绝任何索引重复。当`id-key`记录已存在于`indexes`映射中时，我们不应修改数据库，并向用户打印错误信息。输出应类似于以下内容：
- en: '[PRE25]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final output should be similar to this:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终输出应类似于以下内容：
- en: '[PRE26]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this activity, we have used our new knowledge about reading and updating
    both simple and deeply nested data structures to implement a simple in-memory
    database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们利用了关于读取和更新简单和深层嵌套数据结构的新知识来实现一个简单的内存数据库。
- en: 3\. Functions in Depth
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 深入了解函数
- en: 'Activity 3.01: Building a Distance and Cost Calculator'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动三.01：构建距离和成本计算器
- en: 'Solution:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Start by defining the `walking-speed` and `driving-speed` constants:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义`walking-speed`和`driving-speed`常量：
- en: '[PRE27]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create two other constants representing two locations with the coordinates
    `:lat` and `:lon`. You can use the previous example with Paris and Bordeaux or
    look up your own. You will be using them to test your distance and itinerary functions:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个其他常量，代表具有坐标`:lat`和`:lon`的两个位置。您可以使用之前的巴黎和波尔多的示例，或者查找您自己的位置。您将使用它们来测试您的距离和行程函数：
- en: '[PRE28]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create the distance function. It should take two parameters representing the
    two locations for which we need to calculate the distance. You can use a combination
    of sequential and associative destructuring right in the function parameters to
    disassemble the latitude and longitude from both locations. You can decompose
    the steps of the calculation in a `let` expression and use the `Math/cos` function
    to calculate the cosine and `Math/sqrt` to calculate the square root of a number:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建距离函数。它应接受两个参数，代表我们需要计算距离的两个位置。您可以在函数参数中直接使用顺序和关联解构来分解两个位置的纬度和经度。您可以将计算的步骤分解在`let`表达式中，并使用`Math/cos`函数来计算余弦和`Math/sqrt`来计算一个数的平方根：
- en: '[PRE29]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a multimethod called `itinerary`. It will offer the flexibility of adding
    more types of transport in the future. It should use the value at `:transport`
    as a dispatch *value*:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`itinerary`的多方法。它将提供未来添加更多类型交通的灵活性。它应使用`:transport`值作为调度*值*：
- en: '[PRE30]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create the itinerary function for the `:walking` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from` and
    `:to` keys from the `HashMap` parameter. You can use a `let` expression to decompose
    the calculations of the distance and duration. The distance should simply use
    the `distance` function you created before. To calculate the duration, you should
    use the `walking-speed` constant that you defined in *Step 1*:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`:walking`调度值创建行程函数。您可以在函数参数中使用关联解构来检索`HashMap`参数中的`:from`和`:to`键。您可以使用`let`表达式来分解距离和持续时间的计算。距离应简单地使用您之前创建的`distance`函数。为了计算持续时间，您应使用在*步骤1*中定义的`walking-speed`常量：
- en: '[PRE31]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the `:driving` itinerary function, you could use a *dispatch table* that
    contains the vehicle associated with their costing function. Create a `vehicle-cost-fns`
    dispatch table. It should be a `HashMap` with the keys being the types of vehicles,
    and the values being cost calculation functions based on the distance:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`:driving`行程函数，您可以使用包含与成本函数关联的车辆的*调度表*。创建一个`vehicle-cost-fns`调度表。它应该是一个`HashMap`，键是车辆类型，值是基于距离的成本计算函数：
- en: '[PRE32]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the itinerary function for the `:driving` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from`,
    `:to`, and `:vehicle` keys from the `HashMap` parameter. The driving distance
    and duration can be calculated similarly to the walking distance and duration.
    The cost can be calculated by retrieving the `cost` function from the dispatch
    table using the `:vehicle` key:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `:driving` 分派值创建行程函数。你可以在函数参数中使用关联解构来检索 `HashMap` 参数中的 `:from`、`:to` 和 `:vehicle`
    键。驾驶距离和持续时间可以像步行距离和持续时间一样计算。成本可以通过使用 `:vehicle` 键从分派表中检索 `cost` 函数来计算：
- en: '[PRE33]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now try the following:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在尝试以下操作：
- en: '[PRE34]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this activity, we've put in practice the destructuring and multimethod techniques
    that we have learned in this chapter by building a distance and cost calculator
    between two locations. In the future, you could imagine putting this code behind
    a web server and finishing building a fully blown itinerary calculation app!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们通过构建两个位置之间的距离和成本计算器，将我们在本章中学到的解构和多重方法技术付诸实践。在未来，你可以想象将这段代码放在一个网络服务器后面，完成一个完整的行程计算应用的建设！
- en: 4\. Mapping and Filtering
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 映射和过滤
- en: 'Activity 4.01: Using map and filter to Report Summary Information'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.01：使用映射和过滤来报告摘要信息
- en: 'Solution:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'To start, set up a simple framework using the `->>` threading macro:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `->>` 线程宏设置一个简单的框架：
- en: '[PRE35]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This defines the fundamental structure of our function, which we can sum up
    as follows: start with `users` and send it through a series of transformations.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这定义了我们的函数的基本结构，我们可以总结如下：从 `users` 开始，将其发送通过一系列转换。
- en: 'The first of these transformations will be to filter out all the users that
    don''t have the status we are looking for. We''ll use `filter` for that, naturally,
    and we''ll include a predicate that compares the `:status` field from each user
    with the `status` parameter that was passed into the function: `(filter #(= (:status
    %) status))`.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这些转换中的第一个将是过滤掉所有没有我们正在寻找的状态的用户。我们将自然地使用 `filter` 来做这件事，并包括一个谓词，该谓词将每个用户的 `:status`
    字段与函数中传入的 `status` 参数进行比较：（过滤 #(= (:status %) status)）。'
- en: 'With that, our function now looks like this:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们的函数现在看起来是这样的：
- en: '[PRE36]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We know that we have the correct set of users. Now, we need to extract the
    field we''re interested in. The `field` parameter is a keyword, so we can use
    it as a function to extract the necessary data as we map over each user, like
    this: `(map field)`.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们知道我们有了正确的用户集。现在，我们需要提取我们感兴趣的域。`field` 参数是一个关键字，因此我们可以将其用作一个函数来提取我们映射每个用户时所需的数据，如下所示：（映射
    field）。
- en: 'Now, our function looks like this:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们的函数看起来是这样的：
- en: '[PRE37]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the final step, we use `(apply max)` to find the needle in this haystack:
    the maximum value corresponding to `field`.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用 `(apply max)` 来在这堆干草中找到针：对应于 `field` 的最大值。
- en: 'The complete function looks like this:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的函数看起来像这样：
- en: '[PRE38]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Activity 4.02: Arbitrary Tennis Rivalries'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.02：任意网球对抗
- en: 'Solution:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'The first step will be to set up the function and the `with-open` macro:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步将是设置函数和 `with-open` 宏：
- en: '[PRE39]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside that, set up a `let` binding. The first binding will be to the `lazy-seq`
    returned by `csv/read-csv`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，设置一个 `let` 绑定。第一个绑定将是 `csv/read-csv` 返回的 `lazy-seq`：
- en: '[PRE40]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the same `->>` chain, we also want to keep only the matches where our players
    are actually against each other. Like we did previously, we''ll use the set pattern
    to see whether the set "winner and loser in the match" is equal to the set of
    the two players we are looking for. We''ll also use `map` and `select-keys` to
    only keep the fields we want:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `->>` 链中，我们还想只保留我们的玩家实际上是对抗的匹配。像之前做的那样，我们将使用集合模式来查看“比赛中的胜者和败者”集合是否等于我们正在寻找的两个玩家的集合。我们还将使用
    `map` 和 `select-keys` 来只保留我们想要的字段：
- en: '[PRE41]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can already start gathering some data here, so we''ll make some more bindings
    in the same `let` statement:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以开始收集一些数据，所以我们在同一个 `let` 语句中创建更多的绑定：
- en: '[PRE42]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These are simple filter calls that give us two lists of victories.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是简单的过滤调用，给我们两个胜利列表。
- en: 'We have all the bindings we need, so now it''s time to do some work with them
    inside the scope of the `let` statement. Everything can happen inside the map
    that we are going to return. Now that we have our three sequences, that is, `player-1-victories`,
    `player-2-victories`, and the overall `rivalry-seq`, it becomes easier to grab
    some of our summary data with calls to `count` and `first`. We''ll also write
    one more call to `filter` that inspects the score difference in the rivalry:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有了所有需要的绑定，现在是在 `let` 语句的作用域内使用它们的时候了。所有的事情都可以在我们将要返回的映射内部发生。现在我们已经有了我们的三个序列，即
    `player-1-victories`、`player-2-victories` 和整体的 `rivalry-seq`，这使得通过调用 `count` 和
    `first` 获取一些总结数据变得更容易。我们还将写一个额外的 `filter` 调用，检查竞争中的得分差异：
- en: '[PRE43]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You may be surprised that we did not need to call `doall` in this solution.
    This is because `rivalry-seq` is fully realized by the call to `count`. The final
    code can be found at [https://packt.live/2Ri3904](https://packt.live/2Ri3904).
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会惊讶，我们在这个解决方案中不需要调用 `doall`。这是因为 `rivalry-seq` 是通过调用 `count` 完全实现的。最终的代码可以在[https://packt.live/2Ri3904](https://packt.live/2Ri3904)找到。
- en: By completing this activity, we have produced the summary data for any two players
    who have actually played against each other.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，我们已经为任何实际相互对抗的两个玩家产生了总结数据。
- en: '5\. Many to One: Reducing'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 多对一：减少
- en: 'Activity 5.01: Calculating Elo Ratings for Tennis'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01：计算网球 Elo 评级
- en: 'Solution:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Here is the minimal `deps.edn` file you''ll need:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是你需要的最小 `deps.edn` 文件：
- en: '[PRE44]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is the corresponding namespace declaration:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是相应的命名空间声明：
- en: '[PRE45]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the overall structure of your function, we will follow the same patterns
    we''ve used so far: a `with-open` macro with some pre-processing code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于你函数的整体结构，我们将遵循迄今为止使用的相同模式：一个 `with-open` 宏和一些预处理代码：
- en: '[PRE46]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next step is to outline the call to `reduce`. The `:match-count`, `:predictable-match-count`,
    and `:correct-predictions` fields are just counters that will need to be updated
    depending on whether each match is correctly predicted. The `:players` map will
    contain a key for each player; the values will be their Elo ratings:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是概述对 `reduce` 的调用。`:match-count`、`:predictable-match-count` 和 `:correct-predictions`
    字段只是计数器，将根据每个匹配是否被正确预测而需要更新。`:players` 映射将包含每个玩家的键；值将是他们的 Elo 评级：
- en: '[PRE47]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'From here, it is just a question of applying logic that we''ve already developed.
    First, we extract and calculate, and then we update the accumulator. The body
    of the reducing function starts with some `let` bindings:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，它只是一个应用我们已开发的逻辑的问题。首先，我们提取和计算，然后更新累加器。减少函数的主体从一些 `let` 绑定开始：
- en: '[PRE48]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`winner-rating` and `loser-rating` are extracted from the `:players` map in
    the accumulator. After we make our prediction regarding the match winner by calling
    `match-probability`, the remainder of the operations simply apply the consequences
    of whether our prediction was correct.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`winner-rating` 和 `loser-rating` 是从累加器中的 `:players` 映射中提取的。在通过调用 `match-probability`
    对比赛胜者做出预测后，剩余的操作只是应用我们的预测是否正确的结果。'
- en: 'Now, we can finally update the accumulator. The following code goes inside
    the `let` expression above. This is what the reducing function will return. We
    use the `->` macro to thread the existing `acc` through a series of changes:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们最终可以更新累加器了。以下代码将放在上面的 `let` 表达式内部。这就是减少函数将返回的内容。我们使用 `->` 宏将现有的 `acc` 通过一系列变化传递：
- en: '[PRE49]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is the entire function, when we put everything back together:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是整个函数，当我们把所有东西放在一起时：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It might be interesting to experiment with different values of `k` to see whether
    the precision of the predictions can be improved. This is why we keep track of
    `:correction-predictions` and `:predictable-match-count`. There are many other
    kinds of improvements that could be made: modifying the function to run on multiple
    CSV files (if the ratings started at the very beginning of the dataset, in 1877,
    we would expect the quality to improve); perhaps contextually adjusting `k` depending
    on the relative strength of the two players, or based on current winning and losing
    streaks; or attributing bonuses to players who win more in certain locations.
    You now have a framework for experimentation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的`k`值以查看是否可以提高预测的精度可能很有趣。这就是为什么我们跟踪`:correction-predictions`和`:predictable-match-count`。还有许多其他类型的改进可以实施：修改函数以在多个CSV文件上运行（如果评分从数据集的起始点，即1877年开始，我们预计质量会提高）；也许根据两位选手的相对强度或基于当前的胜负连串来上下文调整`k`；或者给在特定地点赢得更多比赛的选手分配奖金。你现在有一个实验的框架。
- en: 6\. Recursion and Looping
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 递归和循环
- en: 'Activity 6.01: Generating HTML from Clojure Vectors'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：从Clojure向量生成HTML
- en: 'Solution:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'We''ll use `clojure.string` in our solution. It is not strictly necessary,
    but `clojure.string/join` is a very convenient function. Because `clojure.string`
    is a standard Clojure namespace, a `deps.edn` file containing only an empty map
    is sufficient for this activity:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在解决方案中使用`clojure.string`。这并不是严格必要的，但`clojure.string/join`是一个非常方便的函数。因为`clojure.string`是一个标准的Clojure命名空间，一个只包含空映射的`deps.edn`文件就足够用于这项活动：
- en: '[PRE51]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here are the smaller functions that we''ll use later in the main HTML-producing
    function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里列出了我们将在主HTML生成函数中稍后使用的较小函数：
- en: '[PRE52]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first one, `attributes`, takes `map` attribute names and values. We treat
    the map like a sequence and map over the `[key value]` pairs. The keys are Clojure
    keywords, so they need to be converted to strings with the name function. The
    key-value pair becomes a string, `key="value"`. Then, we use `clojure.string/join`
    to combine all the substrings into a single string, making sure that each attribute
    is separated from the others by some whitespace. If the input map, `m`, is empty,
    `clojure.string/join` will return an empty string.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数`attributes`接受`map`属性名称和值。我们将映射视为一个序列，并映射到`[key value]`对。键是Clojure关键字，因此需要使用名称函数将它们转换为字符串。键值对变成一个字符串，`key="value"`。然后，我们使用`clojure.string/join`将所有子字符串组合成一个字符串，确保每个属性与其他属性之间通过一些空格分隔。如果输入映射`m`为空，`clojure.string/join`将返回一个空字符串。
- en: 'The next functions are simple formatting tools for building different kinds
    of tags:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数是用于构建不同类型标签的简单格式化工具：
- en: '[PRE53]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next set of helper functions are predicates that we will need since the
    main recursive function walks the tree of nested vectors. They all take the same
    kind of argument: the tree or subtree that we are analyzing.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个辅助函数集是谓词，我们将在主递归函数遍历嵌套向量树时需要它们。它们都接受相同类型的参数：我们正在分析的树或子树。
- en: 'We need to be able to distinguish between input vectors that have attributes
    and those that don''t. We do this by looking at the type of the second item in
    the vector:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要能够区分具有属性和不具有属性的输入向量。我们通过查看向量中第二个项的类型来实现这一点：
- en: '[PRE54]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The second item of a simple element like `[:h1 "Hello world"]` is a string,
    so `has-attributes?` would return `nil`. If the second item was another vector,
    the result would be the same. On `[:h1 {:class "title"} "Hello Universe"]`, `has-attributes?`
    would return `true`. Because `(map? nil)` returns `nil`, we don''t need to have
    a special case for single-item vectors. `(has-attributes? [:br])` simply returns
    `nil`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单元素如`[:h1 "Hello world"]`的第二个项是一个字符串，所以`has-attributes?`将返回`nil`。如果第二个项是另一个向量，结果将相同。在`[:h1
    {:class "title"} "Hello Universe"]`中，`has-attributes?`将返回`true`。因为`(map? nil)`返回`nil`，所以我们不需要为单元素向量设置特殊案例。`(has-attributes?
    [:br])`简单地返回`nil`：
- en: '[PRE55]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `singleton?` function tests whether an element is a member of a small set
    of HTML elements that are not allowed to have closing tags. Naturally, we use
    a Clojure set to test this. First, though, we make sure that the current item
    is a vector because, sometimes, the current item will be a string (such as the
    second item in `[:h1 "Hello world"]`):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`singleton?` 函数用于测试一个元素是否属于一组不允许有闭合标签的HTML元素集合中的成员。自然地，我们使用Clojure集合来测试这一点。不过，首先我们要确保当前项是一个向量，因为有时当前项将是一个字符串（例如在`[:h1
    "Hello world"]`中的第二个项）：'
- en: '[PRE56]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: These two predicates follow the same basic logic but build on the function we've
    already defined.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个谓词遵循相同的基本逻辑，但建立在已经定义的函数之上。
- en: Now it's time for the main recursive function. Like the predicates, it will
    take a tree as an argument, which can, of course, be the entire vector tree or
    a subtree. Like most recursive functions, there is a `cond` with several branches.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写主要递归函数了。像谓词一样，它将接受一个树作为参数，这当然可以是整个向量树或子树。像大多数递归函数一样，有一个 `cond` 包含多个分支。
- en: 'Here is the basic structure:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是基本结构：
- en: '[PRE57]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s go through the various conditions one by one, before putting them all
    back together:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将所有条件合并之前，让我们逐一分析各种条件：
- en: '[PRE58]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If `tree` is not truthy, it means there is nothing we can do, so we simply
    return `nil`. For the rest of the inputs, we won''t have to worry about getting
    `nil`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `tree` 不是真值，这意味着我们无法进行任何操作，所以我们只需返回 `nil`。对于其他输入，我们不必担心得到 `nil`：
- en: '[PRE59]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If `tree` is a string, we don''t want to transform it. It can be integrated
    into the output string as is:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `tree` 是一个字符串，我们不想对其进行转换。它可以原样集成到输出字符串中：
- en: '[PRE60]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is why we needed the `singleton-with-attrs?` predicate. Now, all we need
    to do is match the singleton tree with the corresponding formatting function.
    Because singleton elements don''t have any content, no recursion is possible here:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要 `singleton-with-attrs?` 谓词的原因。现在，我们只需要将单例树与相应的格式化函数匹配。因为单例元素没有任何内容，所以这里不可能进行递归：
- en: '[PRE61]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is a simpler version of the previous condition:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是之前条件的简化版本：
- en: '[PRE62]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we finally get to do some recursion! If an element has attributes, start
    making a string out of a list. That''s what `(apply str…)` is for. We''ll use
    `concat` to prepend the opening tag and the attributes, now formatted as a string,
    to a list that will be produced by `next` calls to `my-hiccup`, which will happen
    with the call to `map`. And, at the end of the list, we have the formatted closing
    tag. This is the classic case where we cannot use `recur:` the call to `(apply
    str (concat…))` cannot complete until all the underlying calls to `my-hiccup`
    have completed:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以做一些递归了！如果一个元素有属性，开始从列表中制作一个字符串。这就是 `(apply str…)` 的作用。我们将使用 `concat`
    将开标签和属性（现在格式化为字符串）添加到由 `next` 调用生成的列表中，这些调用将在 `map` 调用中发生。在列表的末尾，我们有格式化的关闭标签。这是我们不能使用
    `recur:` 的经典案例，因为 `(apply str (concat…))` 的调用无法完成，直到所有底层的 `my-hiccup` 调用都完成：
- en: '[PRE63]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The last condition follows the same pattern as the previous pattern. We could
    have made this a default condition instead of testing with `vector?`. If our input
    vector tree is malformed, the error indicating no matching case should put us
    on the right track for debugging. In production code, we could add an `:otherwise`
    condition that would throw an exception. You'll learn about exceptions in *Chapter
    9*, *Host Platform Interoperability with Java and JavaScript*.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个条件遵循与之前相同的模式。我们本可以将这个条件作为默认条件，而不是用 `vector?` 进行测试。如果我们的输入向量树格式不正确，没有匹配情况的错误应该能让我们找到调试的正确方向。在生产代码中，我们可以添加一个
    `:otherwise` 条件，这将抛出一个异常。你将在第 9 章，*Java 和 JavaScript 的主机平台互操作性* 中学习关于异常的内容。
- en: 'If we reassemble `my-hiccup`, it looks like this:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们重新组装 `my-hiccup`，它看起来是这样的：
- en: '[PRE64]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you try the `my-hiccup` function in the REPL, you should be able to produce
    the string for a complete HTML page:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在 REPL 中尝试 `my-hiccup` 函数，你应该能够生成一个完整的 HTML 页面的字符串：
- en: '![Figure 6.10: Final output'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.10：最终输出'
- en: '](img/B14502_06_10.jpg)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_06_10.jpg)'
- en: 'Figure 6.10: Final output'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：最终输出
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to try different inputs and page structures. You can even copy the
    output string into a text file to load into your browser.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试不同的输入和页面结构。你甚至可以将输出字符串复制到文本文件中，然后加载到浏览器中。
- en: By completing this activity, we are now able to take any vector written with
    this syntax, including an arbitrary number of descendant vectors, and produce
    a single string containing correctly structured HTML.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，我们现在能够处理任何使用这种语法编写的向量，包括任意数量的后代向量，并生成一个包含正确结构化 HTML 的单个字符串。
- en: '7\. Recursion II: Lazy Sequences'
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 递归 II：懒序列
- en: 'Activity 7.01: Historical, Player-Centric Elo'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第 7.01 部分：历史，以玩家为中心的 Elo
- en: 'Solution:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: Set up your project, which should be based on the code written for the last
    exercises in this chapter.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的项目，该项目应基于本章最后练习中编写的代码。
- en: The solution follows the pattern established with `take-matches`. Let's start
    with the parameters. We need to define separate behaviors for matches played by
    the "focus player" and matches played between other players. The first thing we
    need is, of course, a way to identify the player, so we'll add a `player-slug`
    argument. This wasn't necessary in `take-matches` because there we treated all
    the matches the same, regardless of who played in them.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案遵循与 `take-matches` 建立的模式。让我们从参数开始。我们需要为“焦点玩家”进行的比赛和其他玩家之间的比赛定义不同的行为。我们当然需要一种识别玩家的方法，所以我们将添加一个
    `player-slug` 参数。在 `take-matches` 中这不是必要的，因为在那里我们对待所有比赛都是一样的，无论谁参与了比赛。
- en: 'In `take-matches`, we had a `limit` argument to control how deeply we walked
    the tree. In this case, we need two different parameters, which we will call `focus-depth`
    and `opponent-depth`. Together, that gives us the following parameters for our
    new `focus-history` function:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `take-matches` 中，我们有一个 `limit` 参数来控制我们深入树的深度。在这种情况下，我们需要两个不同的参数，我们将它们称为 `focus-depth`
    和 `opponent-depth`。结合起来，这为我们新的 `focus-history` 函数提供了以下参数：
- en: '[PRE65]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `tree` parameter is, of course, the result of a call to `match-tree-by-player`,
    as before.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tree` 参数当然是 `match-tree-by-player` 调用的结果，就像之前一样。'
- en: Finally, the `f` argument will work the same way as in `take-matches`.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`f` 参数将与 `take-matches` 中的方式相同。
- en: 'Controlling the function''s movement through the tree will end up being a challenge.
    As usual, we will set up a `cond` form that will determine how the function reacts
    to the incoming data. The first two conditions are quite simple, and in fact,
    are nearly identical to the code in `take-matches`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制函数在树中的移动将是一项挑战。像往常一样，我们将设置一个 `cond` 形式，以确定函数如何对传入的数据做出反应。前两个条件相当简单，实际上几乎与
    `take-matches` 中的代码相同：
- en: '[PRE66]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The only change from `take-matches` is that now we are using `focus-depth` instead
    of `limit`. The fact that we are using `focus-depth` here is important nonetheless.
    We are only concerned about `focus-depth` at this stage, and not `opponent-depth`,
    because if `focus-depth` is zero or one, the entire operation stops and in this
    case we no longer care about `opponent-depth`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `take-matches` 的唯一不同之处在于，现在我们使用 `focus-depth` 而不是 `limit`。在这里使用 `focus-depth`
    的事实仍然很重要。我们只关心这个阶段的 `focus-depth`，而不是 `opponent-depth`，因为如果 `focus-depth` 为零或一，整个操作就会停止，在这种情况下我们就不再关心
    `opponent-depth`。
- en: 'The final condition is where this function behaves differently from `take-matches`.
    It is also more complex, though perhaps not as much as you might think at first
    glance. To understand this, let''s look at the equivalent part of `take-matches`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终条件是，这个函数在行为上与 `take-matches` 不同。尽管可能没有你第一眼看到的那样复杂，但它确实更复杂。为了理解这一点，让我们看看 `take-matches`
    的等效部分：
- en: '[PRE67]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: At this point, we are placing `(f (first tree))` at the head of the current
    lazy seq. As such, we are connecting it onto the rest of the sequence, whose first
    item will be a vector containing the starting point for two more branch lazy seqs.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们将 `(f (first tree))` 放在当前惰性序列的头部。这样，我们就将其连接到序列的其余部分，其第一个元素将是一个包含两个更多分支惰性序列起始点的向量。
- en: 'All we need to do here, in order to introduce separate behaviors for the two
    possible cases, is to replace the calls to `take-matches` inside the two-item
    vector. Those two matches are the "parent" matches of the current match; that
    is, they are the matches played by the winner and loser before the current match.
    We need to test first to find which "parent" matches belong to the focus player
    and which belong to an opponent. For the focus player''s previous match, we call
    `focus-history`. For the opponent''s previous match we call `take-matches`. In
    other words, instead of just having two calls to `take-matches`, as above, we
    have two branching conditions:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，为了引入两种可能情况的不同行为，我们只需要在两个元素的向量中替换对 `take-matches` 的调用。这两个匹配是当前匹配的“父”匹配；也就是说，它们是当前匹配之前赢家和输家所进行的匹配。我们需要先测试以找出哪些“父”匹配属于焦点玩家，哪些属于对手。对于焦点玩家的上一场比赛，我们调用
    `focus-history`。对于对手的上一场比赛，我们调用 `take-matches`。换句话说，我们不再像上面那样只有两个对 `take-matches`
    的调用，而是有两个分支条件：
- en: '[PRE68]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In both of these cases, whether we call `focus-history` or `take-matches`, we
    have to be careful to adjust the `tree` argument and the `focus-depth` arguments
    correctly. Remember that `tree` is always relative to the current two-item sequence
    composed of a match and a two-item vector, which is why we use `(first (second
    tree))` and `(second (second tree))`, that is, the first and the second of the
    two lazy sequences in the vector. While it would be tempting to assign these to
    `let` bindings to avoid repeating `(second tree)`, it is generally better in these
    cases to avoid "holding onto the head."
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两种情况下，无论我们调用`focus-history`还是`take-matches`，我们都要小心调整`tree`参数和`focus-depth`参数。记住`tree`始终相对于由一场比赛和两个元素的向量组成的当前两项序列，这就是为什么我们使用`(first
    (second tree))`和`(second (second tree))`，即向量中两个懒序列的第一个和第二个。虽然将这些分配给`let`绑定以避免重复`(second
    tree)`可能很有吸引力，但在这些情况下通常最好避免“保留头部”。
- en: 'Here''s the complete function:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是完整的函数：
- en: '[PRE69]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It's worth noting that this function is only slightly more complex than `take-matches`.
    As is often the case with recursive solutions, the code itself is rather simple.
    The difficulty is in choosing the best strategy.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的是，这个函数比`take-matches`稍微复杂一点。正如递归解决方案通常那样，代码本身相当简单。困难在于选择最佳策略。
- en: 'Here is the function in action, from start to finish. First, we read in the
    data and generate the ratings:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是函数从开始到结束的运行过程。首先，我们读取数据并生成评分：
- en: '[PRE70]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then we build the lazy match tree for the player we''re interested in:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们为感兴趣的球员构建懒匹配树：
- en: '[PRE71]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And now we call our new function:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在调用我们的新函数：
- en: '[PRE72]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The indentation in the results reveals a tree structure:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果中的缩进揭示了树结构：
- en: '![Figure 7.10: The results of focus-history'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.10：焦点历史的成果'
- en: '](img/B14502_07_10.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_07_10.jpg](img/B14502_07_10.jpg)'
- en: 'Figure 7.10: The results of focus-history'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：焦点历史的成果
- en: Matches played by Federer contain deeper sub-trees of the preceding matches.
    The data is ready to be passed to the frontend team, who will translate it into
    a beautiful visualization.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 费德勒打出的比赛包含更深层次的先前比赛的子树。数据已准备好传递给前端团队，他们将把它转换成漂亮的可视化。
- en: 8\. Namespaces, Libraries and Leiningen
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 命名空间、库和Leiningen
- en: 'Activity 8.01: Altering the Users List in an Application'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：在应用程序中更改用户列表
- en: 'Solution:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Import the `clojure.string` namespace with `use` and the `:rename` keyword
    for the `replace` and `reverse` functions:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`use`和`:rename`关键字导入`clojure.string`命名空间，为`replace`和`reverse`函数重命名：
- en: '[PRE73]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a set of users:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组用户：
- en: '[PRE74]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Replace the underscore between honorifics and first names:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换尊称和名字之间的下划线：
- en: '[PRE75]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This will return the following:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE76]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Use the `capitalize` function to capitalize each person''s initials in the
    user group:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`capitalize`函数将用户组中每个人的首字母大写：
- en: '[PRE77]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This will return the following:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE78]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Update the user list by using the string''s `replace` and `capitalize` functions:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串的`replace`和`capitalize`函数更新用户列表：
- en: '[PRE79]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Import only the `print-table` function from the `clojure.pprint` namespace:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅从`clojure.pprint`命名空间导入`print-table`函数：
- en: '[PRE81]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Print a table with users:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印用户表：
- en: '[PRE82]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is as follows:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.23: Printing the table of users'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.23：打印用户表'
- en: '](img/B14502_08_23.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_23.jpg](img/B14502_08_23.jpg)'
- en: 'Figure 8.23: Printing the table of users'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.23：打印用户表
- en: 'Import the `clojure.set` namespace, excluding the `join` function:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`clojure.set`命名空间，排除`join`函数：
- en: '[PRE83]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create and display a set of admins:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并显示一组管理员：
- en: '[PRE84]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is as follows:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE85]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now execute the following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在执行以下操作：
- en: '[PRE86]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is as follows:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE87]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Call the `subset?` function on two sets:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个集合上调用`subset?`函数：
- en: '[PRE88]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is as follows:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE89]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To print the final output, execute the following:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印最终输出，执行以下操作：
- en: '[PRE90]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is as follows:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.24: Printing the final user table'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24：打印最终用户表'
- en: '](img/B14502_08_24.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_24.jpg](img/B14502_08_24.jpg)'
- en: 'Figure 8.24: Printing the final user table'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：打印最终用户表
- en: In this activity, we worked on two features. With the first feature, we capitalized
    usernames. With the second feature, we used `Clojure.set` functions to check whether
    any users were also admins.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们处理了两个功能。第一个功能是将用户名大写。第二个功能是使用`Clojure.set`函数检查是否有任何用户也是管理员。
- en: 'Activity 8.02: Summing Up Numbers'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.02：求和数字
- en: 'Solution:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Create a Leiningen application:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Leiningen应用程序：
- en: '[PRE91]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Convert string arguments to integers:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串参数转换为整数：
- en: '[PRE92]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Add integers to calculate the sum:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加整数进行求和：
- en: '[PRE93]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Print the result as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打印结果：
- en: '[PRE94]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output will look like the following:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.25: Printing the sum'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.25：打印求和结果]'
- en: '](img/B14502_08_25.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_25.jpg](img/B14502_08_25.jpg)'
- en: 'Figure 8.25: Printing the sum'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25：打印求和结果
- en: 'The complete solution should look as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的解决方案应如下所示：
- en: '[PRE95]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In this activity, we created a new Leiningen project. This application accepted
    parameters from the command line. Numbers input into the command line were summed
    and the result was displayed.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们创建了一个新的 Leiningen 项目。这个应用程序可以从命令行接受参数。输入到命令行的数字会被求和，并将结果显示出来。
- en: 'Activity 8.03: Building a Format-Converting Application'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.03：构建格式转换应用程序
- en: 'Solution:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Inside `project.clj`, add the `cheshire` dependency:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `project.clj` 中添加 `cheshire` 依赖项：
- en: '[PRE96]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Create a function to convert from hash to JSON. Inside the core namespace,
    add the following:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在核心命名空间中创建一个从哈希转换为 JSON 的函数：
- en: '[PRE97]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Testing the `generate-json-from-hash` function in the REPL should give us the
    following result:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 REPL 中测试 `generate-json-from-hash` 函数应该给出以下结果：
- en: '![Figure 8.26: Generating JSON from hash'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.26：从哈希生成 JSON]'
- en: '](img/B14502_08_26.jpg)'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_26.jpg](img/B14502_08_26.jpg)'
- en: 'Figure 8.26: Generating JSON from hash'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.26：从哈希生成 JSON
- en: 'Create a function to convert from JSON to hash:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 JSON 转换为哈希的函数：
- en: '[PRE98]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Testing `generate-hash-from-json` in the REPL should give us the following
    result:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 REPL 中测试 `generate-hash-from-json` 应该给出以下结果：
- en: '![Figure 8.27: Generating hash from JSON'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.27：从 JSON 生成哈希]'
- en: '](img/B14502_08_27.jpg)'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_27.jpg](img/B14502_08_27.jpg)'
- en: 'Figure 8.27: Generating hash from JSON'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.27：从 JSON 生成哈希
- en: 'Add the `expectations` library to the testing profile defined for the project.
    In `project.clj`, add the following:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `expectations` 库添加到为项目定义的测试配置文件中。在 `project.clj` 中添加以下内容：
- en: '[PRE99]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Add the `lein-expectations` plugin for the project:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目添加 `lein-expectations` 插件：
- en: '[PRE100]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Write the test for the JSON functions. Inside the `json-parser/test/json_parser/core_test.clj`
    files, add the following:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 JSON 函数的测试。在 `json-parser/test/json_parser/core_test.clj` 文件中添加以下内容：
- en: '[PRE101]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Calling tests with the `qa` profile should give us the following:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `qa` 配置文件调用测试应该给出以下结果：
- en: '![Figure 8.28: Executing the test profile'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.28：执行测试配置文件]'
- en: '](img/B14502_08_28.jpg)'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_28.jpg](img/B14502_08_28.jpg)'
- en: 'Figure 8.28: Executing the test profile'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.28：执行测试配置文件
- en: 'Add `lein-ancient` to user-wide profiles. In `~/.lein/profiles.clj`, add the
    following:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `lein-ancient` 添加到用户全局配置文件中。在 `~/.lein/profiles.clj` 中添加以下内容：
- en: '[PRE102]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Checking for outdated dependencies should show the following:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查过时依赖项应显示以下内容：
- en: '![Figure 8.29: Checking for outdated dependencies'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.29：检查过时依赖项]'
- en: '](img/B14502_08_29.jpg)'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_29.jpg](img/B14502_08_29.jpg)'
- en: 'Figure 8.29: Checking for outdated dependencies'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29：检查过时依赖项
- en: In this activity, we have created an application that performs a conversion
    from JSON format to Clojure data and back. In order to make sure that our application
    runs correctly, we created a testing profile where we included dependencies on
    the `expectations` library and a plugin. To make sure that the libraries in all
    our projects are not outdated, we included the `lein-ancient` plugin in our user-wide
    profile.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们创建了一个应用程序，它能够将 JSON 格式转换为 Clojure 数据格式，并反向转换。为了确保我们的应用程序能够正确运行，我们创建了一个测试配置文件，其中包含了
    `expectations` 库和插件的依赖。为了确保我们所有项目中的库都不会过时，我们在用户全局配置文件中包含了 `lein-ancient` 插件。
- en: 9\. Host Platform Interoperability with Java and JavaScript
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. Java 和 JavaScript 的平台互操作性
- en: 'Activity 9.01: Book-Ordering Application'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 9.01：图书订购应用程序
- en: 'Solution:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Create a new project:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目：
- en: '[PRE103]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Import the necessary namespaces:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的命名空间：
- en: '[PRE104]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Create a map to hold books by year:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按年份存储书籍的映射：
- en: '[PRE105]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Create a variable for a file that stores orders:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为存储订单的文件创建一个变量：
- en: '[PRE106]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create the initial menu with options to order a book and list orders:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始菜单，包含订购书籍和列出订单的选项：
- en: '[PRE107]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The output is as follows:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 9.53: Output for the initial menu'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.53：初始菜单的输出]'
- en: '](img/B14502_09_53.jpg)'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_53.jpg](img/B14502_09_53.jpg)'
- en: 'Figure 9.53: Output for the initial menu'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.53：初始菜单的输出
- en: 'Create a menu to display books by year:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个菜单来显示按年份排序的书籍：
- en: '[PRE108]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The output is as follows:'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 9.54: Output for available books by the year'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.54：按年份显示可用书籍的输出]'
- en: '](img/B14502_09_54.jpg)'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_54.jpg](img/B14502_09_54.jpg)'
- en: 'Figure 9.54: Output for available books by the year'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.54：按年份显示可用书籍的输出
- en: 'Create the application''s `main` method:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序的 `main` 方法：
- en: '[PRE109]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Create a function to save data to a file:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将数据保存到文件的函数：
- en: '[PRE110]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Create a function to save an order:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个保存订单的函数：
- en: '[PRE111]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Create a function to calculate the price of a book:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计算书籍价格的函数：
- en: '[PRE112]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Create a function to display an order confirmation message:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个显示订单确认消息的函数：
- en: '[PRE113]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.55: Order confirmation message'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.55：订单确认消息'
- en: '](img/B14502_09_55.jpg)'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_55.jpg)'
- en: 'Figure 9.55: Order confirmation message'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.55：订单确认消息
- en: 'Create a function to display the bought order:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个显示已购买订单的函数：
- en: '[PRE114]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output is as follows:'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.56: Displaying the purchased order'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.56：显示已购买的订单'
- en: '](img/B14502_09_56.jpg)'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_56.jpg)'
- en: 'Figure 9.56: Displaying the purchased order'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.56：显示已购买的订单
- en: 'Create a function to read a single order:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个读取单个订单的函数：
- en: '[PRE115]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Create a function to check whether a file exists:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个检查文件是否存在的函数：
- en: '[PRE116]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Create a function to load orders from a file:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从文件中加载订单的函数：
- en: '[PRE117]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Create a submenu to order a book:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子菜单来订购书籍：
- en: '[PRE118]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is as follows:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.57: Submenu for book order'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.57：书籍订购子菜单'
- en: '](img/B14502_09_57.jpg)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_57.jpg)'
- en: 'Figure 9.57: Submenu for book order'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.57：书籍订购子菜单
- en: 'Create a function to buy a book by year:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按年份购买书籍的函数：
- en: '[PRE119]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The output is as follows:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.58: Function to buy books by year'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.58：按年份购买书籍的函数'
- en: '](img/B14502_09_58.jpg)'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_58.jpg)'
- en: 'Figure 9.58: Function to buy books by year'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.58：按年份购买书籍的函数
- en: 'Create a function to show orders by year:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按年份显示订单的函数：
- en: '[PRE120]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Create a submenu to list orders:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子菜单来列出订单：
- en: '[PRE121]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The output is as follows:'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.59: Creating submenu'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.59：创建子菜单'
- en: '](img/B14502_09_59.jpg)'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_59.jpg)'
- en: 'Figure 9.59: Creating submenu'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.59：创建子菜单
- en: In this activity, we created an application for ordering books and displaying
    orders. We used our new knowledge about I/O and Java to complete this activity.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们创建了一个用于订购书籍和显示订单的应用程序。我们利用我们对I/O和Java的新知识来完成这个活动。
- en: Once you complete the activity, you should have an output similar to the following.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成活动，你应该得到类似以下输出。
- en: 'Initial menu:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 初始菜单：
- en: '![Figure 9.60: Initial menu'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.60：初始菜单'
- en: '](img/B14502_09_60.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_60.jpg)'
- en: 'Figure 9.60: Initial menu'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.60：初始菜单
- en: 'Listing years:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 列出年份：
- en: '![Figure 9.61: Listing years'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.61：列出年份'
- en: '](img/B14502_09_61.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_61.jpg)'
- en: 'Figure 9.61: Listing years'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.61：列出年份
- en: 'Books in one year:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一年的书籍：
- en: '![Figure 9.62: Books purchased in 2019'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.62：2019年购买的书籍'
- en: '](img/B14502_09_62.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_62.jpg)'
- en: 'Figure 9.62: Books purchased in 2019'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.62：2019年购买的书籍
- en: 'Asking how many books to buy:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 询问购买多少本书：
- en: '![Figure 9.63: Asking for the numbers of books to be bought'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.63：询问购买书籍的数量'
- en: '](img/B14502_09_63.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_63.jpg)'
- en: 'Figure 9.63: Asking for the numbers of books to be bought'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.63：询问购买书籍的数量
- en: 'Order confirmation message:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 订单确认消息：
- en: '![Figure 9.64: Order confirmation message'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.64：订单确认消息'
- en: '](img/B14502_09_64.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_64.jpg)'
- en: 'Figure 9.64: Order confirmation message'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.64：订单确认消息
- en: 'Listing purchased books:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 列出已购买的书籍：
- en: '![Figure 9.65: Listing purchased books'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.65：列出已购买的书籍'
- en: '](img/B14502_09_65.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_65.jpg)'
- en: 'Figure 9.65: Listing purchased books'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.65：列出已购买的书籍
- en: In this section, we used our knowledge of Java interoperability to create a
    command-line application. In the next section, we will learn how to use JavaScript
    in ClojureScript.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们利用我们对Java互操作性的知识创建了一个命令行应用程序。在下一节中，我们将学习如何在ClojureScript中使用JavaScript。
- en: 'Activity 9.02: Creating a Support Desk'
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动九.02：创建支持台
- en: 'Solution:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Create a new project:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目：
- en: '[PRE122]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Add the `jayq` and `cuerdas` libraries as dependencies in `project.clj`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`project.clj`中将`jayq`和`cuerdas`库作为依赖项添加：
- en: '[PRE123]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create the `utils` function to filter the issues list by priority:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`utils`函数来按优先级过滤问题列表：
- en: '[PRE124]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Create the `utils` function to get the sorted issues list:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个获取排序问题列表的`utils`函数：
- en: '[PRE125]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Create the `utils` function to get the sort message by issues count:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个根据问题数量获取排序信息的`utils`函数：
- en: '[PRE126]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'For `0` issues, the output is as follows:'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`0`个问题，输出如下：
- en: '[PRE127]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'For `3` issues, the output is as follows:'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`3`个问题，输出如下：
- en: '[PRE128]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Create the `utils` function to delete issue from a list:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`utils`函数来从列表中删除问题：
- en: '[PRE129]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Create the `utils` function called when sorting is finished:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个在排序完成后调用的`utils`函数：
- en: '[PRE130]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Add jQuery and jQuery UI to `index.html`:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将jQuery和jQuery UI添加到`index.html`：
- en: '[PRE131]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Import `jayq`, `cuerdas`, and `utils` to the core namespace:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`jayq`、`cuerdas`和`utils`导入到核心命名空间：
- en: '[PRE132]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Define the priorities list as follows:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下定义优先级列表：
- en: '[PRE133]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Define `app-state` as follows:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下定义`app-state`：
- en: '[PRE134]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Define the `counter` Rum component:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`counter` Rum组件：
- en: '[PRE135]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Create the issue on `click` function:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`click`函数的问题：
- en: '[PRE136]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Define the issue item in the Rum component:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Rum组件中定义问题项：
- en: '[PRE137]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The output is as follows:'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.66: Defining an issue item in a Rum component'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.66：在Rum组件中定义问题项'
- en: '](img/B14502_09_66.jpg)'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_66.jpg)'
- en: 'Figure 9.66: Defining an issue item in a Rum component'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.66：在Rum组件中定义问题项
- en: 'Define the `reactive` issue items component:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`reactive`问题项组件：
- en: '[PRE138]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Define the reactive page `content` component:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义响应式页面`content`组件：
- en: '[PRE139]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Make the item components sortable:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使项目组件可排序：
- en: '[PRE140]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Mount the page component:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载页面组件：
- en: '[PRE141]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Call the `mount` function:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`mount`函数：
- en: '[PRE142]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Call the `sortable` function:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`sortable`函数：
- en: '[PRE143]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Run the application:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序：
- en: '[PRE144]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The initial issues list will look as follows:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始问题列表将如下所示：
- en: '![Figure 9.67: Initial issue list'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.67：初始问题列表'
- en: '](img/B14502_09_67.jpg)'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_67.jpg)'
- en: 'Figure 9.67: Initial issue list'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.67：初始问题列表
- en: 'The issues list after sorting will look as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后的问题列表将如下所示：
- en: '![Figure 9.68: Issue list after sorting'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.68：排序后的问题列表'
- en: '](img/B14502_09_68.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_68.jpg)'
- en: 'Figure 9.68: Issue list after sorting'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.68：排序后的问题列表
- en: 'The issues list after resolving three issues will look as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 解决三个问题后的问题列表将如下所示：
- en: '![Figure 9.69: Issue list after resolving issues'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.69：解决问题后的问题列表'
- en: '](img/B14502_09_69.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_69.jpg)'
- en: 'Figure 9.69: Issue list after resolving issues'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.69：解决问题后的问题列表
- en: In this activity, we created a support desk application. The application displays
    a list of issues. The issues can be sorted and resolved. We used JavaScript interoperability
    to add a sorting feature.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们创建了一个支持台应用程序。该应用程序显示问题列表。问题可以排序和解决。我们使用了JavaScript互操作性来添加排序功能。
- en: 10\. Testing
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 测试
- en: 'Activity 10.01: Writing Tests for the Coffee-Ordering Application'
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十.01：为咖啡订购应用程序编写测试
- en: 'Solution:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Import the testing namespaces:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入测试命名空间：
- en: '[PRE145]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Create tests using the `clojure.test` library to display the orders messages.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`clojure.test`库创建测试以显示订单消息。
- en: 'Test the application using the `is` macro:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`is`宏测试应用程序：
- en: '[PRE146]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Tests using the `are` macro:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`are`宏进行测试：
- en: '[PRE147]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Create tests using the `clojure.test` library to check whether the file exists.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`clojure.test`库检查文件是否存在。
- en: 'Test whether the file does not exist:'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试文件不存在的情况：
- en: '[PRE148]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Test whether the file does exist:'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试文件是否存在：
- en: '[PRE149]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Create tests using the `clojure.test` library to save and load orders.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`clojure.test`库创建测试以保存和加载订单。
- en: 'Save orders:'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存订单：
- en: '[PRE150]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Load empty orders:'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加载空订单：
- en: '[PRE151]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Load coffee orders:'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加载咖啡订单：
- en: '[PRE152]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The output is as follows:'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.57: Output after saving and loading orders'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.57：保存和加载订单后的输出'
- en: '](img/B14502_10_57.jpg)'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_57.jpg)'
- en: 'Figure 10.57: Output after saving and loading orders'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.57：保存和加载订单后的输出
- en: 'Create tests using the expectations library to display the orders message:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用期望库创建测试以显示订单消息：
- en: '[PRE153]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Create tests using the `Expectations` library to check whether the file exists:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Expectations`库检查文件是否存在：
- en: '[PRE154]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Create tests using the `Expectations` library to save and load orders.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Expectations`库创建测试以保存和加载订单。
- en: 'Save data to a file:'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将数据保存到文件中：
- en: '[PRE155]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Save coffee orders:'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存咖啡订单：
- en: '[PRE156]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Save coffee data:'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存咖啡数据：
- en: '[PRE157]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The output is as follows:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.58: Testing using the Expectations library'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.58：使用Expectations库进行测试'
- en: '](img/B14502_10_58.jpg)'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_58.jpg)'
- en: 'Figure 10.58: Testing using the Expectations library'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.58：使用Expectations库进行测试
- en: 'Create tests using the `Midje` library to display the orders messages:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Midje`库显示订单消息：
- en: '[PRE158]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Create tests using the `Midje` library to checking whether the file exists:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Midje`库检查文件是否存在：
- en: '[PRE159]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Create tests using the `Midje` library to load orders:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Midje`库创建测试以加载订单：
- en: '[PRE160]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The output is as follows:'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.59: Test for loading orders using the Midje library'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.59：使用Midje库加载订单的测试'
- en: '](img/B14502_10_59.jpg)'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_59.jpg)'
- en: 'Figure 10.59: Test for loading orders using the Midje library'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.59：使用Midje库加载订单的测试
- en: 'Create tests using `test.check` to displaying the orders messages. Import the
    `test.check` namespaces:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`test.check`创建测试以显示订单消息。导入`test.check`命名空间：
- en: '[PRE161]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Test displaying the order function:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试显示订单功能：
- en: '[PRE162]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Create tests using `test.check` to check whether the file exists:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`test.check`创建测试以检查文件是否存在：
- en: '[PRE163]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Create tests using `test.check` to load orders:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`test.check`创建测试以加载订单：
- en: '[PRE164]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The output is as follows:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.60: Using test.check to create tests for loading orders'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.60：使用 test.check 创建加载订单的测试]'
- en: '](img/B14502_10_60.jpg)'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 B14502_10_60.jpg]'
- en: 'Figure 10.60: Using test.check to create tests for loading orders'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.60：使用 test.check 创建加载订单的测试]'
- en: In this activity, we created a test suite for the coffee-ordering application.
    We wrote tests for utility functions using four unit testing libraries. We started
    with tests using `clojure.test`, followed by tests with `Expectations` and `Midje`.
    Finally, we wrote property-based tests using the `test.check` library.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们为咖啡订购应用程序创建了一个测试套件。我们使用四个单元测试库编写了测试。我们首先使用 `clojure.test` 编写测试，然后是
    `Expectations` 和 `Midje` 的测试。最后，我们使用 `test.check` 库编写了基于属性的测试。
- en: 'Activity 10.02: Support Desk Application with Tests'
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 10.02：带测试的支持台应用程序
- en: 'Solution:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Add the testing dependencies to the `project.clj` file:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试依赖项添加到 `project.clj` 文件中：
- en: '[PRE165]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Import the namespaces to the `core_test.cljs` file:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命名空间导入到 `core_test.cljs` 文件中：
- en: '[PRE166]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Create fixtures with issues in the application state:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序状态中创建带有问题的固定值：
- en: '[PRE167]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Write tests for the sort message function using `cljs.test`:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写对排序消息函数的测试：
- en: '[PRE168]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Write tests for the sort message function using `test.check`:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `test.check` 编写对排序消息函数的测试：
- en: '[PRE169]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Write tests for the filter issues by priority function using `cljs.test`:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写对按优先级过滤问题函数的测试：
- en: '[PRE170]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Write tests to sort the issues list using `cljs.test`:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写对排序问题列表的测试：
- en: '[PRE171]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Write tests to delete issues from the list using `cljs.test`:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写从列表中删除问题的测试：
- en: '[PRE172]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Write tests for the handle the sort function using `cljs.test`:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写对处理排序函数的测试：
- en: '[PRE173]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'We will use the command line to run the tests:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用命令行来运行测试：
- en: '[PRE174]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'When the tests are run, they should show the following:'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当运行测试时，它们应该显示以下内容：
- en: '![Figure 10.61: Output after running the tests'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.61：运行测试后的输出]'
- en: '](img/B14502_10_61.jpg)'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 B14502_10_61.jpg]'
- en: 'Figure 10.61: Output after running the tests'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.61：运行测试后的输出]'
- en: In this activity, we added ClojureScript tests to a support desk application.
    We wrote unit tests using `cljs.test` and property-based tests using the `test.check`
    library.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们向一个支持台应用程序添加了 ClojureScript 测试。我们使用 `cljs.test` 编写了单元测试，并使用 `test.check`
    库编写了基于属性的测试。
- en: 11\. Macros
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 宏
- en: 'Activity 11.01: A Tennis CSV Macro'
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：网球 CSV 宏
- en: 'Solution:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Here is one possibility for the expanded code:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是扩展代码的一个可能方案：
- en: '[PRE175]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: This should be taken as a rough sketch for the final output.
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该被视为最终输出的粗略草图。
- en: 'Set up your project. The `deps.edn` file should look like this:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的项目。`deps.edn` 文件应该看起来像这样：
- en: '[PRE176]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The namespace declaration of the `tennis_macro.clj` file should look like this:'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tennis_macro.clj` 文件的命名空间声明应该像这样：'
- en: '[PRE177]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The macro''s call signature should look like this:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏的调用签名应该像这样：
- en: '[PRE178]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Because the macro needs to be able to handle a variable number of forms, we
    use `& forms`, which will provide us with a list of forms inside the body of the
    macro.
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为这个宏需要能够处理可变数量的形式，所以我们使用 `& forms`，这将在宏体内部为我们提供一个形式列表。
- en: 'Add the `with-open` and  `->>` expressions and add the threaded function calls
    that never change. Don''t forget to use a gensym for the `reader` binding:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `with-open` 和 `->>` 表达式，并添加那些永远不会改变的线程函数调用。别忘了为 `reader` 绑定使用 gensym：
- en: '[PRE179]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'It turns out that if `sc/cast-with` is supplied with an empty `map`, that is,
    no fields to change, it simply changes nothing. On the other hand, `select-keys`
    does the opposite: with no keys to preserve, it returns an empty `map`. It will
    require some more logic so that when no fields are provided, we get all the fields,
    rather than no fields at all. That''s why we haven''t included it yet.'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果表明，如果 `sc/cast-with` 传递了一个空的 `map`，即没有要更改的字段，它就简单地不改变任何东西。另一方面，`select-keys`
    做的是相反的事情：如果没有要保留的键，它返回一个空的 `map`。这将需要一些额外的逻辑，以便在没有提供字段时，我们得到所有字段，而不是一个字段都没有。这就是为什么我们还没有包括它的原因。
- en: 'Use unquote-splice (`~@`) to insert the threaded forms:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 unquote-splice (`~@`) 插入线程形式：
- en: '[PRE180]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'We need a way to conditionally apply `select-keys`, depending on whether or
    not there are fields to select or not. There are a lot of ways to solve this,
    but perhaps the simplest is to define a specialized version of `select-keys`.
    We''ll call it `maybe-select-keys`:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一种方法来有条件地应用 `select-keys`，取决于是否需要选择字段。有许多解决方法，但可能最简单的是定义 `select-keys` 的一个专用版本。我们将称之为
    `maybe-select-keys`：
- en: '[PRE181]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'This allows us to add a call to `map` that can be the same, regardless of the
    presence of fields to select or not:'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许我们添加一个 `map` 调用，它可以相同，无论是否选择字段：
- en: '[PRE182]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Many other solutions to this part of the problem probably involve referring
    to fields more than once. In these cases, a gensym should be used:'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多其他针对这部分问题的解决方案可能涉及多次引用字段。在这些情况下，应该使用gensym：
- en: '[PRE183]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Test the macro. Let''s try it with the `blowouts` function (this assumes that
    the CSV file has been copied into the project directory):'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试宏。让我们用`blowouts`函数试试（这假设CSV文件已经被复制到项目目录中）：
- en: '[PRE184]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: These are the most lopsided victories in the dataset. Our macro seems to work.
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是在数据集中最不平衡的胜利。我们的宏似乎有效。
- en: 'Here, we''ve obtained a list of all the players who have defeated Roger Federer
    (from 1991 to 2016):'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已经获得了一份从1991年到2016年击败罗杰·费德勒的所有球员名单：
- en: '[PRE185]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'There is one question that should always be asked when writing a macro: could
    this be a function instead? The answer here is probably somewhere between "yes"
    and "maybe."'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写宏时，应该始终问一个问题：这能作为一个函数吗？这里的答案可能介于“是”和“可能”之间。
- en: One approach might be to write a function that simply extracts all the data
    from the CSV file. After passing through `doall`, any kind of transformation would
    be possible. With this solution, however, the benefits of lazy evaluation would
    be lost, which means that the entire CSV file would need to be loaded into memory.
    If one of the processing steps involves filtering out some of the matches, the
    macro solution would be more efficient because the filtering would occur before
    the entire file was read.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法可能是编写一个简单的函数，从CSV文件中提取所有数据。在通过`doall`之后，任何类型的转换都是可能的。然而，使用这种解决方案，会失去懒加载评估的好处，这意味着整个CSV文件都需要加载到内存中。如果处理步骤之一涉及过滤掉一些比赛，宏解决方案将更有效，因为过滤会在读取整个文件之前发生。
- en: 'Another approach would be to use functional composition. The user would supply
    a series of functions that would be wrapped inside a single function called from
    inside the `with-open` macro. This approach would preserve the advantages of lazy
    evaluation. However, the supplied functions would have to be written in a precise
    way that might not be as clear. Here, we''ve been writing the following:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是使用函数组合。用户将提供一系列函数，这些函数将被包装在一个名为`with-open`宏内部的单个函数中。这种方法将保留懒加载评估的优势。然而，提供的函数必须以精确的方式编写，可能不会那么清晰。在这里，我们一直在编写以下内容：
- en: '[PRE186]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Instead, we would have to define a function:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可能需要定义一个函数：
- en: '[PRE187]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: This might not be a deal-breaker. Everything depends on the intended use and
    the intended audience. Macros can often provide a very flexible interface, which
    can be an important factor in choosing to use them.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是决定性的问题。一切取决于预期的用途和预期的受众。宏可以提供非常灵活的接口，这可能是选择使用它们的一个重要因素。
- en: 'When you find yourself repeating code that cannot be easily encapsulated with
    functions, for whatever reason, writing a macro can often be the solution. In
    this case, as in *Exercise 11.04*, *Monitoring Functions* writing a macro is probably
    the least obtrusive way to simplify your code. Writing a macro is always a trade-off
    in terms of added complexity: as we said at the beginning of this chapter, macro
    code is hard to debug, and it can make the rest of your code harder to debug as
    well. But, as is often said, code you never need to debug is code you don''t have
    to write. So, if a solid macro can help you avoid writing many lines of code,
    it might be worth it.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现自己因为某种原因重复编写无法轻易封装成函数的代码时，编写宏通常是一个解决方案。在这种情况下，正如*练习11.04*中的*监控函数*，编写宏可能是简化代码最不引人注目的方式。编写宏始终是在增加复杂性的权衡：正如我们在本章开头所说的，宏代码难以调试，它也可能使你的其他代码更难调试。但是，正如常说的，你永远不会需要调试的代码是你不需要编写的代码。所以，如果一个可靠的宏可以帮助你避免编写许多行代码，那么它可能值得。
- en: 12\. Concurrency
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 并发
- en: 'Activity 12.01: A DOM Whack-a-mole Game'
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：一个DOM Whack-a-mole游戏
- en: 'Solution:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Create a project with `lein figwheel`:'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lein figwheel`创建一个项目：
- en: '[PRE188]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Move to the new `packt-clj.dom-whackamole` directory and start a ClojureScript
    REPL:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到新的`packt-clj.dom-whackamole`目录，并启动ClojureScript REPL：
- en: '[PRE189]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'In your browser, at `localhost:3449/index.html`, you should see the default
    Figwheel page:'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的浏览器中，在`localhost:3449/index.html`，你应该看到默认的Figwheel页面：
- en: '![Figure 12.26: Default Figwheel page'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.26：默认Figwheel页面](img/B14502_12_26.jpg)'
- en: '](img/B14502_12_26.jpg)'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.26：默认Figwheel页面](img/B14502_12_26.jpg)'
- en: 'Figure 12.26: Default Figwheel page'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.26：默认Figwheel页面
- en: Open `dom-whackamole/src/packt-clj/dom-whackamole/core.cljs` in your editor
    or IDE. This is where you will write all the remaining code.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`dom-whackamole/src/packt-clj/dom-whackamole/core.cljs`。这就是你将编写所有剩余代码的地方。
- en: 'Define the atoms that will determine the game''s state:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将决定游戏状态的原子：
- en: '[PRE190]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Most of these are fairly self-explanatory. The `clock-interval` atom will be
    set to a JavaScript interval when the game starts. Defining `game-length-in-seconds`
    and then multiplying by 1,000 isn't necessary but it helps to make our code more
    readable.
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数这些都是相当直观的。当游戏开始时，`clock-interval` 原子将被设置为 JavaScript 间隔。定义 `game-length-in-seconds`
    然后乘以 1,000 并不是必需的，但它有助于使我们的代码更易读。
- en: The `moles` atom will be a vector of maps with `:status` and `:remaining-millis`
    fields. Why type out five identical maps when `repeat` can do the work for us?
    Later, we'll update the moles using their index in the vector, which is why we
    really want to have a vector here, and not a list. By itself, `repeat` would return
    a simple list. To avoid that, we use `(into [] …)` to be sure we have a real vector.
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`moles` 原子将是一个包含 `:status` 和 `:remaining-millis` 字段的映射向量。为什么需要写出五个相同的映射，当 `repeat`
    可以为我们完成这项工作呢？稍后，我们将使用向量中的索引更新地鼠，这就是为什么我们真的想要一个向量，而不是一个列表。`repeat` 本身会返回一个简单的列表。为了避免这种情况，我们使用
    `(into [] …)` 来确保我们有一个真正的向量。'
- en: 'Another equally valid approach would be to wrap all of these items in a single
    atom that could be structured like this:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种同样有效的方法是将所有这些项包裹在一个单一的原子中，其结构可以像这样：
- en: '[PRE191]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This approach would mean changing most of the functions involving data access
    but would not fundamentally change how the game is built.
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法意味着更改涉及数据访问的大多数函数，但不会从根本上改变游戏的构建方式。
- en: Note
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Generally, in more complex applications, the single atom approach would be preferable.
    The downside to this is that any change to the atom would cause all the components
    to update. If only one part of the multi-level map contained in the atom has changed,
    many of these updates would be useless. To avoid this, React-based ClojureScript
    frameworks all have some means for tracking changes to only one part of the application
    state atom. Rum, as well as Om and Reagent, calls these cursors. A cursor allows
    a component to listen to a particular part of the atom state, thus avoiding unnecessary
    re-renders when unrelated parts of the atom change.
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，在更复杂的应用中，单一原子方法会更受欢迎。这种方法的缺点是，对原子的任何更改都会导致所有组件更新。如果原子包含的多级映射中只有一部分发生了变化，那么许多这些更新都是无用的。为了避免这种情况，基于
    React 的 ClojureScript 框架都有一些方法来跟踪应用程序状态原子中仅一部分的变化。Rum、Om 和 Reagent 都将这些游标称为游标。游标允许组件监听原子状态的特定部分，从而在原子中不相关的部分发生变化时避免不必要的重新渲染。
- en: 'Define functions for making changes to the application state atoms:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于更改应用程序状态原子的函数：
- en: '[PRE192]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The first two functions are fairly straightforward. `activate-mole` uses `update`
    instead of `assoc` in order to test whether the mole is already activated or not.
    If it is already `:live`, we don''t want to change the number of remaining milliseconds
    back to 3,000:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前两个函数相当直接。`activate-mole` 使用 `update` 而不是 `assoc` 来测试地鼠是否已经被激活。如果它已经是 `:live`，我们不想将剩余的毫秒数改回
    3,000：
- en: '[PRE193]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: These functions are the heart of the game's logic.
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些函数是游戏逻辑的核心。
- en: The first function, `mole-countdown`, removes 100 from the `:remaining-millis`
    field of any active moles. To do this, it maps over the list of moles. If a mole
    is not `:live`, it is left alone. (We can't use `filter` here because we don't
    want to eliminate the inactive moles; we only want to ignore them.) If the mole
    is `:live`, we subtract 100 from the remaining time. If there is still time left,
    we just update the remaining time in the mole. If we've reached zero, though,
    we set the status back to `:waiting`. This is the case when the player has not
    clicked on the mole after 3 seconds.
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数 `mole-countdown` 从任何活跃地鼠的 `:remaining-millis` 字段中减去 100。为此，它映射地鼠列表。如果一个地鼠不是
    `:live`，它就会被忽略。（我们在这里不能使用 `filter`，因为我们不想消除非活跃的地鼠；我们只想忽略它们。）如果一个地鼠是 `:live`，我们就从剩余时间中减去
    100。如果还有时间剩余，我们只需更新地鼠的剩余时间。如果我们达到了零，那么我们将状态改回 `:waiting`。这是玩家在 3 秒内没有点击地鼠的情况。
- en: The next function, `update-moles`, will be called on each 100-millisecond tick
    of the game clock. It calls `mole-countdown` and then checks whether there are
    enough active moles in the list. If there aren't two active moles, `activate-mole`
    is called with a random index between 0 and 4.
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个函数 `update-moles` 将在游戏时钟的每个 100 毫秒滴答时被调用。它调用 `mole-countdown` 然后检查列表中是否有足够的活跃地鼠。如果没有两个活跃的地鼠，则使用介于
    0 和 4 之间的随机索引调用 `activate-mole`。
- en: You might be surprised that we don't check to see whether the mole we are activating
    here is already `:live` or not. Because this check will happen every 100 milliseconds
    (and because the gameplay of Whack-a-mole doesn't require extreme precision),
    we can avoid doing so. If we try to activate an already active mole, nothing will
    happen (thanks to how we wrote `activate-mole`) and we can try again on the next
    clock tick.
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会惊讶我们没有检查我们正在激活的地鼠是否已经是 `:live`。因为这项检查将每 100 毫秒发生一次（而且 Whack-a-mole 的游戏玩法不需要极端的精度），我们可以避免这样做。如果我们尝试激活一个已经激活的地鼠，什么也不会发生（多亏了我们如何编写
    `activate-mole`），我们可以在下一次时钟滴答声时再次尝试。
- en: The `reset-moles` function will be called when the game clock gets to zero.
    All the moles hide when the game is over.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当游戏时钟到达零时，将调用 `reset-moles` 函数。游戏结束后，所有地鼠都会隐藏。
- en: Finally, the `whack!` function will actually be the click handler. It looks
    up the mole by its index and then calls `deactivite-mole` if the mole happens
    to be `:live`, in which case it also adds a point to the player's score.
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`whack!` 函数实际上是点击处理程序。它通过索引查找地鼠，然后如果地鼠恰好是 `:live`，则调用 `deactivite-mole`，在这种情况下，它还会给玩家的分数加一分。
- en: It's important to note here that all of these functions interact directly with
    the atoms. They all use `deref` (via the `@` reader macro) and not `rum/react`.
    All of this logic, so far, is independent of the Rum components.
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的是，所有这些函数都是直接与原子交互的。它们都使用 `deref`（通过 `@` 读取宏）而不是 `rum/react`。到目前为止，所有这些逻辑都与
    Rum 组件无关。
- en: 'Write the game clock functions:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写游戏时钟函数：
- en: '[PRE194]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The `clock-tick` function determines what happens every 100 milliseconds. Either
    the game is over (`millis-remaining` has reached zero) or it is still going. If
    the game is over, we reset the moles and change the game state back to `:waiting`.
    If not, we call `update-moles` to advance their internal time counters and then
    we advance the global `millis-remaining` atom.
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clock-tick` 函数确定每 100 毫秒发生什么。游戏要么结束（`millis-remaining` 达到零），要么仍在进行。如果游戏结束，我们将重置地鼠并更改游戏状态回
    `:waiting`。如果没有，我们调用 `update-moles` 来推进它们的内部时间计数器，然后推进全局的 `millis-remaining` 原子。'
- en: The `start-clock` function does just that. The first step here is to check for
    an existing interval and stop it. We definitely don't want more than one interval
    running at the same time. (If you notice the clock running at a very fast rate,
    that is probably what is happening.)
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start-clock` 函数正是如此。这里的第一个步骤是检查是否存在现有的间隔并将其停止。我们绝对不希望同时运行多个间隔。（如果你注意到时钟以非常快的速度运行，那可能就是原因。）'
- en: Our call to `swap!` is then just a call to `setInterval` with the `clock-tick`
    function and the 100-millisecond interval.
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `swap!` 调用实际上是一个带有 `clock-tick` 函数和 100 毫秒间隔的 `setInterval` 调用。
- en: 'Now we''re ready to write our `start-game` function that will be called when
    the user clicks on the `Start` button:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备编写 `start-game` 函数，该函数将在用户点击“开始”按钮时被调用：
- en: '[PRE195]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Let''s start writing some simple Rum components that just display the current
    state:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始编写一些简单的 Rum 组件，它们只是显示当前状态：
- en: '[PRE196]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The `clock` and `score` views simply display those values. Since we don''t
    want to actually display milliseconds on the clock, we divide by 1,000\. And since
    we don''t want show times like 5.034, we round down using the `floor` method from
    the JavaScript `Math` library. (Don''t worry if you don''t know about this JavaScript
    library: displaying milliseconds works fine for this exercise.)'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clock` 和 `score` 视图简单地显示这些值。由于我们不想在时钟上实际显示毫秒数，所以我们将其除以 1,000。而且，我们不想显示像 5.034
    这样的时间，所以我们使用 JavaScript `Math` 库中的 `floor` 方法向下取整。（如果你不知道这个 JavaScript 库也不要担心：在这个练习中显示毫秒数是可行的。）'
- en: 'Write a component for the `start-game` button:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `start-game` 按钮的组件：
- en: '[PRE197]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The `start-game-button` view observes the `game-state` atom and shows either
    a `Click to play!` button or an encouraging message.
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start-game-button` 视图会观察 `game-state` 原子，并显示一个“点击开始！”按钮或一条鼓励信息。'
- en: 'Write the mole views:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写地鼠视图：
- en: '[PRE198]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: A lot of important game logic is related to the moles, so we split out a separate
    `mole` component. Notice that `single-mole-view` does not have the `< rum/reactive`
    mixin. These views will get all of their props from their parent view. As a result,
    they do not need to react directly to changes in the atoms; they will receive
    the changes through their arguments.
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多重要的游戏逻辑与地鼠相关，因此我们将其拆分为一个单独的 `mole` 组件。请注意，`single-mole-view` 没有使用 `< rum/reactive`
    混合。这些视图将从其父视图获取所有属性。因此，它们不需要直接对原子的变化做出反应；它们将通过参数接收变化。
- en: The `single-mole-view` displays the state of the mole, `:waiting` or `:live`,
    and sets up the click handler. We've set up the `whack!` function to do nothing
    if the mole's status is `:waiting`, so we don't have to add any logic about that
    here.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`single-mole-view` 显示地鼠的状态，`:waiting` 或 `:live`，并设置点击处理程序。我们已将 `whack!` 函数设置为在地鼠状态为
    `:waiting` 时不做任何事情，因此我们在这里不需要添加任何关于这个状态的逻辑。'
- en: The `moles-view` simply wraps the calls to `single-mole-view` in a `<div>` element
    and provides them with the appropriate data from the `moles` atom.
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`moles-view` 简单地在一个 `<div>` 元素中包装对 `single-mole-view` 的调用，并从 `moles` 原子提供适当的数据。'
- en: 'Write the base view:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写基本视图：
- en: '[PRE199]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The `app` view simply reunites all the previous views in a single while providing
    some additional presentation.
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app` 视图简单地将所有先前的视图重新组合在一起，同时提供一些额外的展示。'
- en: 'Make sure that you the `app` view is mounted at the end of your file:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的 `app` 视图在文件末尾挂载：
- en: '[PRE200]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The call to `on-js-reload` ensures that your code is read again when the browser reloads.
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用 `on-js-reload` 确保在浏览器重新加载时再次读取你的代码。
- en: 'Now you can play the game!:'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你可以玩游戏了！：
- en: '![Figure 12.27: Playing DOM Whack-a-mole'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.27：玩 DOM Whack-a-mole'
- en: '](img/B14502_12_27.jpg)'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_27.jpg)'
- en: 'Figure 12.27: Playing DOM Whack-a-mole'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.27：玩 DOM Whack-a-mole
- en: 13\. Database Interaction and the Application Layer
  id: totrans-673
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 数据库交互和应用层
- en: 'Activity 13.01: Persisting Historic Tennis Results and ELO Calculations'
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 13.01：持久化历史网球结果和 ELO 计算
- en: 'Solution:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'In a new project, begin with the following dependencies:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的项目中，从以下依赖项开始：
- en: '[PRE201]'
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'In our `src` directory, create the following namespaces:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `src` 目录中，创建以下命名空间：
- en: '[PRE202]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Creating our connection pool in the database namespace is straightforward using `hikari`:'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库命名空间中使用 `hikari` 创建我们的连接池非常简单：
- en: '[PRE203]'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Our DDL should look similar to the following. Field data types may vary, although
    not significantly:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 DDL 应该看起来类似于以下内容。字段数据类型可能不同，尽管变化不大：
- en: '[PRE204]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Leveraging `clojure.java.jdbc`, we can apply the schema, taking care of the ordering:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用 `clojure.java.jdbc`，我们可以应用模式，注意排序：
- en: '[PRE205]'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: This is perhaps one of the more creative aspects of the activity, meaning that
    there are many ways to solve the problem, with the following only being one of
    them.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可能是这个活动的更具创造性的方面之一，这意味着有多种方法可以解决这个问题，以下只是其中之一。
- en: 'In the `parse` namespace, we begin by defining the accessors required to extract
    each of the fields we''re interested in:'
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `parse` 命名空间中，我们首先定义了提取我们感兴趣的每个字段所需的访问器：
- en: '[PRE206]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Each preceding definition is a map of `target-key` (that is, where we want to
    store the value in our data structure) to `accessor` (that is, a single-arity
    function that, given a row, will extract, format, and aggregate fields as required).
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个先前的定义都是一个 `target-key`（即，我们想在数据结构中存储值的位置）到 `accessor`（即，一个单参数函数，给定一个行，将提取、格式化和聚合字段，如所需）的映射。
- en: 'We can then define a function that will perform the application of these accessors
    on any given row:'
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个函数，该函数将对任何给定的行执行这些访问器的应用：
- en: '[PRE207]'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Some well-named helper functions can be defined to perform the extraction for
    each of our target structures, which are combined in a simple `parse-row` function:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以定义一些命名良好的辅助函数来执行每个目标结构的提取，这些结构在简单的 `parse-row` 函数中组合：
- en: '[PRE208]'
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Finally, we can combine these into our historic function as follows, adding
    the relevant requires:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将这些组合到我们的历史函数中，如下所示，添加相关的 `requires`：
- en: '[PRE209]'
  id: totrans-695
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The `reduce` function we''ve defined here begins by parsing the incoming row
    into the three target data structures we''re interested in: the players (`winning`
    and `losing`) as well as the match itself. We then check to ensure we''re only
    going to persist a player if we''ve not already seen it. We do this by checking
    against the `player-ids-seen` set using the appropriately named `helper` function.'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义的 `reduce` 函数首先将传入的行解析为三个我们感兴趣的目标数据结构：玩家（`winning` 和 `losing`）以及比赛本身。然后我们检查确保我们只会在我们没有看到过玩家的情况下持久化玩家。我们通过使用命名适当的
    `helper` 函数与 `player-ids-seen` 集合进行检查来完成此操作。
- en: Finally, we use the thread-first macro to maintain our accumulator, adding new
    players/matches and maintaining the set of player IDs we've already processed,
    before extracting the `:data` portion of the map and returning.
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们使用 thread-first 宏来维护我们的累加器，添加新的玩家/比赛，并维护我们已经处理过的玩家 ID 集合，在提取映射的 `:data`
    部分之前。
- en: 'In the `ingest` namespace, a simple call to `parse/historic`, along with a
    destructure in our `let` binding, is enough to extract the players and matches
    we are going to insert into the `db` variable:'
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ingest`命名空间中，一个简单的`parse/historic`调用，以及在我们的`let`绑定中的解构，就足以提取我们将要插入到`db`变量中的玩家和比赛：
- en: '[PRE210]'
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Having taken the `match_scores_1991-2016_unindexed_csv.csv` file and placed
    it in the `resources` directory, we can now ingest our historic data and perform
    a few sanity checks to see whether our `player` and `tennis_match` counts match
    those as follows:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`match_scores_1991-2016_unindexed_csv.csv`文件放入`resources`目录后，我们现在可以摄取我们的历史数据，并执行一些基本检查，以查看我们的`player`和`tennis_match`计数是否如下匹配：
- en: '[PRE211]'
  id: totrans-701
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'The SQL to extract all tennis matches in the `query` namespace is fairly straightforward;
    however, attention should be drawn to the `round_order desc`. Since `round_order`
    *decreases* as the tournament progresses, we must sort this into reverse order:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`query`命名空间中提取所有网球比赛的SQL相当简单；然而，应注意`round_order desc`。由于`round_order`随着比赛的进行而*减少*，我们必须将其排序为逆序：
- en: '[PRE212]'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Leveraging our functions from *Chapter 5*, *Many to One: Reducing*, our `elo`
    namespace starts off as follows:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用我们的*第5章*中的函数*多对一：减少*，我们的`elo`命名空间开始如下：
- en: '[PRE213]'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Calculating the ELO rating for all matches can be achieved as follows. First,
    we can define two helper functions, the first of which yields a tuple of expected
    outcomes.  Since probabilities must sum to 1, we can calculate one probability
    and then subtract it from 1 to get the other probability:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算所有比赛的ELO评分可以如下实现。首先，我们可以定义两个辅助函数，第一个函数产生预期结果的元组。由于概率必须加起来为1，我们可以计算一个概率，然后从1中减去以得到另一个概率：
- en: '[PRE214]'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'We then destructure the tuple in the body of our second helper function, which
    allows us to calculate the new ratings for each player returning an updated player
    data structure that is destructured in `calculate-all`:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在第二个辅助函数的主体中解构元组，这使得我们可以计算每个玩家的新的评分，并返回一个在`calculate-all`中解构的更新后的玩家数据结构：
- en: '[PRE215]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Finally, we destructure the result of the call to `calculate-new-ratings`,
    extracting the `winner` and `loser` IDs so that we can update the `current-player-ratings`
    data structure for the next iteration:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们解构调用`calculate-new-ratings`的结果，提取`winner`和`loser` ID，以便我们可以更新下一次迭代的`current-player-ratings`数据结构：
- en: '[PRE216]'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Using `winner_id` and `loser_id` for the current match, we can look up their
    existing ratings in our accumulator (defaulting to `1000`) if they're not found.
    Next, we determine the expected outcomes using the function described previously.
    Once we have that, we can plug this into the `recalculate-rating` function and
    store the updated values in our accumulator for the next iteration.
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用当前比赛的`winner_id`和`loser_id`，如果它们在累加器（默认为`1000`）中找不到，我们可以查找它们现有的评分。接下来，我们使用之前描述的函数确定预期的结果。一旦我们有了这些，我们就可以将其插入到`recalculate-rating`函数中，并将更新的值存储在累加器中，以便下一次迭代。
- en: '`current-player-rating` is effectively an in-memory cache; we would not want
    to persist ratings to the database only to look them up again.'
  id: totrans-713
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`current-player-rating`实际上是一个内存缓存；我们不想只为了再次查找而将评分持久化到数据库中。'
- en: 'It is also more performant to do a single call to `jdbc/insert-multi!` in the
    `persist-all` function than it is to persist as we go:'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`persist-all`函数中执行单个`jdbc/insert-multi!`调用比边持久化更高效：
- en: '[PRE217]'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'The SQL required to extract all names and ratings is straightforward. Bolting
    on a `result-set-fn` function that iterates over the results one at a time is
    straightforward and intuitive, if less performant than a raw SQL approach:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取所有名称和评分所需的SQL相当简单。附加一个`result-set-fn`函数，该函数逐个遍历结果，直观且简单，尽管比原始SQL方法效率低：
- en: '[PRE218]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: We begin by defining the maximum rating as the smallest integer, guaranteeing
    that it won't end up featuring in our final result!  A simple comparison of the
    existing highest rating with the candidate rating allows us to determine whether
    we update our accumulator using the conditional thread-first macro.
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先定义最大评分为最小的整数，保证它不会出现在我们的最终结果中！通过简单比较现有最高评分与候选评分，我们可以确定是否使用条件线程首先宏更新我们的累加器。
- en: 'Finally, let''s confirm that the player with the highest ELO value matches
    what was expected:'
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们确认具有最高ELO值的玩家是否符合预期：
- en: '[PRE219]'
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Excellent! We've successfully built an application layer allowing us to ingest,
    query, and perform calculations on our large tennis results CSV dataset. Anyone
    new to the application should be able to grasp the purpose of it from the namespaces
    alone. The intention of each individual function, when taken in the context of
    the namespace, should also be clear.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经成功构建了一个应用层，使我们能够摄取、查询和计算我们的大型网球结果CSV数据集。任何新加入应用的人应该能够仅从命名空间中理解其目的。在命名空间上下文中，每个单独函数的意图也应该清晰。
- en: 14\. HTTP with Ring
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. HTTP与Ring
- en: 'Activity 14.01: Exposing Historic Tennis Results and ELO Calculations via REST'
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十四点零一：通过REST公开历史网球结果和ELO计算
- en: 'Solution:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Add the following dependencies to `packt-clj.tennis` in the `deps.edn` file:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`packt-clj.tennis`的`deps.edn`文件中添加以下依赖项：
- en: '[PRE220]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Create our namespace with the following `require` route:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`require`路由创建我们的命名空间：
- en: '[PRE221]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The routes required to expose our player resources and the tennis matches they''ve
    taken part in are as follows:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于公开我们的球员资源和他们参与的网球比赛的所需路由如下：
- en: '[PRE222]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The `query` functions referenced are defined in the `query` namespace like
    so:'
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考的`query`函数定义在`query`命名空间中，如下所示：
- en: '[PRE223]'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Our `run` function looks similar to that we''ve used before, leveraging the
    `wrap-format` and `wrap-params` middleware:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`run`函数看起来与我们之前使用的相似，利用了`wrap-format`和`wrap-params`中间件：
- en: '[PRE224]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'We can add the following route to our `players` context for ELO retrieval,
    along with the means to extract it from our `query` namespace:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`players`上下文中添加以下路由以检索ELO，以及从我们的`query`命名空间中提取它的方法：
- en: '[PRE225]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Define a new `tennis-matches` context, along with the new `query/tennis-match`
    function:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的`tennis-matches`上下文，以及新的`query/tennis-match`函数：
- en: '[PRE226]'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Optionally, if starting from a clean database, we can populate it with relevant
    data using the following:'
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选地，如果我们从一个干净的数据库开始，我们可以使用以下方式填充相关数据：
- en: '[PRE227]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'After starting the web server, we can use a browser to retrieve the current
    ELOs for reference:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Web服务器后，我们可以使用浏览器检索当前的ELO作为参考：
- en: '[PRE228]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'The output is as follows:'
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.22: Printing Sampras'' current rating'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.22：打印Sampras的当前评级'
- en: '](img/B14502_14_22.jpg)'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_14_22.jpg)'
- en: 'Figure 14.22: Printing Sampras'' current rating'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.22：打印Sampras的当前评级
- en: 'Printing the current rating of `Djokovic`:'
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印`Djokovic`的当前评级：
- en: '![Figure 14.23: Printing Djokovic''s current rating'
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.23：打印Djokovic的当前评级'
- en: '](img/B14502_14_23.jpg)'
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_14_23.jpg)'
- en: 'Figure 14.23: Printing Djokovic''s current rating'
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.23：打印Djokovic的当前评级
- en: 'We define our `tennis-match` creation route using `PUT` since we know the ID
    ahead of time. This is added to the `tennis-matches` context. We must query the
    ELO of the two players involved in the match, then create a new record for each
    of them with their updated ELO. This requires a new `ingest/tennis-match` and
    `elo/persist` functions, as shown. Note that the `elo/calculate-new-ratings` function
    should now be marked as public (`defn` rather than `defn-`) now that we require
    it outside of the `elo` namespace:'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`PUT`定义我们的`tennis-match`创建路由，因为我们事先知道ID。这被添加到`tennis-matches`上下文中。我们必须查询比赛中涉及的两个球员的ELO，然后为每个球员创建一个新的记录，并更新他们的ELO。这需要一个新的`ingest/tennis-match`和`elo/persist`函数，如下所示。注意，由于我们现在需要在`elo`命名空间外使用它，`elo/calculate-new-ratings`函数现在应标记为公共的（使用`defn`而不是`defn-`）：
- en: '[PRE229]'
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: (.stop app)
  id: totrans-753
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (.stop app)
- en: (def app (api/run))
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (def app (api/run))
- en: (require '[clj-http.client :as http])
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (require '[clj-http.client :as http])
- en: (http/put "http://localhost:8080/tennis-matches/2019-1-d643-s403-5"
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (http/put "http://localhost:8080/tennis-matches/2019-1-d643-s403-5"
- en: '{:body (pr-str {:tournament_year  2019,'
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{:body (pr-str {:tournament_year  2019,'
- en: :tournament       "umag",
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: :tournament       "umag",
- en: :tournament_order 1,
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: :tournament_order 1,
- en: :round_order      5,
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: :round_order      5,
- en: :match_order      1,
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: :match_order      1,
- en: :winner_id        "d643",
  id: totrans-762
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: :winner_id        "d643",
- en: :loser_id         "s402"})})
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: :loser_id         "s402"})})
- en: '[PRE230]'
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Since Sampras lost our fictitious match, we see his ELO decrease slightly,
    while Djokovic''s has increased:![Figure 14.24: Printing Sampras'' rating'
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Sampras在我们的虚构比赛中输了，我们看到他的ELO略有下降，而Djokovic的ELO有所上升：![图14.24：打印Sampras的评级
- en: '](img/B14502_14_24.jpg)'
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_14_24.jpg)'
- en: 'Figure 14.24: Printing Sampras'' rating'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.24：打印Sampras的评级
- en: 'Following are Djokovic''s ratings:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Djokovic的评级：
- en: '![Figure 14.25: Printing Djokovic''s current rating'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.25：打印Djokovic的当前评级'
- en: '](img/B14502_14_25.jpg)'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_14_25.jpg)'
- en: 'Figure 14.25: Printing Djokovic''s current rating'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.25：打印Djokovic的当前评级
- en: Thus, by completing this activity, we have made our application layer more widely
    available via a REST web service.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过完成这个活动，我们已经通过REST Web服务使我们的应用层更广泛地可用。
- en: '15\. The Frontend: A ClojureScript UI'
  id: totrans-773
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. 前端：ClojureScript UI
- en: 'Activity 15.01: Displaying a Grid of Images from the Internet'
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.01：从互联网显示图片网格
- en: 'Solution:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'At the command-line prompt, create a new Figwheel project using the following
    Leiningen command:'
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行提示符下，使用以下Leiningen命令创建一个新的Figwheel项目：
- en: '[PRE231]'
  id: totrans-777
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Move to the `packt-clj.images/` directory and type:'
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`packt-clj.images/`目录并输入：
- en: '[PRE232]'
  id: totrans-779
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  id: totrans-780
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几秒钟后，你的浏览器应该会打开默认的Figwheel页面：
- en: '![Figure 15.8: A fresh ClojureScript project waiting for your code'
  id: totrans-781
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.8：一个等待你编写代码的新鲜ClojureScript项目'
- en: '](img/B14502_15_08.jpg)'
  id: totrans-782
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_15_08.jpg)'
- en: 'Figure 15.8: A fresh ClojureScript project waiting for your code'
  id: totrans-783
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.8：一个等待你编写代码的新鲜ClojureScript项目
- en: 'Open the `src/packt_clj/images/core.cljs` file in your preferred editor and
    modify the code:'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的编辑器中打开`src/packt_clj/images/core.cljs`文件并修改代码：
- en: '[PRE233]'
  id: totrans-785
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The commonly used alias for Reagent is `r` instead of Reagent:'
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reagent常用的别名是`r`而不是Reagent：
- en: '[PRE234]'
  id: totrans-787
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'The `app-state` is made of two pieces of data: a vector of images that we fetched,
    initially an empty vector, and whether to display the author''s name, initially
    true.'
  id: totrans-788
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app-state`由两部分数据组成：我们获取的图片向量，最初是一个空向量，以及是否显示作者姓名，最初为true。'
- en: 'Let''s create a button that fetches images from the HTTP endpoint and updates
    the `:images` value of the `app-state`. We need two handlers: `fetch-images`,
    which updates `:images` in the `app` state with a vector of images, and `clear-images`,
    which updates `:images` in the `app` state with an empty vector:'
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个按钮，从HTTP端点获取图片并更新`app-state`中的`:images`值。我们需要两个处理器：`fetch-images`，它将图片向量更新到`app`状态中的`:images`，以及`clear-images`，它将空向量更新到`app-state`中的`:images`：
- en: '[PRE235]'
  id: totrans-790
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'And here is the code for the `fetch-or-clear-button` component:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是`fetch-or-clear-button`组件的代码：
- en: '[PRE236]'
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'We apply the `btn` class to the button by using the `:button.btn` short Hiccup
    syntax. The `btn` class is defined in `resources/public/css/style.css`:'
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用`:button.btn`简短的Hiccup语法将`btn`类应用到按钮上。`btn`类在`resources/public/css/style.css`中定义：
- en: '[PRE237]'
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Let''s build an `image` component and an `image-grid` component:'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建一个`image`组件和一个`image-grid`组件：
- en: '[PRE238]'
  id: totrans-796
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'The last component is a button that hides or displays author names:'
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个组件是一个按钮，可以隐藏或显示作者姓名：
- en: '[PRE239]'
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Now, we add all the components as children of the `main` component. We renamed
    the `hello-world` function `app`:'
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将所有组件作为`main`组件的子组件添加。我们将`hello-world`函数重命名为`app`：
- en: '[PRE240]'
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Finally, we render the main component (named `app` instead of `hello-world`):'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染主组件（命名为`app`而不是`hello-world`）：
- en: '[PRE241]'
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'If everything went well, you should see a screen like this:'
  id: totrans-803
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到一个像这样的屏幕：
- en: '![Figure 15.9: Buttons to fetch and clear images'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.9：获取和清除图片的按钮'
- en: '](img/B14502_15_09.jpg)'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_15_09.jpg)'
- en: 'Figure 15.9: Buttons to fetch and clear images'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：获取和清除图片的按钮
- en: 'When you click on the `Fetch Images` button, the images appear with authors''
    names:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“获取图片”按钮时，图片会显示作者的姓名：
- en: '![Figure 15.10: Fetching the images'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10：获取图片'
- en: '](img/B14502_15_10.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_15_10.jpg)'
- en: 'Figure 15.10: Fetching the images'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：获取图片
- en: 'Finally, when you click on the `Hide author` button, the authors'' names disappear:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你点击“隐藏作者”按钮时，作者姓名会消失：
- en: '![Figure 15.11: Hiding the authors'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11：隐藏作者信息'
- en: '](img/B14502_15_11.jpg)'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_15_11.jpg)'
- en: 'Figure 15.11: Hiding the authors'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：隐藏作者信息
- en: Here, we have created a single-page application that can load and clear images
    and text as required.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个单页应用程序，可以按需加载和清除图片和文本。
- en: 'Activity 15.02: Tennis Players with Ranking'
  id: totrans-816
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.02：带排名的网球运动员
- en: 'Solution:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'At the command-line prompt, create a new Figwheel project using the following
    Leiningen command:'
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行提示符下，使用以下Leiningen命令创建一个新的Figwheel项目：
- en: '[PRE242]'
  id: totrans-819
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Move to the `packt-clj.tennis/` directory and type the following:'
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`packt-clj.tennis/`目录并输入以下命令：
- en: '[PRE243]'
  id: totrans-821
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  id: totrans-822
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几秒钟后，你的浏览器应该会打开默认的Figwheel页面：
- en: '![Figure 15.12: A fresh ClojureScript project waiting for your code'
  id: totrans-823
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.12：一个等待你编写代码的新鲜ClojureScript项目'
- en: '](img/B14502_15_12.jpg)'
  id: totrans-824
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_15_12.jpg)'
- en: 'Figure 15.12: A fresh ClojureScript project waiting for your code'
  id: totrans-825
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.12：一个等待你编写代码的新鲜ClojureScript项目
- en: 'Open the `src/packt_clj/tennis/core.cljs` file in your preferred editor and
    modify the code:'
  id: totrans-826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的编辑器中打开`src/packt_clj/tennis/core.cljs`文件并修改代码：
- en: '[PRE244]'
  id: totrans-827
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '`app-state` consists of the list of players and the details about the currently
    selected player.'
  id: totrans-828
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app-state`由玩家列表和当前选中玩家的详细信息组成。'
- en: 'We start with an empty list of players:'
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个空的玩家列表开始：
- en: '[PRE245]'
  id: totrans-830
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Here is the code that fetches the ranking data from the server about a specific
    player:'
  id: totrans-831
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是获取特定玩家服务器上排名数据的代码：
- en: '[PRE246]'
  id: totrans-832
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Here is a player component that displays the name of a player and their ranking:'
  id: totrans-833
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个显示玩家名称和排名的玩家组件：
- en: '[PRE247]'
  id: totrans-834
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Let''s create a button that clears the current player and goes back to the
    list of all the players:'
  id: totrans-835
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个按钮，用于清除当前玩家并返回所有玩家的列表：
- en: '[PRE248]'
  id: totrans-836
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'Let''s write the code for the list of players. We start by writing a component
    for an element of the list. The content is the name of the player. When we click
    on it, it fetches the ranking data about the selected player:'
  id: totrans-837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写玩家列表的代码。我们首先编写列表元素的组件。内容是玩家的名称。当我们点击它时，它会获取所选玩家的排名数据：
- en: '[PRE249]'
  id: totrans-838
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'We now build the `player-list` component. It receives a vector of players and
    returns a `:div` that contains a player component for each player:'
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在构建 `player-list` 组件。它接收一个玩家向量，并返回一个包含每个玩家组件的 `:div`：
- en: '[PRE250]'
  id: totrans-840
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'This is the code for the function that fetches the players data from the server:'
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是获取玩家数据的函数代码：
- en: '[PRE251]'
  id: totrans-842
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'We also need a function that clears the list of players by modifying `app-state`:'
  id: totrans-843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个函数，通过修改 `app-state` 来清除玩家列表：
- en: '[PRE252]'
  id: totrans-844
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Now we add a button that either clears or fills the list of players:'
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加一个按钮，该按钮可以清除或填充玩家列表：
- en: '[PRE253]'
  id: totrans-846
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Now, we write the `main` component. When the value associated to `:current-player`
    is not `nil`, we display the currently selected player. Otherwise, we display
    a list of players. This is the code for the main `app` component:'
  id: totrans-847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们编写 `main` 组件。当与 `:current-player` 关联的值不是 `nil` 时，我们显示当前选定的玩家。否则，我们显示玩家列表。这是主
    `app` 组件的代码：
- en: '[PRE254]'
  id: totrans-848
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Finally, we render the main component:'
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染主组件：
- en: '[PRE255]'
  id: totrans-850
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'By completing the activities, we have seen how to organize the different components
    of a Reagent application: the CSS, HTML, and `cljs` files. Being able to iteratively
    modify the code and have the web page immediately update without any page refresh
    was helpful and time-saving. We learned how to store the state of the app in a
    ratom and access the state for the code of the Reagent components.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这些活动，我们了解了如何组织试剂应用程序的不同组件：CSS、HTML 和 `cljs` 文件。能够迭代修改代码，并且网页能够立即更新而不需要刷新页面，这对我们来说非常有帮助，并且节省了时间。我们学习了如何在
    ratom 中存储应用程序的状态，并访问 Reagent 组件的代码状态。
