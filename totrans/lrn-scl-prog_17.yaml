- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Describe two ways to make it possible for some resource, `R`**, **to be used
    together with the `scala.util.Using` resource management utility.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let `R` extend `java.lang.AutoCloseable`. This will allow existing implicit
    conversion from `AutoCloseable` into `Resource` to be applied to `R`.
  prefs: []
  type: TYPE_NORMAL
- en: Provide an implicit implementation of `Resource[R]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can** `Set` **and** `List` **be compared?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Equality is not defined between `Set` and `List`, hence we have to use the `sameElements`
    method in one of two ways, directly on `List` or on the iterator of `Set`, as
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possibility is to utilize the `corresponds` operation in combination
    with the equality checking function. This works similar in either direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Name the default concrete implementation for an immutable** `Seq`**.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`scala.collection.immutable.List`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name the default concrete implementation for an immutable indexed** `Seq`**.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`scala.collection.immutable.Vector`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name the default concrete implementation for a mutable** `Seq`**.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`scala.collection.mutable.ArrayBuffer`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name the default concrete implementation for a mutable** `IndexedSeq`**.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`scala.collection.mutable.ArrayBuffer`'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is sometimes said that** `List.flatMap` **is more powerful than it is
    expected to be. Can you try to explain why? **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`flatMap` is defined on `IterableOnce` and hence takes a function returning
    `IterableOnce` as its argument. Because of this, it is possible to mix different
    types while `flatMap` pings. Consider the following example where `List` is able
    to `flatMap` the collection with `Set[Int]` and  as its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Describe a way to map over a collection multiple times using different functions
    but without producing intermediate collections.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a view, map over the view as required, and force conversion back to
    the original representation type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Which type constraints can you name?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two constraints: the lower bound or subtype relation and the upper
    bound or supertype relation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What implicit type constraints are added to a type if there are no type constraints
    defined on it by the developer?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For missing upper bound, the compiler adds `Any` as a constraint, and, for missing
    lower bound–`Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which operators can be used to refer to the nested type of some type?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two operators. The notion `A#B` refers to the nested type of the `A` type.
    The notion of `a.B` refers to the `B` subtype of the instance `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which type can be used as an infix type?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any type which is parameterized by exactly two type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is the use of structural types discouraged in Scala?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use of structural types often leads to generated byte code, which accesses methods
    via reflection, which is slower than normal method calls.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is expressed via variance?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The correlation between subtyping relations of parameterized and parameterizing types.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What will be a type of the following function in curried form: `(Int, String)
    => (Long, Boolean, Int) => String`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Int => (String => ((Long, Boolean, Int) => String))` or simplified `Int =>
    String => (Long, Boolean, Int) => String`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the difference between a partially applied function and a partial
    function.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A partial function is not defined for some of the possible input values. A partially
    applied function has some of its parameters fixed to specific values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Define a signature and implement a function, `uncurry`**, **for a curried
    function of three arguments, `A => B => C => R`**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`def uncurry[A,B,C,R](in: A => B => C => R): (A,B,C) => R = (a,b,c) => in(a)(b)(c)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement a head-recursive function for the factorial calculation (n! = n
    * (n-1) * (n-2) * ... * 1.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`def factorial(n: Long): Long = if (n < 2) n else n * factorial(n-1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement a tail-recursive function for a factorial calculation.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement a recursive function for a factorial calculation using trampolining.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Describe a case where an implicit parameter is also an implicit conversion.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the case if an implicit parameter is a function: `def func[A, T](a:
    A)(implicit adapter: A => T): T  = adapter(a)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Replace the following definition that uses view bounds with one using context
    bounds: `def compare[T <% Comparable[T]](x: T, y: T) = x < y`**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Why are type classes sometimes said to separate behavior and data?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because type class instances define logic to work and the data comes from the
    values the type class is applied to.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to change the example of possible conflicts in lexical scope so
    that one of the implicits wins over others and all others can be uncommented without
    having conflicts anymore. Make this change. For example, it can be done by changing
    one of the definitions of `val`s to the definition of an `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, the TSO will be more specific than the rest of the values because of static
    resolution rules and will be selected by the compiler for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Define an invariant property for sorting a list.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Define an idempotent property for sorting a list.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Define an inductive property for sorting a list.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Define a generator for `List[Lists[Int]]` so that elements of the nested
    list are positive.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Define a generator for `Map[UUID, () => String].`**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Please note that `Gen.function0` generates a function of zero arguments that
    just return random values generated by the provided generator.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What would be the proper effect to represent getting each of the following:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The first element of some** `List`: `Option[?]` with `None` representing
    an empty list does not have a head element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A list of tweets**: `Future[List[Tweet]]` as the operation will probably
    take some time as it goes over the network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User information from the database for a given** `userId`: `Future[Option[?]]`
    with `Future` denoting the network call and `Option` denoting no user account
    for a given `userId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is a range of possible values of the following expression:** `Option(scala.util.Random.nextInt(10)).fold(9)(_-1) `'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An inclusive [-1;9]
  prefs: []
  type: TYPE_NORMAL
- en: '**What will be the result of the following expression: **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Try` constructor will not catch an `OutOfMemoryError`, hence the given
    expression will throw the `OutOfMemoryError`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the result of the following expression:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The result of the expression will be `Future(<not completed>)` which will eventually
    throw an `OutOfMemoryError`, as in the previous case.
  prefs: []
  type: TYPE_NORMAL
- en: '**Given the following function:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**What would be the result of the following call:** `either(1)` ?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result will be `true` because `Either.cond` evaluates to `Left` for `i ==
    2` and `Left.forall` evaluates to `true` for any `Left`.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why is the property of associativity essential for the monoid to be useful
    in a distributed setup?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a distributed setup, we're usually talking about folding and reusing datasets
    with parts of the data being processed by different computers. Monoidal operations
    are applied on remote machines. Regardless of the order in which they were sent
    from the master machine, network delays, different load patterns, and hardware
    settings will influence the order in which they will be returned. It is important
    to be able to apply an operation on the intermediate results already at hand without
    waiting for the first operations to complete.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement a monoid for `Boolean` under `OR`**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The property is as follows::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement a monoid for `Boolean` under `AND.`**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The property is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Given `Monoid[A]`, implement `Monoid[Option[A]].`**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The property is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Given `Monoid[R]`, implement `Monoid[Either[L, R]].`**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The property is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Generalize two previous implementations for any effect parameterized by `A` or
    describe why it is not possible.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unfortunately, it is not possible to implement such a monoid in general because
    the implementation would require two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: An identity element for the new monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A possibility to check whether an effect is empty and retrieve an element if
    it is not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to pass an identity element as an argument to the constructor,
    but then there is no way to work with existing effects as required by the second
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Implement** `Functor[Try]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement** `Applicative[Try]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement ** `Applicative[Either]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement** `Traversable[Try]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement** `Traversable[Either]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement **`Traversable.compose`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Implement `Monad[Try]`**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Prove the right identity law for the `State` monad.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with the property definition we had in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let `f(a) = a => State(s => (b, s2))`
  prefs: []
  type: TYPE_NORMAL
- en: First, we substitute the definition of unit with the result of the call. Hence, `M.flatMap(M.unit(a))(f)`
    becomes `M.flatMap(State(s => (a, s)))(f)`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we substitute `M.flatMap` with `compose`, which gives us `State(s => (a,
    s)).compose(f).`
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll use the lemma proved in this chapter to substitute the `compose`
    call with the definition of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By application of `f`, the previous code can be simplified to `State(s => State(s
    => (b, s2)).run(s)` and further to `State(s => (b, s2)`. **(1)**
  prefs: []
  type: TYPE_NORMAL
- en: The right side of the equation, `f(a)`, is by definition equal to `State(s =>
    (b, s2))`. **(2)**
  prefs: []
  type: TYPE_NORMAL
- en: We have (1) == (2) and hence proved the right identity law for the state monad.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pick one of the monads we defined in this chapter and implement the `go` function
    that will encode the notion of sinking the boat with a 1% probability.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Option` will represent the notion of the sunk boat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Please do the same but encode the notion of a motor breaking in 1% of the
    moves, leaving the boat immobilized.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both `Try` and right-biased `Either` can be used to encode the case of the broken
    motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the implementation with `Try`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the implementation with `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Describe the essence of monads we defined in this chapter using (loosely) the following
    template: The state monad passes state between chained computation. The computation
    itself accepts the outcome of the previous calculation and returns the result
    along with the new state.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The option monad allows the chaining of computations which might return no result.
    The computations are carried over until the last one or until the first one returns
    no result.
  prefs: []
  type: TYPE_NORMAL
- en: The try monad does the same as the option monad but instead of having a special
    *no result* value, which aborts the whole computation chain, it has a notion of
    *failure* represented by a `Failure` case class.
  prefs: []
  type: TYPE_NORMAL
- en: Either monad has similar semantics to the option and try monads but, in this
    case, the notion of aborting the sequence of steps is carried on by the Left type
    and the notion of continuing the sequence, by the `Right` type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Define a `go` method that both tracks the boat''s position and takes the
    possibility of sinking the boat using the structure with the following type: `type
    WriterOption[B] = Writer[Vector[(Double, Double)], Option[Boat]]`**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Compare the answer to Question 6 and the way we combined applications in
    the previous chapter.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Chapter 8](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml), *Dealing with Effects*,
    we implemented a generic combinator for applications. In this implementation involving
    monads, we needed to know how to dissect the options effect in order to be able
    to implement the combination logic. Please read [Chapter 10](5503a5a0-2aaa-44f2-be25-64e34977f6ff.xhtml), 
    *A Look at Monad Transformers and Free Monad*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why does the type of monad transformer reflect the type of the stack "upside-down"?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is impossible to define a monad composition in general, only in a way specific
    to the internal effect of the stack. Because of this, the name of the effect is
    fixed in the name of the transformer and the outer effect becomes a type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it possible to reuse existing monads for the top layer of the stack?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The return type of the Kleisli arrow fits well with the type of the stack. For
    this reason, it is possible to produce the result of the proper type by utilizing
    the `flatMap` method of the outer monad.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it impossible to reuse existing monads for the bottom layer of the
    stack?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The argument type of the arrow expects a plain argument. Consequently, we need
    to extract the effect-free value from the context of internal effect. This is
    only possible in a specific way but not in general.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement the `TryT` monad transformer.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Use the `TryT` monad transformer instead of `EitherT` with the example functions
    from this chapter.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Implement another take on the monad transformer stack, this time with this
    layers placed upside-down: **`EitherT[OptionT[Future, A], String, A]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Add an action to release the caught fish to the free monad example we developed
    in the chapter.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Only the changed parts of the example are shown here. Please see the accompanying
    code to see the example with incorporated changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We need to extend the action model and a function, add a helper lifting method,
    add the additional step to the definition of the process, and augment both interpreters
    to support the new action.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Name two ways in which an actor can change itself in response to the received
    message.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An actor can mutate its internal state using a var field. This is a classical
    object-oriented approach.
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to use context and become close over some value which will become
    part of the new state. The context.become can also be used to change the behavior
    of the actor completely. This is a more functional approach because both state
    and behavior are in fact immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the purpose of `ActorRef`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ActorRef provides a means to address an actor via the actor path. It also
    encapsulates an actor's mailbox and a dispatcher. Actors in Akka communicate via
    ActorReference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Look up in the official documentation the description of the system guardian.
    What is the main purpose of it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main purpose of the system guardian is to supervise system level actors.
    It is also used to ensure a proper shutdown order so that system level actors
    are available for user-defined actors until the user guardian is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the advantages and disadvantages of using Akka FSM.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Akka FSM allows for the modeling of actor behavior as a state machine defining
    separate state transitions and data for these states.
  prefs: []
  type: TYPE_NORMAL
- en: Akka FSM couples business logic to the particular implementation and makes it
    hard to test and debug.
  prefs: []
  type: TYPE_NORMAL
- en: '**In how many ways can an actor in another actor system be accessed? Describe
    them.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two ways to access an actor in a remote system – remote deployment
    and remote lookup. With remote deployment, a new actor is created in the remote
    system. The remote deployment can be done explicitly in the code or by providing
    a deployment configuration. Remote lookup allows for the selection of an existing
    actor in a remote system using the same approach as used for the lookup locally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why does testing actors require a special toolkit?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actors are highly non-deterministic. The state of the actor is inaccessible.
    The only way to properly test an actor is by sending messages to it and waiting
    for its responses. Sometimes a whole actor hierarchy needs to be created for this
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is the meaning of the `Behavior[Tpe]` definition?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Behavior[Tpe]` explicitly specifies that this actor is capable of handling
    messages that are subtypes of `Tpe`. By recursion, we can conclude that the returned
    behavior also will be `Behavior[Tpe].`'
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you get access to the scheduler in the actor''s behavior?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The schedule is accessible via the behavior constructor, `Behaviors.withTimers.`
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe possible ways an actor can be stopped.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An actor can be stopped by the parent using the parent''s actor context: `context.stop(child)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An actor can also stop itself by returning respective behavior: `Behaviors.stopped`.'
  prefs: []
  type: TYPE_NORMAL
- en: An actor can also be stopped if an exception was thrown by the actor's logic
    and the `SupervisorStrategy` defined for this actor is `stop`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between a local and a cluster receptionist?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are different implementations but there is no noticeable difference for
    the developer.
  prefs: []
  type: TYPE_NORMAL
- en: '**What supervision possibilities exist and how are they defined?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three supervision strategies: stop, restart, and resume. They are
    defined by wrapping an actor in supervising behavior using `Behaviors.supervise`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why should stashing be used judiciously?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Current stashing implementation buffers messages in memory and can lead to `OutOfMemory`
    or `StashOverflowException`, depending on the stash size. If messages are unstashed,
    the actor will not produce other incoming messages until all stashed bits are
    processed, which might make it unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a preferred way to test actor logic in isolation?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronous testing using BehaviorTestKit provides better possibilities to test
    actor logic in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Name two different modes associated with "classic" streams. Why are they
    problematic?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two modes are push and pull. Push is problematic in the case of a slow consumer
    because it can lead to dropped stream elements or memory overflow. Pull is suboptimal
    in the case of a slow producer because it can lead to blocking or extensive resource
    consumption.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are Reactive Streams considered to work in dynamic pull-push mode?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reactive Streams introduce the notion of non-blocking back pressure. The consumer
    reports the demand it has and the producer pushes data in batches according to
    this demand. When the consumer is faster, the demand is always there so the producer
    is always pushing data as soon as it is available. If there is a producer which
    is faster, there is always data available and the consumer just pulls it as soon
    as it has some demand. The flow automatically switches between these modes.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the typical building blocks of Akka Stream''s graph?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A flow is a stage with exactly one input and one output. Fan-In has multiple
    inputs and one output. Fan-Out is the opposite with multiple outputs and one input.
    BidiFlow represents bi-directional flow with two inputs and two outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you convert a graph into a runnable graph?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A graph can be connected into a runnable graph by connecting a source and a
    sink to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the main goal of having materialization as a separate explicit step?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the materialization step, any graph can be considered to be just a blueprint
    of the stream and hence can be freely shared and reused.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the effects of applying different supervision strategies.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are three different supervision strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Stop interrupts the stream in the failed processing stage. The failure propagates
    downstream and cancellation propagates upstream.
  prefs: []
  type: TYPE_NORMAL
- en: Resume drops the current element and continues streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Restart drops the current element, cleans the internal state of the processing
    stage (usually by re-creating it), and continues steaming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which main abstractions provide Akka Streams TestKit? Why are they useful?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two main abstractions provided by Akka Streams TestKit are TestSink and TestSource.
    They allow the control and verification of assumptions about stream flow on different
    levels, for example, a high messaging level or low reactive-streams level. They
    also make it possible to use a nice DSL to drive the test and to formulate expectations
    about the outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a database migration?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The database migration  (or schema migration) is the automatic management of
    updates to the database schema. The changes to the schema are incremental, usually
    reversible, and applied in the moment the database schema needs to be changed
    in order to reflect changes in the application code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe what could be an alternative approach to discarding an order completely,
    in the case of insufficient stock for some articles? **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the alternatives could be to satisfy orders for all articles for which
    there are sufficient stock. This could be implemented by running each inventory
    update in a separate transaction and combining the results of all of them that
    succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another alternative would be to satisfy orders as fully as possible. This
    approach would require selecting rows for update, calculating new possible states,
    and applying them in the same transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the conceptual difference between http4s and Akka HTTP in regard
    to defining routes.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: http4s defines routes as a partial function that pattern matches over the request.
    Akka HTTP route definition is constructed from nested directives. The requests
    follow the path through matching directives top-down.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you name a reason why event-sourced data storage can scale better than
    a traditional relational database?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concurrent updates require much more locking and synchronization than append-only
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement a `GET /articles/:name` call with http4s and doobie.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1\. Add new route definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '`case GET -> Root / "articles" / name => renderInventory(repo.getArticle(name))`'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Extend the repository `getArticle` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See the source code in GitHub for the refactored version, which reuses the parameterless
    definition of `getInventory.`
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement the `GET /articles/:name` call with Akka HTTP and Akka Persistence.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1\. Add a new query definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '2\. Add a query handler in `InventoryActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '3\. Add the route definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The GitHub repository contains this route definition embedded in the previously
    defined `lazy val articlesRoutes: Route`.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How do you map the endpoint with the query parameter to a REST call?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**What is the recommended serialization format for persistent entities?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lagom's recommended serialization format is JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you explain why clustering is required in order to use persistence in
    Lagom?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lagom's persistence is implemented on top of Akka persistence. Akka requires
    each persistent actor to have a unique persistence ID. In a microservice landscape,
    each service is supposed to have multiple instances at the same time. Without
    clustering, there will be multiple persistent actors with the same ID storing
    events into the same database, which will corrupt data. By utilizing clustering
    and cluster sharding, Akka makes sure there is only one persistent actor in the
    cluster across all instances of the service.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe one possible data model that could be used to make the `Manager`
    to the persistent entity.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Outline an alternative way to implement the Baker service.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Baker` service could also be implemented message passing style similar
    to the `Chef` service.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you identify a design bug in the current implementation of the Chef?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Chef` does not trigger mixing for unbalanced mixing events after recovery.
  prefs: []
  type: TYPE_NORMAL
- en: '**The `Manager` implementation stores a number of cookies in memory and this
    number will be lost at the moment the service restarts. Can you name another reason
    why it is a bad idea to hold the number of cookies in a local variable?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a production environment, there will be multiple instances of the service
    running. Each of them will have its own internal state.
  prefs: []
  type: TYPE_NORMAL
