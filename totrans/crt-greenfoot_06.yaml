- en: Chapter 6. Scrolling and Mapped Worlds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Already know you that which you need."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Yoda* |'
  prefs: []
  type: TYPE_TB
- en: In Greenfoot, we can build worlds that are much larger than the confines of
    a single screen. Through scrolling techniques and dynamic actor generation, we
    can build side-scrolling games and map worlds that can seem endless. When you
    combine these large worlds with the techniques learned in the previous chapters,
    you will be able to create a truly compelling and immersive experience for your
    audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques you will learn in this chapter are similar to the ones you learned
    in [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*, for animation.
    We will use illusion. Through very simple techniques, we can give the appearance
    that the user is moving through an expansive world. In this chapter, you will
    learn to create the following types of worlds:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tile-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you learn more about Greenfoot and Java programming, you will notice repeating
    patterns and methods to accomplish specific tasks. While the content presented
    here warrants its own chapter, it is really a careful mixture of things you have
    already learned.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter scenario examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at four different methods to create large
    worlds for simulations, games, or animations. We are only going to present the
    code necessary to accomplish this and not elaborate further. *You should combine
    the methods learned here with the topics presented in the previous chapters to
    develop complete applications*. In addition, we will use very simple graphics
    in our scenarios and assume that you would spend more time on art and story (as
    described in [Chapter 5](part0034.xhtml "Chapter 5. Interactive Application Design
    and Theory"), *Interactive Application Design and Theory*) for your own work.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically generated worlds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would seem creating worlds that are dynamically generated and potentially
    endless would be the concluding topic of this chapter, instead of the introductory
    one. On the contrary, dynamically creating a world is easy, and we have already
    seen all the coding necessary to do so. In [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, we dynamically created enemies in Avoider
    Game that streamed down from the top, and later, in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*, we added a dynamically generated star field.
    We will use the same techniques to create a seemingly endless world. Imagine that
    the enemies in Avoider Game were generated less frequently and looked like planets.
    It would look like we were travelling through space. Imagine we had a green background
    and used an image of a tree for our enemies. It would look like we were walking
    through a forest. Next, we will create a Greenfoot scenario that displays a user-controlled
    rocket flying through a cloudy sky.
  prefs: []
  type: TYPE_NORMAL
- en: Side-scrolling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create the flying game depicted in *Figure 1*. In this game,
    the user controls the rocket and attempts to avoid the walls. Why walls? Well,
    they are easy to draw and sufficiently illustrate the concepts. In your own scenario,
    you could spend some time and draw alien spaceships, birds, balloons, or anything
    else that makes sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Side-scrolling](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: This is a screenshot of the Clouds Greenfoot scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new Greenfoot scenario, naming it `Clouds`, and saving it
    to disk. We will present the code for the world and actors next.
  prefs: []
  type: TYPE_NORMAL
- en: The Rocket class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example scenario, the user controls a rocket. You move the rocket by
    pressing the arrow keys. The movement of the rocket is restricted to stay inside
    the area of the screen. If the rocket hits a wall (which we will add soon), then
    the scenario will stop. There is no code in the `Rocket` class specific to generating
    a dynamic world, and it is all code we saw in the previous chapters. Create a
    new subclass of `Actor`, name it `Rocket`, associate the image of a rocket provided
    by Greenfoot with it, and enter the following code in its class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should be very familiar with the code to handle key presses and moving actors.
    One additional concept I have added here, is *functional decomposition* to remove
    code redundancy. Notice how the `handleArrowKey()` method can handle movement
    for all arrow keys. The code for `checkForCrash()` simply implements our standard
    template to detect collisions. We will add the `Obstacle` actor soon.
  prefs: []
  type: TYPE_NORMAL
- en: In `boundedMove()`, we have code that gets the user to not leave the screen.
    Without this code, the user could go off the screen and disappear from view in
    any direction. Using Java's `max()` and `min()` math library functions, `boundedMove()`
    ensures that the new *x* and *y* locations of the rocket stay within the confines
    of the screen. The `BOUNDARY` variable defines how close the rocket can get to
    an edge. We add this buffer to prevent the rocket from hiding a majority of its
    image off the sides.
  prefs: []
  type: TYPE_NORMAL
- en: The CloudsWorld class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main responsibility of our world class is to initially place the rocket
    on the screen and randomly generate clouds and walls. Create a new subclass of
    `World`, name it `CloudsWorld`, and assign a plain blue image to it for the background.
    You can either use the blue gradient background we used in [Chapter 4](part0030.xhtml
    "Chapter 4. Projectiles"), *Projectiles*, or create a new one using your favorite
    drawing program. As with the `Rocket` class, most of the code for `CloudsWorld`
    should be a review of previously provided code. Here is the code for `CloudsWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you remember what the `act()` method looked liked in our latest version
    of Avoider Game? Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Doesn't it look similar to the `act()` method for `CloudsWorld`? We are going
    to use the same technique we used to generate enemies in Avoider Game to generate
    clouds in the Clouds application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the `generateActor()` method. This method takes an
    actor (type `Actor`) and an integer (type `int`) as parameters. The integer represents
    the chance that we add the supplied actor to the world. The higher the number,
    the more likely that the actor will appear on screen. With this method, we can
    easily implement the `generateBackgroundClouds()` method and the `generateWalls()`
    method. In these methods, we simply call `generateActor()`, providing the chance
    for the actor to appear on screen as well as a new instance of the desired actor.
  prefs: []
  type: TYPE_NORMAL
- en: Side-scrolling actors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the other actors in our scenario are going to be subclasses of the `SideScrollingActor`
    class. Create this by subclassing `Actor`, but do not associate an image with
    it. With the following code, we are using inheritance to provide the side-scrolling
    behavior to a whole set of actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To give the illusion that our rocket is moving from left to right, we make all
    of the scrolling actors move from right to left. That is why the speed variable
    is negative. In the `act()` method, we move the actor and then call `checkOffScreen()`
    to remove the actor after it has moved off screen. As we never intend to use the
    `SideScrollingActor` class to directly instantiate an object, we make it `abstract`.
    Next, we will discuss the actors that are going to the `SideScrollingActor` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Clouds
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We use three different images of clouds for our application, and we will make
    them travel at different, random speeds. This will provide enough variety to give
    a realistic feel to our flying rocket. The three images I used are shown in *Figure
    2*. You can draw your own or the ones supplied at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: '![Clouds](img/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: These are images of clouds'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a cloud actor by subclassing `SideScrollingActor`, naming it `Cloud1`,
    and then assigning one of your cloud images to it. In the class file for `Cloud1`,
    put the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In `Cloud1`, we assign a random value to the `speed` variable between `1` and
    `3`. We inherited the `speed` variable from the `SideScrollingActor` parent class.
  prefs: []
  type: TYPE_NORMAL
- en: To create two more cloud actors, repeat the preceding steps once, substituting
    `Cloud1` with `Cloud2` and again substituting `Cloud1` with `Cloud3`. For further
    variety, you could change the `SPEEDRANGE` constant in each actor. I recommend
    setting `SPEEDRANGE` to `3` (as shown in Figure 2) for `Cloud1`, `2` for `Cloud2`,
    and `5` for `Cloud3`.
  prefs: []
  type: TYPE_NORMAL
- en: Walls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to add is the wall obstacle. While we only have one
    obstacle in this example, we are going to write code that would allow us to easily
    add additional obstacles in the future. We are going to use inheritance, but this
    time, we are using it to group related types, as opposed to sharing code. In the
    `Rocket Actor` code, we check for a collision with an `Obstacle` class. We will
    now create this class by subclassing `SideScrollingActor`, naming the new subclass
    `Obstacle`, and not associating an image with it. Here is the code for the `Obstacle`
    actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are not using inheritance for code reuse and, therefore, there is
    very little code to add.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create the `Wall` actor, we create a subclass of `Obstacle`. I simply
    created a dark gray rectangle image for my wall. I am sure you can come up with
    something better. Here is the code for the `Wall` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since `Obstacle` inherits from `SideScrollingActor`, the `Wall` actor will have
    the same movement as the `Cloud` actors. However, the `Rocket` class can now detect
    collision with the `Obstacle` class. If we did collision detection with the `SideScrollingActor`
    class, then we would collide with clouds too.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have finished creating the world and actor classes for our Greenfoot scenario.
    *Figure 3* shows the completed Greenfoot scenario. Make sure your class hierarchy
    is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![Try it out](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: This shows the completed Clouds scenario'
  prefs: []
  type: TYPE_NORMAL
- en: Compile it and take care of any typos you created along the way. Spend some
    time running the scenario and observing how the moving clouds give the illusion
    of travelling across an expansive sky. Even knowing how it is done, it is hard
    to imagine that your rocket is actually the actor on screen moving the least.
  prefs: []
  type: TYPE_NORMAL
- en: Mapped worlds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are definitely times when you are going to want a specific background
    for your game or simulation. In these cases, it is not sufficient to randomly
    generate actors to simulate a moving background. The methods we will explore next
    consist of creating a background image that is much larger than the dimensions
    of the screen and moving it appropriately to simulate motion. In addition, we
    will learn how to place actors in this larger world.
  prefs: []
  type: TYPE_NORMAL
- en: Side-scrolling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our side-scrolling example is a scenario that allows the user to walk through
    a mountain forest to find a lake at the end. The user will only be able to walk
    left and right, not up and down. *Figure 4* shows the completed application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Side-scrolling](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: This is a screenshot of HikingWorld'
  prefs: []
  type: TYPE_NORMAL
- en: To create this side-scrolling world, we are going to need a large image to serve
    as the background. For this example, I have created a 2400 x 400 image shown in
    *Figure 5*. Since our scenario has a viewable screen size of 600 x 400, the image
    is six times longer than our screen. Feel free to create your own 2400 x 400 image
    or use the one supplied at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: '![Side-scrolling](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: This is a background image for HikingWorld that is 2400 pixels long
    and 400 pixels high. Note that the image in this figure is one-fourth the original
    size in order to fit on a page'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will describe the code for the world and actor classes.
  prefs: []
  type: TYPE_NORMAL
- en: The HikingWorld class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main responsibility of our world class, `HikingWorld`, is to shift everything
    in the world relative to the user-controlled `Hiker` class. We will allow the
    user to move normally within the confines of a screen, but when a user tries to
    move further than the left boundary or the right boundary of the screen, we will
    move everything to the right-hand side or left-hand side, respectively. Figure
    6 demonstrates what we will do if the user is at the right edge of the screen
    and tries to move to the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '![The HikingWorld class](img/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: If the player moves right at the right edge of the screen, we will
    shift everything to the left'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand what the `HikingWorld` class must do, let''s take a
    look at the code. First, subclass `World` and name the new subclass `HikingWorld`.
    Do not associate an image with this new class; we will do that in the constructor
    function. Here is the code for what the `HikingWorld` class must do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the class, we create three constants to store the dimensions
    of the screen (`SWIDTH` and `SHEIGHT`) and the background image (`WWIDTH`). Since
    the image height and the screen height are the same, we don't need a `WHEIGHT`
    constant. We also declare the `xOffset` instance variable. We use this variable
    to keep track of how far the background image and actors are currently shifted.
    Last, we create an instance variable, `bimg`, to point to the background image.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we load our background image and call `shiftWorld()` with
    an offset of `0` to put everything at its starting location. We use the `prepare()`
    method in a standard way—to place our initial actors. One thing to notice is that
    we use *y* positions larger than the screen size. So, some of our actors will
    be created, but placed off screen. Eventually, they will be shifted to be on screen
    and viewable by the user. The real work to make this world large is done in `shiftWorld()`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the first `if` statement in the `shiftWorld()` method. This `if` statement
    prevents us from shifting the background image to the point where we would see
    the blank white space behind it.
  prefs: []
  type: TYPE_NORMAL
- en: If we are not at the edges of the background image, then we record the new offset
    by adding the current shift (`dx`) to the current offset (`xOffset`). Then, we
    proceed to shift the background image using the `shiftWorldBackground()` method
    and all actors in the world using `shiftWorldActors()`. The `shiftWorldBackground()`
    method is fairly simple. We start by creating a new image the size of the screen.
    We then draw our background image into it, offset by `xOffset` (which has just
    had `dx` added to it), and then set this new image to be the background image.
  prefs: []
  type: TYPE_NORMAL
- en: The `shiftWorldActors()` method may have few lines, but it does a lot of work.
    There is a `World` method called `getObjects()`provided to us that will return
    all of the actors in the world of the supplied class. For us, we call `getObjects(ScrollingActor.class)`
    to get all objects that should be shifted. The class the user controls, `Hiker`,
    is not a subclass of `ScrollingActor`; therefore, it will not be shifted in this
    method. We then iterate through the returned Java `List` and call `setAbsoluteLocation()`
    on each instance of `ScrollingActor`. We will look at the implementation of the
    `ScrollingActor` class and `setAbsoluteLocation()` soon.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the work for creating a side-scrolling world is done in `HikingWorld`.
    Make sure you understand this code before moving on. The rest of the code for
    the remaining actors in this scenario is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The Hiker class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will have one instance of the `Hiker` class that the user will control.
    In this scenario, we are only going to let the user move left and right. This
    amount of control is sufficient to demonstrate a side-scrolling scenario. The
    code for this class is almost identical to the code for the `Rocket` actor in
    the Clouds scenario we created at the beginning of this chapter. First, look at
    the code, and then we will discuss the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The main difference occurs in `boundedMove()`. In the `Rocket` class presented
    earlier, we had a similar method that confined the user movement to a rectangular
    area slightly smaller than the screen. We are doing the same here for horizontal
    movement, but with one added feature. When we detect that the user is at the edge
    of the screen (either the left-hand side or the right-hand side), we will call
    `shiftWorld()` to make it look as though the actor is continuing to move.
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `checkAtLake()` method that has no implementation. It is an
    example of how you could have a goal at the end of your world that the user must
    get to. In our case, we are going to place a lake at the end of the hike. We would
    use this method if we wanted to do something once the user arrived at the lake.
  prefs: []
  type: TYPE_NORMAL
- en: The ScrollingActor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the actors we want to shift will subclass the `ScrollingActor` class.
    It provides both a convenient way to group these actors and allows us to define
    the `setAbsoluteLocation()` method in one place. Here''s how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `HikingWorld` class, we called `setAbsoluteLocation()` on all the actors
    we wanted to shift. This method is simply a wrapper for `setLocation()` and moves
    the actor by the `dx` amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `HedgeHog`, `Lemur`, and `Lake` actors are identical and very
    minimal. Those classes mainly exist to allow different images to be associated
    with them. The images for a hedgehog and lemur come with the default installation
    of Greenfoot. My lake is a simple blue oval created in a drawing program. These
    actors are placed in the world in the `prepare()` method of `HikingWorld`. Create
    each of these now and add the following code to each (make sure to substitute
    in the appropriate class name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Try it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Congratulations! You have created a side-scrolling, mapped world. Compile it
    and try it out. For an extra challenge, implement the `checkAtLake()` method found
    in the `Hiker` class to reward the hiker for reaching their destination. You can
    also download a completed version of the scenario at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: 2D scrolling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating an application that allows a user to explore a large map in both the
    *x* (left and right) and *y* (up and down) directions is an easy extension of
    the side-scrolling world we just created. The code will be exactly the same except
    we will also handle the case for up and down movement. We also need an image that
    is both longer and wider than the screen size of our scenario. The image I created
    is 1200 x 1200 pixels and shown in *Figure 7*. You can create your own or download
    the image from *Figure 7* at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    The picture is meant to represent a top-down view of a terrain with trees.
  prefs: []
  type: TYPE_NORMAL
- en: '![2D scrolling](img/image00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: A background image for HikingWorld2D that is 1200 pixels long and
    1200 pixels high. Note that the image shown in this figure has been scaled down
    to fit on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scenario and name it `HikingWorld2D`. As this code is very similar
    to the `HikingWorld` scenario we just implemented in the previous section, we
    will only highlight the code necessary to handle up and down movement.
  prefs: []
  type: TYPE_NORMAL
- en: The HikingWorld2D class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Subclass `World` and name the new class `HikingWorld2D`, but do not associate
    an image with it. We will add the image shown in *Figure 7* (or one like it that
    you create) in the constructor function of this class. Here is the code to accomplish
    all this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we get `WWIDTH` and `WHEIGHT` to be the dimensions of the background
    image. Previously, we did not need `WHEIGHT` as it was the same as `SHEIGHT`.
    The main difference between this class and the `HikingWorld` class in `HikingWorld,`
    is that we add an extra parameter (`dy`) to `shiftWorld()`, `shiftWorldBackground()`,
    and `shiftWorldActors()` that provides the change in the *y* direction. The use
    of the new `dy` parameter mirrors the use of the `dx` parameter. We end up shifting
    the background image and other actors by both `dx` and `dy`.
  prefs: []
  type: TYPE_NORMAL
- en: The Hiker class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new subclass of `Actor`, name it `Hiker`, and associate one of the
    default people images provided by Greenfoot. Here is the code for this new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This class has also been augmented to handle moving in the *x* and *y* directions.
    In `handleKeyPresses()`, we added two more calls to `handleArrowKey()` to handle
    the up and down arrow keys being pressed. In `boundedMove()`, we add checks to
    make sure the actor does not move off the top or bottom of the screen and that
    it calls `shiftWorld()` at the appropriate times.
  prefs: []
  type: TYPE_NORMAL
- en: The ScrollingActor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new subclass of `Actor` and name it `ScrollingActor`. You do not need
    to associate an image with it. As before, this class simply provides a wrapper
    for `setLocation()`. Now, it handles moving the actor in the *y* direction as
    well. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `HedgeHog`, `Lemur`, and `Lake` classes are exactly the same as they were
    in the `HikingWorld` scenario shown previously. Add them to `HikingWorld2D` as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With just a few changes, we have created a world worth exploring, and all it
    took were a few extensions to our already completed `HikingWorld` scenario. Now,
    it is time to compile and try your scenario out. Handle any typos/errors and then
    explore the map. You can also download a completed version of the scenario at
    [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: Tile-based worlds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tile-based worlds are a happy incorporation between fully dynamically created
    worlds and worlds that use a large image for the background. With large images,
    you create a very detailed and predictable world, but it is very difficult to
    change. Dynamically created worlds are easy to generate but are often too random.
    Tile-based worlds let you easily create detailed, predictable worlds in a way
    such that they are easy to change or modify.
  prefs: []
  type: TYPE_NORMAL
- en: Actors as tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artists can create amazing images using small pieces of tile or glass. *Figure
    8* shows a simple tile mosaic. By strategically placing small pieces of colored
    tiles, you can generate many different types of images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Actors as tiles](img/image00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: This is a simple mosaic, courtesy of pixabay.com at http://pixabay.com/en/uzbekistan-mosaic-pattern-artfully-196875/'
  prefs: []
  type: TYPE_NORMAL
- en: We will use a similar technique to create a world in Greenfoot, but we will
    use small actors instead of tiles. *Figure 9* demonstrates how we will do this.
    We will create a set of actors that will serve as our tiles. Then, we will specify
    how to compose these actors to create images using an array of strings that uses
    letters to code the type of actor to place. For example, the letter `C` corresponds
    to the actor displaying a cloud with a blue background, and the letter `F` corresponds
    to the actor displaying a flower on a green background. *Figure 9* shows a 4 x
    3 matrix of letters that is used to specify the tile layout that creates the final
    image. In the matrix, the upper-left corner letter is an `S`; therefore, the upper-left
    corner of the image is solid blue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Actors as tiles](img/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: This shows the mapping of individual actors to create a larger world'
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you now have a sense of how tile-based world creation will work.
    In the coming snippet, we code the hiking world scenario again, but this time
    modified to use tile-based world creation. Much of the code is directly borrowed
    from the 2D-scrolling hiking world we built in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scenario and name it `HikingWorldTiled`. The world and actor classes
    for this scenario are described in the next section. We only highlight the additions
    pertinent to tile-based world creation. *Figure 10* shows a screenshot from the
    completed scenario. I provide this now, so that you can quickly see all the classes
    we will implement and get a glimpse of part of the image we will be creating.
  prefs: []
  type: TYPE_NORMAL
- en: '![Actors as tiles](img/image00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: This is a screenshot of the completed HikingWorldTiled scenario'
  prefs: []
  type: TYPE_NORMAL
- en: The HikingWorld class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create `HikingWorld` by subclassing `World`. We are dynamically creating a
    background image, so you don''t want to associate an image with this class; here
    is the code to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The two new parts of this class are the array of strings, `WORLD`, declared
    at the top of the class, and the `createWorldFromTiles()` method, which uses the
    method `addActorAtTileLocation()` to assist in building the world from the existing
    actors. The `WORLD` array specifies where we are going to place each actor that
    makes up part of the background. We have three actors we will use for our background
    image; they are `BlackBlock`, `WhiteBlock`, and `BlueBlock`. These actors use
    images that are 25 x 25 pixels. This is a decent size for a tile—any smaller and
    your `WORLD` array will be too large and tedious to manage, and any larger and
    you will lose the ability to create detail.
  prefs: []
  type: TYPE_NORMAL
- en: The `WORLD` array has sixteen strings in it that each contain forty-eight characters,
    thus the size of the image we are creating is 1200 (48 x 25) x 400 (16 x 25).
    The letter `B` corresponds to the `BlackBlock` actor, the letter `W` corresponds
    to the `WhiteBlock` actor, and the letter `U` corresponds to the `BlueBlock` actor.
    This mapping is captured in the `switch` statement in the `addActorAtTileLocation()`
    method. Knowing the mapping, you can look at the `WORLD` array and see that the
    image will have a black border and white background, and will spell the word `Hi`
    in blue.
  prefs: []
  type: TYPE_NORMAL
- en: OK, let's go through `createWorldFromTilesMethod()`. This method iterates through
    every character of every string in `WORLD`. For each character, it calls `addActorAtTileLocation()`,
    supplying parameters that specify the character that indicates which tile should
    be placed as well as the location for that tile. In `addActorAtTileLocation()`,
    we create a new actor based on the character passed to it and then use the provided
    `x` and `y` values to place the new actor in the world.
  prefs: []
  type: TYPE_NORMAL
- en: The Hiker class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code here is identical to the code we looked at earlier for the `Hiker`
    class in the dynamically created world. I reproduce it here for convenience and
    because it is relatively short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The ScrollingActor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This code is also identical to the code provided for the first scenario we
    created in this chapter. *It is important to note here, that the actors we are
    using to create the world could also have additional functionality and not simply
    be a passive background image*. For example, you could have a *Fire* tile that
    would burn the hiker if it collided with it. Here''s the code we are discussing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tiles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code for the `BlackBlock`, `BlueBlock`, and `WhiteBlock` actors are nearly
    identical. The only difference is the name of the class and the associated image.
    Take a look at the code for `BlackBlock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is important that the images for these actors are all the same size, to make
    them easy to compose into a larger image. In our case, the images are 25 pixel
    x 25 pixel colored squares.
  prefs: []
  type: TYPE_NORMAL
- en: The Lake class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Lake` class is the same as in the first scenario. It is important to note
    that not all subclasses of `ScrollingActor` have to serve as tiles for the background
    image. The `Lake` actor represents our final destination This is how the `Lake`
    class is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can just copy it and its associated image from the previous scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compile the scenario and run it. It should feel similar to the side-scrolling
    example we provided after the Clouds scenario, except now it is very easy to change
    the image of the world. Instead of `Hi` being spelled in the background, spell
    your name. For a challenge, change the `Hiker` class such that if it touches a
    blue block, the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: Other game sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, the tiles were very simple. The real strength of tile-based
    world creation comes from having a wide variety of tiles to choose from to create
    an interesting world. You can either create your own world, download some from
    sites that charge, such as [http://cartoonsmartart.com](http://cartoonsmartart.com),
    or download from 100 percent free sites, such as [http://opengameart.org](http://opengameart.org).
    *Figure 11* shows an example of a free tile set from [http://opengameart.org](http://opengameart.org).
  prefs: []
  type: TYPE_NORMAL
- en: '![Other game sprites](img/image00314.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: This is a free tile sheet from opengameart.org provided by Kenny
    at http://opengameart.org/content/rpg-pack-base-set'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By combining the techniques of large-world creation presented in this chapter,
    with the other concepts and techniques presented in previous chapters, you are
    fully equipped to create endless forms of information, entertainment, and immersive
    experiences using Greenfoot. In the next chapter, we will explore making actors
    in your applications behave intelligently to further enhance user experience.
  prefs: []
  type: TYPE_NORMAL
