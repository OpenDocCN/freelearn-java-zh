- en: Chapter 6. Scrolling and Mapped Worlds
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。滚动和映射世界
- en: '|   | *"Already know you that which you need."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"你已经知道你需要什么。"* |   |'
- en: '|   | --*Yoda* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*尤达大师* |'
- en: In Greenfoot, we can build worlds that are much larger than the confines of
    a single screen. Through scrolling techniques and dynamic actor generation, we
    can build side-scrolling games and map worlds that can seem endless. When you
    combine these large worlds with the techniques learned in the previous chapters,
    you will be able to create a truly compelling and immersive experience for your
    audience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Greenfoot中，我们可以构建比单个屏幕范围更大的世界。通过滚动技术和动态演员生成，我们可以构建侧滚动游戏和看似无限的世界地图。当你将这些大型世界与上一章中学到的技术结合起来时，你将为你的观众创造一个真正吸引人和沉浸式的体验。
- en: 'The techniques you will learn in this chapter are similar to the ones you learned
    in [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*, for animation.
    We will use illusion. Through very simple techniques, we can give the appearance
    that the user is moving through an expansive world. In this chapter, you will
    learn to create the following types of worlds:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将学习的技术与你在[第2章](part0017.xhtml "第2章。动画")“动画”中学到的技术相似。我们将使用错觉。通过非常简单的技术，我们可以给人一种用户正在穿越广阔世界的错觉。在本章中，你将学习创建以下类型的世界：
- en: Dynamically generated
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态生成
- en: Mapped
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Tile-based
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于瓦片
- en: As you learn more about Greenfoot and Java programming, you will notice repeating
    patterns and methods to accomplish specific tasks. While the content presented
    here warrants its own chapter, it is really a careful mixture of things you have
    already learned.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对Greenfoot和Java编程了解的深入，你会注意到重复的模式和方法来完成特定的任务。虽然这里展示的内容值得拥有自己的章节，但它实际上是你已经学到的内容的精心混合。
- en: Chapter scenario examples
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节场景示例
- en: In this chapter, we are going to look at four different methods to create large
    worlds for simulations, games, or animations. We are only going to present the
    code necessary to accomplish this and not elaborate further. *You should combine
    the methods learned here with the topics presented in the previous chapters to
    develop complete applications*. In addition, we will use very simple graphics
    in our scenarios and assume that you would spend more time on art and story (as
    described in [Chapter 5](part0034.xhtml "Chapter 5. Interactive Application Design
    and Theory"), *Interactive Application Design and Theory*) for your own work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨四种不同的方法来创建用于模拟、游戏或动画的大型世界。我们只将展示完成这一目标所需的代码，而不会进一步展开。*你应该将在这里学到的方法与上一章中介绍的主题结合起来，以开发完整的应用程序*。此外，在我们的场景中，我们将使用非常简单的图形，并假设你会在艺术和故事（如第5章[交互式应用程序设计和理论](part0034.xhtml
    "第5章。交互式应用程序设计和理论")中所述）上花费更多时间。
- en: Dynamically generated worlds
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态生成世界
- en: It would seem creating worlds that are dynamically generated and potentially
    endless would be the concluding topic of this chapter, instead of the introductory
    one. On the contrary, dynamically creating a world is easy, and we have already
    seen all the coding necessary to do so. In [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, we dynamically created enemies in Avoider
    Game that streamed down from the top, and later, in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*, we added a dynamically generated star field.
    We will use the same techniques to create a seemingly endless world. Imagine that
    the enemies in Avoider Game were generated less frequently and looked like planets.
    It would look like we were travelling through space. Imagine we had a green background
    and used an image of a tree for our enemies. It would look like we were walking
    through a forest. Next, we will create a Greenfoot scenario that displays a user-controlled
    rocket flying through a cloudy sky.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，创建动态生成且可能无限的世界应该是本章的结论性话题，而不是入门话题。相反，动态创建一个世界是很容易的，我们已经看到了完成这一目标所需的所有代码。在[第1章](part0014.xhtml
    "第1章。让我们直接进入…")，“让我们直接进入…”，我们动态创建了从顶部流下来的敌人，后来，在第2章[动画](part0017.xhtml "第2章。动画")中，我们添加了一个动态生成的星系。我们将使用相同的技巧来创建一个看似无限的世界。想象一下，Avoider
    Game中的敌人生成频率较低，看起来像行星。这会让人感觉我们正在穿越太空。想象一下，我们有一个绿色的背景，使用树木的图片作为敌人。这会让人感觉我们正在穿越森林。接下来，我们将创建一个Greenfoot场景，显示一个用户控制的火箭在多云的天空中飞行。
- en: Side-scrolling
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侧滚动
- en: We are going to create the flying game depicted in *Figure 1*. In this game,
    the user controls the rocket and attempts to avoid the walls. Why walls? Well,
    they are easy to draw and sufficiently illustrate the concepts. In your own scenario,
    you could spend some time and draw alien spaceships, birds, balloons, or anything
    else that makes sense to you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建*图1*中描述的飞行游戏。在这个游戏中，用户控制火箭并试图避开墙壁。为什么是墙壁？好吧，它们很容易绘制并且足以说明概念。在你的场景中，你可以花些时间绘制外星飞船、鸟、气球或其他对你有意义的任何东西。
- en: '![Side-scrolling](img/image00304.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![侧滚动](img/image00304.jpeg)'
- en: 'Figure 1: This is a screenshot of the Clouds Greenfoot scenario.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这是Clouds Greenfoot场景的截图。
- en: Start by creating a new Greenfoot scenario, naming it `Clouds`, and saving it
    to disk. We will present the code for the world and actors next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的Greenfoot场景，命名为`Clouds`，并将其保存到磁盘上。我们将接下来展示世界和角色的代码。
- en: The Rocket class
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rocket类
- en: 'In this example scenario, the user controls a rocket. You move the rocket by
    pressing the arrow keys. The movement of the rocket is restricted to stay inside
    the area of the screen. If the rocket hits a wall (which we will add soon), then
    the scenario will stop. There is no code in the `Rocket` class specific to generating
    a dynamic world, and it is all code we saw in the previous chapters. Create a
    new subclass of `Actor`, name it `Rocket`, associate the image of a rocket provided
    by Greenfoot with it, and enter the following code in its class file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例场景中，用户控制一个火箭。你可以通过按箭头键来移动火箭。火箭的移动被限制在屏幕区域内。如果火箭撞到墙壁（我们很快会添加），则场景将停止。`Rocket`类中没有特定于生成动态世界的代码，所有代码都是我们在前几章中看到的。创建一个新的`Actor`子类，命名为`Rocket`，将其与Greenfoot提供的火箭图像关联起来，并在其类文件中输入以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should be very familiar with the code to handle key presses and moving actors.
    One additional concept I have added here, is *functional decomposition* to remove
    code redundancy. Notice how the `handleArrowKey()` method can handle movement
    for all arrow keys. The code for `checkForCrash()` simply implements our standard
    template to detect collisions. We will add the `Obstacle` actor soon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该非常熟悉处理按键和移动角色的代码。我在这里增加的一个额外概念是*功能分解*，用于去除代码冗余。注意`handleArrowKey()`方法可以处理所有箭头键的移动。`checkForCrash()`方法的代码只是简单地实现了我们的标准模板来检测碰撞。我们很快将添加`Obstacle`角色。
- en: In `boundedMove()`, we have code that gets the user to not leave the screen.
    Without this code, the user could go off the screen and disappear from view in
    any direction. Using Java's `max()` and `min()` math library functions, `boundedMove()`
    ensures that the new *x* and *y* locations of the rocket stay within the confines
    of the screen. The `BOUNDARY` variable defines how close the rocket can get to
    an edge. We add this buffer to prevent the rocket from hiding a majority of its
    image off the sides.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`boundedMove()`中，我们有一些代码，用于确保用户不会离开屏幕。如果没有这段代码，用户可以朝任何方向离开屏幕并消失在视野中。使用Java的`max()`和`min()`数学库函数，`boundedMove()`确保火箭的新*x*和*y*位置保持在屏幕范围内。`BOUNDARY`变量定义了火箭可以靠近边缘的距离。我们添加这个缓冲区以防止火箭的大部分图像隐藏在边缘之外。
- en: The CloudsWorld class
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CloudsWorld类
- en: 'The main responsibility of our world class is to initially place the rocket
    on the screen and randomly generate clouds and walls. Create a new subclass of
    `World`, name it `CloudsWorld`, and assign a plain blue image to it for the background.
    You can either use the blue gradient background we used in [Chapter 4](part0030.xhtml
    "Chapter 4. Projectiles"), *Projectiles*, or create a new one using your favorite
    drawing program. As with the `Rocket` class, most of the code for `CloudsWorld`
    should be a review of previously provided code. Here is the code for `CloudsWorld`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的世界类的主要责任是在屏幕上最初放置火箭，并随机生成云和墙壁。创建一个新的`World`子类，命名为`CloudsWorld`，并为其分配一个纯蓝色图像作为背景。你可以使用我们在[第4章](part0030.xhtml
    "第4章。项目")“Projectiles”中使用的蓝色渐变背景，或者使用你喜欢的绘图程序创建一个新的。与`Rocket`类一样，`CloudsWorld`的大多数代码应该是之前提供的代码的复习。以下是`CloudsWorld`的代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Do you remember what the `act()` method looked liked in our latest version
    of Avoider Game? Here''s what it looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们最新版本的Avoider游戏中的`act()`方法的样子吗？下面是这个样子：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Doesn't it look similar to the `act()` method for `CloudsWorld`? We are going
    to use the same technique we used to generate enemies in Avoider Game to generate
    clouds in the Clouds application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来不像是`CloudsWorld`的`act()`方法吗？我们将使用在Avoider游戏中生成敌人的相同技术来在Clouds应用程序中生成云。
- en: Let's start by looking at the `generateActor()` method. This method takes an
    actor (type `Actor`) and an integer (type `int`) as parameters. The integer represents
    the chance that we add the supplied actor to the world. The higher the number,
    the more likely that the actor will appear on screen. With this method, we can
    easily implement the `generateBackgroundClouds()` method and the `generateWalls()`
    method. In these methods, we simply call `generateActor()`, providing the chance
    for the actor to appear on screen as well as a new instance of the desired actor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`generateActor()`方法。该方法接受一个角色（类型`Actor`）和一个整数（类型`int`）作为参数。整数代表我们将提供的角色添加到世界中的概率。数字越高，角色出现在屏幕上的可能性就越大。使用此方法，我们可以轻松实现`generateBackgroundClouds()`方法和`generateWalls()`方法。在这些方法中，我们简单地调用`generateActor()`，提供角色出现在屏幕上的机会以及所需角色的一个新实例。
- en: Side-scrolling actors
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 侧滚动角色
- en: 'All of the other actors in our scenario are going to be subclasses of the `SideScrollingActor`
    class. Create this by subclassing `Actor`, but do not associate an image with
    it. With the following code, we are using inheritance to provide the side-scrolling
    behavior to a whole set of actors:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们场景中的所有其他角色都将成为`SideScrollingActor`类的子类。通过从`Actor`类派生来创建它，但不要与它关联任何图像。使用以下代码，我们通过继承为一系列角色提供侧滚动行为：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To give the illusion that our rocket is moving from left to right, we make all
    of the scrolling actors move from right to left. That is why the speed variable
    is negative. In the `act()` method, we move the actor and then call `checkOffScreen()`
    to remove the actor after it has moved off screen. As we never intend to use the
    `SideScrollingActor` class to directly instantiate an object, we make it `abstract`.
    Next, we will discuss the actors that are going to the `SideScrollingActor` subclass.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生我们的火箭从左向右移动的错觉，我们让所有滚动角色从右向左移动。这就是为什么速度变量是负数的原因。在`act()`方法中，我们移动角色，然后调用`checkOffScreen()`来在角色移出屏幕后将其移除。因为我们从不打算直接使用`SideScrollingActor`类来实例化对象，所以我们将其设置为`abstract`。接下来，我们将讨论将要成为`SideScrollingActor`子类的角色。
- en: Clouds
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 云朵
- en: We use three different images of clouds for our application, and we will make
    them travel at different, random speeds. This will provide enough variety to give
    a realistic feel to our flying rocket. The three images I used are shown in *Figure
    2*. You can draw your own or the ones supplied at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用程序中使用三种不同的云朵图像，并将使它们以不同的随机速度移动。这将提供足够的多样性，使我们的飞行火箭看起来更真实。我使用的三个图像显示在*图2*中。你可以绘制自己的或提供的那些，在[http://www.packtpub.com/support](http://www.packtpub.com/support)。
- en: '![Clouds](img/image00305.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![云朵](img/image00305.jpeg)'
- en: 'Figure 2: These are images of clouds'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这些是云朵的图像
- en: 'Create a cloud actor by subclassing `SideScrollingActor`, naming it `Cloud1`,
    and then assigning one of your cloud images to it. In the class file for `Cloud1`,
    put the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`SideScrollingActor`派生，命名为`Cloud1`，并将你的云朵图像之一分配给它来创建一个云朵角色。在`Cloud1`的类文件中，放置以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In `Cloud1`, we assign a random value to the `speed` variable between `1` and
    `3`. We inherited the `speed` variable from the `SideScrollingActor` parent class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cloud1`中，我们给`speed`变量分配一个介于`1`和`3`之间的随机值。我们继承了`speed`变量来自`SideScrollingActor`父类。
- en: To create two more cloud actors, repeat the preceding steps once, substituting
    `Cloud1` with `Cloud2` and again substituting `Cloud1` with `Cloud3`. For further
    variety, you could change the `SPEEDRANGE` constant in each actor. I recommend
    setting `SPEEDRANGE` to `3` (as shown in Figure 2) for `Cloud1`, `2` for `Cloud2`,
    and `5` for `Cloud3`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建另外两个云朵角色，重复前面的步骤一次，将`Cloud1`替换为`Cloud2`，然后再将`Cloud1`替换为`Cloud3`。为了增加更多变化，你可以更改每个角色中的`SPEEDRANGE`常量。我建议将`Cloud1`的`SPEEDRANGE`设置为`3`（如图2所示），`Cloud2`为`2`，`Cloud3`为`5`。
- en: Walls
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 墙壁
- en: 'The last thing we need to add is the wall obstacle. While we only have one
    obstacle in this example, we are going to write code that would allow us to easily
    add additional obstacles in the future. We are going to use inheritance, but this
    time, we are using it to group related types, as opposed to sharing code. In the
    `Rocket Actor` code, we check for a collision with an `Obstacle` class. We will
    now create this class by subclassing `SideScrollingActor`, naming the new subclass
    `Obstacle`, and not associating an image with it. Here is the code for the `Obstacle`
    actor:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的最后一件事情是墙壁障碍物。虽然在这个例子中我们只有一个障碍物，但我们将要编写的代码将使我们能够轻松地在未来添加更多的障碍物。我们将使用继承，但这次，我们使用它来分组相关类型，而不是共享代码。在`Rocket
    Actor`代码中，我们检查与`Obstacle`类的碰撞。现在我们将通过从`SideScrollingActor`派生来创建这个类，将新的子类命名为`Obstacle`，并且不关联任何图像。以下是`Obstacle`角色的代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, we are not using inheritance for code reuse and, therefore, there is
    very little code to add.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们不是使用继承来重用代码，因此需要添加的代码非常少。
- en: 'Now, to create the `Wall` actor, we create a subclass of `Obstacle`. I simply
    created a dark gray rectangle image for my wall. I am sure you can come up with
    something better. Here is the code for the `Wall` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建`Wall`角色，我们创建了一个`Obstacle`的子类。我简单地为我墙壁创建了一个深灰色矩形图像。我相信你能想出更好的东西。以下是`Wall`类的代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since `Obstacle` inherits from `SideScrollingActor`, the `Wall` actor will have
    the same movement as the `Cloud` actors. However, the `Rocket` class can now detect
    collision with the `Obstacle` class. If we did collision detection with the `SideScrollingActor`
    class, then we would collide with clouds too.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Obstacle`从`SideScrollingActor`继承，`Wall`角色将与`Cloud`角色具有相同的移动方式。然而，`Rocket`类现在可以检测与`Obstacle`类的碰撞。如果我们使用`SideScrollingActor`类进行碰撞检测，那么我们也会与云发生碰撞。
- en: Try it out
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 试一试
- en: We have finished creating the world and actor classes for our Greenfoot scenario.
    *Figure 3* shows the completed Greenfoot scenario. Make sure your class hierarchy
    is exactly the same.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了为我们的Greenfoot场景创建世界和角色类。*图3*展示了完成的Greenfoot场景。确保你的类层次结构完全相同。
- en: '![Try it out](img/image00306.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![试一试](img/image00306.jpeg)'
- en: 'Figure 3: This shows the completed Clouds scenario'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：这显示了完成的云场景
- en: Compile it and take care of any typos you created along the way. Spend some
    time running the scenario and observing how the moving clouds give the illusion
    of travelling across an expansive sky. Even knowing how it is done, it is hard
    to imagine that your rocket is actually the actor on screen moving the least.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编译它，并注意你创建过程中的任何错误。花些时间运行场景，观察移动的云如何产生穿越广阔天空的错觉。即使知道它是如何实现的，也很难想象你的火箭实际上是屏幕上移动最少的演员。
- en: Mapped worlds
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射世界
- en: There are definitely times when you are going to want a specific background
    for your game or simulation. In these cases, it is not sufficient to randomly
    generate actors to simulate a moving background. The methods we will explore next
    consist of creating a background image that is much larger than the dimensions
    of the screen and moving it appropriately to simulate motion. In addition, we
    will learn how to place actors in this larger world.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 肯定有你想为你的游戏或模拟添加特定背景的时候。在这些情况下，仅仅随机生成演员来模拟移动背景是不够的。我们接下来要探索的方法包括创建一个比屏幕尺寸大得多的背景图像，并适当地移动它来模拟运动。此外，我们还将学习如何在这个更大的世界中放置演员。
- en: Side-scrolling
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侧滚动
- en: Our side-scrolling example is a scenario that allows the user to walk through
    a mountain forest to find a lake at the end. The user will only be able to walk
    left and right, not up and down. *Figure 4* shows the completed application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的侧滚动示例是一个允许用户穿越山林，最终找到湖的场景。用户只能左右移动，不能上下移动。*图4*展示了完成的应用。
- en: '![Side-scrolling](img/image00307.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![侧滚动](img/image00307.jpeg)'
- en: 'Figure 4: This is a screenshot of HikingWorld'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：这是HikingWorld的截图
- en: To create this side-scrolling world, we are going to need a large image to serve
    as the background. For this example, I have created a 2400 x 400 image shown in
    *Figure 5*. Since our scenario has a viewable screen size of 600 x 400, the image
    is six times longer than our screen. Feel free to create your own 2400 x 400 image
    or use the one supplied at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个滚动世界，我们需要一张大图作为背景。在这个例子中，我创建了一张2400 x 400像素的图像，如图5所示。由于我们的场景的可视屏幕大小为600
    x 400，所以这张图像比我们的屏幕长六倍。您可以自由地创建自己的2400 x 400像素图像，或者使用提供的[http://www.packtpub.com/support](http://www.packtpub.com/support)上的图像。
- en: '![Side-scrolling](img/image00308.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![侧滚动](img/image00308.jpeg)'
- en: 'Figure 5: This is a background image for HikingWorld that is 2400 pixels long
    and 400 pixels high. Note that the image in this figure is one-fourth the original
    size in order to fit on a page'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：这是HikingWorld的背景图像，长2400像素，高400像素。注意，这个图中的图像是原始大小的四分之一，以便适应页面
- en: Next, we will describe the code for the world and actor classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将描述世界和演员类的代码。
- en: The HikingWorld class
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HikingWorld类
- en: The main responsibility of our world class, `HikingWorld`, is to shift everything
    in the world relative to the user-controlled `Hiker` class. We will allow the
    user to move normally within the confines of a screen, but when a user tries to
    move further than the left boundary or the right boundary of the screen, we will
    move everything to the right-hand side or left-hand side, respectively. Figure
    6 demonstrates what we will do if the user is at the right edge of the screen
    and tries to move to the right-hand side.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的世界类`HikingWorld`的主要责任是将世界中的所有内容相对于用户控制的`Hiker`类进行移动。我们将允许用户在屏幕的范围内正常移动，但当用户尝试移动到屏幕的左侧边界或右侧边界之外时，我们将分别将一切移动到右侧或左侧。图6演示了如果用户在屏幕的右侧边缘并尝试向右移动时，我们会做什么。
- en: '![The HikingWorld class](img/image00309.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![HikingWorld类](img/image00309.jpeg)'
- en: 'Figure 6: If the player moves right at the right edge of the screen, we will
    shift everything to the left'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：如果玩家在屏幕的右侧边缘向右移动，我们将一切向左移动
- en: 'Now that we understand what the `HikingWorld` class must do, let''s take a
    look at the code. First, subclass `World` and name the new subclass `HikingWorld`.
    Do not associate an image with this new class; we will do that in the constructor
    function. Here is the code for what the `HikingWorld` class must do:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`HikingWorld`类必须做什么，让我们看看代码。首先，从`World`类派生出一个子类，并将其命名为`HikingWorld`。不要将图像与这个新类关联；我们将在构造函数中做这件事。以下是`HikingWorld`类必须执行的代码：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the beginning of the class, we create three constants to store the dimensions
    of the screen (`SWIDTH` and `SHEIGHT`) and the background image (`WWIDTH`). Since
    the image height and the screen height are the same, we don't need a `WHEIGHT`
    constant. We also declare the `xOffset` instance variable. We use this variable
    to keep track of how far the background image and actors are currently shifted.
    Last, we create an instance variable, `bimg`, to point to the background image.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在类开始时，我们创建了三个常量来存储屏幕的尺寸（`SWIDTH`和`SHEIGHT`）和背景图像的尺寸（`WWIDTH`）。由于图像高度和屏幕高度相同，我们不需要`WHEIGHT`常量。我们还声明了`xOffset`实例变量。我们使用这个变量来跟踪背景图像和演员当前移动的距离。最后，我们创建了一个实例变量`bimg`，指向背景图像。
- en: In the constructor, we load our background image and call `shiftWorld()` with
    an offset of `0` to put everything at its starting location. We use the `prepare()`
    method in a standard way—to place our initial actors. One thing to notice is that
    we use *y* positions larger than the screen size. So, some of our actors will
    be created, but placed off screen. Eventually, they will be shifted to be on screen
    and viewable by the user. The real work to make this world large is done in `shiftWorld()`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们加载我们的背景图像，并使用偏移量`0`调用`shiftWorld()`，将一切放置在其起始位置。我们以标准方式使用`prepare()`方法——放置我们的初始演员。需要注意的一点是，我们使用大于屏幕大小的*y*位置。因此，一些我们的演员将被创建，但放置在屏幕之外。最终，它们将被移动到屏幕上，用户可以看到。使这个世界变大的真正工作是在`shiftWorld()`中完成的。
- en: Notice the first `if` statement in the `shiftWorld()` method. This `if` statement
    prevents us from shifting the background image to the point where we would see
    the blank white space behind it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`shiftWorld()`方法中的第一个`if`语句。这个`if`语句防止我们将背景图像移动到我们看到它后面的空白白色空间的位置。
- en: If we are not at the edges of the background image, then we record the new offset
    by adding the current shift (`dx`) to the current offset (`xOffset`). Then, we
    proceed to shift the background image using the `shiftWorldBackground()` method
    and all actors in the world using `shiftWorldActors()`. The `shiftWorldBackground()`
    method is fairly simple. We start by creating a new image the size of the screen.
    We then draw our background image into it, offset by `xOffset` (which has just
    had `dx` added to it), and then set this new image to be the background image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在背景图像的边缘，那么我们将通过将当前的偏移量（`dx`）加到当前的偏移量（`xOffset`）上来记录新的偏移量。然后，我们使用`shiftWorldBackground()`方法移动背景图像，并使用`shiftWorldActors()`方法移动世界中的所有角色。`shiftWorldBackground()`方法相当简单。我们首先创建一个与屏幕大小相同的新图像。然后我们将背景图像绘制到其中，偏移量为`xOffset`（刚刚增加了`dx`），然后将这个新图像设置为背景图像。
- en: The `shiftWorldActors()` method may have few lines, but it does a lot of work.
    There is a `World` method called `getObjects()`provided to us that will return
    all of the actors in the world of the supplied class. For us, we call `getObjects(ScrollingActor.class)`
    to get all objects that should be shifted. The class the user controls, `Hiker`,
    is not a subclass of `ScrollingActor`; therefore, it will not be shifted in this
    method. We then iterate through the returned Java `List` and call `setAbsoluteLocation()`
    on each instance of `ScrollingActor`. We will look at the implementation of the
    `ScrollingActor` class and `setAbsoluteLocation()` soon.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`shiftWorldActors()`方法可能只有几行，但它做了很多工作。有一个名为`getObjects()`的`World`方法提供给我们，它将返回所提供类中的所有角色。对我们来说，我们调用`getObjects(ScrollingActor.class)`来获取所有应该移动的对象。用户控制的类`Hiker`不是`ScrollingActor`的子类；因此，在这个方法中它不会被移动。然后我们遍历返回的Java
    `List`，并对每个`ScrollingActor`实例调用`setAbsoluteLocation()`。我们很快将查看`ScrollingActor`类和`setAbsoluteLocation()`方法的实现。'
- en: The majority of the work for creating a side-scrolling world is done in `HikingWorld`.
    Make sure you understand this code before moving on. The rest of the code for
    the remaining actors in this scenario is pretty straightforward.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建侧滚动世界的绝大部分工作都在`HikingWorld`中完成。在继续前进之前，请确保你理解这段代码。这个场景中剩余角色的代码相当直接。
- en: The Hiker class
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Hiker`类'
- en: 'We will have one instance of the `Hiker` class that the user will control.
    In this scenario, we are only going to let the user move left and right. This
    amount of control is sufficient to demonstrate a side-scrolling scenario. The
    code for this class is almost identical to the code for the `Rocket` actor in
    the Clouds scenario we created at the beginning of this chapter. First, look at
    the code, and then we will discuss the differences:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个`Hiker`类的实例，用户将控制它。在这个场景中，我们只允许用户左右移动。这种程度的控制足以演示侧滚动场景。这个类的代码几乎与我们在本章开头创建的Clouds场景中的`Rocket`角色的代码相同。首先，看看代码，然后我们将讨论差异：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The main difference occurs in `boundedMove()`. In the `Rocket` class presented
    earlier, we had a similar method that confined the user movement to a rectangular
    area slightly smaller than the screen. We are doing the same here for horizontal
    movement, but with one added feature. When we detect that the user is at the edge
    of the screen (either the left-hand side or the right-hand side), we will call
    `shiftWorld()` to make it look as though the actor is continuing to move.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别发生在`boundedMove()`方法中。在前面提到的`Rocket`类中，我们有一个类似的方法，它将用户移动限制在比屏幕略小的矩形区域内。我们在这里对水平移动做同样的事情，但增加了一个功能。当我们检测到用户位于屏幕边缘（无论是左侧还是右侧）时，我们将调用`shiftWorld()`来使其看起来像角色正在继续移动。
- en: We also have the `checkAtLake()` method that has no implementation. It is an
    example of how you could have a goal at the end of your world that the user must
    get to. In our case, we are going to place a lake at the end of the hike. We would
    use this method if we wanted to do something once the user arrived at the lake.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个没有实现的`checkAtLake()`方法。这是你可以在世界的尽头设置一个目标，用户必须到达的例子。在我们的案例中，我们将在徒步旅行的尽头放置一个湖。如果我们想在用户到达湖边后做些什么，我们会使用这个方法。
- en: The ScrollingActor class
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ScrollingActor`类'
- en: 'All of the actors we want to shift will subclass the `ScrollingActor` class.
    It provides both a convenient way to group these actors and allows us to define
    the `setAbsoluteLocation()` method in one place. Here''s how it''s done:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要移动的所有角色都将继承自`ScrollingActor`类。它提供了一个方便的方式来分组这些角色，并允许我们在一个地方定义`setAbsoluteLocation()`方法。下面是如何实现的：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `HikingWorld` class, we called `setAbsoluteLocation()` on all the actors
    we wanted to shift. This method is simply a wrapper for `setLocation()` and moves
    the actor by the `dx` amount.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HikingWorld`类中，我们对所有需要移动的演员调用了`setAbsoluteLocation()`方法。这个方法只是`setLocation()`的一个包装，通过`dx`值移动演员。
- en: 'The code for the `HedgeHog`, `Lemur`, and `Lake` actors are identical and very
    minimal. Those classes mainly exist to allow different images to be associated
    with them. The images for a hedgehog and lemur come with the default installation
    of Greenfoot. My lake is a simple blue oval created in a drawing program. These
    actors are placed in the world in the `prepare()` method of `HikingWorld`. Create
    each of these now and add the following code to each (make sure to substitute
    in the appropriate class name):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`HedgeHog`、`Lemur`和`Lake`演员的代码相同且非常简洁。这些类主要存在是为了允许将不同的图片与它们关联。刺猬和狐猴的图片包含在Greenfoot的默认安装中。我的湖是一个简单的蓝色椭圆形，在绘图程序中创建。这些演员在`HikingWorld`的`prepare()`方法中被放置到世界中。现在创建每个这些演员，并将以下代码添加到每个演员中（确保用适当的类名替换）：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Try it out
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试运行
- en: Congratulations! You have created a side-scrolling, mapped world. Compile it
    and try it out. For an extra challenge, implement the `checkAtLake()` method found
    in the `Hiker` class to reward the hiker for reaching their destination. You can
    also download a completed version of the scenario at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经创建了一个横向卷轴、已映射的世界。编译并尝试运行它。为了增加挑战，实现`Hiker`类中的`checkAtLake()`方法，以奖励徒步旅行者到达目的地。您还可以在[http://www.packtpub.com/support](http://www.packtpub.com/support)下载该场景的完整版本。
- en: 2D scrolling
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D滚动
- en: Creating an application that allows a user to explore a large map in both the
    *x* (left and right) and *y* (up and down) directions is an easy extension of
    the side-scrolling world we just created. The code will be exactly the same except
    we will also handle the case for up and down movement. We also need an image that
    is both longer and wider than the screen size of our scenario. The image I created
    is 1200 x 1200 pixels and shown in *Figure 7*. You can create your own or download
    the image from *Figure 7* at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    The picture is meant to represent a top-down view of a terrain with trees.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个允许用户在*x*（左右）和*y*（上下）方向上探索大地图的应用程序，是我们在刚刚创建的横向卷轴世界的一个简单扩展。代码将完全相同，除了我们还将处理上下移动的情况。我们还需要一个比我们场景的屏幕尺寸更长更宽的图片。我创建的图片是1200
    x 1200像素，并在*图7*中展示。您可以创建自己的图片或从[http://www.packtpub.com/support](http://www.packtpub.com/support)下载*图7*中的图片。这张图片旨在表示一个带有树木的地形的俯视图。
- en: '![2D scrolling](img/image00310.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![2D滚动](img/image00310.jpeg)'
- en: 'Figure 7: A background image for HikingWorld2D that is 1200 pixels long and
    1200 pixels high. Note that the image shown in this figure has been scaled down
    to fit on the page.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：HikingWorld2D的背景图片，长宽均为1200像素。请注意，本图中的图片已被缩小以适应页面。
- en: Create a new scenario and name it `HikingWorld2D`. As this code is very similar
    to the `HikingWorld` scenario we just implemented in the previous section, we
    will only highlight the code necessary to handle up and down movement.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并命名为`HikingWorld2D`。由于此代码与我们在上一节中实现的`HikingWorld`场景非常相似，我们只需突出显示处理上下移动所需的代码。
- en: The HikingWorld2D class
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`HikingWorld2D`类'
- en: 'Subclass `World` and name the new class `HikingWorld2D`, but do not associate
    an image with it. We will add the image shown in *Figure 7* (or one like it that
    you create) in the constructor function of this class. Here is the code to accomplish
    all this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 继承`World`类并命名新类为`HikingWorld2D`，但不要为其关联图片。我们将在该类的构造函数中添加*图7*（或您创建的类似图片）。以下是完成所有这些任务的代码：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we get `WWIDTH` and `WHEIGHT` to be the dimensions of the background
    image. Previously, we did not need `WHEIGHT` as it was the same as `SHEIGHT`.
    The main difference between this class and the `HikingWorld` class in `HikingWorld,`
    is that we add an extra parameter (`dy`) to `shiftWorld()`, `shiftWorldBackground()`,
    and `shiftWorldActors()` that provides the change in the *y* direction. The use
    of the new `dy` parameter mirrors the use of the `dx` parameter. We end up shifting
    the background image and other actors by both `dx` and `dy`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`WWIDTH`和`WHEIGHT`设置为背景图像的尺寸。之前，我们不需要`WHEIGHT`，因为它与`SHEIGHT`相同。这个类与`HikingWorld`类在`HikingWorld,`中的主要区别是，我们在`shiftWorld()`、`shiftWorldBackground()`和`shiftWorldActors()`中添加了一个额外的参数（`dy`），它提供了*y*方向上的变化。新`dy`参数的使用反映了`dx`参数的使用。我们最终通过`dx`和`dy`同时移动背景图像和其他演员。
- en: The Hiker class
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漫步者类
- en: 'Create a new subclass of `Actor`, name it `Hiker`, and associate one of the
    default people images provided by Greenfoot. Here is the code for this new class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`Actor`子类，命名为`Hiker`，并关联Greenfoot提供的默认人物图像之一。以下是这个新类的代码：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class has also been augmented to handle moving in the *x* and *y* directions.
    In `handleKeyPresses()`, we added two more calls to `handleArrowKey()` to handle
    the up and down arrow keys being pressed. In `boundedMove()`, we add checks to
    make sure the actor does not move off the top or bottom of the screen and that
    it calls `shiftWorld()` at the appropriate times.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也被增强以处理*x*和*y*方向上的移动。在`handleKeyPresses()`中，我们添加了两个额外的`handleArrowKey()`调用，以处理上下箭头键被按下。在`boundedMove()`中，我们添加了检查以确保演员不会移动到屏幕的顶部或底部，并在适当的时候调用`shiftWorld()`。
- en: The ScrollingActor class
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动演员类
- en: 'Create a new subclass of `Actor` and name it `ScrollingActor`. You do not need
    to associate an image with it. As before, this class simply provides a wrapper
    for `setLocation()`. Now, it handles moving the actor in the *y* direction as
    well. Here is the code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`Actor`子类，命名为`ScrollingActor`。你不需要为它关联一个图像。和之前一样，这个类仅仅提供了一个`setLocation()`方法的包装。现在，它还处理在*y*方向上的移动。以下是代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `HedgeHog`, `Lemur`, and `Lake` classes are exactly the same as they were
    in the `HikingWorld` scenario shown previously. Add them to `HikingWorld2D` as
    well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`HedgeHog`、`Lemur`和`Lake`类与之前在`HikingWorld`场景中展示的完全相同。将它们添加到`HikingWorld2D`中。'
- en: Try it out
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试一下
- en: With just a few changes, we have created a world worth exploring, and all it
    took were a few extensions to our already completed `HikingWorld` scenario. Now,
    it is time to compile and try your scenario out. Handle any typos/errors and then
    explore the map. You can also download a completed version of the scenario at
    [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几处改动，我们就创建了一个值得探索的世界，而我们所做的只是对已经完成的`HikingWorld`场景进行了一些扩展。现在，是时候编译并尝试你的场景了。处理任何拼写错误或错误，然后探索地图。你还可以在[http://www.packtpub.com/support](http://www.packtpub.com/support)下载场景的完整版本。
- en: Tile-based worlds
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于瓦片的宇宙
- en: Tile-based worlds are a happy incorporation between fully dynamically created
    worlds and worlds that use a large image for the background. With large images,
    you create a very detailed and predictable world, but it is very difficult to
    change. Dynamically created worlds are easy to generate but are often too random.
    Tile-based worlds let you easily create detailed, predictable worlds in a way
    such that they are easy to change or modify.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于瓦片的宇宙是全动态创建的宇宙和那些使用大图像作为背景的宇宙的愉快结合。使用大图像，你可以创建一个非常详细且可预测的世界，但改变它非常困难。动态创建的宇宙容易生成，但通常太随机。基于瓦片的宇宙让你能够轻松创建详细、可预测的世界，同时易于更改或修改。
- en: Actors as tiles
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为瓦片的演员
- en: Artists can create amazing images using small pieces of tile or glass. *Figure
    8* shows a simple tile mosaic. By strategically placing small pieces of colored
    tiles, you can generate many different types of images.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家可以使用小块的瓦片或玻璃创造出惊人的图像。*图8*展示了一个简单的瓦片马赛克。通过策略性地放置小块彩色瓦片，你可以生成许多不同类型的图像。
- en: '![Actors as tiles](img/image00311.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![作为瓦片的演员](img/image00311.jpeg)'
- en: 'Figure 8: This is a simple mosaic, courtesy of pixabay.com at http://pixabay.com/en/uzbekistan-mosaic-pattern-artfully-196875/'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：这是一个简单的马赛克，由pixabay.com提供，链接为http://pixabay.com/en/uzbekistan-mosaic-pattern-artfully-196875/
- en: We will use a similar technique to create a world in Greenfoot, but we will
    use small actors instead of tiles. *Figure 9* demonstrates how we will do this.
    We will create a set of actors that will serve as our tiles. Then, we will specify
    how to compose these actors to create images using an array of strings that uses
    letters to code the type of actor to place. For example, the letter `C` corresponds
    to the actor displaying a cloud with a blue background, and the letter `F` corresponds
    to the actor displaying a flower on a green background. *Figure 9* shows a 4 x
    3 matrix of letters that is used to specify the tile layout that creates the final
    image. In the matrix, the upper-left corner letter is an `S`; therefore, the upper-left
    corner of the image is solid blue.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似的技术在Greenfoot中创建世界，但我们将使用小演员而不是瓦片。*图9*演示了我们将如何做到这一点。我们将创建一组演员，它们将作为我们的瓦片。然后，我们将指定如何使用一个字符串数组来组合这些演员，该数组使用字母来编码要放置的演员类型。例如，字母`C`对应于显示蓝色背景的云朵的演员，而字母`F`对应于显示绿色背景的花的演员。*图9*显示了一个4
    x 3的字母矩阵，用于指定创建最终图像的瓦片布局。在矩阵中，左上角的字母是`S`；因此，图像的左上角是纯蓝色。
- en: '![Actors as tiles](img/image00312.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![演员作为瓦片](img/image00312.jpeg)'
- en: 'Figure 9: This shows the mapping of individual actors to create a larger world'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：此图显示了将单个演员映射以创建更大世界的过程
- en: Hopefully, you now have a sense of how tile-based world creation will work.
    In the coming snippet, we code the hiking world scenario again, but this time
    modified to use tile-based world creation. Much of the code is directly borrowed
    from the 2D-scrolling hiking world we built in the last section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在对基于瓦片的世界创建的工作方式有了感觉。在接下来的代码片段中，我们将再次编写徒步世界场景的代码，但这次修改为使用基于瓦片的世界创建。大部分代码直接借鉴了我们上一节中构建的2D滚动徒步世界。
- en: Create a new scenario and name it `HikingWorldTiled`. The world and actor classes
    for this scenario are described in the next section. We only highlight the additions
    pertinent to tile-based world creation. *Figure 10* shows a screenshot from the
    completed scenario. I provide this now, so that you can quickly see all the classes
    we will implement and get a glimpse of part of the image we will be creating.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并将其命名为`HikingWorldTiled`。本节将描述此场景的世界和演员类。我们只突出与基于瓦片的世界创建相关的添加。*图10*显示了完成场景的截图。我现在提供这个截图，以便您可以快速查看我们将要实现的全部类，并一瞥我们将要创建的图像的一部分。
- en: '![Actors as tiles](img/image00313.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![演员作为瓦片](img/image00313.jpeg)'
- en: 'Figure 10: This is a screenshot of the completed HikingWorldTiled scenario'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：这是完成后的HikingWorldTiled场景的截图
- en: The HikingWorld class
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`HikingWorld`类'
- en: 'Create `HikingWorld` by subclassing `World`. We are dynamically creating a
    background image, so you don''t want to associate an image with this class; here
    is the code to accomplish this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承`World`类创建`HikingWorld`。我们正在动态创建一个背景图像，因此你不想将图像与这个类关联；以下是实现此功能的代码：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The two new parts of this class are the array of strings, `WORLD`, declared
    at the top of the class, and the `createWorldFromTiles()` method, which uses the
    method `addActorAtTileLocation()` to assist in building the world from the existing
    actors. The `WORLD` array specifies where we are going to place each actor that
    makes up part of the background. We have three actors we will use for our background
    image; they are `BlackBlock`, `WhiteBlock`, and `BlueBlock`. These actors use
    images that are 25 x 25 pixels. This is a decent size for a tile—any smaller and
    your `WORLD` array will be too large and tedious to manage, and any larger and
    you will lose the ability to create detail.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的新部分是位于类顶部的字符串数组`WORLD`和`createWorldFromTiles()`方法，它使用`addActorAtTileLocation()`方法来帮助从现有演员构建世界。《WORLD》数组指定了我们将放置构成背景的每个演员的位置。我们将使用三个演员来创建我们的背景图像；它们是`BlackBlock`、`WhiteBlock`和`BlueBlock`。这些演员使用25
    x 25像素的图像。这对于瓦片来说是一个合适的大小——任何更小，你的`WORLD`数组都会太大且难以管理，任何更大，你将失去创建细节的能力。
- en: The `WORLD` array has sixteen strings in it that each contain forty-eight characters,
    thus the size of the image we are creating is 1200 (48 x 25) x 400 (16 x 25).
    The letter `B` corresponds to the `BlackBlock` actor, the letter `W` corresponds
    to the `WhiteBlock` actor, and the letter `U` corresponds to the `BlueBlock` actor.
    This mapping is captured in the `switch` statement in the `addActorAtTileLocation()`
    method. Knowing the mapping, you can look at the `WORLD` array and see that the
    image will have a black border and white background, and will spell the word `Hi`
    in blue.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORLD` 数组中有十六个字符串，每个字符串包含四十八个字符，因此我们创建的图像大小为 1200（48 x 25）x 400（16 x 25）。字母
    `B` 对应于 `BlackBlock` 演员字母，字母 `W` 对应于 `WhiteBlock` 演员字母，字母 `U` 对应于 `BlueBlock`
    演员字母。这种映射在 `addActorAtTileLocation()` 方法中的 `switch` 语句中被捕获。了解映射后，你可以查看 `WORLD`
    数组，并看到图像将有一个黑色边框和白色背景，并用蓝色拼写出单词 `Hi`。'
- en: OK, let's go through `createWorldFromTilesMethod()`. This method iterates through
    every character of every string in `WORLD`. For each character, it calls `addActorAtTileLocation()`,
    supplying parameters that specify the character that indicates which tile should
    be placed as well as the location for that tile. In `addActorAtTileLocation()`,
    we create a new actor based on the character passed to it and then use the provided
    `x` and `y` values to place the new actor in the world.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来分析 `createWorldFromTilesMethod()`。此方法遍历 `WORLD` 中每个字符串的每个字符。对于每个字符，它调用
    `addActorAtTileLocation()`，提供参数指定表示哪个瓦片应放置的字符以及该瓦片的位置。在 `addActorAtTileLocation()`
    中，我们根据传递给它的字符创建一个新的演员，然后使用提供的 `x` 和 `y` 值将新演员放置在世界上。
- en: The Hiker class
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hiker 类
- en: 'The code here is identical to the code we looked at earlier for the `Hiker`
    class in the dynamically created world. I reproduce it here for convenience and
    because it is relatively short:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码与我们在动态创建的世界中查看的 `Hiker` 类的代码相同。我在这里重新呈现它是为了方便，因为它相对较短：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The ScrollingActor class
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ScrollingActor 类
- en: 'This code is also identical to the code provided for the first scenario we
    created in this chapter. *It is important to note here, that the actors we are
    using to create the world could also have additional functionality and not simply
    be a passive background image*. For example, you could have a *Fire* tile that
    would burn the hiker if it collided with it. Here''s the code we are discussing:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也与我们在本章中创建的第一个场景提供的代码相同。*在此需要注意的是，我们用来创建世界的演员也可能具有额外的功能，而不仅仅是被动背景图像*。例如，你可以有一个*火焰*瓦片，如果徒步旅行者与之碰撞，就会将其烧毁。以下是我们要讨论的代码：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tiles
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 瓦片
- en: 'The code for the `BlackBlock`, `BlueBlock`, and `WhiteBlock` actors are nearly
    identical. The only difference is the name of the class and the associated image.
    Take a look at the code for `BlackBlock`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlackBlock`、`BlueBlock` 和 `WhiteBlock` 演员的代码几乎相同。唯一的不同之处在于类的名称和相关的图像。看看 `BlackBlock`
    的代码：'
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is important that the images for these actors are all the same size, to make
    them easy to compose into a larger image. In our case, the images are 25 pixel
    x 25 pixel colored squares.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这些演员的图像大小都相同，以便它们容易组合成更大的图像。在我们的例子中，图像是 25 像素 x 25 像素的有色方块。
- en: The Lake class
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lake 类
- en: 'The `Lake` class is the same as in the first scenario. It is important to note
    that not all subclasses of `ScrollingActor` have to serve as tiles for the background
    image. The `Lake` actor represents our final destination This is how the `Lake`
    class is used:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lake` 类与第一个场景中的相同。需要注意的是，并非所有 `ScrollingActor` 的子类都必须作为背景图像的瓦片。`Lake` 演员代表我们的最终目的地。这是
    `Lake` 类的使用方法：'
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can just copy it and its associated image from the previous scenario.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接复制它及其相关的图像从上一个场景。
- en: Try it out
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Compile the scenario and run it. It should feel similar to the side-scrolling
    example we provided after the Clouds scenario, except now it is very easy to change
    the image of the world. Instead of `Hi` being spelled in the background, spell
    your name. For a challenge, change the `Hiker` class such that if it touches a
    blue block, the game ends.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 编译场景并运行它。它应该与我们在 Clouds 场景之后提供的侧滚动示例感觉相似，但现在很容易更改世界的图像。在背景中拼写 `Hi` 的地方，拼写你的名字。作为一个挑战，更改
    `Hiker` 类，使其在接触蓝色方块时游戏结束。
- en: Other game sprites
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他游戏精灵
- en: In our example, the tiles were very simple. The real strength of tile-based
    world creation comes from having a wide variety of tiles to choose from to create
    an interesting world. You can either create your own world, download some from
    sites that charge, such as [http://cartoonsmartart.com](http://cartoonsmartart.com),
    or download from 100 percent free sites, such as [http://opengameart.org](http://opengameart.org).
    *Figure 11* shows an example of a free tile set from [http://opengameart.org](http://opengameart.org).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，瓦片非常简单。基于瓦片的世界创建的真正优势在于拥有广泛的选择，可以创建一个有趣的世界。您可以创建自己的世界，从付费网站下载一些，例如[http://cartoonsmartart.com](http://cartoonsmartart.com)，或者从100%免费的网站下载，例如[http://opengameart.org](http://opengameart.org)。*图11*展示了来自[http://opengameart.org](http://opengameart.org)的免费瓦片集的一个示例。
- en: '![Other game sprites](img/image00314.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![其他游戏精灵](img/image00314.jpeg)'
- en: 'Figure 11: This is a free tile sheet from opengameart.org provided by Kenny
    at http://opengameart.org/content/rpg-pack-base-set'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：这是来自opengameart.org并由Kenny在http://opengameart.org/content/rpg-pack-base-set提供的免费瓦片图集。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By combining the techniques of large-world creation presented in this chapter,
    with the other concepts and techniques presented in previous chapters, you are
    fully equipped to create endless forms of information, entertainment, and immersive
    experiences using Greenfoot. In the next chapter, we will explore making actors
    in your applications behave intelligently to further enhance user experience.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合本章中介绍的大型世界创建技术，以及其他章节中介绍的概念和技术，您已经完全准备好使用Greenfoot创建无限形式的信息、娱乐和沉浸式体验。在下一章中，我们将探讨如何使您的应用程序中的演员智能行为，以进一步增强用户体验。
