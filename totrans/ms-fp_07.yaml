- en: The Idea of the Type Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw the views of functional programming on data
    representation. In functional programming, data is most often encountered in the
    form of what a function returns. This result is usually a data structure that
    includes both the results of the function and data about the side effects that
    have occurred in the function. Different side effects are represented with different
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how analyzing and working with these data structures can become
    tedious, so functional programming gives rise to patterns such as map and `flatMap`.
    There are many more patterns for working with effect types. The `map` and `flatMap`
    are just utility methods that are used in a specific context. However, they are
    general enough to repeat from one data type to another.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how functional programming treats the behavior
    of data structures. We will see how things such as `map` and `flatMap` are organized
    into logical units, and show how these types represent the behavior of data structures.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce a notion of type classes, and we will cover the reasoning
    behind it in order to better understand this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Rich Wrapper pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Type Class pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpretation of the Type Class pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type Classes in different languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich Wrapper pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start our journey to understand the pattern of type
    classes. We'll start by covering the idea of the *Rich Wrapper* pattern. The pattern
    is specific to Scala, but it introduces the problem of separating data from behavior,
    which becomes important in the Type Class pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the following problem. Scala is a language built on top of JVM, so
    it has access to the Core Java library, and you can use the Java Core classes.
    You can also use any Java library in your Scala programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, Scala String and Array data types come from the Java Core. However,
    if you are familiar with Scala, you know that String and Array are more like Scala
    collections than Java strings and arrays. They are treated this way because Scala
    provides you with a set of extra methods, such as `map`, `flatMap`, and `filter`, on
    top of these types. So all the methods that ordinary Scala collections have are
    also available when working with strings and arrays. Strings are treated as collections
    of characters, and arrays as indexed sequences of elements.
  prefs: []
  type: TYPE_NORMAL
- en: How is it possible that in Scala we have collections methods on strings and
    arrays that come from Java? The answer is that Scala has a mechanism to simulate
    method injection into classes. We can have a class that comes from a third-party
    library in Scala and be able to inject additional methods into this class, without
    modifying its original implementation and not extending the original class via
    subtyping. This mechanism for method-injection is handy in the context of separating
    data from its behavior in the functional world.
  prefs: []
  type: TYPE_NORMAL
- en: This solution is called the **Rich Wrapper** pattern. To understand it, you
    need to understand the mechanism of implicit conversions that Scala has. This
    mechanism provides a way to make the compiler do extra work that ordinarily is
    done manually. The easiest way to understand the implicit conversions is with
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have two different models of the same domain. Some methods
    expect the domain objects of one domain, but you want to call them with the domain
    objects of another domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, imagine a web API that responds to HTTP requests with JSON. You
    may want to have two versions of the object that represents your users. One version
    is a full version of this entity. It contains the password hash and all the other
    data. Here is the full version is the internal representation of the entity, meant
    to be used on the backend and not meant to be leaked to the end user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another version of this object is supposed to be sent to the end user upon
    their HTTP requests to the web API. We don''t want to expose too much information,
    so we are going to return a shortened version of this object. This version does
    not expose any sensitive information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider that you need to return an object from a server from a request handler.
    Since the backend represents users with the `FullUser` class, we''ll first need
    to convert it into `ShortUser` using a conversion method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider also that the following method must be executed in order to return
    an object from a request handler in response to the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume we have a `root` user and we need to be able to return it upon
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code snippet, we can imagine an HTTP request handler defined
    along the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You don't want to explicitly perform the conversion from the backend representation
    each time you need to return this object. There may be many contexts in which
    you may want to do so. For example, you can associate the `User` entity with forum
    posts of that user or their comments when these are requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of implicit conversions exists precisely for these situations.
    In Scala, you can define a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we use a `FullUser` instance in a place where `ShortUser` is expected,
    the conversion from the full object into the short object will be done automatically
    by the compiler using the `implicit` method in scope. This way, you can convert
    one value to another implicitly, without cluttering the code with irrelevant details.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the implicit conversion in scope, we can write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is equivalent to the original code where the conversion is
    done explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Rich Wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are implicit conversions related to the example when we need to inject methods
    into classes? We can treat method-injection as a conversion problem. We can use
    the wrapper pattern to define a class that wraps the target class (that is, accepts
    it as a constructor argument) and defines the methods that we need. We can then
    implicitly convert the original class to the wrapper whenever are we are calling
    any of the methods that are not initially present in the wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. We are calling a `filter` method on a String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method is not a member of the `String` class, as the `String` class here
    is `java.lang.String`. However, Scala collections have this method. What happens
    next is that the compiler realizes that the object does not have this method,
    but it does not fail right away. Instead, the compiler starts to look for implicit
    conversions in scope that can convert this object into some other object that
    does have the required method. The mechanics here are the same as in the case
    when we are passing the user object to a method as an argument. The point is that
    the compiler expects one type but receives another type in its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the compiler expects the type with the `filter` method defined
    on it but receives a `String` type that does not have this method. Hence, it will
    try to convert it to the type that matches its expectations, that is, the existence
    of the `filter` method in the class. It turns out that we do have such a method
    in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is an implicit conversion defined in the `Predef` object in Scala that
    converts strings into a Rich Wrapper with all the collections methods, including `filter`.
    The same technique is used to inject the Scala collection methods into Java's
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is not specific to Scala, although the underlying mechanism is.
    In one form or another, it is present in many languages. For example, in C#, you
    have the concept of implicit conversions and can convert one type to another implicitly.
    In Haskell, we have a more powerful, functional version of the same technique.
  prefs: []
  type: TYPE_NORMAL
- en: The Type Class pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the effect type that we are going to use is not known in advance.
    Consider the problem of logging. Logging can be performed to a list or a file.
    Logging to a list can be implemented using the Writer effect type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Writer is an abstraction of a pair of a result and a log generated by a computation.
    In its simplest form, a Writer can be understood as a pair of a list of strings
    and an arbitrary result. We can define the Writer effect type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have also defined the familiar `map` and `flatMap` methods for
    this effect type.
  prefs: []
  type: TYPE_NORMAL
- en: A few words should be said about how we have implemented the `flatMap` method.
    We are using a simplified version of the Writer type, in fact. In its simplified
    form, it is a data structure that contains a result and a list of strings—the
    log entries—in one data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` method answers the question of how to combine sequential computations
    whose effect is `SimpleWriter`. So, given two such computations, one being a continuation
    of another (that is, the result of the previous computation parameterizes it),
    the question is—how do we produce the result of that continuation so that the
    log of the previous computation is preserved in that result?
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, you can see how the implementation of the `flatMap`
    method is done for the `SimpleWriter` data structure. So, first, we run the continuation
    with the result of the current data structure as an input. This run produces another
    result under the side effect of `SimpleWriter`, that is, a result with a log of
    the computation. After that, we produce a combined Writer with the result of the
    second computation and the combined logs of the first and second computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a companion object for this data type that contains convenience
    methods to lift any value to the effect type and to create an empty structure
    with a single log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Writer effect type, we can use logging from an operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Logging to a file can be implemented with the help of another effect, `IO`.
    The `IO` type stands for an input-output effect, which means that the computation
    exchanges information with some external resources. We can define a dummy version
    of IO that just suspends a computation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding definition follows the same pattern as the `SimpleWriter` type.
    The `log` method does not actually write to any file, but simulates this operation
    by outputting to the terminal. With the help of this effect type, we can use logging
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we do not know beforehand where we are going to log? What if sometimes
    we need to log to a file and sometimes we need to log to a list? The preceding
    can be the case if we are working in different environments, for example, stage,
    test, or production. The question is: how exactly should we proceed with generalizing
    the preceding code so that it is effect-independent? The problem here is that
    the preceding two snippets differ only in the effect type they are using to log.
    In programming, whenever we see a pattern, it is a good idea to extract it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to abstract away the effect type is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, the effect type becomes an `F` type parameter. The function becomes parameterized
    on the type level. However, when we try to implement the body of the method, we
    will quickly run into difficulties. The preceding code does not compile because
    the compiler knows nothing about the `F` type parameter. We are calling the `map`
    and `flatMap` methods on this type, and the compiler has no way of knowing which
    methods are implemented on this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem comes in the form of the Type Class pattern. Under
    the Type Class pattern, the method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The reason we can use the `map` and `flatMap` methods here is that we now have
    an implicit dependency in the method's arguments list. The dependency in question
    is on the type class called `Monad`. `Monad` is one of the most common type classes
    in functional programming. One more dependency is Logging, which provides the
    `log` method, which is also a common method available for both effect types we
    are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what type classes are and how they work on the example of `Monad`.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the function, we can use the `map` and `flatMap` functions, and
    the compiler can resolve them. Previously, we saw the same method-injection trick
    done with the help of implicit dependencies. In that case, we had an implicit
    conversion that converts the target type to a Rich Wrapper. In this case, a similar
    pattern is used. However, it is more complex. The complexity is because Rich Wrapper
    wrapped concrete classes, but we are now targeting abstract type variables, in
    our example, it is `F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as in the case of Rich Wrappers, the `map` and `flatMap` methods are injected
    into the preceding code using implicit conversions. Let''s have a look at the
    methods and classes that enable this conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, you can see the entire code that enables the
    required conversion. This code implements the Type Class pattern. Let''s have
    a look at it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see the definition of the trait that
    contains all the methods that a particular set of effect types must implement.
    The concrete implementations of the trait will have the trait's type parameter
    set to the type for which the class is implemented. The trait consists of the
    declaration of all the methods that the type in question is supposed to support.
    Notice that all of the methods expect the object on which they are supposed to
    be called. This means this trait is not supposed to be implemented by the target
    object. Instead, the instances of this trait are supposed to be a sort of toolbox
    that defines certain behaviors for the type in question, without making that type
    extend the trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a companion object of this trait. This companion object defines
    specific methods that are also part of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, there is a Rich Wrapper, as you can see in the preceding code.
    The pattern works the same way as we have seen previously, in the case of wrappers
    for strings and arrays. However, there is one little difference. It is defined
    on an `F[A]` abstract type. In principle, it can be any effect type. It may seem
    at first that we are defining a set of methods for every type possible. However,
    there are constraints on the types for which the methods are implemented. The
    constraints are enforced by the implicit argument that follows a constructor of
    the Rich Wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, to construct the wrapper, we need to satisfy an implicit dependency on the
    type class defined in the preceding code snippet. This means that for the `F` type
    to be able to use the Rich Wrapper pattern, we need to have an instance of the
    trait defined in the preceding code in scope implicitly for this `F` type. When
    we say *an instance of the type class for the F type*, we mean a concrete object
    that extends the type class trait where the type parameter is set to `F`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a `Monad for Writer` instance is an object whose type conforms
    to `Monad[Writer]`.
  prefs: []
  type: TYPE_NORMAL
- en: All the Rich Wrapper's methods mimic that of the type class and are delegated
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we have some default implementations of the type class for certain
    common classes. For example, we can define ones for our Writer and IO types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding examples, we implement the `map` and `flatMap` methods
    by delegating them to the implementations owned by the `SimpleWrapper` and IO
    classes. This is because we have already implemented these classes with the methods
    in question. In the real world, it is often the case that the classes will not
    have the required methods. So you will write the entire implementation of them
    instead of delegating them to the methods owned by the classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `Monad`, the `Logging` type class encapsulates the `log` method
    common to the two effect types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It follows the same pattern as the `Monad` type class. First, the trait declares
    the methods the type class will have. Next, we have the companion object with
    some default implementations for our effect types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how the preceding code enables the logging example to use the `flatMap`
    and `map` methods, and how the mechanics of implicit resolution work here.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the compiler sees that we are trying to call the `flatMap` method
    on an `F` type. The compiler doesn't know anything about the `F` type—it is not
    aware of whether it has the method in question. In an ordinary programming language,
    a compile-time error would have occurred at this point. However, in Scala, implicit
    conversions kick in. The compiler will try to convert this `F` type to something
    that has the required `flatMap` method. It will start the implicit lookup to find
    the implicit conversion that would convert an arbitrary `F` type into something
    that has the required method. It will find such a conversion. The conversion will
    be the Rich Wrapper of the `Monad` type class, as discussed previously. The compiler
    will see that it can convert any `F[A]` effect type into a wrapper that has the
    required methods. However, it will see that it is not able to do so unless it
    can provide the constructor of the Rich Wrapper with an implicit dependency on
    the type class. This type class, `Monad`, defines the `map` and `flatMap` methods
    for the effect types for which it is implemented. So, in other words, only the
    effect types for which there is an implementation of the type class in scope can
    be converted into this Rich Wrapper. If a type does not have an implementation
    of the `Monad` type class, it will not be wrapped by the Monad's Rich Wrapper,
    and hence it will not have the `map` and `flatMap` methods injected into it, and
    a compile-time error will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: So, the compiler will see that it can inject the required methods implicitly,
    but only if it finds an implicit implementation of the necessary type class. Hence,
    it will try to find this implementation. If you are calling it with the Writer
    or IO types, it will be able to find the instances of the type class because they
    are defined inside the Monad companion object. The companion objects are searched
    for the implicit implementations of their companion classes.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have covered a few details specific to Scala—the *Rich Wrapper* pattern
    is more specific to Scala than anything else. However, the Type Class pattern
    repeats in many languages. Next, we will cover some reasoning for the type classes
    so that you know how to think about this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation of the Type Class pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the idea of a type class is highly abstract, it is necessary to develop
    an understanding of what it is and how it can be used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Injectable interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to think about the Type Class pattern is as of a way of injecting entire
    interfaces into existing classes.
  prefs: []
  type: TYPE_NORMAL
- en: In ordinary imperative languages, interfaces facilitate polymorphism. They allow
    you to treat classes that exhibit similar behavior uniformly. So for example,
    if you have classes for a car, a motorcycle, and a truck, you can define an interface
    vehicle, and treat all these classes as instances of that interface. No longer
    do you care about the peculiarities of the implementations of each class, all
    you care about is that all of its entities can drive. That is, they exhibit one
    behavior typical to all of them. An interface is a way to encapsulate a common
    behavior. When programming to interfaces, you are grounding your programs on the
    assumption that a set of entities of your program exhibits a behavior that is
    the same in its nature, although may differ in its details for each implementation.
  prefs: []
  type: TYPE_NORMAL
- en: However, in ordinary imperative languages, such as Java, you must declare the
    interfaces at definition-time. This means, that once the class is defined, you
    are not able to make it implement additional interfaces. This fact makes you struggle
    with polymorphism in certain situations. For example, if you have a bunch of third-party
    libraries and you want the classes of this library to implement specific interfaces
    defined in your program, you will not be able to do that.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a look at the example with the logging, we will see that the example
    is precisely about the polymorphism. We take a random `F` effect type and define
    the example based on the assumption that it has certain behaviors—`flatMap` and
    `map`. Although these behaviors may differ from effect type to effect type, their
    nature remains the same—the sequential composition of side-effecting computations.
    All we care about is that an effect type we are using supports these methods.
    As long as this condition is met, we don't care about other details of an effect
    type.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is of particular help in the functional programming world. Let's
    recall—how did the need for `map` and `flatMap` emerge in the first place? There
    is a theoretical foundation for them from a mathematical perspective. However,
    for engineering purposes, the need for the `map` and `flatMap` methods is quite
    pragmatic. Functional programmers need to frequently analyze the data structures
    of effect types in code in order to compose pure side-effecting computations sequentially,
    and this quickly becomes quite tedious. So, for us to avoid the boilerplate of
    analyzing the data structures every time, we have abstracted away the problem
    of sequential composition into the `map` and `flatMap` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The general pattern here is that we need to do various things with functional
    data structures. The `map` and `flatMap` functions define how to do sequential
    composition of computations. However, we may want to do much more than that. The
    general pattern is that we should be able to abstract away common repeating operations
    that we have, and we may not know beforehand all the operations we may want to
    support. This situation makes a case for separating data from behavior. In the
    modern functional programming libraries, effect types (data structures with information
    about the side effects of a computation) are separated from their behavior (what
    you can do with them). This means that the effect types contain only the data
    that represents the side effects. Whenever we need to do something with the effect
    types, we inject the required behavior into them using the Type Class pattern
    discussed previously. Many functional libraries are divided into two parts—the
    data part that describes the effect types, and the type class part that represents
    what you can do with the data, its behavior. The two parts are unified using the
    type class mechanism specific to the programming language the library is written
    for. For example, in Scala, the mechanism of implicit conversions powers the Type
    Class pattern and method-injection. The Scala compiler itself has no notion of
    the Type Class pattern, but you can express it effectively using the tools the
    language provides.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell has language-level support for type classes. In Haskell, there is a
    language-level separation between data and the type classes. You are not able
    to define any behavior on data. Haskell implements the philosophy of the separation
    of data and behavior at the language level. This cannot be said about Scala. In
    Scala, you can have ordinary OOP classes that can have both data (variables) and
    behavior (methods).
  prefs: []
  type: TYPE_NORMAL
- en: Toolboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful metaphor for the Type Class pattern is that there are toolboxes
    that allow you to do things to your data.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine yourself as a carpenter. A carpenter is a person who creates things
    from wood. How does one go about creating useful things from wood? They take raw
    wood and go to their workshop, where they have a bunch of tools to work with wood.
    They use hammers, saws, and so on to turn wood into tables, chairs, and other
    goods. If the carpenter is sophisticated, they will probably differentiate between
    different types of wood. For example, certain trees have robust wood, and other
    trees have soft wood. The same saw is more effective with one type of wood than
    with another. So, the carpenter has different types of saws for different types
    of wood. However, the fact that the carpenter needs a saw to cut the trees remains
    constant, no matter the type of wood.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the programming world, the effect types are wood. They are the raw material
    of the functional programming from which you compose your program. In the raw
    state, they are hard to process without tools—it is hard to analyze, compose,
    and process effect types by hand, precisely the same way it is hard to carve goods
    from wood without saws and hammers.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, there are tools to process effect types. Type classes are to
    effect types what saws are to wood. They are tools that allow you to process your
    raw material.
  prefs: []
  type: TYPE_NORMAL
- en: The same saw may not apply to different types of wood. In the same way, different
    effect types need different implementations of one type class. For example, the
    Writer and IO effect types need separate implementations of the `Monad` type class.
    The purpose of the type class, the sequential composition, remains the same; it
    is the way the sequential composition is done in each case that is different.
    This can be compared with the fact that the purpose of sawing remains the same
    for a wide variety of raw material, that is, to cut wood. However, the details
    of how it is done vary, hence separate saws for separate types of raw material.
  prefs: []
  type: TYPE_NORMAL
- en: This is why in the Type Class pattern, we first declare what behavior must be
    exhibited in a trait, and only then do we implement this behavior for each type
    individually.
  prefs: []
  type: TYPE_NORMAL
- en: Just as a carpenter has a toolbox to process raw wood, a functional programmer
    has a type class to process raw effect types. And just as a carpenter has an entire
    workshop full of tools, a functional programmer has libraries full of type classes
    for different purposes. We will cover these libraries in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes in different languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In principle, the idea of type classes is present even in Java. For example,
    Java has the `Comparator` interface, which defines how to compare two arbitrary
    types. It defines a relationship of order on a type. The type that is used with
    collections defines the order in which they are sorted.
  prefs: []
  type: TYPE_NORMAL
- en: However, a language such as Java lacks a mechanism for applying that class to
    types conveniently. So, for example, when you are sorting a collection, you need
    to explicitly provide an instance of the type class to the sorting method. This
    is unlike Scala, where it is possible to use implicit conversions and implicit
    lookup for the compiler to look up the implementation of the type class by itself,
    so as not to clutter the code.
  prefs: []
  type: TYPE_NORMAL
- en: In Scala, the compiler is much smarter than in Java, in part due to the presence
    of the implicit resolution mechanism. So, when we want to inject a specific set
    of methods into a class, we can do so with the help of the implicit conversions.
    If in Java we are required to provide all the type classes explicitly, in Scala
    we can leave most of this work to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, a similar mechanism is present to perform the implicit lookup of
    type classes. Also, Haskell follows the separation between data and behavior.
    So, in general, you are not able to declare methods on data, and you are not able
    to define classes that have both variables and methods. This is to enforce the
    purely functional style of programming. In Scala, which is a mix between purely
    functional and object-oriented programming, you can have classes that have both
    variables and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about the implicit resolution mechanism, we should note that it is a
    relatively advanced feature, and not every programming language has it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the idea of a type class, which is central to
    modern functional programming. We built up to this idea by introducing the Rich
    Wrapper pattern first, which facilitates type classes in Scala. A type class can
    be understood as a toolbox to process raw effect types. Another understanding
    of the Type Class pattern is that it is an injectable interface that you can inject
    into your classes to achieve polymorphism. Finally, we had a look at how type
    classes are used in languages other than Scala. In the next chapter, we will learn
    about the commonly used type classes and the libraries they are organized in.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the *Rich Wrapper* pattern for in Scala?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the Rich Wrapper implemented in Scala? What is the implicit conversions
    mechanism in Scala?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the Type Class pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the motivation behind the Type Class pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do imperative languages have type classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
