- en: The Idea of the Type Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类的概念
- en: In the previous chapter, we saw the views of functional programming on data
    representation. In functional programming, data is most often encountered in the
    form of what a function returns. This result is usually a data structure that
    includes both the results of the function and data about the side effects that
    have occurred in the function. Different side effects are represented with different
    data structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了函数式编程对数据表示的观点。在函数式编程中，数据最常见的形式是函数返回的结果。这个结果通常是一个包含函数结果和函数中发生的副作用数据的结构。不同的副作用用不同的数据结构表示。
- en: We also saw how analyzing and working with these data structures can become
    tedious, so functional programming gives rise to patterns such as map and `flatMap`.
    There are many more patterns for working with effect types. The `map` and `flatMap`
    are just utility methods that are used in a specific context. However, they are
    general enough to repeat from one data type to another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了分析和处理这些数据结构可能会变得繁琐，因此函数式编程产生了诸如map和`flatMap`之类的模式。还有许多更多的工作效果类型的模式。`map`和`flatMap`只是特定上下文中使用的实用方法。然而，它们足够通用，可以从一种数据类型重复到另一种数据类型。
- en: In this chapter, we will see how functional programming treats the behavior
    of data structures. We will see how things such as `map` and `flatMap` are organized
    into logical units, and show how these types represent the behavior of data structures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到函数式编程如何处理数据结构的行为。我们将看到诸如`map`和`flatMap`之类的操作如何组织成逻辑单元，并展示这些类型如何表示数据结构的行为。
- en: We will introduce a notion of type classes, and we will cover the reasoning
    behind it in order to better understand this pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍类型类的概念，并解释其背后的推理，以便更好地理解这个模式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Rich Wrapper pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富包装器模式
- en: The Type Class pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类模式
- en: Interpretation of the Type Class pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类模式的解释
- en: Type Classes in different languages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同语言中的类型类
- en: Rich Wrapper pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富包装器模式
- en: In this section, we will start our journey to understand the pattern of type
    classes. We'll start by covering the idea of the *Rich Wrapper* pattern. The pattern
    is specific to Scala, but it introduces the problem of separating data from behavior,
    which becomes important in the Type Class pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始了解类型类模式。我们将从介绍*丰富包装器*模式开始。这个模式是特定于Scala的，但它引入了将数据与行为分离的问题，这在类型类模式中变得很重要。
- en: Motivation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: Consider the following problem. Scala is a language built on top of JVM, so
    it has access to the Core Java library, and you can use the Java Core classes.
    You can also use any Java library in your Scala programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题。Scala是一种建立在JVM之上的语言，因此它可以访问Java核心库，你可以在Scala程序中使用Java核心类。你还可以在你的Scala程序中使用任何Java库。
- en: In this manner, Scala String and Array data types come from the Java Core. However,
    if you are familiar with Scala, you know that String and Array are more like Scala
    collections than Java strings and arrays. They are treated this way because Scala
    provides you with a set of extra methods, such as `map`, `flatMap`, and `filter`, on
    top of these types. So all the methods that ordinary Scala collections have are
    also available when working with strings and arrays. Strings are treated as collections
    of characters, and arrays as indexed sequences of elements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，Scala的String和Array数据类型来自Java核心。然而，如果你熟悉Scala，你知道String和Array更像是Scala集合，而不是Java字符串和数组。它们之所以这样处理，是因为Scala为你提供了一组额外的方法，例如`map`、`flatMap`和`filter`，这些方法在上述类型之上。因此，当与字符串和数组一起工作时，所有普通Scala集合的方法也都可用。字符串被视为字符集合，数组被视为元素的索引序列。
- en: How is it possible that in Scala we have collections methods on strings and
    arrays that come from Java? The answer is that Scala has a mechanism to simulate
    method injection into classes. We can have a class that comes from a third-party
    library in Scala and be able to inject additional methods into this class, without
    modifying its original implementation and not extending the original class via
    subtyping. This mechanism for method-injection is handy in the context of separating
    data from its behavior in the functional world.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，我们如何在字符串和数组上拥有来自Java的集合方法？答案是Scala有一个机制来模拟将方法注入到类中。我们可以在Scala中有一个来自第三方库的类，并且能够向这个类注入额外的方法，而无需修改其原始实现，也不通过子类型扩展原始类。这种方法注入机制在将数据与其行为分离的函数式世界中非常有用。
- en: This solution is called the **Rich Wrapper** pattern. To understand it, you
    need to understand the mechanism of implicit conversions that Scala has. This
    mechanism provides a way to make the compiler do extra work that ordinarily is
    done manually. The easiest way to understand the implicit conversions is with
    an example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案被称为**Rich Wrapper**模式。要理解它，你需要了解Scala中隐式转换的机制。这种机制提供了一种让编译器执行通常手动完成的工作的方法。理解隐式转换的最简单方式是通过一个例子。
- en: Implicit conversions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: Imagine that you have two different models of the same domain. Some methods
    expect the domain objects of one domain, but you want to call them with the domain
    objects of another domain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你拥有同一领域两个不同的模型。某些方法期望一个领域的领域对象，但你希望用另一个领域的领域对象来调用它们。
- en: 'Concretely, imagine a web API that responds to HTTP requests with JSON. You
    may want to have two versions of the object that represents your users. One version
    is a full version of this entity. It contains the password hash and all the other
    data. Here is the full version is the internal representation of the entity, meant
    to be used on the backend and not meant to be leaked to the end user:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，想象一个Web API，它通过JSON响应HTTP请求。你可能希望有两个版本的表示用户的对象。一个版本是这个实体的完整版本。它包含密码散列和所有其他数据。以下是完整版本，是实体的内部表示，用于后端，不打算泄露给最终用户：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another version of this object is supposed to be sent to the end user upon
    their HTTP requests to the web API. We don''t want to expose too much information,
    so we are going to return a shortened version of this object. This version does
    not expose any sensitive information:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的另一个版本应该在用户向Web API发起HTTP请求时发送给最终用户。我们不希望暴露太多信息，因此我们将返回这个对象的简短版本。这个版本不会暴露任何敏感信息：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Consider that you need to return an object from a server from a request handler.
    Since the backend represents users with the `FullUser` class, we''ll first need
    to convert it into `ShortUser` using a conversion method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你需要从请求处理器返回一个对象。由于后端使用`FullUser`类来表示用户，我们首先需要使用转换方法将其转换为`ShortUser`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider also that the following method must be executed in order to return
    an object from a request handler in response to the HTTP request:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑到以下方法必须执行，以便在响应HTTP请求时从请求处理器返回一个对象：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s assume we have a `root` user and we need to be able to return it upon
    request:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`root`用户，并且我们需要能够在请求时返回它：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From the preceding code snippet, we can imagine an HTTP request handler defined
    along the following lines:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以想象一个按照以下方式定义的HTTP请求处理器：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You don't want to explicitly perform the conversion from the backend representation
    each time you need to return this object. There may be many contexts in which
    you may want to do so. For example, you can associate the `User` entity with forum
    posts of that user or their comments when these are requested.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望在每次需要返回这个对象时都显式地执行从后端表示的转换。可能有许多上下文你希望这样做。例如，你可以在请求这些内容时将`User`实体与该用户的论坛帖子或评论关联起来。
- en: 'The concept of implicit conversions exists precisely for these situations.
    In Scala, you can define a method as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换的概念正是为了这些情况而存在的。在Scala中，你可以定义一个方法如下：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Whenever we use a `FullUser` instance in a place where `ShortUser` is expected,
    the conversion from the full object into the short object will be done automatically
    by the compiler using the `implicit` method in scope. This way, you can convert
    one value to another implicitly, without cluttering the code with irrelevant details.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在一个期望`ShortUser`实例的地方使用`FullUser`实例时，编译器会自动使用作用域内的`implicit`方法将完整对象转换为短对象。这样，你可以隐式地将一个值转换为另一个值，而无需在代码中添加无关的细节。
- en: 'With the implicit conversion in scope, we can write the code as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域内有隐式转换的情况下，我们可以编写如下代码：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is equivalent to the original code where the conversion is
    done explicitly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与原始代码等价，其中转换是显式完成的。
- en: Rich Wrapper
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rich Wrapper
- en: How are implicit conversions related to the example when we need to inject methods
    into classes? We can treat method-injection as a conversion problem. We can use
    the wrapper pattern to define a class that wraps the target class (that is, accepts
    it as a constructor argument) and defines the methods that we need. We can then
    implicitly convert the original class to the wrapper whenever are we are calling
    any of the methods that are not initially present in the wrapper.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换如何与我们需要将方法注入类时的示例相关？我们可以将方法注入视为一个转换问题。我们可以使用包装器模式定义一个类，该类包装目标类（即将其作为构造函数参数接受）并定义我们需要的那些方法。然后，每当我们在包装器中调用任何最初不存在的方法时，我们可以隐式地将原始类转换为包装器。
- en: 'Consider the following example. We are calling a `filter` method on a String:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。我们正在对一个字符串调用`filter`方法：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method is not a member of the `String` class, as the `String` class here
    is `java.lang.String`. However, Scala collections have this method. What happens
    next is that the compiler realizes that the object does not have this method,
    but it does not fail right away. Instead, the compiler starts to look for implicit
    conversions in scope that can convert this object into some other object that
    does have the required method. The mechanics here are the same as in the case
    when we are passing the user object to a method as an argument. The point is that
    the compiler expects one type but receives another type in its place.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不是`String`类的一个成员，因为这里的`String`类是`java.lang.String`。然而，Scala集合有这个方法。接下来发生的事情是编译器意识到该对象没有这个方法，但它不会立即失败。相反，编译器开始寻找作用域内的隐式转换，这些转换可以将该对象转换为具有所需方法的另一个对象。这里的机制与我们将用户对象作为参数传递给方法的案例相同。关键是编译器期望一种类型，但接收到的却是另一种类型。
- en: 'In our case, the compiler expects the type with the `filter` method defined
    on it but receives a `String` type that does not have this method. Hence, it will
    try to convert it to the type that matches its expectations, that is, the existence
    of the `filter` method in the class. It turns out that we do have such a method
    in scope:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，编译器期望具有定义了`filter`方法的类型，但接收到的`String`类型没有这个方法。因此，它会尝试将其转换为符合其期望的类型，即类中存在`filter`方法。结果是我们确实在作用域中有一个这样的方法：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is an implicit conversion defined in the `Predef` object in Scala that
    converts strings into a Rich Wrapper with all the collections methods, including `filter`.
    The same technique is used to inject the Scala collection methods into Java's
    arrays.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala的`Predef`对象中定义了一个隐式转换，该转换将字符串转换为具有所有集合方法（包括`filter`）的Rich Wrapper。同样的技术也用于将Scala集合方法注入Java数组中。
- en: This technique is not specific to Scala, although the underlying mechanism is.
    In one form or another, it is present in many languages. For example, in C#, you
    have the concept of implicit conversions and can convert one type to another implicitly.
    In Haskell, we have a more powerful, functional version of the same technique.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术并不特定于Scala，尽管其底层机制是。以某种形式或另一种形式，它存在于许多语言中。例如，在C#中，你有隐式转换的概念，可以隐式地将一种类型转换为另一种类型。在Haskell中，我们有这种技术的更强大、功能性的版本。
- en: The Type Class pattern
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类模式
- en: Sometimes, the effect type that we are going to use is not known in advance.
    Consider the problem of logging. Logging can be performed to a list or a file.
    Logging to a list can be implemented using the Writer effect type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们打算使用的效果类型事先并不知道。考虑日志记录的问题。日志记录可以记录到列表或文件中。使用Writer效果类型可以实现将日志记录到列表中。
- en: 'A Writer is an abstraction of a pair of a result and a log generated by a computation.
    In its simplest form, a Writer can be understood as a pair of a list of strings
    and an arbitrary result. We can define the Writer effect type as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Writer是一个计算生成的结果和日志对的抽象。在其最简单形式中，Writer可以理解为字符串列表和任意结果的配对。我们可以如下定义Writer效果类型：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we have also defined the familiar `map` and `flatMap` methods for
    this effect type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也为这种效果类型定义了熟悉的`map`和`flatMap`方法。
- en: A few words should be said about how we have implemented the `flatMap` method.
    We are using a simplified version of the Writer type, in fact. In its simplified
    form, it is a data structure that contains a result and a list of strings—the
    log entries—in one data structure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有几句话要说关于我们如何实现`flatMap`方法。实际上，我们使用的是Writer类型的简化版本。在其简化形式中，它是一个包含结果和字符串列表（即日志条目）的数据结构。
- en: The `flatMap` method answers the question of how to combine sequential computations
    whose effect is `SimpleWriter`. So, given two such computations, one being a continuation
    of another (that is, the result of the previous computation parameterizes it),
    the question is—how do we produce the result of that continuation so that the
    log of the previous computation is preserved in that result?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`方法回答了如何组合具有`SimpleWriter`效果的顺序计算的问题。所以，给定两个这样的计算，一个作为另一个的延续（即前一个计算的结果参数化了它），问题是——我们如何产生该延续的结果，同时保留前一个计算的日志？'
- en: In the preceding code snippet, you can see how the implementation of the `flatMap`
    method is done for the `SimpleWriter` data structure. So, first, we run the continuation
    with the result of the current data structure as an input. This run produces another
    result under the side effect of `SimpleWriter`, that is, a result with a log of
    the computation. After that, we produce a combined Writer with the result of the
    second computation and the combined logs of the first and second computations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到`flatMap`方法是如何为`SimpleWriter`数据结构实现的。所以，首先，我们使用当前数据结构的结果作为输入来运行延续。这次运行在`SimpleWriter`的副作用下产生另一个结果，即带有计算日志的结果。之后，我们产生一个结合了第二个计算的结果和第一、第二个计算的合并日志的Writer。
- en: 'We can also define a companion object for this data type that contains convenience
    methods to lift any value to the effect type and to create an empty structure
    with a single log message:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为这种数据类型定义一个伴随对象，其中包含将任何值提升到效果类型和创建一个包含单个日志消息的空结构的方法：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the Writer effect type, we can use logging from an operation as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Writer效果类型，我们可以从操作中记录日志如下：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Logging to a file can be implemented with the help of another effect, `IO`.
    The `IO` type stands for an input-output effect, which means that the computation
    exchanges information with some external resources. We can define a dummy version
    of IO that just suspends a computation, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个效果`IO`可以实现对文件的日志记录。`IO`类型代表输入输出效果，这意味着计算与某些外部资源交换信息。我们可以定义一个模拟的IO版本，它只是暂停计算，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding definition follows the same pattern as the `SimpleWriter` type.
    The `log` method does not actually write to any file, but simulates this operation
    by outputting to the terminal. With the help of this effect type, we can use logging
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义遵循与`SimpleWriter`类型相同的模式。`log`方法实际上并不写入任何文件，而是通过输出到终端来模拟此操作。借助这种效果类型，我们可以如下使用日志记录：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What if we do not know beforehand where we are going to log? What if sometimes
    we need to log to a file and sometimes we need to log to a list? The preceding
    can be the case if we are working in different environments, for example, stage,
    test, or production. The question is: how exactly should we proceed with generalizing
    the preceding code so that it is effect-independent? The problem here is that
    the preceding two snippets differ only in the effect type they are using to log.
    In programming, whenever we see a pattern, it is a good idea to extract it.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们事先不知道我们将要记录在哪里？如果我们有时需要将日志记录到文件，有时需要记录到列表中呢？如果我们处于不同的环境中，例如预发布、测试或生产环境，上述情况可能发生。问题是：我们如何具体进行代码的泛化，使其与效果无关？这里的问题是，前面两个代码片段仅在它们使用的日志记录效果类型上有所不同。在编程中，每当看到一种模式时，提取它是好主意。
- en: 'One way to abstract away the effect type is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象掉效果类型的一种方法如下：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, the effect type becomes an `F` type parameter. The function becomes parameterized
    on the type level. However, when we try to implement the body of the method, we
    will quickly run into difficulties. The preceding code does not compile because
    the compiler knows nothing about the `F` type parameter. We are calling the `map`
    and `flatMap` methods on this type, and the compiler has no way of knowing which
    methods are implemented on this type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，效果类型变成了一个`F`类型参数。函数在类型级别上变得参数化了。然而，当我们尝试实现方法的主体时，我们会迅速遇到困难。前面的代码无法编译，因为编译器对`F`类型参数一无所知。我们在这种类型上调用`map`和`flatMap`方法，编译器无法知道这个类型上实现了哪些方法。
- en: 'The solution to this problem comes in the form of the Type Class pattern. Under
    the Type Class pattern, the method looks as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案以类型类模式的形式出现。在类型类模式之下，方法看起来如下所示：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The reason we can use the `map` and `flatMap` methods here is that we now have
    an implicit dependency in the method's arguments list. The dependency in question
    is on the type class called `Monad`. `Monad` is one of the most common type classes
    in functional programming. One more dependency is Logging, which provides the
    `log` method, which is also a common method available for both effect types we
    are interested in.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里使用`map`和`flatMap`方法的原因是，我们现在在方法参数列表中有一个隐式依赖。这个依赖是类型类`Monad`的依赖。`Monad`是函数式编程中最常见的类型类之一。还有一个依赖项是Logging，它提供了`log`方法，这也是我们感兴趣的效果类型都可用的一种常见方法。
- en: Let's look at what type classes are and how they work on the example of `Monad`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类型类是什么，以及它们如何在`Monad`的例子上工作。
- en: In the body of the function, we can use the `map` and `flatMap` functions, and
    the compiler can resolve them. Previously, we saw the same method-injection trick
    done with the help of implicit dependencies. In that case, we had an implicit
    conversion that converts the target type to a Rich Wrapper. In this case, a similar
    pattern is used. However, it is more complex. The complexity is because Rich Wrapper
    wrapped concrete classes, but we are now targeting abstract type variables, in
    our example, it is `F`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的主体中，我们可以使用`map`和`flatMap`函数，编译器可以解析它们。之前，我们看到了使用隐式依赖完成的相同方法注入技巧。在那个案例中，我们有一个将目标类型转换为Rich
    Wrapper的隐式转换。在这种情况下，使用了类似的模式。然而，它更复杂。复杂性在于Rich Wrapper封装了具体类，但我们现在针对的是抽象类型变量，在我们的例子中是`F`。
- en: 'Just as in the case of Rich Wrappers, the `map` and `flatMap` methods are injected
    into the preceding code using implicit conversions. Let''s have a look at the
    methods and classes that enable this conversion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Rich Wrappers的情况一样，`map`和`flatMap`方法通过隐式转换注入到前面的代码中。让我们看看使这种转换成为可能的方法和类：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code snippet, you can see the entire code that enables the
    required conversion. This code implements the Type Class pattern. Let''s have
    a look at it step by step:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到使所需的转换成为可能的整个代码。这段代码实现了类型类模式。让我们一步一步地看看它：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code snippet, you can see the definition of the trait that
    contains all the methods that a particular set of effect types must implement.
    The concrete implementations of the trait will have the trait's type parameter
    set to the type for which the class is implemented. The trait consists of the
    declaration of all the methods that the type in question is supposed to support.
    Notice that all of the methods expect the object on which they are supposed to
    be called. This means this trait is not supposed to be implemented by the target
    object. Instead, the instances of this trait are supposed to be a sort of toolbox
    that defines certain behaviors for the type in question, without making that type
    extend the trait.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到包含所有特定效果类型必须实现的方法的特质的定义。特质的具体实现将特质的类型参数设置为类实现的具体类型。特质由所有应该支持该类型的方法的声明组成。请注意，所有方法都期望调用它们的对象。这意味着这个特质不应该由目标对象实现。相反，这个特质的实例应该是一种工具箱，为特定类型定义某些行为，而不使该类型扩展特质。
- en: 'Next, we have a companion object of this trait. This companion object defines
    specific methods that are also part of the pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有这个特质的伴随对象。这个伴随对象定义了模式中也是一部分的特定方法：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First of all, there is a Rich Wrapper, as you can see in the preceding code.
    The pattern works the same way as we have seen previously, in the case of wrappers
    for strings and arrays. However, there is one little difference. It is defined
    on an `F[A]` abstract type. In principle, it can be any effect type. It may seem
    at first that we are defining a set of methods for every type possible. However,
    there are constraints on the types for which the methods are implemented. The
    constraints are enforced by the implicit argument that follows a constructor of
    the Rich Wrapper:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个富包装器，正如你在前面的代码中看到的那样。这个模式的工作方式与我们之前看到的字符串和数组包装器的方式相同。然而，有一个小小的不同之处。它是在一个`F[A]`抽象类型上定义的。原则上，它可以是对任何效果类型。一开始可能会觉得我们正在为每个可能的类型定义一组方法。然而，对于实现这些方法的类型有一些约束。这些约束是通过富包装器构造函数后面的隐含参数来强制执行的：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, to construct the wrapper, we need to satisfy an implicit dependency on the
    type class defined in the preceding code snippet. This means that for the `F` type
    to be able to use the Rich Wrapper pattern, we need to have an instance of the
    trait defined in the preceding code in scope implicitly for this `F` type. When
    we say *an instance of the type class for the F type*, we mean a concrete object
    that extends the type class trait where the type parameter is set to `F`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了构建包装器，我们需要满足对前面代码片段中定义的类型类的隐含依赖。这意味着为了`F`类型能够使用富包装器模式，我们需要在作用域中隐含地有一个前面代码中定义的特质的实例。当我们说“F类型的类型类的一个实例”时，我们指的是一个具体对象，它扩展了类型类特质，其中类型参数被设置为`F`。
- en: For example, a `Monad for Writer` instance is an object whose type conforms
    to `Monad[Writer]`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Monad for Writer`实例是一个类型符合`Monad[Writer]`的对象。
- en: All the Rich Wrapper's methods mimic that of the type class and are delegated
    to it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有富包装器的方法都模仿类型类，并将其委托给它。
- en: 'After that, we have some default implementations of the type class for certain
    common classes. For example, we can define ones for our Writer and IO types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们对某些常见的类提供了一些类型类的默认实现。例如，我们可以为我们的Writer和IO类型定义一些：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that in the preceding examples, we implement the `map` and `flatMap` methods
    by delegating them to the implementations owned by the `SimpleWrapper` and IO
    classes. This is because we have already implemented these classes with the methods
    in question. In the real world, it is often the case that the classes will not
    have the required methods. So you will write the entire implementation of them
    instead of delegating them to the methods owned by the classes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面示例中，我们通过将它们委托给`SimpleWrapper`和IO类拥有的实现来实现`map`和`flatMap`方法。这是因为我们已经在这些类中实现了这些方法。在现实世界中，通常类将不会有所需的方法。所以你将编写它们的整个实现，而不是将它们委托给类拥有的方法。
- en: 'Similar to the `Monad`, the `Logging` type class encapsulates the `log` method
    common to the two effect types:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Monad`类似，`Logging`类型类封装了两个效果类型共有的`log`方法：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It follows the same pattern as the `Monad` type class. First, the trait declares
    the methods the type class will have. Next, we have the companion object with
    some default implementations for our effect types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循与`Monad`类型类相同的模式。首先，特质声明了类型类将拥有的方法。接下来，我们有伴随对象，为我们的效果类型提供了一些默认实现。
- en: Let's see how the preceding code enables the logging example to use the `flatMap`
    and `map` methods, and how the mechanics of implicit resolution work here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的代码是如何使日志示例能够使用`flatMap`和`map`方法的，以及这里隐含解析的机制是如何工作的。
- en: First of all, the compiler sees that we are trying to call the `flatMap` method
    on an `F` type. The compiler doesn't know anything about the `F` type—it is not
    aware of whether it has the method in question. In an ordinary programming language,
    a compile-time error would have occurred at this point. However, in Scala, implicit
    conversions kick in. The compiler will try to convert this `F` type to something
    that has the required `flatMap` method. It will start the implicit lookup to find
    the implicit conversion that would convert an arbitrary `F` type into something
    that has the required method. It will find such a conversion. The conversion will
    be the Rich Wrapper of the `Monad` type class, as discussed previously. The compiler
    will see that it can convert any `F[A]` effect type into a wrapper that has the
    required methods. However, it will see that it is not able to do so unless it
    can provide the constructor of the Rich Wrapper with an implicit dependency on
    the type class. This type class, `Monad`, defines the `map` and `flatMap` methods
    for the effect types for which it is implemented. So, in other words, only the
    effect types for which there is an implementation of the type class in scope can
    be converted into this Rich Wrapper. If a type does not have an implementation
    of the `Monad` type class, it will not be wrapped by the Monad's Rich Wrapper,
    and hence it will not have the `map` and `flatMap` methods injected into it, and
    a compile-time error will be generated.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器看到我们正在尝试在`F`类型上调用`flatMap`方法。编译器对`F`类型一无所知——它不知道它是否有这个方法。在普通的编程语言中，在这个点上就会发生编译时错误。然而，在Scala中，隐式转换开始发挥作用。编译器会尝试将这个`F`类型转换为具有所需`flatMap`方法的东西。它将开始隐式查找，以找到将任意`F`类型转换为具有所需方法的隐式转换。它会找到这样的转换。这种转换将是之前讨论过的`Monad`类型类的Rich
    Wrapper。编译器会看到它可以转换任何`F[A]`效果类型到一个具有所需方法的包装器。然而，它会看到除非它能向Rich Wrapper的构造函数提供一个对类型类的隐式依赖，否则它无法做到这一点。这个类型类`Monad`为它所实现的效应类型定义了`map`和`flatMap`方法。换句话说，只有当作用域内有类型类的实现时，效应类型才能转换为这种Rich
    Wrapper。如果一个类型没有`Monad`类型类的实现，它将不会被Monad的Rich Wrapper包装，因此它将不会注入`map`和`flatMap`方法，并且将生成编译时错误。
- en: So, the compiler will see that it can inject the required methods implicitly,
    but only if it finds an implicit implementation of the necessary type class. Hence,
    it will try to find this implementation. If you are calling it with the Writer
    or IO types, it will be able to find the instances of the type class because they
    are defined inside the Monad companion object. The companion objects are searched
    for the implicit implementations of their companion classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器会看到它可以隐式地注入所需的方法，但前提是它找到了必要的类型类的隐式实现。因此，它会尝试找到这种实现。如果你使用Writer或IO类型调用它，它将能够找到类型类的实例，因为它们是在Monad伴随对象内部定义的。伴随对象会搜索其伴随类的隐式实现。
- en: Here, we have covered a few details specific to Scala—the *Rich Wrapper* pattern
    is more specific to Scala than anything else. However, the Type Class pattern
    repeats in many languages. Next, we will cover some reasoning for the type classes
    so that you know how to think about this pattern.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论了一些特定于Scala的细节——“**Rich Wrapper**”模式比其他任何模式都更特定于Scala。然而，**Type Class**模式在许多语言中都有重复出现。接下来，我们将讨论一些关于类型类的原因，以便你知道如何思考这种模式。
- en: Interpretation of the Type Class pattern
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Type Class**模式的解释'
- en: Since the idea of a type class is highly abstract, it is necessary to develop
    an understanding of what it is and how it can be used in practice.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型类的概念非常抽象，有必要了解它是什么以及如何在实践中使用它。
- en: Injectable interfaces
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可注入接口
- en: One way to think about the Type Class pattern is as of a way of injecting entire
    interfaces into existing classes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑**Type Class**模式的一种方式是将其视为将整个接口注入现有类的方法。
- en: In ordinary imperative languages, interfaces facilitate polymorphism. They allow
    you to treat classes that exhibit similar behavior uniformly. So for example,
    if you have classes for a car, a motorcycle, and a truck, you can define an interface
    vehicle, and treat all these classes as instances of that interface. No longer
    do you care about the peculiarities of the implementations of each class, all
    you care about is that all of its entities can drive. That is, they exhibit one
    behavior typical to all of them. An interface is a way to encapsulate a common
    behavior. When programming to interfaces, you are grounding your programs on the
    assumption that a set of entities of your program exhibits a behavior that is
    the same in its nature, although may differ in its details for each implementation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通的命令式语言中，接口促进了多态。它们允许你统一地对待表现出相似行为的类。例如，如果你有汽车、摩托车和卡车的类，你可以定义一个`vehicle`接口，并将所有这些类视为该接口的实例。你不再关心每个类的实现细节，你只关心所有实体都能驾驶。也就是说，它们表现出所有类都典型的一种行为。接口是一种封装共同行为的方式。当面向接口编程时，你是在基于这样的假设来编写程序：程序中的一组实体表现出在本质上相同的行为，尽管在每种实现中可能有所不同。
- en: However, in ordinary imperative languages, such as Java, you must declare the
    interfaces at definition-time. This means, that once the class is defined, you
    are not able to make it implement additional interfaces. This fact makes you struggle
    with polymorphism in certain situations. For example, if you have a bunch of third-party
    libraries and you want the classes of this library to implement specific interfaces
    defined in your program, you will not be able to do that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在普通的命令式语言中，例如Java，你必须在定义时声明接口。这意味着一旦类被定义，你就无法让它实现额外的接口。这个事实使你在某些情况下与多态作斗争。例如，如果你有一堆第三方库，并且希望这个库的类实现你程序中定义的特定接口，你就无法做到这一点。
- en: If you have a look at the example with the logging, we will see that the example
    is precisely about the polymorphism. We take a random `F` effect type and define
    the example based on the assumption that it has certain behaviors—`flatMap` and
    `map`. Although these behaviors may differ from effect type to effect type, their
    nature remains the same—the sequential composition of side-effecting computations.
    All we care about is that an effect type we are using supports these methods.
    As long as this condition is met, we don't care about other details of an effect
    type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看带有日志的示例，我们会看到这个示例正是关于多态的。我们随机选择一个`F`效果类型，并基于它具有某些行为——`flatMap`和`map`——的假设来定义示例。尽管这些行为可能因效果类型而异，但它们的本质是相同的——副作用计算的顺序组合。我们唯一关心的是我们使用的效果类型支持这些方法。只要这个条件得到满足，我们就不会关心效果类型的其他细节。
- en: This technique is of particular help in the functional programming world. Let's
    recall—how did the need for `map` and `flatMap` emerge in the first place? There
    is a theoretical foundation for them from a mathematical perspective. However,
    for engineering purposes, the need for the `map` and `flatMap` methods is quite
    pragmatic. Functional programmers need to frequently analyze the data structures
    of effect types in code in order to compose pure side-effecting computations sequentially,
    and this quickly becomes quite tedious. So, for us to avoid the boilerplate of
    analyzing the data structures every time, we have abstracted away the problem
    of sequential composition into the `map` and `flatMap` methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在函数式编程领域特别有帮助。让我们回顾一下——`map`和`flatMap`的需求最初是如何产生的？从数学的角度来看，它们有一个理论基础。然而，从工程的角度来看，`map`和`flatMap`方法的需求非常实用。函数式程序员需要频繁地分析代码中效果类型的代码结构，以便按顺序组合纯副作用计算，这很快就会变得相当繁琐。因此，为了避免每次分析数据结构时的模板代码，我们将顺序组合的问题抽象成了`map`和`flatMap`方法。
- en: The general pattern here is that we need to do various things with functional
    data structures. The `map` and `flatMap` functions define how to do sequential
    composition of computations. However, we may want to do much more than that. The
    general pattern is that we should be able to abstract away common repeating operations
    that we have, and we may not know beforehand all the operations we may want to
    support. This situation makes a case for separating data from behavior. In the
    modern functional programming libraries, effect types (data structures with information
    about the side effects of a computation) are separated from their behavior (what
    you can do with them). This means that the effect types contain only the data
    that represents the side effects. Whenever we need to do something with the effect
    types, we inject the required behavior into them using the Type Class pattern
    discussed previously. Many functional libraries are divided into two parts—the
    data part that describes the effect types, and the type class part that represents
    what you can do with the data, its behavior. The two parts are unified using the
    type class mechanism specific to the programming language the library is written
    for. For example, in Scala, the mechanism of implicit conversions powers the Type
    Class pattern and method-injection. The Scala compiler itself has no notion of
    the Type Class pattern, but you can express it effectively using the tools the
    language provides.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的普遍模式是我们需要用功能数据结构来做各种事情。`map`和`flatMap`函数定义了如何进行计算的顺序组合。然而，我们可能想要做更多的事情。普遍的模式是，我们应该能够抽象出我们已有的常见重复操作，而我们可能事先并不知道所有我们可能想要支持的运算。这种情况使得将数据与行为分离成为必要。在现代函数式编程库中，效果类型（包含计算副作用信息的数据结构）与其行为（你可以用它们做什么）是分开的。这意味着效果类型只包含表示副作用的那些数据。每当我们需要对效果类型做些什么时，我们就可以使用之前讨论过的类型类模式将所需的行为注入其中。许多函数式库分为两部分——描述效果类型的部分，以及代表你可以对数据做什么的、其行为的类型类部分。这两部分通过特定于库所写编程语言的类型类机制统一在一起。例如，在Scala中，隐式转换机制为类型类模式和注入方法提供动力。Scala编译器本身没有类型类模式的概念，但你可以使用语言提供的工具有效地表达它。
- en: Haskell has language-level support for type classes. In Haskell, there is a
    language-level separation between data and the type classes. You are not able
    to define any behavior on data. Haskell implements the philosophy of the separation
    of data and behavior at the language level. This cannot be said about Scala. In
    Scala, you can have ordinary OOP classes that can have both data (variables) and
    behavior (methods).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell对类型类有语言级别的支持。在Haskell中，数据和类型类在语言级别上是分开的。你无法在数据上定义任何行为。Haskell在语言级别上实现了数据与行为分离的哲学。这一点在Scala中并不适用。在Scala中，你可以有普通的面向对象类，这些类可以既有数据（变量）也有行为（方法）。
- en: Toolboxes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具箱
- en: Another useful metaphor for the Type Class pattern is that there are toolboxes
    that allow you to do things to your data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类模式的另一个有用的隐喻是，存在一些工具箱，允许你对数据进行操作。
- en: Imagine yourself as a carpenter. A carpenter is a person who creates things
    from wood. How does one go about creating useful things from wood? They take raw
    wood and go to their workshop, where they have a bunch of tools to work with wood.
    They use hammers, saws, and so on to turn wood into tables, chairs, and other
    goods. If the carpenter is sophisticated, they will probably differentiate between
    different types of wood. For example, certain trees have robust wood, and other
    trees have soft wood. The same saw is more effective with one type of wood than
    with another. So, the carpenter has different types of saws for different types
    of wood. However, the fact that the carpenter needs a saw to cut the trees remains
    constant, no matter the type of wood.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你自己是一名木匠。木匠是这样一种人，他们用木头创造出各种东西。一个人如何从木头中创造出有用的东西呢？他们取来原木，然后去他们的工坊，那里有一堆可以用来加工木头的工具。他们使用锤子、锯子等等，将木头变成桌子、椅子和其他商品。如果木匠技艺高超，他们可能会区分不同种类的木材。例如，某些树木的木材坚固，而其他树木的木材柔软。同样的锯子对一种木材的加工效果比对另一种木材的效果更好。因此，木匠会为不同种类的木材准备不同类型的锯子。然而，无论木材的种类如何，木匠需要锯子来砍伐树木这一事实是恒定的。
- en: Back in the programming world, the effect types are wood. They are the raw material
    of the functional programming from which you compose your program. In the raw
    state, they are hard to process without tools—it is hard to analyze, compose,
    and process effect types by hand, precisely the same way it is hard to carve goods
    from wood without saws and hammers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，效果类型就像是木材。它们是函数式编程的原材料，你从中组合出你的程序。在原始状态下，没有工具很难处理——手动分析、组合和处理效果类型就像没有锯子和锤子很难从木材中雕刻出成品一样。
- en: For this reason, there are tools to process effect types. Type classes are to
    effect types what saws are to wood. They are tools that allow you to process your
    raw material.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存在处理效果类型的工具。类型类对于效果类型来说，就像锯子对于木材一样。它们是允许你处理原材料的工具。
- en: The same saw may not apply to different types of wood. In the same way, different
    effect types need different implementations of one type class. For example, the
    Writer and IO effect types need separate implementations of the `Monad` type class.
    The purpose of the type class, the sequential composition, remains the same; it
    is the way the sequential composition is done in each case that is different.
    This can be compared with the fact that the purpose of sawing remains the same
    for a wide variety of raw material, that is, to cut wood. However, the details
    of how it is done vary, hence separate saws for separate types of raw material.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同一把锯子可能不适用于不同类型的木材。同样地，不同的效果类型需要不同类型类的实现。例如，Writer和IO效果类型需要分别实现`Monad`类型类。类型类的目的，即顺序组合，保持不变；不同情况下顺序组合的方式不同。这可以与锯切各种原材料的目的保持一致，即切割木材。然而，具体操作细节各不相同，因此需要为不同类型的原材料准备不同的锯子。
- en: This is why in the Type Class pattern, we first declare what behavior must be
    exhibited in a trait, and only then do we implement this behavior for each type
    individually.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在类型类模式中，我们首先声明在特质中必须展示的行为，然后才为每个类型单独实现这种行为。
- en: Just as a carpenter has a toolbox to process raw wood, a functional programmer
    has a type class to process raw effect types. And just as a carpenter has an entire
    workshop full of tools, a functional programmer has libraries full of type classes
    for different purposes. We will cover these libraries in the next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如木匠有一个工具箱来处理原材料木材一样，函数式程序员有一个类型类来处理原材料效果类型。而且正如木匠有一个充满工具的整个车间一样，函数式程序员有充满不同目的类型类的库。我们将在下一章中介绍这些库。
- en: Type classes in different languages
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同语言中的类型类
- en: In principle, the idea of type classes is present even in Java. For example,
    Java has the `Comparator` interface, which defines how to compare two arbitrary
    types. It defines a relationship of order on a type. The type that is used with
    collections defines the order in which they are sorted.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，类型类的想法即使在Java中也是存在的。例如，Java有`Comparator`接口，它定义了如何比较两种任意类型。它定义了一个类型上的顺序关系。与集合一起使用的类型定义了它们排序的顺序。
- en: However, a language such as Java lacks a mechanism for applying that class to
    types conveniently. So, for example, when you are sorting a collection, you need
    to explicitly provide an instance of the type class to the sorting method. This
    is unlike Scala, where it is possible to use implicit conversions and implicit
    lookup for the compiler to look up the implementation of the type class by itself,
    so as not to clutter the code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像Java这样的语言缺乏将此类方便地应用于类型的机制。所以，例如，当你对一个集合进行排序时，你需要显式地提供一个类型类的实例给排序方法。这与Scala不同，在Scala中，可以使用隐式转换和隐式查找，让编译器自己查找类型类的实现，从而不使代码杂乱。
- en: In Scala, the compiler is much smarter than in Java, in part due to the presence
    of the implicit resolution mechanism. So, when we want to inject a specific set
    of methods into a class, we can do so with the help of the implicit conversions.
    If in Java we are required to provide all the type classes explicitly, in Scala
    we can leave most of this work to the compiler.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，编译器比Java中的编译器要聪明得多，部分原因是因为存在隐式解析机制。因此，当我们想要将一组特定方法注入一个类时，我们可以借助隐式转换来实现。如果在Java中我们需要显式提供所有类型类，那么在Scala中我们可以将大部分这项工作留给编译器。
- en: In Haskell, a similar mechanism is present to perform the implicit lookup of
    type classes. Also, Haskell follows the separation between data and behavior.
    So, in general, you are not able to declare methods on data, and you are not able
    to define classes that have both variables and methods. This is to enforce the
    purely functional style of programming. In Scala, which is a mix between purely
    functional and object-oriented programming, you can have classes that have both
    variables and methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，存在类似的机制来执行类型类的隐式查找。此外，Haskell 遵循数据和行为的分离。因此，通常情况下，你无法在数据上声明方法，也无法定义同时包含变量和方法的大类。这是为了强制执行纯函数式编程风格。在
    Scala 中，它是一种纯函数式编程和面向对象编程的混合，你可以拥有同时包含变量和方法的大类。
- en: Talking about the implicit resolution mechanism, we should note that it is a
    relatively advanced feature, and not every programming language has it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到隐式解析机制，我们应该注意到这是一个相对高级的功能，并不是每种编程语言都有。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the idea of a type class, which is central to
    modern functional programming. We built up to this idea by introducing the Rich
    Wrapper pattern first, which facilitates type classes in Scala. A type class can
    be understood as a toolbox to process raw effect types. Another understanding
    of the Type Class pattern is that it is an injectable interface that you can inject
    into your classes to achieve polymorphism. Finally, we had a look at how type
    classes are used in languages other than Scala. In the next chapter, we will learn
    about the commonly used type classes and the libraries they are organized in.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了类型类的概念，这是现代函数式编程的核心。我们通过首先介绍 Rich Wrapper 模式来构建这个概念，该模式有助于 Scala 中的类型类。类型类可以被理解为处理原始效果类型的工具箱。对类型类模式的另一种理解是，它是一个可注入的接口，你可以将其注入到你的类中以实现多态。最后，我们探讨了类型类在其他语言中的应用。在下一章中，我们将学习常用类型类及其组织在的库。
- en: Questions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the *Rich Wrapper* pattern for in Scala?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scala 中的 *Rich Wrapper* 模式是什么？
- en: How is the Rich Wrapper implemented in Scala? What is the implicit conversions
    mechanism in Scala?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scala 中 Rich Wrapper 的实现方式是什么？Scala 中的隐式转换机制是什么？
- en: Explain the Type Class pattern.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释类型类模式。
- en: What is the motivation behind the Type Class pattern?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型类模式的动机是什么？
- en: Do imperative languages have type classes?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制性语言有类型类吗？
