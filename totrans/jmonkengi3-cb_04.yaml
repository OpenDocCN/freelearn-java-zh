- en: Chapter 4. Mastering Character Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 精通角色动画
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Previewing animations in SDK
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SDK中预览动画
- en: Creating an animation manager control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画管理器控制
- en: Extending the animation control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展动画控制
- en: Handling jump animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理跳跃动画
- en: Creating a custom animation – leaning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义动画 – 倾斜
- en: Creating a subanimation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建子动画
- en: Lip syncing and facial expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唇同步和面部表情
- en: Eye movement
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 眼睛运动
- en: Location-dependent animation – edge check
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置相关动画 – 边缘检查
- en: Inverse kinematics – aligning feet with ground
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向运动学 – 将脚与地面对齐
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll take a closer look at skeleton-based animations. These
    are central features in many games, and having a good framework can save a lot
    of time (and money) in a project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地研究基于骨骼的动画。这些是许多游戏中的核心功能，拥有一个好的框架可以在项目中节省大量时间（和金钱）。
- en: For those who are completely new to the subject of animations, it's recommended
    that you have a look at the jMonkeyEngine tutorials and Hello Animation in particular
    at [http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation](http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对动画主题完全陌生的人来说，建议查看jMonkeyEngine教程，特别是[http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation](http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation)中的Hello
    Animation。
- en: Previewing animations in SDK
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SDK中预览动画
- en: Before digging into the code, let's just briefly see how we can use SDK to see
    the animations that are supplied with a model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究代码之前，让我们简要地看看我们如何使用SDK查看模型提供的动画。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to see the animations that are supplied with the
    model:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以查看模型提供的动画：
- en: Find the model in the **Projects** window. Right-click on it and select **Edit**
    in **SceneComposer** and you will get the following screenshot:![How to do it...](img/6478OS_04_06.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中找到模型。右键单击它，在**场景作曲家**中选择**编辑**，你将看到以下截图：![如何做到这一点...](img/6478OS_04_06.jpg)
- en: Find the **SceneExplorer** window and open the model's node. Look for **AnimControl**
    as seen in the preceding screenshot.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到**场景探索器**窗口并打开模型的节点。寻找如图所示的**AnimControl**。
- en: Open the **AnimControl** window and you will see the list of animations that
    are available. Then, navigate to the **Properties** window to select any of the
    animations and play them in the model, as shown in the following screenshot:![How
    to do it...](img/6478OS_04_07.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**AnimControl**窗口，你会看到可用的动画列表。然后，导航到**属性**窗口以选择任何动画并在模型中播放，如图所示：![如何做到这一点...](img/6478OS_04_07.jpg)
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The **SceneExplorer** window not only shows all the spatials that belong to
    a node, but also the controls that are attached to any spatial. Apart from adding
    new controls, it's also possible to change them. In the case of `AnimControl`,
    it's possible to set the current animation so it is played instantly. To stop
    playing it, we can select `null`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景探索器**窗口不仅显示属于节点的所有空间，还显示附加到任何空间上的控件。除了添加新控件外，还可以更改它们。在`AnimControl`的情况下，可以设置当前动画以便立即播放。要停止播放，我们可以选择`null`。'
- en: Creating an animation manager control
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画管理器控制
- en: We will create a control that will handle the animations of a character. It
    will follow jMonkeyEngine's control pattern and extend `AbstractControl`. We won't
    actually use most of the functions of `AbstractControl` right away, but it's a
    neat way to offset some of the code from a possible `Character` class. It will
    also be easy to add functionalities later on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个处理角色动画的控制。它将遵循jMonkeyEngine的控制模式并扩展`AbstractControl`。我们实际上不会立即使用`AbstractControl`的大多数功能，但这是一种巧妙的方法，可以将一些代码从可能的`Character`类中分离出来。稍后添加功能也将变得容易。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a control that will handle the animations of a character, perform
    the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个处理角色动画的控制，请执行以下步骤：
- en: Create a class called `CharacterAnimationManager` and have it extend `AbstractControl`.
    This class should also implement `AnimEventListener`, which `AnimControl` uses
    to tell our class when animations have finished playing.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CharacterAnimationManager`的类，并使其扩展`AbstractControl`。这个类还应实现`AnimEventListener`，这是`AnimControl`用来告诉我们的类动画何时播放完毕的。
- en: 'We''re going to map Jaime''s animations into an enum. This is so we don''t
    have to do a lot of string comparisons. While we''re at it, we''ll add some basic
    logic to the enum as well. The name of the animation, whether the animation should
    loop or not, and the time `AnimControl` should take to blend to a new animation
    using the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把杰米的动画映射到一个枚举中。这样我们就不必进行很多字符串比较。同时，我们也会在枚举中添加一些基本逻辑。动画的名称，动画是否应该循环，以及`AnimControl`使用以下代码将动画混合到新动画所需的时间：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need two fields as well: an `AnimControl` field called `animControl` and
    an `AnimChannel` called `mainChannel`.'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要两个字段：一个名为`animControl`的`AnimControl`字段和一个名为`mainChannel`的`AnimChannel`。
- en: 'We set these in the `setSpatial` method, as shown in the following code. Don''t
    forget to add the class to the `AnimControl` field as a listener, or we won''t
    receive any calls when animations are finished:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`setSpatial`方法中设置这些，如下面的代码所示。别忘了将类添加到`AnimControl`字段作为监听器，否则当动画完成后我们不会收到任何调用：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We define a new method called `setAnimation` in the following code. Inside
    this, we set the supplied animation to be `mainChannel` as the current one if
    it''s not the same as the one playing now. We also set `loopMode` according to
    how it''s defined in the enum:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们定义了一个名为`setAnimation`的新方法。在这个方法内部，我们设置提供的动画作为当前正在播放的`mainChannel`。我们还根据枚举中的定义设置`loopMode`：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `onAnimCycleDone` method, we create a control so that all animations
    that don''t loop return to the idle animation, with the exception of `JumpStart`,
    which should switch to `Jumping` (as in midair) as shown in the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onAnimCycleDone`方法中，我们创建一个控制，使得所有不循环的动画都返回到空闲动画，除了`JumpStart`，它应该切换到`Jumping`（如在空中）的状态，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s all that''s needed to create a class that manages animations! To set
    this up from an application, we just need to load a model in the application and
    add the following line:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管理动画的类所需的就是这些！要从应用程序中设置这个，我们只需要在应用程序中加载一个模型并添加以下行：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `AnimControl` class is responsible for playing and keeping track of the
    animations. `AnimChannel` has a list of `Bones` that the animation should affect.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimControl`类负责播放和跟踪动画。`AnimChannel`有一个动画应该影响的`Bones`列表。'
- en: Since we let the enum decide the animation parameters for us, we don't need
    much code in the `setAnimation` method. We do however need to make sure we don't
    set the same animation if it is already playing or it could get stuck, repeating
    the first frame in a loop.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于枚举为我们决定了动画参数，我们不需要在`setAnimation`方法中写很多代码。然而，我们需要确保我们不会设置已经在播放的相同动画，否则可能会导致动画卡住，重复第一帧。
- en: The `onAnimCycleDone` method is called from `AnimControl` whenever an animation
    reaches the end. Here, we decide what will happen when this occurs. If the animation
    is not looping, we must tell it what to do next. Playing the idle animation is
    a good choice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画到达结束时，`onAnimCycleDone`方法会从`AnimControl`中被调用。在这里，我们决定当这种情况发生时会发生什么。如果动画不是循环的，我们必须告诉它接下来要做什么。播放空闲动画是一个不错的选择。
- en: We also have one special case. If you look at the animation list, you will notice
    that Jaime's jump animation is split into three parts. This is to make it easier
    to handle jumps of different lengths or the falling animation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个特殊情况。如果你查看动画列表，你会注意到杰米的跳跃动画被分成了三部分。这是为了更容易地处理不同长度的跳跃或下落动画。
- en: We will tell `AnimControl` to change the animation to a jumping action once
    `JumpStart` is done. We never change to `JumpEnd` once the jumping action has
    taken place however. Instead, this should be called from elsewhere when Jaime
    hits the ground after he jumps. How this is measured is dependent on the game
    logic, but since we're using the `Control` pattern, we could use `controlUpdate`
    to check Jaime's whereabouts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当`JumpStart`完成后，我们将告诉`AnimControl`将动画更改为跳跃动作。然而，一旦跳跃动作发生，我们永远不会更改为`JumpEnd`。相反，这应该在他跳跃后触地时从其他地方调用。如何测量这取决于游戏逻辑，但因为我们使用的是`Control`模式，所以我们可以使用`controlUpdate`来检查杰米的当前位置。
- en: Extending the animation control
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展动画控制
- en: In the previous recipe, we built the basics for an animation by managing the
    `Control` class. This would be fine for many types of games, but for a game where
    a character is in focus, let's say an FPS, we would want a more detailed control.
    This is where the concept of `AnimChannel` comes in handy. `AnimChannel` is a
    way of dividing a skeleton into different groups of bones and applying an animation
    only to them. As we will find out in this recipe, this means we can have different
    animations playing on different parts of the body at the same time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们通过管理 `Control` 类构建了动画的基础。这对于许多类型的游戏来说都很好，但对于一个以角色为重点的游戏，比如第一人称射击游戏（FPS），我们可能需要一个更详细的控制。这就是
    `AnimChannel` 概念发挥作用的地方。`AnimChannel` 是将骨骼分成不同的骨骼组并仅对它们应用动画的一种方式。正如我们将在本食谱中发现的那样，这意味着我们可以在同一时间让身体的不同部位播放不同的动画。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Applying animations only to certain channels can help reduce the workload tremendously
    for a character-focused game. Let's say we're making an FPS or RPG where the character
    can wield a number of different items and weapons, both one– and two–handed. Making
    full-body animations for all the combinations, including standing, walking, running,
    and more, is not feasible. If instead, you are able to apply the weapon animation
    only to the upper body and a walk animation to the lower body, you get a lot more
    freedom.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 仅对某些通道应用动画可以帮助大幅减少以角色为重点的游戏的工作量。比如说，我们正在制作一个第一人称射击游戏（FPS）或角色扮演游戏（RPG），其中角色可以挥舞多种不同的物品和武器，包括单手和双手。为所有组合制作全身动画，包括站立、行走、跑步等，是不切实际的。如果相反，你能够只将武器动画应用于上半身，将行走动画应用于下半身，你将获得更多的自由。
- en: This recipe will also describe some other tricks that might help in developing
    the game.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱还将描述一些可能有助于开发游戏的其他技巧。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can have different animations playing on different parts of the body at
    the same time by performing the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下步骤，我们可以在同一时间让身体的不同部位播放不同的动画：
- en: First of all, we'll implement the `ActionListener` and `AnalogListener` interfaces
    in our animation's `manager` class. This will allow us to receive input directly
    from an input-handling class and decide which animations to play.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在动画的 `manager` 类中实现 `ActionListener` 和 `AnalogListener` 接口。这将允许我们直接从输入处理类接收输入并决定播放哪些动画。
- en: 'Next, we define two `AnimChannels`: one for the upper body called `upperChannel`
    and one for the lower called `lowerChannel`. We also create a `Channel` enum to
    easily choose whether to play an animation in a separate channel or the whole
    body, as shown in the following code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义两个 `AnimChannels`：一个称为 `upperChannel` 的上半身通道和一个称为 `lowerChannel` 的下半身通道。我们还创建了一个
    `Channel` 枚举，以便轻松选择是否在单独的通道或整个身体中播放动画，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The SceneExplorer can be used to find suitable bones as shown in the following
    screenshot:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 SceneExplorer 来查找合适的骨骼，如下面的截图所示：
- en: '![How to do it...](img/6478OS_04_01.jpg)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/6478OS_04_01.jpg)'
- en: 'In the `setSpatial` method, we create the upper and lower channels in `AnimControl`.
    We let `AnimChannel` add all the bones recursively using the `addFromRootBone`
    method, as shown in the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setSpatial` 方法中，我们在 `AnimControl` 中创建上下通道。我们让 `AnimChannel` 使用 `addFromRootBone`
    方法递归地添加所有骨骼，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the same method, add this instance as `AnimEventListener` to `AnimControl`
    to receive events when animations change or cycle, as shown in the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的方法，将此实例作为 `AnimEventListener` 添加到 `AnimControl` 中，以便在动画改变或循环时接收事件，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To be able to set specific animations from other classes, we add a method called
    `setAnimation`, which takes an animation and `Channel` (enum) as the input, as
    shown in the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够从其他类设置特定的动画，我们添加了一个名为 `setAnimation` 的方法，该方法接受一个动画和一个 `Channel`（枚举）作为输入，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `onAction` method, the control can receive input directly from `InputListener`
    and apply the logic on its own before setting the animation, as shown in the following
    code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onAction` 方法中，控制可以直接从 `InputListener` 接收输入，并在设置动画之前应用自己的逻辑，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, to test the concept of `AnimChannels`, we can implement `ActionListener`
    in our `SimpleApplication` instance and bind some keys to it, as shown in the
    following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了测试 `AnimChannels` 的概念，我们可以在我们的 `SimpleApplication` 实例中实现 `ActionListener`
    并将其绑定到一些键上，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As an example of how the concept of `AnimChannels` can be used to create new
    animations out of combined ones, create a new application and set the walk animation
    on Jaime's `lowerChannel` while applying the jumping animation on `upperChannel`.
    Jaime will now commence a zombie walk impression.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为如何使用 `AnimChannels` 的概念从组合动画中创建新动画的示例，创建一个新的应用程序，并将行走动画设置在 Jaime 的 `lowerChannel`
    上，同时将跳跃动画应用于 `upperChannel`。现在，Jaime 将开始僵尸行走的模仿。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We can see that the `Animation` enum has had a field called `key` added. This
    is not necessary but is part of a way to not have to hard-code animation names.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`Animation` 枚举中增加了一个名为 `key` 的字段。这并非必需，但它是一种避免硬编码动画名称的方法的一部分。
- en: 'By using the `addFromRootBone` method, the channel will automatically add all
    the bones recursively, starting with the bone that is supplied first. After adding
    spine to `upperChannel`, it will continue down the chain, adding shoulders, neck,
    arms, and hands, as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `addFromRootBone` 方法，通道将自动递归地添加所有骨骼，从提供的第一个骨骼开始。在将脊椎添加到 `upperChannel`
    之后，它将继续向下链，添加肩膀、颈部、手臂和手，如下面的截图所示：
- en: '![How it works...](img/6478OS_04_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/6478OS_04_02.jpg)'
- en: Different animations applied to the upper and lower parts of the body
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作用于身体上下部分的动画
- en: Since we implemented `ActionListener`, there's also an `onAction` method in
    the class, which can receive an input from a number of external sources, such
    as `InputListener`. This also means it can apply logic by itself before deciding
    on what to play and not simply being an animation-playing control. We can recognize
    the pattern used here from the `GameCharacterControl` class from [Chapter 2](ch02.html
    "Chapter 2. Cameras and Game Controls"), *Cameras and Game Controls*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实现了 `ActionListener`，类中还有一个 `onAction` 方法，它可以接收来自多个外部源（如 `InputListener`）的输入。这也意味着它可以在决定播放什么以及不播放什么之前自行应用逻辑，而不仅仅是作为动画播放控制。我们可以从第
    2 章的 `GameCharacterControl` 类中识别出这里使用的模式，*Cameras and Game Controls*。
- en: By supplying a `Properties` file that maps the animation names, it's possible
    to use models with different naming conventions. It's also easier for a designer
    or artist to try out a number of different animations without consulting a programmer
    to make changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个映射动画名称的 `Properties` 文件，可以使用具有不同命名约定的模型。这也使得设计师或艺术家在无需咨询程序员进行更改的情况下尝试多种不同的动画变得更加容易。
- en: Handling jump animations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理跳跃动画
- en: In this recipe, we'll show how the jumping animation can be handled in the animation
    manager control from previous recipes. Why does this require its own recipe? Animation-wise,
    jumping is usually a set of sequenced animations. If we look at Jaime, for example,
    there's `JumpStart`, `Jumping`, and `JumpEnd`. Normally, sequenced animations
    can be handled in the `onAnimCycleDone` method; when one animation ends, it can
    trigger the next. Jumping is different though since the middle jumping animation
    is indefinite and is on a loop. How long it plays depends on how long the character
    is in the air, which is driven by the gameplay or its physics.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示如何从之前的菜谱中的动画管理器控制中处理跳跃动画。为什么这需要一个单独的菜谱？从动画的角度来看，跳跃通常是一组顺序动画。如果我们以
    Jaime 为例，有 `JumpStart`、`Jumping` 和 `JumpEnd`。通常，顺序动画可以在 `onAnimCycleDone` 方法中处理；当一个动画结束时，它可以触发下一个。但跳跃不同，因为中间的跳跃动画是不确定的，并且是循环的。它播放多长时间取决于角色在空中的时间，这由游戏玩法或其物理属性驱动。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can handle jumping animations by performing the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下步骤处理跳跃动画：
- en: 'For this, we''ll need to add two more Booleans to our animation control: `jumpStarted`
    and `inAir`.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在我们的动画控制中添加两个额外的布尔值：`jumpStarted` 和 `inAir`。
- en: 'We trigger the first part of the animation in the `onAction` method, as shown
    in the following code. The `jumpStarted` Boolean is used to let the class know
    that other animations should not start while the character is the jumping state:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `onAction` 方法中触发动画的第一部分，如下面的代码所示。`jumpStarted` 布尔值用于让类知道，当角色处于跳跃状态时，不应启动其他动画：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `onAnimCycleDone` method should switch animations back to the jumping action
    once `JumpStart` has finished playing. We also set `inAir` to `true`, as shown
    in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `JumpStart` 播放完毕后，`onAnimCycleDone` 方法应将动画切换回跳跃动作。我们还将 `inAir` 设置为 `true`，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `controlUpdate` method is suitable to check whether the character has landed
    after jumping (or falling). We check this directly in `BetterCharacterControl`
    and change the animation if it is back on the ground, as shown in the following
    code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`controlUpdate`方法适合检查角色在跳跃（或下落）后是否已经着陆。我们直接在`BetterCharacterControl`中检查这一点，如果角色回到了地面，就改变动画，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The implementation relies on the listener pattern where this control receives
    a notification of user actions from an external input class. In this project,
    we have a separate class that controls the character.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现依赖于监听器模式，其中这个控制从外部输入类接收用户动作的通知。在这个项目中，我们有一个单独的类来控制角色。
- en: This `onAnimCycleDone` method is called by the `AnimControl` method when an
    animation has finished with one cycle (both looping and non-looping animations).
    Normally, when an animation ends, we'll want to switch to the idle animation to
    stop it from freezing. When `JumpStart` is finished, however, the character is
    most likely in midair and thus switches to a suitable looping animation. The `inAir`
    Boolean is used so the class knows it should start checking for when the character
    lands again.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个动画完成一个循环（包括循环和非循环动画）时，`onAnimCycleDone`方法会被`AnimControl`方法调用。通常，当动画结束时，我们希望切换到空闲动画以防止它冻结。然而，当`JumpStart`完成时，角色很可能是处于空中，因此切换到合适的循环动画。使用`inAir`布尔值，类知道它应该开始检查角色何时再次着陆。
- en: Depending on the size of a project, the control class for the character and
    this animation-managing class might be merged into one. This should make some
    things easier, while the class itself might get bulky as more functions are implemented.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的大小，角色控制类和这个动画管理类可能会合并成一个。这应该会使一些事情变得更容易，但随着更多功能的实现，类本身可能会变得庞大。
- en: The `controlUpdate` class is called automatically with every tick, and here
    we can see whether the character is still airborne. In this implementation, `BetterCharacterControl`
    is used, and it has a method to see whether it is on ground. Jaime has a `JumpEnd`
    animation, but idle seems to work better with some blending.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`controlUpdate`类会随着每个tick自动调用，在这里我们可以看到角色是否仍然在空中。在这个实现中，使用了`BetterCharacterControl`，它有一个方法可以检查角色是否在地面上。Jaime有一个`JumpEnd`动画，但似乎与一些混合效果相比，空闲状态工作得更好。'
- en: Creating a custom animation - leaning
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义动画 - 倾斜
- en: Custom animation is the concept of directly manipulating the bones of a character's
    skeleton to create animations. We will explore this by making a control that can
    be used together with [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*. Together with this recipe, leaning can be used on
    characters other than the player and in networked games.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义动画是直接操纵角色骨骼以创建动画的概念。我们将通过创建一个可以与[第2章](ch02.html "第2章。相机和游戏控制")，*相机和游戏控制*一起使用的控制来探索这一点。与这个食谱一起，倾斜可以用于玩家以外的角色和网络游戏中。
- en: '![Creating a custom animation - leaning](img/6478OS_04_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义动画 - 倾斜](img/6478OS_04_03.jpg)'
- en: Jaime leaning to the left
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Jaime向左倾斜
- en: 'As in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras
    and Game Controls*, we have two ways to handle leaning: one is by using a key
    to lean toward the left and another to lean toward the right. The second one is
    to press a button and lean in any direction using the mouse, which is more common
    in computer games.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[第2章](ch02.html "第2章。相机和游戏控制")，*相机和游戏控制*中所述，我们有两种处理倾斜的方法：一种是通过使用一个键向左倾斜，另一种是向右倾斜。第二种方法是按下一个按钮，并使用鼠标向任何方向倾斜，这在计算机游戏中更为常见。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The control we are going to build will share some code with the recipe from
    [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game
    Controls*. The shared code will be explained there to save space, and it will
    most likely be used in tandem with this recipe, so being familiar with it is helpful.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的控制将共享[第2章](ch02.html "第2章。相机和游戏控制")中的代码，*相机和游戏控制*。共享的代码将在那里解释以节省空间，并且它很可能会与这个食谱一起使用，因此熟悉它是有帮助的。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We start by creating a new class that extends `AbstractControl` and implements
    `Action-` and `AnalogListener`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的类，该类扩展了`AbstractControl`并实现了`Action-`和`AnalogListener`。
- en: Next, we define some values that will help us control the leaning. The `leanValue`
    is the current amount of leaning that is applied. There needs to be a limit on
    how much the character can lean, which is set in `maxLean`. For this example,
    it's 45 degrees in either direction. The two Booleans `leanLeft` and `leanRight`
    define whether we're currently leaning in either direction using keys, and `leanFree`
    defines whether the mouse is used. The `leaningBone` is the bone that we'll modify,
    and we'll also store the bone's original rotation in `boneRotation` and use it
    as a base when leaning.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一些值，这些值将帮助我们控制倾斜。`leanValue` 是当前应用的倾斜量。需要对角色可以倾斜的最大量进行限制，这由 `maxLean`
    设置。在这个例子中，无论是哪个方向，都是45度。两个布尔值 `leanLeft` 和 `leanRight` 定义了是否正在使用按键向任一方向倾斜，而 `leanFree`
    定义了是否使用鼠标。`leaningBone` 是我们将要修改的骨骼，我们还将存储骨骼的原始旋转在 `boneRotation` 中，并在倾斜时将其用作基准。
- en: 'When the control is added to a spatial, we need to look for a bone to apply
    the leaning to. We select spine as `leaningBone`, and clone its current rotation,
    as shown in the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当控制被添加到空间中时，我们需要寻找一个要应用倾斜的骨骼。我们选择脊柱作为 `leaningBone`，并克隆其当前旋转，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `onAction` method will receive the input and should set the controlling
    Booleans, namely, `leanLeft`, `leanRight`, and `leanFree`. The `onAnalog` option
    receives the mouse input when `leanFree` is active.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onAction` 方法将接收输入并应设置控制布尔值，即 `leanLeft`、`leanRight` 和 `leanFree`。`onAnalog`
    选项在 `leanFree` 激活时接收鼠标输入。'
- en: 'In the `controlUpdate` method, we check to see whether any leaning is to be
    applied, first to the left and then similarly to the right. If `leanValue` is
    near `0f`, we will round it off to `0`. If this happens, we give the control back
    to `AnimControl`, as shown in the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `controlUpdate` 方法中，我们检查是否要应用任何倾斜，首先向左倾斜，然后以类似的方式向右倾斜。如果 `leanValue` 接近 `0f`，我们将将其四舍五入到
    `0`。如果发生这种情况，我们将控制权交还给 `AnimControl`，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `lean` method, which applies the leaning to the bone, the first thing
    we do is clamp the value to be inside the allowed threshold. Next, we call `setUserControl`
    on the bone to let it know that it shouldn''t apply animations before creating
    a new `Quaternion` class based on the original rotation, as shown in the following
    code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `lean` 方法中，该方法将倾斜应用于骨骼，我们首先做的事情是将值限制在允许的阈值内。接下来，我们在基于原始旋转创建新的 `Quaternion`
    类之前，在骨骼上调用 `setUserControl` 以让其知道它不应该应用动画，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When selecting a bone to apply the leaning to, it should be close to the base
    of the upper body of the character. On Jaime, the spine is a suitable bone.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要应用倾斜的骨骼时，它应该靠近角色的上半身底部。在Jaime身上，脊柱是一个合适的骨骼。
- en: When `Bone.setUserControl(true)` is called, we tell the bone that no animations
    should be applied and that we will handle any rotation or translation manually.
    This has to be called before we set the rotation, or an exception will be thrown.
    Likewise, when we're done, we need to call `setUserControl(false)` to give the
    control back to the user (or no animation would be played).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `Bone.setUserControl(true)` 时，我们告诉骨骼不应用任何动画，我们将手动处理任何旋转或平移。这必须在设置旋转之前调用，否则将抛出异常。同样，当我们完成时，我们需要调用
    `setUserControl(false)` 将控制权交还给用户（否则不会播放动画）。
- en: Manually controlling bones is powerful and can be useful for many different
    applications, such as precision aiming and head tracking. Getting everything right
    can be tricky, however, and most likely it's not something that you will do frequently.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 手动控制骨骼功能强大，可以用于许多不同的应用，例如精确瞄准和头部跟踪。然而，要一切正确可能很棘手，而且这很可能不是你经常做的事情。
- en: This class can be used separately from [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Controls*, or they can be merged together.
    The benefit of having them separate is that we can also apply them separately.
    For example, the player's own character in a FPS won't need this control since
    you would never see it lean anyway. In this case, it's all about the camera. However,
    other players in the same (networked) FPS will need it, as would AI enemies who
    might use the same character control class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以单独使用，也可以与[第2章](ch02.html "第2章。相机和游戏控制")，*相机和游戏控制*一起使用，或者它们可以合并在一起。将它们分开的好处是，我们也可以单独应用它们。例如，在FPS游戏中，玩家的角色不需要这个控制，因为你永远不会看到它倾斜。在这种情况下，一切都关于相机。然而，同一（网络）FPS中的其他玩家需要它，AI敌人可能也会使用相同的角色控制类。
- en: To learn more about how `leanValue` is used and applied, have a look at the
    *Leaning around corners* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and
    Game Controls"), *Cameras and Game Controls*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`leanValue`的使用和应用，请参阅[第2章](ch02.html "第2章。相机和游戏控制")的*在角落附近倾斜*配方，*相机和游戏控制*。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we're using an imported model and don't have access to a list of the bones,
    how do we know which bone to use? One simple way is to open the model in **Scene
    Explorer**. In **SkeletonControl**, we can see all the bones the character has
    but not their relative position on the model. By right-clicking and selecting
    **Get attachment node**, a new node will be created; also, by selecting it, we
    can see where it's located on the model. For more information on attachment nodes,
    have a look at the *Retrieving an attachment node* recipe of [Chapter 1](ch01.html
    "Chapter 1. SDK Game Development Hub"), *SDK Game Development Hub*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是导入的模型且无法访问骨骼列表，我们如何知道使用哪个骨骼？一种简单的方法是在**场景浏览器**中打开模型。在**骨骼控制**中，我们可以看到角色拥有的所有骨骼，但不知道它们在模型上的相对位置。通过右键单击并选择**获取附件节点**，将创建一个新的节点；同时，通过选择它，我们可以在模型上看到它的位置。有关附件节点的更多信息，请参阅[第1章](ch01.html
    "第1章。SDK游戏开发中心")的*检索附件节点*配方，*SDK游戏开发中心*。
- en: Creating a subanimation
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子动画
- en: 'In this recipe, we''re going to use SceneComposer to create subanimations.
    As the name implies, they''re derived from an animation. Subanimations can be
    a good way to squeeze some extra out of stock models that don''t have the exact
    animations you want, or if the modeler has gone home for the day. In this particular
    application, we''ll prepare for the next recipe, which is about lip syncing. The
    **Extract sub animation** window in SDK looks, as shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用场景作曲家来创建子动画。正如其名所示，它们是从动画中派生出来的。子动画可以是从库存模型中挤出一些额外内容的好方法，或者如果模型师已经回家了。在这个特定的应用中，我们将为下一配方做准备，该配方是关于嘴唇同步的。SDK中的**提取子动画**窗口看起来如下截图所示：
- en: '![Creating a subanimation](img/6478OS_04_04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![创建子动画](img/6478OS_04_04.jpg)'
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The biggest caveat when creating subanimations is that the jMonkeyEngine API
    uses relative time when interacting with models, while subanimations are created
    on a frame basis. So, the easiest way to find out which frames to extract is to
    open the model in an external editor and look at it in parallel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子动画时最大的注意事项是，jMonkeyEngine API在与模型交互时使用相对时间，而子动画是基于帧创建的。因此，找出要提取的帧的最简单方法是打开模型在外部编辑器中，并与之并行查看。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Extracting a subanimation can be done by performing the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提取子动画可以通过以下步骤完成：
- en: With the model opened in the Scene Composer, we expand **AnimControl**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景作曲家打开模型后，我们展开**AnimControl**。
- en: Now, we can see all the animations that are currently available. We right-click
    on an animation we would like to create a subanimation out of and choose the option,
    **Extract Sub-animation**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以看到目前所有可用的动画。我们右键单击想要从中创建子动画的动画，并选择**提取子动画**选项。
- en: Enter a start and end frame and it's done. The new animation is now available
    in the **AnimControl** option.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入起始帧和结束帧，操作完成。新的动画现在可在**AnimControl**选项中找到。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An animation in jMonkeyEngine consists of a number of `BoneTracks`. Each of
    these has an array of floats with the times for the animations, an array of `Vector3f`
    with the positions of the bones, array of Quaternions with rotations, and another
    array of `Vector3f's` with scales. Each instance of the arrays contains information
    about a frame.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: jMonkeyEngine中的动画由多个`BoneTracks`组成。这些中的每一个都有一个包含动画时间的浮点数数组，一个包含骨骼位置的`Vector3f`数组，一个包含旋转的四元数数组，以及另一个包含缩放值的`Vector3f`数组。数组的每个实例都包含有关一帧的信息。
- en: A subanimation is a copy of an excerpt from all the `BoneTracks` in the parent
    animation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 子动画是从父动画中所有`BoneTracks`的摘录的副本。
- en: Lip syncing and facial expressions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嘴唇同步和面部表情
- en: This recipe handles two important parts of making characters seem alive and
    sentient. Technically, they can be handled using `AnimChannel`, but they still
    deserve their own mention as they have some special requirements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方处理使角色看起来有生命和感知的两个重要部分。技术上，可以使用`AnimChannel`来处理，但它们仍然值得单独提及，因为它们有一些特殊要求。
- en: Lip syncing revolves around something called **Phoneme**, which is the distinct
    shape the mouth takes when making certain sounds. The number of phonemes a character
    has varies according to different needs, but there is a basic set that is used
    to create believable mouth movements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 唇同步围绕一个称为**音素**的概念，这是在发出某些声音时嘴巴所采取的独特形状。一个角色拥有的音素数量根据不同的需求而变化，但有一个基本集合用于创建可信的嘴部动作。
- en: Finally, we'll use jMonkeyEngine's **Cinematics** system to apply them in sequence
    and have the character speak (mime) a word. Cinematics is jMonkeyEngine's scripting
    system, and it can be used both to create in-game-scripted events and cutscenes.
    It is covered in more depth in [Chapter 9](ch09.html "Chapter 9. Taking Our Game
    to the Next Level"), *Taking Our Game to the Next Level*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用jMonkeyEngine的**Cinematics**系统按顺序应用它们，并让角色说话（模仿）一个单词。Cinematics是jMonkeyEngine的脚本系统，它可以用来创建游戏中的脚本事件和场景。在[第9章](ch09.html
    "第9章。将我们的游戏提升到下一个层次")*将我们的游戏提升到下一个层次*中有更深入的介绍。
- en: We'll follow the control pattern in this recipe, and control can be merged into
    another animation controller or be kept alone.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循这个食谱中的控制模式，控制可以合并到另一个动画控制器中，或者保持独立。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Having a model with phoneme animations ready or creating them in an external
    modeling program is preferred. It's perfectly all right if the animations are
    one-frame static expressions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个带有音素动画的模型或在外部建模程序中创建它们是首选的。如果动画是一帧静态表情，这也是完全可以接受的。
- en: If the previous options are not available, one method is to use the SDK's functionality
    to create subanimations. A version of Jaime with phoneme animations is supplied
    with the project for the sake of this recipe. For those interested in going through
    the process of creating subanimations themselves, there is a list of the ones
    used in the *Enabling nightly builds* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Fragments*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的选项不可用，一种方法是使用SDK的功能来创建子动画。该项目附带了一个带有音素动画的Jaime版本，用于本食谱。对于那些对创建子动画过程感兴趣的人，可以在[附录](apa.html
    "附录A.信息片段")*信息片段*中的*启用夜间构建*部分找到使用的子动画列表。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'All the required functionalities can be implemented in a single class by performing
    the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必需的功能都可以通过以下步骤在一个类中实现：
- en: To start off, we create a new class called `ExpressionsControl` that extends
    `AbstractControl`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的类，名为`ExpressionsControl`，它扩展了`AbstractControl`。
- en: Inside this, we add `AnimControl` named `animControl`, one `AnimChannel` called
    `mouthChannel`, and another `AnimChannel` called `eyeBrowChannel`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个内部，我们添加了一个名为`animControl`的`AnimControl`，一个名为`mouthChannel`的`AnimChannel`，以及另一个名为`eyeBrowChannel`的`AnimChannel`。
- en: 'We define an enum to keep track of the phonemes that the controller supports.
    These are some of the most common ones, plus a `RESET` option for a neutral mouth
    expression, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个枚举来跟踪控制器支持的音素。这些是最常见的几个，还有一个`RESET`选项用于中性的嘴部表情，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We create another enum to set the expressions of the eyes, which is a simple
    way of adding emotions to what the character says, as shown in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建另一个枚举来设置眼睛的表情，这是一种简单的方法，可以向角色所说的内容添加情感，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `setSpatial` method, we create `AnimChannel` for mouth animations and
    one for the eyes, then we add suitable bones to each of these, as shown in the
    following code. The list of bones available can be seen in `SkeletonControl` in
    `SceneComposer`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setSpatial`方法中，我们为嘴部动画创建`AnimChannel`，并为眼睛创建一个，然后我们向这些中的每一个添加合适的骨骼，如下面的代码所示。可用的骨骼列表可以在`SceneComposer`中的`SkeletonControl`中看到。
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the animations we'll use might just be one or a few frames each, we can
    set `LoopMode` to `Loop` or `Cycle`. The speed has to be higher than `0` or blending
    won't work. Set these for both `AnimChannels`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用的动画可能只是一帧或几帧，我们可以将`LoopMode`设置为`Loop`或`Cycle`。速度必须高于`0`，否则混合效果不会工作。这两个`AnimChannels`都需要设置。
- en: 'Then, we have two setter methods to directly set an expression or phoneme in
    the control. The naming convention might differ depending on the assets, and it''s
    good to have a small blending value:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有两个setter方法可以直接设置控制中的表达式或音素。命名约定可能因资产而异，并且保持一个小的混合值是好的：
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can reuse any test class we might have from other recipes and just apply
    some new code to it as seen in the following code snippet. We set up a simple
    cinematic sequence that makes Jaime say (or mime) *Hello* and look happy.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以重用其他菜谱中的任何测试类，并只需在它上面应用一些新代码，如下面的代码片段所示。我们设置了一个简单的电影序列，让贾伊姆说（或模仿）*你好*并看起来很高兴。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When this recipe was written, the following `AnimationEvent` constructor did
    not exist and `AnimChannels` were not applied properly. A patch has been submitted
    but may not have made it into a stable build. If required, the patch can be found
    in the *The AnimationEvent patch* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Gathering*. It can also be acquired by turning on nightly
    builds in the SDK.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当编写这个菜谱时，以下 `AnimationEvent` 构造函数不存在，并且 `AnimChannels` 没有正确应用。已经提交了一个补丁，但可能还没有进入稳定的构建。如果需要，补丁可以在[附录](apa.html
    "附录 A. 信息片段")的*动画事件补丁*部分找到，*信息收集*。也可以通过在SDK中开启夜间构建来获取。
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The technical principles behind the phonemes are not that different from animating
    other parts of the character. We create `AnimChannels`, which handles different
    sets of bones. The first tricky bit is to organize the channels if you want to
    be able to control different parts of the body at the same time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 音素背后的技术原理与其他部分的动画并没有太大的不同。我们创建 `AnimChannels`，它处理不同的骨骼集合。第一个棘手的问题是，如果你想同时控制身体的各个部分，你需要组织好这些通道。
- en: The pipeline for how to apply the phonemes can also be difficult. The first
    step will be to not set them directly in the code. It's not implausible that changing
    the expression of the character could be called directly from the code on certain
    events. Doing so for each phoneme in a sentence would be very cumbersome. Using
    the cinematics system is a good start as it would be relatively simple to write
    a piece of code that parses a text file and creates a cinematic sequence from
    it. Timing is really crucial, and it can take a lot of time to get the movements
    synced with sound. Doing it in a format that allows you to have a quick iteration
    is important.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用音素的管道也可能很困难。第一步将是不直接在代码中设置它们。从代码中直接调用改变角色的表情在特定事件中并不令人难以置信。对句子中的每个音素都这样做会非常繁琐。使用电影系统是一个好的开始，因为它会相对简单地将代码解析文本文件并从中创建电影序列。时间非常关键，将动作与声音同步可能需要很多时间。以允许快速迭代的格式来做这件事很重要。
- en: Another more complex way would be to build up a database that maps words and
    phonemes and automatically applies them in a sequence.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更复杂的方法是建立一个数据库，该数据库将单词和音素进行映射，并自动按顺序应用它们。
- en: The absolutely simplest approach is to not really care about lip syncing and
    just apply a moving mouth animation whenever the character speaks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是根本不关心唇同步，并在角色说话时应用移动的嘴巴动画。
- en: Eye movement
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 眼睛运动
- en: 'Eye contact is an important factor to make characters feel alive and aware
    of yours and other things'' presence. In this chapter, we''ll make a control that
    will follow a spatial with its eyes, as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 眼神接触是使角色显得生动并意识到你的和其他事物的存在的重要因素。在本章中，我们将创建一个控制，使其眼睛跟随空间，如下面的截图所示：
- en: '![Eye movement](img/6478OS_04_05.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![眼睛运动](img/6478OS_04_05.jpg)'
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Eye tracking can be implemented in a single control using the following steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 眼睛追踪可以通过以下步骤在单个控制中实现：
- en: We begin by creating a new class called `EyeTrackingControl` that extends `AbstractControl`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的类 `EyeTrackingControl`，它扩展了 `AbstractControl`。
- en: 'It needs two `Bone` fields: one called `leftEye` and another called `rightEye`.
    Furthermore, we should add a spatial called `lookAtObject` and a related `Vector3f`
    called `focusPoint`.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要两个 `Bone` 字段：一个称为 `leftEye`，另一个称为 `rightEye`。此外，我们还应该添加一个名为 `lookAtObject`
    的空间和一个相关的 `Vector3f`，称为 `focusPoint`。
- en: In the `setSpatial` method, we find and store the bones for `leftEye` and `rightEye`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setSpatial` 方法中，我们找到并存储 `leftEye` 和 `rightEye` 的骨骼。
- en: We also need a method to set `lookAtObject`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个方法来设置 `lookAtObject`。
- en: 'With this done, we add most of the other functionalities to the `controlUpdate`
    method. First of all, we need to take control of the bones or we won''t be able
    to modify their rotation, as shown in the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将大多数其他功能添加到 `controlUpdate` 方法中。首先，我们需要控制骨骼，否则我们无法修改它们的旋转，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to establish the `lookAtObject` position that is relative to
    the eyes. We do this by converting the position to model space and storing it
    in `focusPoint`, as shown in the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定相对于眼睛的 `lookAtObject` 位置。我们通过将位置转换为模型空间并将其存储在 `focusPoint` 中来完成此操作，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Subtracting the eye position from `Vector3f` gives us the relative direction:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Vector3f` 减去眼睛位置，我们得到相对方向：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We create a new Quaternion and have it look in the direction of the `direction`
    vector. We can apply this on our eyes after modifying it a bit as its 0-rotation
    is up:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的四元数，并使其朝向 `direction` 向量的方向。我们可以在稍作修改后将其应用于我们的眼睛，因为它的 0-旋转是向上：
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we apply it by using `setUserTransformsWorld`. Finally, we give the control
    of the bones back to the system using the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过使用 `setUserTransformsWorld` 来应用它。最后，我们使用以下代码将骨骼的控制权交还给系统：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The actual code is a fairly straightforward trigonometry, but knowing what values
    to use and the flow of doing it can be tricky.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的代码是相当直接的三角函数，但知道使用哪些值以及如何进行流程可以很棘手。
- en: Once the class receives an object to look at, it subtracts the model's `worldTranslation`
    from `lookAtObjects` so they end up in a coordinate system that is relative to
    the model's origo point also called **modelspace**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类接收到要观察的对象，它就会从 `lookAtObjects` 中减去模型的 `worldTranslation`，这样它们最终会出现在相对于模型原点（也称为
    **modelspace**）的坐标系中。
- en: Using `setUserTransformsWorld` also sets the position, but since we supply its
    current `modelSpacePosition`, no change will be applied.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setUserTransformsWorld` 也会设置位置，但由于我们提供了它的当前 `modelSpacePosition`，因此不会应用任何更改。
- en: Actually, the direction of each eye should be calculated separately for the
    result to be entirely correct.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个眼睛的方向都应该单独计算，以确保结果完全正确。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'By now, the character has a very intent stare at the camera. This is an improvement,
    but it can be made more lifelike. Something that may not be so obvious is that
    we rarely look at the same point all the time even if we look at the same object.
    We can emulate this behavior by adding a random bit of flickering to the control:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，角色对摄像机的注视非常专注。这是一个改进，但可以使其更加逼真。可能不那么明显的是，即使我们看的是同一个物体，我们也很少总是看同一个点。我们可以通过在控制中添加一些随机的闪烁来模拟这种行为：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By introducing these three fields, we have a base for what we want to do:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入这三个字段，我们为我们想要做的事情打下了基础：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This piece of code goes in the middle of the `controlUpdate` method, right after
    calculating the direction. What we do is we increase `flickerTime` until it reaches
    0.5f (note that this is not in seconds since we apply a random number). Once this
    happens, we randomize `flickerDirection` based on `flickerAmount` and reset `flickerTime`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码位于 `controlUpdate` 方法的中间，紧接在计算方向之后。我们做的事情是增加 `flickerTime` 直到它达到 0.5f（注意这并不是以秒为单位，因为我们应用了一个随机数）。一旦发生这种情况，我们就根据
    `flickerAmount` 随机化 `flickerDirection` 并重置 `flickerTime`。
- en: With each consecutive update, we will apply this to the calculated direction
    and slightly offset the focus point.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次连续更新中，我们将将其应用于计算出的方向，并稍微偏移焦点点。
- en: Location-dependent animation – edge check
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置相关的动画 – 边缘检查
- en: In certain games, players traverse dangerous areas where a fall off from a ledge
    could lead to their deaths. Sometimes, in these games, the player is not meant
    to fall off and their movement is restricted when they are close, or the player
    gets an extra warning before they plummet.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些游戏中，玩家穿越危险区域，从边缘掉落可能导致他们的死亡。有时，在这些游戏中，玩家不应该掉落，或者当他们靠近时，他们的移动会受到限制，或者玩家在坠落前会得到额外的警告。
- en: The control we'll develop can be used for any of those things, but since this
    chapter is about animations, we'll use it to play a special animation when the
    player gets too close to the edge.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的控制可以用于任何这些事情，但由于本章是关于动画的，我们将使用它来在玩家过于靠近边缘时播放一个特殊的动画。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The recipe will use similar patterns that have been used before in this chapter
    and we'll also use the animation manager control from earlier in the chapter.
    Any animation control will be fine to use, but it should have separate channels
    for the upper and lower parts of the body.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将使用本章之前使用过的类似模式，我们还将使用本章早期提到的动画管理器控制。任何动画控制都可以使用，但它应该有上下身分开的通道。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can implement almost everything we need in a single class as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以在一个类中实现我们需要的所有功能，如下所示：
- en: 'We begin by creating a class called `EdgeCheckControl`, which extends `AbstractControl`
    and contains the following fields, as shown in the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`EdgeCheckControl`的类，它扩展了`AbstractControl`并包含以下字段，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We define the nine rays that will be used for collision detection. In the `setSpatial`
    method, we instantiate them and aim them downwards, as shown in the following
    code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了用于碰撞检测的九条射线。在`setSpatial`方法中，我们实例化它们并将它们指向下方，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `controlUpdate` method, we begin by placing one of the rays at the center
    of the character, as shown in the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们首先将一条射线放置在角色的中心，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We step around the character, placing the remaining rays in a circular shape.
    For each, we see whether it collides with something using the `checkCollision`
    method. If it doesn''t, we don''t need to check the rest and can exit the loop
    using the following code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们围绕角色走动，将剩余的射线放置成圆形。对于每一个，我们使用`checkCollision`方法查看它是否与任何东西发生碰撞。如果没有，我们不需要检查其余部分，可以使用以下代码退出循环：
- en: '[PRE32]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the last step in this method, we call the animation manager and tell it
    to play or stop playing the near-edge animation, as shown in the following code.
    We do this based on whether all the collisions have been detected or not, making
    sure we only send any change in state:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此方法的最后一步，我们调用动画管理器并告诉它播放或停止播放近边缘动画，如下面的代码所示。我们根据是否已检测到所有碰撞来执行此操作，确保我们只发送任何状态变化：
- en: '[PRE33]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Switching to our animation manager class, we modify it accordingly. The state
    is stored here so it can be used to see what other animations are allowed to be
    played, as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到我们的动画管理器类，我们相应地对其进行修改。状态存储在这里，以便可以查看允许播放的其他动画，如下所示：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With each update, the nine rays we create are placed in a circle around the
    character, with one in the center.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次更新中，我们创建的九条射线被放置在角色周围的圆圈中，其中一条位于中心。
- en: They will check for collisions with a surface below them. If any of them (this
    might be changed to two or three) does not hit something within `okDistance`,
    it will be reported as the character being close to a dangerous edge.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将检查与它们下面的表面的碰撞。如果其中任何一个（这可能会改为两个或三个）在`okDistance`内没有击中任何东西，它将被报告为角色接近危险边缘。
- en: The `okDistance` has to be set to something suitable, higher than a step on
    a stair, probably at a height where the player could take damage.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`okDistance`必须设置为一个合适的值，高于楼梯的一步，可能是在玩家可能受到伤害的高度。'
- en: When this happens, the animation manager will be called with the `NearEdge`
    action set to `true`. This will apply the jumping animation (wild flaying of the
    arms) to the upper body of the character while still allowing other animations
    to be played on the lower part.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，动画管理器将被调用，并将`NearEdge`动作设置为`true`。这将应用跳跃动画（手臂的疯狂挥舞）到角色的上半身，同时仍然允许在下半身播放其他动画。
- en: The `NearEdge` Boolean is used to make sure that we only send the call to the
    animation manager once.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`NearEdge`布尔值用于确保我们只向动画管理器发送一次调用。'
- en: When doing collision checks, one should be careful about the amount and shape
    of the objects that are being collided. If the world is large or constructed from
    complex shapes (or even worse, if it has `MeshCollisionShape`), we should try
    to find optimized ways of applying the method. One way could be to separate the
    world into parts and have an auxiliary method to select which part to collide
    against. This method might use `contains` on `BoundingVolume` to see the part
    the player is located in.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行碰撞检查时，应注意被碰撞的对象的数量和形状。如果世界很大或由复杂形状构成（或者更糟糕的是，如果它有`MeshCollisionShape`），我们应该尝试找到应用此方法的优化方法。一种方法是将世界分成几个部分，并有一个辅助方法来选择要碰撞的部分。此方法可能使用`contains`在`BoundingVolume`上查看玩家所在的部分。
- en: Aligning feet with ground – inverse kinematics
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将脚与地面对齐 - 反向运动学
- en: Inverse kinematics is now a common part of animation systems in games and is
    a topic that might cover a chapter on its own. In this recipe, we'll look at placing
    a character's feet in accordance to the ground below. This is useful where an
    animation would otherwise place them in the air or on sloped ground.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 反向运动学现在是游戏动画系统的一个常见部分，它可能是一个单独章节的主题。在这个菜谱中，我们将查看将角色的脚放置在地面以下的位置。这在动画可能会将它们放置在空中或斜坡地面上时非常有用。
- en: Normally, animations work according to forward kinematics; that is, when a bone
    near the root of the skeleton rotates, it affects the bones further down the chain.
    As the name implies, Inverse Kinematics starts at the other end.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，动画根据前向运动学工作；也就是说，当骨骼靠近骨骼根部旋转时，它会影响链中更下面的骨骼。正如其名所示，逆运动学从另一端开始。
- en: Here, we strive toward a desired position for the tip of a chain of bones, and
    bones further up the chain try to align themselves to suit this.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们努力达到一串骨骼尖端所需的位置，而链中更高位置的骨骼则试图调整自己以适应这一位置。
- en: The most straightforward implementation of this rotates the bones by a small
    amount on all the axes. It then checks which of the rotations brings the tip closest
    to the desired position. This is repeated for all the bones in the chain and iterated
    until it has come close enough.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最直接的实施方式是在所有轴向上旋转骨骼一小部分。然后它检查哪种旋转可以使尖端最接近所需位置。这会针对链中的所有骨骼重复进行，直到足够接近。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A model with `SkeletonControl` is needed for this recipe, and it's recommended
    that you be familiar with its setup. At the time of writing this recipe, the resident
    monkey, Jaime, is used.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要一个带有`SkeletonControl`的模型，并且建议您熟悉其设置。在编写此配方时，使用的居民猴子是Jaime。
- en: This recipe uses an experimental feature that at the time of writing this is
    not part of a core build. To use it, you can build jMonkeyEngine yourself from
    the sources. You can also get it by enabling nightly builds. Refer to [Appendix](apa.html
    "Appendix A. Information Fragments"), *Information Fragments,* to find out how
    to change this setting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用一个实验性功能，在编写此配方时，它不是核心构建的一部分。要使用它，您可以自己从源代码构建jMonkeyEngine。您也可以通过启用夜间构建来获取它。请参阅[附录](apa.html
    "附录 A. 信息片段")，*信息片段*，了解如何更改此设置。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to get the basic IK functionality:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以获取基本IK功能：
- en: Let's begin by creating a new class that extends `AbstractControl`, and define
    a list that will contain the bones we want to use as tip bones.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的类，该类扩展了`AbstractControl`，并定义一个将包含我们想要用作尖端骨骼的骨骼列表。
- en: 'In the `setSpatial` method, we add both the feet and toe bones to the list.
    We also supply some values that `KinematicRagdollControl` should work with when
    applying the IK and tell it which bones to work with, as shown in the following
    code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setSpatial`方法中，我们将脚和脚趾骨骼添加到列表中。我们还提供了一些`KinematicRagdollControl`在应用IK时应使用的值，并告诉它要使用哪些骨骼，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a method called `sampleTargetPositions` that goes through each of
    our targets and finds a position the control should try to reach, as shown in
    the following code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`sampleTargetPositions`的方法，遍历我们的每个目标并找到一个控制应该尝试达到的位置，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, in the created method, we call `KinematicRagdollControl` and tell
    it to switch to the Inverse Kinematics mode:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在创建的方法中，我们调用`KinematicRagdollControl`并告诉它切换到逆运动学模式：
- en: '[PRE37]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To make it reusable, we use the `setEnabled` method to clear things up when
    the control is not in use; we make it apply IK when it''s enabled again:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其可重用，我们使用`setEnabled`方法在控制未使用时清除一些事情；我们使其在再次启用时应用IK：
- en: '[PRE38]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The list we defined contains the bones that we want to have at the end of the
    chain. These are the bones that the control will try to get as close to the target
    position as possible. To get the feet at a suitable angle, we not only need the
    feet but also the toe bones. By trying to align both the feet and the toe bones,
    we get a better approximation of the ground below.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的列表包含我们希望在链末尾的骨骼。这些是控制将尝试尽可能接近目标位置的骨骼。为了使脚处于合适的角度，我们不仅需要脚，还需要脚趾骨骼。通过尝试对脚和脚趾骨骼进行校准，我们得到对地面下方更好的近似。
- en: Unlike most of our controls, we don't actually do anything in the `controlUpdate`
    method. This is because the actual alignment is passed on to `KinematicRagdollControl`.
    Instead, we do a check each time the control is enabled and see what positions
    it should try to reach.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的大多数控件不同，我们在`controlUpdate`方法中实际上并没有做任何事情。这是因为实际的校准是通过`KinematicRagdollControl`传递的。相反，我们每次控制被启用时都会进行检查，看看它应该尝试达到哪些位置。
- en: For each of the tip bones, we shoot a ray straight up, using an offset to start
    some way below the ground. The reason we don't just use the bones' position and
    check below it is because we can't be sure that the model is completely above
    the ground. Animations might very well push body parts inside the ground, and
    if we then shot a ray downwards, we wouldn't hit what we want.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个末端骨骼，我们直接向上发射一条射线，使用偏移量从地面下方某处开始。我们不直接使用骨骼的位置并检查其下方的原因是因为我们无法确定模型是否完全在地面之上。动画可能会将身体部分推入地面，如果我们向下发射射线，我们就不会击中我们想要的目标。
- en: Once a target position is found, we supply the bone to `KinematicRagdollControl`.
    Along with this is also an integer that defines how long the chain of bones should
    be that it can modify when trying to reach the target.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到目标位置，我们就将骨骼提供给`KinematicRagdollControl`。此外，还有一个整数，它定义了在尝试达到目标时可以修改的骨骼链的长度。
- en: There are some more values we supply to `KinematicRagdollControl`. The `IKThreshold`
    value is the distance from the target point where it is okay for it to stop trying.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为`KinematicRagdollControl`提供了一些其他值。`IKThreshold`值是指目标点停止尝试的距离。
- en: '`LimbDampening` can be used to effect how much a bone should move in relation
    to others. Imagine we''re stretching out for something on our desk. Our forearms
    are most likely to perform bigger movements (rotation-wise) than our upper arms.
    If `limbDampening` is lower than 1.0, the bones higher up in the chain (and likely
    bigger) will move less with each update than those closer to the tip bone.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`LimbDampening`可以用来影响骨骼相对于其他骨骼的运动程度。想象一下，我们正在伸手去拿桌子上的东西。我们的前臂可能比我们的上臂进行更大的运动（旋转）。如果`limbDampening`小于1.0，那么在链条中位置更高（可能更大）的骨骼在每次更新时移动的幅度会比接近末端骨骼的骨骼小。'
- en: '`IKRotSpeed` defines the rotation steps the control should apply with each
    turn. A higher value means it''ll get closer quicker, but it also means the margin
    of error becomes higher.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`IKRotSpeed`定义了控制每次转动时应应用的旋转步数。值越高，它就越快接近目标，但也意味着误差范围更高。'
- en: All these values require tweaking to get them right for the application. Implementation
    is just the first step. The `KinematicRagdollControl` method also needs some setting
    up, most importantly, it needs to know the bones it should be able to control.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些值都需要调整才能适用于应用程序。实现只是第一步。`KinematicRagdollControl`方法还需要一些设置，最重要的是，它需要知道它应该能够控制的骨骼。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we've implemented the recipe thus far, we can see that the result is not
    what we expected. On wobbly legs, resembling rubber or cooked spaghetti, our character
    slowly adjusts to the ground below it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到目前为止已经实现了这个配方，我们可以看到结果并不是我们预期的。在摇摇晃晃的腿上，类似于橡胶或煮熟的意大利面，我们的角色缓慢地调整到下面的地面。
- en: The most disturbing thing is probably that the legs seem to go in any direction.
    Fortunately, this can be remedied with some tweaking. The `KinematicRagdollControl`
    function has a method called `setJointLimit`, which does what it says. It can
    set the limits to how much rotation can be applied on each axis of a bone. Getting
    it right for all the bones will take some time though.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人烦恼的可能就是腿似乎可以向任何方向移动。幸运的是，这可以通过一些调整来修复。`KinematicRagdollControl`函数有一个名为`setJointLimit`的方法，它做了它所说的。它可以设置骨骼每个轴上可以应用的旋转限制。但是，要为所有骨骼设置正确，可能需要一些时间。
