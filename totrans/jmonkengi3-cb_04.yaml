- en: Chapter 4. Mastering Character Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Previewing animations in SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an animation manager control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the animation control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling jump animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom animation – leaning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a subanimation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lip syncing and facial expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eye movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location-dependent animation – edge check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverse kinematics – aligning feet with ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll take a closer look at skeleton-based animations. These
    are central features in many games, and having a good framework can save a lot
    of time (and money) in a project.
  prefs: []
  type: TYPE_NORMAL
- en: For those who are completely new to the subject of animations, it's recommended
    that you have a look at the jMonkeyEngine tutorials and Hello Animation in particular
    at [http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation](http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation).
  prefs: []
  type: TYPE_NORMAL
- en: Previewing animations in SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before digging into the code, let's just briefly see how we can use SDK to see
    the animations that are supplied with a model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to see the animations that are supplied with the
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the model in the **Projects** window. Right-click on it and select **Edit**
    in **SceneComposer** and you will get the following screenshot:![How to do it...](img/6478OS_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **SceneExplorer** window and open the model's node. Look for **AnimControl**
    as seen in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **AnimControl** window and you will see the list of animations that
    are available. Then, navigate to the **Properties** window to select any of the
    animations and play them in the model, as shown in the following screenshot:![How
    to do it...](img/6478OS_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **SceneExplorer** window not only shows all the spatials that belong to
    a node, but also the controls that are attached to any spatial. Apart from adding
    new controls, it's also possible to change them. In the case of `AnimControl`,
    it's possible to set the current animation so it is played instantly. To stop
    playing it, we can select `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an animation manager control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a control that will handle the animations of a character. It
    will follow jMonkeyEngine's control pattern and extend `AbstractControl`. We won't
    actually use most of the functions of `AbstractControl` right away, but it's a
    neat way to offset some of the code from a possible `Character` class. It will
    also be easy to add functionalities later on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a control that will handle the animations of a character, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `CharacterAnimationManager` and have it extend `AbstractControl`.
    This class should also implement `AnimEventListener`, which `AnimControl` uses
    to tell our class when animations have finished playing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re going to map Jaime''s animations into an enum. This is so we don''t
    have to do a lot of string comparisons. While we''re at it, we''ll add some basic
    logic to the enum as well. The name of the animation, whether the animation should
    loop or not, and the time `AnimControl` should take to blend to a new animation
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need two fields as well: an `AnimControl` field called `animControl` and
    an `AnimChannel` called `mainChannel`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We set these in the `setSpatial` method, as shown in the following code. Don''t
    forget to add the class to the `AnimControl` field as a listener, or we won''t
    receive any calls when animations are finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a new method called `setAnimation` in the following code. Inside
    this, we set the supplied animation to be `mainChannel` as the current one if
    it''s not the same as the one playing now. We also set `loopMode` according to
    how it''s defined in the enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onAnimCycleDone` method, we create a control so that all animations
    that don''t loop return to the idle animation, with the exception of `JumpStart`,
    which should switch to `Jumping` (as in midair) as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s all that''s needed to create a class that manages animations! To set
    this up from an application, we just need to load a model in the application and
    add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AnimControl` class is responsible for playing and keeping track of the
    animations. `AnimChannel` has a list of `Bones` that the animation should affect.
  prefs: []
  type: TYPE_NORMAL
- en: Since we let the enum decide the animation parameters for us, we don't need
    much code in the `setAnimation` method. We do however need to make sure we don't
    set the same animation if it is already playing or it could get stuck, repeating
    the first frame in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `onAnimCycleDone` method is called from `AnimControl` whenever an animation
    reaches the end. Here, we decide what will happen when this occurs. If the animation
    is not looping, we must tell it what to do next. Playing the idle animation is
    a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: We also have one special case. If you look at the animation list, you will notice
    that Jaime's jump animation is split into three parts. This is to make it easier
    to handle jumps of different lengths or the falling animation.
  prefs: []
  type: TYPE_NORMAL
- en: We will tell `AnimControl` to change the animation to a jumping action once
    `JumpStart` is done. We never change to `JumpEnd` once the jumping action has
    taken place however. Instead, this should be called from elsewhere when Jaime
    hits the ground after he jumps. How this is measured is dependent on the game
    logic, but since we're using the `Control` pattern, we could use `controlUpdate`
    to check Jaime's whereabouts.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the animation control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we built the basics for an animation by managing the
    `Control` class. This would be fine for many types of games, but for a game where
    a character is in focus, let's say an FPS, we would want a more detailed control.
    This is where the concept of `AnimChannel` comes in handy. `AnimChannel` is a
    way of dividing a skeleton into different groups of bones and applying an animation
    only to them. As we will find out in this recipe, this means we can have different
    animations playing on different parts of the body at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applying animations only to certain channels can help reduce the workload tremendously
    for a character-focused game. Let's say we're making an FPS or RPG where the character
    can wield a number of different items and weapons, both one– and two–handed. Making
    full-body animations for all the combinations, including standing, walking, running,
    and more, is not feasible. If instead, you are able to apply the weapon animation
    only to the upper body and a walk animation to the lower body, you get a lot more
    freedom.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will also describe some other tricks that might help in developing
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can have different animations playing on different parts of the body at
    the same time by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we'll implement the `ActionListener` and `AnalogListener` interfaces
    in our animation's `manager` class. This will allow us to receive input directly
    from an input-handling class and decide which animations to play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we define two `AnimChannels`: one for the upper body called `upperChannel`
    and one for the lower called `lowerChannel`. We also create a `Channel` enum to
    easily choose whether to play an animation in a separate channel or the whole
    body, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The SceneExplorer can be used to find suitable bones as shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_04_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the `setSpatial` method, we create the upper and lower channels in `AnimControl`.
    We let `AnimChannel` add all the bones recursively using the `addFromRootBone`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same method, add this instance as `AnimEventListener` to `AnimControl`
    to receive events when animations change or cycle, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be able to set specific animations from other classes, we add a method called
    `setAnimation`, which takes an animation and `Channel` (enum) as the input, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onAction` method, the control can receive input directly from `InputListener`
    and apply the logic on its own before setting the animation, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to test the concept of `AnimChannels`, we can implement `ActionListener`
    in our `SimpleApplication` instance and bind some keys to it, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an example of how the concept of `AnimChannels` can be used to create new
    animations out of combined ones, create a new application and set the walk animation
    on Jaime's `lowerChannel` while applying the jumping animation on `upperChannel`.
    Jaime will now commence a zombie walk impression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see that the `Animation` enum has had a field called `key` added. This
    is not necessary but is part of a way to not have to hard-code animation names.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `addFromRootBone` method, the channel will automatically add all
    the bones recursively, starting with the bone that is supplied first. After adding
    spine to `upperChannel`, it will continue down the chain, adding shoulders, neck,
    arms, and hands, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/6478OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Different animations applied to the upper and lower parts of the body
  prefs: []
  type: TYPE_NORMAL
- en: Since we implemented `ActionListener`, there's also an `onAction` method in
    the class, which can receive an input from a number of external sources, such
    as `InputListener`. This also means it can apply logic by itself before deciding
    on what to play and not simply being an animation-playing control. We can recognize
    the pattern used here from the `GameCharacterControl` class from [Chapter 2](ch02.html
    "Chapter 2. Cameras and Game Controls"), *Cameras and Game Controls*.
  prefs: []
  type: TYPE_NORMAL
- en: By supplying a `Properties` file that maps the animation names, it's possible
    to use models with different naming conventions. It's also easier for a designer
    or artist to try out a number of different animations without consulting a programmer
    to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling jump animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll show how the jumping animation can be handled in the animation
    manager control from previous recipes. Why does this require its own recipe? Animation-wise,
    jumping is usually a set of sequenced animations. If we look at Jaime, for example,
    there's `JumpStart`, `Jumping`, and `JumpEnd`. Normally, sequenced animations
    can be handled in the `onAnimCycleDone` method; when one animation ends, it can
    trigger the next. Jumping is different though since the middle jumping animation
    is indefinite and is on a loop. How long it plays depends on how long the character
    is in the air, which is driven by the gameplay or its physics.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can handle jumping animations by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we''ll need to add two more Booleans to our animation control: `jumpStarted`
    and `inAir`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We trigger the first part of the animation in the `onAction` method, as shown
    in the following code. The `jumpStarted` Boolean is used to let the class know
    that other animations should not start while the character is the jumping state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `onAnimCycleDone` method should switch animations back to the jumping action
    once `JumpStart` has finished playing. We also set `inAir` to `true`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `controlUpdate` method is suitable to check whether the character has landed
    after jumping (or falling). We check this directly in `BetterCharacterControl`
    and change the animation if it is back on the ground, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation relies on the listener pattern where this control receives
    a notification of user actions from an external input class. In this project,
    we have a separate class that controls the character.
  prefs: []
  type: TYPE_NORMAL
- en: This `onAnimCycleDone` method is called by the `AnimControl` method when an
    animation has finished with one cycle (both looping and non-looping animations).
    Normally, when an animation ends, we'll want to switch to the idle animation to
    stop it from freezing. When `JumpStart` is finished, however, the character is
    most likely in midair and thus switches to a suitable looping animation. The `inAir`
    Boolean is used so the class knows it should start checking for when the character
    lands again.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the size of a project, the control class for the character and
    this animation-managing class might be merged into one. This should make some
    things easier, while the class itself might get bulky as more functions are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The `controlUpdate` class is called automatically with every tick, and here
    we can see whether the character is still airborne. In this implementation, `BetterCharacterControl`
    is used, and it has a method to see whether it is on ground. Jaime has a `JumpEnd`
    animation, but idle seems to work better with some blending.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom animation - leaning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom animation is the concept of directly manipulating the bones of a character's
    skeleton to create animations. We will explore this by making a control that can
    be used together with [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*. Together with this recipe, leaning can be used on
    characters other than the player and in networked games.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom animation - leaning](img/6478OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jaime leaning to the left
  prefs: []
  type: TYPE_NORMAL
- en: 'As in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras
    and Game Controls*, we have two ways to handle leaning: one is by using a key
    to lean toward the left and another to lean toward the right. The second one is
    to press a button and lean in any direction using the mouse, which is more common
    in computer games.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The control we are going to build will share some code with the recipe from
    [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game
    Controls*. The shared code will be explained there to save space, and it will
    most likely be used in tandem with this recipe, so being familiar with it is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating a new class that extends `AbstractControl` and implements
    `Action-` and `AnalogListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we define some values that will help us control the leaning. The `leanValue`
    is the current amount of leaning that is applied. There needs to be a limit on
    how much the character can lean, which is set in `maxLean`. For this example,
    it's 45 degrees in either direction. The two Booleans `leanLeft` and `leanRight`
    define whether we're currently leaning in either direction using keys, and `leanFree`
    defines whether the mouse is used. The `leaningBone` is the bone that we'll modify,
    and we'll also store the bone's original rotation in `boneRotation` and use it
    as a base when leaning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the control is added to a spatial, we need to look for a bone to apply
    the leaning to. We select spine as `leaningBone`, and clone its current rotation,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `onAction` method will receive the input and should set the controlling
    Booleans, namely, `leanLeft`, `leanRight`, and `leanFree`. The `onAnalog` option
    receives the mouse input when `leanFree` is active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `controlUpdate` method, we check to see whether any leaning is to be
    applied, first to the left and then similarly to the right. If `leanValue` is
    near `0f`, we will round it off to `0`. If this happens, we give the control back
    to `AnimControl`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `lean` method, which applies the leaning to the bone, the first thing
    we do is clamp the value to be inside the allowed threshold. Next, we call `setUserControl`
    on the bone to let it know that it shouldn''t apply animations before creating
    a new `Quaternion` class based on the original rotation, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When selecting a bone to apply the leaning to, it should be close to the base
    of the upper body of the character. On Jaime, the spine is a suitable bone.
  prefs: []
  type: TYPE_NORMAL
- en: When `Bone.setUserControl(true)` is called, we tell the bone that no animations
    should be applied and that we will handle any rotation or translation manually.
    This has to be called before we set the rotation, or an exception will be thrown.
    Likewise, when we're done, we need to call `setUserControl(false)` to give the
    control back to the user (or no animation would be played).
  prefs: []
  type: TYPE_NORMAL
- en: Manually controlling bones is powerful and can be useful for many different
    applications, such as precision aiming and head tracking. Getting everything right
    can be tricky, however, and most likely it's not something that you will do frequently.
  prefs: []
  type: TYPE_NORMAL
- en: This class can be used separately from [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Controls*, or they can be merged together.
    The benefit of having them separate is that we can also apply them separately.
    For example, the player's own character in a FPS won't need this control since
    you would never see it lean anyway. In this case, it's all about the camera. However,
    other players in the same (networked) FPS will need it, as would AI enemies who
    might use the same character control class.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about how `leanValue` is used and applied, have a look at the
    *Leaning around corners* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and
    Game Controls"), *Cameras and Game Controls*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we're using an imported model and don't have access to a list of the bones,
    how do we know which bone to use? One simple way is to open the model in **Scene
    Explorer**. In **SkeletonControl**, we can see all the bones the character has
    but not their relative position on the model. By right-clicking and selecting
    **Get attachment node**, a new node will be created; also, by selecting it, we
    can see where it's located on the model. For more information on attachment nodes,
    have a look at the *Retrieving an attachment node* recipe of [Chapter 1](ch01.html
    "Chapter 1. SDK Game Development Hub"), *SDK Game Development Hub*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a subanimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''re going to use SceneComposer to create subanimations.
    As the name implies, they''re derived from an animation. Subanimations can be
    a good way to squeeze some extra out of stock models that don''t have the exact
    animations you want, or if the modeler has gone home for the day. In this particular
    application, we''ll prepare for the next recipe, which is about lip syncing. The
    **Extract sub animation** window in SDK looks, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a subanimation](img/6478OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest caveat when creating subanimations is that the jMonkeyEngine API
    uses relative time when interacting with models, while subanimations are created
    on a frame basis. So, the easiest way to find out which frames to extract is to
    open the model in an external editor and look at it in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extracting a subanimation can be done by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With the model opened in the Scene Composer, we expand **AnimControl**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can see all the animations that are currently available. We right-click
    on an animation we would like to create a subanimation out of and choose the option,
    **Extract Sub-animation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a start and end frame and it's done. The new animation is now available
    in the **AnimControl** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An animation in jMonkeyEngine consists of a number of `BoneTracks`. Each of
    these has an array of floats with the times for the animations, an array of `Vector3f`
    with the positions of the bones, array of Quaternions with rotations, and another
    array of `Vector3f's` with scales. Each instance of the arrays contains information
    about a frame.
  prefs: []
  type: TYPE_NORMAL
- en: A subanimation is a copy of an excerpt from all the `BoneTracks` in the parent
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: Lip syncing and facial expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe handles two important parts of making characters seem alive and
    sentient. Technically, they can be handled using `AnimChannel`, but they still
    deserve their own mention as they have some special requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Lip syncing revolves around something called **Phoneme**, which is the distinct
    shape the mouth takes when making certain sounds. The number of phonemes a character
    has varies according to different needs, but there is a basic set that is used
    to create believable mouth movements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll use jMonkeyEngine's **Cinematics** system to apply them in sequence
    and have the character speak (mime) a word. Cinematics is jMonkeyEngine's scripting
    system, and it can be used both to create in-game-scripted events and cutscenes.
    It is covered in more depth in [Chapter 9](ch09.html "Chapter 9. Taking Our Game
    to the Next Level"), *Taking Our Game to the Next Level*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll follow the control pattern in this recipe, and control can be merged into
    another animation controller or be kept alone.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a model with phoneme animations ready or creating them in an external
    modeling program is preferred. It's perfectly all right if the animations are
    one-frame static expressions.
  prefs: []
  type: TYPE_NORMAL
- en: If the previous options are not available, one method is to use the SDK's functionality
    to create subanimations. A version of Jaime with phoneme animations is supplied
    with the project for the sake of this recipe. For those interested in going through
    the process of creating subanimations themselves, there is a list of the ones
    used in the *Enabling nightly builds* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Fragments*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the required functionalities can be implemented in a single class by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To start off, we create a new class called `ExpressionsControl` that extends
    `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, we add `AnimControl` named `animControl`, one `AnimChannel` called
    `mouthChannel`, and another `AnimChannel` called `eyeBrowChannel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define an enum to keep track of the phonemes that the controller supports.
    These are some of the most common ones, plus a `RESET` option for a neutral mouth
    expression, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create another enum to set the expressions of the eyes, which is a simple
    way of adding emotions to what the character says, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setSpatial` method, we create `AnimChannel` for mouth animations and
    one for the eyes, then we add suitable bones to each of these, as shown in the
    following code. The list of bones available can be seen in `SkeletonControl` in
    `SceneComposer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the animations we'll use might just be one or a few frames each, we can
    set `LoopMode` to `Loop` or `Cycle`. The speed has to be higher than `0` or blending
    won't work. Set these for both `AnimChannels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we have two setter methods to directly set an expression or phoneme in
    the control. The naming convention might differ depending on the assets, and it''s
    good to have a small blending value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can reuse any test class we might have from other recipes and just apply
    some new code to it as seen in the following code snippet. We set up a simple
    cinematic sequence that makes Jaime say (or mime) *Hello* and look happy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When this recipe was written, the following `AnimationEvent` constructor did
    not exist and `AnimChannels` were not applied properly. A patch has been submitted
    but may not have made it into a stable build. If required, the patch can be found
    in the *The AnimationEvent patch* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Gathering*. It can also be acquired by turning on nightly
    builds in the SDK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technical principles behind the phonemes are not that different from animating
    other parts of the character. We create `AnimChannels`, which handles different
    sets of bones. The first tricky bit is to organize the channels if you want to
    be able to control different parts of the body at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline for how to apply the phonemes can also be difficult. The first
    step will be to not set them directly in the code. It's not implausible that changing
    the expression of the character could be called directly from the code on certain
    events. Doing so for each phoneme in a sentence would be very cumbersome. Using
    the cinematics system is a good start as it would be relatively simple to write
    a piece of code that parses a text file and creates a cinematic sequence from
    it. Timing is really crucial, and it can take a lot of time to get the movements
    synced with sound. Doing it in a format that allows you to have a quick iteration
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: Another more complex way would be to build up a database that maps words and
    phonemes and automatically applies them in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The absolutely simplest approach is to not really care about lip syncing and
    just apply a moving mouth animation whenever the character speaks.
  prefs: []
  type: TYPE_NORMAL
- en: Eye movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eye contact is an important factor to make characters feel alive and aware
    of yours and other things'' presence. In this chapter, we''ll make a control that
    will follow a spatial with its eyes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Eye movement](img/6478OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Eye tracking can be implemented in a single control using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating a new class called `EyeTrackingControl` that extends `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It needs two `Bone` fields: one called `leftEye` and another called `rightEye`.
    Furthermore, we should add a spatial called `lookAtObject` and a related `Vector3f`
    called `focusPoint`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `setSpatial` method, we find and store the bones for `leftEye` and `rightEye`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need a method to set `lookAtObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this done, we add most of the other functionalities to the `controlUpdate`
    method. First of all, we need to take control of the bones or we won''t be able
    to modify their rotation, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to establish the `lookAtObject` position that is relative to
    the eyes. We do this by converting the position to model space and storing it
    in `focusPoint`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Subtracting the eye position from `Vector3f` gives us the relative direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new Quaternion and have it look in the direction of the `direction`
    vector. We can apply this on our eyes after modifying it a bit as its 0-rotation
    is up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we apply it by using `setUserTransformsWorld`. Finally, we give the control
    of the bones back to the system using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The actual code is a fairly straightforward trigonometry, but knowing what values
    to use and the flow of doing it can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Once the class receives an object to look at, it subtracts the model's `worldTranslation`
    from `lookAtObjects` so they end up in a coordinate system that is relative to
    the model's origo point also called **modelspace**.
  prefs: []
  type: TYPE_NORMAL
- en: Using `setUserTransformsWorld` also sets the position, but since we supply its
    current `modelSpacePosition`, no change will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the direction of each eye should be calculated separately for the
    result to be entirely correct.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, the character has a very intent stare at the camera. This is an improvement,
    but it can be made more lifelike. Something that may not be so obvious is that
    we rarely look at the same point all the time even if we look at the same object.
    We can emulate this behavior by adding a random bit of flickering to the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By introducing these three fields, we have a base for what we want to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code goes in the middle of the `controlUpdate` method, right after
    calculating the direction. What we do is we increase `flickerTime` until it reaches
    0.5f (note that this is not in seconds since we apply a random number). Once this
    happens, we randomize `flickerDirection` based on `flickerAmount` and reset `flickerTime`.
  prefs: []
  type: TYPE_NORMAL
- en: With each consecutive update, we will apply this to the calculated direction
    and slightly offset the focus point.
  prefs: []
  type: TYPE_NORMAL
- en: Location-dependent animation – edge check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In certain games, players traverse dangerous areas where a fall off from a ledge
    could lead to their deaths. Sometimes, in these games, the player is not meant
    to fall off and their movement is restricted when they are close, or the player
    gets an extra warning before they plummet.
  prefs: []
  type: TYPE_NORMAL
- en: The control we'll develop can be used for any of those things, but since this
    chapter is about animations, we'll use it to play a special animation when the
    player gets too close to the edge.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe will use similar patterns that have been used before in this chapter
    and we'll also use the animation manager control from earlier in the chapter.
    Any animation control will be fine to use, but it should have separate channels
    for the upper and lower parts of the body.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can implement almost everything we need in a single class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by creating a class called `EdgeCheckControl`, which extends `AbstractControl`
    and contains the following fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the nine rays that will be used for collision detection. In the `setSpatial`
    method, we instantiate them and aim them downwards, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `controlUpdate` method, we begin by placing one of the rays at the center
    of the character, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We step around the character, placing the remaining rays in a circular shape.
    For each, we see whether it collides with something using the `checkCollision`
    method. If it doesn''t, we don''t need to check the rest and can exit the loop
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the last step in this method, we call the animation manager and tell it
    to play or stop playing the near-edge animation, as shown in the following code.
    We do this based on whether all the collisions have been detected or not, making
    sure we only send any change in state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switching to our animation manager class, we modify it accordingly. The state
    is stored here so it can be used to see what other animations are allowed to be
    played, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With each update, the nine rays we create are placed in a circle around the
    character, with one in the center.
  prefs: []
  type: TYPE_NORMAL
- en: They will check for collisions with a surface below them. If any of them (this
    might be changed to two or three) does not hit something within `okDistance`,
    it will be reported as the character being close to a dangerous edge.
  prefs: []
  type: TYPE_NORMAL
- en: The `okDistance` has to be set to something suitable, higher than a step on
    a stair, probably at a height where the player could take damage.
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, the animation manager will be called with the `NearEdge`
    action set to `true`. This will apply the jumping animation (wild flaying of the
    arms) to the upper body of the character while still allowing other animations
    to be played on the lower part.
  prefs: []
  type: TYPE_NORMAL
- en: The `NearEdge` Boolean is used to make sure that we only send the call to the
    animation manager once.
  prefs: []
  type: TYPE_NORMAL
- en: When doing collision checks, one should be careful about the amount and shape
    of the objects that are being collided. If the world is large or constructed from
    complex shapes (or even worse, if it has `MeshCollisionShape`), we should try
    to find optimized ways of applying the method. One way could be to separate the
    world into parts and have an auxiliary method to select which part to collide
    against. This method might use `contains` on `BoundingVolume` to see the part
    the player is located in.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning feet with ground – inverse kinematics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inverse kinematics is now a common part of animation systems in games and is
    a topic that might cover a chapter on its own. In this recipe, we'll look at placing
    a character's feet in accordance to the ground below. This is useful where an
    animation would otherwise place them in the air or on sloped ground.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, animations work according to forward kinematics; that is, when a bone
    near the root of the skeleton rotates, it affects the bones further down the chain.
    As the name implies, Inverse Kinematics starts at the other end.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we strive toward a desired position for the tip of a chain of bones, and
    bones further up the chain try to align themselves to suit this.
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward implementation of this rotates the bones by a small
    amount on all the axes. It then checks which of the rotations brings the tip closest
    to the desired position. This is repeated for all the bones in the chain and iterated
    until it has come close enough.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A model with `SkeletonControl` is needed for this recipe, and it's recommended
    that you be familiar with its setup. At the time of writing this recipe, the resident
    monkey, Jaime, is used.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe uses an experimental feature that at the time of writing this is
    not part of a core build. To use it, you can build jMonkeyEngine yourself from
    the sources. You can also get it by enabling nightly builds. Refer to [Appendix](apa.html
    "Appendix A. Information Fragments"), *Information Fragments,* to find out how
    to change this setting.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to get the basic IK functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by creating a new class that extends `AbstractControl`, and define
    a list that will contain the bones we want to use as tip bones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `setSpatial` method, we add both the feet and toe bones to the list.
    We also supply some values that `KinematicRagdollControl` should work with when
    applying the IK and tell it which bones to work with, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a method called `sampleTargetPositions` that goes through each of
    our targets and finds a position the control should try to reach, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the created method, we call `KinematicRagdollControl` and tell
    it to switch to the Inverse Kinematics mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make it reusable, we use the `setEnabled` method to clear things up when
    the control is not in use; we make it apply IK when it''s enabled again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list we defined contains the bones that we want to have at the end of the
    chain. These are the bones that the control will try to get as close to the target
    position as possible. To get the feet at a suitable angle, we not only need the
    feet but also the toe bones. By trying to align both the feet and the toe bones,
    we get a better approximation of the ground below.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most of our controls, we don't actually do anything in the `controlUpdate`
    method. This is because the actual alignment is passed on to `KinematicRagdollControl`.
    Instead, we do a check each time the control is enabled and see what positions
    it should try to reach.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the tip bones, we shoot a ray straight up, using an offset to start
    some way below the ground. The reason we don't just use the bones' position and
    check below it is because we can't be sure that the model is completely above
    the ground. Animations might very well push body parts inside the ground, and
    if we then shot a ray downwards, we wouldn't hit what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Once a target position is found, we supply the bone to `KinematicRagdollControl`.
    Along with this is also an integer that defines how long the chain of bones should
    be that it can modify when trying to reach the target.
  prefs: []
  type: TYPE_NORMAL
- en: There are some more values we supply to `KinematicRagdollControl`. The `IKThreshold`
    value is the distance from the target point where it is okay for it to stop trying.
  prefs: []
  type: TYPE_NORMAL
- en: '`LimbDampening` can be used to effect how much a bone should move in relation
    to others. Imagine we''re stretching out for something on our desk. Our forearms
    are most likely to perform bigger movements (rotation-wise) than our upper arms.
    If `limbDampening` is lower than 1.0, the bones higher up in the chain (and likely
    bigger) will move less with each update than those closer to the tip bone.'
  prefs: []
  type: TYPE_NORMAL
- en: '`IKRotSpeed` defines the rotation steps the control should apply with each
    turn. A higher value means it''ll get closer quicker, but it also means the margin
    of error becomes higher.'
  prefs: []
  type: TYPE_NORMAL
- en: All these values require tweaking to get them right for the application. Implementation
    is just the first step. The `KinematicRagdollControl` method also needs some setting
    up, most importantly, it needs to know the bones it should be able to control.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we've implemented the recipe thus far, we can see that the result is not
    what we expected. On wobbly legs, resembling rubber or cooked spaghetti, our character
    slowly adjusts to the ground below it.
  prefs: []
  type: TYPE_NORMAL
- en: The most disturbing thing is probably that the legs seem to go in any direction.
    Fortunately, this can be remedied with some tweaking. The `KinematicRagdollControl`
    function has a method called `setJointLimit`, which does what it says. It can
    set the limits to how much rotation can be applied on each axis of a bone. Getting
    it right for all the bones will take some time though.
  prefs: []
  type: TYPE_NORMAL
