<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting to Know Implicits and Type Classes</h1>
                </header>
            
            <article>
                
<p class="p1">We are already familiar with two cornerstones of Scala—its type system and first-class functions. Implicits is the third one. Implicits enable elegant designs and probably no state-of-the-art Scala library is possible without them.</p>
<p class="p1">In this chapter, we will start with a systematic overview of different types of implicits and recap the implicit scope resolution rules. After taking a short look at context bounds, we'll move on to type classes, the central implementation mechanism that's utilized in modern functional programming libraries.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Types of implicits</li>
<li>Context bounds</li>
<li>Type classes</li>
<li>Type classes and recursive resolution</li>
<li>Type class variance</li>
<li>Implicit scope resolution rules</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Before we begin, make sure you have the following installed:</p>
<ul>
<li>JDK 1.8+</li>
<li>SBT 1.2+</li>
</ul>
<p>The source code for this chapter is available under our GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter04</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Types of implicits</h1>
                </header>
            
            <article>
                
<p>In Scala, there are a couple of different mechanisms hidden behind the keyword <kbd>implicit</kbd>. This list contains implicit parameters, implicit conversions, and implicit classes. They have slightly different semantics and it is important to know in which situations which one is the best fit. Each of these three types deserves a brief overview.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit conversions</h1>
                </header>
            
            <article>
                
<p class="mce-root">The first type of implicit in our list is implicit conversion. They allow you automatically to convert values of one type into values of another type. This implicit conversion is defined as a one-argument method that's marked with the <kbd>implicit</kbd> keyword. Implicit conversions are considered to be a somewhat controversial language feature (we will take a look at why in a moment), so we need to enable them <span>explicitly </span>with a compiler flag or by importing the corresponding language feature:</p>
<pre><span>import </span>scala.language.<span>implicitConversions</span></pre>
<p><kbd>Predef</kbd> contains a number of implicit conversions for Java-specific classes and primitives. For example, this is how <em>autoboxing</em> and <em>autounboxing</em> is defined for Scala's <kbd>Int</kbd> and Java's <kbd>Integer</kbd>:</p>
<pre><span>// part of Predef in Scala<br/></span><span>implicit def int2Integer(x: Int): java.lang.Integer = x.asInstanceOf[java.lang.Integer]<br/>implicit def Integer2int(x: java.lang.Integer): Int = x.asInstanceOf[Int]<br/></span></pre>
<p>These two methods are used by the compiler in cases where a value of type <kbd>Int</kbd> is expected, but the value with the type <kbd>java.lang.Integer</kbd> is provided and vice versa. Assuming that we have a Java method returning a random <kbd>Integer</kbd>, we would have implicit conversion applied in the following scenario:</p>
<pre><span>val </span><span>integer</span>: Integer = RandomInt.<span>randomInt</span>()<br/><span>val </span><span>int</span>: Int = math.<span>abs</span>(<span>integer</span>)</pre>
<p><kbd>math.abs</kbd> expects <kbd>Int</kbd>, but an <kbd>Integer</kbd> is provided, so the compiler applies the implicit conversion <kbd>Integer2int</kbd>.</p>
<p>Identical principles apply to the return types in the same way that they apply to the parameters. If the compiler finds a method call on a type that does not have this method, it will look for an implicit conversion so that the original return type can be converted to the type that suits this method. This allows you to implement a pattern called <strong>extension methods</strong>. A <kbd>String</kbd> type in Scala is a perfect example. It is defined as a type alias for Java's <kbd>String</kbd>:</p>
<pre><span>type </span><span>String </span>= java.lang.String</pre>
<p>But it is possible to call methods such as <kbd>map</kbd>, <kbd>flatMap</kbd>, <kbd>append</kbd>, <kbd>prepend</kbd>, and many others, which are not defined in the original <kbd>String</kbd>. This is achieved by converting a <kbd>String</kbd> into <kbd>StringOps</kbd> every time such a method is called:</p>
<pre><span>@inline </span><span>implicit def </span>augmentString(x: <span>String</span>): StringOps = <span>new </span>StringOps(x)<br/><br/>scala&gt; "I'm a string".flatMap(_.toString * 2) ++ ", look what I can do"<br/>res1: String = II''mm aa ssttrriinngg, look what I can do</pre>
<p>The implicit conversion can be type-parameterized, but cannot be nested or directly chained. The compiler will only apply one implicit conversion at a time:</p>
<pre><span>case class </span>A[<span>T</span>](a: <span>T</span>)<br/><span>case class </span>B[<span>T</span>](a: <span>T</span>)<br/><br/><span>implicit def </span>a2A[<span>T</span>](a: <span>T</span>): A[<span>T</span>] = <span>A</span>(a)<br/><span>implicit def </span>a2B[<span>T</span>](a: <span>T</span>): B[<span>T</span>] = <span>B</span>(a)<br/><br/><span>def </span>ab[<span>C</span>](a: B[A[<span>C</span>]]): Unit = <span>println</span>(a)</pre>
<p>The compiler will accept the call with <kbd>A</kbd> because of implicit conversion <kbd>t2B</kbd> being in scope, but will reject everything that is neither <kbd>A</kbd> nor <kbd>B</kbd>:</p>
<pre>scala&gt; ab(A("A"))<br/>B(A(A))<br/><br/>scala&gt; ab("A")<br/>          ^<br/>       error: type mismatch;<br/>        found : String("A")<br/>        required: B[A[?]]</pre>
<p class="mce-root"/>
<p>Sometimes, it is possible to enforce one of the conversions so that the compiler can then apply the other. Here, we tell the compiler to apply a conversion from <kbd>String</kbd> to <kbd>A[String]</kbd> by providing a type ascription. The conversion from <kbd>A</kbd> to <kbd>B[A]</kbd> then happens like it did previously:</p>
<pre>scala&gt; ab("A" : A[String])<br/>B(A(A))</pre>
<p>Quite handy, isn't it?</p>
<p>Why are implicit conversions considered disputable, then? Because sometimes they can be applied without the developer knowing that and can change semantics in unexpected ways. This can be especially bad in situations where conversions for two types<span> exist for </span><span>both directions</span> (like in our Int/Integer example<span>)</span> or when pre-existing types are involved. This classical example is based on having some implicit conversions in scope and type coercions later:</p>
<pre>scala&gt; implicit val directions: List[String] = List("North", "West", "South", "East")<br/>directions: List[String] = List(north, west, south, east)<br/>scala&gt; implicit val grades: Map[Char, String] = Map('A' -&gt; "90%", 'B' -&gt; "80%", 'C' -&gt; "70%", 'D' -&gt; "60%", 'F' -&gt; "0%")<br/>grades: Map[Char,String] = ChampHashMap(F -&gt; 0%, A -&gt; 90%, B -&gt; 80%, C -&gt; 70%, D -&gt; 60%)<br/>scala&gt; println("B" + 42: String)<br/>B42<br/>scala&gt; println(("B" + 42): String)<br/>B42<br/>scala&gt; println("B" + (42: String))<br/>java.lang.IndexOutOfBoundsException: 42<br/>  at scala.collection.LinearSeqOps.apply(LinearSeq.scala:74)<br/>  at scala.collection.LinearSeqOps.apply$(LinearSeq.scala:71)<br/>  at scala.collection.immutable.List.apply(List.scala:72)<br/>  ... 38 elided<br/>scala&gt; "B" + 'C'<br/>res3: String = BC<br/>scala&gt; "B" + ('C': String)<br/>res4: String = B70%<br/>scala&gt; "B" + (2: String)<br/>res5: String = BSouth</pre>
<p>Here, we can see two examples of this behavior: one with a semantically similar <kbd>String</kbd> plus <kbd>Int</kbd> concatenation producing different results, and another crafted in the same way but for <kbd>String</kbd> and <kbd>Char</kbd>.</p>
<p>The reason for strange results and <kbd>IndexOutOfBoundsException</kbd> is that <kbd>Map</kbd> and <kbd>List</kbd> both implement <kbd>PartialFunction</kbd>, and thus just <kbd>Function1</kbd>. In our case, it's <kbd>Int =&gt; String</kbd> for the <kbd>List</kbd> and <kbd>Char =&gt; String</kbd> for the <kbd>Map</kbd>. Both are defined as implicit, and at the moment one of both type conversions is required, the corresponding function is applied. </p>
<p>Because of this unpredictability, the use of implicit conversions is discouraged in modern Scala, though they are not removed from the language or deprecated, because a lot of existing implementations depend on them. They are mostly used to add methods to the existing classes or to add trait implementations for the new traits.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit parameters</h1>
                </header>
            
            <article>
                
<p>Implicit parameters use the same syntax as implicit conversions, but provide different functionality. They allow you to pass arguments into a function <span>automatically </span>. The definition of implicit parameters is done as a separate argument list in the definition of the function<span> with a leading <kbd>implicit</kbd> keyword</span>. Only one implicit argument list is allowed:</p>
<pre><span>case class </span>A[<span>T</span>](a: <span>T</span>)<br/><span>case class </span>B[<span>T</span>](a: <span>T</span>)<br/><span><br/>def </span>ab[<span>C</span>](name: <span>String</span>)(a: A[<span>C</span>])(<span>implicit </span>b: B[<span>C</span>]): Unit =<br/>  <span>println</span>(<span>s"</span><span>$</span>name<span>$</span>a<span>$</span>b<span>"</span>)</pre>
<p>Implicit arguments do not require any special imports or compiler options to be activated. The preceding example shows that they also can be type-parameterized. If there is no value for the implicit argument <em>visible</em> at the moment the method is called, the compiler will report an error:</p>
<pre>scala&gt; ab("1")(A("A"))<br/>                ^<br/>    error: could not find implicit value for parameter b: B[String]</pre>
<p>This error can be fixed by providing the required implicit value:</p>
<pre>scala&gt; implicit val b = B("[Implicit]")<br/>b: B[String] = B([Implicit])<br/><br/>scala&gt; ab("1")(A("A"))<br/>1A(A)B([Implicit])</pre>
<p>If there are multiple implicit values in scope, the compiler will return an error:</p>
<pre>scala&gt; implicit val c = B("[Another Implicit]")<br/>c: B[String] = B([Another Implicit])<br/><br/>scala&gt; ab("1")(A("A"))<br/>                ^<br/>       error: ambiguous implicit values:<br/>        both value b of type =&gt; B[String]<br/>        and value c of type =&gt; B[String]<br/>        match expected type B[String]</pre>
<p>The solution to this problem is to remove all but one of the ambiguous implicit values or make one of the values <em>more specific</em>. We will look at how this can be done in a moment. Yet another approach is to provide the implicit value explicitly:</p>
<pre>scala&gt; ab("1")(A("A"))(b)<br/>1A(A)B([Implicit])<br/><br/>scala&gt; ab("1")(A("A"))(c)<br/>1A(A)B([Another Implicit])</pre>
<p>The implicit parameter does not need to be a value—it can be defined as a method. Having impure implicit methods can lead to <em>random</em> behavior, especially in the case of the type of implicit parameter being somewhat general:</p>
<pre>scala&gt; implicit def randomLong: Long = scala.util.Random.nextLong()<br/>randomLong: Long<br/><br/>scala&gt; def withTimestamp(s: String)(implicit time: Long): Unit = println(s"$time: $s")<br/>withTimestamp: (s: String)(implicit time: Long)Unit<br/><br/>scala&gt; withTimestamp("First")<br/>-3416379805929107640: First<br/><br/>scala&gt; withTimestamp("Second")<br/>8464636473881709888: Second</pre>
<p>Because of this, there is a general rule that implicit parameters must have possibly specific types. Following this rule also allows you to avoid confusing the compiler with recursive implicit parameters like the following:</p>
<pre>scala&gt; implicit def recursiveLong(implicit seed: Long): Long = scala.util.Random.nextLong(seed)<br/>recursiveLong: (implicit seed: Long)Long<br/><br/>scala&gt; withTimestamp("Third")<br/>                    ^<br/>       error: diverging implicit expansion for type Long<br/>       starting with method recursiveLong</pre>
<p>Done right, implicit parameters can be very useful and can provide configuration parameters for the implementations. Usually, it is done top-down and affects all layers of the program:</p>
<pre><span>object </span>Application {<br/>  <span>case class </span>Configuration(name: <span>String</span>)<br/>  <span>implicit val </span><span>cfg</span>: Configuration = <span>Configuration</span>(<span>"test"</span>)<br/>  <span>class </span>Persistence(<span>implicit </span>cfg: Configuration) {<br/>    <span>class </span>Database(<span>implicit </span>cfg: Configuration) {<br/>      <span>def </span>query(id: Long)(<span>implicit </span>cfg: Configuration) = <span>???<br/></span><span>      </span><span>def </span>update(id: Long, name: <span>String</span>)(<span>implicit </span>cfg: Configuration) = <span>???<br/></span><span>    </span>}<br/>    new Database().query(1L)<br/>  }<br/>}</pre>
<p>In this example, the configuration is defined once in the top layer and automatically passed down to the methods in the lowest layer. As a result, the calling of the function becomes more readable.</p>
<p>These configuration settings are just a special case of a more general use case—context passing. The context is usually stable compared to normal arguments and it is because of this that it makes sense to pass it implicitly. The classic example of this is an <kbd>ExecutionContext</kbd>, which is required for most of the <kbd>Future</kbd> methods (we'll take a detailed look at this in <a href="8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml">Chapter 6</a>, <em>Exploring Built-In Effects</em>):</p>
<pre><span>def </span>filter(p: <span>T </span>=&gt; Boolean)(<span>implicit </span>executor: ExecutionContext): Future[<span>T</span>] = ...</pre>
<p>The execution context usually doesn't change as opposed to the filtering logic, and therefore is passed implicitly.</p>
<p>Another use case is to verify types. We already saw an example of this in <a href="c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml">Chapter 2</a>, <em>Understanding Types in Scala</em> when we discussed generalized type constraints.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit classes</h1>
                </header>
            
            <article>
                
<p>So far, we have discussed implicit conversions and the extension methods pattern. The implementation is usually done in such a way that the old type is wrapped in an instance of a new type, which then provides the additional methods. We looked at <kbd>StringOps</kbd> as an example, but let's try to come up with a homegrown implementation of this pattern. We'll have a type, <kbd>A</kbd>, and we want it to be able to do some operation, <kbd>b</kbd>:</p>
<pre><span>case class </span>A[<span>T</span>](a: <span>T</span>) { <span>def </span>doA(): <span>T </span>= a }<br/>A("I'm an A").doB() // does not compile</pre>
<p>We can fix the compile error by defining a class, with the required operation, and by providing an implicit conversion from <kbd>A</kbd> to <kbd>B</kbd>:</p>
<pre><span>case class </span>B[<span>T</span>](b: <span>T</span>) { <span>def </span>doB(): <span>T </span>= b }<br/><br/><span>import </span>scala.language.<span>implicitConversions<br/></span><span>implicit def </span>a2b[<span>T</span>](a: A[<span>T</span>]): B[<span>T</span>] = <span>B</span>(a.a)<br/><br/>A("I'm an A").doB() // works</pre>
<p>This approach is so common that Scala has a special syntax for that called <strong>implicit classes</strong>. It combines defining a class and an implicit conversion into one definition of the class. The extended type becomes an argument for the constructor of the new class just as, in the previous code and in the following <span>example:</span></p>
<pre><span>implicit class </span>C[<span>T</span>](a: A[<span>T</span>]) { <span>def </span>doC(): <span>T </span>= a.a }<br/><span>A</span>(<span>"I'm an A"</span>).doC()</pre>
<p>It's cleaner and it does not require a <kbd>scala.language.implicitConversions</kbd> import. </p>
<p>The reason for this is that there is a subtle but significant difference between plain implicit conversions and implicit classes. While an implicit conversion can represent any kind of change, including already existing and/or primitive types, an <kbd>implicit</kbd> class is something that is created with the typed conversion in mind. The fact that it accepts the initial type as a constructor parameter makes it parameterized by this type—<span>in a sense</span>. All in all, it is safer to use implicit classes than implicit conversions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">View and context bounds</h1>
                </header>
            
            <article>
                
<p>Implicit conversions and implicit parameters we discussed previously, and they are so ubiquitous that there is a special language syntax for them, that is, view and context bounds. View bounds have been deprecated since Scala 2.11, but we believe that knowing about them will help you understand context bounds, so we'll cover both, though in different degrees of details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">View bounds</h1>
                </header>
            
            <article>
                
<p>The <em>view bound</em> is a syntactic sugar for the implicit parameter, which represents conversion between two types. It allows you to write a method signature with such implicit arguments in a slightly shorter form. We can see the difference between these two approaches by developing a method that will compare two unrelated types if there is a conversion to the third specific type for both of them:</p>
<pre><span>case class </span>CanEqual(hash: Int)<br/><br/>def equal[CA, CB](a: CA, b: CB)(implicit ca: CA =&gt; CanEqual, cb: CB =&gt; CanEqual): Boolean = ca(a).hash == ca(a).hash</pre>
<p>The version with view bounds (similar to the upper bound and lower bound, which we discussed in <a href="c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml">Chapter 2</a>, <em>Understanding Types in Scala</em>) has a shorter definition:</p>
<pre><span>def </span>equalsWithBounds[<span>CA </span>&lt;% CanEqual, <span>CB </span>&lt;% CanEqual](a: <span>CA</span>, b: <span>CB</span>): Boolean = {<br/>  <span>val </span>hashA = <span>implicitly</span>[<span>CA </span>=&gt; CanEqual].apply(a).hash<br/>  <span>val </span>hashB = <span>implicitly</span>[<span>CB </span>=&gt; CanEqual].apply(b).hash<br/>  hashA == hashB <br/>}</pre>
<p>The implicit method we are using here is a <kbd>helper</kbd> method, which is defined in Predef as the following:</p>
<pre><span>@inline </span><span>def </span>implicitly[<span>T</span>](<span>implicit </span>e: <span>T</span>) = e</pre>
<p>This allows us to summon an implicit value of type <kbd>T</kbd>. We're not providing this implicit value explicitly, and so we need to help the compiler figure out the sequence of calls by using the apply method on the summoned conversion.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If the implementation is more complex as compared to the original version, why would we want to use it? The answer is this—it becomes much better if the implicit parameters were just passed over to some internal function:</p>
<pre><span>def </span>equalsWithPassing[<span>CA </span>&lt;% CanEqual, <span>CB </span>&lt;% CanEqual](a: <span>CA</span>, b: <span>CB</span>): Boolean = <span>equal</span>(a, b)</pre>
<p>Like we said previously, view bounds have been deprecated since Scala 2.11, so we won't go into further details. Instead, we'll give our attention to context bounds.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Context bounds</h1>
                </header>
            
            <article>
                
<p>There is a yet another special case with implicit parameters where they are parameterized with the types of normal parameters. In this case, our previous example could be rewritten as follows:</p>
<pre><span>trait </span>CanEqual[<span>T</span>] { <span>def </span>hash(t: <span>T</span>): Int }<br/><br/>def equal[CA, CB](a: CA, b: CB)(implicit ca: CanEqual[CA], cb: CanEqual[CB]): Boolean =<br/>  ca.hash(a) == cb.hash(b)</pre>
<p>As we have already mentioned, there is also some syntactic sugar for this case named <em>context bounds</em>. With context bounds, our example can be simplified as follows:</p>
<pre><span>def </span>equalBounds[<span>CA</span>: CanEqual, <span>CB</span>: CanEqual](a: <span>CA</span>, b: <span>CB</span>): Boolean = {<br/>  <span>val </span>hashA = <span>implicitly</span>[CanEqual[<span>CA</span>]].hash(a) <br/>  <span>val </span>hashB = <span>implicitly</span>[CanEqual[<span>CB</span>]].hash(b)<br/>  hashA == hashB<br/>}</pre>
<p>As in the previous case, this syntax becomes concise in the case of the implicit parameters being passed over to the internal function:</p>
<pre><span>def </span>equalDelegate[<span>CA</span>: CanEqual, <span>CB</span>: CanEqual](a: <span>CA</span>, b: <span>CB</span>): Boolean = <span>equal</span>(a, b)</pre>
<p>Now, this is short and readable!</p>
<p>What is missing is the implementation of the implicit parameters for the different <kbd>CA</kbd> and <kbd>CB</kbd>. For <kbd>String</kbd>, it might be implemented as follows:</p>
<pre><span>implicit val </span><span>stringEqual</span>: CanEqual[<span>String</span>] = <span>new </span>CanEqual[<span>String</span>] {<br/>  <span>def </span>hash(in: <span>String</span>): Int = in.hashCode()<br/>}</pre>
<p>The implementation for <kbd>Int</kbd> is done in a very similar way. Using single abstract method syntax, we can replace the class definition with a function:</p>
<pre><span>implicit val </span><span>intEqual</span>: CanEqual[Int] = (in: Int) =&gt; in</pre>
<p>We can do this with even shorter code by using the identity in curried form:</p>
<pre><span>implicit val </span><span>intEqual</span>: CanEqual[Int] = <span>identity </span>_</pre>
<p>Now, we can use our implicit values to call functions with context bounds:</p>
<pre>scala&gt; equal(10, 20)<br/>res5: Boolean = false<br/>scala&gt; equalBounds("10", "20")<br/>res6: Boolean = false<br/>scala&gt; equalDelegate(10, "20")<br/>res7: Boolean = false<br/>scala&gt; equalDelegate(1598, "20")<br/>res8: Boolean = true</pre>
<p>In the previous snippet, the compiler resolves different implicits for different types of parameters, and these implicits are used to compare the arguments of the function.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type classes</h1>
                </header>
            
            <article>
                
<p>The previous example demonstrated that we need three parts for context bounds to work:</p>
<ol>
<li>A parameterized type, <kbd>T</kbd>, which is defined as an implicit parameter of the function we're going to call</li>
<li>One or more operations (methods) which are defined on <kbd>T</kbd>, and which will be available after the conversion</li>
<li>Implicit instances that implement <kbd>T</kbd></li>
</ol>
<p>In the case of the type referred to of the method definition being an abstract one and the mentioned method being implemented in different ways in instances, we're talking about <em>ad-hoc polymorphism</em> (as opposed to parametric polymorphism for functions, and subtype polymorphism for subclasses). Here, we will explore how this concept is implemented with type classes, how the compiler finds suitable instances if needed, and how variance applies in ad hoc polymorphic <span>cases.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type classes</h1>
                </header>
            
            <article>
                
<p>Ad-hoc polymorphism is especially useful in languages that aren't object-oriented and thus can't have subtype polymorphism. One example of such a language is Haskell. The pattern we're discussing is named<span> </span><em>type classes</em><span> </span>in Haskell and this name also came over to Scala. Type classes are widely used in <kbd>stdlib</kbd> and open source libraries and are fundamental for functional programming in Scala.</p>
<div class="packt_tip packt_infobox">The name <em>type classes</em> sound very familiar for an object-oriented developer because of the notion of classes. Unfortunately, it has nothing to do with classes in the OO sense and is just confusing. It helped me to think about type classes as a <em>class of types</em> instead in order to rewire my brain for this pattern.</div>
<p>Let's compare it to the traditional object-oriented approach and a type class that is used to define a set of USB cables. With OO, we would have the following definition:</p>
<pre><span>trait </span>Cable {<br/>  <span>def </span>connect(): Boolean<br/>}<br/><span>case class </span>Usb(orientation: Boolean) <span>extends </span>Cable {<br/>  <span>override def </span>connect(): Boolean = orientation<span><br/></span>}<br/><span>case class </span>Lightning(length: Int) <span>extends </span>Cable {<br/>  <span>override def </span>connect(): Boolean = length &gt; <span>100<br/></span>}<br/><span>case class </span>UsbC(kind: <span>String</span>) <span>extends </span>Cable {<br/>  <span>override def </span>connect(): Boolean = kind.contains(<span>"USB 3.1"</span>)<br/>}<br/><span>def </span>connectCable(c: Cable): Boolean = c.connect()</pre>
<p>Each of the subclasses implements the <kbd>connect</kbd> method by overriding the base traits' method. The <kbd>connectCable</kbd> just delegates the call to the instance, and proper implementation is called using dynamic dispatch:</p>
<pre>scala&gt; connectCable(Usb(false))<br/>res9: Boolean = false<br/>scala&gt; connectCable(Lightning(150))<br/>res10: Boolean = true</pre>
<p class="mce-root"/>
<p>The type class version looks slightly different. The classes do not need to extend the <kbd>Cable</kbd> any more (and thus are free to be a part of a different class hierarchy). We've also made a <kbd>UsbC</kbd> type generic, just for fun:</p>
<pre><span>case class </span>Usb(orientation: Boolean)<br/><span>case class </span>Lightning(length: Int)<br/><span>case class </span>UsbC[<span>Kind</span>](kind: <span>Kind</span>)</pre>
<p>The connection logic has moved into the type class that's been parameterized by the type of the cable:</p>
<pre><span>trait </span>Cable[<span>C</span>] {<br/>  <span>def </span>connect(c: <span>C</span>): Boolean<br/>}</pre>
<p>It is implemented in the respective type class instances:</p>
<pre><span>implicit val </span><span>UsbCable</span>: Cable[Usb] = <span>new </span>Cable[Usb] {<br/>  <span>override def </span>connect(c: Usb): Boolean = c.orientation<br/>}</pre>
<p>Or in the same approach using <span>single abstract method syntax:</span></p>
<pre><span>implicit val </span><span>LightningCable</span>: Cable[Lightning] = (_: Lightning).length &gt; <span>100</span></pre>
<p>We can't just define an implicit instance for our recently parameterized <kbd>UsbC</kbd> as we can't provide a generic implementation for <em>any</em> type parameter. The instance for the <kbd>UsbC[String]</kbd> (the same as in the OO version) can be easily implemented through the following:</p>
<pre><span>implicit val </span><span>UsbCCableString</span>: Cable[UsbC[<span>String</span>]] = <br/>  (_: UsbC[<span>String</span>]).kind.contains(<span>"USB 3.1"</span>)</pre>
<p>The <kbd>connectCable</kbd> is implemented with the context bound and uses ad-hoc polymorphism to select a proper delegate method:</p>
<pre><span>def </span>connectCable[<span>C </span>: Cable](c: <span>C</span>): Boolean = <span>implicitly</span>[Cable[<span>C</span>]].connect(c)</pre>
<p>This method can be called in the same way we called its OO sibling:</p>
<pre>scala&gt; connectCable(Usb(false))<br/>res11: Boolean = false<br/>scala&gt; connectCable(Lightning(150))<br/>res12: Boolean = true<br/>scala&gt; connectCable(UsbC("USB 3.1"))<br/>res13: Boolean = true</pre>
<p>On the call side, we have the same syntax, but the implementation is different. It is completely decoupled—our case classes don't know anything about the connection logic. In fact, we could have implemented this logic for the classes defined in another, closed source library!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type class recursive resolution</h1>
                </header>
            
            <article>
                
<p>In our previous example, we haven't implemented the connection functionality for the parameterized <kbd>UsbC</kbd> type, and our solution was only limited to <kbd>UsbC[String]</kbd>.</p>
<p>We could improve our solution by further delegating the connection logic. Say that we have an implicit function, <kbd>T =&gt; Boolean</kbd>, available—we could say that this is the logic the user of our library wants to use to describe the connection method. </p>
<div class="packt_infobox">This is an example of a <em>bad</em> use of implicits. This does not only include <em>primitive</em> <kbd>Boolean</kbd> types; it is highly probable that it will refer to another predefined type at the moment the implicit conversion will be defined. We provide this example exactly as it is mentioned—as an illustration of the bad design to be avoided!</div>
<p>This is what our delegate method could look like:</p>
<pre><span>implicit def </span>usbCCableDelegate[<span>T</span>](<span>implicit </span>conn: <span>T </span>=&gt; Boolean): Cable[UsbC[<span>T</span>]] = (c: UsbC[<span>T</span>]) =&gt; conn(c.kind)</pre>
<p>It literally reflects the intuition we had for the delegating function—the compiler will create an instance of <kbd>Cable[UsbC[T]]</kbd> if there is an implicit conversion of <kbd>T =&gt; Boolean</kbd> available.</p>
<p>This is how this could be used:</p>
<pre><span>implicit val </span><span>symbolConnect</span>: Symbol =&gt; Boolean = <br/>  (_: Symbol).name.toLowerCase.contains(<span>"cable"</span>)<br/><br/>scala&gt; connectCable(UsbC('NonameCable))<br/>res18: Boolean = true<br/>scala&gt; connectCable(UsbC('FakeKable))<br/>res19: Boolean = false</pre>
<p>But then, we have to deal with all of the dangers of the implicit conversion we're delegating to. For example, having the following unrelated conversions in scope:</p>
<pre><span>implicit val </span><span>isEven</span>: Int =&gt; Boolean = i =&gt; i % <span>2 </span>== <span>0<br/></span><span>implicit val </span><span>hexChar</span>: Char =&gt; Boolean = c =&gt; c &gt;= <span>'A' </span>&amp;&amp; c &lt;=<span>'F'<br/></span></pre>
<p>Would suddenly allow us to connect cables in unexpected ways:</p>
<pre>scala&gt; connectCable(UsbC(10))<br/>res23: Boolean = true<br/>scala&gt; connectCable(UsbC(11))<br/>res24: Boolean = false<br/>scala&gt; connectCable(UsbC('D'))<br/>res25: Boolean = true</pre>
<p>It might look like it is a dangerous approach to have an implicit definition that relies on the existence of another implicit in order to produce the required implicit value, but this is exactly what gives type classes their power.</p>
<p>To demonstrate this, let's imagine that we'd like to implement a USB adapter that should connect two USB devices with different standards. We could do this easily by representing our adapter as a pair of cable ends to connect, and delegating the real connection to the respective end of the cable:</p>
<pre><span>implicit def </span>adapt[<span>A</span>, <span>B</span>](<span>implicit </span>ev1: Cable[<span>A</span>], ev2: Cable[<span>B</span>]): Cable[(<span>A</span>, <span>B</span>)] = <span>new </span>Cable[(<span>A</span>, <span>B</span>)] {<br/>  <span>def </span>connect(ab: (<span>A</span>, <span>B</span>)): Boolean = <br/>    ev1.connect(ab._1) &amp;&amp; ev2.connect(ab._2) <br/>}</pre>
<p>Or, we could use context bounds and SAM syntax: </p>
<pre><span>implicit def </span>adapt[<span>A</span>: Cable, <span>B</span>: Cable]: Cable[(<span>A</span>, <span>B</span>)] =<br/>  (ab: (<span>A</span>, <span>B</span>)) =&gt; <br/><span>    implicitly</span>[Cable[<span>A</span>]].connect(ab._1) &amp;&amp;<br/><span>    implicitly</span>[Cable[<span>B</span>]].connect(ab._2)</pre>
<p>Now, we can use this implicit to call our existing <kbd>connectCable</kbd> method, but with the adapter logic:</p>
<pre>scala&gt; val usb2usbC = (Usb(false), UsbC('NonameCable))<br/>usb2usbC: (Usb, UsbC[Symbol]) = (Usb(false),UsbC('NonameCable))<br/><br/>scala&gt; connectCable(usb2usbC)<br/>res33: Boolean = false<br/><br/>scala&gt; val lightning2usbC = (Lightning(150), UsbC('NonameCable))<br/>lightning2usbC: (Lightning, UsbC[Symbol]) = (Lightning(150),UsbC('NonameCable))<br/><br/>scala&gt; connectCable(lightning2usbC)<br/>res34: Boolean = true</pre>
<p class="mce-root"/>
<p>Impressive, isn't it? Just imagine how much effort would be needed to add this functionality to the OO version!</p>
<p>The fun does not stop here! Because of the recursive nature of the context bound resolution, we can now build a chain of any length and the compiler will recursively check if it is possible to build the required adapter at compile time:</p>
<pre>scala&gt; val usbC2usb2lightning2usbC = ((UsbC('NonameCable), Usb(false)), (Lightning(150), UsbC("USB 3.1")))<br/>usbC2usb2lightning2usbC: ((UsbC[Symbol], Usb), (Lightning, UsbC[String])) = ((UsbC('NonameCable),Usb(false)),(Lightning(150),UsbC(USB 3.1)))<br/><br/>scala&gt; connectCable(usbC2usb2lightning2usbC)<br/>res35: Boolean = false<br/><br/>scala&gt; val noUsbC_Long_Cable = (UsbC('NonameCable), (Lightning(150), UsbC(10L)))<br/>noUsbC_Long_Cable: (UsbC[Symbol], (Lightning, UsbC[Long])) = (UsbC('NonameCable),(Lightning(150),UsbC(10)))<br/><br/>scala&gt; connectCable(noUsbC_Long_Cable)<br/>                     ^<br/>       error: could not find implicit value for evidence parameter of type Cable[(UsbC[Symbol], (Lightning, UsbC[Long]))]</pre>
<p>We can improve the error message a bit by applying a special annotation on our type class definition:</p>
<pre><span>@scala.annotation.implicitNotFound</span>(<span>"Cannot connect cable of type ${C}"</span>)<br/><span>trait </span>Cable[<span>C</span>] {<br/>  <span>def </span>connect(c: <span>C</span>): Boolean<br/>}</pre>
<p>Then, our last unsuccessful attempt will explain the reason for the failure a bit better:</p>
<pre>scala&gt; connectCable(noUsbC_Long_Cable)<br/>                     ^<br/>       error: Cannot connect cable of type (UsbC[Symbol], (Lightning, UsbC[Long]))</pre>
<p>Unfortunately, this is only as far as we can get in this case. The compiler can't currently figure out that the real reason for the failure is just <kbd>UsbC[Long]</kbd> and not the whole type.</p>
<p>The compiler will always try to infer the most specific implicit value with respect to subtyping and variance. This is why it is possible to combine subtype polymorphism and ad-hoc polymorphism.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type class variance</h1>
                </header>
            
            <article>
                
<p>To see how this combination works, let's imagine that our USB cables represent a hierarchy with a common ancestor:</p>
<pre><span>abstract class </span>UsbConnector<br/><span>case class </span>Usb(orientation: Boolean) <span>extends </span>UsbConnector<br/><span>case class </span>Lightning(length: Int) <span>extends </span>UsbConnector<br/><span>case class </span>UsbC[<span>Kind</span>](kind: <span>Kind</span>) <span>extends </span>UsbConnector</pre>
<p>How will this affect our type class definition? Well, of course, our previous version with every subtype implemented separately will work fine. But what if we would like to provide a generic type class instance for the whole <kbd>UsbConnector</kbd> hierarchy as shown in the following example?</p>
<pre><span>implicit val </span><span>usbCable</span>: Cable[UsbConnector] = <span>new </span>Cable[UsbConnector] {<br/>  <span>override def </span>connect(c: UsbConnector): Boolean = {<br/>    <span>println</span>(<span>s"Connecting </span><span>$</span>c<span>"</span>)<br/>    <span>true<br/></span><span>  </span>}<br/>}</pre>
<p>We would not be able to connect our cables anymore:</p>
<pre>scala&gt; connectCable(UsbC("3.1"))<br/>                   ^<br/>       error: could not find implicit value for evidence parameter of type Cable[UsbC[String]]</pre>
<p>This happens because the definition of our type class is invariant—thus, we are expected to provide an instance of <kbd>Cable[T]</kbd> with <kbd>T &lt;:&lt; </kbd><span><kbd>UsbC[String]</kbd>. Is the <kbd>usbCable</kbd> a good fit? It turns out that it is not because its return type is <kbd>Cable[UsbConnector]</kbd> and we're expected to provide a <kbd>UsbC[String]</kbd>.</span></p>
<p>We can fix this in two ways, depending upon whether we want our type class to work the same way for any class hierarchy or whether each class hierarchy that needs general treatment has to define it separately.</p>
<p>In the first case, we need to make sure that the compiler understands the following:</p>
<pre>Cable[UsbConnector] &lt;:&lt; Cable[UsbC[<span>String</span>]]</pre>
<p>We can check that this is currently not the case in the REPL:</p>
<pre>implicitly[Cable[UsbConnector] &lt;:&lt; Cable[UsbC[String]]]<br/>                 ^<br/>        error: Cannot prove that Cable[UsbConnector] &lt;:&lt; Cable[UsbC[String]]</pre>
<p>But we already know what we need to change in order to make it pass—our <kbd>Cable</kbd> should become contravariant:</p>
<pre><span>trait </span>Cable[<span>-C</span>] {<br/>  <span>def </span>connect(c: <span>C</span>): Boolean<br/>}</pre>
<p>As soon as we have proper variation in the definition of the <kbd>Cable</kbd>, everything falls into place, and the compiler can resolve all required implicits:</p>
<pre>scala&gt; implicitly[Cable[UsbConnector] &lt;:&lt; Cable[UsbC[String]]]<br/>res1: TypeClassVariance.Cable[TypeClassVariance.UsbConnector] &lt;:&lt; TypeClassVariance.Cable[TypeClassVariance.UsbC[String]] = generalized constraint<br/><br/>scala&gt; connectCable(UsbC("3.1"))<br/>Connecting UsbC(3.1)</pre>
<p>Unfortunately, if we decide that we need a special handling just for some of the classes from our hierarchy, we won't be able to reuse our implementation by defining a <em>more specific</em> type class instance:</p>
<pre><span>implicit val </span><span>usbCCable</span>: Cable[UsbC[<span>String</span>]] = <span>new </span>Cable[UsbC[<span>String</span>]] {<br/>  <span>override def </span>connect(c: UsbC[<span>String</span>]): Boolean = {<br/>    <span>println</span>(<span>s"Connecting USB C </span><span>$</span>{c.kind}<span>"</span>)<br/>    <span>true<br/></span><span>  </span>}<br/>}<br/><br/>scala&gt; connectCable(UsbC("3.1"))<br/>Connecting UsbC(3.1)</pre>
<p>This test shows that the generic instance is still used and that the specific one is ignored.</p>
<p>Luckily, we have another option that is feasible in the case that we can afford that each hierarchy takes care of subtyping resolution on its own. In this case, we keep our type class invariant but change the type class instance to be of a specific type instead of a general one:</p>
<pre><span>implicit def </span>usbPolyCable[<span>T </span>&lt;: UsbConnector]: Cable[<span>T</span>] = <span>new </span>Cable[<span>T</span>] {<br/>  <span>override def </span>connect(c: <span>T</span>): Boolean = {<br/>    <span>println</span>(<span>s"Poly-Connecting </span><span>$</span>c<span>"</span>)<br/>    <span>true<br/></span><span>  </span>}<br/>}</pre>
<p>We need to change <kbd>val</kbd> to a <kbd>def</kbd> in order to be able to parameterize it. Our generalized constraint starts to fail again for the invariant type class:</p>
<pre>scala&gt; implicitly[Cable[UsbConnector] &lt;:&lt; Cable[UsbC[String]]]<br/> ^<br/> error: Cannot prove that Cable[UsbConnector] &lt;:&lt; Cable[UsbC[String]].</pre>
<p>Nevertheless, we can connect the cable:</p>
<pre>scala&gt; connectCable(UsbC("3.1"))<br/>Poly-Connecting UsbC(3.1)</pre>
<p>Now, the compiler is able to choose the most specific instance available for our type class! If we bring the definition of <kbd>implicit val usbCCable</kbd> back into scope, we'll see that the output changes:</p>
<pre>scala&gt; connectCable(UsbC("3.1"))<br/>Connecting USB C 3.1</pre>
<p>This shows how <em>static overloading resolution</em> works. But this is only part of the picture. Let's clarify how and where the compiler looks for implicits if it needs them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit scope resolution</h1>
                </header>
            
            <article>
                
<p>In order to put the implicits in the places where they are required, the compiler first has to find them. This process is called <strong>implicit scope resolution</strong> and has well-defined rules in order to guarantee that implicits are determined as expected by the language specification and the developer using them. Implicit scope resolution is a three-step process.</p>
<div class="packt_infobox">Or four-step, if we count the case where the implicit parameter is provided explicitly as an argument to the method. We'll consider this case as number zero and won't take it into the account because it has the highest precedence and does not involve implicit lookup.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We'll provide a short overview of these steps so that we have them in one place for easy reference and then go into the details of each on the list:</p>
<ul>
<li>The current invocation (or lexical) scope. It has precedence over the implicit scope and encloses implicits that are accessible directly by their names without prefix, such as the following:
<ul>
<li>Local declarations</li>
<li>Outer scope declarations</li>
<li>Package objects</li>
<li>Inheritance chain</li>
<li>Import statements</li>
</ul>
</li>
<li>The implicit scope. It is looked up recursively and includes the following:<br/>
<ul>
<li>Companion object of the parameters</li>
<li>Companion object of super types</li>
<li>Companion object of mixin types (supertraits)</li>
<li>Companion object of the type</li>
<li>Companion object of the type parameters</li>
<li>Companion object of the type constructor</li>
</ul>
</li>
<li>Static overloading rules in the case of multiple implicits being found on one of the scopes.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lexical scope</h1>
                </header>
            
            <article>
                
<p>Let's start with the <em>lexical scope</em>. The lexical scope defines how variables are resolved in nested language constructs such as methods, functions, and other structured blocks. In general, the definitions of outer blocks are visible from inside the inner block (unless they are shadowed).</p>
<p>The following listing shows all possible conflicts during<span> implicit resolution in this scope</span>:</p>
<pre><br/><span>package object </span>resolution {<br/>  <span>implicit val </span><span>a</span>: TS = <span>new </span>TS(<span>"val in package object"</span>) <span>// (1)<br/></span>}<br/><br/><span>package </span>resolution {<br/>  <span>class </span>TS(<span>override val </span>toString: <span>String</span>)<br/>  <span>class </span>Parent {<br/>    <span>// <span class="underline">implicit val c: TS = new TS("val in parent class") // (2)</span><br/></span><span>  </span>}<br/>  <span>trait </span>Mixin {<br/>    <span>// <span class="underline">implicit val d: TS = new TS("val in mixin") // (3)</span><br/></span><span>  </span>}<br/>  <span>// <span class="underline">import Outer._ // (4)</span><br/></span><span>  </span><span>class </span>Outer {<br/>    <span>// <span class="underline">implicit val e: TS = new TS("val in outer class") // (5)</span><br/></span><span>    // <span class="underline">import Inner._ // (6)</span><br/></span><span><br/></span><span>    </span><span>class </span>Inner(<span>/*<span class="underline">implicit (7)</span> */ </span><span>val </span>arg: TS = <span>implicitly</span>[TS]) <span>extends </span>Parent <span>with </span>Mixin {<br/>      <span>// <span class="underline">implicit val f: TS = new TS("val in inner class") (8)</span><br/></span><span>      </span><span>private val </span><span>resolve </span>= <span>implicitly</span>[TS]<br/>    }<br/>    <span>object </span>Inner {<br/>      <span>implicit val </span><span>g</span>: TS = <span>new </span>TS(<span>"val in companion object"</span>)<br/>    }<br/>  }<br/>  <span>object </span>Outer {<br/>    <span>implicit val </span><span>h</span>: TS = <span>new </span>TS(<span>"val in parent companion object"</span>)<br/>  }<br/>}</pre>
<p>The possible conflicts are underlined. It is easy to see that implicit values in the package object, outer and inner scope, as well as those brought into the inner or outer scope, are of the same weight. The parameter to the class constructor (7) will lead to the conflict as well, if it is declared implicit.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit scope</h1>
                </header>
            
            <article>
                
<p>Now, let's move on to an example for the <em>implicit scope</em>, which has lower precedence than the lexical scope. The implicit scope usually includes (if applicable) the companion object of the type, the implicit scope of an argument's type, the implicit scope of type argument(s), and for nested types, outer objects.</p>
<p>The following example demonstrates the first three cases in action:</p>
<pre><span>import </span>scala.language.<span>implicitConversions<br/></span><span><br/></span><span>trait </span>ParentA { <span>def </span>name: <span>String </span>}<br/><span>trait </span>ParentB<br/><span>class </span>ChildA(<span>val </span>name: <span>String</span>) <span>extends </span>ParentA <span>with </span>ParentB<br/><br/><span>object </span>ParentB {<br/>  <span>implicit def </span>a2Char(a: ParentA): Char = a.name.head<br/><br/>}<br/><span>object </span>ParentA {<br/>  <span>implicit def </span>a2Int(a: ParentA): Int = a.hashCode()<br/>  <span>implicit val </span><span>ordering </span>= <span>new </span><span>Ordering</span>[ChildA] {<br/>    <span>override def </span>compare(a: ChildA, b: ChildA): Int =<br/>      <span>implicitly</span>[<span>Ordering</span>[<span>String</span>]].compare(a.name, b.name)<br/>  }<br/>}<br/><span>object </span>ChildA {<br/>  <span>implicit def </span>a2String(a: ParentA): <span>String </span>= a.name<br/>}<br/><br/><span>trait </span>Test {<br/>  <span>def </span>test(a: ChildA) = {<br/>    <span>val </span>_: Int = a <span>// companion object of ParentA<br/></span><span>    </span><span>val </span>_: <span>String </span>= a <span>// companion object of ChildA<br/></span><span>    </span><span>val </span>_: Char = a <span>// companion object of ParentB<br/></span><span>  </span>}<br/>  <span>def </span>constructor[<span>T</span>: <span>Ordering</span>](in: <span>T</span>*): <span>List</span>[<span>T</span>] = in.toList.sorted <span>// companion object of type constructor<br/></span><span>  </span>constructor(<span>new </span>ChildA(<span>"A"</span>), <span>new </span>ChildA(<span>"B"</span>)).sorted <span>// companion object of type parameters<br/></span>}</pre>
<p>Here, we spread a few implicit conversions in a class hierarchy to show how the lookup goes over companion objects of the argument and its supertypes, including supertraits. The last two lines demonstrate how the implicit scope includes type parameters of both the constructor and parameter type of the <kbd>sorted</kbd> method.</p>
<p>Unlike the first example, all implicits we defined in this one are unambiguous. If they aren't, the compiler would apply the static resolution rules to try to figure out the most specific implicit.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Static overloading rules</h1>
                </header>
            
            <article>
                
<p>The definition of static overloading rules is quite long and complicated (it can be found in the official documentation at <a href="https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution">https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#overloading-resolution</a>). It specifies a number of rules that the compiler uses to decide which alternative implicit is chosen. This decision is based on the relative weight of the alternatives. The higher weight means that the alternative <kbd>A</kbd> is more specific than <kbd>B</kbd>, and <kbd>A</kbd> wins. </p>
<p>The relative weight of <kbd>A</kbd> over <kbd>B</kbd> is calculated as a sum of two numbers:</p>
<ul>
<li>If <kbd>A</kbd> is defined in a class or object which is derived from the class or object defining <kbd>B</kbd> (simplified, <kbd>A</kbd> is derived from <kbd>B</kbd> if <kbd>A</kbd> is a subclass or <span>companion object of a subclass </span>of <kbd>B</kbd>, or <kbd>B</kbd> is a companion object of a superclass of <kbd>A</kbd>)</li>
<li>If <kbd>A</kbd> is as specific as <kbd>B</kbd> (simplified, this means that if <kbd>A</kbd> is a method, it can be called with the same arguments as <kbd>B</kbd>; for polymorphic methods, this also means more specific type constraints)</li>
</ul>
<p>These two rules allow you to calculate relative weights for two implicit conversions or parameters between 0 and 2 and to select the more suitable alternative in the case of the weights being different. If the weights are equal, the compiler will report <span>ambiguous implicit values.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">We have discussed three types of implicits in this chapter. These include implicit conversions, implicit classes, and implicit parameters.</p>
<p class="p1">We also discussed the syntactic sugar that's provided by the language in the form of view bounds and context bounds. We've seen how the former allows for defining implicit conversions in a somewhat concise way and that the latter does the same for type classes.</p>
<p class="p1">We compared object-oriented and type class based approaches in regards to polymorphic behavior. To depend on our knowledge of the topic, we worked through the recursive resolution of case classes and showed an example of type class variance.</p>
<p class="p1">In conclusion, we studied how the three levels of implicit scope resolution work. We've shown that all implicits in the lexical scope have the same precedence. The implicit scope is only looked at by the compiler if no suitable implicit can be found in the lexical scope. If there are multiple implicits in the scope, the static overloading rules are used to resolve possible conflicts.</p>
<p>This chapter concludes part of the book dedicated to Scala language constructs. In the following chapters, we'll move over to more complex concepts. But before doing this, in the next chapter, we'll take a brief digression into property-based testing to learn about some of the <span>techniques</span> we'll use to validate assumptions about the code we'll write in the second part of this book.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Describe a case where an implicit parameter is also an implicit conversion.</li>
<li>Replace the following definition that uses view bounds with one using context bounds: <kbd>def compare[T &lt;% Comparable[T]](x: T, y: T) = x &lt; y</kbd>?</li>
<li>Why are type classes sometimes said to separate behavior and data?</li>
<li>It is easy to change the example of possible conflicts in lexical scope so that one of the implicits wins over others and so that all others can be uncommented without having conflicts anymore. Can you change this?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<div class="book-top-block-info-anl cf">
<p class="book-top-block-info-authors left">Mads Hartmann, Ruslan Shevchenko, <em>Professional Scala</em>:<span> Writing concise and expressive, type-safe code in an environment that lets you build for the JVM, browser, and more.</span></p>
</div>
<p><span>Vikash Sharma, </span><em>Learning Scala Programming</em>: <span>Learn how to write scalable and concurrent programs in Scala, a language that grows with you.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>