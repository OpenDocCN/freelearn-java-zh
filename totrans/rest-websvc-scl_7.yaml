- en: Chapter 7. JSON, HATEOAS, and Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter, we're going to look a bit deeper into a couple of important
    parts of REST. We'll start with a more in-depth explanation of the different JSON
    libraries that are available, and after that, we'll explore the HATEOAS concept
    and explain how you can apply that principle to the frameworks explained in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many different JSON frameworks available for Scala. In this chapter,
    we''ll look at four of the most important and most used frameworks. The following
    table gives a short introduction to the frameworks that we''ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Framework | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Argonaut | Argonaut is an extensive JSON library that offers a functional
    approach to working with JSON. It has a very extensive JSON traversal and search
    functionality. You can find out more about it at [http://argonaut.io](http://argonaut.io).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Json4s | Json4s is a library that provides a standard way of parsing and
    rendering JSON. It provides a standardized interface on top of the existing libraries,
    such as lift-json and Jackson. You can find out more about it at [http://json4s.org/](http://json4s.org/).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Play JSON | Play JSON provides JSON support for the Play 2 framework. This
    library, however, can also be used in a standalone manner, and provides a very
    easy to use way of working with JSON. You can find out more about it at [https://www.playframework.com/documentation/2.4.x/ScalaJson](https://www.playframework.com/documentation/2.4.x/ScalaJson).
    |'
  prefs: []
  type: TYPE_TB
- en: '| spray-json | spray-json is a lightweight JSON framework, which provides some
    basic functions for processing JSON. It was part of the Spray framework, but can
    also be used as a standalone. You can find out more about it at [https://github.com/spray/spray-json](https://github.com/spray/spray-json).
    |'
  prefs: []
  type: TYPE_TB
- en: 'For each framework, we will look at how you can accomplish the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parse from string to JSON object**: The input for this step is a string.
    We''ll show you how you can use the JSON frameworks to convert this string into
    a JSON object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output JSON object as a string**: When you''ve got a JSON object, a common
    requirement is to print it as a string. All the frameworks provide support for
    this functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create a JSON object by hand**: Sometimes, you want to create a JSON object
    by hand (for example, when serializing part of a complex object). In this step,
    we''ll explain how to do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query a JSON object**: After converting a string in to a JSON object, a common
    requirement is to get specific values out of the JSON string. In this step, we''ll
    show you the different ways in which this is supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Converting to and from a case class**: In the previous chapters, we already
    saw how case classes can be converted to and from JSON. All the frameworks provide
    explicit support for this functionality, and we''ll explore how this works in
    this step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we look at the code, we first have to make sure we have all the required
    libraries. Each of the JSON libraries can be added just by including a single
    SBT dependency. The following set of dependencies adds all the libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step we explain for each of the frameworks is how to convert a string
    to a JSON object. For each of the frameworks, we''ll use the following input string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also directly run the code from the various libraries. You can find
    the sources in the `chapter7` folder and run the examples by running SBT. From
    SBT, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at the first JSON library, Json4s.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Json4s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll show how to parse the string value we just saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All you have to do is call the `parse` function on the string and the result
    is a `JValue` object. If the string can''t be parsed, a `ParseException` will
    be thrown. The result, when printed, looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the string is parsed into a set of Json4s-specific classes.
    Now that we have got a `JValue` object, we can also convert it back to a string
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling `pretty(render(parsedJson)`, you get a `pretty` printed string value.
    If you want a compact string, you can call `compact(render(parsedJson))` instead.
    The result of the `pretty` function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is creating a JSON object (a `JValue` object) by hand. Json4s
    provides a very convenient way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you only need to specify the key and provide a value; Json4s
    will automatically create the corresponding JSON objects. And when we print it,
    this time using the `compact` function, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To query a JSON object, Json4s provides two approaches. You can use an XPath-like
    expression, as we have in the following code fragment, or you can use a comprehension
    (more info on that can be found at the Json4s website):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code fragment, we use the `\` and `\\` operators to search through
    the JSON object. With the `\` operator, we select a single node, and with the
    `\\` operator, we search through all the children. The result of the previous
    `println` statement is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides these operators, Json4s also provides a number of functions to search
    through a JSON object. You can see the available functions by looking at the `MonadicJValue`
    class. The final feature we look at is how to convert case classes to and from
    JSON. If we''ve already got a Json4s JSON object, we can use the extract function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is a `Task` instance. You can also serialize it directly
    to and from a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using Json4s is really very straightforward. It provides the core functionality
    to easily create, query, and serialize JSON. Next up is Argonaut.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Argonaut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Argonaut follows a more functional approach to create and parse JSON as you''ll
    see in the following examples. We start again by converting a string object in
    to a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Argonaut extends the string object with a `parse` function. The result of this
    function is a `\/` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to an `Either` object, but where an `Either` object isn't right
    or left-biased, the `\/` instance is right-biased (which means you can also easily
    use it in `for` comprehensions). To get the value out of the `\/` instance, we
    use the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a JSON value, we can easily convert it in to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For output that is more compact, you can also use `spaces2` or `nospaces`.
    Argonout also provides a flexible way of creating JSON objects manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Argonaut provides a number of operators you can use to build a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `->:` | This prepends the given value to a JSON object. |'
  prefs: []
  type: TYPE_TB
- en: '| `->?` | This prepends the given optional value to a JSON object if it is
    set. |'
  prefs: []
  type: TYPE_TB
- en: '| `-->>:` | This prepends the given value to a JSON array. |'
  prefs: []
  type: TYPE_TB
- en: '| `-->>:?` | This prepends the given optional value to a JSON array if it is
    set. |'
  prefs: []
  type: TYPE_TB
- en: On the Argonaut website, a couple of alternative ways of creating JSON objects
    can also be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying objects with Argonaut can also be done in a couple of different ways.
    For our example, we''ll query using a lens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With this piece of code, we have defined a lens that matches a specific element
    in a JSON object. We always start with a `jObjectPL` function, which selects the
    root node of a JSON object. Next, we use the `jsonObjectPL("notes")` function
    to select the value of the `"notes"` key. By using `jArrayPL`, we convert the
    value to an array and use `jsonArrayPL(0)` to select the first element of the
    array. Finally, we use `JObjectPL` again to convert it in to an object, on which
    we query the `"id"` key and finally, convert it in to a string. Now that we have
    a lens, we can use it on a specific JSON object to extract the value (as an `Option[String]`
    instance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Argonaut, of course, also supports converting to and from case classes. The
    first thing we have to do is define a codec. A codec defines how a case class
    maps to the keys of a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we make the codecs implicit. This way, Argonaut will pick them up
    when it needs to convert a string in to a case class and back again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When you've defined a codec for a specific case class, you can just call the
    `asJson` function to convert the case class in to a `Json` object. To convert
    from a JSON string to a case class we can use the `Parse.decodeOption` function
    (Argonaut also provide a `decodeEither` function, a `decodeValidation` and a `decodeOr`
    if you want other wrappers instead of `Option`).
  prefs: []
  type: TYPE_NORMAL
- en: In the chapter on Akka HTTP, we already mentioned that, for JSON support, we
    use the spray-json library. In the following section, we'll dive a bit deeper
    into this library.
  prefs: []
  type: TYPE_NORMAL
- en: Working with spray-json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: spray-json provides a very easy way to work with JSON strings. To parse a string
    to a JSON object you can just call `parseJson` on the string value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, when printed, looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can also convert a JSON object back to a string by using either
    the `prettyPrint` or `compactPrint` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result from `prettyPrint` looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you want to create a JSON object by hand, spray-json provides a number
    of basic classes you can use for that (`JsObject`, `JsString`, `JsNumber`, and
    `JsArray`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is pretty much the same object we saw in the first example of the
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step we''ll look at is how we can query a JSON object for a specific
    field. This is something for which spray-json doesn''t provide specific functions
    or operators. The only way to access a specific field or value is by using the
    `getFields` or `fields` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `getFields` function returns a `Vector` object, containing all the fields
    on the current object that match this name. The fields function returns a `Map`
    object of all the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last feature we look at in each of the frameworks is how we can use it
    to convert from case classes to JSON and back again. In the chapter on Akka HTTP,
    we already showed you how to do this with spray-json:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What we do is extend the `DefaultJsonProtocol` and define, for each of our case
    classes, how they should be mapped through and from JSON. spray-json provides
    us with a very convenient helper function called `jsonFormat#(object)`, where
    the `#` corresponds to the number of arguments of the case class. With this function,
    we can define the default marshalling for our case classes, like we did in the
    preceding example. To use these implicit conversions, all we have to do is bring
    them in scope, and we can use the `toJson` function on our case classes to serialize
    them to `Json`, and use `convertTo` to convert JSON back to our case class.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Play JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final JSON library is also one we have touched upon in the previous chapters—Play
    JSON. As you''ll see in the code, the way this library works closely resembles
    the spray-json library. Let''s start by looking at converting from a string into
    a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Very simple, just call the `parse` function and provide the JSON, and the result
    is the following JSON object (when printed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert the JSON object to a string, we can either call the `stringify`
    function directly on the JSON object or use the `Json.prettyPrint` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prettyPrint` function returns the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too special so far. The same goes for creating JSON objects manually.
    Just like spray-json, Play JSON provides you with a set of base classes (`JsObject`,
    `JsNumber`, `JsString`, `JsObject`, and `JsArray`) that you can use to create
    your JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go to querying. This is where Play JSON provides us with a couple
    of very useful operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `\\` operator, we look for all the fields in the complete tree matching
    the field and return that as a `List` object, and with the single `\` operator,
    we look for a field in the current object. What makes this very easy to use is
    that these operators can easily be nested as you can see from the previous code
    fragment. When we look at the output, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting to and from case classes is also very straightforward with this
    library. We first define a set of implicit conversions, simply by calling `Json.format[T]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And with these implicit conversions defined, we can use the `toJson` and `fromJson[T]`
    functions to convert our case classes to and from JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's quickly recap the frameworks before we move on to the next subject.
  prefs: []
  type: TYPE_NORMAL
- en: JSON frameworks summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, which JSON framework is the best? Well, the general answer, of course, is
    it depends. All the frameworks have their advantages and disadvantages. If I do
    have to make a choice, I'd say that for simple JSON needs, Json4s is a really
    great choice. It provides a very easy way to create JSON objects from scratch,
    has an intuitive way of querying data, and allows you to easily convert to and
    from case classes. If you have more complex requirements, Argonaut is a very interesting
    choice. It provides a very functional way of JSON processing and has a number
    of interesting features for creating new JSON objects and querying the existing
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter, we looked at the definition of what a RESTful service
    is. Part of that definition is that a REST service should use HATEOAS, which is
    an acronym for Hypertext As The Engine Of Application State. What this means is
    that to be truly RESTful, our services doesn''t just need to provide more information
    than simply the JSON representation of a resource, but it should also provide
    information about the state of the application. When we talk about HATEOAS, we
    have to deal with the following two main principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypermedia/mime-types/media-types/content-types**: The hypermedia of a resource
    describes the current state of a resource. You can look at this as a sort of contract
    that describes the resource we''re working with. So, instead of setting the type
    of a resource to `application/json`, you define a custom content-type like `application/vnd.restwithscala.task+json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Links**: The second part of HATEOAS is that a resource representation needs
    to have links to other states of the resource and actions that can be executed
    on that resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, the following code provides information about the current response
    through the `self` link and uses media-types to indicate what to expect from these
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Since media-types are an important part of the resource, we don't just need
    to be able to set the media-type on the response, but also filter based on the
    incoming media-type, since a different media-type on a specific endpoint can have
    a different meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Handling media-types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let us walk through the frameworks discussed in this book and see how they
    handle media-types. You can, of course, run all these examples from the code provided
    with this book. You can use the following commands to start the various servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also provided a number of requests in Postman that you can use to test
    whether media handling works. You can find these in the **Chapter 07** collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling media-types](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first framework we'll explore is Finch.
  prefs: []
  type: TYPE_NORMAL
- en: Handling media-types with Finch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle media-types with Finch, we''re going to create a filter. This filter,
    and the code to glue everything together, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can create a filter by extending the `SimpleFilter` class. This filter provides
    access to the incoming `HttpRequest` instance and the outgoing `HttpResponse`
    instance. In this filter, we check whether the media-type is the correct one,
    and if this is the case, we process the request. If not, we return a `BadRequest`
    response. To give the client an indication of the type of response they are dealing
    with, we also set the media-type on the response object. With the filter defined,
    we create our route and invoke the `createNewTaskFilter` instance, which first
    calls the `filter` instance and then the `createTask` service. Now whenever a
    request with the correct media-type comes in, it is processed in the correct manner.
  prefs: []
  type: TYPE_NORMAL
- en: Handling media-types with Unfiltered
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Filtering on media-types is very easy to do in Unfiltered. We use some basic
    Scala pattern matching to check whether the `POST` on a specific path contains
    the correct media-type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all we do is pattern match two request properties, the verb
    (`POST`) and the content-type of the request; when those match, we process the
    request, and set the correct header on the response.
  prefs: []
  type: TYPE_NORMAL
- en: Handling media-types with Scalatra
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next one to discuss on the list of frameworks is Scalatra. As we have seen
    when discussing Scalatra, it provides a way to define a `before` function and
    an `after` function for a specific path. We use that functionality to check in
    the `before` function whether the media-type matches, and in the `after` function,
    we update the content-type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use pattern matching to match a specific verb and content-type.
    This means that if we have a `POST` verb and the correct content-type, we execute
    the request. If the verb matches but the content-type doesn't, we respond with
    a bad request and if the verb doesn't match, we just process it normally.
  prefs: []
  type: TYPE_NORMAL
- en: Handling media-types with Akka HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using media-types with Akka HTTP takes a bit more work. The reason is that
    Akka HTTP extracts the content-type out of the headers and adds it to the entity.
    This means we have to check the entity for the existence of a specific content-type
    instead of just checking a header. The first thing we do is define the content-type
    we''re looking for, and a function, which we can use to transform the response
    object and set the correct type on the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `mapEntity` function takes a `ResponseEntity` instance
    as its parameters, and returns a new one with the correct content-type. In the
    next code fragment, we''ll show how you can check the incoming request for the
    correct content-type and use the previously-defined function to set the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot is happening here, so let''s look at the directives we use here and why:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we extract the request and the entity of the request (the body and content-type)
    with the `entity` and `extractRequest` directives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we match the `request.entity.contentType` property of the entity, and
    if it matches, we create a new entity with the `application/json` content-type.
    We do this so that the standard JSON-to-case-class mapping of Akka HTTP still
    works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we convert the entity in to a `Task` instance, call the service, and create
    a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the response is returned, the `mapResponseEntity` function is called,
    which sets the content-type to our original value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that instead of an approach using directives, we could also have redefined
    the required implicits to make the JSON conversion work with our own custom content-type.
  prefs: []
  type: TYPE_NORMAL
- en: Handling media-types with Play 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement custom media-types in Play 2, we''ll use an `ActionBuilder` approach.
    With an `ActionBuilder` approach, we can change the way an action is invoked.
    The following code shows what the `ActionBuilder` approach of this example looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a new type of action, called a `MediaTypeAction`. When we use
    this action instead of the normal `Action` class, first the content-type of the
    incoming message is checked; if it matches, the request is processed; if not,
    the request is ignored and a `BadRequest` response is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this new `MediaTypeAction` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just replace the `Action` with `MediaTypeAction` and that's
    it. When this action is called, first the code from `MediaTypeAction` is executed,
    then the code is provided to the `Action`. To properly convert the incoming data
    to a JSON object, we need to make some small changes to the way we handle JSON.
    We use an explicit body parser (`parse.tolerantJson`) to parse the incoming JSON.
    With the function, we don't check whether the provided content-type is `application/json`,
    but just convert the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the beginning of this section, we explained two important parts of HATEOAS:
    media-type handling and supporting links. In the next section, we''ll show a way
    you can add links to your case classes easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Using links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the links, we''re going to create a very simple extension to our model.
    Instead of just sending the case class serialized to JSON, we''re adding a `_links`
    object. This object can contain different links. For instance, it can not only
    define a link to the resource itself, but also can contain links to actions that
    can be executed on this resource. The final JSON we''re aiming for looks similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, we''ll use Play JSON, but pretty much the same approach can
    be used with the other JSON libraries explored in this chapter. The first thing
    we do is define what the links will look like. For this, we define a trait and
    a case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create a new `Task`, we can extend from this trait to add links. As
    we have explained before, Play JSON uses implicit values to determine how to serialize
    a specific class to JSON. For this scenario, we define the following implicit
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: What happens here is that we define the standard implicits for the various parts
    of our model, including our new `HasLinks` trait. Besides that, we also define
    a very specific implicit that matches `Tasks` that extend the `HasLinks` trait.
    So, when we call the `toJson` function on a `Task` that extends `HasLinks`, the
    `taskWithLinksWrites` will match. In the `writes` function, we first convert the
    `Links` object and combine this with the converted `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this, all we have to do is define a new `Task` and use with `HasLinks`
    to add any links we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, after importing the correct implicits, we can convert the `Task` with `HasLinks`
    to JSON, just like we do other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we looked at a couple of important aspects of REST. We
    explored the various JSON libraries that can be used in your REST services for
    converting objects to and from JSON. Besides that, we looked at a very important
    aspect of REST called HATEOAS. The most important aspect of HATEOAS is the ability
    to detect and filter on media-type (content-type) and to add links to your resources
    to create self-describing APIs. We saw how to detect and work with media-types
    in the frameworks discussed in this book, and how to add links with one of the
    JSON frameworks explored in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With this last section on adding links to a JSON response, we have reached the
    end of this book. In the various chapters, we explored the most important features
    of a number of REST frameworks that are available in the Scala ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we tried to show you the most important features of
    these frameworks and explain how to use these features to create scalable, asynchronous,
    and maintainable REST services. Please keep in mind that each of these frameworks
    has many more features than we could explore in this book.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have had fun reading the book and experimenting with the examples.
    If you like them, feel free to use them, expand them, and share the results!
  prefs: []
  type: TYPE_NORMAL
