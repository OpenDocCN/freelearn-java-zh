- en: Chapter 10. Testing Apache Karaf with Pax Exam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Pax Exam test environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Apache Karaf features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing commands with Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage with Apache Karaf Pax exam tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Apache Camel with Blueprint and Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to set up a test environment for Apache Karaf. As
    developing OSGi applications for Apache Karaf also needs thorough testing, an
    environment for integration testing is needed. Pax Exam is a powerful tool for
    developing integration tests and can be combined with Apache Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details about Pax Exam can be found at the OPS4j community website at [https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam](https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam).
    If help is needed, you can find a working community at [https://groups.google.com/forum/#!forum/ops4j](https://groups.google.com/forum/#!forum/ops4j).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Pax Exam test environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will guide you through the basic setup of a Pax Exam test environment
    using the Felix framework as the core OSGi container. The next recipe will cover
    how to combine Pax Exam and Apache Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, the sources can be found at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform integration tests with Pax Exam, the POM configuration is essential,
    since it is already part of the build environment. For example, use the `pax-exam-container-native`
    artifact and of course it is mandatory to connect JUnit with Pax Exam. This can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Besides this, it is required to define the OSGi framework in which to run this
    test scenario. This can either be the Felix framework, Equinox, or any other framework
    available as a Maven dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the important parts of the POM configuration, let's
    focus on the JUnit integration test.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test class only consists of two major methods: the test method itself
    where we have a minor test setup for the container to work properly, and the far
    more important method at this point—the configuration. Consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The unit test class needs the `@RunWith(PaxExam.class)` annotation to make clear
    it is a Pax Exam test. The `@ExamReactorStrategy` annotation lets you define a
    strategy for testing, either `PerClass`, `PerMethod`, or `PerSuite`, where you
    also need to define the test classes to run with. In our test, it is sufficient
    to run with the `PerClass` strategy as it starts the container only once per class,
    whereas the `PerMethod` strategy starts the test and its setup for each method
    invocation. The `PerSuite` strategy starts and configures the test setup for a
    suite of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For details about the test strategies, refer to the Pax Exam documentation at
    [https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam](https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam).
  prefs: []
  type: TYPE_NORMAL
- en: 'A Pax Exam test class always needs a `configuration` method annotated with
    the `@Configuration` annotation. This is needed for Pax Exam to know the configuration
    needed to run the test. For example, it is best to give a `workingDirectory` method,
    otherwise the working directory is placed in the temporary directory of the system.
    With the `junitBundles` method, the JUnit bundles are included so Pax Exam is
    capable of running JUnit tests. To run the tests with TestNG, it is required to
    add the dependencies of TestNG to the `configuration` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the `frameworkProperty("osgi.console")` property, you're able to add an
    OSGi console to the test; if you run the test in debug mode, you're able to access
    this console via port `6666`. This completes the basic setup of a Pax Exam test
    where we already have one test method that checks whether the injected (`@Inject`)
    bundle context is available.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Pax Exam finds its own modules on the classpath through Maven, it starts
    the container by itself. This is true for either a Felix or Equinox or any other
    kind of container supplied to Pax Exam by the POM configuration. Everything else
    needs to be specified using the `configuration` method. If you are using other
    bundles in your test scenario, you also need to specify their Maven coordinates.
    It's usually best to specify the version of the bundle in question in your POM
    configuration, and reuse this version in your configuration. You'll find more
    on this in the upcoming recipes.
  prefs: []
  type: TYPE_NORMAL
- en: So how does Pax Exam compare with a standard unit test? While testing on a unit
    level, maybe even with mocks, the tests are about the unit alone. Integration
    tests usually cover a wider range or a bigger scope with more units under test.
    Integration tests might be run as external tests against an externally available
    API. This is a bit hard if your APIs are services within a container. Pax Exam
    works with and within the container. The test class will be part of the deployed
    artifacts. In an OSGi environment, Pax Exam builds a dynamical bundle containing
    your test class, even with package imports. These bundle manifest headers can
    also be manipulated by the test; more details are available in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An integration test usually tests an already built artifact, but sometimes
    it is essential to either alter the artifact or to test not after the artifact
    is built but when building this artifact. For this scenario, it is possible to
    build a *dynamic* bundle on the fly by configuring a `streamBundle`. This can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how to build a dynamic bundle including an activator and
    exporting the right packages and other manifest header entries. The registered
    service can be directly imported into the test and used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might also be interested in using Pax Exam with other environments; it also
    supports Tomcat, Jetty, or JEE servers as backend for the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Apache Karaf features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After going through the *Setting up a Pax Exam test environment* recipe, you
    should be ready to test OSGi applications in general. Now, let's take a closer
    look at what is needed to run a test with Apache Karaf as the container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in the previous chapters, the sources are available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2).
    To fully understand this recipe, it is best to have gone through the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Setting up a Pax Exam test environment* recipe, we defined the Felix
    framework as the runtime container. Now, we need to change this to Apache Karaf,
    so the first changes need to be done to the POM configuration. Pax Exam needs
    to know that it needs to run with Apache Karaf as the container; this is configured
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pax-exam-container-karaf` dependency as a replacement dependency for the
    Felix framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `apache-karaf` ZIP artifact to be used as the runtime container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The standard features file for installing the standard features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After these changes are made to the POM configuration, the test itself needs
    to be reconfigured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first major change should jump out at you right away: the Apache Karaf
    configuration, which has the `karafDistributionConfiguration` function with the
    Maven coordinates to an Apache Karaf ZIP file. As it is already defined in the
    POM configuration, the `versionAsInProject()` configuration can be used. Besides
    this, a feature is installed right away from the configuration and is available
    as soon as the container is up and running. The tests make sure the expected feature
    is installed.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pax Exam uses Karaf as container instead of a given OSGi framework. Some extra
    configuration is needed because the container is assembled as a ZIP file and needs
    to be unwrapped first. After this is done, the Apache Karaf container is started
    at the given location with the configured constraints, for example, to turn off
    the `Deploy` folder. The `versionAsInProject()` configuration needs some extra
    handling. For this to work, you need to make sure a Maven dependency file is generated.
    This can be done by configuring `depends-maven-plugin` from the ServiceMix project.
    This will generate a file containing all dependency information contained in the
    POM configuration readable by Pax Exam. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these configurations done, your tests are set. In the given test sample,
    we used an internal feature descriptor; if you want to test any other kind of
    custom feature, you just need to add it to the configuration and tell it which
    feature should be deployed. In the previous sample, it is the `eventadmin` feature.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the already known simple injection of the `bundlecontext` object, it
    is also possible to inject any kind of service to the test that is available in
    the container. In the previous sample, we injected `featuresService`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing commands with Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you've gone through the first two recipes, you should be set for thorough
    testing of OSGi bundles, either standalone or in Apache Karaf. When working with
    Apache Karaf, it is sometimes necessary to also have new commands. This recipe
    will cover how to test with commands and make sure these commands are executed
    inside the Apache Karaf shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's best to have gone through the *Testing Apache Karaf features* recipe before
    starting this recipe, as this one is a follow up. The sources can be found at
    [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the execution of an Apache Karaf shell command, you need to tweak the
    test class. First, you need to alter the way the test is run. For this, we add
    the probe builder which configures the way the test bundle is built. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code make sure the injection for the `CommandProcessor`
    interface works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the actual testing of commands, we add a convenience method that sends
    the command to the Karaf shell and receives the output from it. This can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This string containing the response is testable for the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essential part of this test is the addition of the `ProbeBuilder` annotation.
    The `ProbeBuilder` annotation alters the way the bundle containing the test class
    is built. In our case, it alters the `Package-Import` header of the generated
    bundle. It is not only possible to alter or add manifest headers, but also to
    add additional classes or test classes.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage with Apache Karaf Pax Exam tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from testing the application, it is usually also a requirement to know
    how well the unit and integration tests actually cover the code. For code coverage,
    a couple of technologies are available. This recipe will cover how to set up your
    test environment to find the coverage of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's best to have gone through the *Testing Apache Karaf features* recipe before
    starting this follow-up recipe. The sources of this recipe are available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find out about the coverage of the test, a code coverage tool is needed.
    We will take the Java Code Coverage Library as it has a Maven plugin for automated
    coverage analysis. At first, the Maven coordinates for the plugin are added as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to prepare the code first so it can be covered by the agent as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will include the `com.packt` package, including subpackages. After the
    integration tests are done, the test report needs to be generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides these additions to the POM configuration, you need to add the VM options
    to the configuration of the Apache Karaf test. Without setting these options to
    the virtual machine, which executes the test, the executing environment doesn''t
    know of the coverage and, therefore, no coverage is done. This can be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The resulting report of this coverage looks like the following screenshot. It
    shows the coverage of the `CalculatorImpl` class and its methods. While the `add`
    method has been called by the test, the `sub` method wasn't. This results in zero
    coverage for that method.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_10_01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you need to prepare the agent for covering, this will be inserted into
    the `jcoverage.command` property. This property is passed to the test by adding
    the `vmOption` directory. This way the coverage agent is added to the Java Virtual
    Machine and it tracks the coverage of the test execution. After the test is run
    successfully, the report is generated by the `jacoco-maven-plugin`. All of this
    works fine with a single Maven module. A multimodule project setup will require
    additional work, especially if you want to combine unit and integration test coverage.
    More details can be found at [http://www.eclemma.org/jacoco/index.html](http://www.eclemma.org/jacoco/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Testing Apache Camel with Blueprint and Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will cover how to test a Camel Blueprint definition. The focus of
    this recipe will be on the test and how it differs from the *Testing Apache Karaf
    features* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's best to have gone through the *Testing Apache Karaf features* recipe and
    the *Creating a Blueprint-based Camel Router for deployment in Apache Karaf* recipe
    before starting this follow-up recipe. The sources of this chapter are available
    at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have based this recipe on the *Testing Apache Karaf features* recipe,
    we already have a basic setup containing the setup of the Apache Karaf container.
    Additionally, we need the Apache Camel feature for Karaf. This way all the bundles
    required for testing a Camel route are present. The test itself requires the Camel
    Context of the `blueprint.xml` definition to attach itself to its mock object.
    This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class itself inherits from the `CamelTestSupport` class for easier
    testing of Camel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To have access to the mock contained in the Camel route, we make sure the Camel
    Context is injected. The `@Filter` annotation makes sure only the desired Camel
    Context is injected within the given timeout.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The configuration contains the targeted Karaf runtime and installs the required
    `camel-blueprint` and `camel-test` features as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, the `HelloBean` class and `blueprint.xml` file are wrapped up
    in a streamed bundle so the test is runnable inside the same module. As the last
    specialty to the test, we make sure the Camel Context is only created once per
    class creation. This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This completes the setup for testing a Camel route with Pax Exam inside the
    Karaf container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Test` method, we make sure that the required features are installed,
    the Camel Context has been injected, and that the mock is satisfied. Consider
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in the previous recipes, Pax Exam makes sure Apache Karaf is run as the basic
    container. With the feature configuration inside the `@Configuration` method,
    we install the `camel-blueprint` and `camel-test` features. The test makes sure
    those features are indeed installed and running. To verify that the `HelloBean`
    class has actually sent a message to the mock endpoint, the test gets the mock
    endpoint from the injected Camel Context and expects at least a message count
    of one. Pax Exam injects the Camel Context used by the `blueprint.xml` file into
    the test class. To make sure it is the context that is actually needed, the `@Filter`
    annotation given with the LDAP filter syntax for OSGi services is used. While
    the `blueprint.xml` file containing the Camel Context is started, the Camel Context
    itself is registered as a service in the OSGi registry with the Camel Context
    ID registered as the `camel.context.name` property.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the inheritance and the overridden `isCreateCamelContextPerClass`
    method, the Camel Context is only created once during the test execution. This
    is essential for running the Camel tests with Pax Exam because the container is
    only created once in the test. Otherwise, the Camel Context would be created a
    couple of times resulting in various errors.
  prefs: []
  type: TYPE_NORMAL
- en: To assert the successful execution of the test and to verify the expected message
    count, you are required to call the `assertIsSatisfied` method on the mock instead
    of calling the `assertMockEndpointsSatisfied` method. The latter method asserts
    all mock endpoints of the Camel Context bound to the test itself, while the former
    one asserts the mock that is contained in the Camel Context created by the Blueprint
    handler.
  prefs: []
  type: TYPE_NORMAL
