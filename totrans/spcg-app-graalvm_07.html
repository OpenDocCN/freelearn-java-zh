<html><head></head><body>
		<div id="_idContainer115">
			<h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor097"/>Chapter 5</em>: Graal Ahead-of-Time Compiler and Native Image</h1>
			<p>Graal ahead-of-time compilation helps build native images that start up faster, and have a smaller footprint than traditional Java applications. Native images are critical for modern-day cloud-native deployments. GraalVM comes bundled with a tool called <strong class="source-inline">native-image</strong> that is used to compile ahead of time and generate native images.</p>
			<p><strong class="source-inline">native-image</strong> compiles the code into an executable that can run standalone without a virtual machine. The executable includes all the classes, dependencies, libraries, and more importantly, all the virtual machine functionalities such as memory management, thread management, and so on. The virtual machine functionality is packaged as a runtime called Substrate VM. We briefly covered Substrate VM in <a href="B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">GraalVM Architecture</em>, in the <em class="italic">Substrate VM (Graal AOT and native image)</em> section. In this chapter, we will gain a deeper understanding of native images. We will learn how to build, run, and optimize native images with a sample.</p>
			<p>Native images can only perform static code optimizations and do not have the advantage of runtime optimizations that just-in-time compilers perform. We will explore profile-guided optimization, which is a technique that can be used to optimize native images, by using runtime profiling data. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding how to build and run native images</li>
				<li>Understanding the architecture of a native image, and how the compilation works</li>
				<li>Exploring various tools, compilers, and runtime configurations to analyze and optimize the way native images are built and executed </li>
				<li>Understanding how to optimize native images using <strong class="bold">Profile-Guided Optimization</strong> (<strong class="bold">PGO</strong>)</li>
				<li>Understanding the limitations of native images, and how to overcome these limitations</li>
				<li>Understanding how memory is managed by native images</li>
			</ul>
			<p>By the end of this chapter, you will have a clear understanding of Graal ahead-of-time compilation and hands-on experience in building and optimizing native images.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor098"/>Technical requirements</h1>
			<p>We will be using the following tools and sample code for exploring and understanding Graal ahead-of-time compilation:</p>
			<ul>
				<li><strong class="bold">The native-image tool</strong>: We will cover how to install and run the <strong class="source-inline">native-image</strong> tool.</li>
				<li><strong class="bold">GraalVM Dashboard</strong>: We will be using GraalVM Dashboard in this chapter to analyze the native images that we create.</li>
				<li><strong class="bold">Access to GitHub</strong>: There are some sample code snippets, which are available in a Git repository. The code can be downloaded from <a href="https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05">https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05</a>.</li>
				<li>The Code in Action video for this chapter can be found at <a href="https://bit.ly/3ftfzNr.">https://bit.ly/3ftfzNr.</a></li>
			</ul>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor099"/>Building native images</h1>
			<p>In this section, we will <a id="_idIndexMarker406"/>build a native image, using the Graal Native Image builder (<strong class="source-inline">native-image</strong>).<strong class="source-inline"> </strong>Let's start by installing the Native Image builder. </p>
			<p><strong class="source-inline">native-image</strong> can be installed using GraalVM Updater with the following command:</p>
			<p class="source-code">gu install native-image</p>
			<p>The tool is directly installed in the <strong class="source-inline">/bin</strong> folder of <strong class="source-inline">GRAALVM_HOME</strong>.</p>
			<p>Let's now create a native image of <strong class="source-inline">FibonacciCalculator</strong>, from the <em class="italic">Graal compiler configurations</em> section in <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Graal Just-In-Time Compiler</em>.</p>
			<p>To create a native image, compile the <a id="_idIndexMarker407"/>Java file and run <strong class="source-inline">native-image FibonacciCalculator –no-fallback -noserver</strong>. The following screenshot shows the output after running the command: </p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B16878_Figure_5.1.jpg" alt="Figure 5.1 – FibonacciCalculator – generating a Native Image console output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – FibonacciCalculator – generating a Native Image console output</p>
			<p>Native Image compilation takes time, as it has to perform a lot of static code analysis to optimize the image that is generated. The following diagram shows the flow of ahead-of-time compilation performed by the Native Image builder:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B16878_Figure_5.2.jpg" alt="Figure 5.2 – Native Image pipeline flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Native Image pipeline flow</p>
			<p>Let's try to <a id="_idIndexMarker408"/>understand this picture better:</p>
			<ul>
				<li>The ahead-of-time compiler loads all the application code and dependency libraries and classes and packages them along with the Java Development Kit classes and Substrate VM classes. </li>
				<li>Substrate VM has all the virtual machine functionality that is required to run the application. This includes memory management, garbage collection, thread management, scheduling, and so on. </li>
				<li>The compiler then performs the following optimization on the code before building the native image:<p>a. <strong class="bold">Points-to Analysis</strong>: Identifies only classes and methods that are used and called, and eliminates all the <a id="_idIndexMarker409"/>code that is never used or called. For example, our code may not be doing a lot of math operations or string operations. There is no point in taking the complete JDK and converting it to machine code. Instead, only the used classes/methods are picked. The points-to analysis assumes that all the bytecode that is ever used in the application is available. This means that the classes cannot be loaded at runtime. Even the runtime modification of class structure, using reflection, is not supported directly. However, if the application uses reflection, we can create a meta-file in JSON, to configure reflection (<strong class="source-inline">META-INF/native-image/reflect-config.json</strong>). It is also possible to configure other dynamic features such as JNI, proxies, and so on. The configuration files need to be in <strong class="source-inline">CLASSPATH</strong>, then the compiler takes care of including these features in the final native image.</p><p>b. <strong class="bold">Initialize</strong>: The classes are initialized and the heap allocations are performed.</p><p>c. <strong class="bold">Region Analysis and Heap Snapshot</strong>: Create a snapshot of the heap so that the heap image <a id="_idIndexMarker410"/>can be created and built into the native image, for faster loads. Heap snapshotting gathers all the objects that are reachable at runtime. This includes class initializations, initializing <strong class="source-inline">static</strong> and <strong class="source-inline">static final</strong> fields, <strong class="source-inline">enum</strong> constants, <strong class="source-inline">java.lang.Class</strong> objects, and so on.</p></li>
				<li>The final native image has the code section, where the final optimized binary code is placed, and in the data section of the executable, the heap image is written. This will help load the native image quickly.</li>
			</ul>
			<p>Here is a higher-level flow of how points-to analysis and region analysis work at build time and runtime:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B16878_Figure_5.3.jpg" alt="Figure 5.3 – Native Image pipeline – points-to analysis and region analysis&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Native Image pipeline – points-to analysis and region analysis</p>
			<p>Let's <a id="_idIndexMarker411"/>understand this picture in detail:</p>
			<ul>
				<li>At build time, the points-to analysis scans through the application code, dependencies, and JDK to find reachable code. </li>
				<li>The region analysis captures the heap region metadata, which includes region mappings and the region entry/exit. Region analysis also uses the reachable code to identify which static elements need to be initialized.</li>
				<li>The code is generated <a id="_idIndexMarker412"/>with the reachable code and the region metadata. </li>
				<li>At runtime, the heap allocator allocates ahead of time using the region mappings and the region manager handles the entry and exit. </li>
			</ul>
			<p>Let's now run the <a id="_idIndexMarker413"/>native image by issuing <strong class="source-inline">./fibonaccicalculator</strong> from the command line. The following is a screenshot of executing the native image:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B16878_Figure_5.4.jpg" alt="Figure 5.4 – FibonacciCalculator – running fibonaccicalculator native image console output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – FibonacciCalculator – running fibonaccicalculator native image console output</p>
			<p>One of the biggest disadvantages of ahead-of-time compilation is that the compiler never gets to profile the runtime to optimize the code, which happens very well with just-in-time compilation. To bring the best of both worlds together, we can use the PGO technique. We covered PGO briefly in <a href="B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">GraalVM Architecture</em>. Let's see it in action and understand it in a little more depth. </p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor100"/>Analyzing the native image with GraalVM Dashboard </h1>
			<p>To gain a deeper understanding of <a id="_idIndexMarker414"/>how the points-to analysis and region analysis works, we can use GraalVM Dashboard. In this section, we <a id="_idIndexMarker415"/>will create a dump while building the native image and use GraalVM to visualize the Native Image builder perform points-to analysis and region analysis. </p>
			<p>In the section <em class="italic">Debugging and Monitoring applications</em> from <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Graal Just-In-Time Compiler</em>, we briefly covered GraalVM Dashboard. GraalVM Dashboard is a very powerful tool specifically for native images. In this section, we will generate a dashboard dump of our <strong class="source-inline">FibonnacciCalculator</strong> sample, and explore how we can use GraalVM Dashboard to gain insights into the native image. </p>
			<p>To generate the dashboard dump, we have to use the <strong class="source-inline">-H:DashboardDump=&lt;name of the file&gt;</strong> flag. For our <strong class="source-inline">FibonacciCalculator</strong>, we use the following command:</p>
			<p class="source-code">native-image -H:DashboardDump=dashboard -H:DashboardAll FibonacciCalculator</p>
			<p>The following screenshot shows the output generated by this command. The command created a <strong class="source-inline">dashboard.bgv</strong> file:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B16878_Figure_5.5.jpg" alt="Figure 5.5 – FibonacciCalculator – generating the dashboard dump console output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – FibonacciCalculator – generating the dashboard dump console output</p>
			<p>We also used the <strong class="source-inline">-H:DashboardAll</strong> flag to <a id="_idIndexMarker416"/>dump all the <a id="_idIndexMarker417"/>parameters. The following are alternative flags that we can use:</p>
			<ul>
				<li><strong class="source-inline">-H:+DashboardHeap</strong>: This flag only dumps the image heap.</li>
				<li><strong class="source-inline">-H:+DashboardCode</strong>: This flag generates the code size, broken down by method.</li>
				<li><strong class="source-inline">-H:+DashboardPointsTo</strong>: This flag creates a dump of the points-to analysis that the Native Image builder has performed.</li>
			</ul>
			<p>Now let's load this <strong class="source-inline">dashboard.bgv</strong>, and analyze the results. We need to upload the <strong class="source-inline">dashboard.bgv</strong> file to GraalVM Dashboard. Open the browser and go to <a href="https://www.graalvm.org/docs/tools/dashboard/">https://www.graalvm.org/docs/tools/dashboard/</a>.</p>
			<p>We should then see the following screen:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B16878_Figure_5.6.jpg" alt="Figure 5.6 – GraalVM Dashboard home page &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – GraalVM Dashboard home page </p>
			<p>Click on the <strong class="bold">+ Load data</strong> button at the top left. You will get a dialog box as shown in the next screenshot:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B16878_Figure_5.7.jpg" alt="Figure 5.7 – Upload dashboard dump file window &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Upload dashboard dump file window </p>
			<p>Click on the <strong class="bold">Select File</strong> button and point to the <strong class="source-inline">dashboard.bgv</strong> file that we generated. You <a id="_idIndexMarker418"/>will immediately see the <a id="_idIndexMarker419"/>dashboard, as shown in <em class="italic">Figure 5.8</em>. You will find two reports that are generated on the left side – <strong class="bold">Code Size Breakdown</strong> and <strong class="bold">Heap Size Breakdown</strong>.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor101"/>Understanding the code size breakdown report</h2>
			<p>The code size breakdown report provides the <a id="_idIndexMarker420"/>size of the code of <a id="_idIndexMarker421"/>various classes categorized into blocks. The size of the block represents the size of the code. The following figure shows the initial dashboard screen when we select the <strong class="bold">Code Size Breakdown</strong> option in the left pane for <strong class="source-inline">dashboard.bgv</strong> we generated in the previous section. By hovering over the blocks, we get more clear size breakdowns by method. We can double-click on these blocks to dig down deeper:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B16878_Figure_5.8.jpg" alt="Figure 5.8 – Code size breakdown dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Code size breakdown dashboard</p>
			<p>The following <a id="_idIndexMarker422"/>screenshot shows the report we see when we <a id="_idIndexMarker423"/>double-click on the FibonacciCalculator block. Once again, we can double-click on the call graph:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B16878_Figure_5.9.jpg" alt="Figure 5.9 – Code size breakdown – details report&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Code size breakdown – details report</p>
			<p>The following screenshot <a id="_idIndexMarker424"/>shows the call graph. This helps us <a id="_idIndexMarker425"/>understand the points-to analysis that the Native Image builder has performed. This can be used to identify opportunities to optimize the source code if we identify any classes' or methods' dependencies that are not used:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B16878_Figure_5.10.jpg" alt="Figure 5.10 – Code points-to dependency report&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Code points-to dependency report</p>
			<p>Now let's look at heap size breakdown.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor102"/>Heap size breakdown</h2>
			<p>Heap size breakdown provides a <a id="_idIndexMarker426"/>detailed insight into heap allocation and also provides a deep dive into the heap. We can double-click on these blocks to <a id="_idIndexMarker427"/>understand these heap allocations. The following screenshot shows the heap size breakdown report for <strong class="source-inline">FibonacciCalculator</strong>:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B16878_Figure_5.11.jpg" alt="Figure 5.11 – Heap Size Breakdown dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Heap Size Breakdown dashboard</p>
			<p>In this section, we looked at how we can use GraalVM Dashboard to analyze native images. Now let's look at how we can optimize our native images using PGO. </p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor103"/>Understanding PGO</h1>
			<p>Using PGO, we can <a id="_idIndexMarker428"/>run the native image with an option to generate a runtime profile. The JVM creates a profile file, <strong class="source-inline">.iprof</strong>, which <a id="_idIndexMarker429"/>can be used to recompile the native image, to further optimize it. The following diagram (recall it from the <em class="italic">Profile Guided Optimization (PGO)</em> section in <a href="B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">,</em> <em class="italic">GraalVM Architecture</em>) shows how PGO works:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B16878_Figure_5.12.jpg" alt="Figure 5.12 – Native Image – profile-guided optimization pipeline flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Native Image – profile-guided optimization pipeline flow</p>
			<p>The preceding diagram <a id="_idIndexMarker430"/>shows the native image compilation pipeline flow using PGO. Let's understand this flow better:</p>
			<ul>
				<li>The initial native image is instrumented to create a profile by passing the <strong class="source-inline">–pgo-instrument</strong> flag argument, while bundling the native image. This will generate a native image with instrumentation code.</li>
				<li>When we run the native image with several inputs, a profile is created by the native image. This profile is a file generated in the same directory with the <strong class="source-inline">.iprof</strong> extension.</li>
				<li>Once we have run <a id="_idIndexMarker431"/>through all the use cases, to ensure that the profile created covers all the paths. We can then rebuild the native image by passing the <strong class="source-inline">.iprof</strong> file as a parameter along with the <strong class="source-inline">--pgo</strong> argument. </li>
				<li>This will generate the optimized native image. </li>
			</ul>
			<p>Let us now build an optimized native image of our <strong class="source-inline">FibonacciCalculator</strong> class. Let's first start by creating an instrumented native image by running the follo<a id="_idTextAnchor104"/>wing command:</p>
			<p class="source-code">java -Dgraal.PGOInstrument=fibonaccicalculator.iprof -Djvmci.CompilerIdleDelay-0 FibonacciCalculator</p>
			<p>This command will build the <a id="_idIndexMarker432"/>native image using the profile information. The following screenshot shows the output of <a id="_idIndexMarker433"/>building the native image:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B16878_Figure_5.13.jpg" alt="Figure 5.13 – FibonacciCalculator – generating PGO profile console output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – FibonacciCalculator – generating PGO profile console output</p>
			<p>This will generate the <strong class="source-inline">fibonaccicalculator.iprof</strong> file in the current directory. Let's now use this profile to rebuild our native image using the following command:</p>
			<p class="source-code">native-image –pgo=fibonaccicalculator.iprof FibonacciCalculator</p>
			<p>This will rebuild the native image, with the optimum executable. The following screenshot shows the output when we build the native image with the profile:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B16878_Figure_5.14.jpg" alt="Figure 5.14 – FibonacciCalculator – generating profile-guided optimized native image console output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – FibonacciCalculator – generating profile-guided optimized native image console output</p>
			<p>Now let's execute the <a id="_idIndexMarker434"/>optimized file. The following <a id="_idIndexMarker435"/>screenshot shows the output results when we run the optimized native image: </p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B16878_Figure_5.15.jpg" alt="Figure 5.15 – FibonacciCalculator – running PGO image console output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – FibonacciCalculator – running PGO image console output</p>
			<p>As you can see, it's much faster than the original native image. Let's now compare the values. The following graph shows the compression:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B16878_Figure_5.16.jpg" alt="Figure 5.16 – FibonacciCalculator – native image versus PGO native image comparison&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – FibonacciCalculator – native image versus PGO native image comparison</p>
			<p>As you can see, PGO <a id="_idIndexMarker436"/>performs much <a id="_idIndexMarker437"/>faster and better.</p>
			<p>While this is all good, if you compare this with the JIT, we see that native image does not perform so well. Let's compare this with JIT (both Graal and Java HotSpot). The following graph shows the comparison:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B16878_Figure_5.17.jpg" alt="Figure 5.17 – FibonacciCalculator – Graal JIT versus Java HotSpot versus native image versus PGO native image comparison&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – FibonacciCalculator – Graal JIT versus Java HotSpot versus native image versus PGO native image comparison</p>
			<p>This highlights one of the key points, that <a id="_idIndexMarker438"/>native images are not always optimum. In this case, it is definitely not, because of the heap allocation that we are doing with the large arrays that we are building. This directly <a id="_idIndexMarker439"/>impacts the performance. This is one of the areas where it's important as a developer to optimize the code. Native images use the Serial GC, hence it's not a good idea to use native images for large heaps. </p>
			<p>Let's optimize the code and see if native images run faster than JIT. Here is the optimized code, which does the exact same logic, but uses less Heap:</p>
			<p class="source-code">public class FibonacciCalculator2{    </p>
			<p class="source-code">         public long findFibonacci(int count) {</p>
			<p class="source-code">                  int fib1 = 0;</p>
			<p class="source-code">                  int fib2 = 1;</p>
			<p class="source-code">                  int currentFib, index;</p>
			<p class="source-code">                  long total = 0;</p>
			<p class="source-code">                  for(index=2; index &lt; count; ++index ) {         </p>
			<p class="source-code">                           currentFib = fib1 + fib2;         </p>
			<p class="source-code">                           fib1 = fib2;         </p>
			<p class="source-code">                           fib2 = currentFib;         </p>
			<p class="source-code">                           total += currentFib;</p>
			<p class="source-code">                  }</p>
			<p class="source-code">                  return total;</p>
			<p class="source-code">         }</p>
			<p class="source-code">         public static void main(String args[]) {         </p>
			<p class="source-code">                  FibonacciCalculator2 fibCal =                     new FibonacciCalculator2();</p>
			<p class="source-code">                  long startTime =                     System.currentTimeMillis();</p>
			<p class="source-code">                  long now = 0;</p>
			<p class="source-code">                  long last = startTime;</p>
			<p class="source-code">                  for (int i = 1000000000; i &lt; 1000000010; i++)                   {</p>
			<p class="source-code">                           fibCal.findFibonacci(i);</p>
			<p class="source-code">                           now = System.currentTimeMillis();</p>
			<p class="source-code">                           System.out.printf("%d (%d                                ms)%n", i , now - last);</p>
			<p class="source-code">                           last = now;</p>
			<p class="source-code">                  }</p>
			<p class="source-code">                  long endTime =                      System.currentTimeMillis();</p>
			<p class="source-code">                  System.out.printf(" total: (%d ms)%n",                           System.currentTimeMillis() –                                    startTime);</p>
			<p class="source-code">         }</p>
			<p class="source-code">}</p>
			<p>Here are the final results of <a id="_idIndexMarker440"/>running this code with Graal JIT and Native Image. As you'll see in the following screenshots, Native Image <a id="_idIndexMarker441"/>does not take any time for startup and performs much faster than JIT. Let's run the optimized code with Graal JIT. Following is the output after running the optimized code:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B16878_Figure_5.18.jpg" alt="Figure 5.18 – FibonacciCalculator2 – running optimized code with Graal &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – FibonacciCalculator2 – running optimized code with Graal </p>
			<p>Now let's run the native image of the optimized code. The next screenshot shows the output after running the native image:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B16878_Figure_5.19.jpg" alt="Figure 5.19 – FibonacciCalculator2 – running optimized code as a native image &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – FibonacciCalculator2 – running optimized code as a native image </p>
			<p>If you chart the <a id="_idIndexMarker442"/>performance, you <a id="_idIndexMarker443"/>can see a significant improvement:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B16878_Figure_5.20.jpg" alt="Figure 5.20 – FibonacciCalculator2 – Graal JIT versus Native Image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – FibonacciCalculator2 – Graal JIT versus Native Image</p>
			<p>It's important to <a id="_idIndexMarker444"/>understand the <a id="_idIndexMarker445"/>limitations of AOT compilation and use the right approach. Let's quickly go through some of the compiler configurations for building native images.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor105"/>Native image configuration</h1>
			<p>A native image build is <a id="_idIndexMarker446"/>highly configurable and it is always recommended to provide all the build configuration in the <strong class="source-inline">native-image.properties</strong> file. As the <strong class="source-inline">native-image</strong> tool takes a JAR file as an input, it is recommended to package <strong class="source-inline">native-image.properties</strong> in <strong class="source-inline">META-INF/native-image/&lt;unique-application-identifier&gt;</strong> within the JAR file. A unique application identifier is used to avoid any collision of resources. These paths have to be unique, as they will be configured on <strong class="source-inline">CLASSPATH</strong>. The <strong class="source-inline">native-image</strong> tool uses <strong class="source-inline">CLASSPATH</strong> to load these resources while building. Apart from <strong class="source-inline">native-image.properties</strong>, there are various other configuration files that can be packaged. We will cover some of the important configurations in this section. </p>
			<p>The following is the <a id="_idIndexMarker447"/>typical format of the <strong class="source-inline">native-image.properties</strong> file followed by an explanation of each of the sections in the properties file: </p>
			<p class="source-code">Requires = &lt;space separated list of languages that are required&gt; </p>
			<p class="source-code">JavaArgs = &lt;Javaargs that we want to pass to the JVM&gt;</p>
			<p class="source-code">Args = &lt;native-image arguments that we want to pass&gt;</p>
			<ul>
				<li><strong class="source-inline">Requires</strong>: The <strong class="source-inline">Requires</strong> property is used to list all the language examples, such as <strong class="source-inline">language:llvm</strong> <strong class="source-inline">language:python.</strong></li>
				<li><strong class="source-inline">JavaArgs</strong>: We can pass regular Java arguments using this property.</li>
				<li><strong class="source-inline">ImageName</strong>: This can be used to provide a custom name for the native image that is generated. By default, the native image is named after the JAR file or Mainclass file (all in lowercase letters). For example, our <strong class="source-inline">FibonnaciCalculator.class</strong> generates <strong class="source-inline">fibonaccicalculator</strong>. </li>
				<li><strong class="source-inline">Args</strong>: This is the most commonly used property. It can be used to provide the native-image arguments. The arguments can also be passed from the command line, but it is much better from the configuration management perspective to have them listed in <strong class="source-inline">native-image.properties</strong>, so that it can go into Git (or any source code repository) and track any changes. The following table explains some of the important arguments that are typically used:</li>
			</ul>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B16878_Table_5.1.jpg" alt=""/>
				</div>
			</div>
			<p>Please refer to <a href="https://www.graalvm.org/reference-manual/native-image/Options/">https://www.graalvm.org/reference-manual/native-image/Options/</a> for the <a id="_idIndexMarker448"/>complete list of options.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor106"/>Hosted options and resource configurations </h2>
			<p>We can configure <a id="_idIndexMarker449"/>various resources using various parameters. These <a id="_idIndexMarker450"/>resource declarations are normally configured in an external JSON file, and various <strong class="source-inline">-H:</strong> flags can be made to point to these resource files. The syntax is <strong class="source-inline">-H&lt;Resource Flag&gt;=${.}/jsonfile.json</strong>. The following table lists some of the important arguments that are used:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B16878_Table_5.1a.jpg" alt=""/>
				</div>
			</div>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B16878_Table_5.1b.jpg" alt=""/>
				</div>
			</div>
			<p><strong class="source-inline">native-images.properties</strong> captures all the configuration parameters, and it is a good practice to pass configurations through the <strong class="source-inline">native-image.properties</strong> file, as it's easy to manage it in a source code configuration management tool. </p>
			<p>GraalVM comes with an <a id="_idIndexMarker451"/>agent that tracks the dynamic features of a Java program at runtime. This helps in identifying and configuring the <a id="_idIndexMarker452"/>native image build with dynamic features. To run the Java application with the Native image agent, we need to pass <strong class="source-inline">-agentlib:native-image-agent=config-output-dir=&lt;path to config dir&gt;</strong>. The agent tracks the execution and intercepts calls that look up classes, methods, resources, and proxies. The agent then generates <strong class="source-inline">jni-config.json</strong>, <strong class="source-inline">reflect-config.json</strong>, <strong class="source-inline">proxy-config.json</strong>, and <strong class="source-inline">resource-config.json</strong> in the config directory passed as the parameter. It's a good practice to run the application multiple times, with different test cases, to ensure that the complete code is covered, and the agent gets to catch most of the dynamic calls. When we run iterations, it is important to use <strong class="source-inline">-agentlib:native-image-agent=config-merge-dir=&lt;path to config dir&gt;</strong> so that the configuration files are not overwritten but merged.</p>
			<p>We can generate Graal graphs with native images, to analyze how the native image is running. In the next section, we will explore how to generate these Graal graphs.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor107"/>Generating Graal graphs for native images</h1>
			<p>Graal graphs can be generated <a id="_idIndexMarker453"/>even for native images. Graal graphs <a id="_idIndexMarker454"/>can be generated during build time or at runtime. Let's explore this feature in this section using our <strong class="source-inline">FibonnaciCalculator</strong> application.</p>
			<p>Let's generate the dump for <strong class="source-inline">FibonacciCalculator</strong> using this command: </p>
			<p class="source-code">native-image -H:Dump=1 FibonacciCalculator</p>
			<p>The following is the output:</p>
			<p class="source-code"><img src="image/Code_Block_Symbol_01.png" alt=""/> native-image -H:Dump=1 FibonacciCalculator</p>
			<p class="source-code">[fibonaccicalculator:54143]  classlist:  811.75 ms,    0.96 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]      (cap):  4,939.64 ms,  0.96 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]      setup:  6,923.28 ms,  0.96 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]   (clinit):  155.70 ms,    2.29 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]  typeflow):  3,841.07 ms,  2.29 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]  (objects):  3,235.92 ms,  2.29 GB</p>
			<p class="source-code">[fibonaccicalculator:54143] (features):  169.55 ms,    2.29 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]   analysis:  7,550.64 ms,  2.29 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]   universe:  295.75 ms,    2.29 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]    (parse):  829.58 ms,    3.18 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]   (inline):  1,357.72 ms,  3.18 GB</p>
			<p class="source-code">[Use -Dgraal.LogFile=&lt;path&gt; to redirect Graal log output to a file.]</p>
			<p class="source-code">Dumping IGV graphs in /graal_dumps/2021.02.28.20.32.24.880</p>
			<p class="source-code">Dumping IGV graphs in /graal_dumps/2021.02.28.20.32.24.880</p>
			<p class="source-code">[fibonaccicalculator:54143]  (compile):  13,244.17 ms, 4.74 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]    compile:  16,249.17 ms, 4.74 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]      image:  1,816.98 ms,  4.74 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]      write:  430.54 ms,    4.74 GB</p>
			<p class="source-code">[fibonaccicalculator:54143]    [total]:  34,247.73 ms, 4.74 GB</p>
			<p>This command generates a <a id="_idIndexMarker455"/>lot of graphs for every class that is initialized. We can use the <strong class="source-inline">-H:MethodFilter</strong> flag to specify the class and method <a id="_idIndexMarker456"/>that we want to generate a graph for. The command would look something like this:</p>
			<p class="source-code">native-image -H:Dump=1 -H:MethodFilter=FibonacciCalculator.main FibonacciCalculator</p>
			<p>Please refer to the section <em class="italic">Graal intermediate representation</em> from <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Graal Just-In-Time Compiler</em>, to know how to read these graphs and understand opportunities for optimizing the code. Optimizing the source code is critical for native images as there are no runtime optimizations like we have in just-in-time compilers.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor108"/>Understanding how native images manage memory</h1>
			<p>Native images come <a id="_idIndexMarker457"/>bundled with Substrate VM, which has the functionality of managing memory, including garbage collection. As we saw in the <em class="italic">Building native images</em> section, the heap allocation happens as part of the image creation to speed up the startup. These are classes that are initialized at build time. Refer to <em class="italic">Figure 5.3</em> to see how the Native Image builder initialized the heap region after performing static region analysis. At runtime, a garbage collector manages the memory. There are two garbage collection configurations that the Native Image builder supports. Let's understand <a id="_idIndexMarker458"/>these two garbage collection configurations in the following subsections.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor109"/>The Serial garbage collector</h2>
			<p>The Serial Garbage Collector (GC) is the default that <a id="_idIndexMarker459"/>gets built into the native image. This is available both on the Community and Enterprise edition. This garbage collector is <a id="_idIndexMarker460"/>optimized for a low memory footprint and small heap size. We can use the <strong class="source-inline">--gc=serial</strong> flag to explicitly use the Serial GC. The Serial GC is a simple implementation of the GC.</p>
			<p>The Serial GC divides the heap into two regions, that is, young and old. The following figure shows how the Serial GC works:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B16878_Figure_5.21.jpg" alt="Figure 5.21 – Serial GC heap architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – Serial GC heap architecture</p>
			<p>The young generation is used for new objects. It is triggered when the young generation block is full and all the objects that are not used are reclaimed. When the old generation blocks become full, a full collection is triggered. Young collections run faster and a full collection is more time-consuming at runtime. This behavior can be tweaked using the argument <strong class="source-inline">-XX:PercentTimeInIncrementalCollection</strong>. </p>
			<p>By default, this percentage is 50. This can be increased to reduce the number of full collections, improving the performance, but will have a negative effect on the memory size. Depending on the memory profiling, while testing the application, we can optimize this parameter for better performance and memory footprint. Here is an example of how to pass this parameter at runtime:</p>
			<p class="source-code">./fibonaccicalculator -XX:PercentTimeInIncrementalCollection=40</p>
			<p>This parameter can also be passed at build time:</p>
			<p class="source-code">native-image --gc=serial -R:PercentTimeInIncrementalCollection=70 FibonacciCalculator</p>
			<p>There are other arguments that can also be used for fine-tuning, such as <strong class="source-inline">-XX:MaximumYoungGenerationSizePercent</strong>. This argument can be used to tweak the maximum percentage the young generation block should occupy of the overall heap. </p>
			<p>The Serial GC is <a id="_idIndexMarker461"/>single-threaded and works well for small heaps. The following figure shows how the Serial GC works. The application threads <a id="_idIndexMarker462"/>are paused to reclaim the memory. It is <a id="_idIndexMarker463"/>called a <em class="italic">Stop the World</em> event. During this time, the <strong class="bold">Garbage Collector Thread</strong> runs and reclaims <a id="_idIndexMarker464"/>the memory. This has an impact on the performance of the application if the heap size is large and if there are a lot of threads running. The Serial GC is very good for small processes with small heap sizes.</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B16878_Figure_5.22.jpg" alt="Figure 5.22 – Serial GC heap flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22 – Serial GC heap flow</p>
			<p>By default, the Serial GC assumes an 80% heap size, before it starts the GC thread. This can be changed <a id="_idIndexMarker465"/>using the <strong class="source-inline">-XX:MaximumHeapSizePercent</strong> flag. There are <a id="_idIndexMarker466"/>other flags that can be used to fine-tune the performance of the Serial GC. </p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>The G1 Garbage Collector</h2>
			<p>The G1 Garbage Collector is the <a id="_idIndexMarker467"/>more recent and advanced implementation of the garbage collector. This is only available in the Enterprise edition. The G1 Garbage Collector <a id="_idIndexMarker468"/>can be enabled using the flag <strong class="source-inline">--gc=G1</strong>. G1 provides the right balance of throughput and latency. Throughput is the average time spent running the code versus GC. Higher throughput means we have more CPU cycles for code, rather than the GC thread. Latency is the amount of time the <em class="italic">Stop The World</em> event takes or the time taken to pause the code execution. The less latency, the better for us. G1 targets high throughput and low latency. Here is how it works.</p>
			<p>G1 divides the whole heap into small regions. G1 runs concurrent threads to find all live objects, and the Java application is never paused, and keeps track of all the pointers between regions, and tries to collect regions so that there are shorter pauses in the program. G1 might also move live objects and consolidate them into regions and tries to make the regions empty. </p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B16878_Figure_5.23.jpg" alt="Figure 5.23 – G1 GC heap flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23 – G1 GC heap flow</p>
			<p>The previous diagram shows how G1 GC works by dividing into regions. The allocation of objects into the regions is based on trying to allocate memory in empty regions and trying to empty the regions by consolidating the objects into regions, like partitioning and de-partitioning. The idea is to optimally manage and collect the regions.</p>
			<p>G1 garbage collector has a larger footprint than the <a id="_idIndexMarker469"/>Serial GC and is for longer-running, larger heap sizes. There are various parameters that can be used to <a id="_idIndexMarker470"/>fine-tune the performance of G1 GC. Listed next are some of them (<strong class="source-inline">-H</strong> are the parameters passed during the building of the image and <strong class="source-inline">-XX</strong> is passed while running the image):</p>
			<ul>
				<li><strong class="source-inline">-H:G1HeapRegionSize</strong>: This is the size of each region. </li>
				<li>-<strong class="source-inline">XX:MaxRAMPercentage</strong>: Percentage of physical memory size that is used as the heap size.</li>
				<li><strong class="source-inline">-XX:ConcGCThreads</strong>: Number of concurrent GC threads. This needs to be optimized for the best performance.</li>
				<li><strong class="source-inline">-XX:G1HeapWastePercent</strong>: The garbage collector stops claiming when it reaches this percentage. This will allow lower latency and higher throughput, however, it is critical to set an optimum value, as if it's too high, then the objects will never get collected, and the application memory footprint will always be high.</li>
			</ul>
			<p>The choice of using the right garbage collector and the configuration is critical for the performance and memory footprint of the application.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/>Managing the heap size and generating heap dumps</h2>
			<p>Heap size can be <a id="_idIndexMarker471"/>manually set using the following runtime parameters passed to the native image while running them. <strong class="source-inline">-Xmx</strong> sets the <a id="_idIndexMarker472"/>maximum heap size, <strong class="source-inline">-Xms</strong> sets the minimum heap size, and <strong class="source-inline">-Xmn</strong> sets the size of the young generation region, in bytes. Here is an example of how these arguments can be used at runtime:</p>
			<p class="source-code">./fibonaccicalculator -Xms2m -Xmx10m -Xmn1m</p>
			<p>At build time, we can pass arguments to configure the heap size. This is a critical configuration and has to be done with a lot of care as this has a direct impact on the memory footprint and performance of the native image. The following command is an example that configures the <a id="_idIndexMarker473"/>minimum heap size, maximum heap size, and the <a id="_idIndexMarker474"/>maximum new size of the heap: </p>
			<p class="source-code">native-image -R:MinHeapSize=2m -R:MaxHeapSize=10m -R:MaxNewSize=1m FibonacciCalculator</p>
			<p>Heap dumps are the most <a id="_idIndexMarker475"/>important for debugging any memory leaks and memory management issues. We typically use tools such as VisualVM to do such heap dump analysis. Native images are not built with <strong class="bold">Java Virtual Machine Tool Interface</strong> (<strong class="bold">JVMTI</strong>) agents to perform <a id="_idIndexMarker476"/>heap dumps on while the application is running. However, while building the native image, we <a id="_idIndexMarker477"/>can build with the <strong class="source-inline">-H:+AllowVMInspection</strong> flag. This will create a native image that can generate a stack dump when we send a USR1 signal (<strong class="source-inline">sudo kill -USR1</strong> or <strong class="source-inline">-SIGUSR1</strong> or <strong class="source-inline">QUIT/BREAK</strong> keys) and a runtime compilation information dump when we send a USR2 signal (<strong class="source-inline">sudo kill -USR2</strong> or <strong class="source-inline">-SIGUSR2</strong> – you can check the exact signal using the <strong class="source-inline">kill -l</strong> command). This feature is available only in the Enterprise edition.</p>
			<p>We can also programmatically create heap dumps by calling <strong class="source-inline">org.graalvm.nativeimage.VMRuntime#dumpHeap</strong> when required.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor112"/>Building static native images and native shared libraries</h1>
			<p>Static native images are <a id="_idIndexMarker478"/>statically linked binaries that do not need any additional dependent libraries at runtime. These are very useful when we are building <a id="_idIndexMarker479"/>microservice applications as native images so that they can be easily packaged into Docker, without worrying about dependencies. Static images are best for building container-based microservices.</p>
			<p>At the time of writing this book, this feature is only available for Linux AMD64 on Java 11. Please refer to <a href="https://www.graalvm.org/reference-manual/native-image/StaticImages/">https://www.graalvm.org/reference-manual/native-image/StaticImages/</a> for the latest updates and the process of building static native images.</p>
			<p>The Native Image builder also builds shared libraries. Sometimes you may want to create your code as a <a id="_idIndexMarker480"/>shared library that is used by some other <a id="_idIndexMarker481"/>application. For that, you have to pass the <strong class="source-inline">–shared</strong> flag to build a shared library, instead of an executable one.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor113"/>Debugging native images</h1>
			<p>Debugging a native image requires <a id="_idIndexMarker482"/>building the image with debug info. We can use <strong class="source-inline">-H:GenerateDebugInfo=1</strong>. Here is an example of using this argument for <strong class="source-inline">FibonnacciCalculator</strong>:</p>
			<p class="source-code">native-image -H:GenerateDebugInfo=1 FibonacciCalculator</p>
			<p>The generated image has <a id="_idIndexMarker483"/>debug information in the form of the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>). This can be used to debug the code at runtime. The following shows the output of running the preceding command: </p>
			<p class="source-code">native-image -H:GenerateDebugInfo=1 FibonacciCalculator</p>
			<p class="source-code">[fibonaccicalculator:57833]  classlist:  817.01 ms,    0.96 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]      (cap):  6,301.03 ms,  0.96 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]      setup:  9,946.35 ms,  0.96 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]   (clinit):  147.54 ms,    1.22 GB</p>
			<p class="source-code">[fibonaccicalculator:57833] (typeflow):  3,642.34 ms,  1.22 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]  (objects):  3,164.39 ms,  1.22 GB</p>
			<p class="source-code">[fibonaccicalculator:57833] (features):  181.00 ms,    1.22 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]   analysis:  7,282.44 ms,  1.22 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]   universe:  304.43 ms,    1.22 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]    (parse):  624.60 ms,    1.22 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]   (inline):  989.65 ms,    1.67 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]  (compile):  8,486.97 ms,  3.15 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]    compile:  10,625.01 ms, 3.15 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]      image:  869.81 ms,    3.15 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]  debuginfo:  1,078.95 ms,  3.15 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]      write:  2,224.22 ms,  3.15 GB</p>
			<p class="source-code">[fibonaccicalculator:57833]    [total]:  33,325.95 ms, 3.15 GB</p>
			<p>This will generate a <strong class="source-inline">sources</strong> directory, which <a id="_idIndexMarker484"/>holds the cache that is generated by the native image builder. This cache brings JDSK, GraalVM, and application classes to help with debugging. The following is the output of listing the contents of the <strong class="source-inline">sources</strong> directory:</p>
			<p class="source-code">$ ls -la                         </p>
			<p class="source-code">total 8</p>
			<p class="source-code">drwxr-xr-x     9 vijaykumarab    staff      288 17 Apr 09:01 .</p>
			<p class="source-code">drwxr-xr-x    10 vijaykumarab    staff      320 17 Apr 09:01 ..</p>
			<p class="source-code">-rw-r--r--     1 vijaykumarab    staff     1240 17 Apr 09:01 FibonacciCalculator.java</p>
			<p class="source-code">drwxr-xr-x     3 vijaykumarab    staff       96 17 Apr 09:01 com</p>
			<p class="source-code">drwxr-xr-x     5 vijaykumarab    staff      160 17 Apr 09:01 java.base</p>
			<p class="source-code">drwxr-xr-x     3 vijaykumarab    staff       96 17 Apr 09:01 jdk.internal.vm.compiler</p>
			<p class="source-code">drwxr-xr-x     3 vijaykumarab    staff       96 17 Apr 09:01 jdk.localedata</p>
			<p class="source-code">drwxr-xr-x     3 vijaykumarab    staff       96 17 Apr 09:01 jdk.unsupported</p>
			<p class="source-code">drwxr-xr-x     3 vijaykumarab    staff       96 17 Apr 09:01 org.graalvm.sdk</p>
			<p>To debug native images, we need the <strong class="source-inline">gdb</strong> utility. Please refer to <a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a> for how to install <strong class="source-inline">gdb</strong> for your target machine. Once properly installed, we <a id="_idIndexMarker485"/>should be able to enter the <strong class="source-inline">gdb</strong> shell by executing the <strong class="source-inline">gdb</strong> command. The following shows the typical output:</p>
			<p class="source-code">$ gdb                   </p>
			<p class="source-code">GNU gdb (GDB) 10.1</p>
			<p class="source-code">Copyright (C) 2020 Free Software Foundation, Inc.</p>
			<p class="source-code">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</p>
			<p class="source-code">This is free software: you are free to change and redistribute it.</p>
			<p class="source-code">There is NO WARRANTY, to the extent permitted by law.</p>
			<p class="source-code">Type "show copying" and "show warranty" for details.</p>
			<p class="source-code">This GDB was configured as "x86_64-apple-darwin20.2.0".</p>
			<p class="source-code">Type "show configuration" for configuration details.</p>
			<p class="source-code">For bug reporting instructions, please see:&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</p>
			<p class="source-code">Find the GDB manual and other documentation resources online at:</p>
			<p class="source-code">         &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</p>
			<p class="source-code">For help, type "help".</p>
			<p class="source-code">Type "apropos word" to search for commands related to "word".(gdb)</p>
			<p>We need to point to the <a id="_idIndexMarker486"/>directories where we generated the source files in the previous step. We can do that by executing the following command:</p>
			<p class="source-code">set directories /&lt;sources directory&gt;/jdk:/ &lt;sources directory&gt;/graal:/ &lt;sources directory&gt;/src</p>
			<p>Once the environment is set, we can use <strong class="source-inline">gdb</strong> to set the breakpoints and debug. Please refer to <a href="https://www.gnu.org/software/gdb/documentation/">https://www.gnu.org/software/gdb/documentation/</a> for detailed documentation on how to use <strong class="source-inline">gdb</strong> to debug executables.</p>
			<p>At the time of writing this book, debug information can be used to perform breakpoints, single-stepping, stack backtrace, printing primitive values, the casting and printing of objects, path expressions, and references by method name and static data. Please refer to <a href="https://www.graalvm.org/reference-manual/native-image/DebugInfo/">https://www.graalvm.org/reference-manual/native-image/DebugInfo/</a> for more details. </p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor114"/>Limitations of Graal AOT (Native Image)</h1>
			<p>In this section, we will go through <a id="_idIndexMarker487"/>some of the <a id="_idIndexMarker488"/>limitations of Graal AOT and native images.</p>
			<p>Graal ahead-of-time compilation performs static analysis with the closed-world assumption. It assumes that all the classes that are reachable at runtime are available during build time. This has a direct implication on writing any code that requires dynamic loading – such as Reflection, JNI, Proxies, and so on. However, the Graal AOT compiler (<strong class="source-inline">native-image</strong>) provides a <a id="_idIndexMarker489"/>way to provide this metadata in the form of JSON manifest files. These files can be packaged along with the JAR file, as an input for the compiler:</p>
			<ul>
				<li>Loading classes dynamically: Classes that are loaded at runtime, which will not be visible to the AOT compiler at build time, need to be specific in the configuration file. These <a id="_idIndexMarker490"/>configuration files are typically saved under <strong class="source-inline">META-INF/native-image/</strong>, and should be in <strong class="source-inline">CLASSPATH</strong>. If the class is not found during the compilation of the configuration file, it will throw a <strong class="source-inline">ClassNotFoundException</strong>.</li>
				<li>Reflection: Any call to the <strong class="source-inline">java.lang.reflect</strong> API to list the methods and fields or invoke them using the reflection API has to be configured in the <strong class="source-inline">reflect-config.json</strong> file under <strong class="source-inline">META-INF/native-image/</strong>. The compiler tries to identify these reflective elements through static analysis.</li>
				<li>Dynamic Proxy: Dynamic proxy classes that are generated instances of <strong class="source-inline">java.lang.reflect.Proxy</strong> need to be defined during build time. The interfaces need to be configured in proxy-config.json. </li>
				<li><strong class="bold">Java Native Interface</strong> (<strong class="bold">JNI</strong>): Like reflection, JNI also <a id="_idIndexMarker491"/>accesses a lot of class information dynamically. Even these calls need to be configured in <strong class="source-inline">jni-config.json.</strong></li>
				<li>Serialization: Java serialization also accesses a lot of class metadata dynamically. Even these accesses need to be configured ahead of time.</li>
			</ul>
			<p>You can find more details about the other limitations here: <a href="https://www.graalvm.org/reference-manual/native-image/Limitations/">https://www.graalvm.org/reference-manual/native-image/Limitations/</a>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor115"/>GraalVM containers</h1>
			<p>GraalVM also comes packaged as a Docker container. It can be directly pulled from the Docker Registry (<a href="http://ghcr.io">ghcr.io</a>) or can be used as a base image to build custom images. Here are some of the key commands to use GraalVM containers:</p>
			<ul>
				<li>To pull the <a id="_idIndexMarker492"/>Docker image: <strong class="source-inline">docker pull ghcr.io/graalvm/graalvm-ce:latest</strong></li>
				<li>To run the container: <strong class="source-inline">docker run -it ghcr.io/graalvm/graalvm-ce:latest bash</strong></li>
				<li>To use in the Dockerfile as a base image: <strong class="source-inline">FROM ghcr.io/graalvm/graalvm-ce:latest</strong></li>
			</ul>
			<p>We will be exploring <a id="_idIndexMarker493"/>more about GraalVM containers in <a href="B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169"><em class="italic">Chapter 9</em></a>, <em class="italic">GraalVM Polyglot – LLVM, Ruby, and WASM</em>, when we talk about building microservices on GraalVM.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor116"/>Summary</h1>
			<p>In this chapter, we went through Graal just-in-time and ahead-of-time compilers in detail. We took sample code and looked at how Graal JIT performs various optimizations. We also went through, in detail, how to understand Graal graphs. This is critical knowledge that will help in analyzing and identifying optimizations that we can do during development, to speed up Graal JIT compilation at runtime.</p>
			<p>The chapter provided detailed instructions on how to build native images, and how to optimize native images using profile-guided optimization. We took sample code and compiled native image, and also found out how a native image works internally. We identified code issues that might cause native images to run slower than just-in-time compilers. We also covered the limitations of native images, and when to use native images. We explored various build time and runtime configurations to optimize a build and running native images.</p>
			<p>In the next chapter, we will get into understanding the Truffle language implementation framework and how to build polyglot applications. </p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor117"/>Questions</h1>
			<ol>
				<li>How are native images created?</li>
				<li>What is points-to analysis?</li>
				<li>What is region analysis?</li>
				<li>What are the Serial GC and the G1 GC? </li>
				<li>How do you optimize native images? What is PGO?</li>
				<li>What are the limitations of native images?</li>
			</ol>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor118"/>Further reading</h1>
			<ul>
				<li>GraalVM Enterprise edition (<a href="https://docs.oracle.com/en/graalvm/enterprise/19/index.html">https://docs.oracle.com/en/graalvm/enterprise/19/index.html</a>)</li>
				<li>Graal VM Native Image documents (<a href="https://www.graalvm.org/reference-manual/native-image/">https://www.graalvm.org/reference-manual/native-image/</a>)</li>
			</ul>
		</div>
	</body></html>