- en: Creating an Application to List World Countries with their GDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring is an ecosystem that facilitates the development of JVM-based enterprise
    applications. And this is achieved using various modules provided by Spring. One
    of them, called Spring-core, is the heart of the framework in the Spring ecosystem,
    which provides support for dependency injection, web application, data access,
    transaction management, testing, and others.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start from scratch and use Spring Framework to develop
    a simple application. Familiarity with Spring Framework is not required and we
    will see to it that by the end of the chapter you should be confident enough to
    use Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the database structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the World Bank API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the wireframes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an empty application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the model classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the data access layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the API controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Tomcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will develop an application to show the GDP information of various countries.
    We will make use of the sample World DB ([https://dev.mysql.com/doc/world-setup/en/world-setup-installation.html](https://dev.mysql.com/doc/world-setup/en/world-setup-installation.html))
    available with MySQL to list the countries and get a detailed view to display
    the country information and its GDP information obtained from the World Bank API
    ([https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries)).
  prefs: []
  type: TYPE_NORMAL
- en: The listing will make use of the countries data available in the World DB. In
    the detail view, we will make use of data available in the World DB to list cities
    and languages, and make use of the World Bank API to get additional information and
    the GDP information about the country.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also support editing basic details of the country entry, adding and
    deleting cities from the country entry, and adding and deleting languages from
    the country entry. We will use the following tools and technologies in this application:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC framework for implementing the MVC pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interaction with the MySQL DB will be done using the Spring JDBC template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interaction with the World Bank API will be done using RestTemplate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The views will be created using a templating framework called Thymeleaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend will be driven by jQuery and Bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the database structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't have MySQL installed, head over to the MySQL link ([https://dev.mysql.com/downloads/installer](https://dev.mysql.com/downloads/installer))
    to install it and populate it with the world database, if it is not already available.
    The appendix will also guide you on how to run the queries using MySQL Workbench
    and MySQL command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The world database schema is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c6b1066-91ef-4e5c-9435-cedc3d0bcfa7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The database schema is simple, containing three tables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**city**: List of cities mapped to the three character country coded in the
    country table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**country**: List of countries where the primary key is the three character
    country code. There is a column that has the ISO country code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**countrylanguage**: List of languages mapped to the country with one of the
    languages of the country marked as official.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the World Bank API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of APIs exposed by the World Bank ([http://www.worldbank.org/](http://www.worldbank.org/))
    and the API documentation can be found here ([https://datahelpdesk.worldbank.org/knowledgebase/articles/889386-developer-information-overview](https://datahelpdesk.worldbank.org/knowledgebase/articles/889386-developer-information-overview)).
    Out of the available APIs, we will use the Indicator APIs ([https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries)),
    which represent information such as total population, GDP, GNI, energy use, and
    much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Indicator API, we will fetch the GDP information for the countries
    available in the database for the last 10 years. Let''s look at the API''s REST
    URL and the data returned by the API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `BR` is a country code (*Brazil*) in this URL. The `NY.GDP.MKTP.CD` is the
    flag used by the Word Bank API internally to call Indicator API. The request parameter, `date`,
    indicates the duration of which the GDP information is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The excerpt from the response you will get for the preceding API is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding response shows the GDP indicator in US$ for Brazil for the year
    2016.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the wireframes of application screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wireframe is the basic skeleton of an application or website. It gives an
    idea about how the final application looks. It basically helps to decide navigation
    flows, understand functionality, design the user interface, and helps in setting
    the expectation before the application even exists. This process greatly helps
    developers, designers, product owners, and clients to work in a synchronous manner
    to avoid any gap in between. We will follow the same model and we will design
    various wireframes of the application as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Country listing page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make it simple. The home page shows the country list with pagination,
    and allow searching by country name and filtering by continent/region. The following
    would be the home page of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/821768fe-363a-4c5f-9274-460a06f4bd32.png)'
  prefs: []
  type: TYPE_IMG
- en: Country detail page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This screen will show details of the country such as cities, languages, and
    the GDP information obtained from the World Bank API. The GDP data will be visible
    in a graphical view. The page looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b435b5fd-2731-4946-b34f-89bd0aabe494.png)'
  prefs: []
  type: TYPE_IMG
- en: Country edit page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In country listing page, there will be one button called **Edit**. On clicking
    it, the system will show the country in edit mode, enabling the update of the
    basic details of the country. The following is the view structure for editing
    the basic detail of a country:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d68ffe7-8d04-41c3-b543-c63c78a0a226.png)'
  prefs: []
  type: TYPE_IMG
- en: Add a new city and language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the country detail page, two modal views, one for adding a new city and
    another for adding a new language, are available by clicking on the New button. The
    following is the view for the two modal dialogs used to add a new country and
    language. They will be opened individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9a78694-069d-4b01-b51f-b21327824eb4.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating an empty application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Maven to generate an empty application with the structure required
    for Java-based web applications. If you do not have Maven installed, please follow
    the instructions here ([https://maven.apache.org/install.html](https://maven.apache.org/install.html))
    to install Maven. Once installed, run the following command to create an empty
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command will show the command-line argument values for
    confirmation as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f914bc77-a56b-4996-afb2-e033aff461e2.png)'
  prefs: []
  type: TYPE_IMG
- en: You would have to type in `Y` in the Command Prompt shown in the previous screenshot
    to complete the empty project creation. Now you can import this project into an
    IDE of your choice and continue with the development activity. For the sake of
    simplicity, we will use Eclipse, as it is among the most popular IDEs used by
    the Java community today.
  prefs: []
  type: TYPE_NORMAL
- en: 'On successful creation of the application, you will see the folder structure,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3b3a0ad-e578-412c-bd23-13511439466a.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see `index.jsp` added by default while creating the default project
    structure. You must delete it as, in this application, we will use Thymeleaf—another
    template engine to develop the landing page.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the model classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create Java classes to model the data in the database and also the
    data coming from the World Bank API. Our approach is simple. We will have one
    Java class for each table in our database and the columns of the database will
    become the properties of the Java class.
  prefs: []
  type: TYPE_NORMAL
- en: In the generated application, the `java` folder is missing under the `main`
    directory. We will manually create the `java` folder and package the  `com.nilangpatel.worldgdp`,
    which will be the root package for the application. Let's go ahead and implement
    the approach we decided on. But before that, let's see an interesting project
    called **Project Lombok**.
  prefs: []
  type: TYPE_NORMAL
- en: Project Lombok provides annotations for generating your getters, setters, default,
    and overloaded constructors, and other boilerplate code. More details on how to
    integrate with your IDE can be found on their project website ([https://projectlombok.org/](https://projectlombok.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to update our `pom.xml` to include a dependency on Project Lombok.
    The following are the parts of `pom.xml` you need to copy and add to relevant
    locations in the XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All the model classes that we are going to create next belong to the `com.nilangpatel.worldgdp.model` package. The
    model class to represent `Country` data is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `City` class is not created yet, let''s go ahead and create it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to model the `CountryLanguage` class, which is the language spoken
    in a country, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a model class to map the GDP information obtained from the World
    Bank API. Let''s go ahead and create a `CountryGDP` class as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, everything works perfectly fine. But when you start calling
    getter and setter of these model classes into some other class, you may get a
    compilation error. This is because we need to do one more step to configure Lombok.
    After you defined the Maven dependency, you will see the JAR reference from IDE.
    Just right-click on it and select the Run As* |* Java Application option. Alternatively,
    you can execute the following command from terminal at the location where the
    Lombok JAR file is kept, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `lombok-1.16.18.jar` is the name of JAR file. You will see a separate
    window pop up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d796b115-b20e-4fb2-b9b5-25beb17e150a.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the location of your IDE by clicking on the Specify location... button.
    Once selected, click on the Install / Update button to install it. You will get
    a success message. Just restart the IDE and rebuild the project and you will see
    that just by defining `@Setter` and `@Getter`, the actual setters and getters
    are available to other classes. You are no longer required to add them explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hibernate Validator to add validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few checks we need to add to our model classes so that the data
    being sent from the UI is not invalid. For this, we will make use of Hibernate
    Validator. You are required to add the Hibernate dependency as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go back to `com.nilangpatel.worldgdp.model.Country` and update it with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to update the `com.nilangpatel.worldgdp.model.City` class in a similar
    way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, update `com.nilangpatel.worldgdp.model.CountryLanguage` class
    as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Defining the data access layer – Spring JDBC Template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the model classes that reflect the structure of the data in the database that
    we obtained from the World Bank API. Now we need to develop a data access layer
    that interacts with our MySQL and populates the data stored in the database into
    instances of the model classes. We will use the Spring JDBC Template to achieve
    the required interaction with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need the JDBC driver to connect any Java application with MySQL.
    This can be obtained by adding the following dependency and version property to
    our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Wherever you see `<something.version>1.5.6</something.version>`, it should go
    within the `<properties></properties>` tag. Will not mention this repeatedly.
    This is for keeping the versions of libraries used in one place, making it easy
    to maintain and look up.
  prefs: []
  type: TYPE_NORMAL
- en: Anything that comes as `<dependency></dependency>` goes within the `<dependencies></dependencies>`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add a dependency to the Spring core APIs, as well as the Spring
    JDBC APIs (which contain the JDBC Template) to our `pom.xml`. A brief intro about
    these two dependencies is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring core APIs:** It provides us with core Spring features such as dependency
    injection and configuration model'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spring JDBC APIs:** It provides us with the APIs required to create the `DataSource` instance
    and interact with the database'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is a sample application, we aren't using Hibernate or other ORM libraries
    because they provide lots of functionalities apart from basic CRUD operations.
    Instead, we will write SQL queries and use them with JDBC Template to make things
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `dependency` information for the two libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the preceding two dependencies, we need to add a few more Spring
    dependencies to assist us in setting up Java-based configurations using annotations
    (such as `@bean`,  `@Service`, `@Configuration`, `@ComponentScan`, and so on)
    and dependency injection using annotations (`@Autowired`). For this, we will be
    adding further dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Defining the JDBC connection properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will define the JDBC connection properties in an `application.properties`
    file and place it in `src/main/resources`. The properties we define are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding properties are with the assumptions that MySQL is running on
    port `3306` and the database username and password are `root` and `test` respectively.
    You can change these properties as per your local configuration. The next step
    is to define a properties resolver that will be able to resolve the properties
    when used from within the code. We will use the `@PropertySource` annotation,
    along with an instance of  `PropertySourcesPlaceholderConfigurer`, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will follow the convention of placing all our configuration classes in `com.nilangpatel.worldgdp.config`
    and any root configuration will go in the `com.nilangpatel.worldgdp` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class reads all the properties from the `application.properties` file
    stored in classpath (`src/main/resources`). Next up is to configure a `javax.sql.DataSource`
    object that will connect to the database using the properties defined in the `application.properties`
    file. We will use the HikariCP connection pooling library for creating our `DataSource`
    instance. This `DataSource` instance is then used to instantiate `NamedParameterJdbcTemplate`.
    We will use `NamedParameterJdbcTemplate` to execute all our SQL queries. At this
    point, we need to add a necessary dependency for the HikariCP library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DBConfiguration` data source configuration class should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a quick introduction to a few new things used in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`@Configuration`:** This is to indicate to Spring Framework that this class
    creates Java objects that contain some configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`@Bean`:** This is method-level annotation, used to indicate to Spring Framework
    that the method returns Java objects whose life cycle is managed by Spring Framework
    and injected into places where its dependency is declared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`@Value`:** This is used to refer to the properties defined in the `application.properties`,
    which are resolved by the `PropertySourcesPlaceholderConfigurer` bean defined
    in the `PropertiesWithJavaConfig` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is always good practice to write unit test cases in JUnit. We will write
    test cases for our application. For that, we need to create the corresponding
    configuration classes for running our JUnit tests. In the next section, we will
    look at setting up the test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the test environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's adopt a test first approach here. So, before going into writing the queries
    and DAO classes, let's set up the environment for our unit testing. If you don't
    find the `src/test/java` and `src/test/resources` folders, then please go ahead
    and create them either from your IDE or from your OS file explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src/test/java` folder will contain all the Java code and `src/test/resources`
    will contain the required property files and other resources required for test
    cases. After creating the required folders, the project structure looks something
    like that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f495b7e-63f6-40f6-adc4-4b26af1833a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the H2 database as a source of data for our testing environment.
    For that, we will update our Maven dependencies to add H2 and JUnit dependencies.
    H2 is one of the most popular embedded databases. The following is the dependency
    information that you need to add in your `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We already have a property for `spring.version`, but we need version properties
    for the other two, as given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The World DB schema available in MySQL will not be compatible to run with H2,
    but don't worry. The compatible World DB schema for H2 is available in the source
    code of this chapter, you can download from GitHub ([https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01)).
    It is kept in the `src/test/resources` folder in the project. The file name is `h2_world.sql`.
    We will use this file to bootstrap our H2 database with the required tables and
    data that will then be available in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is to configure H2 and one of the things we configure is the name of
    the SQL script file that contains the schema and data. This SQL script file should
    be available on the classpath. The following is the configuration class created
    in the `com.nilangpatel.worldgdp.test.config` package under `src/test/java` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Along with the H2 configuration, we are initializing `NamedParameterJdbcTemplate`
    by providing it with the H2 datasource built in the other method.
  prefs: []
  type: TYPE_NORMAL
- en: We have added few other dependencies specific to JUnit. You can refer to them
    by downloading the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the RowMapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are using the JDBC Template, we need a way to map the rows of data from
    a database to a Java object. This can be achieved by implementing a `RowMapper`
    interface. We will define mapper classes for all the three entities. For `Country`,
    the raw mapper class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the mapper class for `City` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we define `CountryLanguage` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Designing the CountryDAO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and define the `CountryDAO` class in the `com.nilangpatel.worldgdp.dao` package along
    with the required methods, starting with the `getCountries` method. This method
    will fetch the details of countries to show them in the listing page. This method
    is also called while filtering the country list. Based on listing, filtering,
    and paginating, we have broken up the query used in this method into the following
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Search where clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Continent filter where clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Region filter where clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Pagination clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The placeholders defined by `:<<variableName>>` are replaced by the values
    provided in the `Map` to the `NamedParameterJdbcTemplate`. This way we can avoid
    concatenating the values into the SQL query, thereby avoiding chances of SQL injection.
    The `getCountries()` definition would now be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to implement the `getCountriesCount` method, which is similar to `getCountries`,
    except that it returns the count of entries matching the `WHERE` clause without
    the pagination applied. The implementation is as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the `getCountryDetail` method to get the detail of the country,
    given its code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In all of the previous DAO method implementations, we have made use of the `CountryRowMapper` we
    defined in the *Defining the RowMapper* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the method to allow editing the country information, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The previous method uses a helper method that builds a `Map` object, by using
    the data present in the `Country` object. We need the map, as we'll be using it
    as a parameter source for our `namedParamJdbcTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The helper method has a simple implementation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write our JUnit test for the `CountryDAO` class, which we haven''t created
    yet. Create `CountryDAOTest` class into the `com.nilangpatel.worldgdp.test.dao` package
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to note about configuring JUnit tests using the Spring
    test framework from the following test, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith` is used to replace the JUnit''s test runner with a custom test runner,
    which in this case, is Spring''s `SpringRunner`. Spring''s test runner helps in
    integrating JUnit with the Spring test framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SpringJUnitConfig` is used to provide the list of classes that contain the
    required configuration to satisfy the dependencies for running the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many people who choose ORM frameworks may feel that writing complicated SQL
    queries like this is awkward. However, from the next chapter onward, we'll start
    using the Spring Data framework to make an interaction with various data sources;
    the database is one of those accessed with the Spring Data JPA. Here, we wanted
    to show how the Spring JDBC offering interacts with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the CityDAO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the important operations to be supported by `com.nilangpatel.worldgdp.dao.CityDAO`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Get cities for a country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get city details for given ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new city to a country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the given city from the country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and implement each one of these functionalities starting with
    the `getCities`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using a paginated query to get a list of cities for a country. We will
    also need another overloaded version of this method where we return all the cities
    of a country and we will use this query to fetch all the cities while editing
    the country to select its capital. The overloaded version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to implement the method to get the city details, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the method to add a city as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw with adding a country, this will also make use of a helper method
    to return a `Map` from the `City` data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'An important thing to notice in `addCity` is the use of `KeyHolder` and `GeneratedKeyHolder` to
    return the generated (due to auto increment) primary key that is the `cityId`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we implement the method to delete a city from the country as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a test for `CityDAO`. Add the `CityDAOTest` class in `com.nilangpatel.worldgdp.test.dao` package under
    `src/test/java` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Designing the CountryLanguageDAO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to expose the following APIs to interact with the `countrylanguage`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: Get list of languages for a given country code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new language for a country by checking that the language doesn't already
    exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a language for a country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the sake of keeping it short, we will show the method implementations covering
    these three scenarios. The complete code can be found in the `com.nilangpatel.worldgdp.dao.CountryLanguageDAO` class
    available in the code downloaded for this book. The following is the code for
    these method implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Designing the client for World Bank API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to fetch the GDP data from WorldBank API. As we discussed, it is REST
    end point, where we have to send few parameters and will get the response. For
    this, we will use RestTemplate to make REST call. The following is the definition
    for the `com.packt.external.WorldBankApiClient` class, which is used to invoke
    the World Bank API and process its response to return `List<CountryGDP>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Defining the API controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have written code to interact with the DB. Next up is to work on
    the code for the controller. We will have both types of controller—one that returns
    the view name (Thymeleaf template in our case) with the data for the view populated
    in the model object, and the other that exposes the RESTful APIs. We will need
    to add the following dependency to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Adding `spring-webmvc` to the dependency will automatically include `spring-core`,
    `spring-beans`, and `spring-context` dependencies. So we can remove them from
    the `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Web MVC using @EnableWebMvc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to make use of the Spring MVC features, we need to have one class
    that has been annotated with `@Configuration`, to be annotated with `@EnableWebMvc`.
    The `@EnableWebMvc` annotation, imports the Spring MVC configuration from the `WebMvcConfigurationSupport`
    class present in the Spring MVC framework. If we need to override any of the default
    imported configuration, we would have to implement the `WebMvcConfigurer` interface
    present in the Spring MVC framework and override the required methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an `AppConfiguration` class with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous configuration, a few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableWebMvc`: This imports the Spring MVC related configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan`: This is used for declaring the packages that have to be scanned
    for Spring components (which can be `@Configuration`, `@Service`, `@Controller`,
    `@Component`, and so on). If no package is defined, then it scans starting from
    the package where the class is defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebMvcConfigurer`: We are going to implement this interface to override some
    of the default Spring MVC configuration seen in the previous code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration to deploy to Tomcat without web.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we will be deploying the application to Tomcat, we need to provide the servlet
    configuration to the application server. We will look at how to deploy to Tomcat
    in a separate section, but now we will look at the Java configuration, which is
    sufficient to deploy the application to Tomcat or any application server without
    the need for an additional `web.xml`. The Java class definition is given in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `AbstractAnnotationConfigDispatcherServletInitializer` abstract class is
    an implementation of the `WebApplicationInitializer` interface that is used to
    register Spring's `DispatcherServlet` instance and uses the other `@Configuration`
    classes to configure the `DispatcherServlet`.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to override the `getRootConfigClasses()`, `getServletConfigClasses()`,
    and `getServletMappings()` methods. The first two methods point to the configuration
    classes that need to load into the servlet context, and the last method is used
    to provide the servlet mapping for `DispatcherServlet`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DispatcherServlet` follows the front controller pattern, where there is a
    single servlet registered to handle all the web requests. This servlet uses the
    `RequestHandlerMapping` and invokes the corresponding implementation based on
    the URL mapped to the implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make a small update to the Maven WAR plugin so that it doesn''t
    fail if there is no `web.xml` found. This can be done by updating the `<plugins>` tag
    in the `pom.xml` file, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now we are all set to implement our controllers. We will show you how to deploy
    to Tomcat once we have implemented all the RESTful API controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the RESTful API controller for country resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define the RESTful API controller for the country resource. The following
    is the template for the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few things to note from the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RestController`: This is used to annotate a class as a controller with each
    of the RESTful methods returning the data in the response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping`: This is for assigning the root URL for accessing the resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping` and `@PostMapping`: These are used to assign the HTTP verbs that
    will be used to invoke the resources. The URL for the resources are passed within
    the annotation, along with other request headers that consume and produce information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement each of the methods in order, starting with `getCountries()`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some of the things to note from the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestParam`: This annotation is used to declare request parameters accepted
    by the controller endpoint. The parameters can be provided with a default value
    and can also be made mandatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResponseEntity`: This class is used to return the response body, along with
    other response parameters such as status, headers, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next up is the API for editing country details, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few things to note from the previous code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@PathVariable`: This is used to declare any variable that needs to be part
    of the URL path of the controller endpoint. In our case, we want the country code
    to be part of the URL. So the URL will be of the `/api/countries/IND` form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Valid`: This triggers the Bean Validation API to check for the restrictions
    on each of the class properties. If the data from the client is not valid, it
    returns a 400.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestBody`: This is used to capture the data sent in the request body and
    the `Jackson` library is used to convert the JSON data in the request body to
    the corresponding Java object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the API implementation can be found in the `CountryAPIController`
    class. The tests for the API controller can be found in the `CountryAPIControllerTest`
    class, which is available in the source code of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the RESTful API controller for city resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the city resource we would need the following APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Get cities for a given country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new city to the country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the city from the country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this controller can be found in the `CityAPIController` class and
    the tests for the API controller can be found in the `CityAPIControllerTest` class, which
    is available in the source code of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the RESTful API controller for country language resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the `CountryLanguage` resource we need the following APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Get languages for a country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a language for a country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a language from the country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this controller can be found in the `CountryLanguageAPIController`
    class and the tests for the API controller can be found in the `CountryLanguageAPIControllerTest` class,
    which is available in the source code of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Tomcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with View and Controller for handling views, we will deploy
    the app developed so far to Tomcat. You can download Tomcat 8.5 from here ([https://tomcat.apache.org/download-80.cgi](https://tomcat.apache.org/download-80.cgi)).
    Installation is as simple as extracting the ZIP/TAR file onto your file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a user `admin` and `manager-gui` role in Tomcat. To do this,
    have to edit `apache-tomcat-8.5.23/conf/tomcat-users.xml` and add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting up Tomcat is simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `apache-tomcat-8.5.23/bin`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `startup.bat`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to `http://localhost:8080/manager/html` and enter `admin`, and `admin`
    for username and password respectively, to be able to view Tomcat''s manager console.
    The initial part of the page will list the applications deployed in the current
    instance, and toward the later part of the page you will find an option to upload
    a WAR file to deploy the application, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c21e48b-e79b-4804-a73c-91ec6b6abaa9.png)'
  prefs: []
  type: TYPE_IMG
- en: We can either upload the WAR file generated after running `mvn package` or update
    the `server.xml` of the Tomcat instance to refer to the target directory of the
    project to be able to deploy automatically. The latter approach can be used for
    development, while the former that is WAR deployment can be used for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a production system, you can have a continuous deployment server generate
    a WAR file and deploy to a remote Tomcat instance. In this scenario, we will use
    the latter approach of updating the Tomcat''s configuration. You have to add the
    following line of code in the Tomcat''s `server.xml` file, located at `TOMCAT_HOME/conf/server.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line has to be added between the `<Host></Host>` tags. Alternatively,
    you can configure Tomcat in your IDE (for example, Eclipse), which is more convenient
    for development purposes. We will build the project with Maven, but before that,
    please add following configuration to the `<properties></properties>` section
    of `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make sure to choose the correct Java compiler version while building
    (packaging) the application with Maven from the command line. Next is to build
    the project using the `mvn package` and run Tomcat using `TOMCAT_HOME/bin/startup.bat`,
    and once the server is UP, you can visit the API `http://localhost:8080/worldgdp/api/countries`
    in the browser to see the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/253a8a32-c15a-418a-8929-a9e7717d2c0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Defining the view controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will have one view controller, `ViewController.java` defined in the `com.nilangpatel.worldgdp.controller.view`.
    The view controller will be responsible for populating the data required for the
    view templates and also mapping URLs to corresponding view templates.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Thymeleaf ([www.thymeleaf.org](https://www.thymeleaf.org/))
    as the server-side template engine and Mustache.js ([https://github.com/janl/mustache.js](https://github.com/janl/mustache.js))
    as our client-side template engine. The advantage of using a client-side template
    engine is that any data loaded asynchronously in the form of JSON can easily be
    added to the DOM by generating HTML using the client-side templates. We will explore
    more about Thymeleaf and Mustache.js in [Chapter 3](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml), *Blogpress
    – A simple blog management system*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are much better ways to do this by using frameworks such as Vue.js, React.js,
    Angular.js, and so on. We will look at the view template in the next section. Let''s
    continue our discussion about the view controller. The view controller should
    map the right view template and the data for the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing of countries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing country detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing country detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following skeletal structural definition of the `ViewController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few important things from the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Controller`: This annotation is used to declare a controller that can return
    view template names to be able to render the view, as well as returning JSON/XML
    data in the response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ResponseBody`: This annotation when present on the method of the controller
    indicates that the method is going to return the data in the response body, and
    hence, Spring will not use the view resolver to resolve the view to be rendered.
    The `@RestController` annotation by default adds this annotation to all its methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model`: This instance is used to pass on the data required for building the
    view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case of the listing of countries, the complete HTML is rendered at the server
    using the Thymeleaf template engine, so we need to obtain the request parameters,
    if any are present in the URL, and obtain a filtered and paginated list of the
    countries. We also need to populate the lookups that is the data for the `<select>`
    controls, which will be used for filtering the data. Let''s look at its implementation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is pretty straightforward. We are making use of the DAO classes
    to populate the required data into the `Model` instance and then returning the
    view name, which in this case is `countries`. Similarly, the rest of the method
    implementation can be found in the `ViewController` controller class.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the view templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the Thymeleaf template engine for handling server-side templates.
    Thymeleaf provides various dialects and conditional blocks for rendering the dynamic
    content within the static HTML. Let''s look at some simple syntactical element
    of Thymeleaf, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: From the previous examples, we can observe that the items to be evaluated by
    Thymeleaf are prefixed with `th:` and any content to be rendered between the tags
    can be done either using `th:text` or `[[${variable}]]`. The latter syntax has
    been introduced in Thymeleaf 3\. This was a very short primer, as going in to
    depth on Thymeleaf is out of the scope of this book. A beautiful guide explaining
    different parts of the template can be found at [http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html](http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Thymeleaf template engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the Thymeleaf template engine with Spring MVC, we need to do
    some configuration wherein we set up the Thymeleaf template engine and update
    Spring''s view resolver to use the template engine to resolve any views. Before
    moving further, we need to define required dependencies in `pom.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the configuration view resolver in order, starting with setting
    up the template resolver as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous configuration sets the template location that the template engine
    will use to resolve the template files. Next is to define the template engine,
    which will make use of `SpringTemplateEngine` and the template resolver defined
    earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the previous configuration, we make use of the Thymeleaf Layout Dialect ([https://github.com/ultraq/thymeleaf-layout-dialect](https://github.com/ultraq/thymeleaf-layout-dialect))
    created by *Emanuel Rabina*. This layout dialect helps us in creating a view decorator
    framework wherein all the templates will be decorated with a base template and
    the decorated templates just provide the necessary content to complete the page.
    So all the headers, footers, CSS, scripts, and other common HTML can be placed
    in the base template. This prevents redundancy to a great extent. In our sample
    app, the `base.html` file present in `worldgdp/src/main/resources/templates` is
    the base template that is used by other templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is to define a Thymeleaf view resolver that will override Spring''s default
    view resolver, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The previous configuration is available in the `com.packt.config.ViewConfiguration`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Managing static resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look back at the `com.nilangpatel.worldgdp.AppConfiguration` class,
    you will see that we have overridden the `addResourceHandlers` method of `WebMvcConfigurer`
    interface. In the method implementation shown in the following code, we have mapped
    the static resources prefix URL `/static/**` to the static resources location
    `/static/` in the `webapp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We have added a few static resources (both CSS and JavaScript) in the `/src/main/webapp/static`
    folder of the project. Please download the code of this chapter and refer to them
    side by side.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the base template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned before that we will be using the Thymeleaf Layout Dialect to create
    a base template and use the base template to decorate all other templates. The
    base template will contain all the CSS links, JavaScript source file links, the
    header, and the footer, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The two main important parts of the following template are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<div layout:fragment="page_content"></div>`: The other templates that use
    the base template as decorator provide their HTML within this section. Thymeleaf
    Layout Dialect at runtime decorates this HTML with the content from the base template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<th:block layout:fragment="scripts"></th:block>`: Similar to the HTML previous
    content, any page-specific JavaScript or links to any specific JavaScript source
    files can be added within this section. This helps in isolating page-specific
    JavaScript in their own pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any template that wants to use the base template as the decorator will declare
    this attribute, `layout:decorate="~{base}"`, in the `<html>` tag. We will not
    go into the content of individual templates as it''s mostly HTML. All the templates
    can be found at the location `worldgdp/src/main/resources/templates`. We have
    three templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`countries.html`: This is for showing the countries'' list with filtering and
    pagination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`country-form.html`: This is for editing a country''s detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`country.html`: This is for showing a country''s detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump into the rest of the steps to develop an application, it is
    good practice to define a log level and format. It is, however, optional but good
    practice to print the logs in a desired format, along with various logging levels.
    For this, add an XML file called `logback.xml` with following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Logback was developed as a successor to the popular Log4j project, and is used
    as a logging framework for Java applications. This configuration defines the pattern,
    along with the logging level. To enable logback in your application, you need
    to add following dependencies to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have already configured the deployment to Tomcat, you should have the
    application running now. You can always download the source code for this book;
    find the source code under the `worldgdp` folder. After downloading, you have
    to build it using Maven, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will run the tests as well. The WAR file `worldgdp.war`,
    present in the `target`, can be uploaded to Tomcat through the Manager app or
    copied to the `TOMCAT_HOME/webapps` folder. Tomcat will then explode the archive
    and deploy the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the screenshots of the application in action, starting
    with the listing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea8a1112-6b0f-4c4e-b506-465aa9138f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next is the page that displays the country details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f99e0a4f-5bf4-494c-928b-23fadf61b223.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The form that is used to edit the country details is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/945cadbf-de57-4099-8259-b4c044f59bc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we have popups that are used to add a new city to the country, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00f915d1-38c2-428d-bec6-a22d2df2df8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we have another popup to add a new country language, as shown in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07f46f66-80d6-40ef-aff2-09fbf2303055.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is designed with the aim of kick-starting your work with the Spring
    Framework. We have covered various topics, starting from scratch to create a project
    structure and design the view templates. It comprises various technologies and
    tools to build web-based applications in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: It is always good practice to do more hands-on exercises to understand the concepts
    in detail. Next, you can think of enhancing the application further by adopting
    a few other World Bank APIs and integrate them in to this application. In this
    chapter, we have configured most of the things with our own.
  prefs: []
  type: TYPE_NORMAL
- en: However, Spring provides a tool called **Spring Boot**, which really helps in
    doing most of the configuration in an automated manner, allowing you to focus
    on developing the application. In subsequent chapters, we will explore how to
    use Spring Boot for developing web applications in Spring in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore another great feature called Reactive Programming
    in Spring Framework using WebFlux. We will learn the basics of the Reactive paradigm,
    what are the benefits, and explore various Reactive libraries. Spring uses `Reactor`—a
    library that provides implementation of Reactive Stream to develop web-based applications.
    So, get ready to explore all those new and exciting topics in the second chapter.
  prefs: []
  type: TYPE_NORMAL
