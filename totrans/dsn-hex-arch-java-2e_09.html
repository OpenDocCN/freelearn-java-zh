<html><head></head><body>
<div id="_idContainer064">
<h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.2.1">Applying Dependency Inversion with Java Modules</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we learned how to develop each hexagon as a Java module. </span><span class="koboSpan" id="kobo.3.2">By doing that, we started to enforce the scope and responsibilities of each hexagon in the architecture. </span><span class="koboSpan" id="kobo.3.3">However, we did not go too far in exploiting the Java module’s features, such as encapsulation and dependency inversion, and how these features can enhance the overall structure of a hexagonal system by making it more robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">loosely coupled.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">To understand the role that’s played by the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Java Platform Module System</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">JPMS</span></strong><span class="koboSpan" id="kobo.9.1">) in developing a hexagonal system, we need to understand what problems the JPMS aims to solve. </span><span class="koboSpan" id="kobo.9.2">Once we know what we can do with the JPMS in terms of encapsulation and dependency inversion, we can apply these techniques in conjunction with the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">hexagonal architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">So, in this chapter, we will learn how to combine the JPMS with the hexagonal architecture to create a well-encapsulated system with clearly defined boundaries that are reinforced by the system’s modular structure and dependency inversion techniques. </span><span class="koboSpan" id="kobo.11.2">We’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the JPMS</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Inverting dependencies on a </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">hexagonal application</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Using the Java platform’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.19.1"> class to retrieve JPMS </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">provider implementations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">By the end of this chapter, you will have learned how to use services, consumers, and providers from the JPMS to apply dependency inversion and encapsulation principles for a </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">hexagonal system.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To compile and run the code examples presented in this chapter, you will need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.26.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.28.1"> installed on your computer. </span><span class="koboSpan" id="kobo.28.2">They are both available for the Linux, macOS, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.34.1">Introducing the JPMS</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Before </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">Java SE 9</span></strong><span class="koboSpan" id="kobo.37.1">, the only mechanism</span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.38.1"> we had to handle dependencies in Java was the </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">classpath</span></strong><span class="koboSpan" id="kobo.40.1"> parameter. </span><span class="koboSpan" id="kobo.40.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">classpath</span></strong><span class="koboSpan" id="kobo.42.1"> parameter is where we put dependencies in the form of </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">JAR files</span></strong><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">However, the</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.45.1"> problem is that there is no way to determine which JAR file a particular dependency came from. </span><span class="koboSpan" id="kobo.45.2">If you have two classes with the same name, in the same package, and present in two different JAR files, one of the JAR files would be loaded first, causing one JAR file to be shadowed by </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">the other.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.47.1">Shadowing</span></strong><span class="koboSpan" id="kobo.48.1"> is the term </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.49.1">we use to refer to a situation where two or more JAR files that contain the same dependency are put into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">classpath</span></strong><span class="koboSpan" id="kobo.51.1"> parameter, but only one of the JAR files is loaded, shadowing the rest. </span><span class="koboSpan" id="kobo.51.2">This JAR dependency entanglement issue is also known as </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">JAR hell</span></strong><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">A</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.54.1"> symptom that indicates that things are not so good with dependencies that have been loaded into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">classpath</span></strong><span class="koboSpan" id="kobo.56.1"> parameter is when we see unexpected </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">ClassNotFoundException</span></strong><span class="koboSpan" id="kobo.58.1"> exceptions at </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">system runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The JPMS cannot completely prevent JAR hell issues related to dependency version mismatches and shadowing. </span><span class="koboSpan" id="kobo.60.2">Still, the modular approach helps us have a better view of the dependencies that are needed by a system. </span><span class="koboSpan" id="kobo.60.3">This broader dependency perspective is helpful to prevent and diagnose such </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">dependency issues.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Before the JPMS, there was no way to control access to public types from different JAR files. </span><span class="koboSpan" id="kobo.62.2">The default </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.63.1">behavior of a </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">Java Virtual Machine</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">JVM</span></strong><span class="koboSpan" id="kobo.67.1">) is to always make these public types available between other JAR files, which often leads to collisions involving classes with the same name </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">and package.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">The JPMS introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">module</span></strong><span class="koboSpan" id="kobo.71.1"> path and a strict encapsulation policy that restricts, by default, access to all public types between different modules. </span><span class="koboSpan" id="kobo.71.2">No longer can all public types be accessed from other dependencies. </span><span class="koboSpan" id="kobo.71.3">With the JPMS, </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">module</span></strong><span class="koboSpan" id="kobo.73.1"> has to state which packages that contain public types are available to other modules. </span><span class="koboSpan" id="kobo.73.2">We did that by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">exports</span></strong><span class="koboSpan" id="kobo.75.1"> directive on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">domain</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.77.1">hexagon module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
module domain {
    exports dev.davivieira.topologyinventory.domain.entity;
    exports dev.davivieira.topologyinventory.domain.entity
      .factory;
    exports dev.davivieira.topologyinventory.domain
      .service;
    exports dev.davivieira.topologyinventory.domain
      .specification;
    exports dev.davivieira.topologyinventory.domain.vo;
    requires static lombok;
}</span></pre> <p><span class="koboSpan" id="kobo.79.1">Then, to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">domain</span></strong><span class="koboSpan" id="kobo.81.1"> hexagon module, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">requires</span></strong><span class="koboSpan" id="kobo.83.1"> directive</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.84.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">application</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.86.1">hexagon module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
module application {
    requires domain;
}</span></pre> <p><span class="koboSpan" id="kobo.88.1">This modularization mechanism assembles code in a new Java construct called </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">module</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">As we saw previously, </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">module</span></strong><span class="koboSpan" id="kobo.92.1"> may have to determine which package it intends to export and which other modules it requires. </span><span class="koboSpan" id="kobo.92.2">In this arrangement, we have more control over the things our application exposes </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">and consumes.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">If you’re targeting development on cloud-based environments and care for performance and cost, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">module</span></strong><span class="koboSpan" id="kobo.96.1"> system’s nature allows you to construct a customized Java runtime (known in the past as </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">JRE</span></strong><span class="koboSpan" id="kobo.98.1">) containing just the modules required to run the application. </span><span class="koboSpan" id="kobo.98.2">With a smaller Java runtime, both the application startup time and memory usage will decrease. </span><span class="koboSpan" id="kobo.98.3">Let’s say we’re talking about hundreds – even thousands – of Kubernetes pods running Java in the cloud. </span><span class="koboSpan" id="kobo.98.4">With a smaller Java runtime, we can achieve a considerable economy regarding computational </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">resource consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Now that we are more acquainted with the JPMS’s motivations and benefits, let’s go back to developing our</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.101.1"> topology and inventory system. </span><span class="koboSpan" id="kobo.101.2">We will learn how to use more advanced JPMS features to enhance encapsulation and adherence to dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">inversion principles.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.103.1">Inverting dependencies on a hexagonal application</span></h1>
<p><span class="koboSpan" id="kobo.104.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">dependency inversion principle</span></strong><span class="koboSpan" id="kobo.106.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.107.1">DIP</span></strong><span class="koboSpan" id="kobo.108.1">), as introduced by Robert C. </span><span class="koboSpan" id="kobo.108.2">Martin, states that high-level </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.109.1">components should not depend on low-level components. </span><span class="koboSpan" id="kobo.109.2">Instead, both of them should depend on abstractions. </span><span class="koboSpan" id="kobo.109.3">At first glance, for some, it may not be so obvious to understand such a concept. </span><em class="italic"><span class="koboSpan" id="kobo.110.1">After all, what do the high- and low-level components mean?</span></em> <em class="italic"><span class="koboSpan" id="kobo.111.1">And what kind of abstractions are we </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.112.1">talking about?</span></em></span></p>
<p><span class="koboSpan" id="kobo.113.1">A high-level component has a </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.114.1">set of operations orchestrated to enable a major system behavior. </span><span class="koboSpan" id="kobo.114.2">A high-level component may rely on low-level components to provide a major system behavior. </span><span class="koboSpan" id="kobo.114.3">A low-level component, in turn, utilizes a specialized behavior that supports the goals of a high-level component. </span><span class="koboSpan" id="kobo.114.4">We call a piece of client code that acts as the high-level component because it depends on and consumes the functionalities provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">low-level component.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">The high-level component can be either a concrete or abstract element, while the low-level component should be concrete because it always provides </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">implementation details.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">Let’s consider some client code as a high-level component that calls methods on a serving code. </span><span class="koboSpan" id="kobo.118.2">The serving code, in turn, can be regarded as a low-level component. </span><span class="koboSpan" id="kobo.118.3">This low-level component contains the implementation details. </span><span class="koboSpan" id="kobo.118.4">In procedural programming designs, it’s common to see high-level components depending directly on the implementation details provided by low-level components. </span><span class="koboSpan" id="kobo.118.5">Martin says that this direct dependency on implementation details is bad because it makes the system rigid. </span><span class="koboSpan" id="kobo.118.6">For example, if we change these implementation details on the low-level components, such changes can cause immediate problems for the high-level components that depend directly on them. </span><span class="koboSpan" id="kobo.118.7">That’s where this rigidity comes from: we cannot change one part of the code without causing side effects in </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">other parts.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">To invert the dependency, we need to make the high-level component depend on the same abstraction that the low-level component is derived from. </span><span class="koboSpan" id="kobo.120.2">In object-oriented designs, we can achieve this feat by using abstract classes or interfaces. </span><span class="koboSpan" id="kobo.120.3">The low-level component implements an abstraction, whereas the high-level component refers to that abstraction instead of the low-level implementation. </span><span class="koboSpan" id="kobo.120.4">So, this is what we have to do to invert the </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">dependencies properly.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">The JPMS introduced a</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.123.1"> mechanism to help us avoid this dependency on implementation details. </span><span class="koboSpan" id="kobo.123.2">This mechanism is based on consumers, services, and providers. </span><span class="koboSpan" id="kobo.123.3">In addition to these three JPMS elements, there is one more, already known in previous Java versions, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.125.1">, which enables the system to find and retrieve implementations of a </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">given abstraction.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">We call a consumer with a module that declares the need to consume a service provided by a provider module through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">uses</span></strong><span class="koboSpan" id="kobo.129.1"> directive. </span><span class="koboSpan" id="kobo.129.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">uses</span></strong><span class="koboSpan" id="kobo.131.1"> directive states the name of an interface or abstract class that represents the service we intend to use. </span><span class="koboSpan" id="kobo.131.2">The service, in turn, is the object that implements the interface or extends the abstract class that’s informed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">uses</span></strong><span class="koboSpan" id="kobo.133.1"> directive. </span><span class="koboSpan" id="kobo.133.2">The provider is a module that declares the service interface and its implementations with the providers and </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">directives, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Let’s see how we can use the JPMS to apply this DIP to our hexagonal system, topology, and inventory. </span><span class="koboSpan" id="kobo.135.2">We’ll also see a representation for inverting dependencies using input adapters, use cases, and </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">input ports.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.137.1">Providing services with use cases and input ports</span></h2>
<p><span class="koboSpan" id="kobo.138.1">When developing the </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.139.1">topology and inventory system, we designed use cases as interfaces and input ports as implementations for these interfaces. </span><span class="koboSpan" id="kobo.139.2">We can consider use cases and input ports as hexagonal architecture components that match the JPMS definition for a service. </span><span class="koboSpan" id="kobo.139.3">The Application hexagon module can be regarded as the module that provides the service. </span><em class="italic"><span class="koboSpan" id="kobo.140.1">And what about the consumer?</span></em><span class="koboSpan" id="kobo.141.1"> The Framework hexagon module is the direct consumer of the Application </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">hexagon module.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">Based on that reasoning, we’ll re-implement both the Application and Framework hexagon modules so that the input adapters from the Framework hexagon will no longer need to depend on the input port implementations from the Application hexagon. </span><span class="koboSpan" id="kobo.143.2">Instead, the input adapters will only depend on the use case interface types, rather than the input ports’ concrete types. </span><span class="koboSpan" id="kobo.143.3">In such a context, we can regard input adapters as high-level components and input ports as low-level components. </span><span class="koboSpan" id="kobo.143.4">Input adapters refer to use case interfaces. </span><span class="koboSpan" id="kobo.143.5">Input</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.144.1"> ports implement these use cases. </span><span class="koboSpan" id="kobo.144.2">The following diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">illustrates this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.146.1"><img alt="Figure 9.1 – Dependency inversion with an input adapter, use case, and input port" src="image/B19777_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.147.1">Figure 9.1 – Dependency inversion with an input adapter, use case, and input port</span></p>
<p><span class="koboSpan" id="kobo.148.1">The preceding diagram illustrates how we can approach dependency inversion in the hexagonal architecture. </span><span class="koboSpan" id="kobo.148.2">This example considers the dependency inversion between the Framework and Application hexagons, but we can do the same thing with the Domain hexagon </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">Let’s consider how </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">RouterManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.152.1"> is currently accessing the implementation details instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the abstraction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.154.1">
private RouterManagementUseCase;
public RouterManagementGenericAdapter(){
    setPorts();
}
private void setPorts(){
    this.routerManagementUseCase = new
      RouterManagementInputPort(
            RouterManagementH2Adapter.getInstance()
    );
}</span></pre> <p><span class="koboSpan" id="kobo.155.1">By calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">new RouterManagementInputPort(RouterManagementH2Adapter.getInstance())</span></strong><span class="koboSpan" id="kobo.157.1">, we are making the input adapter depend on the implementation details of both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.159.1"> input port and the output adapter expressed </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">RouterManagementH2Adapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">To make an input </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.164.1">port class eligible to be used as a provider class in the JPMS, we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.166.1">First, we must add a </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">no-arguments constructor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.168.1">
@NoArgsConstructor
public class RouterManagementInputPort implements
  RouterManagementUseCase {
/** Code omitted **/
}</span></pre></li> <li><span class="koboSpan" id="kobo.169.1">Then, we must declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.171.1"> method in the use </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">case interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.173.1">
public interface RouterManagementUseCase {
    void setOutputPort(
    RouterManagementOutputPort
      routerManagementOutputPort);
}</span></pre></li> <li><span class="koboSpan" id="kobo.174.1">Lastly, we must implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.176.1"> method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">input port:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.178.1">
@Override
public void setOutputPort(RouterManagementOutputPort
  routerManagementOutputPort) {
    this.routerManagementOutputPort =
    routerManagementOutputPort;
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.179.1">Now, we can update the</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.180.1"> Application hexagon’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">module</span></strong><span class="koboSpan" id="kobo.182.1"> descriptor to define the services that we’ll provide by using the use case interfaces and their input </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">port’s implementations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
module application {
    requires domain;
    requires static lombok;
    exports dev.davivieira.topologyinventory.application
      .ports.
</span><span class="koboSpan" id="kobo.184.2">    input;
    exports dev.davivieira.topologyinventory.application
      .ports.
</span><span class="koboSpan" id="kobo.184.3">    output;
    exports dev.davivieira.topologyinventory.application
      .usecases;
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.185.1">We start by declaring the dependency that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">application</span></strong><span class="koboSpan" id="kobo.187.1"> module has on the Domain hexagon and </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">lombok</span></strong><span class="koboSpan" id="kobo.189.1"> modules. </span><span class="koboSpan" id="kobo.189.2">Then, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">exports</span></strong><span class="koboSpan" id="kobo.191.1"> to enable access to the input ports, output ports, and </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Next, we must declare the services we want to provide. </span><span class="koboSpan" id="kobo.193.2">We can accomplish this service declaration by providing</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.194.1"> a use case interface and the input port that implements it. </span><span class="koboSpan" id="kobo.194.2">Let’s declare the service provider for </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">router management:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
    provides dev.davivieira.topologyinventory.application
      .usecases.
</span><span class="koboSpan" id="kobo.196.2">    RouterManagementUseCase
    with dev.davivieira.topologyinventory.application.ports
      .input.
</span><span class="koboSpan" id="kobo.196.3">    RouterManagementInputPort;</span></pre> <p><span class="koboSpan" id="kobo.197.1">In the preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.199.1"> is being provided </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">RouterManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Next, we must define the service provider for </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">switch management:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
    provides dev.davivieira.topologyinventory.application
      .usecases.
</span><span class="koboSpan" id="kobo.205.2">    SwitchManagementUseCase
    with dev.davivieira.topologyinventory.application.ports
      .input.
</span><span class="koboSpan" id="kobo.205.3">    SwitchManagementInputPort;</span></pre> <p><span class="koboSpan" id="kobo.206.1">In the preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.208.1"> is being provided </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">SwitchManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Finally, we must declare the service provider for </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">network management:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
    provides dev.davivieira.topologyinventory.application
      .usecases.
</span><span class="koboSpan" id="kobo.214.2">    NetworkManagementUseCase
    with dev.davivieira.topologyinventory.application.ports
      .input.
</span><span class="koboSpan" id="kobo.214.3">    NetworkManagementInputPort;</span></pre> <p><span class="koboSpan" id="kobo.215.1">Here, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.217.1"> being provided </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">NetworkManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">Before we learn </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.222.1">how to access these input ports through JPMS services in input adapters, let’s learn how we can invert dependencies when working with output ports and </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">output adapters.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.224.1">Providing services with output ports and output adapters</span></h2>
<p><span class="koboSpan" id="kobo.225.1">In the Framework hexagon, we have output ports </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.226.1">as interfaces and output adapters as their implementations. </span><span class="koboSpan" id="kobo.226.2">Input ports depend on output ports. </span><span class="koboSpan" id="kobo.226.3">In that sense, input ports can be regarded as high-level components because they depend on the abstractions provided by output ports. </span><span class="koboSpan" id="kobo.226.4">Output adapters act as low-level components that provide implementations for output port abstractions. </span><span class="koboSpan" id="kobo.226.5">The following diagram shows an illustration of this dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">inversion arrangement:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.228.1"><img alt="Figure 9.2 – Dependency inversion with an input port, output port, and output adapter" src="image/B19777_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.229.1">Figure 9.2 – Dependency inversion with an input port, output port, and output adapter</span></p>
<p><span class="koboSpan" id="kobo.230.1">Note that both the input port and the output adapter point to the same output port abstraction. </span><span class="koboSpan" id="kobo.230.2">This means that we can use the JPMS to apply the dependency inversion principle with these </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">architecture components.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">However, there is one </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.233.1">requirement we have to meet to use output adapters as implementation providers. </span><span class="koboSpan" id="kobo.233.2">This requirement requires every provider class to have a public constructor with no parameters, which is not the case for the output adapters we implemented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">previous chapters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
private RouterManagementH2Adapter(){
    setUpH2Database();
}</span></pre> <p><span class="koboSpan" id="kobo.236.1">We implemented the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.238.1"> constructor as </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">private</span></strong><span class="koboSpan" id="kobo.240.1"> to enforce a singleton pattern. </span><span class="koboSpan" id="kobo.240.2">To show how to use this output adapter as a JPMS service provider, we need to disable the singleton pattern by changing the constructor’s access modifier from </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">private</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.242.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">public</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
public RouterManagementH2Adapter(){
    setUpH2Database();
}</span></pre> <p><span class="koboSpan" id="kobo.246.1">Now, we can update</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.247.1"> the framework hexagon’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">module</span></strong><span class="koboSpan" id="kobo.249.1"> (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">info.java</span></strong><span class="koboSpan" id="kobo.251.1"> file) to define </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
module framework {
    requires domain;
    requires application;
    /** Code omitted **/
    exports dev.davivieira.topologyinventory.framework
      .adapters.
</span><span class="koboSpan" id="kobo.253.2">    output.h2.data;
    opens dev.davivieira.topologyinventory.framework
      .adapters.
</span><span class="koboSpan" id="kobo.253.3">    output.h2.data;
    provides dev.davivieira.topologyinventory.application
      .ports.
</span><span class="koboSpan" id="kobo.253.4">    output.RouterManagementOutputPort
    with dev.davivieira.topologyinventory.framework
      .adapters.output.
</span><span class="koboSpan" id="kobo.253.5">    h2.RouterManagementH2Adapter;
    provides dev.davivieira.topologyinventory.application
      .ports.
</span><span class="koboSpan" id="kobo.253.6">    output.SwitchManagementOutputPort
    with dev.davivieira.topologyinventory.framework
      .adapters.output.
</span><span class="koboSpan" id="kobo.253.7">    h2.SwitchManagementH2Adapter;
}</span></pre> <p><span class="koboSpan" id="kobo.254.1">We start by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">requires</span></strong><span class="koboSpan" id="kobo.256.1"> directive to declare the module dependencies on the Domain and Application hexagon modules. </span><span class="koboSpan" id="kobo.256.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">exports</span></strong><span class="koboSpan" id="kobo.258.1"> directive to enable access to all public types in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">dev.davivieira.topologyinventory.framework.adapters.output.h2.data</span></strong><span class="koboSpan" id="kobo.260.1"> package. </span><span class="koboSpan" id="kobo.260.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">opens</span></strong><span class="koboSpan" id="kobo.262.1"> directive to allow runtime reflective access to the output adapters. </span><span class="koboSpan" id="kobo.262.2">We need this reflective access because of the</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.263.1"> database library dependencies that these output </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">adapters have.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Finally, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">provides</span></strong><span class="koboSpan" id="kobo.267.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">with</span></strong><span class="koboSpan" id="kobo.269.1"> directives to inform the output port interfaces, </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.271.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">SwitchManagementOutputPort</span></strong><span class="koboSpan" id="kobo.273.1">, along with their respective output adapter implementations, </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">RouterManagementH2Adapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.275.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">SwitchManagementH2Adapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">Now that we’ve completed the configuration that’s required to enable dependency inversion between the output ports and adapters, let’s learn how to configure input adapters to access dependencies through </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">their abstractions.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.280.1">Making the input adapters dependent on abstractions</span></h2>
<p><span class="koboSpan" id="kobo.281.1">The first step in consuming</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.282.1"> the services we have exposed with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">provides</span></strong><span class="koboSpan" id="kobo.284.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">with</span></strong><span class="koboSpan" id="kobo.286.1"> directives is to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">module</span></strong><span class="koboSpan" id="kobo.288.1"> descriptor of the consumer’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">framework</span></strong><span class="koboSpan" id="kobo.290.1"> hexagon module by utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">uses</span></strong><span class="koboSpan" id="kobo.292.1"> directive. </span><span class="koboSpan" id="kobo.292.2">We’ll execute the following steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">do so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.294.1">Let’s start by updating the </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">module descriptor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.296.1">
module framework {
    /** Code omitted **/
    uses dev.davivieira.topologyinventory.application
      .usecases
    .RouterManagementUseCase;
    uses dev.davivieira.topologyinventory.application
      .usecases
    .SwitchManagementUseCase;
    uses dev.davivieira.topologyinventory.application
      .usecases
    .NetworkManagementUseCase;
    uses dev.davivieira.topologyinventory.application
      .ports.output
    .RouterManagementOutputPort;
    uses dev.davivieira.topologyinventory.application
      .ports.output
    .SwitchManagementOutputPort;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.297.1">The first three </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">uses</span></strong><span class="koboSpan" id="kobo.299.1"> directives point to the services provided by the Application hexagon module. </span><span class="koboSpan" id="kobo.299.2">The</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.300.1"> last two </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">uses</span></strong><span class="koboSpan" id="kobo.302.1"> directives refer to the services we exposed in the Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">hexagon module.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.304.1">Now that we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">module</span></strong><span class="koboSpan" id="kobo.306.1"> descriptors adequately configured to allow the system to depend on interfaces instead of implementations, we need to refactor the input adapters so that they only rely on use case interfaces from the Application hexagon module and output the port interfaces from the Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">hexagon module.</span></span></p></li> <li><span class="koboSpan" id="kobo.308.1">First, we must configure the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">RouterManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1"> adapter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
public class RouterManagementGenericAdapter {
    private RouterManagementUseCase
      routerManagementUseCase;
    public RouterManagementGenericAdapter(
    RouterManagementUseCase routerManagementUseCase) {
        this.routerManagementUseCase =
          routerManagementUseCase;
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.312.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">RouterManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.314.1"> no longer depends on </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.316.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.318.1">, as it did previously. </span><span class="koboSpan" id="kobo.318.2">There is </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.319.1">only one dependency on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1"> interface.</span></span></p></li> <li><span class="koboSpan" id="kobo.322.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">SwitchManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.324.1"> input adapter, this is how we should configure </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the dependency:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.326.1">
public class SwitchManagementGenericAdapter {
    private SwitchManagementUseCase
      switchManagementUseCase;
    private RouterManagementUseCase
      routerManagementUseCase;
    public SwitchManagementGenericAdapter (
    RouterManagementUseCase,
    SwitchManagementUseCase switchManagementUseCase){
        this.routerManagementUseCase =
          routerManagementUseCase;
        this.switchManagementUseCase =
          switchManagementUseCase;
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.327.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">SwitchManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.329.1"> input adapter depends on both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.333.1"> use case interfaces</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.334.1"> to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">its activities.</span></span></p></li> <li><span class="koboSpan" id="kobo.336.1">To conclude, we have to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">NetworkManagementGenericA</span><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.338.1">dapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.339.1">adapter class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.340.1">
public class NetworkManagementGenericAdapter {
    private SwitchManagementUseCase
      switchManagementUseCase;
    private NetworkManagementUseCase
      networkManagementUseCase;
    public NetworkManagementGenericAdapter(
    SwitchManagementUseCase,
    NetworkManagementUseCase networkManagementUseCase) {
        this.switchManagementUseCase =
          switchManagementUseCase;
        this.networkManagementUseCase =
          networkManagementUseCase;
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.341.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">NetworkManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.343.1"> input adapter follows the same pattern we used in the previous input adapters and requires use case references in the input</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.344.1"> adapter’s constructor. </span><span class="koboSpan" id="kobo.344.2">Here, we’re making use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.346.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.348.1"> use </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">case interfaces.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.350.1">In this section, we touched on a crucial JPMS feature: service providers. </span><span class="koboSpan" id="kobo.350.2">By using them, we can bind input port implementations to the use case interfaces. </span><span class="koboSpan" id="kobo.350.3">That’s how we arrange the code. </span><span class="koboSpan" id="kobo.350.4">So, the input adapters can rely on use case abstractions to trigger operations on the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">Application hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Now, let’s learn how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.354.1"> to retrieve service implementations based on the JPMS providers we </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">have defined.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.356.1">Using the Java platform’s ServiceLoader class to retrieve JPMS provider implementations</span></h1>
<p><span class="koboSpan" id="kobo.357.1">So far, we have configured the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">module</span></strong><span class="koboSpan" id="kobo.359.1"> descriptor of the Application and Framework hexagon modules. </span><span class="koboSpan" id="kobo.359.2">We have refactored the input adapters so that they only depend on the abstractions provided by use case interfaces. </span><em class="italic"><span class="koboSpan" id="kobo.360.1">But how can we retrieve the concrete instances that implement those use case interfaces?</span></em><span class="koboSpan" id="kobo.361.1"> That’s exactly what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">ServiceLoader</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.363.1">class does.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.365.1"> is not a new class </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.366.1">made solely to support JPMS features. </span><span class="koboSpan" id="kobo.366.2">Instead, </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.368.1"> has been present in Java since version </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">1.6</span></strong><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">From </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">Java 9</span></strong><span class="koboSpan" id="kobo.372.1"> onward, this class was enhanced to work with the Java module’s services. </span><span class="koboSpan" id="kobo.372.2">It relies on the configuration provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">module</span></strong><span class="koboSpan" id="kobo.374.1"> descriptor to find implementations for a given service </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">provider interface.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">To illustrate how we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.378.1">, let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">FrameworkTestData</span></strong><span class="koboSpan" id="kobo.380.1"> test class by creating a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">loadPortsAndUseCases</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">This method uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.384.1"> to retrieve the objects we need to instantiate the input adapters. </span><span class="koboSpan" id="kobo.384.2">We need to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">loadPortsAndUseCases</span></strong><span class="koboSpan" id="kobo.386.1"> method because we’ll call it to initialize the input adapters through </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">Before creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">loadPortsAndUseCases</span></strong><span class="koboSpan" id="kobo.390.1"> method, we need to declare the input adapter variables that we’ll use to assign the objects that are instantiated with the aid </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">ServiceLoader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
public class FrameworkTestData {
  protected RouterManagementGenericAdapter
  routerManagementGenericAdapter;
  protected SwitchManagementGenericAdapter
  switchManagementGenericAdapter;
  protected NetworkManagementGenericAdapter
  networkManagementGenericAdapter;
  /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.395.1">The variables we’ve declared here are used to store references for the input adapters we’ll create using the input ports and output adapters objects that we obtained from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">ServiceLoader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Let’s start by</span><a id="_idIndexMarker639"/> <span class="No-Break"><span class="koboSpan" id="kobo.399.1">initializing </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">RouterManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.402.1">Initializing RouterManagementGenericAdapter</span></h2>
<p><span class="koboSpan" id="kobo.403.1">We will start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">loadPortsAndUseCases</span></strong><span class="koboSpan" id="kobo.405.1"> method’s implementation by using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.407.1"> instance to retrieve the objects that are </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.408.1">necessary for instantiating </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">RouterManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.410.1">. </span><span class="koboSpan" id="kobo.410.2">We’ll perform the following steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">do this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.412.1">The following code shows</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.413.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">loadPortsAndUseCases</span></strong><span class="koboSpan" id="kobo.415.1"> method’s </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">initial implementation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.417.1">
protected void loadPortsAndUseCases() {
  // Load router implementations
  ServiceLoader&lt;RouterManagementUseCase&gt;
    loaderUseCaseRouter =
  ServiceLoader.load(Route</span><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.418.1">rManagementUseCase.class);
  RouterManagementUseCase =
  loaderUseCaseRouter.findFirst().get();
  // Code omitted //
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.419.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">load</span></strong><span class="koboSpan" id="kobo.421.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.423.1"> receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">RouterManagementUseCase.class</span></strong><span class="koboSpan" id="kobo.425.1"> file as a parameter. </span><span class="koboSpan" id="kobo.425.2">This method can find all the implementations for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.427.1"> interface. </span><span class="koboSpan" id="kobo.427.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.429.1"> is the only implementation that’s available for the use case interface, we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">loaderUseCaseRouter.findFirst().get()</span></strong><span class="koboSpan" id="kobo.431.1"> to get </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">that implementation.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.433.1">Aside from a proper implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.435.1"> interface, we also need to provide an implementation for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">RouterManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> interface.</span></span></p></li> <li><span class="koboSpan" id="kobo.438.1">The following code </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.439.1">shows how to retrieve a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">RouterManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.441.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.442.1">
ServiceLoader&lt;RouterManagementOutputPort&gt; loaderOutpu
  tRouter =
ServiceLoader.load(RouterManagementOutputPort.class);
</span><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.443.1">RouterManagementOutputPort = loaderOutputRouter.find
  First().get();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.444.1">The call on </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">loaderOutputRouter.findFirst().get()</span></strong><span class="koboSpan" id="kobo.446.1"> retrieves a </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.448.1"> object, which is the only available implementation for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">RouterManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1"> interface.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.451.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.453.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.455.1"> objects </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.456.1">loaded from </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.458.1">, we have the required objects to create an input adapter. </span><span class="koboSpan" id="kobo.458.2">But first, we need to set up the output port for the </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">use case.</span></span></p></li> <li><span class="koboSpan" id="kobo.460.1">This is how we can set a </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.462.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.466.1">
routerManagementUseCase.setOutputPort(routerManagemen
  tOutputPort);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.467.1">By calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">routerManagementUseCase.setOutputPort(routerManagementOutputPort)</span></strong><span class="koboSpan" id="kobo.469.1">, we are setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">RouterManagementOutputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.471.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.474.1">Now, we can create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">RouterManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.476.1"> adapter by passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.478.1">, which we have just created, to </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">its constructor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.480.1">
this.route</span><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.481.1">rManagementGenericAdapter =
new RouterManagementGenericAdapter(routerManagemen
  tUseCase);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.482.1">Now, let’s move on </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.483.1">and learn how to </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">initialize </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">SwitchManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.487.1">Initializing SwitchManagementGenericAdapter</span></h2>
<p><span class="koboSpan" id="kobo.488.1">Still inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">loadPortsAndUseCases</span></strong><span class="koboSpan" id="kobo.490.1"> method, we need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.492.1"> to find an available</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.493.1"> implementation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.495.1">. </span><span class="koboSpan" id="kobo.495.2">We’ll perform</span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.496.1"> the following steps for the </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">same reason:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.498.1">In the following code, we are retrieving a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">SwitchManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.500.1"> implementation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.501.1">
ServiceLoader&lt;SwitchManagementUseCase&gt; loaderUseCas
  eSwitch = ServiceLoader.load(SwitchManagementUse
    Case.class);
SwitchManagementUseCase switchManagementUseCase =
  loaderUseCaseSwitch.findFirst().get();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.502.1">By calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">ServiceLoader.load(SwitchManagementUseCase.class)</span></strong><span class="koboSpan" id="kobo.504.1">, we are retrieving a </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.506.1"> object containing all the available implementations for </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">In our case, the only available implementation is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">SwitchManagementInputPort</span></strong><span class="koboSpan" id="kobo.510.1"> input port. </span><span class="koboSpan" id="kobo.510.2">To load such an implementation, we must </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">loaderUseCaseSwitch.findFirst().get()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.514.1">We also need an implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">SwitchManagementOutputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.516.1">output port.</span></span></p></li> <li><span class="koboSpan" id="kobo.517.1">The following code shows </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.518.1">how we can get a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">SwitchManagementOutputPort</span></strong></span><span class="No-Break"><strong class="source-inline"><a id="_idIndexMarker648"/></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1"> implementation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.521.1">
ServiceLoader&lt;SwitchManagementOutputPort&gt; loaderOut
  putSwitch = ServiceLoader.load(SwitchManagementOut
    putPort.class);
SwitchManagementOutputPort = loaderOutputSwitch.find
  First().get();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.522.1">Output adapters implement output ports. </span><span class="koboSpan" id="kobo.522.2">So, to get an output port implementation, we should call </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">ServiceLoader.load(SwitchManagementOutputPort.class)</span></strong><span class="koboSpan" id="kobo.524.1"> to load the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">SwitchManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.526.1"> implementation and then call </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">loaderOutputSwitch.findFirst().get()</span></strong><span class="koboSpan" id="kobo.528.1"> to retrieve that </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">implementation object.</span></span></p></li> <li><span class="koboSpan" id="kobo.530.1">Now, we can use the output port object to set it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">use case:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.532.1">
switchManagementUseCase.setOutputPort(switchManagemen
  tOutputPort);</span></pre></li> <li><span class="koboSpan" id="kobo.533.1">Finally, we can initiate the </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">input adapter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.535.1">
this.switchManagementGenericAdapter =
new SwitchManagementGenericAdapter(
routerManagementUseCase, switchManagementUseCase);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.536.1">To instantiate </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">SwitchManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.538.1">, we need to pass references for both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.540.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">SwitchManagementUseCase</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.542.1">use cases.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.543.1">Now, let’s move on and</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.544.1"> learn how to </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">initialize </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">NetworkManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.548.1">Initializing NetworkManagementGenericAdapter</span></h2>
<p><span class="koboSpan" id="kobo.549.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">NetworkManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.551.1">, we only need to load an implementation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.553.1">. </span><span class="koboSpan" id="kobo.553.2">Follow</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.554.1"> these steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">do so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.556.1">The following code shows how we</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.557.1"> should use </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.559.1"> to get a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">NetworkManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
ServiceLoader&lt;NetworkManagementUseCase&gt; load
  erUseCaseNetwork = ServiceLoader.load(NetworkManage
    mentUseCase.class);
NetworkManagementUseCase networkManagementUseCase =
  loaderUseCaseNetwork.findFirst().get()</span></pre></li> <li><span class="koboSpan" id="kobo.563.1">Then, we must reuse </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.565.1">, which we loaded previously, to </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">set </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">NetworkManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
networkManagementUseCase.setOutputPort(routerManage
  mentOutputPort);</span></pre></li> <li><span class="koboSpan" id="kobo.570.1">Finally, we can </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">initiate </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">NetworkManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.574.1">
this.networkManagementGenericAdapter = new NetworkMan
  agementGenericAdapter(switchManagementUseCase, net
    workManagementUseCase);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.575.1">To initiate a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">NetworkManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.577.1"> adapter, we must pass references for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.579.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">NetworkManagementUseCase</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.581.1">use cases.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.582.1">This section taught us how to retrieve interface implementations using </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">ServiceLoader</span></strong><span class="koboSpan" id="kobo.584.1"> in conjunction with JPMS </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.585.1">service providers. </span><span class="koboSpan" id="kobo.585.2">With this technique, we can structure code that</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.586.1"> only relies on abstractions rather </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">than implementations.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.588.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.589.1">In this chapter, we started by looking into the motivations and benefits behind the JPMS. </span><span class="koboSpan" id="kobo.589.2">We discovered that one of the problems the JPMS solves is that of JAR hell, where it’s difficult to control the dependencies that an application should expose and use. </span><span class="koboSpan" id="kobo.589.3">The JPMS addresses this problem by closing access to every public type in a module, requiring the developer to explicitly state which packages containing public types should be visible to other modules. </span><span class="koboSpan" id="kobo.589.4">Also, the developer should state the modules that a given module depends on in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">module</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1"> descriptor.</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">Next, we discussed the DIP and recognized the use cases, input ports, input adapters, and output adapters as components that we can apply to the DIP. </span><span class="koboSpan" id="kobo.592.2">Then, we used JPMS features such as consumers, services, and providers to refactor the topology and inventory system to enable dependency inversion in conjunction with hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">architecture components.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">By employing the DIP, we created a more supple design, an important characteristic when it comes to building change-tolerant systems. </span><span class="koboSpan" id="kobo.594.2">We learned that the JPMS is a Java technology that we can use to implement DIP. </span><span class="koboSpan" id="kobo.594.3">Such technology also enables us to provide robust encapsulation by isolating related code into modules. </span><span class="koboSpan" id="kobo.594.4">This capability is paramount if we wish to establish and enforce boundaries between the Domain, Application, and </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">Framework hexagons.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">In the next chapter, we’ll start our journey into the cloud-native world by learning about the Quarkus Framework and how to use it to prepare and optimize a hexagonal system to run in a </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">cloud-native environment.</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.598.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.599.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.601.1">Which JAR dependency problem does the JPMS aim </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">to solve?</span></span></li>
<li><span class="koboSpan" id="kobo.603.1">Which JPMS directive should we use to enable access to a package containing </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">public types?</span></span></li>
<li><span class="koboSpan" id="kobo.605.1">To declare a dependency on a module, which JPMS directive should </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">we use?</span></span></li>
<li><span class="koboSpan" id="kobo.607.1">When applying dependency inversion on the hexagonal architecture, which components can be regarded as high-level, abstraction, </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">and low-level?</span></span></li>
</ol>
<h1 id="_idParaDest-163"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.609.1">Answers</span></h1>
<p><span class="koboSpan" id="kobo.610.1">Here are the answers to this </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">chapter’s questions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.612.1">The JAR </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">hell problem.</span></span></li>
<li><span class="koboSpan" id="kobo.614.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">exports directive.</span></span></li>
<li><span class="koboSpan" id="kobo.616.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">requires directive.</span></span></li>
<li><span class="koboSpan" id="kobo.618.1">Input adapters, use cases, and input </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">ports, respectively.</span></span></li>
</ol>
<h1 id="_idParaDest-164"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.620.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.621.1">The Dependency Inversion Principle</span></em><span class="koboSpan" id="kobo.622.1">, by Robert C. </span><span class="koboSpan" id="kobo.622.2">Martin, C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">Report, 1996.</span></span></li>
</ul>
</div>


<div class="Content" id="_idContainer065">
<h1 id="_idParaDest-165" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1.1">Part 3: Becoming Cloud-Native</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will integrate the Quarkus framework into a hexagonal application, making it truly modern cloud-native software that's ready to be deployed in </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">cloud environments.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">We'll learn how to add Quarkus to our existing topology and inventory system. </span><span class="koboSpan" id="kobo.4.2">Then, we'll explore some of the exciting Quarkus features, such as CDI beans, RESTEasy Reactive, and Hibernate Reactive. </span><span class="koboSpan" id="kobo.4.3">After combining Quarkus and hexagonal architecture, we'll learn how to dockerize and create Kubernetes objects to deploy our hexagonal application to a </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B19777_10.xhtml#_idTextAnchor213"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Adding Quarkus to a Modularized Hexagonal Application</span></em></li>
<li><a href="B19777_11.xhtml#_idTextAnchor228"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Leveraging CDI Beans to Manage Ports and Use Cases</span></em></li>
<li><a href="B19777_12.xhtml#_idTextAnchor244"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Using RESTEasy Reactive to Implement Input Adapters</span></em></li>
<li><a href="B19777_13.xhtml#_idTextAnchor263"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Persisting Data with Output Adapters and Hibernate Reactive</span></em></li>
<li><a href="B19777_14.xhtml#_idTextAnchor286"><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.21.1">, </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Setting Up Dockerfile and Kubernetes Objects for Cloud Deployment</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer066">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer067">
</div>
</div>
</body></html>