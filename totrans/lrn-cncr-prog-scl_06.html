<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 6. Concurrent Programming with Reactive Extensions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/><span class="koboSpan" id="kobo.1.1">Chapter 6. Concurrent Programming with Reactive Extensions</span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"Your mouse is a database."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Erik Meijer</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">The futures and promises from </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.9.1">Chapter 4</span></a><span class="koboSpan" id="kobo.10.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.12.1">, push concurrent programming to a new level. </span><span class="koboSpan" id="kobo.12.2">First, they avoid blocking when transferring the result of the computation from the producer to the consumer. </span><span class="koboSpan" id="kobo.12.3">Second, they allow you to idiomatically compose simple future objects into more complex ones, resulting in programs that are more concise. </span><span class="koboSpan" id="kobo.12.4">Futures encapsulate patterns of asynchronous communication in a way that is clear and easily understandable.</span></p><p><span class="koboSpan" id="kobo.13.1">One disadvantage of futures is that they can only deal with a single result. </span><span class="koboSpan" id="kobo.13.2">For HTTP requests or asynchronous computations that compute a single value, futures can be adequate, but sometimes we need to react to many different events coming from the same computation. </span><span class="koboSpan" id="kobo.13.3">For example, it is cumbersome to track the progress status of a file download with futures. </span><span class="koboSpan" id="kobo.13.4">Event streams are a much better tool for this use case; unlike futures, they can produce any number of values, which we call events. </span><span class="koboSpan" id="kobo.13.5">First-class event streams, which we will learn about in this chapter, can be used inside expressions as if they were regular values. </span><span class="koboSpan" id="kobo.13.6">Just as with futures, first-class event streams can be composed and transformed using functional combinators.</span></p><p><span class="koboSpan" id="kobo.14.1">In computer science, </span><span class="strong"><strong><span class="koboSpan" id="kobo.15.1">event-driven programming</span></strong></span><span class="koboSpan" id="kobo.16.1"> is a programming style in which the flow of the program is determined by events such as external inputs, user actions, or messages coming from other computations. </span><span class="koboSpan" id="kobo.16.2">Here, a user action might be a mouse click, and an external input can be a network interface. </span><span class="koboSpan" id="kobo.16.3">Both futures and event streams can be classified as event-driven programming abstractions.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">Reactive programming</span></strong></span><span class="koboSpan" id="kobo.18.1">, which deals with the propagation of change and the flow of data in the program, is a closely related discipline. </span><span class="koboSpan" id="kobo.18.2">Traditionally, reactive programming is defined as a programming style that allows you to express various constraints between the data values in the program. </span><span class="koboSpan" id="kobo.18.3">For example, when we say </span><code class="literal"><span class="koboSpan" id="kobo.19.1">a = b + 1</span></code><span class="koboSpan" id="kobo.20.1"> in an imperative programming model, it means that </span><code class="literal"><span class="koboSpan" id="kobo.21.1">a</span></code><span class="koboSpan" id="kobo.22.1"> is assigned the current value of </span><code class="literal"><span class="koboSpan" id="kobo.23.1">b</span></code><span class="koboSpan" id="kobo.24.1"> increased by </span><code class="literal"><span class="koboSpan" id="kobo.25.1">1</span></code><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">If the value </span><code class="literal"><span class="koboSpan" id="kobo.27.1">b</span></code><span class="koboSpan" id="kobo.28.1"> later changes, the value of </span><code class="literal"><span class="koboSpan" id="kobo.29.1">a</span></code><span class="koboSpan" id="kobo.30.1"> does not change. </span><span class="koboSpan" id="kobo.30.2">By contrast, in reactive programming, whenever the value </span><code class="literal"><span class="koboSpan" id="kobo.31.1">b</span></code><span class="koboSpan" id="kobo.32.1"> changes, the value </span><code class="literal"><span class="koboSpan" id="kobo.33.1">a</span></code><span class="koboSpan" id="kobo.34.1"> is updated using the constraint </span><code class="literal"><span class="koboSpan" id="kobo.35.1">a = b + 1</span></code><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">With the rising demand for concurrency, the need for event-driven and reactive programming grows even larger. </span><span class="koboSpan" id="kobo.36.3">Traditional callback-based and imperative APIs have shown to be inadequate for this task: they obscure the program flow, mix concurrency concerns with program logic, and rely on mutable state. </span><span class="koboSpan" id="kobo.36.4">In larger applications, swarms of unstructured callback declarations lead to an effect known as the callback hell, in which the programmer can no longer make sense of the control flow of the program. </span><span class="koboSpan" id="kobo.36.5">In a way, callbacks are the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">GOTO</span></code><span class="koboSpan" id="kobo.38.1"> statement of reactive programming. </span><span class="strong"><strong><span class="koboSpan" id="kobo.39.1">Event stream composition</span></strong></span><span class="koboSpan" id="kobo.40.1"> captures patterns of callback declarations, allowing the programmer to express them more easily. </span><span class="koboSpan" id="kobo.40.2">It is a much more structured approach for building event-based systems.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.41.1">Reactive Extensions</span></strong></span><span class="koboSpan" id="kobo.42.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.43.1">Rx</span></strong></span><span class="koboSpan" id="kobo.44.1">) is a programming framework for composing asynchronous and event-driven programs using event streams. </span><span class="koboSpan" id="kobo.44.2">In Rx, an event stream that produces events of type </span><code class="literal"><span class="koboSpan" id="kobo.45.1">T</span></code><span class="koboSpan" id="kobo.46.1"> is represented with the type </span><code class="literal"><span class="koboSpan" id="kobo.47.1">Observable[T]</span></code><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">As we will learn in this chapter, the Rx framework incorporates principles present both in reactive and in event-driven programming. </span><span class="koboSpan" id="kobo.48.3">The fundamental concept around Rx is that events and data can be manipulated in a similar way.</span></p><p><span class="koboSpan" id="kobo.49.1">In this chapter, we will study the semantics of </span><code class="literal"><span class="koboSpan" id="kobo.50.1">RxObservable</span></code><span class="koboSpan" id="kobo.51.1"> objects, and learn how to use them to build event-driven and reactive applications. </span><span class="koboSpan" id="kobo.51.2">Concretely, we will cover the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.52.1">Creating and subscribing to the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">Observable</span></code><span class="koboSpan" id="kobo.54.1"> objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.55.1">The observable contract and how to implement custom </span><code class="literal"><span class="koboSpan" id="kobo.56.1">Observable</span></code><span class="koboSpan" id="kobo.57.1"> objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.58.1">Using the subscriptions to cancel event sources</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.59.1">Composing observable objects using Rx combinators</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.60.1">Controlling concurrency with Rx scheduler instances</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.61.1">Using Rx subjects for designing larger applications</span></li></ul></div><p><span class="koboSpan" id="kobo.62.1">We will start with simple examples that show you how to create and manipulate the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">Observable</span></code><span class="koboSpan" id="kobo.64.1"> objects, and illustrate how they propagate events.</span></p><div class="section" title="Creating Observable objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/><span class="koboSpan" id="kobo.65.1">Creating Observable objects</span></h1></div></div></div><p><span class="koboSpan" id="kobo.66.1">In this section, we will study various ways of creating </span><code class="literal"><span class="koboSpan" id="kobo.67.1">Observable</span></code><span class="koboSpan" id="kobo.68.1"> objects. </span><span class="koboSpan" id="kobo.68.2">We will learn how to subscribe to different kinds of event produced by </span><code class="literal"><span class="koboSpan" id="kobo.69.1">Observable</span></code><span class="koboSpan" id="kobo.70.1"> instances and learn how to correctly create custom </span><code class="literal"><span class="koboSpan" id="kobo.71.1">Observable</span></code><span class="koboSpan" id="kobo.72.1"> objects. </span><span class="koboSpan" id="kobo.72.2">Finally, we will discuss the difference between cold and hot observables.</span></p><p><span class="koboSpan" id="kobo.73.1">An </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Observable</span></code><span class="koboSpan" id="kobo.75.1"> object is an object that has a method called </span><code class="literal"><span class="koboSpan" id="kobo.76.1">subscribe</span></code><span class="koboSpan" id="kobo.77.1">, which takes an object called an observer as a parameter. </span><span class="koboSpan" id="kobo.77.2">The observer is a user-specified object with custom event-handling logic. </span><span class="koboSpan" id="kobo.77.3">When we call the </span><code class="literal"><span class="koboSpan" id="kobo.78.1">subscribe</span></code><span class="koboSpan" id="kobo.79.1"> method with a specific observer, we can say that the observer becomes subscribed to the respective </span><code class="literal"><span class="koboSpan" id="kobo.80.1">Observable</span></code><span class="koboSpan" id="kobo.81.1"> object. </span><span class="koboSpan" id="kobo.81.2">Every time the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">Observable</span></code><span class="koboSpan" id="kobo.83.1"> object produces an event, its subscribed observers get notified.</span></p><p><span class="koboSpan" id="kobo.84.1">The Rx implementation for Scala is not a part of the Scala standard library. </span><span class="koboSpan" id="kobo.84.2">To use Rx in Scala, we need to add the following dependency to our </span><code class="literal"><span class="koboSpan" id="kobo.85.1">build.sbt</span></code><span class="koboSpan" id="kobo.86.1"> file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.87.1">libraryDependencies += 
  "com.netflix.rxjava" % "rxjava-scala" % "0.19.1" 
</span></pre><p><span class="koboSpan" id="kobo.88.1">Now, we can import the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">rx.lang.scala</span></code><span class="koboSpan" id="kobo.90.1"> package to start using Rx. </span><span class="koboSpan" id="kobo.90.2">Let's say that we want to create a simple </span><code class="literal"><span class="koboSpan" id="kobo.91.1">Observable</span></code><span class="koboSpan" id="kobo.92.1"> object that first emits several </span><code class="literal"><span class="koboSpan" id="kobo.93.1">String</span></code><span class="koboSpan" id="kobo.94.1"> events and then completes the execution. </span><span class="koboSpan" id="kobo.94.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">items</span></code><span class="koboSpan" id="kobo.96.1"> factory method on the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Observable</span></code><span class="koboSpan" id="kobo.98.1"> companion object to create an </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Observable</span></code><span class="koboSpan" id="kobo.100.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.101.1">o</span></code><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.103.1">subscribe</span></code><span class="koboSpan" id="kobo.104.1"> method, which is similar to the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">foreach</span></code><span class="koboSpan" id="kobo.106.1"> method on futures introduced in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.107.1">Chapter 4</span></a><span class="koboSpan" id="kobo.108.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.109.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">The </span><code class="literal"><span class="koboSpan" id="kobo.111.1">subscribe</span></code><span class="koboSpan" id="kobo.112.1"> method takes a callback function and instructs the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">Observable</span></code><span class="koboSpan" id="kobo.114.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.115.1">o</span></code><span class="koboSpan" id="kobo.116.1"> to invoke the callback function for each event that is emitted. </span><span class="koboSpan" id="kobo.116.2">It does so by creating an </span><code class="literal"><span class="koboSpan" id="kobo.117.1">Observer</span></code><span class="koboSpan" id="kobo.118.1"> object behind the scenes. </span><span class="koboSpan" id="kobo.118.2">The difference is that, unlike futures, the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">Observable</span></code><span class="koboSpan" id="kobo.120.1"> objects can emit multiple events. </span><span class="koboSpan" id="kobo.120.2">In our example, the callback functions print the events to the screen by calling the </span><code class="literal"><span class="koboSpan" id="kobo.121.1">log</span></code><span class="koboSpan" id="kobo.122.1"> statement, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.123.1">import rx.lang.scala._ 
object ObservablesItems extends App { 
  val o = Observable.items("Pascal", "Java", "Scala") 
  o.subscribe(name =&gt; log(s"learned the $name language")) 
  o.subscribe(name =&gt; log(s"forgot the $name language")) 
} 
</span></pre><p><span class="koboSpan" id="kobo.124.1">Upon running this example, we notice two things. </span><span class="koboSpan" id="kobo.124.2">First, all the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">log</span></code><span class="koboSpan" id="kobo.126.1"> statements are executed on the main program thread. </span><span class="koboSpan" id="kobo.126.2">Second, the callback associated with the first </span><code class="literal"><span class="koboSpan" id="kobo.127.1">subscribe</span></code><span class="koboSpan" id="kobo.128.1"> call is invoked for all three programming languages before the callback associated with the second </span><code class="literal"><span class="koboSpan" id="kobo.129.1">subscribe</span></code><span class="koboSpan" id="kobo.130.1"> call is called for these three languages:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.131.1">run-main-0: learned the Pascal language 
run-main-0: learned the Java language 
run-main-0: learned the Scala language 
run-main-0: forgot the Pascal language 
run-main-0: forgot the Java language 
run-main-0: forgot the Scala language 
</span></pre><p><span class="koboSpan" id="kobo.132.1">We can conclude that the </span><code class="literal"><span class="koboSpan" id="kobo.133.1">subscribe</span></code><span class="koboSpan" id="kobo.134.1"> call executes synchronously--it invokes callback for all the events emitted by the event stream </span><code class="literal"><span class="koboSpan" id="kobo.135.1">o</span></code><span class="koboSpan" id="kobo.136.1"> before returning. </span><span class="koboSpan" id="kobo.136.2">However, this is not always the case. </span><span class="koboSpan" id="kobo.136.3">The </span><code class="literal"><span class="koboSpan" id="kobo.137.1">subscribe</span></code><span class="koboSpan" id="kobo.138.1"> call can also return the control to the main thread immediately, and invoke the callback functions asynchronously. </span><span class="koboSpan" id="kobo.138.2">This behavior depends on the implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.139.1">Observable</span></code><span class="koboSpan" id="kobo.140.1"> object. </span><span class="koboSpan" id="kobo.140.2">In this Rx implementation, the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">Observable</span></code><span class="koboSpan" id="kobo.142.1"> objects created using the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">items</span></code><span class="koboSpan" id="kobo.144.1"> method have their events available when the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">Observable</span></code><span class="koboSpan" id="kobo.146.1"> object is created, so their </span><code class="literal"><span class="koboSpan" id="kobo.147.1">subscribe</span></code><span class="koboSpan" id="kobo.148.1"> method is synchronous.</span></p><p><span class="koboSpan" id="kobo.149.1">In the previous example, the </span><code class="literal"><span class="koboSpan" id="kobo.150.1">Observable</span></code><span class="koboSpan" id="kobo.151.1"> object feels almost like an immutable Scala collection, and the </span><code class="literal"><span class="koboSpan" id="kobo.152.1">subscribe</span></code><span class="koboSpan" id="kobo.153.1"> method acts as if it is a </span><code class="literal"><span class="koboSpan" id="kobo.154.1">foreach</span></code><span class="koboSpan" id="kobo.155.1"> method on a collection. </span><span class="koboSpan" id="kobo.155.2">However, the </span><code class="literal"><span class="koboSpan" id="kobo.156.1">Observable</span></code><span class="koboSpan" id="kobo.157.1"> objects are more general. </span><span class="koboSpan" id="kobo.157.2">We will see an </span><code class="literal"><span class="koboSpan" id="kobo.158.1">Observable</span></code><span class="koboSpan" id="kobo.159.1"> object that emits events asynchronously next.</span></p><p><span class="koboSpan" id="kobo.160.1">Let's assume that we want the </span><code class="literal"><span class="koboSpan" id="kobo.161.1">Observable</span></code><span class="koboSpan" id="kobo.162.1"> object that emits an event after a certain period of time has elapsed. </span><span class="koboSpan" id="kobo.162.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.163.1">timer</span></code><span class="koboSpan" id="kobo.164.1"> factory method to create such an </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Observable</span></code><span class="koboSpan" id="kobo.166.1"> object and set the timeout to 1 second. </span><span class="koboSpan" id="kobo.166.2">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.167.1">subscribe</span></code><span class="koboSpan" id="kobo.168.1"> method with two different callbacks, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.169.1">import scala.concurrent.duration._ 
object ObservablesTimer extends App { 
  val o = Observable.timer(1.second) 
  o.subscribe(_ =&gt; log("Timeout!")) 
  o.subscribe(_ =&gt; log("Another timeout!")) 
  Thread.sleep(2000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.170.1">This time, the </span><code class="literal"><span class="koboSpan" id="kobo.171.1">subscribe</span></code><span class="koboSpan" id="kobo.172.1"> method calls are asynchronous; it makes no sense to block the main thread for an entire second and wait until the timeout event appears. </span><span class="koboSpan" id="kobo.172.2">Running the example shows that the main thread continues before the callback functions are invoked:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.173.1">RxComputationThreadPool-2: Another timeout! 
</span><span class="koboSpan" id="kobo.173.2">RxComputationThreadPool-1: Timeout! 
</span></pre><p><span class="koboSpan" id="kobo.174.1">Furthermore, the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">log</span></code><span class="koboSpan" id="kobo.176.1"> statements reveal that the callback functions are invoked on the thread pool internally used by Rx, in an unspecified order.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip61"/><span class="koboSpan" id="kobo.177.1">Tip</span></h3><p><span class="koboSpan" id="kobo.178.1">The </span><code class="literal"><span class="koboSpan" id="kobo.179.1">Observable</span></code><span class="koboSpan" id="kobo.180.1"> objects can emit events either synchronously or asynchronously, depending on the implementation of the specific </span><code class="literal"><span class="koboSpan" id="kobo.181.1">Observable</span></code><span class="koboSpan" id="kobo.182.1"> object.</span></p></div></div><p><span class="koboSpan" id="kobo.183.1">As we will see, in most use cases, events are not available when calling the </span><code class="literal"><span class="koboSpan" id="kobo.184.1">subscribe</span></code><span class="koboSpan" id="kobo.185.1"> method. </span><span class="koboSpan" id="kobo.185.2">This is the case with UI events, file modification events, or HTTP responses. </span><span class="koboSpan" id="kobo.185.3">To avoid blocking the thread that calls the </span><code class="literal"><span class="koboSpan" id="kobo.186.1">subscribe</span></code><span class="koboSpan" id="kobo.187.1"> method, the </span><code class="literal"><span class="koboSpan" id="kobo.188.1">Observable</span></code><span class="koboSpan" id="kobo.189.1"> objects emit such events asynchronously.</span></p><div class="section" title="Observables and exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/><span class="koboSpan" id="kobo.190.1">Observables and exceptions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.191.1">In </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.192.1">Chapter 4</span></a><span class="koboSpan" id="kobo.193.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.194.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.195.1">, we saw that asynchronous computations sometimes throw exceptions. </span><span class="koboSpan" id="kobo.195.2">When that happens, the </span><code class="literal"><span class="koboSpan" id="kobo.196.1">Future</span></code><span class="koboSpan" id="kobo.197.1"> object associated with the exception fails; instead of being completed with the result of the computation, the </span><code class="literal"><span class="koboSpan" id="kobo.198.1">Future</span></code><span class="koboSpan" id="kobo.199.1"> object is completed with the exception that failed the asynchronous computation. </span><span class="koboSpan" id="kobo.199.2">The clients of the </span><code class="literal"><span class="koboSpan" id="kobo.200.1">Future</span></code><span class="koboSpan" id="kobo.201.1"> objects can react to exceptions by registering callbacks with the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">failed.foreach</span></code><span class="koboSpan" id="kobo.203.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.204.1">onComplete</span></code><span class="koboSpan" id="kobo.205.1"> methods.</span></p><p><span class="koboSpan" id="kobo.206.1">Computations that produce events in </span><code class="literal"><span class="koboSpan" id="kobo.207.1">Observable</span></code><span class="koboSpan" id="kobo.208.1"> objects can also throw exceptions. </span><span class="koboSpan" id="kobo.208.2">To respond to exceptions produced by the </span><code class="literal"><span class="koboSpan" id="kobo.209.1">Observable</span></code><span class="koboSpan" id="kobo.210.1"> objects, we can use an overload of the </span><code class="literal"><span class="koboSpan" id="kobo.211.1">subscribe</span></code><span class="koboSpan" id="kobo.212.1"> method that takes two callback arguments to create an observer--the callback function for the events and the callback function for the exception.</span></p><p><span class="koboSpan" id="kobo.213.1">The following program creates an </span><code class="literal"><span class="koboSpan" id="kobo.214.1">Observable</span></code><span class="koboSpan" id="kobo.215.1"> object that emits numbers </span><code class="literal"><span class="koboSpan" id="kobo.216.1">1</span></code><span class="koboSpan" id="kobo.217.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.218.1">2</span></code><span class="koboSpan" id="kobo.219.1">, and then produces a </span><code class="literal"><span class="koboSpan" id="kobo.220.1">RuntimeException</span></code><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">The </span><code class="literal"><span class="koboSpan" id="kobo.222.1">items</span></code><span class="koboSpan" id="kobo.223.1"> factory method creates the </span><code class="literal"><span class="koboSpan" id="kobo.224.1">Observable</span></code><span class="koboSpan" id="kobo.225.1"> object with the numbers, and the </span><code class="literal"><span class="koboSpan" id="kobo.226.1">error</span></code><span class="koboSpan" id="kobo.227.1"> factory method creates another </span><code class="literal"><span class="koboSpan" id="kobo.228.1">Observable</span></code><span class="koboSpan" id="kobo.229.1"> object with an exception. </span><span class="koboSpan" id="kobo.229.2">We then concatenate the two together with the </span><code class="literal"><span class="koboSpan" id="kobo.230.1">++</span></code><span class="koboSpan" id="kobo.231.1"> operator on </span><code class="literal"><span class="koboSpan" id="kobo.232.1">Observable</span></code><span class="koboSpan" id="kobo.233.1"> instances. </span><span class="koboSpan" id="kobo.233.2">The first callback logs the numbers to the standard output and ignores the exception. </span><span class="koboSpan" id="kobo.233.3">Conversely, the second callback logs the </span><code class="literal"><span class="koboSpan" id="kobo.234.1">Throwable</span></code><span class="koboSpan" id="kobo.235.1"> objects and ignores the numbers. </span><span class="koboSpan" id="kobo.235.2">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.236.1">object ObservablesExceptions extends App { 
  val exc = new RuntimeException 
  val o = Observable.items(1, 2) ++ Observable.error(exc) 
  o.subscribe( 
    x =&gt; log(s"number $x"), 
    t =&gt; log(s"an error occurred: $t") 
  ) 
} 
</span></pre><p><span class="koboSpan" id="kobo.237.1">The program first prints numbers </span><code class="literal"><span class="koboSpan" id="kobo.238.1">1</span></code><span class="koboSpan" id="kobo.239.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.240.1">2</span></code><span class="koboSpan" id="kobo.241.1">, and then prints the exception object. </span><span class="koboSpan" id="kobo.241.2">Without the second callback function being passed to the </span><code class="literal"><span class="koboSpan" id="kobo.242.1">subscribe</span></code><span class="koboSpan" id="kobo.243.1"> method, the exception will be emitted by the </span><code class="literal"><span class="koboSpan" id="kobo.244.1">Observable</span></code><span class="koboSpan" id="kobo.245.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.246.1">o</span></code><span class="koboSpan" id="kobo.247.1">, but never passed to the observer. </span><span class="koboSpan" id="kobo.247.2">Importantly, after an exception is emitted, the </span><code class="literal"><span class="koboSpan" id="kobo.248.1">Observable</span></code><span class="koboSpan" id="kobo.249.1"> object is not allowed to emit any additional events. </span><span class="koboSpan" id="kobo.249.2">We can redefine the </span><code class="literal"><span class="koboSpan" id="kobo.250.1">Observable</span></code><span class="koboSpan" id="kobo.251.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.252.1">o</span></code><span class="koboSpan" id="kobo.253.1"> as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.254.1">import Observable._ 
val o = items(1, 2) ++ error(exc) ++ items(3, 4) 
</span></pre><p><span class="koboSpan" id="kobo.255.1">We might expect the program to print events </span><code class="literal"><span class="koboSpan" id="kobo.256.1">3</span></code><span class="koboSpan" id="kobo.257.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.258.1">4</span></code><span class="koboSpan" id="kobo.259.1">, but they are not emitted by the </span><code class="literal"><span class="koboSpan" id="kobo.260.1">Observable</span></code><span class="koboSpan" id="kobo.261.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.262.1">o</span></code><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">When an </span><code class="literal"><span class="koboSpan" id="kobo.264.1">Observable</span></code><span class="koboSpan" id="kobo.265.1"> object produces an exception, we say that it is in the error state.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip62"/><span class="koboSpan" id="kobo.266.1">Tip</span></h3><p><span class="koboSpan" id="kobo.267.1">When an </span><code class="literal"><span class="koboSpan" id="kobo.268.1">Observable</span></code><span class="koboSpan" id="kobo.269.1"> object produces an exception, it enters the error state and cannot emit more events.</span></p></div></div><p><span class="koboSpan" id="kobo.270.1">Irrespective of whether the </span><code class="literal"><span class="koboSpan" id="kobo.271.1">Observable</span></code><span class="koboSpan" id="kobo.272.1"> object is created using a factory method, or is a custom </span><code class="literal"><span class="koboSpan" id="kobo.273.1">Observable</span></code><span class="koboSpan" id="kobo.274.1"> implementation described in the subsequent sections, an </span><code class="literal"><span class="koboSpan" id="kobo.275.1">Observable</span></code><span class="koboSpan" id="kobo.276.1"> object is not allowed to emit events after it produces an exception. </span><span class="koboSpan" id="kobo.276.2">In the next section, we will examine this contract in more detail.</span></p></div><div class="section" title="The Observable contract"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/><span class="koboSpan" id="kobo.277.1">The Observable contract</span></h2></div></div></div><p><span class="koboSpan" id="kobo.278.1">Now that we have seen how to create simple </span><code class="literal"><span class="koboSpan" id="kobo.279.1">Observable</span></code><span class="koboSpan" id="kobo.280.1"> objects and react to their events, it is time to take a closer look at the lifetime of an </span><code class="literal"><span class="koboSpan" id="kobo.281.1">Observable</span></code><span class="koboSpan" id="kobo.282.1"> object. </span><span class="koboSpan" id="kobo.282.2">Every </span><code class="literal"><span class="koboSpan" id="kobo.283.1">Observable</span></code><span class="koboSpan" id="kobo.284.1"> object can be in three states: uncompleted, error, or completed. </span><span class="koboSpan" id="kobo.284.2">As long as the </span><code class="literal"><span class="koboSpan" id="kobo.285.1">Observable[T]</span></code><span class="koboSpan" id="kobo.286.1"> object is uncompleted, it can emit events of type </span><code class="literal"><span class="koboSpan" id="kobo.287.1">T</span></code><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">As we already learned, an </span><code class="literal"><span class="koboSpan" id="kobo.289.1">Observable</span></code><span class="koboSpan" id="kobo.290.1"> object can produce an exception to indicate that it failed to produce additional data. </span><span class="koboSpan" id="kobo.290.2">When this happens, the </span><code class="literal"><span class="koboSpan" id="kobo.291.1">Observable</span></code><span class="koboSpan" id="kobo.292.1"> object enters the error state and cannot emit any additional events. </span><span class="koboSpan" id="kobo.292.2">Similarly, when an </span><code class="literal"><span class="koboSpan" id="kobo.293.1">Observable</span></code><span class="koboSpan" id="kobo.294.1"> object decides that it will not produce any additional data, it might enter the completed state. </span><span class="koboSpan" id="kobo.294.2">After an </span><code class="literal"><span class="koboSpan" id="kobo.295.1">Observable</span></code><span class="koboSpan" id="kobo.296.1"> object is completed, it is not allowed to emit any additional events.</span></p><p><span class="koboSpan" id="kobo.297.1">In Rx, an object that subscribes to events from an </span><code class="literal"><span class="koboSpan" id="kobo.298.1">Observable</span></code><span class="koboSpan" id="kobo.299.1"> object is called an </span><code class="literal"><span class="koboSpan" id="kobo.300.1">Observer</span></code><span class="koboSpan" id="kobo.301.1"> object. </span><span class="koboSpan" id="kobo.301.2">The </span><code class="literal"><span class="koboSpan" id="kobo.302.1">Observer[T]</span></code><span class="koboSpan" id="kobo.303.1"> trait comes with three methods: </span><code class="literal"><span class="koboSpan" id="kobo.304.1">onNext</span></code><span class="koboSpan" id="kobo.305.1">, </span><code class="literal"><span class="koboSpan" id="kobo.306.1">onError</span></code><span class="koboSpan" id="kobo.307.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.308.1">onCompleted</span></code><span class="koboSpan" id="kobo.309.1">, which get invoked when an </span><code class="literal"><span class="koboSpan" id="kobo.310.1">Observable</span></code><span class="koboSpan" id="kobo.311.1"> object emits an event, produces an error, or is completed, respectively. </span><span class="koboSpan" id="kobo.311.2">This trait is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.312.1">trait Observer[T] { 
  def onNext(event: T): Unit 
  def onError(error: Throwable): Unit 
  def onCompleted(): Unit 
} 
</span></pre><p><span class="koboSpan" id="kobo.313.1">In the previous examples, whenever we called the </span><code class="literal"><span class="koboSpan" id="kobo.314.1">subscribe</span></code><span class="koboSpan" id="kobo.315.1"> method, Rx created an </span><code class="literal"><span class="koboSpan" id="kobo.316.1">Observer</span></code><span class="koboSpan" id="kobo.317.1"> object and assigned it to the </span><code class="literal"><span class="koboSpan" id="kobo.318.1">Observable</span></code><span class="koboSpan" id="kobo.319.1"> instance. </span><span class="koboSpan" id="kobo.319.2">Alternatively, we can provide an </span><code class="literal"><span class="koboSpan" id="kobo.320.1">Observer</span></code><span class="koboSpan" id="kobo.321.1"> object directly to an overloaded version of the </span><code class="literal"><span class="koboSpan" id="kobo.322.1">subscribe</span></code><span class="koboSpan" id="kobo.323.1"> method. </span><span class="koboSpan" id="kobo.323.2">The following program uses the </span><code class="literal"><span class="koboSpan" id="kobo.324.1">from</span></code><span class="koboSpan" id="kobo.325.1"> factory method which converts a list of movie titles into an </span><code class="literal"><span class="koboSpan" id="kobo.326.1">Observable</span></code><span class="koboSpan" id="kobo.327.1"> object. </span><span class="koboSpan" id="kobo.327.2">It then creates an </span><code class="literal"><span class="koboSpan" id="kobo.328.1">Observer</span></code><span class="koboSpan" id="kobo.329.1"> object and passes it to the </span><code class="literal"><span class="koboSpan" id="kobo.330.1">subscribe</span></code><span class="koboSpan" id="kobo.331.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.332.1">object ObservablesLifetime extends App { 
  val classics = List("Good, bad, ugly", "Titanic", "Die Hard") 
  val movies = Observable.from(classics) 
  movies.subscribe(new Observer[String] { 
    override def onNext(m: String) = log(s"Movies Watchlist - $m") 
    override def onError(e: Throwable) = log(s"Ooops - $e!") 
    override def onCompleted() = log(s"No more movies.") 
  }) 
} 
</span></pre><p><span class="koboSpan" id="kobo.333.1">This program first prints our favorite movies, and terminates after calling </span><code class="literal"><span class="koboSpan" id="kobo.334.1">onCompleted</span></code><span class="koboSpan" id="kobo.335.1"> and printing </span><code class="literal"><span class="koboSpan" id="kobo.336.1">"No more movies"</span></code><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">The </span><code class="literal"><span class="koboSpan" id="kobo.338.1">Observable</span></code><span class="koboSpan" id="kobo.339.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.340.1">movies</span></code><span class="koboSpan" id="kobo.341.1"> is created from a finite collection of strings; after these events are emitted, the </span><code class="literal"><span class="koboSpan" id="kobo.342.1">movies</span></code><span class="koboSpan" id="kobo.343.1"> event stream calls the </span><code class="literal"><span class="koboSpan" id="kobo.344.1">onCompleted</span></code><span class="koboSpan" id="kobo.345.1"> method. </span><span class="koboSpan" id="kobo.345.2">In general, the </span><code class="literal"><span class="koboSpan" id="kobo.346.1">Observable</span></code><span class="koboSpan" id="kobo.347.1"> objects can only call the </span><code class="literal"><span class="koboSpan" id="kobo.348.1">onCompleted</span></code><span class="koboSpan" id="kobo.349.1"> method after it is certain that there will be no more events.</span></p><p><span class="koboSpan" id="kobo.350.1">Every </span><code class="literal"><span class="koboSpan" id="kobo.351.1">Observable</span></code><span class="koboSpan" id="kobo.352.1"> object can call the </span><code class="literal"><span class="koboSpan" id="kobo.353.1">onNext</span></code><span class="koboSpan" id="kobo.354.1"> method on its </span><code class="literal"><span class="koboSpan" id="kobo.355.1">Observer</span></code><span class="koboSpan" id="kobo.356.1"> objects zero or more times. </span><span class="koboSpan" id="kobo.356.2">An </span><code class="literal"><span class="koboSpan" id="kobo.357.1">Observable</span></code><span class="koboSpan" id="kobo.358.1"> object might then enter the completed or error state by calling the </span><code class="literal"><span class="koboSpan" id="kobo.359.1">onCompleted</span></code><span class="koboSpan" id="kobo.360.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.361.1">onError</span></code><span class="koboSpan" id="kobo.362.1"> method on its </span><code class="literal"><span class="koboSpan" id="kobo.363.1">Observer</span></code><span class="koboSpan" id="kobo.364.1"> objects. </span><span class="koboSpan" id="kobo.364.2">This is known as the </span><code class="literal"><span class="koboSpan" id="kobo.365.1">Observable</span></code><span class="koboSpan" id="kobo.366.1"> contract, and is shown graphically in the following state diagram, where different nodes denote </span><code class="literal"><span class="koboSpan" id="kobo.367.1">Observable</span></code><span class="koboSpan" id="kobo.368.1"> states, and links denote calls to different </span><code class="literal"><span class="koboSpan" id="kobo.369.1">Observer</span></code><span class="koboSpan" id="kobo.370.1"> methods:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.371.1"><img src="graphics/image_06_001.jpg" alt="The Observable contract"/></span></div><p><span class="koboSpan" id="kobo.372.1">Note that an </span><code class="literal"><span class="koboSpan" id="kobo.373.1">Observable</span></code><span class="koboSpan" id="kobo.374.1"> object can call the </span><code class="literal"><span class="koboSpan" id="kobo.375.1">onCompleted</span></code><span class="koboSpan" id="kobo.376.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.377.1">onError</span></code><span class="koboSpan" id="kobo.378.1"> method if it knows that it will not emit additional events, but it is free to call neither. </span><span class="koboSpan" id="kobo.378.2">Some Observable objects, such as </span><code class="literal"><span class="koboSpan" id="kobo.379.1">items</span></code><span class="koboSpan" id="kobo.380.1">, know when they emit the last event. </span><span class="koboSpan" id="kobo.380.2">On the other hand, an </span><code class="literal"><span class="koboSpan" id="kobo.381.1">Observable</span></code><span class="koboSpan" id="kobo.382.1"> instance that emits mouse or keyboard events never calls the </span><code class="literal"><span class="koboSpan" id="kobo.383.1">onCompleted</span></code><span class="koboSpan" id="kobo.384.1"> method.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note63"/><span class="koboSpan" id="kobo.385.1">Note</span></h3><p><span class="koboSpan" id="kobo.386.1">An </span><code class="literal"><span class="koboSpan" id="kobo.387.1">Observable</span></code><span class="koboSpan" id="kobo.388.1"> object can call the </span><code class="literal"><span class="koboSpan" id="kobo.389.1">onNext</span></code><span class="koboSpan" id="kobo.390.1"> method on the subscribed </span><code class="literal"><span class="koboSpan" id="kobo.391.1">Observer</span></code><span class="koboSpan" id="kobo.392.1"> objects an unlimited number of times. </span><span class="koboSpan" id="kobo.392.2">After optionally calling the </span><code class="literal"><span class="koboSpan" id="kobo.393.1">onCompleted</span></code><span class="koboSpan" id="kobo.394.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.395.1">onError</span></code><span class="koboSpan" id="kobo.396.1"> method, an </span><code class="literal"><span class="koboSpan" id="kobo.397.1">Observable</span></code><span class="koboSpan" id="kobo.398.1"> object is not allowed to call any </span><code class="literal"><span class="koboSpan" id="kobo.399.1">Observer</span></code><span class="koboSpan" id="kobo.400.1"> methods.</span></p></div></div><p><span class="koboSpan" id="kobo.401.1">The </span><code class="literal"><span class="koboSpan" id="kobo.402.1">Observable</span></code><span class="koboSpan" id="kobo.403.1"> objects produced by the Rx API implement the </span><code class="literal"><span class="koboSpan" id="kobo.404.1">Observable</span></code><span class="koboSpan" id="kobo.405.1"> contract. </span><span class="koboSpan" id="kobo.405.2">In practice, we do not need to worry about the </span><code class="literal"><span class="koboSpan" id="kobo.406.1">Observable</span></code><span class="koboSpan" id="kobo.407.1"> contract, unless we are implementing our own custom </span><code class="literal"><span class="koboSpan" id="kobo.408.1">Observable</span></code><span class="koboSpan" id="kobo.409.1"> object. </span><span class="koboSpan" id="kobo.409.2">This is the topic of the next section.</span></p></div><div class="section" title="Implementing custom Observable objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/><span class="koboSpan" id="kobo.410.1">Implementing custom Observable objects</span></h2></div></div></div><p><span class="koboSpan" id="kobo.411.1">To create a custom </span><code class="literal"><span class="koboSpan" id="kobo.412.1">Observable</span></code><span class="koboSpan" id="kobo.413.1"> object, we can use the </span><code class="literal"><span class="koboSpan" id="kobo.414.1">Observable.create</span></code><span class="koboSpan" id="kobo.415.1"> factory method as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.416.1">def create(f: Observer[T] =&gt; Subscription): Observable[T] 
</span></pre><p><span class="koboSpan" id="kobo.417.1">The preceding method takes a function </span><code class="literal"><span class="koboSpan" id="kobo.418.1">f</span></code><span class="koboSpan" id="kobo.419.1"> from an </span><code class="literal"><span class="koboSpan" id="kobo.420.1">Observer</span></code><span class="koboSpan" id="kobo.421.1"> to a </span><code class="literal"><span class="koboSpan" id="kobo.422.1">Subscription</span></code><span class="koboSpan" id="kobo.423.1"> object and returns a new </span><code class="literal"><span class="koboSpan" id="kobo.424.1">Observable</span></code><span class="koboSpan" id="kobo.425.1"> object. </span><span class="koboSpan" id="kobo.425.2">Whenever the </span><code class="literal"><span class="koboSpan" id="kobo.426.1">subscribe</span></code><span class="koboSpan" id="kobo.427.1"> method gets called, the function </span><code class="literal"><span class="koboSpan" id="kobo.428.1">f</span></code><span class="koboSpan" id="kobo.429.1"> is called on the corresponding </span><code class="literal"><span class="koboSpan" id="kobo.430.1">Observer</span></code><span class="koboSpan" id="kobo.431.1"> object. </span><span class="koboSpan" id="kobo.431.2">The function </span><code class="literal"><span class="koboSpan" id="kobo.432.1">f</span></code><span class="koboSpan" id="kobo.433.1"> returns a </span><code class="literal"><span class="koboSpan" id="kobo.434.1">Subscription</span></code><span class="koboSpan" id="kobo.435.1"> object, which can be used to unsubscribe the </span><code class="literal"><span class="koboSpan" id="kobo.436.1">Observer</span></code><span class="koboSpan" id="kobo.437.1"> object from the </span><code class="literal"><span class="koboSpan" id="kobo.438.1">Observable</span></code><span class="koboSpan" id="kobo.439.1"> instance. </span><span class="koboSpan" id="kobo.439.2">The </span><code class="literal"><span class="koboSpan" id="kobo.440.1">Subscription</span></code><span class="koboSpan" id="kobo.441.1"> trait defines a single method called </span><code class="literal"><span class="koboSpan" id="kobo.442.1">unsubscribe</span></code><span class="koboSpan" id="kobo.443.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.444.1">trait Subscription { 
  def unsubscribe(): Unit 
} 
</span></pre><p><span class="koboSpan" id="kobo.445.1">We will talk about the </span><code class="literal"><span class="koboSpan" id="kobo.446.1">Subscription</span></code><span class="koboSpan" id="kobo.447.1"> objects in more detail in a subsequent section. </span><span class="koboSpan" id="kobo.447.2">For now, we only use the empty </span><code class="literal"><span class="koboSpan" id="kobo.448.1">Subscription</span></code><span class="koboSpan" id="kobo.449.1"> object, which does not unsubscribe the </span><code class="literal"><span class="koboSpan" id="kobo.450.1">Observer</span></code><span class="koboSpan" id="kobo.451.1"> object.</span></p><p><span class="koboSpan" id="kobo.452.1">To illustrate how to use the </span><code class="literal"><span class="koboSpan" id="kobo.453.1">Observable.create</span></code><span class="koboSpan" id="kobo.454.1"> method, we implement an </span><code class="literal"><span class="koboSpan" id="kobo.455.1">Observable</span></code><span class="koboSpan" id="kobo.456.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.457.1">vms</span></code><span class="koboSpan" id="kobo.458.1">, which emits names of popular virtual machine implementations. </span><span class="koboSpan" id="kobo.458.2">In </span><code class="literal"><span class="koboSpan" id="kobo.459.1">Observable.create</span></code><span class="koboSpan" id="kobo.460.1">, we take care to first call </span><code class="literal"><span class="koboSpan" id="kobo.461.1">onNext</span></code><span class="koboSpan" id="kobo.462.1"> with all the VM names, and then call </span><code class="literal"><span class="koboSpan" id="kobo.463.1">onCompleted</span></code><span class="koboSpan" id="kobo.464.1"> once. </span><span class="koboSpan" id="kobo.464.2">Finally, we return the empty </span><code class="literal"><span class="koboSpan" id="kobo.465.1">Subscription</span></code><span class="koboSpan" id="kobo.466.1"> object. </span><span class="koboSpan" id="kobo.466.2">This is shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.467.1">object ObservablesCreate extends App { 
  val vms = Observable.apply[String] { obs =&gt; 
    obs.onNext("JVM") 
    obs.onNext("DartVM") 
    obs.onNext("V8") 
    obs.onCompleted() 
    Subscription() 
  } 
  vms.subscribe(log _, e =&gt; log(s"oops - $e"), () =&gt; log("Done!")) 
} 
</span></pre><p><span class="koboSpan" id="kobo.468.1">The </span><code class="literal"><span class="koboSpan" id="kobo.469.1">Observable</span></code><span class="koboSpan" id="kobo.470.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.471.1">vms</span></code><span class="koboSpan" id="kobo.472.1"> has a synchronous </span><code class="literal"><span class="koboSpan" id="kobo.473.1">subscribe</span></code><span class="koboSpan" id="kobo.474.1"> method. </span><span class="koboSpan" id="kobo.474.2">All the events are emitted to an </span><code class="literal"><span class="koboSpan" id="kobo.475.1">obs</span></code><span class="koboSpan" id="kobo.476.1"> observer before returning the control to the thread that called the </span><code class="literal"><span class="koboSpan" id="kobo.477.1">subscribe</span></code><span class="koboSpan" id="kobo.478.1"> method. </span><span class="koboSpan" id="kobo.478.2">In general, we can use the </span><code class="literal"><span class="koboSpan" id="kobo.479.1">Observable.create</span></code><span class="koboSpan" id="kobo.480.1"> method in order to create an </span><code class="literal"><span class="koboSpan" id="kobo.481.1">Observable</span></code><span class="koboSpan" id="kobo.482.1"> instance that emits events asynchronously. </span><span class="koboSpan" id="kobo.482.2">We will study how to convert a </span><code class="literal"><span class="koboSpan" id="kobo.483.1">Future</span></code><span class="koboSpan" id="kobo.484.1"> object into an </span><code class="literal"><span class="koboSpan" id="kobo.485.1">Observable</span></code><span class="koboSpan" id="kobo.486.1"> object next.</span></p></div><div class="section" title="Creating Observables from futures"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/><span class="koboSpan" id="kobo.487.1">Creating Observables from futures</span></h2></div></div></div><p><span class="koboSpan" id="kobo.488.1">Futures are objects that represent the result of an asynchronous computation. </span><span class="koboSpan" id="kobo.488.2">One can consider an </span><code class="literal"><span class="koboSpan" id="kobo.489.1">Observable</span></code><span class="koboSpan" id="kobo.490.1"> object as a generalization of a </span><code class="literal"><span class="koboSpan" id="kobo.491.1">Future</span></code><span class="koboSpan" id="kobo.492.1"> object. </span><span class="koboSpan" id="kobo.492.2">Instead of emitting a single success or failure event, an </span><code class="literal"><span class="koboSpan" id="kobo.493.1">Observable</span></code><span class="koboSpan" id="kobo.494.1"> object emits a sequence of events, before failing or completing successfully.</span></p><p><span class="koboSpan" id="kobo.495.1">Scala APIs that deal with asynchronous computations generally return the </span><code class="literal"><span class="koboSpan" id="kobo.496.1">Future</span></code><span class="koboSpan" id="kobo.497.1"> objects, and not </span><code class="literal"><span class="koboSpan" id="kobo.498.1">Observable</span></code><span class="koboSpan" id="kobo.499.1"> instances. </span><span class="koboSpan" id="kobo.499.2">In some cases, it is useful to be able to convert a </span><code class="literal"><span class="koboSpan" id="kobo.500.1">Future</span></code><span class="koboSpan" id="kobo.501.1"> object into an </span><code class="literal"><span class="koboSpan" id="kobo.502.1">Observable</span></code><span class="koboSpan" id="kobo.503.1"> object. </span><span class="koboSpan" id="kobo.503.2">Here, after a </span><code class="literal"><span class="koboSpan" id="kobo.504.1">Future</span></code><span class="koboSpan" id="kobo.505.1"> object is completed successfully, the corresponding </span><code class="literal"><span class="koboSpan" id="kobo.506.1">Observable</span></code><span class="koboSpan" id="kobo.507.1"> object must emit an event with the future value, and then call the </span><code class="literal"><span class="koboSpan" id="kobo.508.1">onCompleted</span></code><span class="koboSpan" id="kobo.509.1"> method. </span><span class="koboSpan" id="kobo.509.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.510.1">Future</span></code><span class="koboSpan" id="kobo.511.1"> object fails, the corresponding </span><code class="literal"><span class="koboSpan" id="kobo.512.1">Observable</span></code><span class="koboSpan" id="kobo.513.1"> object should call the </span><code class="literal"><span class="koboSpan" id="kobo.514.1">onError</span></code><span class="koboSpan" id="kobo.515.1"> method. </span><span class="koboSpan" id="kobo.515.2">Before we begin, we need to import the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.516.1">scala.concurrent</span></code><span class="koboSpan" id="kobo.517.1"> package and the global </span><code class="literal"><span class="koboSpan" id="kobo.518.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.519.1"> object, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.520.1">import scala.concurrent._ 
import ExecutionContext.Implicits.global 
</span></pre><p><span class="koboSpan" id="kobo.521.1">We then use the </span><code class="literal"><span class="koboSpan" id="kobo.522.1">Observable.create</span></code><span class="koboSpan" id="kobo.523.1"> method to create an </span><code class="literal"><span class="koboSpan" id="kobo.524.1">Observable</span></code><span class="koboSpan" id="kobo.525.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.526.1">o</span></code><span class="koboSpan" id="kobo.527.1">. </span><span class="koboSpan" id="kobo.527.2">Instead of calling the </span><code class="literal"><span class="koboSpan" id="kobo.528.1">onNext</span></code><span class="koboSpan" id="kobo.529.1">, </span><code class="literal"><span class="koboSpan" id="kobo.530.1">onError</span></code><span class="koboSpan" id="kobo.531.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.532.1">onCompleted</span></code><span class="koboSpan" id="kobo.533.1"> methods directly on the </span><code class="literal"><span class="koboSpan" id="kobo.534.1">Observer</span></code><span class="koboSpan" id="kobo.535.1"> object, we will install callbacks on the </span><code class="literal"><span class="koboSpan" id="kobo.536.1">Future</span></code><span class="koboSpan" id="kobo.537.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.538.1">f</span></code><span class="koboSpan" id="kobo.539.1">, as shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.540.1">object ObservablesCreateFuture extends App { 
  val f = Future { "Back to the Future(s)" } 
  val o = Observable.create[String] { obs =&gt; 
    f foreach { case s =&gt; obs.onNext(s); obs.onCompleted() } 
    f.failed foreach { case t =&gt; obs.onError(t) } 
    Subscription() 
  } 
  o.subscribe(log _) 
} 
</span></pre><p><span class="koboSpan" id="kobo.541.1">This time, the </span><code class="literal"><span class="koboSpan" id="kobo.542.1">subscribe</span></code><span class="koboSpan" id="kobo.543.1"> method is asynchronous. </span><span class="koboSpan" id="kobo.543.2">It returns immediately after installing the callback on the </span><code class="literal"><span class="koboSpan" id="kobo.544.1">Future</span></code><span class="koboSpan" id="kobo.545.1"> object. </span><span class="koboSpan" id="kobo.545.2">In fact, this pattern is so common that Rx comes with the </span><code class="literal"><span class="koboSpan" id="kobo.546.1">Observable.from</span></code><span class="koboSpan" id="kobo.547.1"> factory method that converts a </span><code class="literal"><span class="koboSpan" id="kobo.548.1">Future</span></code><span class="koboSpan" id="kobo.549.1"> object into an </span><code class="literal"><span class="koboSpan" id="kobo.550.1">Observable</span></code><span class="koboSpan" id="kobo.551.1"> object directly, as shown by the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.552.1">val o = Observable.from(Future { "Back to the Future(s)" }) 
</span></pre><p><span class="koboSpan" id="kobo.553.1">Still, learning how to convert a </span><code class="literal"><span class="koboSpan" id="kobo.554.1">Future</span></code><span class="koboSpan" id="kobo.555.1"> object into an </span><code class="literal"><span class="koboSpan" id="kobo.556.1">Observable</span></code><span class="koboSpan" id="kobo.557.1"> object is handy. </span><span class="koboSpan" id="kobo.557.2">The </span><code class="literal"><span class="koboSpan" id="kobo.558.1">Observable.create</span></code><span class="koboSpan" id="kobo.559.1"> method is the preferred way to convert callback-based APIs to </span><code class="literal"><span class="koboSpan" id="kobo.560.1">Observable</span></code><span class="koboSpan" id="kobo.561.1"> objects, as we will see in subsequent sections.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip64"/><span class="koboSpan" id="kobo.562.1">Tip</span></h3><p><span class="koboSpan" id="kobo.563.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.564.1">Observable.create</span></code><span class="koboSpan" id="kobo.565.1"> factory method to create the </span><code class="literal"><span class="koboSpan" id="kobo.566.1">Observable</span></code><span class="koboSpan" id="kobo.567.1"> objects from callback-based APIs.</span></p></div></div><p><span class="koboSpan" id="kobo.568.1">In the examples so far, we have always returned an empty </span><code class="literal"><span class="koboSpan" id="kobo.569.1">Subscription</span></code><span class="koboSpan" id="kobo.570.1"> object. </span><span class="koboSpan" id="kobo.570.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.571.1">unsubscribe</span></code><span class="koboSpan" id="kobo.572.1"> method on such a </span><code class="literal"><span class="koboSpan" id="kobo.573.1">Subscription</span></code><span class="koboSpan" id="kobo.574.1"> object has no effect. </span><span class="koboSpan" id="kobo.574.2">Sometimes, the </span><code class="literal"><span class="koboSpan" id="kobo.575.1">Subscription</span></code><span class="koboSpan" id="kobo.576.1"> objects need to release resources associated with the corresponding </span><code class="literal"><span class="koboSpan" id="kobo.577.1">Observable</span></code><span class="koboSpan" id="kobo.578.1"> instance. </span><span class="koboSpan" id="kobo.578.2">We will study how to implement and work with such </span><code class="literal"><span class="koboSpan" id="kobo.579.1">Subscription</span></code><span class="koboSpan" id="kobo.580.1"> objects next.</span></p></div><div class="section" title="Subscriptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/><span class="koboSpan" id="kobo.581.1">Subscriptions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.582.1">Recall the example monitoring the filesystem for changes in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.583.1">Chapter 4</span></a><span class="koboSpan" id="kobo.584.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.585.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.586.1">, where we used the file monitoring package from the Apache Commons IO library to complete a </span><code class="literal"><span class="koboSpan" id="kobo.587.1">Future</span></code><span class="koboSpan" id="kobo.588.1"> object when a new file is created. </span><span class="koboSpan" id="kobo.588.2">A </span><code class="literal"><span class="koboSpan" id="kobo.589.1">Future</span></code><span class="koboSpan" id="kobo.590.1"> object can be completed only once, so the future was completed with the name of the first file that was created. </span><span class="koboSpan" id="kobo.590.2">It is more natural to use </span><code class="literal"><span class="koboSpan" id="kobo.591.1">Observable</span></code><span class="koboSpan" id="kobo.592.1"> objects for this use case, as files in a filesystem can be created and deleted many times. </span><span class="koboSpan" id="kobo.592.2">In an application such as a file browser or an FTP server, we would like to receive all such events.</span></p><p><span class="koboSpan" id="kobo.593.1">Later in the program, we might want to unsubscribe from the events in the </span><code class="literal"><span class="koboSpan" id="kobo.594.1">Observable</span></code><span class="koboSpan" id="kobo.595.1"> object. </span><span class="koboSpan" id="kobo.595.2">We will now see how to use the </span><code class="literal"><span class="koboSpan" id="kobo.596.1">Subscription</span></code><span class="koboSpan" id="kobo.597.1"> object to achieve this. </span><span class="koboSpan" id="kobo.597.2">We first import the contents of the </span><span class="strong"><strong><span class="koboSpan" id="kobo.598.1">Apache Commons IO file monitoring</span></strong></span><span class="koboSpan" id="kobo.599.1"> package, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.600.1">import org.apache.commons.io.monitor._ 
</span></pre><p><span class="koboSpan" id="kobo.601.1">We define the </span><code class="literal"><span class="koboSpan" id="kobo.602.1">modified</span></code><span class="koboSpan" id="kobo.603.1"> method, which returns an </span><code class="literal"><span class="koboSpan" id="kobo.604.1">Observable</span></code><span class="koboSpan" id="kobo.605.1"> object with filenames of the modified files in the specified directory. </span><span class="koboSpan" id="kobo.605.2">The </span><code class="literal"><span class="koboSpan" id="kobo.606.1">Observable.create</span></code><span class="koboSpan" id="kobo.607.1"> method bridges the gap between the Commons IO callback-based API and Rx. </span><span class="koboSpan" id="kobo.607.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.608.1">subscribe</span></code><span class="koboSpan" id="kobo.609.1"> method is called, we create a </span><code class="literal"><span class="koboSpan" id="kobo.610.1">FileAlterationMonitor</span></code><span class="koboSpan" id="kobo.611.1"> object, which uses a separate thread to scan the filesystem and emit filesystem events every 1000 milliseconds, a </span><code class="literal"><span class="koboSpan" id="kobo.612.1">FileAlterationObserver</span></code><span class="koboSpan" id="kobo.613.1"> object, which specifies a directory to monitor; and a </span><code class="literal"><span class="koboSpan" id="kobo.614.1">FileAlterationListener</span></code><span class="koboSpan" id="kobo.615.1"> object, which reacts to file events by calling the </span><code class="literal"><span class="koboSpan" id="kobo.616.1">onNext</span></code><span class="koboSpan" id="kobo.617.1"> method on the Rx </span><code class="literal"><span class="koboSpan" id="kobo.618.1">Observer</span></code><span class="koboSpan" id="kobo.619.1"> object. </span><span class="koboSpan" id="kobo.619.2">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.620.1">start</span></code><span class="koboSpan" id="kobo.621.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.622.1">fileMonitor</span></code><span class="koboSpan" id="kobo.623.1"> object.</span></p><p><span class="koboSpan" id="kobo.624.1">Finally, we return a custom </span><code class="literal"><span class="koboSpan" id="kobo.625.1">Subscription</span></code><span class="koboSpan" id="kobo.626.1"> object, which calls </span><code class="literal"><span class="koboSpan" id="kobo.627.1">stop</span></code><span class="koboSpan" id="kobo.628.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.629.1">fileMonitor</span></code><span class="koboSpan" id="kobo.630.1"> object. </span><span class="koboSpan" id="kobo.630.2">The </span><code class="literal"><span class="koboSpan" id="kobo.631.1">modified</span></code><span class="koboSpan" id="kobo.632.1"> method is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.633.1">def modified(directory: String): Observable[String] = { 
  Observable.create { observer =&gt; 
    val fileMonitor = new FileAlterationMonitor(1000) 
    val fileObs = new FileAlterationObserver(directory) 
    val fileLis = new FileAlterationListenerAdaptor { 
      override def onFileChange(file: java.io.File) { 
        observer.onNext(file.getName) 
      } 
    } 
    fileObs.addListener(fileLis) 
    fileMonitor.addObserver(fileObs) 
    fileMonitor.start() 
    Subscription { fileMonitor.stop() } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.634.1">We used the </span><code class="literal"><span class="koboSpan" id="kobo.635.1">apply</span></code><span class="koboSpan" id="kobo.636.1"> factory method on the </span><code class="literal"><span class="koboSpan" id="kobo.637.1">Subscription</span></code><span class="koboSpan" id="kobo.638.1"> companion object in the preceding code snippet. </span><span class="koboSpan" id="kobo.638.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.639.1">unsubscribe</span></code><span class="koboSpan" id="kobo.640.1"> method is called on the resulting </span><code class="literal"><span class="koboSpan" id="kobo.641.1">Subscription</span></code><span class="koboSpan" id="kobo.642.1"> object, the specified block of code is run. </span><span class="koboSpan" id="kobo.642.2">Importantly, calling the </span><code class="literal"><span class="koboSpan" id="kobo.643.1">unsubscribe</span></code><span class="koboSpan" id="kobo.644.1"> method, the second time will not run the specified block of code again. </span><span class="koboSpan" id="kobo.644.2">We say that the </span><code class="literal"><span class="koboSpan" id="kobo.645.1">unsubscribe</span></code><span class="koboSpan" id="kobo.646.1"> method is </span><span class="strong"><strong><span class="koboSpan" id="kobo.647.1">idempotent</span></strong></span><span class="koboSpan" id="kobo.648.1">; calling it multiple times has the same effect as calling it only once. </span><span class="koboSpan" id="kobo.648.2">In our example, the </span><code class="literal"><span class="koboSpan" id="kobo.649.1">unsubscribe</span></code><span class="koboSpan" id="kobo.650.1"> method calls the </span><code class="literal"><span class="koboSpan" id="kobo.651.1">stop</span></code><span class="koboSpan" id="kobo.652.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.653.1">fileMonitor</span></code><span class="koboSpan" id="kobo.654.1"> object at most once. </span><span class="koboSpan" id="kobo.654.2">When sub-classing the </span><code class="literal"><span class="koboSpan" id="kobo.655.1">Subscription</span></code><span class="koboSpan" id="kobo.656.1"> trait, we need to ensure that the </span><code class="literal"><span class="koboSpan" id="kobo.657.1">unsubscribe</span></code><span class="koboSpan" id="kobo.658.1"> method is idempotent, and the </span><code class="literal"><span class="koboSpan" id="kobo.659.1">Subscription.apply</span></code><span class="koboSpan" id="kobo.660.1"> method is a convenience method that ensures idempotence automatically.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip65"/><span class="koboSpan" id="kobo.661.1">Tip</span></h3><p><span class="koboSpan" id="kobo.662.1">Implementations of the </span><code class="literal"><span class="koboSpan" id="kobo.663.1">unsubscribe</span></code><span class="koboSpan" id="kobo.664.1"> method in the </span><code class="literal"><span class="koboSpan" id="kobo.665.1">Subscription</span></code><span class="koboSpan" id="kobo.666.1"> trait need to be idempotent. </span><span class="koboSpan" id="kobo.666.2">Use the </span><code class="literal"><span class="koboSpan" id="kobo.667.1">Subscription.apply</span></code><span class="koboSpan" id="kobo.668.1"> method to create the </span><code class="literal"><span class="koboSpan" id="kobo.669.1">Subscription</span></code><span class="koboSpan" id="kobo.670.1"> objects that are idempotent by default.</span></p></div></div><p><span class="koboSpan" id="kobo.671.1">We use the </span><code class="literal"><span class="koboSpan" id="kobo.672.1">modified</span></code><span class="koboSpan" id="kobo.673.1"> method to track file changes in our project. </span><span class="koboSpan" id="kobo.673.2">After we call the </span><code class="literal"><span class="koboSpan" id="kobo.674.1">subscribe</span></code><span class="koboSpan" id="kobo.675.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.676.1">Observable</span></code><span class="koboSpan" id="kobo.677.1"> object returned by the </span><code class="literal"><span class="koboSpan" id="kobo.678.1">modified</span></code><span class="koboSpan" id="kobo.679.1"> method, the main thread suspends for 10 seconds. </span><span class="koboSpan" id="kobo.679.2">If we save files in our editor during this time, the program will log file modification events to the standard output. </span><span class="koboSpan" id="kobo.679.3">This is shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.680.1">object ObservablesSubscriptions extends App { 
  log(s"starting to monitor files") 
  val sub = modified(".").subscribe(n =&gt; log(s"$n modified!")) 
  log(s"please modify and save a file") 
  Thread.sleep(10000) 
  sub.unsubscribe() 
  log(s"monitoring done") 
} 
</span></pre><p><span class="koboSpan" id="kobo.681.1">Note that, in this example, the </span><code class="literal"><span class="koboSpan" id="kobo.682.1">FileAlterationMonitor</span></code><span class="koboSpan" id="kobo.683.1"> object is only created if the program invokes the </span><code class="literal"><span class="koboSpan" id="kobo.684.1">subscribe</span></code><span class="koboSpan" id="kobo.685.1"> method. </span><span class="koboSpan" id="kobo.685.2">The </span><code class="literal"><span class="koboSpan" id="kobo.686.1">Observable</span></code><span class="koboSpan" id="kobo.687.1"> instance returned by the </span><code class="literal"><span class="koboSpan" id="kobo.688.1">modified</span></code><span class="koboSpan" id="kobo.689.1"> method does not emit events unless there exists an </span><code class="literal"><span class="koboSpan" id="kobo.690.1">Observer</span></code><span class="koboSpan" id="kobo.691.1"> object subscribed to it. </span><span class="koboSpan" id="kobo.691.2">In Rx, the </span><code class="literal"><span class="koboSpan" id="kobo.692.1">Observable</span></code><span class="koboSpan" id="kobo.693.1"> objects that emit events only when subscriptions exist are called </span><span class="strong"><strong><span class="koboSpan" id="kobo.694.1">cold observables</span></strong></span><span class="koboSpan" id="kobo.695.1">. </span><span class="koboSpan" id="kobo.695.2">On the other hand, some </span><code class="literal"><span class="koboSpan" id="kobo.696.1">Observable</span></code><span class="koboSpan" id="kobo.697.1"> objects emit events even when there are no associated subscriptions. </span><span class="koboSpan" id="kobo.697.2">This is usually the case with </span><code class="literal"><span class="koboSpan" id="kobo.698.1">Observable</span></code><span class="koboSpan" id="kobo.699.1"> instances that handle user input, such as keyboard or mouse events. </span><code class="literal"><span class="koboSpan" id="kobo.700.1">Observable</span></code><span class="koboSpan" id="kobo.701.1"> objects that emit events regardless of their subscriptions are called </span><span class="strong"><strong><span class="koboSpan" id="kobo.702.1">hot observables</span></strong></span><span class="koboSpan" id="kobo.703.1">. </span><span class="koboSpan" id="kobo.703.2">We now reimplement an </span><code class="literal"><span class="koboSpan" id="kobo.704.1">Observable</span></code><span class="koboSpan" id="kobo.705.1"> object that tracks file modifications as a hot observable. </span><span class="koboSpan" id="kobo.705.2">We first instantiate and start the </span><code class="literal"><span class="koboSpan" id="kobo.706.1">FileAlterationMonitor</span></code><span class="koboSpan" id="kobo.707.1"> object, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.708.1">val fileMonitor = new FileAlterationMonitor(1000) 
fileMonitor.start() 
</span></pre><p><span class="koboSpan" id="kobo.709.1">The </span><code class="literal"><span class="koboSpan" id="kobo.710.1">Observable</span></code><span class="koboSpan" id="kobo.711.1"> object uses the </span><code class="literal"><span class="koboSpan" id="kobo.712.1">fileMonitor</span></code><span class="koboSpan" id="kobo.713.1"> object to specify the directory in order to monitor. </span><span class="koboSpan" id="kobo.713.2">The downside is that our </span><code class="literal"><span class="koboSpan" id="kobo.714.1">Observable</span></code><span class="koboSpan" id="kobo.715.1"> object now consumes computational resources even when there are no subscriptions. </span><span class="koboSpan" id="kobo.715.2">The advantage of using a hot observable is that multiple subscriptions do not need to instantiate multiple </span><code class="literal"><span class="koboSpan" id="kobo.716.1">FileAlterationMonitor</span></code><span class="koboSpan" id="kobo.717.1"> objects, which are relatively heavyweight. </span><span class="koboSpan" id="kobo.717.2">We implement the hot </span><code class="literal"><span class="koboSpan" id="kobo.718.1">Observable</span></code><span class="koboSpan" id="kobo.719.1"> object in the </span><code class="literal"><span class="koboSpan" id="kobo.720.1">hotModified</span></code><span class="koboSpan" id="kobo.721.1"> method, as shown in the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.722.1">def hotModified(directory: String): Observable[String] = { 
  val fileObs = new FileAlterationObserver(directory) 
  fileMonitor.addObserver(fileObs) 
  Observable.create { observer =&gt; 
    val fileLis = new FileAlterationListenerAdaptor { 
      override def onFileChange(file: java.io.File) { 
        observer.onNext(file.getName) 
      } 
    } 
    fileObs.addListener(fileLis) 
    Subscription { fileObs.removeListener(fileLis) } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.723.1">The </span><code class="literal"><span class="koboSpan" id="kobo.724.1">hotModified</span></code><span class="koboSpan" id="kobo.725.1"> method creates an </span><code class="literal"><span class="koboSpan" id="kobo.726.1">Observable</span></code><span class="koboSpan" id="kobo.727.1"> object with file changes for a given directory by registering the specified directory with the </span><code class="literal"><span class="koboSpan" id="kobo.728.1">fileMonitor</span></code><span class="koboSpan" id="kobo.729.1"> object, and only then calls the </span><code class="literal"><span class="koboSpan" id="kobo.730.1">Observable.create</span></code><span class="koboSpan" id="kobo.731.1"> method. </span><span class="koboSpan" id="kobo.731.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.732.1">subscribe</span></code><span class="koboSpan" id="kobo.733.1"> method is called on the resulting </span><code class="literal"><span class="koboSpan" id="kobo.734.1">Observable</span></code><span class="koboSpan" id="kobo.735.1"> object, we instantiate and add a new </span><code class="literal"><span class="koboSpan" id="kobo.736.1">FileAlterationListener</span></code><span class="koboSpan" id="kobo.737.1"> object. </span><span class="koboSpan" id="kobo.737.2">In the </span><code class="literal"><span class="koboSpan" id="kobo.738.1">Subscription</span></code><span class="koboSpan" id="kobo.739.1"> object, we remove the </span><code class="literal"><span class="koboSpan" id="kobo.740.1">FileAlterationListener</span></code><span class="koboSpan" id="kobo.741.1"> object in order to avoid receiving additional file modification events, but we do not call the </span><code class="literal"><span class="koboSpan" id="kobo.742.1">stop</span></code><span class="koboSpan" id="kobo.743.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.744.1">fileMonitor</span></code><span class="koboSpan" id="kobo.745.1"> object until the program terminates.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Composing Observable objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/><span class="koboSpan" id="kobo.1.1">Composing Observable objects</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Having seen different ways of creating various types of the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Observable</span></code><span class="koboSpan" id="kobo.4.1"> objects, subscribing to their events, and using the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Subscription</span></code><span class="koboSpan" id="kobo.6.1"> objects, we turn our attention to composing the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Observable</span></code><span class="koboSpan" id="kobo.8.1"> objects into larger programs. </span><span class="koboSpan" id="kobo.8.2">From what we have seen so far, the advantages of using the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">Observable</span></code><span class="koboSpan" id="kobo.10.1"> objects over a callback-based API are hardly worth the trouble.</span></p><p><span class="koboSpan" id="kobo.11.1">The true power of Rx becomes apparent when we start composing the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Observable</span></code><span class="koboSpan" id="kobo.13.1"> objects using various combinators. </span><span class="koboSpan" id="kobo.13.2">We can think of an </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Observable</span></code><span class="koboSpan" id="kobo.15.1"> object in a similar way as we think of Scala sequence collections. </span><span class="koboSpan" id="kobo.15.2">In a Scala sequence, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">Seq[T]</span></code><span class="koboSpan" id="kobo.17.1"> trait, elements of type </span><code class="literal"><span class="koboSpan" id="kobo.18.1">T</span></code><span class="koboSpan" id="kobo.19.1"> are ordered in the memory according to their indices. </span><span class="koboSpan" id="kobo.19.2">In an </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Observable[T]</span></code><span class="koboSpan" id="kobo.21.1"> trait, events of type </span><code class="literal"><span class="koboSpan" id="kobo.22.1">T</span></code><span class="koboSpan" id="kobo.23.1"> are ordered in time.</span></p><p><span class="koboSpan" id="kobo.24.1">Let's use the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Observable.interval</span></code><span class="koboSpan" id="kobo.26.1"> factory method in order to create an </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Observable</span></code><span class="koboSpan" id="kobo.28.1"> object, which asynchronously emits a number every 0.5 seconds, and then output the first five odd numbers. </span><span class="koboSpan" id="kobo.28.2">To do this, we first call </span><code class="literal"><span class="koboSpan" id="kobo.29.1">filter</span></code><span class="koboSpan" id="kobo.30.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">Observable</span></code><span class="koboSpan" id="kobo.32.1"> object in order to obtain an intermediate </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Observable</span></code><span class="koboSpan" id="kobo.34.1"> object that emits only odd numbers. </span><span class="koboSpan" id="kobo.34.2">Note that calling the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">filter</span></code><span class="koboSpan" id="kobo.36.1"> on an </span><code class="literal"><span class="koboSpan" id="kobo.37.1">Observable</span></code><span class="koboSpan" id="kobo.38.1"> object is similar to calling </span><code class="literal"><span class="koboSpan" id="kobo.39.1">filter</span></code><span class="koboSpan" id="kobo.40.1"> method on a Scala collection. </span><span class="koboSpan" id="kobo.40.2">Similarly, we obtain another </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Observable</span></code><span class="koboSpan" id="kobo.42.1"> object by calling the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">map</span></code><span class="koboSpan" id="kobo.44.1"> method in order to transform each odd number into a string. </span><span class="koboSpan" id="kobo.44.2">We then call </span><code class="literal"><span class="koboSpan" id="kobo.45.1">take</span></code><span class="koboSpan" id="kobo.46.1"> to create an </span><code class="literal"><span class="koboSpan" id="kobo.47.1">Observable</span></code><span class="koboSpan" id="kobo.48.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.49.1">odds</span></code><span class="koboSpan" id="kobo.50.1">, which  contains only the first five events. </span><span class="koboSpan" id="kobo.50.2">Finally, we subscribe to </span><code class="literal"><span class="koboSpan" id="kobo.51.1">odds</span></code><span class="koboSpan" id="kobo.52.1"> so that we can print the events it emits. </span><span class="koboSpan" id="kobo.52.2">This is shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.53.1">object CompositionMapAndFilter extends App { 
  val odds = Observable.interval(0.5.seconds) 
    .filter(_ % 2 == 1).map(n =&gt; s"num $n").take(5) 
  odds.subscribe( 
    log _, e =&gt; log(s"unexpected $e"), () =&gt; log("no more odds")) 
  Thread.sleep(4000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.54.1">To concisely explain the semantics of different Rx combinators, we often rely on marble diagrams. </span><span class="koboSpan" id="kobo.54.2">These diagrams graphically represent events in an </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Observable</span></code><span class="koboSpan" id="kobo.56.1"> object and transformations between different </span><code class="literal"><span class="koboSpan" id="kobo.57.1">Observable</span></code><span class="koboSpan" id="kobo.58.1"> objects. </span><span class="koboSpan" id="kobo.58.2">The marble diagram represents every </span><code class="literal"><span class="koboSpan" id="kobo.59.1">Observable</span></code><span class="koboSpan" id="kobo.60.1"> object with a timeline containing its events. </span><span class="koboSpan" id="kobo.60.2">The first three intermediate </span><code class="literal"><span class="koboSpan" id="kobo.61.1">Observable</span></code><span class="koboSpan" id="kobo.62.1"> objects never call the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">onCompleted</span></code><span class="koboSpan" id="kobo.64.1"> method on its observers.</span></p><p><span class="koboSpan" id="kobo.65.1">The </span><code class="literal"><span class="koboSpan" id="kobo.66.1">Observable</span></code><span class="koboSpan" id="kobo.67.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.68.1">odds</span></code><span class="koboSpan" id="kobo.69.1"> contains at most five events, so it calls </span><code class="literal"><span class="koboSpan" id="kobo.70.1">onCompleted</span></code><span class="koboSpan" id="kobo.71.1"> after emitting them. </span><span class="koboSpan" id="kobo.71.2">We denote a call to the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">onCompleted</span></code><span class="koboSpan" id="kobo.73.1"> method with a vertical bar in the marble diagram, as shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.74.1"><img src="graphics/image_06_002.jpg" alt="Composing Observable objects"/></span></div><p><span class="koboSpan" id="kobo.75.1">Note that the preceding diagram is a high-level illustration of the relationships between different </span><code class="literal"><span class="koboSpan" id="kobo.76.1">Observable</span></code><span class="koboSpan" id="kobo.77.1"> objects, but some of these events can be omitted during execution. </span><span class="koboSpan" id="kobo.77.2">The particular Rx implementation can detect that the events </span><code class="literal"><span class="koboSpan" id="kobo.78.1">11</span></code><span class="koboSpan" id="kobo.79.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.80.1">12</span></code><span class="koboSpan" id="kobo.81.1"> cannot be observed by the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">subscribe</span></code><span class="koboSpan" id="kobo.83.1"> invocation, so these events are not emitted to save computational resources.</span></p><p><span class="koboSpan" id="kobo.84.1">As an expert on sequential programming in Scala, you probably noticed that we can rewrite the previous program more concisely using the for-comprehensions. </span><span class="koboSpan" id="kobo.84.2">For example, we can output the first five even natural numbers with the following for-comprehension:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.85.1">val evens = for (n &lt;- Observable.from(0 until 9); if n % 2 == 0) 
yield s"even number $n" 
evens.subscribe(log _) 
</span></pre><p><span class="koboSpan" id="kobo.86.1">Before moving on to more complex for-comprehensions, we will study a special kind of </span><code class="literal"><span class="koboSpan" id="kobo.87.1">Observable</span></code><span class="koboSpan" id="kobo.88.1"> object whose events are other </span><code class="literal"><span class="koboSpan" id="kobo.89.1">Observable</span></code><span class="koboSpan" id="kobo.90.1"> objects.</span></p><div class="section" title="Nested Observables"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec58"/><span class="koboSpan" id="kobo.91.1">Nested Observables</span></h2></div></div></div><p><span class="koboSpan" id="kobo.92.1">A nested observable, also called a higher-order event stream, is an </span><code class="literal"><span class="koboSpan" id="kobo.93.1">Observable</span></code><span class="koboSpan" id="kobo.94.1"> object that emits events that are themselves </span><code class="literal"><span class="koboSpan" id="kobo.95.1">Observable</span></code><span class="koboSpan" id="kobo.96.1"> objects. </span><span class="koboSpan" id="kobo.96.2">A higher-order function such as the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">foreach</span></code><span class="koboSpan" id="kobo.98.1"> statement is called a higher-order function because it has a nested function inside its </span><code class="literal"><span class="koboSpan" id="kobo.99.1">(T =&gt; Unit) =&gt; Unit</span></code><span class="koboSpan" id="kobo.100.1"> type. </span><span class="koboSpan" id="kobo.100.2">Similarly, higher-order event streams earned this fancy name because they have a type </span><code class="literal"><span class="koboSpan" id="kobo.101.1">Observable[T]</span></code><span class="koboSpan" id="kobo.102.1"> as part of their type </span><code class="literal"><span class="koboSpan" id="kobo.103.1">Observable[Observable[T]]</span></code><span class="koboSpan" id="kobo.104.1">. </span><span class="koboSpan" id="kobo.104.2">In this section, we will study when the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">nestedObservable</span></code><span class="koboSpan" id="kobo.106.1"> objects are useful and how to manipulate them.</span></p><p><span class="koboSpan" id="kobo.107.1">Let's assume that we are writing a book and we want to add a famous quote at the beginning of each chapter. </span><span class="koboSpan" id="kobo.107.2">Choosing the right quote for a chapter is a hard job and we want to automate it. </span><span class="koboSpan" id="kobo.107.3">We write a short program that uses </span><code class="literal"><span class="koboSpan" id="kobo.108.1">Observable</span></code><span class="koboSpan" id="kobo.109.1"> objects to fetch random quotes from the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.110.1">I Heart Quotes</span></em></span><span class="koboSpan" id="kobo.111.1"> website every 0.5 seconds and prints them to the screen. </span><span class="koboSpan" id="kobo.111.2">Once we see a nice quote, we have to quickly copy it to our book chapter.</span></p><p><span class="koboSpan" id="kobo.112.1">We will start by defining a </span><code class="literal"><span class="koboSpan" id="kobo.113.1">fetchQuote</span></code><span class="koboSpan" id="kobo.114.1"> method that returns a </span><code class="literal"><span class="koboSpan" id="kobo.115.1">Future</span></code><span class="koboSpan" id="kobo.116.1"> object with the text of the quote. </span><span class="koboSpan" id="kobo.116.2">Luckily, the HTTP API of the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.117.1">I Heart Quotes</span></em></span><span class="koboSpan" id="kobo.118.1"> website returns plain text, so we do not need to parse any JSON or XML. </span><span class="koboSpan" id="kobo.118.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">scala.io.Source</span></code><span class="koboSpan" id="kobo.120.1"> object to fetch the contents of the proper URL, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.121.1">import scala.io.Source 
def fetchQuote(): Future[String] = Future { 
  blocking { 
    val url = "http://quotes.stormconsultancy.co.uk/random.json" + 
      "show_permalink=false&amp;show_source=false" 
    Source.fromURL(url).getLines.mkString 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.122.1">Recall that we can convert a </span><code class="literal"><span class="koboSpan" id="kobo.123.1">Future</span></code><span class="koboSpan" id="kobo.124.1"> object to an </span><code class="literal"><span class="koboSpan" id="kobo.125.1">Observable</span></code><span class="koboSpan" id="kobo.126.1"> object using the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">from</span></code><span class="koboSpan" id="kobo.128.1"> factory method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.129.1">def fetchQuoteObservable(): Observable[String] = { 
  Observable.from(fetchQuote()) 
} 
</span></pre><p><span class="koboSpan" id="kobo.130.1">We now use the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">Observable.interval</span></code><span class="koboSpan" id="kobo.132.1"> factory method in order to create an </span><code class="literal"><span class="koboSpan" id="kobo.133.1">Observable</span></code><span class="koboSpan" id="kobo.134.1"> object that emits a number every 0.5 seconds. </span><span class="koboSpan" id="kobo.134.2">For the purposes of our example, we take only the first four numbers. </span><span class="koboSpan" id="kobo.134.3">Then, we map each of these numbers into an </span><code class="literal"><span class="koboSpan" id="kobo.135.1">Observable</span></code><span class="koboSpan" id="kobo.136.1"> object that emits a quote, prefixed with the ordinal number of the quote. </span><span class="koboSpan" id="kobo.136.2">To do this, we call the </span><code class="literal"><span class="koboSpan" id="kobo.137.1">fetchQuoteObservable</span></code><span class="koboSpan" id="kobo.138.1"> method and map the quotes using a nested </span><code class="literal"><span class="koboSpan" id="kobo.139.1">map</span></code><span class="koboSpan" id="kobo.140.1"> call, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.141.1">def quotes: Observable[Observable[String]] = 
  Observable.interval(0.5 seconds).take(4).map { 
    n =&gt; fetchQuoteObservable().map(txt =&gt; s"$n) $txt") 
  } 
</span></pre><p><span class="koboSpan" id="kobo.142.1">Note that the inner </span><code class="literal"><span class="koboSpan" id="kobo.143.1">map</span></code><span class="koboSpan" id="kobo.144.1"> call transforms an </span><code class="literal"><span class="koboSpan" id="kobo.145.1">Observable[String]</span></code><span class="koboSpan" id="kobo.146.1"> instance, which contains the quote text, to another </span><code class="literal"><span class="koboSpan" id="kobo.147.1">Observable[String]</span></code><span class="koboSpan" id="kobo.148.1"> instance, which contains the quote prefixed with a number. </span><span class="koboSpan" id="kobo.148.2">The outer </span><code class="literal"><span class="koboSpan" id="kobo.149.1">map</span></code><span class="koboSpan" id="kobo.150.1"> call transforms the </span><code class="literal"><span class="koboSpan" id="kobo.151.1">Observable[Long]</span></code><span class="koboSpan" id="kobo.152.1"> object, which contains the first four numbers, to an </span><code class="literal"><span class="koboSpan" id="kobo.153.1">Observable[Observable[String]]</span></code><span class="koboSpan" id="kobo.154.1"> instance, which contains </span><code class="literal"><span class="koboSpan" id="kobo.155.1">Observable</span></code><span class="koboSpan" id="kobo.156.1"> objects emitting separate quotes. </span><span class="koboSpan" id="kobo.156.2">The </span><code class="literal"><span class="koboSpan" id="kobo.157.1">Observable</span></code><span class="koboSpan" id="kobo.158.1"> objects created by the </span><code class="literal"><span class="koboSpan" id="kobo.159.1">quotes</span></code><span class="koboSpan" id="kobo.160.1"> method are shown in the following marble diagram. </span><span class="koboSpan" id="kobo.160.2">Events in the nested </span><code class="literal"><span class="koboSpan" id="kobo.161.1">Observable</span></code><span class="koboSpan" id="kobo.162.1"> objects presented last are themselves </span><code class="literal"><span class="koboSpan" id="kobo.163.1">Observable</span></code><span class="koboSpan" id="kobo.164.1"> objects that contain a single event: the text of the quote returned in the </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Future</span></code><span class="koboSpan" id="kobo.166.1"> object. </span><span class="koboSpan" id="kobo.166.2">Note that we omit the nested </span><code class="literal"><span class="koboSpan" id="kobo.167.1">map</span></code><span class="koboSpan" id="kobo.168.1"> call from the diagram to make it more readable:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.169.1"><img src="graphics/image_06_003.jpg" alt="Nested Observables"/></span></div><p><span class="koboSpan" id="kobo.170.1">Drawing a marble diagram makes the contents of this </span><code class="literal"><span class="koboSpan" id="kobo.171.1">Observable</span></code><span class="koboSpan" id="kobo.172.1"> object more understandable, but how do we subscribe to events in an </span><code class="literal"><span class="koboSpan" id="kobo.173.1">Observable[Observable[String]]</span></code><span class="koboSpan" id="kobo.174.1"> object? </span><span class="koboSpan" id="kobo.174.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">subscribe</span></code><span class="koboSpan" id="kobo.176.1"> method on quotes requires observers to handle the </span><code class="literal"><span class="koboSpan" id="kobo.177.1">Observable[String]</span></code><span class="koboSpan" id="kobo.178.1"> objects, and not the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">String</span></code><span class="koboSpan" id="kobo.180.1"> events directly.</span></p><p><span class="koboSpan" id="kobo.181.1">Once again, an analogy with Scala sequence collections is useful in order to understand how to solve this issue. </span><span class="koboSpan" id="kobo.181.2">Whenever we have a nested sequence, say </span><code class="literal"><span class="koboSpan" id="kobo.182.1">Seq[Seq[T]]</span></code><span class="koboSpan" id="kobo.183.1">, we can flatten it to a </span><code class="literal"><span class="koboSpan" id="kobo.184.1">Seq[T]</span></code><span class="koboSpan" id="kobo.185.1"> collection by calling the </span><code class="literal"><span class="koboSpan" id="kobo.186.1">flatten</span></code><span class="koboSpan" id="kobo.187.1"> method. </span><span class="koboSpan" id="kobo.187.2">When we do this, elements of the nested sequences are simply concatenated together. </span><span class="koboSpan" id="kobo.187.3">The Rx API provides similar methods that flatten the </span><code class="literal"><span class="koboSpan" id="kobo.188.1">Observable</span></code><span class="koboSpan" id="kobo.189.1"> objects, but they must deal with the additional complexity associated with the timing of events. </span><span class="koboSpan" id="kobo.189.2">There are different ways of flattening the </span><code class="literal"><span class="koboSpan" id="kobo.190.1">Observable</span></code><span class="koboSpan" id="kobo.191.1"> objects depending on the time when their events arrive.</span></p><p><span class="koboSpan" id="kobo.192.1">The first method, called </span><code class="literal"><span class="koboSpan" id="kobo.193.1">concat</span></code><span class="koboSpan" id="kobo.194.1">, concatenates the </span><code class="literal"><span class="koboSpan" id="kobo.195.1">nestedObservable</span></code><span class="koboSpan" id="kobo.196.1"> objects by ordering all the events in one nested </span><code class="literal"><span class="koboSpan" id="kobo.197.1">Observable</span></code><span class="koboSpan" id="kobo.198.1"> object before the events in a subsequent </span><code class="literal"><span class="koboSpan" id="kobo.199.1">Observable</span></code><span class="koboSpan" id="kobo.200.1"> object. </span><span class="koboSpan" id="kobo.200.2">An </span><code class="literal"><span class="koboSpan" id="kobo.201.1">Observable</span></code><span class="koboSpan" id="kobo.202.1"> object that appears earlier must complete before the events from a subsequent </span><code class="literal"><span class="koboSpan" id="kobo.203.1">Observable</span></code><span class="koboSpan" id="kobo.204.1"> object can be emitted. </span><span class="koboSpan" id="kobo.204.2">The marble diagram for the </span><code class="literal"><span class="koboSpan" id="kobo.205.1">concat</span></code><span class="koboSpan" id="kobo.206.1"> operation is shown in the following figure. Although the quote </span><span class="strong"><strong><span class="koboSpan" id="kobo.207.1">Veni, vidi, vici.</span></strong></span><span class="koboSpan" id="kobo.208.1">, arrives before the quote </span><span class="strong"><strong><span class="koboSpan" id="kobo.209.1">Carpe diem</span></strong></span><span class="koboSpan" id="kobo.210.1">., the quote </span><span class="strong"><strong><span class="koboSpan" id="kobo.211.1">Veni, vidi, vici.</span></strong></span><span class="koboSpan" id="kobo.212.1"> is emitted only after the </span><code class="literal"><span class="koboSpan" id="kobo.213.1">Observable</span></code><span class="koboSpan" id="kobo.214.1"> object associated with the quote </span><span class="strong"><strong><span class="koboSpan" id="kobo.215.1">Carpe diem.</span></strong></span><span class="koboSpan" id="kobo.216.1"> completes. </span><span class="koboSpan" id="kobo.216.2">The resulting </span><code class="literal"><span class="koboSpan" id="kobo.217.1">Observable</span></code><span class="koboSpan" id="kobo.218.1"> object completes only after the </span><code class="literal"><span class="koboSpan" id="kobo.219.1">Observable</span></code><span class="koboSpan" id="kobo.220.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.221.1">quotes</span></code><span class="koboSpan" id="kobo.222.1"> and all the nested </span><code class="literal"><span class="koboSpan" id="kobo.223.1">Observable</span></code><span class="koboSpan" id="kobo.224.1"> objects complete:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.225.1"><img src="graphics/image_06_004.jpg" alt="Nested Observables"/></span></div><p><span class="koboSpan" id="kobo.226.1">The second method is called </span><code class="literal"><span class="koboSpan" id="kobo.227.1">flatten</span></code><span class="koboSpan" id="kobo.228.1">, analogously to the similar method in the Scala collections API. </span><span class="koboSpan" id="kobo.228.2">This method emits events from the nested </span><code class="literal"><span class="koboSpan" id="kobo.229.1">Observable</span></code><span class="koboSpan" id="kobo.230.1"> objects in the order in which they arrive in time, regardless of when the respective nested </span><code class="literal"><span class="koboSpan" id="kobo.231.1">Observable</span></code><span class="koboSpan" id="kobo.232.1"> object started. </span><span class="koboSpan" id="kobo.232.2">An </span><code class="literal"><span class="koboSpan" id="kobo.233.1">Observable</span></code><span class="koboSpan" id="kobo.234.1"> object that appears earlier is not required to complete before events from a subsequent </span><code class="literal"><span class="koboSpan" id="kobo.235.1">Observable</span></code><span class="koboSpan" id="kobo.236.1"> object are emitted.</span></p><p><span class="koboSpan" id="kobo.237.1">This is illustrated in the following marble diagram. </span><span class="koboSpan" id="kobo.237.2">A quote is emitted to the resulting </span><code class="literal"><span class="koboSpan" id="kobo.238.1">Observable</span></code><span class="koboSpan" id="kobo.239.1"> object as soon as it appears on any of the nested </span><code class="literal"><span class="koboSpan" id="kobo.240.1">Observable</span></code><span class="koboSpan" id="kobo.241.1"> objects. </span><span class="koboSpan" id="kobo.241.2">Once </span><code class="literal"><span class="koboSpan" id="kobo.242.1">quotes</span></code><span class="koboSpan" id="kobo.243.1"> and all the nested </span><code class="literal"><span class="koboSpan" id="kobo.244.1">Observable</span></code><span class="koboSpan" id="kobo.245.1"> objects complete, the resulting </span><code class="literal"><span class="koboSpan" id="kobo.246.1">Observable</span></code><span class="koboSpan" id="kobo.247.1"> object completes as well. </span></p><div class="mediaobject"><span class="koboSpan" id="kobo.248.1"><img src="graphics/image_06_005.jpg" alt="Nested Observables"/></span></div><p><span class="koboSpan" id="kobo.249.1">To test the difference between the </span><code class="literal"><span class="koboSpan" id="kobo.250.1">concat</span></code><span class="koboSpan" id="kobo.251.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.252.1">flatten</span></code><span class="koboSpan" id="kobo.253.1"> methods, we subscribe to events in </span><code class="literal"><span class="koboSpan" id="kobo.254.1">quotes</span></code><span class="koboSpan" id="kobo.255.1"> using each of these two methods. </span><span class="koboSpan" id="kobo.255.2">If our network is unreliable or has particularly nondeterministic latency, the order in which the second </span><code class="literal"><span class="koboSpan" id="kobo.256.1">subscribe</span></code><span class="koboSpan" id="kobo.257.1"> call prints the </span><code class="literal"><span class="koboSpan" id="kobo.258.1">quotes</span></code><span class="koboSpan" id="kobo.259.1"> object can be mangled. </span><span class="koboSpan" id="kobo.259.2">We can reduce the interval between queries from 0.5 to 0.01 seconds to witness this effect. </span><span class="koboSpan" id="kobo.259.3">The ordinal numbers preceding each quote become unordered when using the </span><code class="literal"><span class="koboSpan" id="kobo.260.1">flatten</span></code><span class="koboSpan" id="kobo.261.1"> method. </span><span class="koboSpan" id="kobo.261.2">This is illustrated in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.262.1">object CompositionConcatAndFlatten extends App { 
  log(s"Using concat") 
  quotes.concat.subscribe(log _) 
  Thread.sleep(6000) 
  log(s"Now using flatten") 
  quotes.flatten.subscribe(log _) 
  Thread.sleep(6000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.263.1">How do we choose between the </span><code class="literal"><span class="koboSpan" id="kobo.264.1">concat</span></code><span class="koboSpan" id="kobo.265.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.266.1">flatten</span></code><span class="koboSpan" id="kobo.267.1"> methods? </span><span class="koboSpan" id="kobo.267.2">The </span><code class="literal"><span class="koboSpan" id="kobo.268.1">concat</span></code><span class="koboSpan" id="kobo.269.1"> method has the advantage that it maintains the relative order between events coming from different </span><code class="literal"><span class="koboSpan" id="kobo.270.1">Observable</span></code><span class="koboSpan" id="kobo.271.1"> objects. </span><span class="koboSpan" id="kobo.271.2">If we had been fetching and printing quotes in a lexicographic order, then the </span><code class="literal"><span class="koboSpan" id="kobo.272.1">concat</span></code><span class="koboSpan" id="kobo.273.1"> method would be the correct way to flatten the nested </span><code class="literal"><span class="koboSpan" id="kobo.274.1">Observable</span></code><span class="koboSpan" id="kobo.275.1"> objects.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip66"/><span class="koboSpan" id="kobo.276.1">Tip</span></h3><p><span class="koboSpan" id="kobo.277.1">Use </span><code class="literal"><span class="koboSpan" id="kobo.278.1">concat</span></code><span class="koboSpan" id="kobo.279.1"> to flatten nested </span><code class="literal"><span class="koboSpan" id="kobo.280.1">Observable</span></code><span class="koboSpan" id="kobo.281.1"> objects whenever the order of events between different nested </span><code class="literal"><span class="koboSpan" id="kobo.282.1">Observable</span></code><span class="koboSpan" id="kobo.283.1"> objects needs to be maintained.</span></p></div></div><p><span class="koboSpan" id="kobo.284.1">The </span><code class="literal"><span class="koboSpan" id="kobo.285.1">concat</span></code><span class="koboSpan" id="kobo.286.1"> method does not subscribe to subsequent </span><code class="literal"><span class="koboSpan" id="kobo.287.1">Observable</span></code><span class="koboSpan" id="kobo.288.1"> objects before the current </span><code class="literal"><span class="koboSpan" id="kobo.289.1">Observable</span></code><span class="koboSpan" id="kobo.290.1"> object completes. </span><span class="koboSpan" id="kobo.290.2">If one of the nested </span><code class="literal"><span class="koboSpan" id="kobo.291.1">Observable</span></code><span class="koboSpan" id="kobo.292.1"> objects takes a long time to complete or does not complete at all, the events from the remaining </span><code class="literal"><span class="koboSpan" id="kobo.293.1">Observable</span></code><span class="koboSpan" id="kobo.294.1"> objects are postponed or never emitted. </span><span class="koboSpan" id="kobo.294.2">The </span><code class="literal"><span class="koboSpan" id="kobo.295.1">flatten</span></code><span class="koboSpan" id="kobo.296.1"> method subscribes to a nested </span><code class="literal"><span class="koboSpan" id="kobo.297.1">Observable</span></code><span class="koboSpan" id="kobo.298.1"> object as soon as the nested </span><code class="literal"><span class="koboSpan" id="kobo.299.1">Observable</span></code><span class="koboSpan" id="kobo.300.1"> object is emitted, and emits events as soon as they arrive.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip67"/><span class="koboSpan" id="kobo.301.1">Tip</span></h3><p><span class="koboSpan" id="kobo.302.1">If at least one of the nested </span><code class="literal"><span class="koboSpan" id="kobo.303.1">Observable</span></code><span class="koboSpan" id="kobo.304.1"> objects has an unbounded number of events or never completes, use the </span><code class="literal"><span class="koboSpan" id="kobo.305.1">flatten</span></code><span class="koboSpan" id="kobo.306.1"> method instead of the </span><code class="literal"><span class="koboSpan" id="kobo.307.1">concat</span></code><span class="koboSpan" id="kobo.308.1"> method.</span></p></div></div><p><span class="koboSpan" id="kobo.309.1">We can also traverse events from multiple </span><code class="literal"><span class="koboSpan" id="kobo.310.1">Observable</span></code><span class="koboSpan" id="kobo.311.1"> objects in a </span><code class="literal"><span class="koboSpan" id="kobo.312.1">for</span></code><span class="koboSpan" id="kobo.313.1"> comprehension. </span><span class="koboSpan" id="kobo.313.2">The </span><code class="literal"><span class="koboSpan" id="kobo.314.1">Observable</span></code><span class="koboSpan" id="kobo.315.1"> objects come with the </span><code class="literal"><span class="koboSpan" id="kobo.316.1">flatMap</span></code><span class="koboSpan" id="kobo.317.1"> method, and this allows you to use them in </span><code class="literal"><span class="koboSpan" id="kobo.318.1">for</span></code><span class="koboSpan" id="kobo.319.1"> comprehensions. </span><span class="koboSpan" id="kobo.319.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.320.1">flatMap</span></code><span class="koboSpan" id="kobo.321.1"> method on an </span><code class="literal"><span class="koboSpan" id="kobo.322.1">Observable</span></code><span class="koboSpan" id="kobo.323.1"> object is equivalent to mapping each of its events into a nested </span><code class="literal"><span class="koboSpan" id="kobo.324.1">Observable</span></code><span class="koboSpan" id="kobo.325.1"> object, and then calling the </span><code class="literal"><span class="koboSpan" id="kobo.326.1">flatten</span></code><span class="koboSpan" id="kobo.327.1"> method. </span><span class="koboSpan" id="kobo.327.2">Thus, we can rewrite the </span><code class="literal"><span class="koboSpan" id="kobo.328.1">quotes.flatten</span></code><span class="koboSpan" id="kobo.329.1"> method as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.330.1">Observable.interval(0.5 seconds).take(5).flatMap({ 
  n =&gt; fetchQuoteObservable().map(txt =&gt; s"$n) $txt") 
}).subscribe(log _) 
</span></pre><p><span class="koboSpan" id="kobo.331.1">Having already mastered </span><code class="literal"><span class="koboSpan" id="kobo.332.1">for</span></code><span class="koboSpan" id="kobo.333.1"> comprehensions on Scala collections and </span><code class="literal"><span class="koboSpan" id="kobo.334.1">for</span></code><span class="koboSpan" id="kobo.335.1"> comprehensions on futures, this pattern of </span><code class="literal"><span class="koboSpan" id="kobo.336.1">flatMap</span></code><span class="koboSpan" id="kobo.337.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.338.1">map</span></code><span class="koboSpan" id="kobo.339.1"> calls immediately rings a bell, and we recognize the previous expression as the following </span><code class="literal"><span class="koboSpan" id="kobo.340.1">for</span></code><span class="koboSpan" id="kobo.341.1"> comprehension:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.342.1">val qs = for { 
  n   &lt;- Observable.interval(0.5 seconds).take(5) 
  txt &lt;- fetchQuoteObservable() 
} yield s"$n) $txt" 
qs.subscribe(log _) 
</span></pre><p><span class="koboSpan" id="kobo.343.1">This is much more concise and understandable, and almost feels like we're back with collections land. </span><span class="koboSpan" id="kobo.343.2">Still, we need to be careful, because for-comprehensions on </span><code class="literal"><span class="koboSpan" id="kobo.344.1">Observable</span></code><span class="koboSpan" id="kobo.345.1"> objects do not maintain the relative order of the events in the way that the for-comprehensions on collections do. </span><span class="koboSpan" id="kobo.345.2">In the preceding example, as soon as we can pair a </span><code class="literal"><span class="koboSpan" id="kobo.346.1">n</span></code><span class="koboSpan" id="kobo.347.1"> number with some quote </span><code class="literal"><span class="koboSpan" id="kobo.348.1">txt</span></code><span class="koboSpan" id="kobo.349.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.350.1">s"$n) $txt"</span></code><span class="koboSpan" id="kobo.351.1"> event is emitted, irrespective of the events associated with the preceding </span><code class="literal"><span class="koboSpan" id="kobo.352.1">n</span></code><span class="koboSpan" id="kobo.353.1"> number.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note68"/><span class="koboSpan" id="kobo.354.1">Note</span></h3><p><span class="koboSpan" id="kobo.355.1">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.356.1">flatMap</span></code><span class="koboSpan" id="kobo.357.1"> method or using </span><code class="literal"><span class="koboSpan" id="kobo.358.1">Observable</span></code><span class="koboSpan" id="kobo.359.1"> objects in </span><code class="literal"><span class="koboSpan" id="kobo.360.1">for</span></code><span class="koboSpan" id="kobo.361.1"> comprehensions emits events in the order in which they arrive, and it does not maintain ordering between events from different </span><code class="literal"><span class="koboSpan" id="kobo.362.1">Observable</span></code><span class="koboSpan" id="kobo.363.1"> objects. </span><span class="koboSpan" id="kobo.363.2">Invoking the </span><code class="literal"><span class="koboSpan" id="kobo.364.1">flatMap</span></code><span class="koboSpan" id="kobo.365.1"> method is semantically equivalent to calling </span><code class="literal"><span class="koboSpan" id="kobo.366.1">map</span></code><span class="koboSpan" id="kobo.367.1"> followed by the </span><code class="literal"><span class="koboSpan" id="kobo.368.1">flatten</span></code><span class="koboSpan" id="kobo.369.1"> call.</span></p></div></div><p><span class="koboSpan" id="kobo.370.1">An attentive reader will notice that we did not consider the case where one of the nested </span><code class="literal"><span class="koboSpan" id="kobo.371.1">Observable</span></code><span class="koboSpan" id="kobo.372.1"> objects terminates by calling the </span><code class="literal"><span class="koboSpan" id="kobo.373.1">onError</span></code><span class="koboSpan" id="kobo.374.1"> method. </span><span class="koboSpan" id="kobo.374.2">When this happens, both </span><code class="literal"><span class="koboSpan" id="kobo.375.1">concat</span></code><span class="koboSpan" id="kobo.376.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.377.1">flatten</span></code><span class="koboSpan" id="kobo.378.1"> call the </span><code class="literal"><span class="koboSpan" id="kobo.379.1">onError</span></code><span class="koboSpan" id="kobo.380.1"> method with the same exception. </span><span class="koboSpan" id="kobo.380.2">Similarly, </span><code class="literal"><span class="koboSpan" id="kobo.381.1">map</span></code><span class="koboSpan" id="kobo.382.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.383.1">filter</span></code><span class="koboSpan" id="kobo.384.1"> fail the resulting </span><code class="literal"><span class="koboSpan" id="kobo.385.1">Observable</span></code><span class="koboSpan" id="kobo.386.1"> object if the input </span><code class="literal"><span class="koboSpan" id="kobo.387.1">Observable</span></code><span class="koboSpan" id="kobo.388.1"> object produces an exception, so it is unclear how to compose failed </span><code class="literal"><span class="koboSpan" id="kobo.389.1">Observable</span></code><span class="koboSpan" id="kobo.390.1"> objects. </span><span class="koboSpan" id="kobo.390.2">This is the focus of the next section.</span></p></div><div class="section" title="Failure handling in Observables"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec59"/><span class="koboSpan" id="kobo.391.1">Failure handling in Observables</span></h2></div></div></div><p><span class="koboSpan" id="kobo.392.1">If you ran the previous examples yourself, you might have noticed that some of the quotes are long and tedious to read. </span><span class="koboSpan" id="kobo.392.2">We don't want to put a long quote at the beginning of the chapter. </span><span class="koboSpan" id="kobo.392.3">If we did that, our readers might lose interest. </span><span class="koboSpan" id="kobo.392.4">The best quotes are short and straight to the point.</span></p><p><span class="koboSpan" id="kobo.393.1">Our next goal will be to replace quotes longer than 100 characters with a string </span><code class="literal"><span class="koboSpan" id="kobo.394.1">Retrying...</span></code><span class="koboSpan" id="kobo.395.1"> and print the first quote shorter than 100 characters. </span><span class="koboSpan" id="kobo.395.2">This time, we define an </span><code class="literal"><span class="koboSpan" id="kobo.396.1">Observable</span></code><span class="koboSpan" id="kobo.397.1"> object called </span><code class="literal"><span class="koboSpan" id="kobo.398.1">randomQuote</span></code><span class="koboSpan" id="kobo.399.1">, which emits a random quote every time we subscribe to it. </span><span class="koboSpan" id="kobo.399.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.400.1">Observable.create</span></code><span class="koboSpan" id="kobo.401.1"> method in order to obtain a random quote as before and emit the quote to the observer. </span><span class="koboSpan" id="kobo.401.2">We then return an empty </span><code class="literal"><span class="koboSpan" id="kobo.402.1">Subscription</span></code><span class="koboSpan" id="kobo.403.1"> object. </span><span class="koboSpan" id="kobo.403.2">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.404.1">def randomQuote = Observable.create[String] { obs =&gt; 
  val url = "http://www.iheartquotes.com/api/v1/random?" </span><span class="koboSpan" id="kobo.404.2">+ 
    "show_permalink=false&amp;show_source=false" 
  obs.onNext(Source.fromURL(url).getLines.mkString) 
  obs.onCompleted() 
  Subscription() 
} 
</span></pre><p><span class="koboSpan" id="kobo.405.1">There is a subtle difference between the </span><code class="literal"><span class="koboSpan" id="kobo.406.1">Observable</span></code><span class="koboSpan" id="kobo.407.1"> object returned by the </span><code class="literal"><span class="koboSpan" id="kobo.408.1">randomQuote</span></code><span class="koboSpan" id="kobo.409.1"> method and the one returned by the </span><code class="literal"><span class="koboSpan" id="kobo.410.1">fetchQuoteObservable</span></code><span class="koboSpan" id="kobo.411.1"> method, defined earlier. </span><span class="koboSpan" id="kobo.411.2">The </span><code class="literal"><span class="koboSpan" id="kobo.412.1">fetchQuoteObservable</span></code><span class="koboSpan" id="kobo.413.1"> method creates a </span><code class="literal"><span class="koboSpan" id="kobo.414.1">Future</span></code><span class="koboSpan" id="kobo.415.1"> object in order to obtain a quote and emits the quote in that </span><code class="literal"><span class="koboSpan" id="kobo.416.1">Future</span></code><span class="koboSpan" id="kobo.417.1"> object to every observer. </span><span class="koboSpan" id="kobo.417.2">By contrast, the </span><code class="literal"><span class="koboSpan" id="kobo.418.1">randomQuote</span></code><span class="koboSpan" id="kobo.419.1"> method fetches a new quote every time the </span><code class="literal"><span class="koboSpan" id="kobo.420.1">subscribe</span></code><span class="koboSpan" id="kobo.421.1"> method is called. </span><span class="koboSpan" id="kobo.421.2">In the previously introduced terminology, the </span><code class="literal"><span class="koboSpan" id="kobo.422.1">randomQuote</span></code><span class="koboSpan" id="kobo.423.1"> method creates cold </span><code class="literal"><span class="koboSpan" id="kobo.424.1">Observable</span></code><span class="koboSpan" id="kobo.425.1"> objects, which emit events only when we subscribe to them, whereas the </span><code class="literal"><span class="koboSpan" id="kobo.426.1">fetchQuoteObservable</span></code><span class="koboSpan" id="kobo.427.1"> method creates hot </span><code class="literal"><span class="koboSpan" id="kobo.428.1">Observable</span></code><span class="koboSpan" id="kobo.429.1"> objects, which emit the same quote to all their observers.</span></p><p><span class="koboSpan" id="kobo.430.1">To re-subscribe to a failed </span><code class="literal"><span class="koboSpan" id="kobo.431.1">Observable</span></code><span class="koboSpan" id="kobo.432.1"> object, we can use the </span><code class="literal"><span class="koboSpan" id="kobo.433.1">retry</span></code><span class="koboSpan" id="kobo.434.1"> combinator. </span><span class="koboSpan" id="kobo.434.2">The </span><code class="literal"><span class="koboSpan" id="kobo.435.1">retry</span></code><span class="koboSpan" id="kobo.436.1"> combinator takes an input </span><code class="literal"><span class="koboSpan" id="kobo.437.1">Observable</span></code><span class="koboSpan" id="kobo.438.1">, and returns another </span><code class="literal"><span class="koboSpan" id="kobo.439.1">Observable</span></code><span class="koboSpan" id="kobo.440.1"> object that emits events from the input </span><code class="literal"><span class="koboSpan" id="kobo.441.1">Observable</span></code><span class="koboSpan" id="kobo.442.1"> object until it either completes or fails. </span><span class="koboSpan" id="kobo.442.2">If the input </span><code class="literal"><span class="koboSpan" id="kobo.443.1">Observable</span></code><span class="koboSpan" id="kobo.444.1"> object fails, the </span><code class="literal"><span class="koboSpan" id="kobo.445.1">retry</span></code><span class="koboSpan" id="kobo.446.1"> combinator subscribes to the input </span><code class="literal"><span class="koboSpan" id="kobo.447.1">Observable</span></code><span class="koboSpan" id="kobo.448.1"> object again.</span></p><p><span class="koboSpan" id="kobo.449.1">We now use the </span><code class="literal"><span class="koboSpan" id="kobo.450.1">retry</span></code><span class="koboSpan" id="kobo.451.1"> combinator with the </span><code class="literal"><span class="koboSpan" id="kobo.452.1">randomQuote</span></code><span class="koboSpan" id="kobo.453.1"> method to fetch quotes until we obtain a quote shorter than 100 characters. </span><span class="koboSpan" id="kobo.453.2">We first transform the long quotes from the </span><code class="literal"><span class="koboSpan" id="kobo.454.1">randomQuote</span></code><span class="koboSpan" id="kobo.455.1"> method into failed observables, which enables </span><code class="literal"><span class="koboSpan" id="kobo.456.1">retry</span></code><span class="koboSpan" id="kobo.457.1"> to subscribe again to obtain another quote. </span><span class="koboSpan" id="kobo.457.2">To do this, we define a new </span><code class="literal"><span class="koboSpan" id="kobo.458.1">Observable</span></code><span class="koboSpan" id="kobo.459.1"> object called </span><code class="literal"><span class="koboSpan" id="kobo.460.1">errorMessage</span></code><span class="koboSpan" id="kobo.461.1">, which emits a string </span><code class="literal"><span class="koboSpan" id="kobo.462.1">"Retrying..."</span></code><span class="koboSpan" id="kobo.463.1"> and then fails. </span><span class="koboSpan" id="kobo.463.2">We then traverse the </span><code class="literal"><span class="koboSpan" id="kobo.464.1">text</span></code><span class="koboSpan" id="kobo.465.1"> quote from </span><code class="literal"><span class="koboSpan" id="kobo.466.1">randomQuote</span></code><span class="koboSpan" id="kobo.467.1"> in a </span><code class="literal"><span class="koboSpan" id="kobo.468.1">for</span></code><span class="koboSpan" id="kobo.469.1"> comprehension. </span><span class="koboSpan" id="kobo.469.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.470.1">text</span></code><span class="koboSpan" id="kobo.471.1"> quote is shorter than 100 characters, we traverse an </span><code class="literal"><span class="koboSpan" id="kobo.472.1">Observable</span></code><span class="koboSpan" id="kobo.473.1"> object that emits text. </span><span class="koboSpan" id="kobo.473.2">Otherwise, we traverse the </span><code class="literal"><span class="koboSpan" id="kobo.474.1">errorMessage</span></code><span class="koboSpan" id="kobo.475.1"> object to output </span><code class="literal"><span class="koboSpan" id="kobo.476.1">"Retrying..."</span></code><span class="koboSpan" id="kobo.477.1"> instead of </span><code class="literal"><span class="koboSpan" id="kobo.478.1">text</span></code><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">This </span><code class="literal"><span class="koboSpan" id="kobo.480.1">for</span></code><span class="koboSpan" id="kobo.481.1"> comprehension defines an </span><code class="literal"><span class="koboSpan" id="kobo.482.1">Observable</span></code><span class="koboSpan" id="kobo.483.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.484.1">quoteMessage</span></code><span class="koboSpan" id="kobo.485.1">, which either emits a short quote, or emits </span><code class="literal"><span class="koboSpan" id="kobo.486.1">"Retrying..."</span></code><span class="koboSpan" id="kobo.487.1"> and fails. </span><span class="koboSpan" id="kobo.487.2">The marble diagram of the resulting </span><code class="literal"><span class="koboSpan" id="kobo.488.1">Observable</span></code><span class="koboSpan" id="kobo.489.1"> object, called </span><code class="literal"><span class="koboSpan" id="kobo.490.1">quoteMessage</span></code><span class="koboSpan" id="kobo.491.1">, is shown for these two cases, in which the exception in the </span><code class="literal"><span class="koboSpan" id="kobo.492.1">Observable</span></code><span class="koboSpan" id="kobo.493.1"> object is shown with a cross symbol:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.494.1"><img src="graphics/image_06_006.jpg" alt="Failure handling in Observables"/></span></div><p><span class="koboSpan" id="kobo.495.1">Finally, we call the </span><code class="literal"><span class="koboSpan" id="kobo.496.1">retry</span></code><span class="koboSpan" id="kobo.497.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.498.1">quoteMessage</span></code><span class="koboSpan" id="kobo.499.1"> object and subscribe to it. </span><span class="koboSpan" id="kobo.499.2">We specify that we want to retry up to five times, as omitting the argument would retry forever. </span><span class="koboSpan" id="kobo.499.3">We implement the </span><code class="literal"><span class="koboSpan" id="kobo.500.1">Observable</span></code><span class="koboSpan" id="kobo.501.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.502.1">quoteMessage</span></code><span class="koboSpan" id="kobo.503.1"> in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.504.1">object CompositionRetry extends App { 
  import Observable._ 
  def errorMessage = items("Retrying...") ++ error(new Exception) 
  def quoteMessage = for { 
    text    &lt;- randomQuote 
    message &lt;- if (text.size &lt; 100) items(text) else errorMessage 
  } yield message 
  quoteMessage.retry(5).subscribe(log _) 
  Thread.sleep(2500) 
} 
</span></pre><p><span class="koboSpan" id="kobo.505.1">Run this program several times. </span><span class="koboSpan" id="kobo.505.2">You will notice that a short quote is either printed right away, or after a few retries, depending on some random distribution of the quotes. </span><span class="koboSpan" id="kobo.505.3">You may be wondering how many quotes are on average longer than 100 characters. </span><span class="koboSpan" id="kobo.505.4">It turns out that it is easy to do this statistic in Rx. </span><span class="koboSpan" id="kobo.505.5">We introduce two new combinators. </span><span class="koboSpan" id="kobo.505.6">The first one is called </span><code class="literal"><span class="koboSpan" id="kobo.506.1">repeat</span></code><span class="koboSpan" id="kobo.507.1">, and it is very similar to </span><code class="literal"><span class="koboSpan" id="kobo.508.1">retry</span></code><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">Instead of re-subscribing to an </span><code class="literal"><span class="koboSpan" id="kobo.510.1">Observable</span></code><span class="koboSpan" id="kobo.511.1"> object when it fails, it re-subscribes when an </span><code class="literal"><span class="koboSpan" id="kobo.512.1">Observable</span></code><span class="koboSpan" id="kobo.513.1"> object completes. </span><span class="koboSpan" id="kobo.513.2">The second combinator is called </span><code class="literal"><span class="koboSpan" id="kobo.514.1">scan</span></code><span class="koboSpan" id="kobo.515.1"> and it is similar to the </span><code class="literal"><span class="koboSpan" id="kobo.516.1">scanLeft</span></code><span class="koboSpan" id="kobo.517.1"> operator on collections. </span><span class="koboSpan" id="kobo.517.2">Given an input </span><code class="literal"><span class="koboSpan" id="kobo.518.1">Observable</span></code><span class="koboSpan" id="kobo.519.1"> object and a starting value for the accumulation, it emits the value of the accumulation by applying the specified binary operator to the accumulation and the event, updating the accumulation as the events arrive. </span><span class="koboSpan" id="kobo.519.2">The usage of the </span><code class="literal"><span class="koboSpan" id="kobo.520.1">repeat</span></code><span class="koboSpan" id="kobo.521.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.522.1">scan</span></code><span class="koboSpan" id="kobo.523.1"> combinators is illustrated in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.524.1">object CompositionScan extends App { 
  CompositionRetry.quoteMessage.retry.repeat.take(100).scan(0) { 
    (n, q) =&gt; if (q == "Retrying...") n + 1 else n 
  } subscribe(n =&gt; log(s"$n / 100")) 
} 
</span></pre><p><span class="koboSpan" id="kobo.525.1">In the preceding example, we use the </span><code class="literal"><span class="koboSpan" id="kobo.526.1">Observable</span></code><span class="koboSpan" id="kobo.527.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.528.1">quoteMessage</span></code><span class="koboSpan" id="kobo.529.1"> defined earlier in order to obtain a short quote or a message </span><code class="literal"><span class="koboSpan" id="kobo.530.1">"Retrying..."</span></code><span class="koboSpan" id="kobo.531.1"> followed by an exception. </span><span class="koboSpan" id="kobo.531.2">We retry quotes that have failed because of being too long, and repeat whenever a quote is short enough. </span><span class="koboSpan" id="kobo.531.3">We take 100 quotes in total, and use the </span><code class="literal"><span class="koboSpan" id="kobo.532.1">scan</span></code><span class="koboSpan" id="kobo.533.1"> operator to count the short quotes. </span><span class="koboSpan" id="kobo.533.2">When we ran this program, it turned out that 57 out of 100 quotes are too long for our book.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note69"/><span class="koboSpan" id="kobo.534.1">Note</span></h3><p><span class="koboSpan" id="kobo.535.1">The </span><code class="literal"><span class="koboSpan" id="kobo.536.1">retry</span></code><span class="koboSpan" id="kobo.537.1"> method is used in order to repeat events from failed </span><code class="literal"><span class="koboSpan" id="kobo.538.1">Observable</span></code><span class="koboSpan" id="kobo.539.1"> objects. </span><span class="koboSpan" id="kobo.539.2">Similarly, the </span><code class="literal"><span class="koboSpan" id="kobo.540.1">repeat</span></code><span class="koboSpan" id="kobo.541.1"> method is used in order to repeat events from completed </span><code class="literal"><span class="koboSpan" id="kobo.542.1">Observable</span></code><span class="koboSpan" id="kobo.543.1"> objects.</span></p></div></div><p><span class="koboSpan" id="kobo.544.1">In the examples shown so far, we use the same </span><code class="literal"><span class="koboSpan" id="kobo.545.1">Observable</span></code><span class="koboSpan" id="kobo.546.1"> object to re-subscribe and emit additional events if that </span><code class="literal"><span class="koboSpan" id="kobo.547.1">Observable</span></code><span class="koboSpan" id="kobo.548.1"> object fails. </span><span class="koboSpan" id="kobo.548.2">In some cases, we want to emit specific events when we encounter an exception, or fall back to a different </span><code class="literal"><span class="koboSpan" id="kobo.549.1">Observable</span></code><span class="koboSpan" id="kobo.550.1"> object. </span><span class="koboSpan" id="kobo.550.2">Recall that this is what we did with </span><code class="literal"><span class="koboSpan" id="kobo.551.1">Future</span></code><span class="koboSpan" id="kobo.552.1"> objects previously. </span><span class="koboSpan" id="kobo.552.2">The Rx methods that replace an exception with an event, or multiple events from another </span><code class="literal"><span class="koboSpan" id="kobo.553.1">Observable</span></code><span class="koboSpan" id="kobo.554.1"> object, are called </span><code class="literal"><span class="koboSpan" id="kobo.555.1">onErrorReturn</span></code><span class="koboSpan" id="kobo.556.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.557.1">onErrorResumeNext</span></code><span class="koboSpan" id="kobo.558.1">, respectively. </span><span class="koboSpan" id="kobo.558.2">In the following program, we first replace the exception from </span><code class="literal"><span class="koboSpan" id="kobo.559.1">status</span></code><span class="koboSpan" id="kobo.560.1"> with a string </span><code class="literal"><span class="koboSpan" id="kobo.561.1">"exception occurred."</span></code><span class="koboSpan" id="kobo.562.1">. </span><span class="koboSpan" id="kobo.562.2">We then replace the exception with strings from another </span><code class="literal"><span class="koboSpan" id="kobo.563.1">Observable</span></code><span class="koboSpan" id="kobo.564.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.565.1">object CompositionErrors extends App { 
  val status = items("ok", "still ok") ++ error(new Exception) 
  val fixedStatus = 
    status.onErrorReturn(e =&gt; "exception occurred.") 
  fixedStatus.subscribe(log _) 
  val continuedStatus = 
    status.onErrorResumeNext(e =&gt; items("better", "much better")) 
  continuedStatus.subscribe(log _) 
} 
</span></pre><p><span class="koboSpan" id="kobo.566.1">Having seen various ways to compose </span><code class="literal"><span class="koboSpan" id="kobo.567.1">Observable</span></code><span class="koboSpan" id="kobo.568.1"> objects, we turn to the concurrency features of Rx. </span><span class="koboSpan" id="kobo.568.2">So far, we did not pay close attention to the thread on which an </span><code class="literal"><span class="koboSpan" id="kobo.569.1">Observable</span></code><span class="koboSpan" id="kobo.570.1"> object emits events. </span><span class="koboSpan" id="kobo.570.2">In the next section, we will study how to transfer events between </span><code class="literal"><span class="koboSpan" id="kobo.571.1">Observable</span></code><span class="koboSpan" id="kobo.572.1"> objects on different threads, and learn when this can be useful.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Rx schedulers"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/><span class="koboSpan" id="kobo.1.1">Rx schedulers</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">At the beginning of this chapter, we observed that different </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Observable</span></code><span class="koboSpan" id="kobo.4.1"> objects emit events on different threads. </span><span class="koboSpan" id="kobo.4.2">A synchronous </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Observable</span></code><span class="koboSpan" id="kobo.6.1"> object emits on the caller thread when the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">subscribe</span></code><span class="koboSpan" id="kobo.8.1"> method gets invoked. </span><span class="koboSpan" id="kobo.8.2">The </span><code class="literal"><span class="koboSpan" id="kobo.9.1">Observable.timer</span></code><span class="koboSpan" id="kobo.10.1"> object emits events asynchronously on threads internally used by Rx. </span><span class="koboSpan" id="kobo.10.2">Similarly, events in </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Observable</span></code><span class="koboSpan" id="kobo.12.1"> objects created from </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Future</span></code><span class="koboSpan" id="kobo.14.1"> objects are emitted on </span><code class="literal"><span class="koboSpan" id="kobo.15.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.16.1"> threads. </span><span class="koboSpan" id="kobo.16.2">What if we want to use an existing </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Observable</span></code><span class="koboSpan" id="kobo.18.1"> object to create another </span><code class="literal"><span class="koboSpan" id="kobo.19.1">Observable</span></code><span class="koboSpan" id="kobo.20.1"> object bound to a specific thread?</span></p><p><span class="koboSpan" id="kobo.21.1">To encapsulate the choice of the thread on which an </span><code class="literal"><span class="koboSpan" id="kobo.22.1">Observable</span></code><span class="koboSpan" id="kobo.23.1"> object should emit events, Rx defines a special class called </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Scheduler</span></code><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">A </span><code class="literal"><span class="koboSpan" id="kobo.26.1">Scheduler</span></code><span class="koboSpan" id="kobo.27.1"> class is similar to the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">Executor</span></code><span class="koboSpan" id="kobo.29.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.30.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.31.1"> interfaces we saw in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.32.1">Chapter 3</span></a><span class="koboSpan" id="kobo.33.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.34.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">The </span><code class="literal"><span class="koboSpan" id="kobo.36.1">Observable</span></code><span class="koboSpan" id="kobo.37.1"> objects come with a combinator called </span><code class="literal"><span class="koboSpan" id="kobo.38.1">observeOn</span></code><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">This combinator returns a new </span><code class="literal"><span class="koboSpan" id="kobo.40.1">Observable</span></code><span class="koboSpan" id="kobo.41.1"> object that emits events using the specified </span><code class="literal"><span class="koboSpan" id="kobo.42.1">Scheduler</span></code><span class="koboSpan" id="kobo.43.1"> class. </span><span class="koboSpan" id="kobo.43.2">In the following program, we instantiate a </span><code class="literal"><span class="koboSpan" id="kobo.44.1">Scheduler</span></code><span class="koboSpan" id="kobo.45.1"> object called </span><code class="literal"><span class="koboSpan" id="kobo.46.1">ComputationScheduler</span></code><span class="koboSpan" id="kobo.47.1">, which emits events using an internal thread pool. </span><span class="koboSpan" id="kobo.47.2">We then emit events with and without calling the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">observeOn</span></code><span class="koboSpan" id="kobo.49.1"> combinator:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">object SchedulersComputation extends App { 
  val scheduler = schedulers.ComputationScheduler() 
  val numbers = Observable.from(0 until 20) 
  numbers.subscribe(n =&gt; log(s"num $n")) 
  numbers.observeOn(scheduler).subscribe(n =&gt; log(s"num $n")) 
  Thread.sleep(2000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.51.1">From the output, we can see that the second </span><code class="literal"><span class="koboSpan" id="kobo.52.1">subscribe</span></code><span class="koboSpan" id="kobo.53.1"> call uses a thread pool:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">run-main-42: num 0 
... 
</span><span class="koboSpan" id="kobo.54.2">run-main-42: num 19 
RxComputationThreadPool-1: num 0 
... 
</span><span class="koboSpan" id="kobo.54.3">RxComputationThreadPool-1: num 19 
</span></pre><p><span class="koboSpan" id="kobo.55.1">The </span><code class="literal"><span class="koboSpan" id="kobo.56.1">ComputationScheduler</span></code><span class="koboSpan" id="kobo.57.1"> object maintains a pool of threads intended for computational tasks. </span><span class="koboSpan" id="kobo.57.2">If processing the events blocks or waits for I/O operations, we must use the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">IOScheduler</span></code><span class="koboSpan" id="kobo.59.1"> object, which automatically spawns new threads when necessary. </span><span class="koboSpan" id="kobo.59.2">Exceptionally, if processing each event is a very coarse-grained task, we can use the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">NewThreadScheduler</span></code><span class="koboSpan" id="kobo.61.1"> object, which spawns a new thread for each event.</span></p><div class="section" title="Using custom schedulers for UI applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec60"/><span class="koboSpan" id="kobo.62.1">Using custom schedulers for UI applications</span></h2></div></div></div><p><span class="koboSpan" id="kobo.63.1">Built-in Rx schedulers are useful for most tasks, but in some cases we need more control. </span><span class="koboSpan" id="kobo.63.2">Most UI toolkits only allow you to read and modify UI elements from a special thread. </span><span class="koboSpan" id="kobo.63.3">This thread is called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.64.1">event-dispatching</span></strong></span><span class="koboSpan" id="kobo.65.1"> thread. </span><span class="koboSpan" id="kobo.65.2">This approach simplifies the design and the implementation of a UI toolkit, and protects clients from subtle concurrency errors. </span><span class="koboSpan" id="kobo.65.3">Since the UI usually does not usually represent a computational bottleneck, this approach has been widely adopted; the Swing toolkit uses an </span><code class="literal"><span class="koboSpan" id="kobo.66.1">EventDispatchThread</span></code><span class="koboSpan" id="kobo.67.1"> object in order to propagate events.</span></p><p><span class="koboSpan" id="kobo.68.1">The </span><code class="literal"><span class="koboSpan" id="kobo.69.1">Observable</span></code><span class="koboSpan" id="kobo.70.1"> objects are particularly useful when applied to UI applications; a user interface is all about events. </span><span class="koboSpan" id="kobo.70.2">In subsequent examples, we will use the Scala Swing library to illustrate the usefulness of Rx in UI code. </span><span class="koboSpan" id="kobo.70.3">We start by adding the following dependency to our project:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.71.1">libraryDependencies +=  
  "org.scala-lang.modules" %% "scala-swing" % "1.0.1" 
</span></pre><p><span class="koboSpan" id="kobo.72.1">We will start by creating a simple Swing application with a single button. </span><span class="koboSpan" id="kobo.72.2">Clicking on this button will print a message to the standard output. </span><span class="koboSpan" id="kobo.72.3">This application illustrates how to convert Swing events into an </span><code class="literal"><span class="koboSpan" id="kobo.73.1">Observable</span></code><span class="koboSpan" id="kobo.74.1"> object. </span><span class="koboSpan" id="kobo.74.2">We will start by importing the relevant Scala Swing packages as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.75.1">import scala.swing._ 
import scala.swing.event._ 
</span></pre><p><span class="koboSpan" id="kobo.76.1">To create a Swing application, we need to extend the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">SimpleSwingApplication</span></code><span class="koboSpan" id="kobo.78.1"> class. </span><span class="koboSpan" id="kobo.78.2">This class has a single abstract method, </span><code class="literal"><span class="koboSpan" id="kobo.79.1">top</span></code><span class="koboSpan" id="kobo.80.1">, which needs to return a </span><code class="literal"><span class="koboSpan" id="kobo.81.1">Frame</span></code><span class="koboSpan" id="kobo.82.1"> object. </span><span class="koboSpan" id="kobo.82.2">The Swing's abstract </span><code class="literal"><span class="koboSpan" id="kobo.83.1">Frame</span></code><span class="koboSpan" id="kobo.84.1"> class represents the application window. </span><span class="koboSpan" id="kobo.84.2">We return a new </span><code class="literal"><span class="koboSpan" id="kobo.85.1">MainFrame</span></code><span class="koboSpan" id="kobo.86.1"> object, which is a subclass of the </span><code class="literal"><span class="koboSpan" id="kobo.87.1">Frame</span></code><span class="koboSpan" id="kobo.88.1"> object. </span><span class="koboSpan" id="kobo.88.2">In the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">MainFrame</span></code><span class="koboSpan" id="kobo.90.1"> constructor, we set the window title bar text to </span><code class="literal"><span class="koboSpan" id="kobo.91.1">Swing Observables</span></code><span class="koboSpan" id="kobo.92.1">, and instantiate a new </span><code class="literal"><span class="koboSpan" id="kobo.93.1">Button</span></code><span class="koboSpan" id="kobo.94.1"> object with the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">Click</span></code><span class="koboSpan" id="kobo.96.1"> text. </span><span class="koboSpan" id="kobo.96.2">We then set the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">MainFrame</span></code><span class="koboSpan" id="kobo.98.1"> constructor to that button.</span></p><p><span class="koboSpan" id="kobo.99.1">So much for the UI elements and their layout; we now want to add some logic to this simple application. </span><span class="koboSpan" id="kobo.99.2">Traditionally, we would make a Swing application interactive by installing callbacks to various UI elements. </span><span class="koboSpan" id="kobo.99.3">Using Rx, we instead convert callbacks into event streams; we define an </span><code class="literal"><span class="koboSpan" id="kobo.100.1">Observable</span></code><span class="koboSpan" id="kobo.101.1"> object called </span><code class="literal"><span class="koboSpan" id="kobo.102.1">buttonClicks</span></code><span class="koboSpan" id="kobo.103.1"> that emits an event every time the button element is clicked on. </span><span class="koboSpan" id="kobo.103.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.104.1">Observable.create</span></code><span class="koboSpan" id="kobo.105.1"> method in order to register a </span><code class="literal"><span class="koboSpan" id="kobo.106.1">ButtonClicked</span></code><span class="koboSpan" id="kobo.107.1"> callback that calls the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">onNext</span></code><span class="koboSpan" id="kobo.109.1"> method on the observer. </span><span class="koboSpan" id="kobo.109.2">To log clicks to the standard output, we subscribe to </span><code class="literal"><span class="koboSpan" id="kobo.110.1">buttonClicks</span></code><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">The complete Swing application is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.112.1">object SchedulersSwing extends SimpleSwingApplication { 
  def top = new MainFrame { 
    title = "Swing Observables" 
    val button = new Button { 
      text = "Click" 
    } 
    contents = button 
    val buttonClicks = Observable.create[Button] { obs =&gt; 
      button.reactions += { 
        case ButtonClicked(_) =&gt; obs.onNext(button) 
      } 
      Subscription() 
    } 
    buttonClicks.subscribe(_ =&gt; log("button clicked")) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.113.1">Running this application opens the window, shown in the following screenshot. </span><span class="koboSpan" id="kobo.113.2">Clicking on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.114.1">Click</span></strong></span><span class="koboSpan" id="kobo.115.1"> button prints a string to the standard output. </span><span class="koboSpan" id="kobo.115.2">We can see that the events are emitted on the thread called </span><code class="literal"><span class="koboSpan" id="kobo.116.1">AWT-EventQueue-0</span></code><span class="koboSpan" id="kobo.117.1">, which is the event-dispatching thread in Swing:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.118.1"><img src="graphics/image_06_007.jpg" alt="Using custom schedulers for UI applications"/></span></div><p><span class="koboSpan" id="kobo.119.1">One downside of single-threaded UI toolkits is that long-running computations on the event-dispatching thread block the UI and harm the user experience. </span><span class="koboSpan" id="kobo.119.2">If we issue a blocking HTTP request each time the user clicks on a button, we will witness a noticeable lag after each click. </span><span class="koboSpan" id="kobo.119.3">Luckily, this is easy to address by executing long-running computations asynchronously.</span></p><p><span class="koboSpan" id="kobo.120.1">Usually, we are not content with just starting an asynchronous computation. </span><span class="koboSpan" id="kobo.120.2">Once the asynchronous computation produces a result, we would like to display it in the application. </span><span class="koboSpan" id="kobo.120.3">Recall that we are not allowed to do this directly from the computation thread; we need to return the control back to event-dispatching thread. </span><span class="koboSpan" id="kobo.120.4">Swing defines the </span><code class="literal"><span class="koboSpan" id="kobo.121.1">invokeLater</span></code><span class="koboSpan" id="kobo.122.1"> method, which schedules tasks on Swing's event-dispatching thread. </span><span class="koboSpan" id="kobo.122.2">On the other hand, Rx has a </span><code class="literal"><span class="koboSpan" id="kobo.123.1">Schedulers.from</span></code><span class="koboSpan" id="kobo.124.1"> built-in method that converts an </span><code class="literal"><span class="koboSpan" id="kobo.125.1">Executor</span></code><span class="koboSpan" id="kobo.126.1"> object into a </span><code class="literal"><span class="koboSpan" id="kobo.127.1">Scheduler</span></code><span class="koboSpan" id="kobo.128.1"> object. </span><span class="koboSpan" id="kobo.128.2">To bridge the gap between Swing's </span><code class="literal"><span class="koboSpan" id="kobo.129.1">invokeLater</span></code><span class="koboSpan" id="kobo.130.1"> method and Rx schedulers, we implement a custom </span><code class="literal"><span class="koboSpan" id="kobo.131.1">Executor</span></code><span class="koboSpan" id="kobo.132.1"> object that wraps a call to </span><code class="literal"><span class="koboSpan" id="kobo.133.1">invokeLater</span></code><span class="koboSpan" id="kobo.134.1">, and we pass this </span><code class="literal"><span class="koboSpan" id="kobo.135.1">Executor</span></code><span class="koboSpan" id="kobo.136.1"> object to </span><code class="literal"><span class="koboSpan" id="kobo.137.1">Schedulers.from</span></code><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">The custom </span><code class="literal"><span class="koboSpan" id="kobo.139.1">swingScheduler</span></code><span class="koboSpan" id="kobo.140.1"> object is implemented as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.141.1">import java.util.concurrent.Executor 
import rx.schedulers.Schedulers.{from =&gt; fromExecutor} 
import javax.swing.SwingUtilities.invokeLater 
val swingScheduler = new Scheduler { 
  val asJavaScheduler = fromExecutor(new Executor { 
    def execute(r: Runnable) = invokeLater(r) 
  }) 
} 
</span></pre><p><span class="koboSpan" id="kobo.142.1">We can use the newly-defined </span><code class="literal"><span class="koboSpan" id="kobo.143.1">swingScheduler</span></code><span class="koboSpan" id="kobo.144.1"> object in order to send events back to Swing. </span><span class="koboSpan" id="kobo.144.2">To illustrate this, let's implement a small web browser application. </span><span class="koboSpan" id="kobo.144.3">Our browser consists of a </span><code class="literal"><span class="koboSpan" id="kobo.145.1">urlfield</span></code><span class="koboSpan" id="kobo.146.1"> address bar and the </span><span class="strong"><strong><span class="koboSpan" id="kobo.147.1">Feeling lucky</span></strong></span><span class="koboSpan" id="kobo.148.1"> button. </span><span class="koboSpan" id="kobo.148.2">Typing into the address bar displays suggestions for the URL, and clicking on the button displays the raw HTML of the webpage. </span><span class="koboSpan" id="kobo.148.3">The browser is not a trivial application, so we separate the implementation of the UI layout from the UI logic. </span><span class="koboSpan" id="kobo.148.4">We start by defining the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">BrowserFrame</span></code><span class="koboSpan" id="kobo.150.1"> class, which describes the layout of the UI elements:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.151.1">abstract class BrowserFrame extends MainFrame { 
  title = "MiniBrowser" 
  val specUrl = "http://www.w3.org/Addressing/URL/url-spec.txt" 
  val urlfield = new TextField(specUrl) 
  val pagefield = new TextArea 
  val button = new Button { 
    text = "Feeling Lucky" 
  } 
  contents = new BorderPanel { 
    import BorderPanel.Position._ 
    layout(new BorderPanel { 
      layout(new Label("URL:")) = West 
      layout(urlfield) = Center 
      layout(button) = East 
    }) = North 
    layout(pagefield) = Center 
  } 
  size = new Dimension(1024, 768) 
} 
</span></pre><p><span class="koboSpan" id="kobo.152.1">Scala Swing was implemented long before the introduction of Rx, so it does not come with event streams. </span><span class="koboSpan" id="kobo.152.2">We use Scala's extension method pattern in order to enrich the existing UI element classes with </span><code class="literal"><span class="koboSpan" id="kobo.153.1">Observable</span></code><span class="koboSpan" id="kobo.154.1"> objects, and add implicit classes, </span><code class="literal"><span class="koboSpan" id="kobo.155.1">ButtonOps</span></code><span class="koboSpan" id="kobo.156.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.157.1">TextFieldOps</span></code><span class="koboSpan" id="kobo.158.1">, with methods, </span><code class="literal"><span class="koboSpan" id="kobo.159.1">clicks</span></code><span class="koboSpan" id="kobo.160.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.161.1">texts</span></code><span class="koboSpan" id="kobo.162.1">, respectively. </span><span class="koboSpan" id="kobo.162.2">The </span><code class="literal"><span class="koboSpan" id="kobo.163.1">clicks</span></code><span class="koboSpan" id="kobo.164.1"> method returns an </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Observable</span></code><span class="koboSpan" id="kobo.166.1"> object that emits an event each time the corresponding button is clicked on. </span><span class="koboSpan" id="kobo.166.2">Similarly, the </span><code class="literal"><span class="koboSpan" id="kobo.167.1">texts</span></code><span class="koboSpan" id="kobo.168.1"> method emits an event each time the content of a text field changes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.169.1">implicit class ButtonOps(val self: Button) { 
  def clicks = Observable.create[Unit] { obs =&gt; 
    self.reactions += { 
      case ButtonClicked(_) =&gt; obs.onNext(()) 
    } 
    Subscription() 
  } 
} 
implicit class TextFieldOps(val self: TextField) { 
  def texts = Observable.create[String] { obs =&gt; 
    self.reactions += { 
      case ValueChanged(_) =&gt; obs.onNext(self.text) 
    } 
    Subscription() 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.170.1">We now have the necessary utilities to concisely define the logic of our web browser. </span><span class="koboSpan" id="kobo.170.2">We implement the browser logic in a trait called </span><code class="literal"><span class="koboSpan" id="kobo.171.1">BrowserLogic</span></code><span class="koboSpan" id="kobo.172.1">, annotated with a self-type </span><code class="literal"><span class="koboSpan" id="kobo.173.1">BrowserFrame</span></code><span class="koboSpan" id="kobo.174.1"> object. </span><span class="koboSpan" id="kobo.174.2">The type </span><code class="literal"><span class="koboSpan" id="kobo.175.1">self</span></code><span class="koboSpan" id="kobo.176.1"> allows you to mix the </span><code class="literal"><span class="koboSpan" id="kobo.177.1">BrowserLogic</span></code><span class="koboSpan" id="kobo.178.1"> trait only into classes that extend the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">BrowserFrame</span></code><span class="koboSpan" id="kobo.180.1"> object. </span><span class="koboSpan" id="kobo.180.2">This makes sense; the browser logic needs to know about UI events to react to them.</span></p><p><span class="koboSpan" id="kobo.181.1">There are two main functionalities supported by the web browser. </span><span class="koboSpan" id="kobo.181.2">First, the browser needs to suggest possible URLs while the user types into the address bar. </span><span class="koboSpan" id="kobo.181.3">To facilitate this, we define a helper method, </span><code class="literal"><span class="koboSpan" id="kobo.182.1">suggestRequest</span></code><span class="koboSpan" id="kobo.183.1">, which takes a term from the address bar and returns an </span><code class="literal"><span class="koboSpan" id="kobo.184.1">Observable</span></code><span class="koboSpan" id="kobo.185.1"> object with the possible completions. </span><span class="koboSpan" id="kobo.185.2">This </span><code class="literal"><span class="koboSpan" id="kobo.186.1">Observable</span></code><span class="koboSpan" id="kobo.187.1"> object uses Google's query suggestion service to get a list of possible URLs. </span><span class="koboSpan" id="kobo.187.2">To cope with network errors, the </span><code class="literal"><span class="koboSpan" id="kobo.188.1">Observable</span></code><span class="koboSpan" id="kobo.189.1"> object will time-out after 0.5 seconds if there is no reply from the server, and emit an error message.</span></p><p><span class="koboSpan" id="kobo.190.1">Second, our browser needs to display the contents of the specified URL, when we click on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.191.1">Feeling lucky</span></strong></span><span class="koboSpan" id="kobo.192.1"> button. </span><span class="koboSpan" id="kobo.192.2">To achieve this, we define another helper method named </span><code class="literal"><span class="koboSpan" id="kobo.193.1">pageRequest</span></code><span class="koboSpan" id="kobo.194.1">, which returns an </span><code class="literal"><span class="koboSpan" id="kobo.195.1">Observable</span></code><span class="koboSpan" id="kobo.196.1"> object with the raw HTML of the web page. </span><span class="koboSpan" id="kobo.196.2">This </span><code class="literal"><span class="koboSpan" id="kobo.197.1">Observable</span></code><span class="koboSpan" id="kobo.198.1"> object times-out after four seconds if the page is not loaded by that time.</span></p><p><span class="koboSpan" id="kobo.199.1">Using these helper methods and the UI element </span><code class="literal"><span class="koboSpan" id="kobo.200.1">Observable</span></code><span class="koboSpan" id="kobo.201.1"> objects, we can encode the browser logic more easily. </span><span class="koboSpan" id="kobo.201.2">Each </span><code class="literal"><span class="koboSpan" id="kobo.202.1">urlField</span></code><span class="koboSpan" id="kobo.203.1"> text modification event maps into a nested </span><code class="literal"><span class="koboSpan" id="kobo.204.1">Observable</span></code><span class="koboSpan" id="kobo.205.1"> object with the suggestion. </span><span class="koboSpan" id="kobo.205.2">The call to </span><code class="literal"><span class="koboSpan" id="kobo.206.1">concat</span></code><span class="koboSpan" id="kobo.207.1"> then flattens the nested </span><code class="literal"><span class="koboSpan" id="kobo.208.1">Observable</span></code><span class="koboSpan" id="kobo.209.1"> object. </span><span class="koboSpan" id="kobo.209.2">The suggestion events transfer back to the Swing event-dispatching thread using the </span><code class="literal"><span class="koboSpan" id="kobo.210.1">observeOn</span></code><span class="koboSpan" id="kobo.211.1"> combinator. </span><span class="koboSpan" id="kobo.211.2">We subscribe to the events on the Swing event-dispatching thread in order to modify the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.212.1">pagefield</span></code><span class="koboSpan" id="kobo.213.1"> text area. </span><span class="koboSpan" id="kobo.213.2">We subscribe to </span><code class="literal"><span class="koboSpan" id="kobo.214.1">button.clicks</span></code><span class="koboSpan" id="kobo.215.1"> in a similar way:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.216.1">trait BrowserLogic { 
  self: BrowserFrame =&gt; 
  def suggestRequest(term: String): Observable[String] = { 
    val url = "http://suggestqueries.google.com/" + 
      s"complete/search?client=firefox&amp;q=$term" 
    val request = Future { Source.fromURL(url).mkString } 
    Observable.from(request) 
              .timeout(0.5.seconds) 
              .onErrorReturn(e =&gt; "(no suggestion)") 
  } 
  def pageRequest(url: String): Observable[String] = { 
    val request = Future { Source.fromURL(url).mkString } 
    Observable.from(request) 
              .timeout(4.seconds) 
              .onErrorReturn(e =&gt; s"Could not load page: $e") 
  } 
  urlfield.texts.map(suggestRequest).concat 
                .observeOn(swingScheduler) 
                .subscribe(response =&gt; pagefield.text = response) 
  button.clicks.map(_ =&gt; pageRequest(urlfield.text)).concat 
               .observeOn(swingScheduler) 
               .subscribe(response =&gt; pagefield.text = response) 
} 
</span></pre><p><span class="koboSpan" id="kobo.217.1">After defining both the UI layout and the UI logic, we only need to instantiate the browser frame in a Swing application:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.218.1">object SchedulersBrowser extends SimpleSwingApplication { 
  def top = new BrowserFrame with BrowserLogic 
} 
</span></pre><p><span class="koboSpan" id="kobo.219.1">Running the application opens the browser frame, and we can start surfing in our very own Rx-based web browser. </span><span class="koboSpan" id="kobo.219.2">The guys at Mozilla and Google will surely be impressed when they see the following screenshot:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.220.1"><img src="graphics/image_06_008.jpg" alt="Using custom schedulers for UI applications"/></span></div><p><span class="koboSpan" id="kobo.221.1">Although our web browser is very simple, we managed to separate its functionality into the UI layout and browser logic layers. </span><span class="koboSpan" id="kobo.221.2">The UI layout layer defines </span><code class="literal"><span class="koboSpan" id="kobo.222.1">Observable</span></code><span class="koboSpan" id="kobo.223.1"> objects such as </span><code class="literal"><span class="koboSpan" id="kobo.224.1">urlfield.texts</span></code><span class="koboSpan" id="kobo.225.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.226.1">button.clicks</span></code><span class="koboSpan" id="kobo.227.1"> as part of its interface. </span><span class="koboSpan" id="kobo.227.2">The browser logic layer relies on the functionality from the UI layout layer; for example, we could not describe the updates to the </span><code class="literal"><span class="koboSpan" id="kobo.228.1">pagefield</span></code><span class="koboSpan" id="kobo.229.1"> UI element without referencing the </span><code class="literal"><span class="koboSpan" id="kobo.230.1">Observable</span></code><span class="koboSpan" id="kobo.231.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.232.1">button.clicks</span></code><span class="koboSpan" id="kobo.233.1">.</span></p><p><span class="koboSpan" id="kobo.234.1">We say that the browser logic depends on the UI layout, but not vice versa. </span><span class="koboSpan" id="kobo.234.2">For a UI application, this can be acceptable, but other applications require a more loosely coupled design, in which different layers do not refer to each other directly.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Subjects and top-down reactive programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/><span class="koboSpan" id="kobo.1.1">Subjects and top-down reactive programming</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Composing </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Observable</span></code><span class="koboSpan" id="kobo.4.1"> objects is similar to composing functions, collections, or futures. </span><span class="koboSpan" id="kobo.4.2">Complex </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Observable</span></code><span class="koboSpan" id="kobo.6.1"> objects are formed from simpler parts using functional composition. </span><span class="koboSpan" id="kobo.6.2">This is a very Scala-idiomatic pattern, and it results in concise and understandable programs.</span></p><p><span class="koboSpan" id="kobo.7.1">A not-so-obvious downside of functional composition is that it favors the </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">bottom-up programming style</span></strong></span><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">An </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Observable</span></code><span class="koboSpan" id="kobo.11.1"> object cannot be created without a reference to another </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Observable</span></code><span class="koboSpan" id="kobo.13.1"> object that it depends on. </span><span class="koboSpan" id="kobo.13.2">For instance, we cannot create an </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Observable</span></code><span class="koboSpan" id="kobo.15.1"> object using the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">map</span></code><span class="koboSpan" id="kobo.17.1"> combinator without having an input </span><code class="literal"><span class="koboSpan" id="kobo.18.1">Observable</span></code><span class="koboSpan" id="kobo.19.1"> object to call the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">map</span></code><span class="koboSpan" id="kobo.21.1"> method on. </span><span class="koboSpan" id="kobo.21.2">In a bottom-up programming style, we build complex programs by implementing the simplest parts first, and then gradually working our way up. </span><span class="koboSpan" id="kobo.21.3">By contrast, in a </span><span class="strong"><strong><span class="koboSpan" id="kobo.22.1">top-down programming style</span></strong></span><span class="koboSpan" id="kobo.23.1">, we first define the complex parts of the system, and then gradually divide them into successively smaller pieces. </span><span class="koboSpan" id="kobo.23.2">The top-down programming style allows first declaring an </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Observable</span></code><span class="koboSpan" id="kobo.25.1"> object, and defining its dependencies later.</span></p><p><span class="koboSpan" id="kobo.26.1">To allow building systems in a top-down programming style, Rx defines an abstraction called a subject, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Subject</span></code><span class="koboSpan" id="kobo.28.1"> trait. </span><span class="koboSpan" id="kobo.28.2">A </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Subject</span></code><span class="koboSpan" id="kobo.30.1"> trait is simultaneously an </span><code class="literal"><span class="koboSpan" id="kobo.31.1">Observable</span></code><span class="koboSpan" id="kobo.32.1"> object and an </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Observer</span></code><span class="koboSpan" id="kobo.34.1"> object. </span><span class="koboSpan" id="kobo.34.2">As an </span><code class="literal"><span class="koboSpan" id="kobo.35.1">Observable</span></code><span class="koboSpan" id="kobo.36.1"> object, a </span><code class="literal"><span class="koboSpan" id="kobo.37.1">Subject</span></code><span class="koboSpan" id="kobo.38.1"> trait can emit events to its subscribers. </span><span class="koboSpan" id="kobo.38.2">As an </span><code class="literal"><span class="koboSpan" id="kobo.39.1">Observer</span></code><span class="koboSpan" id="kobo.40.1"> object, a </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Subject</span></code><span class="koboSpan" id="kobo.42.1"> trait can subscribe to different input </span><code class="literal"><span class="koboSpan" id="kobo.43.1">Observable</span></code><span class="koboSpan" id="kobo.44.1"> objects and forward their events to its own subscribers.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note70"/><span class="koboSpan" id="kobo.45.1">Note</span></h3><p><span class="koboSpan" id="kobo.46.1">A </span><code class="literal"><span class="koboSpan" id="kobo.47.1">Subject</span></code><span class="koboSpan" id="kobo.48.1"> trait is an </span><code class="literal"><span class="koboSpan" id="kobo.49.1">Observable</span></code><span class="koboSpan" id="kobo.50.1"> object whose inputs can change after its creation.</span></p></div></div><p><span class="koboSpan" id="kobo.51.1">To see how to use a Subject trait in practice, let's assume that we are building our own operating system. </span><span class="koboSpan" id="kobo.51.2">Having witnessed how practical the Rx event streams are, we decide to use them throughout our operating system, which we name </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">RxOS</span></strong></span><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">To make RxOS pluggable, its functionality is divided into separate components called kernel modules. </span><span class="koboSpan" id="kobo.53.3">Each kernel module might define a certain number of </span><code class="literal"><span class="koboSpan" id="kobo.54.1">Observable</span></code><span class="koboSpan" id="kobo.55.1"> objects. </span><span class="koboSpan" id="kobo.55.2">For example, a </span><code class="literal"><span class="koboSpan" id="kobo.56.1">TimeModule</span></code><span class="koboSpan" id="kobo.57.1"> module exposes an </span><code class="literal"><span class="koboSpan" id="kobo.58.1">Observable</span></code><span class="koboSpan" id="kobo.59.1"> object named </span><code class="literal"><span class="koboSpan" id="kobo.60.1">systemClock</span></code><span class="koboSpan" id="kobo.61.1">, which outputs a string with the system uptime every second:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.62.1">object TimeModule { 
  import Observable._ 
  val systemClock = interval(1.seconds).map(t =&gt; s"systime: $t") 
} 
</span></pre><p><span class="koboSpan" id="kobo.63.1">System output is an essential part of every operating system. </span><span class="koboSpan" id="kobo.63.2">We want RxOS to output important system events such as the system uptime. </span><span class="koboSpan" id="kobo.63.3">We already know how to do this by calling </span><code class="literal"><span class="koboSpan" id="kobo.64.1">subscribe</span></code><span class="koboSpan" id="kobo.65.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">systemClock</span></code><span class="koboSpan" id="kobo.67.1"> object from the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">TimeModule</span></code><span class="koboSpan" id="kobo.69.1"> module, as shown in the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.70.1">object RxOS { 
  val messageBus = TimeModule.systemClock.subscribe(log _) 
} 
</span></pre><p><span class="koboSpan" id="kobo.71.1">Let's say that another team now independently develops another kernel module named </span><code class="literal"><span class="koboSpan" id="kobo.72.1">FileSystemModule</span></code><span class="koboSpan" id="kobo.73.1">, which exposes an </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Observable</span></code><span class="koboSpan" id="kobo.75.1"> object called </span><code class="literal"><span class="koboSpan" id="kobo.76.1">fileModifications</span></code><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">This </span><code class="literal"><span class="koboSpan" id="kobo.78.1">Observable</span></code><span class="koboSpan" id="kobo.79.1"> object emits a filename each time a file is modified:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.80.1">object FileSystemModule { 
  val fileModifications = modified(".") 
} 
</span></pre><p><span class="koboSpan" id="kobo.81.1">Our core development team now decides that the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">fileModifications</span></code><span class="koboSpan" id="kobo.83.1"> objects are important system events and wants to log these events as part of the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">messageBus</span></code><span class="koboSpan" id="kobo.85.1"> subscription. </span><span class="koboSpan" id="kobo.85.2">We now need to redefine the singleton object </span><code class="literal"><span class="koboSpan" id="kobo.86.1">RxOS</span></code><span class="koboSpan" id="kobo.87.1">, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.88.1">object RxOS { 
  val messageBus = Observable.items( 
    TimeModule.systemClock, 
    FileSystemModule.fileModifications 
  ).flatten.subscribe(log _) 
} 
</span></pre><p><span class="koboSpan" id="kobo.89.1">This patch solves the situation, but what if another kernel module introduces another group of important system events? </span><span class="koboSpan" id="kobo.89.2">With our current approach, we will have to recompile the RxOS kernel each time some third-party developer implements a kernel module. </span><span class="koboSpan" id="kobo.89.3">Even worse, the </span><code class="literal"><span class="koboSpan" id="kobo.90.1">RxOS</span></code><span class="koboSpan" id="kobo.91.1"> object definition references kernel modules, and thus, depends on them. </span><span class="koboSpan" id="kobo.91.2">Developers who want to build custom, reduced versions of RxOS now need to tweak the kernel source code.</span></p><p><span class="koboSpan" id="kobo.92.1">This is the classic culprit of the bottom-up programming style; we are unable to declare the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">messageBus</span></code><span class="koboSpan" id="kobo.94.1"> object without declaring its dependencies, and declaring them binds us to specific kernel modules.</span></p><p><span class="koboSpan" id="kobo.95.1">We now redefine the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">messageBus</span></code><span class="koboSpan" id="kobo.97.1"> object as an Rx subject. </span><span class="koboSpan" id="kobo.97.2">We create a new </span><code class="literal"><span class="koboSpan" id="kobo.98.1">Subject</span></code><span class="koboSpan" id="kobo.99.1"> instance that emits strings, and we then subscribe to it, as shown in the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.100.1">object RxOS { 
  val messageBus = Subject[String]() 
  messageBus.subscribe(log _) 
} 
</span></pre><p><span class="koboSpan" id="kobo.101.1">At this point, the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">messageBus</span></code><span class="koboSpan" id="kobo.103.1"> object is not subscribed to any </span><code class="literal"><span class="koboSpan" id="kobo.104.1">Observable</span></code><span class="koboSpan" id="kobo.105.1"> objects and does not emit any events. </span><span class="koboSpan" id="kobo.105.2">We can now define the RxOS boot sequence separately from the modules and the kernel code. </span><span class="koboSpan" id="kobo.105.3">The boot sequence specifies which kernel modules to subscribe with the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">messageBus</span></code><span class="koboSpan" id="kobo.107.1"> object, and stores their subscriptions into the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">loadedModules</span></code><span class="koboSpan" id="kobo.109.1"> list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.110.1">object SubjectsOS extends App { 
  log(s"RxOS boot sequence starting...") 
  val loadedModules = List( 
    TimeModule.systemClock, 
    FileSystemModule.fileModifications 
  ).map(_.subscribe(RxOS.messageBus)) 
  log(s"RxOS boot sequence finished!") 
  Thread.sleep(10000) 
  for (mod &lt;- loadedModules) mod.unsubscribe() 
  log(s"RxOS going for shutdown") 
} 
</span></pre><p><span class="koboSpan" id="kobo.111.1">The boot sequence first subscribes the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">messageBus</span></code><span class="koboSpan" id="kobo.113.1"> object to each of the required modules. </span><span class="koboSpan" id="kobo.113.2">We can do this because the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">messageBus</span></code><span class="koboSpan" id="kobo.115.1"> object is an </span><code class="literal"><span class="koboSpan" id="kobo.116.1">Observer</span></code><span class="koboSpan" id="kobo.117.1"> object, in addition to being an </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Observable</span></code><span class="koboSpan" id="kobo.119.1"> object. </span><span class="koboSpan" id="kobo.119.2">The </span><code class="literal"><span class="koboSpan" id="kobo.120.1">RxOS</span></code><span class="koboSpan" id="kobo.121.1"> then stays up for 10 seconds before calling </span><code class="literal"><span class="koboSpan" id="kobo.122.1">unsubscribe</span></code><span class="koboSpan" id="kobo.123.1"> on the modules and shutting down. </span><span class="koboSpan" id="kobo.123.2">During this time, the system clock emits an event to the </span><code class="literal"><span class="koboSpan" id="kobo.124.1">messageBus</span></code><span class="koboSpan" id="kobo.125.1"> object every second. </span><span class="koboSpan" id="kobo.125.2">Similarly, the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">messageBus</span></code><span class="koboSpan" id="kobo.127.1"> object outputs the name of the modified file every time a file modification occurs, as shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.128.1"><img src="graphics/image_06_009.jpg" alt="Subjects and top-down reactive programming"/></span></div><p><span class="koboSpan" id="kobo.129.1">The difference between the two approaches is shown in the preceding figure. </span><span class="koboSpan" id="kobo.129.2">In the bottom-up approach, we first need to define all the kernel modules and then make RxOS depend on them. </span><span class="koboSpan" id="kobo.129.3">In the top-down approach, RxOS does not depend on the kernel modules. </span><span class="koboSpan" id="kobo.129.4">Instead, it is glued together with them by the boot sequence module. </span><span class="koboSpan" id="kobo.129.5">The RxOS clients no longer need to tweak or recompile the kernel code if they want to add a new kernel module. </span><span class="koboSpan" id="kobo.129.6">In fact, the new design even allows hot-plugging kernel modules into a running RxOS instance, long after the boot sequence is completed.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip71"/><span class="koboSpan" id="kobo.130.1">Tip</span></h3><p><span class="koboSpan" id="kobo.131.1">Use </span><code class="literal"><span class="koboSpan" id="kobo.132.1">Subject</span></code><span class="koboSpan" id="kobo.133.1"> instances when you need to create an </span><code class="literal"><span class="koboSpan" id="kobo.134.1">Observable</span></code><span class="koboSpan" id="kobo.135.1"> object whose inputs are not available when the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">Observable</span></code><span class="koboSpan" id="kobo.137.1"> object is created.</span></p></div></div><p><span class="koboSpan" id="kobo.138.1">In our example, designing a web browser is a lot like ordering a MacBook. </span><span class="koboSpan" id="kobo.138.2">After specifying the preferred processor type and the hard disk size, the MacBook is assembled, and its components cannot be exchanged easily. </span><span class="koboSpan" id="kobo.138.3">Analogously, after implementing the browser's UI layout, the event streams that describe the interaction between UI components are declared only once, and cannot change if the UI components are replaced. </span><span class="koboSpan" id="kobo.138.4">On the other hand, building an OS is more like building a desktop computer from custom components. </span><span class="koboSpan" id="kobo.138.5">After putting the motherboard into the case, we can plug in components such as the graphics card or the RAID controller independently. </span><span class="koboSpan" id="kobo.138.6">Similarly, after declaring the </span><code class="literal"><span class="koboSpan" id="kobo.139.1">messageBus</span></code><span class="koboSpan" id="kobo.140.1"> subject, we can plug in any number of kernel modules at any time during the execution of the program.</span></p><p><span class="koboSpan" id="kobo.141.1">Although the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">Subject</span></code><span class="koboSpan" id="kobo.143.1"> interface is more flexible than the </span><code class="literal"><span class="koboSpan" id="kobo.144.1">Observable</span></code><span class="koboSpan" id="kobo.145.1"> interface, you should not always use the </span><code class="literal"><span class="koboSpan" id="kobo.146.1">Subject</span></code><span class="koboSpan" id="kobo.147.1"> instances and rely exclusively on the top-down programming style. </span><span class="koboSpan" id="kobo.147.2">While declaring the dependencies of an </span><code class="literal"><span class="koboSpan" id="kobo.148.1">Observable</span></code><span class="koboSpan" id="kobo.149.1"> object at its creation point makes the application less flexible, it also makes it more declarative and easier to understand. </span><span class="koboSpan" id="kobo.149.2">Modern large-scale applications usually combine both bottom-up and top-down approaches.</span></p><p><span class="koboSpan" id="kobo.150.1">Rx defines several other types of subject. </span><span class="koboSpan" id="kobo.150.2">The type </span><code class="literal"><span class="koboSpan" id="kobo.151.1">ReplaySubject</span></code><span class="koboSpan" id="kobo.152.1"> is a </span><code class="literal"><span class="koboSpan" id="kobo.153.1">Subject</span></code><span class="koboSpan" id="kobo.154.1"> implementation that buffers the events it receives as an </span><code class="literal"><span class="koboSpan" id="kobo.155.1">Observer</span></code><span class="koboSpan" id="kobo.156.1"> object. </span><span class="koboSpan" id="kobo.156.2">When another </span><code class="literal"><span class="koboSpan" id="kobo.157.1">Observer</span></code><span class="koboSpan" id="kobo.158.1"> object subscribes to a </span><code class="literal"><span class="koboSpan" id="kobo.159.1">ReplaySubject</span></code><span class="koboSpan" id="kobo.160.1"> instance, all the events previously buffered by the </span><code class="literal"><span class="koboSpan" id="kobo.161.1">ReplaySubject</span></code><span class="koboSpan" id="kobo.162.1"> instance are replayed. </span><span class="koboSpan" id="kobo.162.2">In the following code snippet, we define a </span><code class="literal"><span class="koboSpan" id="kobo.163.1">ReplaySubject</span></code><span class="koboSpan" id="kobo.164.1"> instance called </span><code class="literal"><span class="koboSpan" id="kobo.165.1">messageLog</span></code><span class="koboSpan" id="kobo.166.1"> in </span><code class="literal"><span class="koboSpan" id="kobo.167.1">RxOS</span></code><span class="koboSpan" id="kobo.168.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.169.1">object RxOS { 
  val messageBus = Subject[String]() 
  val messageLog = subjects.ReplaySubject[String]() 
  messageBus.subscribe(log _) 
  messageBus.subscribe(messageLog) 
} 
</span></pre><p><span class="koboSpan" id="kobo.170.1">The </span><code class="literal"><span class="koboSpan" id="kobo.171.1">messageLog</span></code><span class="koboSpan" id="kobo.172.1"> object subscribes to the </span><code class="literal"><span class="koboSpan" id="kobo.173.1">messageBus</span></code><span class="koboSpan" id="kobo.174.1"> object in order to buffer all the system messages. </span><span class="koboSpan" id="kobo.174.2">If, for example, we now want to dump all the messages into a log file, we can subscribe to the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">messageLog</span></code><span class="koboSpan" id="kobo.176.1"> object immediately before the application ends, as shown in the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.177.1">log(s"RxOS dumping the complete system event log") 
RxOS.messageLog.subscribe(logToFile) 
log(s"RxOS going for shutdown") 
</span></pre><p><span class="koboSpan" id="kobo.178.1">Rx also defines two other subjects called </span><code class="literal"><span class="koboSpan" id="kobo.179.1">BehaviorSubject</span></code><span class="koboSpan" id="kobo.180.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.181.1">AsyncSubject</span></code><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">The </span><code class="literal"><span class="koboSpan" id="kobo.183.1">BehaviorSubject</span></code><span class="koboSpan" id="kobo.184.1"> class buffers only the most recent event, and the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">AsyncSubject</span></code><span class="koboSpan" id="kobo.186.1"> class only emits the event immediately preceding </span><code class="literal"><span class="koboSpan" id="kobo.187.1">onComplete</span></code><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">We will not study their exact semantics and use case here, but we refer you to the online documentation to find out more about them.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">First-class event streams are an extremely expressive tool for modelling dynamic, event-based systems with time-varying values. </span><span class="koboSpan" id="kobo.2.2">Rx </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Observable</span></code><span class="koboSpan" id="kobo.4.1"> objects are an event stream implementation designed to build scalable, concurrent, event-based applications. </span><span class="koboSpan" id="kobo.4.2">In this chapter, we saw how to create Rx </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Observable</span></code><span class="koboSpan" id="kobo.6.1"> objects and how to subscribe to their events. </span><span class="koboSpan" id="kobo.6.2">We studied the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Observable</span></code><span class="koboSpan" id="kobo.8.1"> contract and learned how to compose complex </span><code class="literal"><span class="koboSpan" id="kobo.9.1">Observable</span></code><span class="koboSpan" id="kobo.10.1"> objects from simple ones. </span><span class="koboSpan" id="kobo.10.2">We investigated various ways of recovering from failures and saw how to use Rx schedulers to transfer events between threads. </span><span class="koboSpan" id="kobo.10.3">Finally, we learned how to design loosely coupled systems with Rx subjects. </span><span class="koboSpan" id="kobo.10.4">These powerful tools together allow us to build a plethora of different applications, ranging from web browsers, FTP servers, the music and video players to real-time games and trading platforms, and even operating systems.</span></p><p><span class="koboSpan" id="kobo.11.1">Due to the increasing popularity of reactive programming, a number of frameworks similar to Rx have appeared in the recent years: REScala, Akka Streams, and Reactive Collections, to name a few. </span><span class="koboSpan" id="kobo.11.2">We did not study the semantics of these frameworks in this chapter, but leave it to the readers to explore them on their own.</span></p><p><span class="koboSpan" id="kobo.12.1">We have seen that </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Observable</span></code><span class="koboSpan" id="kobo.14.1"> objects are very declarative in nature, making the Rx programming model easy to use and understand. </span><span class="koboSpan" id="kobo.14.2">Nevertheless, it is sometimes useful to model a system imperatively, using explicit state. </span><span class="koboSpan" id="kobo.14.3">In the next chapter, we will study software transactional memory, which allows accessing shared program state without the risk of deadlocks and race conditions, which we learned about in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.15.1">Chapter 2</span></a><span class="koboSpan" id="kobo.16.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.18.1">.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the following exercises, you will need to implement different </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Observable</span></code><span class="koboSpan" id="kobo.4.1"> objects. </span><span class="koboSpan" id="kobo.4.2">The exercises show different use cases for </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Observable</span></code><span class="koboSpan" id="kobo.6.1"> objects, and contrast the different ways of creating </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Observable</span></code><span class="koboSpan" id="kobo.8.1"> objects. </span><span class="koboSpan" id="kobo.8.2">Also, some of the exercises introduce new reactive programming abstractions, such as reactive maps and reactive priority queues.</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.9.1">Implement a custom </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Observable[Thread]</span></code><span class="koboSpan" id="kobo.11.1"> object that emits an event when it detects that a thread was started. </span><span class="koboSpan" id="kobo.11.2">The implementation is allowed to miss some of the events.</span></li><li class="listitem"><span class="koboSpan" id="kobo.12.1">Implement an </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Observable</span></code><span class="koboSpan" id="kobo.14.1"> object that emits an event every 5 seconds and every 12 seconds, but not if the elapsed time is a multiple of 30 seconds. </span><span class="koboSpan" id="kobo.14.2">Use functional combinators on </span><code class="literal"><span class="koboSpan" id="kobo.15.1">Observable</span></code><span class="koboSpan" id="kobo.16.1"> objects.</span></li><li class="listitem"><span class="koboSpan" id="kobo.17.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">randomQuote</span></code><span class="koboSpan" id="kobo.19.1"> method from this section in order to create an </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Observable</span></code><span class="koboSpan" id="kobo.21.1"> object with the moving average of the quote lengths. </span><span class="koboSpan" id="kobo.21.2">Each time a new quote arrives, a new average value should be emitted.</span></li><li class="listitem"><span class="koboSpan" id="kobo.22.1">Implement the reactive signal abstraction, represented with the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">Signal[T]</span></code><span class="koboSpan" id="kobo.24.1"> type. </span><span class="koboSpan" id="kobo.24.2">The type </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Signal[T]</span></code><span class="koboSpan" id="kobo.26.1"> comes with the method </span><code class="literal"><span class="koboSpan" id="kobo.27.1">apply</span></code><span class="koboSpan" id="kobo.28.1">, used to query the last event emitted by this signal, and several combinators with the same semantics as the corresponding </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Observable</span></code><span class="koboSpan" id="kobo.30.1"> methods:</span><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">            class Signal[T] { 
              def apply(): T = ??? 
              </span><span class="koboSpan" id="kobo.31.2">def map(f: T =&gt; S): Signal[S] = ??? 
              </span><span class="koboSpan" id="kobo.31.3">def zip[S](that: Signal[S]): Signal[(T, S)] = ??? 
              </span><span class="koboSpan" id="kobo.31.4">def scan[S](z: S)(f: (S, T) =&gt; S) = ??? 
            </span><span class="koboSpan" id="kobo.31.5">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.32.1">Then, add the method </span><code class="literal"><span class="koboSpan" id="kobo.33.1">toSignal</span></code><span class="koboSpan" id="kobo.34.1"> to the type </span><code class="literal"><span class="koboSpan" id="kobo.35.1">Observable[T]</span></code><span class="koboSpan" id="kobo.36.1">, which converts an </span><code class="literal"><span class="koboSpan" id="kobo.37.1">Observable</span></code><span class="koboSpan" id="kobo.38.1"> object to a reactive signal:</span></p><p>
</p><pre class="programlisting"><span class="koboSpan" id="kobo.39.1">            def toSignal: Signal[T] = ??? 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.40.1">Consider using Rx subjects for this task.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.41.1">Implement the reactive cell abstraction, represented with the type </span><code class="literal"><span class="koboSpan" id="kobo.42.1">RCell[T]</span></code><span class="koboSpan" id="kobo.43.1">:</span><pre class="programlisting"><span class="koboSpan" id="kobo.44.1">            class RCell[T] extends Signal[T] { 
              def :=(x: T): Unit = ???  
            </span><span class="koboSpan" id="kobo.44.2">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.45.1">A reactive cell is simultaneously a reactive signal from the previous exercise. </span><span class="koboSpan" id="kobo.45.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">:=</span></code><span class="koboSpan" id="kobo.47.1"> method sets a new value to the reactive cell, and emits an event.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.48.1">Implement the reactive map collection, represented with the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">RMap</span></code><span class="koboSpan" id="kobo.50.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">            class RMap[K, V] { 
              def update(k: K, v: V): Unit 
              def apply(k: K): Observable[V] 
            }  
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.52.1">The </span><code class="literal"><span class="koboSpan" id="kobo.53.1">update</span></code><span class="koboSpan" id="kobo.54.1"> method behaves like the update on a regular </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Map</span></code><span class="koboSpan" id="kobo.56.1"> collection. </span><span class="koboSpan" id="kobo.56.2">Calling </span><code class="literal"><span class="koboSpan" id="kobo.57.1">apply</span></code><span class="koboSpan" id="kobo.58.1"> on a reactive map returns an </span><code class="literal"><span class="koboSpan" id="kobo.59.1">Observable</span></code><span class="koboSpan" id="kobo.60.1"> object with all the subsequent updates of the specific key.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.61.1">Implement the reactive priority queue, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.62.1">RPriorityQueue</span></code><span class="koboSpan" id="kobo.63.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.64.1">            class RPriorityQueue[T] { 
              def add(x: T): Unit = ??? 
              </span><span class="koboSpan" id="kobo.64.2">def pop(): T = ??? 
              </span><span class="koboSpan" id="kobo.64.3">def popped: Observable[T] = ??? 
            </span><span class="koboSpan" id="kobo.64.4">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.65.1">The reactive priority queue exposes the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">Observable</span></code><span class="koboSpan" id="kobo.67.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.68.1">popped</span></code><span class="koboSpan" id="kobo.69.1">, which emits events whenever the smallest element in the priority queue gets removed by calling </span><code class="literal"><span class="koboSpan" id="kobo.70.1">pop</span></code><span class="koboSpan" id="kobo.71.1">.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.72.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.73.1">copyFile</span></code><span class="koboSpan" id="kobo.74.1"> method, which copies a file specified with the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">src</span></code><span class="koboSpan" id="kobo.76.1"> parameter to the destination specified with the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">dest</span></code><span class="koboSpan" id="kobo.78.1"> parameter. </span><span class="koboSpan" id="kobo.78.2">The method returns an </span><code class="literal"><span class="koboSpan" id="kobo.79.1">Observable[Double]</span></code><span class="koboSpan" id="kobo.80.1"> object, which emits an event with the file transfer progress every 100 milliseconds:</span><pre class="programlisting"><span class="koboSpan" id="kobo.81.1">            def copyFile(src: String, dest: String): Observable[Double] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.82.1">The resulting </span><code class="literal"><span class="koboSpan" id="kobo.83.1">Observable</span></code><span class="koboSpan" id="kobo.84.1"> object must complete if the file transfer completes successfully, or otherwise fail with an exception.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.85.1">Create a custom Swing component, called </span><code class="literal"><span class="koboSpan" id="kobo.86.1">RxCanvas</span></code><span class="koboSpan" id="kobo.87.1">, which exposes mouse events using </span><code class="literal"><span class="koboSpan" id="kobo.88.1">Observable</span></code><span class="koboSpan" id="kobo.89.1"> objects:</span><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">            class RxCanvas extends Component { 
              def mouseMoves: Observable[(Int, Int)] 
              def mousePresses: Observable[(Int, Int)] 
              def mouseReleases: Observable[(Int, Int)] 
            } 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.91.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">RxCanvas</span></code><span class="koboSpan" id="kobo.93.1"> component to build your own Paint program, in which you can drag lines on the canvas using a brush, and save the contents of the canvas to an image file. </span><span class="koboSpan" id="kobo.93.2">Consider using nested </span><code class="literal"><span class="koboSpan" id="kobo.94.1">Observable</span></code><span class="koboSpan" id="kobo.95.1"> objects to implement dragging.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.96.1">Implement a method called </span><code class="literal"><span class="koboSpan" id="kobo.97.1">scatterGather</span></code><span class="koboSpan" id="kobo.98.1"> on the type </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Observable</span></code><span class="koboSpan" id="kobo.100.1">, which forwards every event to one of the worker threads, performs some work on those threads, and emits the computed results on a new </span><code class="literal"><span class="koboSpan" id="kobo.101.1">Observable</span></code><span class="koboSpan" id="kobo.102.1"> object. </span><span class="koboSpan" id="kobo.102.2">The signature of this method is as follows, where type </span><code class="literal"><span class="koboSpan" id="kobo.103.1">T</span></code><span class="koboSpan" id="kobo.104.1"> is the type of the events in the original </span><code class="literal"><span class="koboSpan" id="kobo.105.1">Observable</span></code><span class="koboSpan" id="kobo.106.1">:</span><pre class="programlisting"><span class="koboSpan" id="kobo.107.1">            def scatterGather[S](f: T =&gt; S): Observable[S] 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.108.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.109.1">sorted</span></code><span class="koboSpan" id="kobo.110.1"> method on the type </span><code class="literal"><span class="koboSpan" id="kobo.111.1">Observable</span></code><span class="koboSpan" id="kobo.112.1">, which emits incoming events in the sorted order. </span><span class="koboSpan" id="kobo.112.2">The events can be emitted only after the original </span><code class="literal"><span class="koboSpan" id="kobo.113.1">Observable</span></code><span class="koboSpan" id="kobo.114.1"> terminates.</span></li></ol></div></div></div></div></body></html>