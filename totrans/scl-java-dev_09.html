<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Building Reactive Web Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Building Reactive Web Applications</h1></div></div></div><p>Modern web applications increasingly require us to move from static web content to a more dynamic paradigm where a lot of integration happens in the background and the user interaction is more and more sophisticated. At the same time, the provided online services need to adapt to the changing business requirements and scale to elastic loads, that is, handling peak hour traffic. Finally, in addition to the service they provide, web applications now tend to collect extra information concerning user interaction to better understand customer behavior. In this chapter, we are going to tackle the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding what makes applications reactive</li><li class="listitem" style="list-style-type: disc">Introducing the processing of streams in Play Framework with the <span class="emphasis"><em>Iteratees</em></span> pattern</li><li class="listitem" style="list-style-type: disc">Writing reactive applications including web sockets</li></ul></div><div class="section" title="Describing reactive applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Describing reactive applications</h1></div></div></div><p>The traditional pull model <a id="id491" class="indexterm"/>adopted by the Web, which is used to browse HTML pages now needs to be seconded by two-way communication. This includes a push model where users, for example, receive confirmation of asynchronous and long-running services or just get notifications of various natures.</p><p>The recently created Reactive <a id="id492" class="indexterm"/>Manifesto, which is available at <a class="ulink" href="http://www.reactivemanifesto.org">http://www.reactivemanifesto.org</a>, aims to summarize the criteria that characterize reactive applications in a technology-agnostic way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>React to events</strong></span>: <a id="id493" class="indexterm"/>Message-passing architecture, not wasting the time waiting for resources</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>React to load</strong></span>: Focuses on <a id="id494" class="indexterm"/>scalability by avoiding contention on shared resources</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>React to failure</strong></span>: Build resilient <a id="id495" class="indexterm"/>systems with the ability to recover at all levels</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>React to users</strong></span>: Honor <a id="id496" class="indexterm"/>response time guarantees regardless of load</li></ul></div><p>Without going into the details of the manifesto that you are encouraged to read, we can directly see that the notion of message-driven architecture, which was used by Akka in the previous chapter, fits very well with this reactive model. In the following sections, we are going to focus on examples of building such web applications on top of the Play Framework.</p></div></div>
<div class="section" title="Handling streams reactively"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Handling streams reactively</h1></div></div></div><p>Whenever you need to consume and <a id="id497" class="indexterm"/>transform streams of data in web applications, such as watching stock updates or monitoring log activities on a service, you need mechanisms to manipulate chunks of data that can be pushed from a server to a browser, for instance, using Comet (<a class="ulink" href="http://en.wikipedia.org/wiki/Comet_(programming)">http://en.wikipedia.org/wiki/Comet_(programming)</a>) or WebSocket (<a class="ulink" href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a>) technologies. The <code class="literal">Iteratee</code> pattern available within the Play framework is such a mechanism. It was borrowed from the Haskell functional language initially.</p><div class="section" title="Understanding Iteratees in Play"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec62"/>Understanding Iteratees in Play</h2></div></div></div><p>An <code class="literal">Iteratee</code> construct aims at <a id="id498" class="indexterm"/>providing a composable and nonblocking way of handling streams produced by <a id="id499" class="indexterm"/>its counterpart called <code class="literal">Enumerator</code>.</p><p>Let's launch a Scala REPL to explore the <code class="literal">Iteratee</code>/<code class="literal">Enumerator</code> constructs in more detail. To create a new play project as we have done several times before, notably in <a class="link" href="ch05.html" title="Chapter 5. Getting Started with the Play Framework">Chapter 5</a>, <span class="emphasis"><em>Getting Started with the Play Framework</em></span>, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play new ch9samples (then choose Scala as language)</strong></span>
<span class="strong"><strong>&gt; cd ch9samples</strong></span>
<span class="strong"><strong>&gt; play console</strong></span>
</pre></div><p>First, we will remind ourselves how an iteration is done within an imperative language such as Java. The following statements written in Scala describe the use of a mutable variable <code class="literal">total</code> that will be updated at each step of the iteration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val numbers = List(1,4,7,8,10,20)</strong></span>
<span class="strong"><strong>numbers: List[Int] = List(1, 4, 7, 8, 10, 20)</strong></span>
<span class="strong"><strong>scala&gt; var total = 0</strong></span>
<span class="strong"><strong>total: Int = 0</strong></span>
<span class="strong"><strong>scala&gt; var iterator = numbers.iterator</strong></span>
<span class="strong"><strong>iterator: Iterator[Int] = non-empty iterator</strong></span>
<span class="strong"><strong>scala&gt; while (iterator.hasNext) {</strong></span>
<span class="strong"><strong>           total += iterator.next</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>scala&gt; total</strong></span>
<span class="strong"><strong>res2: Int = 50</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>As explained in the blog post available at <a class="ulink" href="http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/">http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/</a>, we need to take care of the following when iterating:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The state of the iteration (are there more elements to follow or is it finished)?</li><li class="listitem" style="list-style-type: disc">A context (here the total accumulator)</li><li class="listitem" style="list-style-type: disc">An action, updating the context, that is, the total += iterator.next</li></ul></div></div></div><p>We have seen in <a class="link" href="ch01.html" title="Chapter 1. Programming Interactively within Your Project">Chapter 1</a>, <span class="emphasis"><em>Programming Interactively within Your Project,</em></span> that we can implement the same operation in a concise and more functional way by using the <code class="literal">foldLeft</code> Scala construct in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; List(1,4,7,8,10,20).foldLeft(0){ (total,elem) =&gt;</strong></span>
<span class="strong"><strong>       total + elem } </strong></span>
<span class="strong"><strong>res3: Int = 50</strong></span>
</pre></div><p>The <code class="literal">foldLeft</code> construct is a powerful construct that is applied to Scala collections such as <code class="literal">Lists</code>. If we want to process other forms of input such as a file, a network, a database connection, or a flow produced by an <a id="id500" class="indexterm"/>Akka actor for instance, then the <code class="literal">Enumerator/Iteratee</code> comes into play. An <code class="literal">Enumerator</code> construct can be seen as the producer of data (similar to the previous <code class="literal">List</code> ) and an <code class="literal">Iteratee</code> as the consumer of that data, processing each step of the iteration. The preceding example involving the <code class="literal">foldLeft</code> method on a <code class="literal">List</code> could just be rewritten using an <code class="literal">Enumerator/Iteratee </code>construct. As the <code class="literal">iteratee</code> library is already available within Play, it can be imported directly by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import play.api.libs.iteratee._</strong></span>
<span class="strong"><strong>import play.api.libs.iteratee._</strong></span>
<span class="strong"><strong>scala&gt; import play.api.libs.concurrent.Execution.Implicits._</strong></span>
<span class="strong"><strong>import play.api.libs.concurrent.Execution.Implicits._</strong></span>
</pre></div><p>After importing the <span class="emphasis"><em>iteratee</em></span> library and a global execution context for the <code class="literal">iteratee</code> variables to work with, we can define our first <code class="literal">Enumerator</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val enumerator = Enumerator(1,4,7,8,10,20)</strong></span>
<span class="strong"><strong>enumerator: play.api.libs.iteratee.Enumerator[Int] = play.api.libs.iteratee.Enumerator$$anon$19@27a21c85...</strong></span>
</pre></div><p>The <code class="literal">iteratee</code> variable defined as follows indicates the computation step to be performed while accepting an input from the <code class="literal">enumerator</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val iteratee = Iteratee.fold(0){ (total, elem:Int) =&gt; total + elem }</strong></span>
<span class="strong"><strong>iteratee: play.api.libs.iteratee.Iteratee[Int,Int] = play.api.libs.iteratee.ContIteratee@e07a406</strong></span>
</pre></div><p>Combining the <code class="literal">enumerator</code> construct with the <code class="literal">iteratee</code> construct is a matter of invoking the <code class="literal">run</code> method of <code class="literal">enumerator</code> that takes the <code class="literal">iteratee</code> as an argument:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val result = enumerator.run(iteratee)</strong></span>
<span class="strong"><strong>result: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@78b5282b</strong></span>
</pre></div><p>As we have an asynchronous computation, we get back a <code class="literal">result</code> as a <code class="literal">Future</code> that we can display once it is completed, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; result onComplete println</strong></span>
<span class="strong"><strong>scala&gt; Success(50)</strong></span>
</pre></div><p>The <code class="literal">enumerator</code> object mentioned <a id="id501" class="indexterm"/>previously was an enumerator of integers. We can create producers of data of many different types, such as strings or double values. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val stringEnumerator = Enumerator("one","two","four")</strong></span>
<span class="strong"><strong>stringEnumerator: play.api.libs.iteratee.Enumerator[String] = play.api.libs.iteratee.Enumerator$$anon$19@1ca7d367</strong></span>
<span class="strong"><strong>scala&gt; val doubleEnumerator = Enumerator(1.03,2.34,4)</strong></span>
<span class="strong"><strong>doubleEnumerator: play.api.libs.iteratee.Enumerator[Double] = play.api.libs.iteratee.Enumerator$$anon$19@a8e29a5</strong></span>
</pre></div><p>To illustrate the creation of an Enumerator from a file, let's add a little text file named <code class="literal">samplefile.txt</code> in the root of the current project containing, for instance, the following three lines of text:</p><div class="informalexample"><pre class="programlisting">Alice
Bob
Charlie</pre></div><p>You may use a separate console window to create this file while leaving the REPL running in the original console window. Otherwise, you will have to rerun the import statements. Creating an <code class="literal">Enumerator</code> from a file is shown in the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import java.io.File</strong></span>
<span class="strong"><strong>import java.io.File</strong></span>
<span class="strong"><strong>scala&gt; val fileEnumerator: Enumerator[Array[Byte]] = Enumerator.fromFile(new File("./samplefile.txt"))</strong></span>
<span class="strong"><strong>fileEnumerator: play.api.libs.iteratee.Enumerator[Array[Byte]] = play.api.libs.iteratee.Enumerator$$anon$4@33500f2</strong></span>
</pre></div><p>
<code class="literal">Enumerator</code> even comprises some useful methods. For example, a stream of events that are generated at regular intervals each time the <code class="literal">Promise</code> object, which contains the current time, times out (every 500 milliseconds).</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val dateGenerator: Enumerator[String] = Enumerator.generateM(</strong></span>
<span class="strong"><strong>          play.api.libs.concurrent.Promise.timeout(</strong></span>
<span class="strong"><strong>    Some("current time %s".format((new java.util.Date()))),</strong></span>
<span class="strong"><strong>    500</strong></span>
<span class="strong"><strong>    )) </strong></span>
</pre></div><p>In a more general way, we can say that <code class="literal">Enumerator[E]</code> (read enumerator of type E) produces three possible kinds of <a id="id502" class="indexterm"/>chunks of data of type E:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Input[E]</code>: It is a <a id="id503" class="indexterm"/>chunk of data of type E, for example, <code class="literal">Input[LogData]</code> is a chunk of <code class="literal">LogData</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Input.Empty</code>: It means that the <a id="id504" class="indexterm"/>enumerator is empty, for instance, an <code class="literal">Enumerator</code> streaming an empty file</li><li class="listitem" style="list-style-type: disc"><code class="literal">Input.EOF</code>: It means that the <a id="id505" class="indexterm"/>enumerator has reached its end, for instance, an <code class="literal">Enumerator</code> construct streaming a file and reaching the end of the file</li></ul></div><p>In addition to the <code class="literal">run</code> method <a id="id506" class="indexterm"/>used to run an <code class="literal">Enumerator</code> over an <code class="literal">Iteratee</code>, you can also invoke the constructor, <a id="id507" class="indexterm"/>that is, the <code class="literal">apply</code> method of the enumerator directly. Notice in the following two commands, the different result types you get depending on how you combine <code class="literal">enumerator</code>/<code class="literal">iteratee</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val result = enumerator.run(iteratee)</strong></span>
<span class="strong"><strong>result: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@1837220f</strong></span>
<span class="strong"><strong>scala&gt; val result2=enumerator(iteratee)</strong></span>
<span class="strong"><strong>result2: scala.concurrent.Future[play.api.libs.iteratee.Iteratee[Int,Int]] = scala.concurrent.impl.Promise$DefaultPromise@5261b67f</strong></span>
</pre></div><p>This last <code class="literal">Future</code> result contains an <code class="literal">Iteratee[Int,Int]</code>, that is, an <code class="literal">Iteratee[&lt;type contained in chunk&gt;, &lt;result of the iteration&gt;]</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val enumerator = Enumerator(1,4,7,8,10,20)</strong></span>
<span class="strong"><strong>enumerator: play.api.libs.iteratee.Enumerator[Int] = play.api.libs.iteratee.Enumerator$$anon$19@7e666ce4</strong></span>
</pre></div><p>The following <code class="literal">Iteratee</code> consumes all the chunks from the <code class="literal">enumerator</code> stream and returns them as a <code class="literal">List</code> collection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val chunksIteratee = Iteratee.getChunks[Int]</strong></span>
<span class="strong"><strong>chunksIteratee: play.api.libs.iteratee.Iteratee[Int,List[Int]] = play.api.libs.iteratee.ContIteratee@53af8d86</strong></span>
<span class="strong"><strong>scala&gt; val list = enumerator.run(chunksIteratee)</strong></span>
<span class="strong"><strong>list: scala.concurrent.Future[List[Int]] = scala.concurrent.impl.Promise$DefaultPromise@66e1b41c</strong></span>
<span class="strong"><strong>scala&gt; list onComplete println</strong></span>
<span class="strong"><strong>scala&gt; Success(List(1, 4, 7, 8, 10, 20))</strong></span>
</pre></div><p>The examples of <code class="literal">Iteratee</code> that we have seen so far use the method <code class="literal">fold</code> pretty much like the <code class="literal">foldLeft</code> <a id="id508" class="indexterm"/>and the <code class="literal">foldRight</code> <a id="id509" class="indexterm"/>methods that are part of the Scala collection. Let's try to build a more sophisticated <code class="literal">Iteratee</code>: one that, for instance, selects words containing the letter <code class="literal">E</code> out of the enumerator <a id="id510" class="indexterm"/>streams. This can be done using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def wordsWithE: Iteratee[String,List[String]] = {</strong></span>
<span class="strong"><strong>  def step(total:List[String])(input:Input[String]): Iteratee[String,List[String]] = input match {</strong></span>
<span class="strong"><strong>    case Input.EOF | Input.Empty =&gt; Done(total,Input.EOF)</strong></span>
<span class="strong"><strong>    case Input.El(elem) =&gt;</strong></span>
<span class="strong"><strong>      if(elem.contains("E")) Cont[String,List[String]](i=&gt; step(elem::total)(i))</strong></span>
<span class="strong"><strong>      else Cont[String,List[String]](i=&gt; step(total)(i))</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  Cont[String,List[String]](i=&gt; step(List[String]())(i))</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>wordsWithE: play.api.libs.iteratee.Iteratee[String,List[String]]</strong></span>
</pre></div><p>The <code class="literal">step</code> recursive function is using a <code class="literal">total</code> accumulator variable, that is, a context to keep some state at each step of the recursion. This is a list of strings containing all the results we are interested in. The second argument to the <code class="literal">step</code> function is the new chunk from the <code class="literal">enumerator</code> stream that comes up at each step. This chunk is matched against the possible states; if either the stream is empty or we have reached its end, we return the accumulated result in a <code class="literal">Done</code> state. Otherwise, we handle the incoming element. If the element verifies the <code class="literal">if</code> condition, then we add it to the accumulator and invoke the next step in our recursion as part of a <code class="literal">Cont</code> (continue) state. Otherwise, we just invoke the next step without saving the element.</p><p>Finally, the last step initiates the recursion by calling the <code class="literal">step</code> function on the first element of the stream with an empty accumulator. Applying this newly-defined <code class="literal">Iteratee</code> on a simple enumerator looks like the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val output = Enumerator("ONE","TWO","THREE") run wordsWithE</strong></span>
<span class="strong"><strong>output: scala.concurrent.Future[List[String]] = scala.concurrent.impl.Promise$DefaultPromise@50e0cc83</strong></span>
<span class="strong"><strong>scala&gt; output onComplete println</strong></span>
<span class="strong"><strong>scala&gt; Success(List(THREE, ONE))</strong></span>
</pre></div><p>Every computation step performed on an <a id="id511" class="indexterm"/>incoming string either appends that string to the total accumulator or ignores it, depending on whether it matches the <code class="literal">if</code> condition or not. In this example, it simply checks that the word contains at least one <code class="literal">E</code>.</p></div><div class="section" title="Adapting Enumerator with Enumeratee"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec63"/>Adapting Enumerator with Enumeratee</h2></div></div></div><p>It might happen that the <a id="id512" class="indexterm"/>data consumed by an <code class="literal">Iteratee</code> does not match the input produced by an <code class="literal">Enumerator</code>. The role of an <code class="literal">Enumeratee</code> is to be an adapter that sits in between the <code class="literal">Enumerator</code> and <code class="literal">Iteratee</code> to transform the incoming data before feeding the <code class="literal">Iteratee</code>.</p><p>As an example of simple transformation from an <code class="literal">Enumerator</code> to another one, we could ,for instance, define an <a id="id513" class="indexterm"/>
<code class="literal">Enumeratee</code> that converts an input of the type <code class="literal">String</code> to <code class="literal">Int</code>, as illustrated by the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val summingIteratee = Iteratee.fold(0){ (total, elem:Int) =&gt; total + elem }</strong></span>
<span class="strong"><strong>summingIteratee: play.api.libs.iteratee.Iteratee[Int,Int] = play.api.libs.iteratee.ContIteratee@196fad1a</strong></span>
<span class="strong"><strong>scala&gt; Enumerator("2","5","7") through Enumeratee.map(x =&gt; x.toInt) run summingIteratee</strong></span>
<span class="strong"><strong>res5: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@5ec418a8</strong></span>
<span class="strong"><strong>scala&gt; res5 onComplete println</strong></span>
<span class="strong"><strong>scala&gt; Success(14)</strong></span>
</pre></div><p>The transformation provided by the <code class="literal">Enumeratee</code> can be declared in its <code class="literal">map</code> method.</p><p>Adapting the <code class="literal">Enumerator</code> can also consist of transforming the input data to a different format without changing the type. Considering <code class="literal">wordsWithE</code> that we defined previously, we could apply an <code class="literal">Enumeratee</code> that converts all the input data to uppercase so that the consumption of the stream of data by the <code class="literal">Iteratee</code> would produce a different result than the one obtained without <code class="literal">Enumeratee</code>. <a id="id514" class="indexterm"/>The following code illustrates that behavior:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val enumerator = Enumerator("ONE","Two","Three")</strong></span>
<span class="strong"><strong>scala&gt; enumerator run wordsWithE onComplete println</strong></span>
<span class="strong"><strong>scala&gt; Success(List(ONE))</strong></span>
<span class="strong"><strong>scala&gt; enumerator through Enumeratee.map(x=&gt;x.toUpperCase) run wordsWithE onComplete println</strong></span>
<span class="strong"><strong>scala&gt; Success(List(THREE, ONE))</strong></span>
</pre></div><p>To summarize, an <code class="literal">Enumerator</code> is a producer of a data stream, an <code class="literal">Iteratee</code> a consumer of that data, and an <code class="literal">Enumeratee</code> an adapter between the two. The <span class="emphasis"><em>iteratee</em></span> pattern has been integrated together with the Play Framework as a way to handle streams of data reactively in a web application. In the next section, we are going to build web applications in such a way, by additionally using WebSockets to communicate between the client and the server in both <a id="id515" class="indexterm"/>directions.</p></div></div>
<div class="section" title="Experimenting with WebSockets and Iteratees in Play"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Experimenting with WebSockets and Iteratees in Play</h1></div></div></div><p>In addition to the traditional <a id="id516" class="indexterm"/>pull model of getting HTML displayed in a browser when querying a service, most web browsers now support bidirectional communication via WebSockets so that servers can push data without the user having to query for it first. Once a socket is established between client and server, the communication can stay open for further interaction, unlike the HTTP protocol. Modern web apps are using this feature more and more to push data from streams reactively.</p><p>As a reminder, a <span class="strong"><strong>WebSocket</strong></span> is a protocol providing bidirectional communication over a single TCP connection, in contrast to the traditional one-way, stateless communication of HTTP (either a request or a response). Let's look at the support that Play provides in this area and demonstrate in a short example how to establish a WebSocket communication between the Play server and a client browser.</p><p>As we have already created a <a id="id517" class="indexterm"/>
<code class="literal">ch9samples</code> Play project at the beginning of this chapter to experiment with <code class="literal">Iteratees</code> in the REPL, we can just reuse it. We will start by opening the tiny <code class="literal">controllers/Application.scala</code> server-side class that is available by default. We can add a new <code class="literal">connect</code> method to it to create a WebSocket interaction. In a regular Play controller, a method would normally use an <code class="literal">Action</code> class, as we have seen previously. In this example, we use the <code class="literal">WebSocket</code> class instead, illustrated in the <a id="id518" class="indexterm"/>controller as follows:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api._
import play.api.mvc._
<span class="strong"><strong>import play.api.libs.iteratee._</strong></span>
<span class="strong"><strong>import scala.concurrent.ExecutionContext.Implicits.global</strong></span>

object Application extends Controller {
  
  def index = Action {
    Ok(views.html.index("Your new application is ready."))
  }
  
  <span class="strong"><strong>def connect =  WebSocket.using[String] { request =&gt;</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>    // Concurrent.broadcast returns (Enumerator, Concurrent.Channel)</strong></span>
<span class="strong"><strong>    val (out,channel) = Concurrent.broadcast[String]</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>    // log message to stdout and send response back to client</strong></span>
<span class="strong"><strong>    val in = Iteratee.foreach[String] { msg =&gt;</strong></span>
<span class="strong"><strong>      println(msg)</strong></span>
<span class="strong"><strong>      //the channel will push to the Enumerator</strong></span>
<span class="strong"><strong>      channel push("RESPONSE: " + msg)</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    (in,out)</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>In the server-side controller seen in the <a id="id519" class="indexterm"/>preceding code, the <code class="literal">in</code> variable contains the logic to handle messages coming from the client, and it will produce an <code class="literal">Enumerator</code> to assemble some response data that will be pushed through the channel to each client.</p><p>On the client side, the <code class="literal">views/main.scala.html</code> view is where we are going to add the WebSocket support, as a part of a JavaScript script, whose role is to open a web socket and react to incoming messages. as follows:</p><div class="informalexample"><pre class="programlisting">@(title: String)(content: Html)

&lt;!DOCTYPE html&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;@title&lt;/title&gt;
        &lt;link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/main.css")"&gt;
        &lt;link rel="shortcut icon" type="image/png" href="@routes.Assets.at("images/favicon.png")"&gt;
        &lt;script src="@routes.Assets.at("javascripts/jquery-1.9.0.min.js")" type="text/javascript"&gt;&lt;/script&gt;
        
        &lt;script type="text/javascript"&gt;
    function WebSocketTest() {
      if ("WebSocket" in window) {
         alert("WebSocket is supported by your Browser!");
         // Let us open a web socket
         var ws = new WebSocket("ws://localhost:9000/connect");
         ws.onopen = function() {
            // Web Socket is connected, send data
                 var msg = "Hello Websocket!"
            ws.send(msg);
            alert("Message is sent..."+msg);
         };
         ws.onmessage = function (evt) { 
            var received_msg = evt.data;
            alert("Message is received..."+received_msg);
         };
         ws.onclose = function() { 
            // websocket is closed.
            alert("Connection is closed..."); 
         };
      }
      else {
         // The browser doesn't support WebSocket
         alert("WebSocket NOT supported by your Browser!");
      }
    }
    &lt;/script&gt;
  &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="sse"&gt;
            &lt;a href="javascript:WebSocketTest()"&gt;Run WebSocket&lt;/a&gt;
           &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Now that we have both ends, the only remaining step is to define a route for the controller's <code class="literal">connect</code> method. Edit the <code class="literal">conf/routes</code> <a id="id520" class="indexterm"/>file to make it look like the following:</p><div class="informalexample"><pre class="programlisting"># Routes
# This file defines all application routes (Higher priority routes first)
# ~~~~

# Home page
GET  /      controllers.Application.index
<span class="strong"><strong>GET  /connect    controllers.Application.connect</strong></span>

# Map static resources from the /public folder to the /assets URL path
GET  /assets/*file  controllers.Assets.at(path="/public", file)</pre></div><p>Now, we are ready to try the demo by starting the play server from the command prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play run</strong></span>
</pre></div><p>Opening a browser at <code class="literal">http://localhost:9000/</code> (preferably one that supports WebSockets) and clicking on the <span class="strong"><strong>Run WebSocket</strong></span> link should first confirm that the browser is indeed supporting WebSockets. Clicking on <span class="strong"><strong>OK</strong></span> a couple of times will first  show you that a message has been sent, and then show that the roundtrip has been achieved by receiving a message from the server. You should also see the <code class="literal">Message to send</code> log message on the play server prompt.</p></div>
<div class="section" title="Learning from activator templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Learning from activator templates</h1></div></div></div><p>There is a growing list of <a id="id521" class="indexterm"/>reactive applications based on <span class="emphasis"><em>iteratees</em></span> that have been packaged and deployed as activator templates. At the time of writing this book, we have identified more than five templates and you can look at a few of them. They often mix technologies such as WebSockets with Akka for communication and message processing and, on the client side, JavaScript frameworks such as Angular.js, to often provide simple HTML rendering.</p><p>As the Typesafe activator templates HTML page lets you select tags to filter out projects depending on some keywords, you may <a id="id522" class="indexterm"/>check the appropriate projects by selecting the reactive checkbox.</p><div class="section" title="Reactive stocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec64"/>Reactive stocks</h2></div></div></div><p>This sample is a project <a id="id523" class="indexterm"/>based on the Java version of Play. It graphically demonstrates the real-time update of stock values (that are randomly generated for simplicity). It <a id="id524" class="indexterm"/>contains both Java and Scala code. An Akka <a id="id525" class="indexterm"/>
<code class="literal">StockActor</code> actor is instantiated for every stock symbol, and its role is to maintain a list of all users watching this stock. Some additional functionality queries a twitter API to retrieve all tweets matching a particular symbol (for example, <a class="ulink" href="http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl">http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl</a>). This knowledge can then be processed to calculate a sentiment index that should help to decide whether to buy this stock or not. The following screenshot illustrates graphically what the app looks like, once it is run:</p><div class="mediaobject"><img src="graphics/3637_09_01.jpg" alt="Reactive stocks"/></div></div><div class="section" title="Reactive real-time search"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec65"/>Reactive real-time search</h2></div></div></div><p>To demonstrate some <a id="id526" class="indexterm"/>integration between ElasticSearch and the <a id="id527" class="indexterm"/>reactive features of the Typesafe stack through Play iteratees and Akka, this sample exhibits how to push log events to a browser. As a reminder, <a id="id528" class="indexterm"/>ElasticSearch (<a class="ulink" href="http://www.elasticsearch.org">http://www.elasticsearch.org</a>) is a distributed real-time search and an analytics engine based on the well-established Apache Lucene (<a class="ulink" href="https://lucene.apache.org">https://lucene.apache.org</a>) full-text search engine.</p><p>It notably provides a <span class="strong"><strong>percolation</strong></span> feature, that notifies your application when new content matches your search criteria (instead of having to poll the search engine to check regularly for new updates).</p><p>To emulate content, an Akka <a id="id529" class="indexterm"/>
<code class="literal">LogEntryProducerActor</code> actor is responsible for generating random log entries each time it receives a <code class="literal">Tick</code> message. These messages are produced at regular intervals by a <code class="literal">MainSearchActor</code> <a id="id530" class="indexterm"/>actor that also acts as a coordinator for the search. Finally, an <a id="id531" class="indexterm"/>
<code class="literal">ElasticSearchActor</code> actor implements the percolation feature by interacting with an embedded ElasticSearch server (<code class="literal">EmbeddedESServer</code>) that is started from the Play <code class="literal">Global</code> <a id="id532" class="indexterm"/>class. Instead of pushing information to the browser via WebSockets, the sample uses <span class="strong"><strong>Server Side Events</strong></span> (<span class="strong"><strong>SSE</strong></span>) as it only needs <a id="id533" class="indexterm"/>one-way communication once the search criteria are known.</p><p>Further information on the template <a id="id534" class="indexterm"/>and all the code behind it is available at <a class="ulink" href="https://github.com/DrewEaster/realtime-search">https://github.com/DrewEaster/realtime-search</a>. In particular, the query syntax to be entered for a search is defined as Lucene syntax and is specified at <a class="ulink" href="http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description">http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description</a>.</p><p>If we execute this sample by installing and running the activator template (with the <code class="literal">&gt; activator run</code> command from the root of the template project), we can open a browser at <code class="literal">localhost:9000</code> and enter <code class="literal">GET</code> as the search criterion. After a few seconds, some browser output should progressively be displayed, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_09_02.jpg" alt="Reactive real-time search"/></div></div><div class="section" title="The Play-Akka-Angular-WebSocket template"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec66"/>The Play-Akka-Angular-WebSocket template</h2></div></div></div><p>As another <a id="id535" class="indexterm"/>example of reactively <a id="id536" class="indexterm"/>pushing information to the browser, this sample updates a clock on the client by scheduling an actor. The role of this actor is to send events in the JSON format via a WebSocket connection by using the Play <code class="literal">WebSocket.async[JsValue]</code> <a id="id537" class="indexterm"/>method call. The Angular.js JavaScript framework is used on the client side and the GUI looks like the following screenshot once it starts running:</p><div class="mediaobject"><img src="graphics/3637_09_03.jpg" alt="The Play-Akka-Angular-WebSocket template"/></div><p>The number of activator templates that illustrate reactive applications is growing. Also, you can check out from time to <a id="id538" class="indexterm"/>time the <a id="id539" class="indexterm"/>new templates that are available, without upgrading the version of the activator each time.</p></div></div>
<div class="section" title="Playing with Actor Room"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Playing with Actor Room</h1></div></div></div><p>In the previous section, we <a id="id540" class="indexterm"/>have seen a number of projects that are using <code class="literal">Enumerators</code>/<code class="literal">Iteratees</code> to send and receive messages reactively, with various levels of complexity. <code class="literal">Iteratees</code> are powerful, but using them can sometimes lead to code snippets that are not easy to understand. The Play Actor Room project, which is available at <a class="ulink" href="https://github.com/mandubian/play-actor-room">https://github.com/mandubian/play-actor-room</a>, proposes to reduce some of the complexity of setting up <code class="literal">Iteratees</code> by abstracting away this part and letting the programmer focus only on the domain logic, such as processing incoming messages and assembling outgoing messages. This project started from the observation that many applications need the same functionality, which can be seen as a server <code class="literal">Room</code> (holding state, for instance, and being the middle man between distributed clients). The role of this room is to listen for incoming messages from connected clients, and either broadcast received messages after processing them or just unicast communication to a single client. It is a good illustration of how an application can react to users/events. Typical applications such as a multiuser chat are therefore very straightforward to write, and they are one of the two samples given as examples. Let's experiment with the most basic use of the actor room support, a sample called <code class="literal">simplest</code>.</p><p>To clone the project somewhere on your disk, just enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; git clone https://github.com/mandubian/play-actor-room</strong></span>
</pre></div><p>First, we can look at the application once it is running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd play-actor-room/samples/simplest</strong></span>
<span class="strong"><strong>&gt; play run</strong></span>
</pre></div><p>Opening a browser at the default play port (<code class="literal">http://localhost:9000/</code>) will show you a simple <span class="strong"><strong>sign-in</strong></span> widget, as shown in the following screenshot. Enter your name to log in, type a message in the provided text area, and then press <span class="emphasis"><em>Enter</em></span>.</p><div class="mediaobject"><img src="graphics/3637_09_04.jpg" alt="Playing with Actor Room"/></div><p>In the console window where you started the actor room application, you should now see the logging information printed by the actor that received messages from the client browser. The information can be seen as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[info] play - Application started (Dev)</strong></span>
<span class="strong"><strong>[info] play - Starting application default Akka system.</strong></span>
<span class="strong"><strong>[debug] application - Connected Member with ID:Thomas</strong></span>
<span class="strong"><strong>[info] application - received Play Actor Room rocks</strong></span>
</pre></div><p>On opening several browser windows and logging in with different names, you can see all the messages hitting the server room, that is, at the console. The actor room actually broadcasts the received messages back to all connected browsers, although for now there is nothing in the view to handle the <a id="id541" class="indexterm"/>messages. </p><p>You can, however, open the console of one browser to see the display of the broadcast messages, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_09_05.jpg" alt="Playing with Actor Room"/></div><p>Additionally, invoking the <code class="literal">http://localhost:9000/list/</code> URL from a third window will return the list of currently connected clients.</p><p>Some of the interesting features of this <a id="id542" class="indexterm"/>basic application can be observed once we import the project into eclipse (entering the <code class="literal">&gt; play eclipse</code> command) and open the controller that includes the implementation of the receiving <code class="literal">Actor</code> class.</p><p>The <code class="literal">Receiver</code> actor that acts as the <a id="id543" class="indexterm"/>server has been created by a supervisor <code class="literal">Actor</code>. It handles messages in JSON format. All the default logic of the receiving <code class="literal">Actor</code>, which is the only code that we need to care about for processing messages from clients, is as follows:</p><div class="informalexample"><pre class="programlisting">class Receiver extends Actor {
  def receive = {
    case Received(from, js: JsValue) =&gt;
      (js \ "msg").asOpt[String] match {
        case None =&gt; play.Logger.error("couldn't msg in websocket event")
        case Some(s) =&gt;
          play.Logger.info(s"received $s")
          context.parent ! Broadcast(from, Json.obj("msg" -&gt; s))
      }
  }
}</pre></div><p>Note that broadcasting the response from <a id="id544" class="indexterm"/>the server to all the clients is done by the supervising actor referenced by <code class="literal">context.parent</code>. In the previous logic, the <code class="literal">Broadcast</code> message also includes the originator <code class="literal">from</code> <code class="literal">ActorRef</code> reference.</p><p>As a small modification to the default room behavior to fit new business requirements, we can, for instance, reuse the <code class="literal">TravelAgent</code>, <code class="literal">Flight</code>, and <code class="literal">Hotel</code> actors that we created in <a class="link" href="ch08.html" title="Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency">Chapter 8</a>, <span class="emphasis"><em>Essential Properties of Modern Applications – Asynchrony and Concurrency</em></span>. We want to provide each user with the ability to book a flight, and (at any time) monitor how many seats are still available. To do this, we can involve a slightly bigger JSON message as the exchange format between the server and client.</p><p>A useful enhancement to Scala that came with Version 2.10 is the notion of string interpolation. We already used this feature throughout this book and introduced it in <a class="link" href="ch01.html" title="Chapter 1. Programming Interactively within Your Project">Chapter 1</a>, <span class="emphasis"><em>Programming Interactively within Your Project</em></span>. Similarly, JSON interpolation has been created as an extension to the JSON support in Play. We can reuse JSON interpolation, for instance, to do some elegant pattern matching. Just add the following extension dependencies to the <code class="literal">Build.scala</code> file:</p><div class="informalexample"><pre class="programlisting">val appDependencies = Seq(
    "org.mandubian" %% "play-actor-room" % "0.1",
    "play-json-zipper" %% "play-json-zipper" % "1.0",
    "com.typesafe.play" %% "play-json"           % "2.2.0"
  )</pre></div><p>Once in place, the JSON pattern matching feature handles the JSON messages coming from the browser client to the <code class="literal">Receiver </code>actor, as follows</p><div class="informalexample"><pre class="programlisting">case Received(from, js: JsValue) =&gt;
      js match {
        case json"""{
          "booking":"flight",
          "numberOfPersons":$v1
        }""" =&gt;  play.Logger.info(s"received $v1")
        …</pre></div><p>Let's add a <code class="literal">Flight</code> actor to keep the count of <a id="id545" class="indexterm"/>seats available. In a new package <code class="literal">actors</code>, which is directly under the <code class="literal">app/</code> source directory, we can add a <code class="literal">Flight.scala</code> class that looks like the following:</p><div class="informalexample"><pre class="programlisting">package actors

import akka.actor.Actor
import akka.event.LoggingReceive

object Flight {
  case class BookSeat(number:Int) {
    require(number &gt; 0)
  }
  case object GetSeatsLeft
  case object Done
  case object Failed
}
class Flight extends Actor {
  import Flight._
  
  def book(seats:Int):Receive = LoggingReceive {
    case BookSeat(nb) if nb &lt;= seats =&gt;
      context.become(book(seats-nb))
      sender ! Done
    case GetSeatsLeft =&gt; sender ! seats
    case _ =&gt; sender ! Failed
  }
  
  def receive = book(50) // Initial number of available seats
}</pre></div><p>Rather than creating a mutable state variable <code class="literal">var seatsLeft</code>, as we did in <a class="link" href="ch08.html" title="Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency">Chapter 8</a>, <span class="emphasis"><em>Essential Properties of Modern Applications – Asynchrony and Concurrency</em></span>, we encapsulated this state change as an argument passed while switching context each time we receive a <code class="literal">BookSeat</code> message. This way of proceeding is a recommended best practice to avoid holding mutable variables. We have added a <code class="literal">GetSeatsLeft</code> message to be able to query the value of the current state, in which case the state is sent back to the <code class="literal">sender</code> actor.</p><p>On the client side, we can modify the <code class="literal">index.scala.html</code> view to add a couple of simple widgets to our application. In particular, we can add a placeholder to display the number of available seats left in the flight. <a id="id546" class="indexterm"/>This is the information that will be pushed to all connected browsers by the server room actor. An example of such a view is as follows:</p><div class="informalexample"><pre class="programlisting">@(connected: Option[String] = None)

@main(connected) {

  @connected.map { id =&gt;
    &lt;p class="pull-right"&gt;
     Logged in as @id
       &lt;a href="@routes.Application.index()"&gt;Disconnect&lt;/a&gt;
    &lt;/p&gt;
    &lt;div&gt;Places left in flight: &lt;input size="10" id="placesLeft"&gt;&lt;/input&gt;&lt;/div&gt;
      
    &lt;div&gt;
      &lt;select id ="booking"&gt;
        &lt;option value="flight"&gt;Flight&lt;/option&gt;
        &lt;option value="hotel"&gt;Hotel&lt;/option&gt;
      &lt;/select&gt;
      Number of persons to book:
      &lt;textarea id ="numberOfPersons" &gt;&lt;/textarea&gt;
    &lt;/div&gt;

    &lt;script type="text/javascript" charset="utf-8" src="@routes.Application.websocketJs(id)"&gt;&lt;/script&gt;
  }.getOrElse {
    &lt;form action="@routes.Application.connect(None)" class="pull-right"&gt;
      &lt;input id="username" name="id" class="input-small" type="text" placeholder="Username"&gt;
        &lt;button class="btn" type="submit"&gt;Sign in&lt;/button&gt;
    &lt;/form&gt;
  }
}</pre></div><p>We also need to slightly modify the small JavaScript snippet that handles communication between the client browser and the server <a id="id547" class="indexterm"/>via the WebSocket so that it handles the new JSON format. The modified <code class="literal">websocket.scala.js</code> file is given as follows:</p><div class="informalexample"><pre class="programlisting">@(id: String)(implicit r: RequestHeader)

$(function() {

  var WS = window['MozWebSocket'] ? MozWebSocket : WebSocket;
  var wsSocket = new WS("@routes.Application.websocket(id).webSocketURL()");
  var sendMessage = function() {
    wsSocket.send(JSON.stringify(
       {
         "booking":$("#booking").val(),
         "numberOfPersons":$("#numberOfPersons").val()
       }
    ))
    $("#numberOfPersons").val('');
  }

  var receiveEvent = function(event) {
    console.log(event);
    var data = JSON.parse(event.data);
    // Handle errors
    if(data.error) {
      console.log("WS Error ", data.error);
      wsSocket.close();
      // TODO manage error
      return;
    } else {
      console.log("WS received ", data);
      // TODO manage display
      $("#placesLeft").val(data.placesLeft);
    }
  }

  var handleReturnKey = function(e) {
    if(e.charCode == 13 || e.keyCode == 13) {
      e.preventDefault();
      sendMessage();
    }
  }

  $("#numberOfPersons").keypress(handleReturnKey);

  wsSocket.onmessage = receiveEvent;

})</pre></div><p>Finally, in the <code class="literal">Application.scala</code> file of the server part, we can extend the <code class="literal">Receiver</code> actor to handle incoming JSON messages and contact the <code class="literal">Flight</code> actor to both update and read the current value of its state, <a id="id548" class="indexterm"/>as follows:</p><div class="informalexample"><pre class="programlisting">[…imports from the original actor room sample…]
import play.api.libs.json._
import play.api.libs.functional.syntax._
import play.api.libs.json.extensions._

import actors._

object Receiver {
  val flightBookingActor = Akka.system.actorOf(Props[Flight],"flight")
}
class Receiver extends Actor {
  import Receiver.flightBookingActor
  
  def receive = LoggingReceive {
    case x:Int =&gt; 
      play.Logger.info(s"Received number of seats left: $x")
      val placesLeft:String = if (x&lt;0) "Fully Booked" else x.toString
      context.parent ! Broadcast("flight", Json.obj("placesLeft" -&gt; placesLeft))  
    case Received(from, js: JsValue) =&gt;
      js match {
        case json"""{
          "booking":"flight",
          "numberOfPersons":$v1
        }""" =&gt; 
          play.Logger.info(s"received $v1")
          val nbOfPersons = v1.as[String]
          flightBookingActor ! Flight.BookSeat(nbOfPersons.toInt)
          val placesCount = flightBookingActor ! Flight.GetSeatsLeft           
        case _ =&gt; play.Logger.info(s"no match found")
      }
  }
}</pre></div><p>Now that we have all the pieces in place, let's run the example in a couple of browsers. Notice that we have added the <a id="id549" class="indexterm"/>
<code class="literal">LoggingReceive</code> call to both the <code class="literal">Receiver</code> and <code class="literal">Flight</code> actors so that we get extensive logging output once we execute the server code. On the command prompt, you may enter the following commands to start the Play application with the additional flags to activate <a id="id550" class="indexterm"/>the logging output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play</strong></span>
<span class="strong"><strong>&gt; run -Dakka.loglevel=DEBUG -Dakka.actor.debug.receive=true</strong></span>
</pre></div><p>Open two browser windows (possibly using two different browsers) at the URL <code class="literal">http://localhost/9000</code>. Complete the sign-in step; for instance, use <span class="strong"><strong>Alice</strong></span> and <span class="strong"><strong>Bob</strong></span> as names to connect to the actor room from the two browsers, respectively.</p><p>Entering the seats that you want to book from either window will update the global number of seats left in both windows, as illustrated in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_09_06.jpg" alt="Playing with Actor Room"/></div><p>The console output from the server should display the logging information as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[info] play - Starting application default Akka system.</strong></span>
<span class="strong"><strong>[debug] application - Connected Member with ID:Alice</strong></span>
<span class="strong"><strong>[debug] application - Connected Member with ID:Bob</strong></span>
<span class="strong"><strong>… </strong></span>
<span class="strong"><strong>Received(Bob,{"booking":"flight","numberOfPersons":"5"})</strong></span>
<span class="strong"><strong>… </strong></span>
<span class="strong"><strong>Received(Alice,{"booking":"flight","numberOfPersons":"3"})</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>[info] application - Received number of seats left: 42</strong></span>
<span class="strong"><strong>[DEBUG] [02/15/2014 22:51:01.226] [application-akka.actor.default-dispatcher-7] [akka://application/user/flight] received handled message GetSeatsLeft</strong></span>
<span class="strong"><strong>[DEBUG] [02/15/2014 22:51:01.226] [application-akka.actor.default-dispatcher-6] [akka://application/user/$a/Alice-receiver] received handled message 42</strong></span>
</pre></div><p>Entering a number of seats that is greater <a id="id551" class="indexterm"/>than the number of remaining places will not update the counter, and it will end up in a <code class="literal">Fail</code> message from the <code class="literal">Flight</code> actor.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Summary</h1></div></div></div><p>In this chapter, we have experimented with the <span class="emphasis"><em>iteratees</em></span> pattern supported by the Play Framework to handle streams reactively. We have then used it along with WebSockets and Akka to write a small, reactive web application.</p><p>The samples of reactive web applications that we have addressed and discussed in this chapter are just a glimpse of the endless possibilities of making applications that react to events and are resilient to failure and load. As web applications grow in complexity, such architectures should gain in popularity and adoption rate.</p><p>Being able to asynchronously process streams in real time is, in our opinion, a big competitive advantage if this functionality is built in a manageable and maintainable way. This is precisely the goal that the Play Framework combined with Akka illustrates.</p><p>In the next and the last chapter of this book, we are going to consider a few areas where we think Scala provides additional, convenient help.</p></div></body></html>