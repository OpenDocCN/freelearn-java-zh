- en: Finalizing Java Knowledge to a Professional Level
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Java知识提升到专业水平
- en: By now, you have learned the most important areas and topics needed for a professional
    Java developer. What we still have ahead of us in this book is to discuss some
    topics that will lead you from being a junior developer to a senior developer.
    Reading this chapter will not make anyone a senior developer, though. The previous
    chapters were the roads that we walked through. This chapter is only the map.
    If each of the previous chapters covered a short walk of a few miles in the journey
    of coding to reach the harbor, then this chapter is the nautical map to discover
    a new continent.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学到了成为一名专业Java开发者所需的最重要领域和主题。在这本书中，我们接下来要讨论的一些主题将引导你从初级开发者成长为高级开发者。尽管阅读这一章不会使任何人成为高级开发者，但前几章是我们走过的路。这一章只是地图。如果前几章涵盖了在编码之旅中到达港口前的一段几英里的短途旅行，那么这一章就是探索新大陆的航海图。
- en: We will briefly bite into some very deep and high-level professional areas,
    such as creating a Java agent, compile-time annotation processing, polyglot programming,
    a bit of architecture design and tools, and techniques to work in teams. We'll
    do it just for the taste. Now, you have enough knowledge to understand the importance
    of these topics, and getting a taste will create an appetite for the coming years
    of self-development, or, at least, that is my intention to make you, the reader,
    addicted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要地涉猎一些非常深入和高级的专业领域，例如创建一个Java代理、编译时注解处理、多语言编程、一点架构设计和工具，以及团队协作的技术。我们这样做只是为了尝尝鲜。现在，你已经拥有了足够的知识来理解这些主题的重要性，而尝试这些将激发你对未来几年自我发展的渴望，至少，这是我想要让你，作为读者，上瘾的意图。
- en: Java deep technologies
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java深度技术
- en: 'In this section, we will list three technologies:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将列出三种技术：
- en: Java agent
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java代理
- en: Polyglot programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言编程
- en: Annotation processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解处理
- en: Knowing them is not a must for a Java professional. Knowing about them is. Java
    agents are used mainly in development environments and in operation. They are
    complex runtime technologies that interact with the already running *JVM*. Annotation
    processing is the other end. Annotation processors are plugged into the Java compiler.
    Polyglot programming is in the middle. It is JVM programming, just like programming
    in Java, but by using some different language or, perhaps, some different language
    and Java together. Or even many languages, such as Jython, Groovy, Clojure, and
    Java together.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java专业人士来说，了解它们不是必须的。了解它们是必须的。Java代理主要用于开发环境和运营中。它们是与已经运行的*JVM*交互的复杂运行时技术。注解处理是另一端。注解处理器被连接到Java编译器。多语言编程位于中间。它是JVM编程，就像用Java编程一样，但通过使用一些不同的语言，或者可能是某种不同的语言和Java一起。甚至可能是多种语言，例如Jython、Groovy、Clojure和Java一起。
- en: We will discuss these technologies so that we will get some idea about what
    they are and where to look for further information in case we want to learn more
    about them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论这些技术，以便我们能够了解它们是什么，以及如果我们想要了解更多关于它们的信息，我们应该在哪里寻找更多信息。
- en: Java agent
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java代理
- en: 'A Java agent is a Java program that is loaded by the Java runtime in a special
    way and can be used to interfere with the byte code of the loaded classes, altering
    them. They can be used to:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java代理是一种以特殊方式由Java运行时加载的Java程序，可以用来干扰已加载类的字节码，从而改变它们。它们可以用来：
- en: List or log, and report the loaded classes during runtime, as they are loaded
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时列出或记录，并报告加载的类，就像它们被加载时一样
- en: Modify the classes so that the methods will contain extra code to report runtime
    behavior
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改类，使方法包含额外的代码来报告运行时行为
- en: Support debuggers to alter the content of a class as the developer modifies
    the source code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持调试器在开发者修改源代码时更改类的内容
- en: This technology is used in, for example, the products **JRebel** and **XRebel**
    from [https://zeroturnaround.com/](https://zeroturnaround.com/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被用于，例如，来自[https://zeroturnaround.com/](https://zeroturnaround.com/)的**JRebel**和**XRebel**产品。
- en: Although Java agents work in the deep details of Java, they are not magic. They
    are a bit complex and you need a deep understanding of Java, but anyone who can
    program in Java can write a Java agent. All that is required is that the class,
    which is the agent, has some predefined methods packaged into a *JAR* file along
    with the other classes of the agent and has a `META-INF/MANIFEST.MF` file that
    defines the names of the classes implementing the `premain` and/or `agentmain`
    methods, and some other fields.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java代理在Java的深层细节中工作，但它们并不是魔法。它们有点复杂，你需要深入理解Java，但任何能够用Java编程的人都可以编写Java代理。所需的一切只是将代理类（即代理）打包到一个*JAR*文件中，其中包含代理的其他类，并且有一个`META-INF/MANIFEST.MF`文件，该文件定义了实现`premain`和/或`agentmain`方法的类的名称，以及一些其他字段。
- en: The detailed and precise reference documentation is part of the *JDK JavaDoc*
    available at [http://download.java.net/java/jdk9/docs/api/](http://download.java.net/java/jdk9/docs/api/)
    in the documentation of the `java.lang.instrument` package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 详细且精确的参考文档是`java.lang.instrument`包文档中可用的*JDK JavaDoc*的一部分，可在[http://download.java.net/java/jdk9/docs/api/](http://download.java.net/java/jdk9/docs/api/)找到。
- en: 'When a Java application is started with a Java agent, the command line has
    to contain the following option:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Java代理启动Java应用程序时，命令行必须包含以下选项：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `jarpath` points to the JAR file that contains the agent class and the
    manifest file. The class must have a method named `premain` or `agentmain`. It
    may have one or two arguments. The JVM tries to call the two-argument version
    first after the JVM is initialized:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`jarpath`指向包含代理类和清单文件的JAR文件。该类必须有一个名为`premain`或`agentmain`的方法。它可能有一个或两个参数。JVM在JVM初始化后尝试首先调用两个参数版本：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If a two-argument version does not exist, then the one-argument version is
    used, which is essentially the same as the two-argument version but misses the
    instrumentation argument, which, in my opinion, does not make too much sense since
    a Java agent cannot do much without the `Instrumentation` object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在两个参数版本，则使用一个参数版本，它本质上与两个参数版本相同，但缺少了仪器参数，在我看来，这并不太有意义，因为Java代理没有`Instrumentation`对象就无法做很多事情：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `agentArgs` parameter is the string passed as an option on the command line.
    The second argument, `Instrumentation`, provides methods to register class transformers
    that can modify class byte codes and also methods that can ask the JVM to perform
    redefinition or retransformation of classes during runtime.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`agentArgs`参数是作为命令行选项传递的字符串。第二个参数`Instrumentation`提供了注册类转换器的方法，这些转换器可以修改类字节码，以及可以请求JVM在运行时重新定义或重新转换类的方法。'
- en: Java applications can also load an agent after the program has already started.
    In such a case, the agent cannot be invoked before the main method of the Java
    application, since it has already started by that time. To separate the two cases,
    JVM calls `agentmain` in such a scenario. Note that either `premain` or `agentmain`
    is invoked for an agent and never both. A single agent can implement both so that
    it is capable of performing its task loaded at the startup, specified on the command
    line or after the JVM started.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序也可以在程序启动后加载代理。在这种情况下，由于程序已经启动，代理不能在Java应用程序的主方法之前被调用。为了区分这两种情况，JVM在这种情况下调用`agentmain`。请注意，对于代理来说，要么调用`premain`，要么调用`agentmain`，永远不会同时调用。单个代理可以实现两者，使其能够在启动时执行其任务，指定在命令行上或在JVM启动后。
- en: If `agentmain` is used, it has the same arguments as `premain`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`agentmain`，它具有与`premain`相同的参数。
- en: There is one major and important difference between the invocation of `premain`
    and `agentmain`. If an agent cannot be loaded during startup, for example, if
    it cannot be found, if the JAR file does not exist, if the class does not have
    the `premain` method, or if it throws an exception, the JVM will abort. If the
    agent is loaded after the *JVM* is started (in this case, `agentmain` is to be
    used), the JVM will not abort if there is some error in the agent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`premain`和`agentmain`的调用之间存在一个主要且重要的区别。如果代理在启动期间无法加载，例如，如果找不到它，如果JAR文件不存在，如果类没有`premain`方法，或者如果它抛出异常，JVM将终止。如果代理在JVM启动后加载（在这种情况下，应使用`agentmain`），即使代理中存在某些错误，JVM也不会终止。'
- en: This approach is fairly reasonable. Imagine that there is a server application
    that runs on the Tomcat servlet container. When a new version is started, the
    system is down for a maintenance period. If the new version cannot be started
    because the agent is not behaving well, then it is better not started. The damage
    to debug the situation and fix it, or roll back the application to the old version
    and call for a longer fixing session may be less than starting up the application
    and not having the proper agent functionality. If the application starts up only
    without the agent, then the suboptimal operation may not immediately be recognized.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当合理。想象一下，有一个在 Tomcat 服务器容器上运行的服务器应用程序。当启动新版本时，系统会停机进行维护。如果由于代理表现不佳而无法启动新版本，那么最好不启动。调试这种情况并修复它，或者将应用程序回滚到旧版本并请求更长时间的修复会话可能比启动应用程序而没有适当的代理功能造成的损害要小。如果应用程序仅在没有代理的情况下启动，那么次优操作可能不会立即被识别。
- en: On the other hand, when an agent is attached later, the application is already
    running. An agent is attached to an already running application to get information
    from an already running instance. To stop the already running instance and fail
    it, especially in an operational environment, is more damaging than just not attaching
    the agent. It may not go unnoticed anyway because the agent that is most probably
    attached is used by operational personnel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当代理稍后附加时，应用程序已经正在运行。将代理附加到已运行的应用程序是为了从已运行的实例中获取信息。停止已运行的实例并使其失败，特别是在操作环境中，比仅仅不附加代理更有害。无论如何，这可能会被注意到，因为最有可能附加的代理可能被操作人员使用。
- en: 'A `premain` or `agentmain` agent gets an `Instrumentation` object as the second
    argument. This object implements several methods. One of them is:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`premain` 或 `agentmain` 代理获取一个 `Instrumentation` 对象作为第二个参数。此对象实现了几个方法。其中之一是：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The agent implements the transformer, and it has the `transform` method signature:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代理实现了转换器，并具有 `transform` 方法签名：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method is called by the JVM when a class is loaded or when it is to be
    transformed. The method gets the class object itself, but, more importantly, it
    gets the byte array containing the byte code of the class. The method is expected
    to return the byte code of the transformed class. Modifying the byte code needs
    some knowledge of how the byte code is built and what the structure of a class
    file is. There are libraries that help to do that, such as Javassist ([http://www.javassist.org/](http://www.javassist.org/)
    ) or ASM ([http://asm.ow2.org/](http://asm.ow2.org/)). Nevertheless, I will not
    start coding before getting acquainted with the structure of the byte code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JVM 在类加载时或要转换时调用此方法。该方法获取类对象本身，但更重要的是，它获取包含类字节码的字节数组。该方法预期返回转换后的类的字节码。修改字节码需要对字节码的构建方式和类文件的结构有所了解。有一些库可以帮助完成这项工作，例如
    Javassist ([http://www.javassist.org/](http://www.javassist.org/)) 或 ASM ([http://asm.ow2.org/](http://asm.ow2.org/))。尽管如此，我将在熟悉字节码结构之前不会开始编码。
- en: 'Agents, running in a separate thread and presumably interacting with the user
    or the filesystem and based upon some external observation at any time, may call
    the following method to perform the retransformation of the classes using the
    registered transformers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代理在单独的线程中运行，并假设在任何时候都与用户或文件系统交互，基于某些外部观察，可以调用以下方法来使用已注册的转换器重新转换类：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The agent can also call the following method, which will redefine the classes
    given as arguments:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代理还可以调用以下方法，这将重新定义作为参数给出的类：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ClassDefinition` class is simply a `Class` and a `byte[]` pair. This will
    redefine the classes through the class maintaining mechanism of the JVM.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassDefinition` 类只是一个 `Class` 和 `byte[]` 对的简单组合。这将通过 JVM 的类维护机制重新定义类。'
- en: Note that these methods and Java agents interact with the deep, low-level part
    of the JVM. This also bears the consequence that it is very easy to destroy the
    whole JVM. The byte code is not checked, unlike during the loading of the class,
    and thus, if there is some error in it, the consequence may not only be an exception
    but also the crashing of the JVM. Also, the redefinition and the transformations
    should not alter the structure of the classes. They should not change their inheritance
    footprint, add, rename, or remove methods, or change the signature of the methods,
    and this is also true for fields.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法和 Java 代理与 JVM 的深层、低级部分交互。这也意味着，很容易破坏整个 JVM。与类加载时的字节码检查不同，字节码不会被检查，因此，如果其中存在错误，后果可能不仅是一个异常，还可能是
    JVM 的崩溃。此外，重新定义和转换不应改变类的结构。它们不应改变它们的继承足迹，添加、重命名或删除方法，或更改方法的签名，这也适用于字段。
- en: Also note that the already created objects will not be affected by the changes;
    they will still use the old definition of the class and only new instances will
    be affected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，已经创建的对象不会受到更改的影响；它们仍然使用类的旧定义，只有新的实例才会受到影响。
- en: Polyglot programming
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言编程
- en: Polyglot programming is the technique when there are different programming languages
    used in the same application. Such an approach is not only appropriate when a
    different part of the application runs on a different environment. For example,
    the client executes in the browser using JavaScript, CSS, and HTML while the server
    is programmed to run in a Tomcat environment in Java. This is a different story,
    and, usually, this is not the typical use when someone is speaking about polyglot
    programming.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言编程是在同一应用程序中使用不同编程语言的技术。这种做法不仅适用于应用程序的不同部分运行在不同的环境中。例如，客户端在浏览器中使用 JavaScript、CSS
    和 HTML 执行，而服务器是用 Java 编程以在 Tomcat 环境中运行。这是一个不同的情况，通常，当人们谈论多语言编程时，这并不是典型的用法。
- en: When the application that runs on the server partially runs in Java and also
    in some other language, then we can speak about polyglot programming. For example,
    we create the order handling application in Java and some of the code that checks
    the correctness of the order based on the product-specific codes that the order
    contains is written in JavaScript. Does it ring a bell? We have already done that
    in this book to demonstrate the scripting API of the JDK. That was real polyglot
    programing even if we did not mention it that way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行在服务器上的应用程序部分运行在 Java 中，同时也运行在某些其他语言中时，我们就可以谈论多语言编程。例如，我们用 Java 创建订单处理应用程序，而检查订单正确性的某些代码（基于订单包含的产品特定代码）是用
    JavaScript 编写的。这让你想起什么了吗？我们已经在本书中这样做来演示 JDK 的脚本 API。即使我们没有那样说，那也是一个真正的多语言程序。
- en: The JVM that runs the compiled Java code is a very good target for different
    language compilers, and thus, there are many languages that compile for it. When
    the JVM runs the byte code of a class, it does not know what the source language
    was, and it does not really care; some compiler created the byte code and it just
    executes that.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行编译后的 Java 代码的 JVM 是不同语言编译器的良好目标，因此，有许多语言可以为其编译。当 JVM 运行一个类的字节码时，它不知道源语言是什么，它并不真正关心；某个编译器创建了字节码，它只是执行它。
- en: We can use different languages, such as Jython, Groovy, and Scala, to name a
    few popular ones that compile for the JVM. We can write one class using one language
    and the other one using another. When they are put together into a JAR, WAR, or
    an EAR file, the runtime system will just run them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的语言，例如 Jython、Groovy 和 Scala，仅举几个编译为 JVM 的流行语言。我们可以使用一种语言编写一个类，而使用另一种语言编写另一个类。当它们被组合成
    JAR、WAR 或 EAR 文件时，运行时系统将直接运行它们。
- en: When do we use polyglot programming?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在什么情况下使用多语言编程？
- en: Polyglot configuration
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言配置
- en: Usually, we turn towards polyglot programming when we want to create an application
    that is more flexible and more configurable. Applications that get installed in
    many instances, usually, at different customer sites have some configurations.
    These configurations can be XML files, properties files, and INI files (those
    come from Windows). As the programs develop sooner or later, these static configuration
    possibilities reach their limits. Application developers soon see that they need
    to configure some functionality that is cumbersome to describe using these technologies.
    Configuration files start being larger and, also, the code that reads and interprets
    the configuration files grow large. Good developers have to realize that this
    is the situation, and before the configuration files and the code handling them
    become unmanageable, some scripting configuration, polyglot programming has to
    be implemented.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们想要创建一个更加灵活和可配置的应用程序时，我们会转向多语言编程。通常，这些被安装在多个实例中的应用程序，通常在不同的客户站点，都有一些配置。这些配置可以是XML文件、属性文件和INI文件（这些来自Windows）。随着程序的不断发展，这些静态配置的可能性最终会达到极限。应用程序开发者很快就会意识到，他们需要配置一些使用这些技术难以描述的功能。配置文件开始变得越来越大，同时，读取和解释配置文件的代码也变得庞大。优秀的开发者必须意识到这种情况，并且在配置文件和它们所处理的代码变得难以管理之前，必须实施一些脚本配置和多语言编程。
- en: '![](img/00064.gif)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00064.gif)'
- en: Decent developer teams may reach a point when they develop their configuration
    language and the interpreter of that language. It can be based on XML, or it can
    just be any other language. After all, writing a language is fun; I have done
    it a few times myself. Most of these were, however, hobbies and not professional
    projects. Usually, there is no customer value in crafting another language. We
    can better use an existing one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的开发者团队可能会达到一个阶段，即他们开发自己的配置语言和该语言的解释器。它可以基于XML，也可以是任何其他语言。毕竟，编写一种语言很有趣；我自己也做过几次。然而，这些大多数都是爱好，而不是专业项目。通常，创造另一种语言并没有客户价值。我们最好使用现有的语言。
- en: In the case of configuration, Groovy is a very handy language that supports
    complex closure and meta-class syntax and implementation. This way, the language
    is extremely suitable to create a domain-specific language. Since Groovy is compiled
    to JVM, Groovy classes can be invoked directly from Java, and in the other way
    round, reading the configuration is essentially invoking the class compiled from
    the configuration file. The compilation can be during application build time,
    but in the case of configuration, it makes more sense to do it during application
    startup. We have already seen that the Groovy implementation of the scripting
    API or the special API that Groovy provides is absolutely capable of doing that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置的情况下，Groovy是一种非常实用的语言，它支持复杂的闭包和元类语法和实现。这样，这种语言非常适合创建领域特定语言。由于Groovy编译到JVM，Groovy类可以直接从Java调用，反之亦然，读取配置本质上就是调用从配置文件编译的类。编译可以在应用程序构建时进行，但在配置的情况下，在应用程序启动时进行更有意义。我们已经看到，Groovy脚本API的实现或Groovy提供的特殊API完全能够做到这一点。
- en: Have we seen examples of this in our book? It may be a surprise to you, but
    we have in fact used Groovy to describe some configuration many times. *Gradle*
    build files are nothing more than Groovy DSL developed mainly in Groovy to support
    project build configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中看到过这样的例子吗？这可能对你来说是个惊喜，但事实上，我们已经多次使用Groovy来描述一些配置。*Gradle*构建文件不过是主要用Groovy开发的Groovy
    DSL，用于支持项目构建配置。
- en: Polyglot scripting
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言脚本
- en: Configuration is not the only application of polyglot programming. Configuration
    is executed at the program startup and the configuration data is used as static
    data afterwards. We can execute scripts during the application's execution any
    time and not only during its startup. This can be used to provide extra functionality
    to the program's user with installations that use the same application but are
    furnished with different scripts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 配置并不是多语言编程的唯一应用。配置在程序启动时执行，配置数据随后用作静态数据。我们可以在应用程序执行过程中任何时间执行脚本，而不仅仅是启动时。这可以用来为使用相同应用程序但配备了不同脚本的安装提供额外的功能。
- en: One of the first applications that provided such scripting capability was the
    emacs editor. The core of the application was written in C language and it contained
    a Lisp interpreter that let the user to write scripts, which were executed in
    the editor environment. The engineering program, AutoCAD, also used a Lisp interpreter
    for similar purposes. Why was Lisp used for this purpose?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提供这种脚本能力的第一个应用之一是 emacs 编辑器。该应用程序的核心是用 C 语言编写的，并包含一个 Lisp 解释器，允许用户编写脚本，这些脚本在编辑器环境中执行。工程程序
    AutoCAD 也为了类似的目的使用了 Lisp 解释器。为什么 Lisp 被用于这个目的？
- en: Lisp has very simple syntax, and therefore, it is easy to parse Lisp code. At
    the same time, the language is powerful, and last but not least, there were open
    source Lisp interpreters (at least one) available by the time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 的语法非常简单，因此解析 Lisp 代码很容易。同时，这种语言功能强大，而且最重要的是，在那时已经有了开源的 Lisp 解释器（至少有一个）。
- en: To get this kind of flexibility, applications, many times, provide plugin APIs,
    which a developer can use to extend the application. This, however, requires that
    the developer sets up coding tools, including IDE, build tool, continuous integration,
    and so on, that is, a professional programming environment. When the task to be
    solved by the plugin is simple, the overhead is simply too large. In such a case,
    a scripting solution is handier.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这种灵活性，应用程序通常会提供插件 API，开发者可以使用它来扩展应用程序。然而，这要求开发者设置编码工具，包括 IDE、构建工具、持续集成等，即一个专业的编程环境。当插件要解决的问题很简单时，这种开销就太大了。在这种情况下，脚本解决方案会更加方便。
- en: Scripting is not a solution for everything. When the scripts extending the application
    tend to become too complex, it means that the scripting possibility is just too
    much. It is difficult, however, to take back a toy from a child. If users get
    used to the scripting possibility, then they will not take it easy if the next
    version of the application we release does not provide that possibility. Thus,
    it is extremely important to assess the possible use of the scripting capability
    in our application. Scripting and, more generally, any feature of our program
    will not be used for what we intended them for. They will be used for whatever
    it is possible to use them for. Users can go beyond all imagination when it comes
    to abusing some feature. It may be a good idea to think about limiting the scripting
    possibility beforehand, limiting the running time of the scripts or the size of
    the script our program agrees to work with. If these limitations are set reasonably,
    and the users understand and accept these, a plugin structure in addition to the
    scripting capability has to be considered.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本并不是解决所有问题的方案。当扩展应用程序的脚本变得过于复杂时，这意味着脚本的可能性太多了。然而，要从一个孩子的玩具中拿回玩具是困难的。如果用户习惯了脚本的可能性，那么当我们的下一个版本的应用程序不提供这种可能性时，他们可能不会轻易接受。因此，评估我们应用程序中脚本能力的潜在用途非常重要。脚本以及我们程序的任何功能都不会被用于我们原本打算它们被用的目的。它们将被用于它们可能被用于的任何目的。当涉及到滥用某些功能时，用户可以超越所有想象。事先考虑限制脚本的可能性可能是一个好主意，限制脚本的运行时间或我们程序同意处理的脚本大小。如果这些限制设置得合理，并且用户理解和接受这些限制，那么除了脚本能力之外，还需要考虑插件结构。
- en: The security of an application, including plugin or scripting extension, is
    also very important. The scripts or plugins run on the same JVM as the core application.
    Some scripting languages provide some fence around the scripts that limits the
    access to the core application's objects and classes, but this is an exception.
    Usually, scripts run with the same privilege as the core application and that
    way they can do just anything. Thus, scripts should be trusted the same way as
    the core application. Script installation or modification should never be possible
    for an unprivileged user of the application. Such an action is almost always reserved
    for the system administrator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的安全性，包括插件或脚本扩展，也非常重要。脚本或插件在核心应用程序相同的 JVM 上运行。一些脚本语言为脚本提供了一些围栏，限制了它们对核心应用程序的对象和类的访问，但这只是一个例外。通常，脚本与核心应用程序具有相同的权限，因此它们可以做任何事情。因此，脚本应该像核心应用程序一样被信任。应用程序的无权限用户不应可能安装或修改脚本。这种操作几乎总是留给系统管理员。
- en: If an unprivileged user can upload a script to the server and then have it executed,
    we just opened a security hole in our application. Since access restrictions are
    enforced by the application, it is easy to override these limitations using an
    uncontrolled script. The hacker can just access other users' data easily, which
    he is not entitled to, and read and modify our database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个无权限的用户可以将脚本上传到服务器并执行它，那么我们就在我们的应用程序中打开了一个安全漏洞。由于访问限制是由应用程序实施的，因此很容易使用不受控制的脚本覆盖这些限制。黑客可以轻易地访问他无权访问的其他用户的数据，并读取和修改我们的数据库。
- en: Business DSL
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务DSL
- en: Polyglot programming may also come into the picture when the application's code
    can be separated into business code and technology code. The business code contains
    the top-level business logic that we actually write the application for, and this
    is the code that contains the logic that the customer pays for. The technology
    code is to support the algorithms coded in the business DSL.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的代码可以被分为业务代码和技术代码时，多语言编程也可能成为问题。业务代码包含我们实际编写应用程序的顶层业务逻辑，这是客户支付逻辑的代码。技术代码是为了支持在业务DSL中编写的算法。
- en: Most of the enterprise applications contain these two types of code but many
    do not separate them. This leads to a monolithic application that contains repetitive
    code. When you feel that you are writing the same type of code when you need persistence
    or networking, and again the same type of code while coding some business rules,
    then this is the code smell that suggests that the two code types are not separated.
    DSL and scripting are not a magic wand and do not solve all the problems that
    stem from a wrong application structure. In such a situation, the code has to
    be refactored first to separate the business logic and the infrastructure code,
    and it is only the second step to implement a DSL and a business API supporting
    it and to rewrite the business code into the DSL. Every step of such a project
    delivers value for the application and even if it never gets to DSL and scripting,
    the effort invested is not wasted.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数企业应用程序包含这两种类型的代码，但许多没有将它们分开。这导致了一个包含重复代码的单一应用程序。当你感觉到在需要持久性或网络时需要编写相同类型的代码，而在编写一些业务规则时又需要编写相同类型的代码，那么这就是表明这两种代码类型没有分开的代码异味。领域特定语言（DSL）和脚本并不是一个魔杖，并不能解决所有源于错误的应用程序结构的问题。在这种情况下，首先必须重构代码以分离业务逻辑和基础设施代码，然后才是实施支持它的DSL和业务API，并将业务代码重写为DSL。这样的项目的每一步都对应用程序产生价值，即使它永远达不到DSL和脚本，所投入的努力也不会白费。
- en: The business DSL scripting is very similar to pluggable scripts, except that
    this time it is not the application that calls the scripts from time to time to
    execute some special extension functionality. Instead, the DSL code calls the
    application through the business API that it provides. The advantage of providing
    the API and using a DSL is that the code that implements the business logic gets
    rid of the technical details, can be very abstract, and, this way, be much closer
    to a business-level description of the problem rather than just program code.
    Even some businessperson can understand a business DSL, and though it is not a
    goal in real-life examples, they could even write code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 业务DSL脚本与可插拔脚本非常相似，但这次不是应用程序时不时地调用脚本以执行一些特殊扩展功能。相反，DSL代码通过它提供的业务API调用应用程序。提供API和使用DSL的优势在于，实现业务逻辑的代码摆脱了技术细节，可以非常抽象，并且这样就可以更接近问题的业务级描述，而不是仅仅的程序代码。甚至一些业务人员也能理解业务DSL，尽管在现实生活中的例子中这不是一个目标，他们甚至可以编写代码。
- en: At TU Vienna, we also used a similar approach to make semiconductor simulation
    more usable for the semiconductor design engineer. The core calculating code was
    written in Fortran. A C language framework that handled the massive simulation
    data input and output and that embedded the XLISP interpreter executed these programs.
    The Lisp code contained the simulation configuration data and could also contain
    simple loops when the simulation was to be executed for many configuration points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在维也纳科技大学，我们也采用了类似的方法，使半导体模拟对半导体设计工程师更加可用。核心计算代码是用Fortran编写的。一个处理大量模拟数据输入和输出并嵌入XLISP解释器的C语言框架执行了这些程序。Lisp代码包含模拟配置数据，当模拟需要针对许多配置点执行时，也可以包含简单的循环。
- en: It was polyglot programming, except that we did not know that this is going
    to be the name years after this application coding style.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种多语言编程，只是我们不知道在几年后的应用程序编码风格中，这个名字将会是什么。
- en: Problems with polyglot
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言编程的问题
- en: Polyglot programming is not only all about advantages. Before jumping into this
    direction, developers making the decision have to consider a lot of things.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言编程不仅仅是关于优势。在跳入这个方向之前，做出决定的开发者必须考虑很多因素。
- en: Using another language for the application needs knowledge. Finding people who
    can code in the languages that are used is eventually more difficult than finding
    developers who only know Java. (This is also true if the kernel application language
    is not Java.) Different languages require different mindsets and, many times,
    different people. The team should also have some members who are proficient in
    both languages, and it is also an advantage if most of the people know at least
    a bit about the other language.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一种语言进行应用程序开发需要知识。找到能够使用这些语言的程序员最终比找到只懂Java的开发者更困难。（如果核心应用程序语言不是Java，这也同样适用。）不同的语言需要不同的思维方式，很多时候，不同的人。团队也应该有一些精通两种语言的成员，如果大多数人至少对另一种语言有一些了解，这也是一个优势。
- en: The toolset supporting Java is outstanding. The build tools, integrated development
    environment, libraries, debugging possibilities, and logging frameworks, to name
    a few, are all extremely good compared with other languages. Polyglot development
    needs support for the other language as well, which may not be as advanced as
    the support for Java. Many times, it is really an issue to debug DSL solutions
    and IDE support may also be lagging.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Java的工具集非常出色。构建工具、集成开发环境、库、调试可能性以及日志框架等，与其他语言相比都非常好。多语言开发还需要支持其他语言，这可能不如Java的支持先进。很多时候，调试DSL解决方案真的是一个问题，IDE支持也可能落后。
- en: When we program in Java, many times, we take for granted that the IDE reads
    the meta-data of the libraries and whenever we need to call a method, or reference
    a class, the IDE suggests the best possibility. XML and properties files may also
    be supported and the IDE may know some of the most used frameworks, such as *Spring*,
    and understand the XML configuration handling the names of the classes as hyperlinks,
    even when the class names are inside some attribute strings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用Java编程时，很多时候，我们都会想当然地认为IDE读取库的元数据，无论何时我们需要调用一个方法或引用一个类，IDE都会建议最佳的可能性。XML和属性文件也可能得到支持，IDE可能知道一些最常用的框架，如*Spring*，并理解处理类名的XML配置，即使类名位于某些属性字符串中。
- en: This is far from being this easy in the case of other languages. For the languages
    that have a wide user base, the tooling support may be good, but if you pick some
    exotic language, you are on your own. The more exotic the language the less support
    you may have.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言的情况下，这远非如此简单。对于拥有广泛用户基础的语言，工具支持可能很好，但如果你选择了一些异国情调的语言，你就得自己解决了。语言越异国情调，你可能拥有的支持就越少。
- en: You can create some tool to support your DSL that you develop. It is not hard
    to do so using tools such as [http://www.eclipse.org/Xtext/](http://www.eclipse.org/Xtext/).
    In such a case, you are tied to *Eclipse*, which may or may not be a problem.
    You can pick a special language, for example, *Kotlin*, which is extensively supported
    by *IntelliJ*, because the same company supports the language and the IDE, but
    again, you buy into a special technology that can be expensive to replace in case
    you have to. It is generally true not only for languages but also for any technology
    you include into your development. When you select one, you should consider the
    support and the cost of getting off the horse if or when it starts dying.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一些工具来支持你开发的领域特定语言（DSL）。使用像[http://www.eclipse.org/Xtext/](http://www.eclipse.org/Xtext/)这样的工具来做这件事并不难。在这种情况下，你可能会被绑定到*Eclipse*，这可能会或可能不会成为一个问题。你可以选择一种特殊的语言，例如*Kotlin*，它被*IntelliJ*广泛支持，因为同一家公司支持该语言和IDE，但再次，你购买了一种可能在你需要更换时昂贵的特殊技术。这不仅仅适用于语言，也适用于你包含到你的开发中的任何技术。当你选择一种时，你应该考虑支持和退出该技术的成本，如果或当它开始衰落时。
- en: Annotation processing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解处理
- en: 'We have already discussed annotations in great detail. You may recall that
    we defined our annotation interfaces using the following annotation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细讨论了注解。你可能还记得，我们使用以下注解定义了我们的注解接口：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This told the Java compiler to keep the annotation and put it into the JVM
    code so that the code can access it during runtime using reflection. The default
    value is `RetentionPolicy.CLASS`, which means that the annotation gets into the
    byte code, but the JVM does not make it available for the runtime system. If we
    use `RetentionPolicy.SOURCE`, the annotation does not even get into the class
    file. In this case, there is only one possibility to do anything with the annotation:
    compile time.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Java编译器保留注解并将其放入JVM代码中，以便代码在运行时可以通过反射访问它。默认值是`RetentionPolicy.CLASS`，这意味着注解会进入字节码，但JVM不会将其提供给运行时系统。如果我们使用`RetentionPolicy.SOURCE`，注解甚至不会进入类文件。在这种情况下，唯一能够对注解做任何事情的可能性就是编译时。
- en: How can we write code that runs during compile time? Java supports the notion
    of annotation processors. If there is a class on the classpath of the compiler
    that implements the `javax.annotation.processing.Processor` interface, then the
    compiler will invoke the implemented methods one or more times, passing information
    about the source file that the compiler is actually processing. The methods will
    be able to access the compiled methods, classes, or whatever is annotated, and
    also the annotation that triggered the processor invocation. It is important,
    however, that this access is not the same as in runtime. What the annotation processor
    accesses is neither a compiled nor a loaded class, that is, it is available when
    the code uses reflection. The source file at this time is under compilation; thus,
    the data structures that describe the code are actually structures of the compiler,
    as we will see in our next example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写在编译时运行的代码？Java支持注解处理器的概念。如果编译器的类路径上有一个实现了`javax.annotation.processing.Processor`接口的类，那么编译器将调用实现的方法一次或多次，传递编译器实际处理的源文件的信息。这些方法将能够访问编译的方法、类或任何被注解的内容，以及触发处理器调用的注解。然而，重要的是，这种访问与运行时不同。注解处理器访问的既不是编译的也不是加载的类，也就是说，当代码使用反射时它是可用的。此时，源文件正在编译中；因此，描述代码的数据结构实际上是编译器的结构，正如我们将在下一个示例中看到的那样。
- en: The annotation processor is called one or more times. The reason it is invoked
    many times is that the compiler makes it possible for the annotation processors
    to generate source code based on what it sees in the partially compiled source
    code. If the annotation processor generates any Java source file, the compiler
    has to compile the new source code and perhaps compile some of the already compiled
    files again. This new compilation phase needs annotation processor support until
    there are no more rounds to execute.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注解处理器被调用一次或多次。它被多次调用的原因是因为编译器使得注解处理器能够根据其在部分编译的源代码中看到的内容生成源代码。如果注解处理器生成了任何Java源文件，编译器就必须编译新的源代码，也许还需要重新编译一些已经编译过的文件。这个新的编译阶段需要注解处理器的支持，直到没有更多的执行轮次。
- en: Annotation processors are executed one after the other, and they work on the
    same set of source files. There is no way to specify the order of the annotation
    processor executions; thus, two processors working together should perform their
    tasks, no matter in what order they are invoked. Also, note that these codes run
    inside the compiler. If an annotation processor throws an exception, then the
    compilation process will most probably fail. Thus, throwing an exception out of
    the annotation processor should only be done if there is an error that cannot
    be recovered and the annotation processor decides that the compilation after that
    error cannot be complete.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注解处理器一个接一个地执行，并且它们在相同的源文件集上工作。无法指定注解处理器执行的顺序；因此，两个一起工作的处理器应该按照它们被调用的顺序执行任务。此外，请注意，这些代码是在编译器内部运行的。如果一个注解处理器抛出异常，那么编译过程很可能会失败。因此，只有在有无法恢复的错误并且注解处理器决定在该错误之后的编译无法完成时，才应该在注解处理器中抛出异常。
- en: 'When the compiler gets to the phase to execute the annotation processors, it
    looks at the classes that implement the `javax.annotation.processing.Processor`
    interface and creates instances of these classes. These classes have to have a
    public no-argument constructor. To streamline the execution of the processors
    and to invoke a processor only for the annotations that it can handle, the interface
    contains two methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器到达执行注解处理器的阶段时，它会查看实现`javax.annotation.processing.Processor`接口的类，并创建这些类的实例。这些类必须有一个公共的无参数构造函数。为了简化处理器的执行，并且只为处理器可以处理的注解调用处理器，该接口包含两个方法：
- en: '`getSupportedSourceVersion` to return the latest version the annotation processor
    can support'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSupportedSourceVersion`以返回注解处理器可以支持的最新版本'
- en: '`getSupportedAnnotationTypes` to return a set of `String` objects containing
    the fully qualified class name of the annotations that this processor can handle'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSupportedAnnotationTypes`以返回一个包含此处理器可以处理的注解的完全限定类名的`String`对象集合'
- en: If an annotation processor was created for Java 1.8, it may work with Java 9,
    but it may also not work. If it declares that the latest supported version is
    1.8, then the compiler in a Java 9 environment will not invoke it. It is better
    not to invoke an annotation processor than calling it and messing up the compilation
    process, which may even create compiled but erroneous code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为Java 1.8创建了一个注解处理器，它可能与Java 9一起工作，但也可能不工作。如果它声明最新支持版本是1.8，那么Java 9环境中的编译器将不会调用它。最好不调用注解处理器，而不是调用它并搞乱编译过程，这甚至可能创建编译但错误的代码。
- en: The values returned by these methods are fairly constant for an annotation processor.
    An annotation processor will return the same source version it can handle and
    will return the same set of annotations. Therefore, it would be clever to have
    some way to define these values in the source code in a declarative manner.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回的值对于注解处理器来说是相当恒定的。注解处理器将返回它可以处理的相同源版本，并将返回相同的注解集合。因此，在源代码中以声明方式定义这些值将是明智的。
- en: It can be done when we extend the `javax.annotation.processing.AbstractProcessor`
    class instead of directly implementing the `Processor` interface. This abstract
    class implements these methods. Both of them get the information from the annotation
    so that we can decorate the class that extends the abstract class. For example,
    the `getSupportedAnnotationTypes` method looks at the `SupportedAnnotationTypes` annotation
    and returns an array of annotation type strings that are listed in the annotation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过扩展`javax.annotation.processing.AbstractProcessor`类而不是直接实现`Processor`接口来完成。这个抽象类实现了这些方法。它们都从注解中获取信息，以便我们可以装饰扩展抽象类的类。例如，`getSupportedAnnotationTypes`方法查看`SupportedAnnotationTypes`注解，并返回一个包含在注解中列出的注解类型字符串的数组。
- en: 'Now, this is a bit brain twisting and can also be confusing at first. We are
    executing our annotation processor during compile time. But the compiler itself
    is a Java application, and in this way, the time is runtime for the code that
    runs inside the compiler. The code of `AbstractProcessor` accesses the `SupportedAnnotationTypes`
    annotation as a runtime annotation using reflection methods. There is no magic
    in it. The method in the JDK 9 is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这一点有点让人费解，一开始也可能令人困惑。我们是在编译时执行注解处理器。但编译器本身是一个Java应用程序，以这种方式，编译器内部运行的代码的时间是运行时。`AbstractProcessor`的代码使用反射方法将`SupportedAnnotationTypes`注解作为运行时注解访问。这里没有魔法。JDK
    9中的方法是这样的：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (The code has been edited for brevity.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: （代码已被编辑以缩短篇幅。）
- en: 'To have an example, we will sort of look at the code of a polyglot annotation
    processor. Our very simple annotation processor will process one simple annotation:
    `com.javax0.scriapt.CompileScript`, which can specify a script file. The annotation
    processor will load the script file and execute it using the scripting interface
    of Java 9.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例，我们将大致查看一个多语言注解处理器的代码。我们非常简单的注解处理器将处理一个简单的注解：`com.javax0.scriapt.CompileScript`，它可以指定一个脚本文件。注解处理器将加载脚本文件并使用Java
    9的脚本接口执行它。
- en: This code was developed as a demonstration code by the author of this book a
    few years ago and is available with the Apache license from GitHub. Thus, the
    package of the classes is retained.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是由本书作者几年前开发的一个演示代码，并且可以从GitHub上以Apache许可证获取。因此，类的包保持不变。
- en: 'The annotation processor contains two code files. One of the annotation itself
    that the processor will work on:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注解处理器包含两个代码文件。一个是处理器将要工作的注解本身：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, this annotation will not get into the class file after compilation;
    thus, there will be no trace during runtime so that any class source may occasionally
    use this annotation. `Target` of the annotation is `ElementType.TYPE`, meaning
    that this annotation can only be applied to those Java 9 language constructs that
    are some kind of types: `class`, `interface`, and `enum`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个注解在编译后不会进入类文件；因此，在运行时不会有任何痕迹，这样任何类源代码都可能偶尔使用这个注解。注解的`Target`是`ElementType.TYPE`，这意味着这个注解只能应用于那些Java
    9语言结构中的一些类型：`class`、`interface`和`enum`。
- en: The annotation has two parameters. The value should specify the name of the
    script file, and the engine may optionally define the type of the script that
    is in that file. The implementation we'll create will try to identify the type
    of the script from the filename extension, but if somebody would like to bury
    some Groovy code into a file that has the `.jy` extension (which is usually for
    Jython), so be it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注解有两个参数。值应指定脚本文件名，引擎可以可选地定义该文件中脚本的类型。我们将创建的实现将尝试从文件名扩展名中识别脚本类型，但如果有人想在具有`.jy`扩展名的文件（通常用于Jython）中隐藏一些Groovy代码，那也行。
- en: 'The processor extends `AbstractProcessor` and, in this way, some of the methods
    are inherited at the expense of some annotations used in the class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器扩展了`AbstractProcessor`，因此，以牺牲一些类中使用的注解为代价，继承了一些方法：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is no need to implement the `getSupportedAnnotationTypes` and `getSupportedSourceVersion`
    methods. These are replaced by the use of the annotations on the class. We support
    only one annotation in this processor, the one that we defined in the previously
    listed source file, and we are prepared to manage the source code up to Java version
    9\. The only method we have to override is `process`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要实现`getSupportedAnnotationTypes`和`getSupportedSourceVersion`方法。这些方法被类上的注解所取代。在这个处理器中，我们只支持一个注解，即我们在之前列出的源文件中定义的注解，并且我们准备管理到Java版本9的源代码。我们唯一需要重写的方法是`process`：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The actual annotation is not available during compile time as we already mentioned.
    Hence, what we have available is only a compile time mirror image of the annotation.
    It has the `AnnotationMirror` type, which can be used to get the actual type of
    the annotation and, also, the values of the annotation. The type of the annotation
    is available during compile time. The compiler needs it; otherwise, it could not
    compile the annotation. The values are available from the annotation itself. Our
    `processAnnotation` method handles each annotation it gets as an argument:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，实际的注解在编译时是不可用的。因此，我们所能得到的是注解的编译时镜像。它具有`AnnotationMirror`类型，可以用来获取注解的实际类型以及注解的值。注解的类型在编译时是可用的。编译器需要它；否则，它无法编译注解。值可以从注解本身获得。我们的`processAnnotation`方法处理它作为参数接收到的每个注解：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `@CompileScript` annotation defines two parameters. The first value is
    the script filename and the second one is the scripting engine name. If the second
    one is not specified, then an empty string is set as the default value. The `execute`
    method is called for each and every occasion of the annotation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`@CompileScript`注解定义了两个参数。第一个值是脚本文件名，第二个值是脚本引擎名。如果第二个值没有指定，则将空字符串设置为默认值。对于注解的每个实例，都会调用`execute`方法：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The method tries to load the script, based on the filename, and tries to instantiate
    the script engine, based on the given name. If there is no name given, then the
    filename extension is used to identify the scripting engine. By default, the JavaScript
    engine is on the classpath as it is part of the JDK. If any other JVM-based scripting
    engine is in use, then it has to be made available on the classpath or on the
    module path.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法尝试根据文件名加载脚本，并根据给定的名称尝试实例化脚本引擎。如果没有给出名称，则使用文件名扩展名来识别脚本引擎。默认情况下，JavaScript引擎在类路径上，因为它是JDK的一部分。如果使用任何其他基于JVM的脚本引擎，那么它必须放在类路径或模块路径上。
- en: 'The last method of the class is a simple script manipulation method, nothing
    special. It just chops off the filename extension so that the engine can be identified
    based on the extension string:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类的最后一个方法是简单的脚本操作方法，没有什么特别之处。它只是切掉了文件名扩展名，以便根据扩展字符串来识别引擎：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And just for the sake of completeness, we have the closing brace of the class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了完整性，我们还有类的结束括号：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Programming in the enterprise
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业中的编程
- en: When a professional works for an enterprise, she does not work alone. There
    are a lot of people, developers as well as other coworkers, we have to cooperate
    with. The older the IT department of the enterprise is, and the larger the enterprise
    is, the more specialized roles people are in. You will certainly meet business
    analysts, project managers, test engineers, build engineers, subject-matter experts,
    testers, architects, scrum masters, and automation engineers, to name a few roles.
    Some of these roles may overlap, no person may have more than one responsibility,
    and while in other cases, some roles could even be more specialized. Some of the
    roles are very technical and require less business-related knowledge; others are
    more business oriented.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个专业人士为企业工作时，她并不是独自工作。有很多很多人，包括开发者和其他同事，我们必须与他们合作。企业的IT部门越老，企业规模越大，人们的专业角色就越多样化。你肯定会遇到业务分析师、项目经理、测试工程师、构建工程师、领域专家、测试员、架构师、敏捷教练和自动化工程师等角色。其中一些角色可能存在重叠，没有人可能承担超过一个的责任，而在其他情况下，一些角色甚至可能更加专业化。有些角色非常技术性，需要较少的业务相关知识；而另一些则更偏向于业务导向。
- en: Working together as a team with so many people and with so many different roles
    is not simple. The complexity of the task may be overwhelming for a novice developer
    and cannot be done without definite policies that all members of the operation
    follow, more or less. Perhaps your experience will show that it is more times
    less than more, but that is a different story.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与众多不同角色的人一起作为一个团队工作并不简单。任务的复杂性可能对新手开发者来说是压倒性的，而且没有所有操作成员都遵循的明确政策是无法完成的，或多或少都是如此。也许你的经验会表明，这更多的是少而不是多，但这又是另一个故事了。
- en: 'For the way developers work together, there are well-established industry practices.
    These support the **Software Development Lifecycle** (**SDLC**) using waterfall,
    agile, or a mix of the two models in some way. In the following sections, we will
    look at tools and techniques that are, or at least should have been, used in every
    software development organization. These are:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者如何协作，有成熟的行业实践。这些实践支持使用瀑布、敏捷或两种模型的某种组合的**软件开发生命周期**（**SDLC**）。在接下来的章节中，我们将探讨在每一个软件开发组织中，至少应该使用过的工具和技术。这些包括：
- en: Static code analysis tools that control the quality of the code examining the
    source code
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态代码分析工具，通过检查源代码来控制代码质量
- en: Source code version control that stores all the versions of the source code
    and help get the source code for any old version of the development
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码版本控制，存储所有源代码版本，并帮助获取任何旧版本开发的源代码
- en: Software versioning to keep some order of how we identify the different versions
    and do not get lost among the different versions
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件版本控制，以保持我们对不同版本标识的某种顺序，并避免在众多版本中迷失
- en: Code review and tools that help in pin-pointing bugs that are not revealed by
    tests and aid knowledge sharing
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查和帮助定位测试未揭示的缺陷的工具，以及促进知识共享
- en: Knowledge base tools to record and document the findings
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知识库工具，用于记录和文档化发现
- en: Issue tracking tools that record bugs, customer issues, and other tasks that
    somebody has to attend to
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题跟踪工具，用于记录缺陷、客户问题和其他人必须处理的任务
- en: Selection process and considerations for external products and libraries
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部产品和库的选择流程和考虑因素
- en: Continuous integration that keeps the software in a consistent state and reports
    immediately if there is some error in it before the error propagates to other
    versions or other code, depending on how the erroneous code gets developed
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成，保持软件的一致状态，并在错误传播到其他版本或其他代码之前立即报告错误，这取决于错误代码是如何开发的
- en: Release management, which keeps track of the different release versions of the
    software
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本管理，它跟踪软件的不同版本
- en: Code repository, which stores the compiled and packed artifacts
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码仓库，存储编译和打包的工件
- en: 'The following diagram shows the most widely used tools for these tasks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这些任务最广泛使用的工具：
- en: '![](img/00065.gif)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00065.gif)'
- en: Static code analysis
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Static code analysis tools read the code just like the compiler and analyze
    it, but instead of compilation, they try to find errors or mistakes in it. Not
    the syntax errors. For that, we already have the Java compiler. Mistakes, such
    as using a loop variable outside a loop, which may be absolutely valid but is
    usually bad style and, many times, such usage comes from some simple mistakes.
    They also check that the code follows the styling rules that we set.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析工具读取代码的方式就像编译器一样，并对其进行分析，但它们不是进行编译，而是试图在其中找到错误或错误。不是语法错误。对于这一点，我们已经有Java编译器了。错误，例如在循环外部使用循环变量，这可能是绝对有效的，但通常是糟糕的风格，而且很多时候，这种用法可能源于一些简单的错误。它们还检查代码是否遵循我们设定的样式规则。
- en: Static code analyzers help identify many small and obvious errors in the code.
    Sometimes, they are annoying, warning about something that may not be really a
    problem. In such a case, it is better to code the program a bit differently, not
    because we want the static code analysis to run without warning. We should never
    modify the code because of a tool. If we code something in such a way that it
    passes some quality check tool and not because it is better that way, then we
    are serving the tools instead of the tools serving us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析器有助于识别代码中的许多小而明显的错误。有时，它们可能会令人烦恼，警告某些可能并不是真正的问题。在这种情况下，最好是稍微改变一下程序代码，不是因为我们要让静态代码分析工具在没有警告的情况下运行。我们永远不应该因为一个工具而修改代码。如果我们以某种方式编写代码，使其通过某些质量检查工具，而不是因为它这样做更好，那么我们就是在为工具服务，而不是让工具为我们服务。
- en: The reason to change the code to pass the code analysis is that it is very probable
    that the code is more readable to an average programmer if it does not violate
    the coding style. You or the other team members can be excellent programmers who
    understand the code very easily even if it uses some special construct. However,
    you cannot say that about all the programmers who will maintain your code in the
    future. The code lives a long life. I work with some programs that have been written
    50 years ago. They are still running and maintained by young professionals around
    the age of 30\. It means that they were not even born when the code was developed.
    It can easily happen that the person maintaining your code is not even born by
    the time you write the code. You cannot tell anything about their cleverness and
    coding practices. The best we can do is to prepare for the average and that is
    exactly what static code analysis tools are set for.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码修改为通过代码分析的原因是，如果代码不违反编码风格，那么它对普通程序员来说更有可能是可读的。你或其他团队成员可能是优秀的程序员，即使代码使用了某些特殊结构，也能很容易地理解代码。然而，你不能说所有将来会维护你的代码的程序员都是这样。代码的生命周期很长。我工作的一些程序是50年前编写的。它们仍在运行，并由大约30岁的年轻专业人士维护。这意味着它们在代码开发时甚至还没有出生。很容易发生的情况是，维护你代码的人在你编写代码的时候甚至还没有出生。你不能对他们的聪明才智和编码实践有任何了解。我们能做的最好的事情就是为平均水平做准备，这正是静态代码分析工具设定的目的。
- en: The checks that these tools perform are not hardwired into the tools. Some special
    language inside the tools describes the rules and they can be deleted, other rules
    can be added, and rules can be modified. This way, you can accommodate the coding
    standards of the enterprise you work for. The different rules can be categorized
    as cosmetic, minor, major, and critical. Cosmetic things are mainly warnings and
    we do not really care about them, even though it is nice to fix even these issues.
    Sometimes, these small things may signal some really big issue. We can set limits
    for the number of minor and major bugs before the check is declared as failing
    and also for the critical errors. In the last case, this limit is usually zero.
    If a coding error seems to be critical, then better not have any in the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具执行的检查不是硬编码在工具中的。工具内部有一些特殊的语言描述了规则，可以删除某些规则，可以添加其他规则，并且可以修改规则。这样，你可以适应你工作的企业的编码标准。不同的规则可以分为外观、轻微、重要和关键。外观问题主要是警告，我们并不真正关心它们，尽管修复这些问题也很不错。有时，这些小问题可能预示着一些真正的大问题。我们可以在检查被宣布为失败之前设置轻微和重要错误的数量限制，也可以为关键错误设置限制。在最后一种情况下，这个限制通常是零。如果一个编码错误似乎很关键，那么最好代码中没有任何这样的错误。
- en: The most frequently used tools are **Checkstyle**, **FindBugs**, and **PMD**.
    The execution of these tools is usually automated, and though they can be executed
    from the IDE or from the developer's command line, their main use is on the **continuous
    integration** (**CI**) server. During the build, these tools are configured on
    the CI server to run, and it can be configured such that the build should be broken
    if the static code analysis fails with some limit. Executing the static code analysis
    is usually the next step after compilation and unit test execution, and before
    the actual packaging.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的工具是 **Checkstyle**、**FindBugs** 和 **PMD**。这些工具的执行通常自动化，尽管可以从 IDE 或开发者的命令行执行，但它们的主要用途是在
    **持续集成** (**CI**) 服务器上。在构建过程中，这些工具在 CI 服务器上配置为运行，并且可以配置为如果静态代码分析失败达到某些限制时构建应中断。执行静态代码分析通常是编译和单元测试执行之后的下一步，以及实际打包之前。
- en: The **SonarQube** tool ([https://www.sonarqube.org/](https://www.sonarqube.org/))
    is a special tool in addition to being a static code analysis tool. SonarQube
    maintains the history of the previous checks as well as supports unit test code
    coverage and can report the change of the quality over time. This way, you can
    see how the quality, coverage percentage, and number of different qualifications
    of code style errors have changed. Many times, you can see that when approaching
    the release date, the code quality decreases as people are in a rush. This is
    very bad because this is the time when most of the bugs should be eliminated.
    Having a statistic about the quality may help change the practice by seeing the
    trends before the quality, and thus the maintainability of the code gets out of
    hand.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**SonarQube** 工具 ([https://www.sonarqube.org/](https://www.sonarqube.org/))
    除了是一个静态代码分析工具外，还是一个特殊的工具。SonarQube 维护了之前检查的历史记录，同时支持单元测试代码覆盖率，并能报告质量随时间的变化。这样，你可以看到质量、覆盖率百分比以及代码风格错误的不同质量级别的数量是如何变化的。很多时候，你可以看到，当接近发布日期时，由于人们急于完成工作，代码质量会下降。这是非常糟糕的，因为这是大多数错误应该被消除的时候。有关质量的统计数据可能有助于通过在质量恶化之前看到趋势来改变实践，从而使代码的可维护性失控。'
- en: Source code version control
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码版本控制
- en: Source code version control systems store different versions of the source code.
    These days, we cannot imagine professional software development without it. This
    was not always the case, but the availability of free online repositories encouraged
    hobby developers to use some version control, and when these developers worked
    for enterprises later, it was evident that the use of these systems is kind of
    a must.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码版本控制系统存储源代码的不同版本。如今，我们无法想象没有它进行专业软件开发。这并非一直如此，但免费在线仓库的可用性鼓励了业余开发者使用某些版本控制，而当这些开发者后来为企业工作时，很明显，使用这些系统是必不可少的。
- en: There are many different revision control systems. The most widely used one
    is Git. The version control that was previously widely used was **SVN** and, even
    before that, **CVS**. These are less and less used these days. We can see **SVN**
    as a successor of **CVS** and Git as a successor of **SVN**. In addition to these,
    there are other version control systems such as **Mercurial**, **Bazaar**, or
    **Visual Studio Team Services**. For a comprehensive list of the available tools,
    visit the Wikipedia page at [https://en.wikipedia.org/wiki/List_of_version_control_software](https://en.wikipedia.org/wiki/List_of_version_control_software).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着许多不同的版本控制系统。最广泛使用的是 Git。之前广泛使用的版本控制是 **SVN**，甚至在那之前是 **CVS**。这些系统现在越来越不常用。我们可以将
    **SVN** 视为 **CVS** 的继承者，Git 视为 **SVN** 的继承者。除此之外，还有其他版本控制系统，如 **Mercurial**、**Bazaar**
    或 **Visual Studio Team Services**。要查看可用工具的完整列表，请访问维基百科页面 [https://en.wikipedia.org/wiki/List_of_version_control_software](https://en.wikipedia.org/wiki/List_of_version_control_software)。
- en: My bet is that you will meet Git in the first place and there is a high probability
    of you coming across SVN when programming for an enterprise. Mercury may appear
    in your practice but any of the others that currently exist are very rare, are
    used for a specific area, or are simply extinct.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我的猜测是，你首先会遇到 Git，并且在你为企业编程时遇到 SVN 的可能性很高。Mercury 可能会在你的实践中出现，但任何目前存在的其他系统都非常罕见，它们用于特定领域，或者它们已经灭绝。
- en: Version control systems allow the development team to store the different versions
    of the software in an organized manner on a storage that is maintained (backed
    up regularly in a reliable manner). This is important for different purposes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统允许开发团队以有组织的方式在维护的存储（以可靠的方式定期备份）上存储软件的不同版本。这对于不同的目的都很重要。
- en: The first thing is that different versions of the software may be deployed to
    different instances. If we develop software for clients and we have many clients
    with whom we hope to have to make a terrific business, then different clients
    may have different versions. This is not only because some clients are reluctant
    to pay for the upgrade, and we just do not want to give the new version for free.
    Many times, the costs that rise on the side of the customer prevent the upgrade
    for a long time. Software products do not work on their own in an isolated environment.
    Different clients have different integrated environments; the software communicates
    with different other applications. When a new version is to be introduced in an
    enterprise environment, it has to be tested for whether it works with all the
    systems it has to cooperate with. This testing takes a lot of effort and money.
    If the new features or other values that the new version delivers over the old
    one do not justify the cost, then it would be waste of money to deploy the new
    version. The fact that there is a new version of our software does not mean that
    the old versions are not usable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是，软件的不同版本可能部署到不同的实例中。如果我们为客户端开发软件，并且我们有很多希望与之建立卓越业务的客户，那么不同的客户可能有不同的版本。这不仅是因为一些客户不愿意为升级付费，我们也不想免费提供新版本。很多时候，客户方面的成本上升会长期阻止升级。软件产品不会在孤立的环境中自行工作。不同的客户有不同的集成环境；软件与不同的其他应用程序进行通信。当要在企业环境中引入新版本时，必须测试它是否与所有必须合作的系统兼容。这项测试需要大量的努力和资金。如果新版本提供的新功能或其他价值不足以证明成本合理，那么部署新版本将是金钱的浪费。我们软件有新版本的事实并不意味着旧版本不可用。
- en: If there is some bug at the customer's end, then it is vital that we fix the
    bug in that version. To do so, the bug has to be reproduced in the development
    environment, which eventually means that the source code for that version has
    to be available for the developers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端存在一些错误，那么我们修复该版本中的错误至关重要。为此，必须在开发环境中重现该错误，这意味着该版本的源代码必须对开发者可用。
- en: This does require the customer database to contain references to the different
    versions of our software products that are installed at the customer site. To
    make it more complicated, a customer may have more than one version at a time
    in different systems and may also have different licenses, so the issue is more
    complex than it first seems. If we do not know which version the client has, then
    we are in trouble.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实需要客户数据库包含对客户站点上安装的我们软件产品不同版本的引用。更复杂的是，客户可能在不同的系统中同时拥有多个版本，也可能拥有不同的许可证，因此问题比最初看起来更复杂。如果我们不知道客户拥有哪个版本，那么我们就麻烦了。
- en: Since the database registering the versions for the customers and real life
    may get unsynchronized, software products log their version at startup. We have
    a separate section about versioning in this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于为顾客和现实生活注册版本的数据库可能会不同步，软件产品在启动时记录其版本。在本章中，我们专门有一节关于版本控制的内容。
- en: If the bug is fixed in the version that the client has, the incident at the
    customer's end may be solved after deployment. The problem, though, still remains
    if the version is not the previous version of the software. The bug fix introduced
    to an old version of the software may still be lurking around in the later or,
    for that matter, earlier versions. The development team has to identify which
    versions are relevant to clients. For example, an old version that is not installed
    any more at any of the clients' sites does not deserve the investigation. After
    that, the relevant versions have to be investigated to check whether they exhibit
    the bug. This can only be done if we have the source version. Some old versions
    may not have the bug if the code causing the bug is introduced in later versions.
    Some new versions may also be immune to the bug because the bug was already fixed
    in the previous version, or simply because the piece of code that caused the bug
    was refactored even before the bug manifested. Some bugs may even affect a specific
    version instead of a range of products. Big fixing may be applied to different
    versions and they may need slightly different fixes. All this needs a maintained
    source version repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端所使用的版本中已经修复了该错误，那么在部署后，客户端的故障可能就会得到解决。然而，如果版本不是软件的上一版本，问题仍然存在。对旧版本软件引入的错误修复可能仍然潜伏在后续版本，甚至可能是早期版本。开发团队必须确定哪些版本与客户相关。例如，不再安装在任何客户站点上的旧版本不值得调查。之后，必须调查相关版本以检查它们是否表现出该错误。这只有在我们有源版本的情况下才能完成。如果导致错误的代码是在后续版本中引入的，那么一些旧版本可能没有错误。一些新版本也可能对错误免疫，因为错误已经在上一版本中修复，或者简单地因为导致错误的代码在错误出现之前就已经重构。一些错误甚至可能只影响特定版本而不是一系列产品。对不同的版本可能需要应用不同的修复，所有这些都需要维护一个源版本库。
- en: Even when we do not have different customers with different versions, it is
    more than likely that we have more than one version of our software in development.
    The development of a major release is coming to an end, and therefore, one part
    of the team responsible for testing and bug fixing focuses on those activities.
    At the same time, the development of features for the next version still goes
    on. The code implementing the functionalities for the next version should not
    get into the version that is about to be released. The new code may be very fresh,
    untested, and may introduce new bugs. It is very common to introduce freeze times
    during the release process. For example, it may be forbidden to implement any
    new feature of the upcoming release. This is called feature freeze.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有不同版本的客户，我们很可能在开发中拥有我们软件的多个版本。主要发布版本的开发即将结束，因此，负责测试和错误修复的团队的一部分专注于这些活动。同时，下一版本的特性开发仍在继续。实现下一版本功能的代码不应该进入即将发布的版本。新代码可能非常新鲜，未经测试，并可能引入新的错误。在发布过程中引入冻结时间是很常见的。例如，可能禁止实现即将发布版本的新功能。这被称为特性冻结。
- en: Revision control systems deal with these freeze periods, maintaining different
    branches of the code. The release will be maintained in one branch and the version
    for later releases in a different one. When the release goes out, the bug fixes
    that were applied to it should also be propagated to the newer version; otherwise,
    it might so happen that the next version will contain bugs that were already fixed
    in the previous version. To do so, the release branch is merged with the ongoing
    one. Thus, version control systems maintain a graph of the versions, where each
    version of the code is a node in the graph and the changes are vertices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统处理这些冻结期，维护代码的不同分支。发布将维护在一个分支上，而后续发布的版本将维护在另一个分支上。当发布推出时，应用于它的错误修复也应该传播到新版本；否则，可能会发生这样的情况，即下一版本将包含已经在上一版本中修复的错误。为此，发布分支将与正在进行的分支合并。因此，版本控制系统维护一个版本图，其中每个代码版本是图中的一个节点，而更改是顶点。
- en: Git goes very far in this direction. It supports branch creation and merging
    so well that developers create separate branches for each change that they create
    and then they merge it back with the master branch when the feature development
    is done. This also makes for a good opportunity for code review. The developer
    making the feature development or bug fix creates a pull request in the GitHub
    application, and another developer is requested to review the change and perform
    the pull. This is a kind of four-eyed principle applied to code development.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Git在这方面做得非常出色。它很好地支持分支创建和合并，以至于开发者为每个创建的更改创建单独的分支，然后在功能开发完成后将其合并回主分支。这也为代码审查提供了良好的机会。进行功能开发或错误修复的开发者在GitHub应用程序中创建一个拉取请求，并请求另一位开发者审查更改并执行拉取。这是一种将四眼原则应用于代码开发的方法。
- en: Some of the revision control systems keep the repository on a server and any
    change gets to the server. The advantage of this is that any change committed
    gets to a server disk that is regularly backed up and is thus safe. Since the
    server-side access is controlled, any code sent to the server cannot be rolled
    back without trace. All versions, even the wrong versions, are stored on the server.
    This may be required by some legal control. On the other hand, if commit requires
    network access and server interaction, it may be slow and this will, in the long
    run, motivate developers not to commit their changes frequently. The longer a
    change remains on the local machine, the more risk we have of losing some of the
    code, and merging becomes more and more difficult with time. To heal this situation,
    Git distributes the repository and the commit happens to the local repository,
    which is exactly the same as the remote one on some server. The repositories are
    synchronized when one repository pushes the changes to another one. This encourages
    the developers to make frequent commits to the repository, giving short commit
    messages, which helps in tracking the change made to the code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本控制系统将仓库保存在服务器上，任何更改都会发送到服务器。这种做法的优势在于，任何提交的更改都会存储在定期备份的服务器磁盘上，因此是安全的。由于服务器端访问受到控制，发送到服务器的任何代码都无法无痕迹地回滚。所有版本，即使是错误的版本，都会存储在服务器上。这可能是由某些法律控制所要求的。另一方面，如果提交需要网络访问和服务器交互，可能会很慢，这最终会促使开发者不经常提交更改。更改在本地机器上停留的时间越长，我们丢失代码的风险就越大，随着时间的推移，合并变得越来越困难。为了解决这个问题，Git将仓库分散到各个地方，提交操作发生在本地仓库上，这与服务器上的远程仓库完全相同。当一个仓库将更改推送到另一个仓库时，仓库会同步。这鼓励开发者频繁地向仓库提交更改，提供简短的提交信息，这有助于跟踪对代码所做的更改。
- en: Some older version control systems support file locking. This way, when a developer
    checks out a code file, others cannot work on the same piece of code. This essentially
    avoids the collisions during code merging. Over the years, this approach did not
    seem to fit the development methodologies. Merge issues are less of a problem
    than files that are checked out and forgotten. SVN supports file locking but this
    is not really serious and does not prevent one developer to commit changes to
    a file that somebody else locked. It is more of only a suggestion than real locking.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较老的版本控制系统支持文件锁定。这种方式下，当开发者检出代码文件时，其他人不能在相同的代码片段上工作。这本质上避免了代码合并时的冲突。多年来，这种方法似乎并不适合开发方法。合并问题不如检出并遗忘的文件问题严重。SVN支持文件锁定，但这并不是真正的锁定，并不能阻止一个开发者提交更改到另一个开发者锁定的文件。这更像是一种建议，而不是真正的锁定。
- en: Source code repositories are very important but should not be confused with
    release repositories, which store the compiled released version of the code in
    binary. Source and release repositories work together.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码仓库非常重要，但不应该与存储编译后发布版本的代码的二进制文件的发布仓库混淆。源代码仓库和发布仓库协同工作。
- en: Software versioning
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件版本控制
- en: Software versioning is magic. Think about the different versions of Windows
    or Star Wars movies. Well, the latter is not really software versioning but it
    shows that the issue is very general. In the case of Java, versioning is not that
    complex. First of all, the version of Java we use now is 9\. The previous version
    was 1.8, before that 1.7, and so on, down to 1.0\. Earlier versions of Java were
    called Oak but that is history. After all, that is, who can tell what Java 2 was?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 软件版本化是神奇的。想想Windows或星球大战电影的各个版本。嗯，后者其实并不是软件版本化，但它表明这个问题是非常普遍的。在Java的情况下，版本化并不那么复杂。首先，我们现在使用的Java版本是9。之前的版本是1.8，再之前是1.7，以此类推，直到1.0。早期的Java版本被称为Oak，但那是历史。毕竟，谁又能说清楚Java
    2是什么？
- en: 'Fortunately, when we create a Java application, the situation is simpler. There
    has been a suggestion from Oracle, from the time of Java 1.3, about how to version JARs:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当我们创建一个Java应用程序时，情况要简单得多。从Java 1.3时代起，Oracle就提出了关于如何版本化JAR的建议：
- en: '[http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/versioning.html](http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/versioning.html)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/versioning.html](http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/versioning.html)'
- en: This document distinguishes between specification version and implementation
    version. If the specification of a JAR content changes, the code has to behave
    differently from how it was behaving till then; the specification version should
    change. If the specification is not changed but the implementation does--for example,
    when we fix a bug--then the implementation version changes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档区分了规范版本和实现版本。如果JAR内容的规范发生变化，代码必须以不同的方式运行，与之前的行为不同；规范版本应该改变。如果规范没有改变，但实现发生了变化——例如，当我们修复一个错误时——那么实现版本就会改变。
- en: In practice, nobody has used this scheme, although it is a brilliant idea to
    separate the implementation and specification versions, at least, in theory. I
    even bet that most of your colleagues have not even ever heard about this versioning.
    What we use in practice is semantic versioning.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，没有人使用这个方案，尽管在理论上将实现版本和规范版本分开是一个绝妙的主意。我甚至打赌，你们中的大多数同事甚至从未听说过这种版本化。我们在实践中使用的是语义版本化。
- en: 'Semantic versioning ([http://semver.org/](http://semver.org/)) mixes the specification
    and implementation versions into one single version number triplet. This triplet
    has the format of **mmp,** that is:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本化([http://semver.org/](http://semver.org/))将规范版本和实现版本混合成一个单一的版本号三元组。这个三元组的格式为**mmp**，即：
- en: '**m**: major version number'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**m**：主版本号'
- en: '**m**: minor version number'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**m**：次版本号'
- en: '**p**: patch number'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**p**：补丁号'
- en: 'The specification says that these numbers start with zero and increase by one.
    If the major number is zero, it means that the software is still in development.
    In this state, the API is not stable and may change without a new major version
    number. The major version number gets to 1 when the software is released. Later
    it has to be increased when the API of the application (library) has changed from
    the previous version and the application is not backward compatible with the previous
    version. The minor version number is increased when the change effects only the
    implementation but the change is significant, perhaps, even the API is also changing
    but in a backward-compatible manner. The patch version is increased when some
    bug is fixed, but the change is not major and the API does not change. The minor
    and the patch levels have to be reset to zero if any version number in the triplet
    in front of any of them is increased: major version number increase resets both
    minor and patch version; minor version number increase resets patch number.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 规范说明这些数字从零开始，每次增加一。如果主版本号是零，这意味着软件仍在开发中。在这种情况下，API是不稳定的，可能会在没有新的主版本号的情况下发生变化。当软件发布时，主版本号达到1。之后，当应用程序（库）的API从上一个版本发生变化，并且应用程序与上一个版本不向后兼容时，主版本号必须增加。当变化仅影响实现但变化是显著的，也许API也在变化，但以向后兼容的方式时，次版本号会增加。当修复了一些错误，但变化不是主要的，API没有变化时，补丁版本号会增加。如果任何三元组中的版本号增加，则次要和补丁级别必须重置为零：主版本号增加重置次要和补丁版本；次版本号增加重置补丁号。
- en: This way, semantic versioning keeps the first element of the triplet for the
    specification version. The minor is a mix of the specification and implementation
    versions. A patch version change is clearly an implementation version change.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，语义版本控制保持了三元组中规范版本的第一个元素。次要版本是规范版本和实现版本的混合。补丁版本的变化显然是实施版本的变化。
- en: In addition to these, semantic versioning allows appending a pre-release string,
    such as `-RC1` and `-RC2`. It also allows the appending of metadata, such as a
    date after a plus sign, for example, `+20160120` as a date.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，语义版本控制允许附加预发布字符串，例如 `-RC1` 和 `-RC2`。它还允许附加元数据，例如在加号之后的日期，例如，`+20160120`
    作为日期。
- en: The use of semantic versioning helps those that use the software to easily spot
    compatible versions and to see which version is older and which is newer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制的使用有助于那些使用软件的人轻松地找到兼容版本，并看到哪个版本更老，哪个版本更新。
- en: Code review
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查
- en: When we create programs in a professional way, it is done in teams. There is
    no one-man show programming other than in a hobby or going along with the tutorials.
    It is not only because it is more effective to work in teams but also because
    one person is vulnerable. If you work alone and get hit by the bus or you hit
    the lottery and lose your ability or motivation to work on the project, your customer
    is in trouble. That is not professional. Professional projects should be resilient
    to any member falling off.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以专业的方式创建程序时，是在团队中完成的。除了在业余爱好或跟随教程之外，没有单打独斗的编程。这不仅是因为团队合作更有效，而且因为一个人是脆弱的。如果你独自工作，被撞到或中了彩票而失去了工作项目的能力或动力，你的客户就会陷入麻烦。这不是专业。专业项目应该能够抵御任何成员的退出。
- en: Teamwork needs cooperation and one form of cooperation is code review. This
    is the process when a developer or a group of developers reads a part of the code
    that some other team members have written. There are direct gains from this activity;
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 团队合作需要合作，代码审查就是其中一种合作形式。这是当开发者或一组开发者阅读其他团队成员编写的代码的一部分时的过程。从这个活动中可以直接获得收益；
- en: The developers reading the code get more knowledge about the code; they learn
    the code. This way, if the developer creating the code gets out of the process
    for any reason, the others can continue the work with minimal bump.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读代码的开发者可以更多地了解代码；他们学习了代码。这样，如果创建代码的开发者因任何原因退出流程，其他人可以以最小的干扰继续工作。
- en: Coding styles can be aligned. Developers, even seniors, paying careful attention
    make coding mistakes. This may be a bug or it may be a coding style violation.
    Coding style is important because the more readable the code is, the less possibility
    of it having unnoticed bugs. (Also see the next bullet point.) It is also important
    that the coding style is the same for the team. All team members should use the
    same style. Looking at a code that has a different style from the one I wrote
    is a bit harder to follow and understand. The differences may distract the reader
    and the team members have to be able to read the code. The code belongs to the
    team and not a single developer. Any team member should know the code and be able
    to modify it.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码风格可以统一。即使是经验丰富的开发者，在仔细注意的情况下也会犯编码错误。这可能是错误，也可能是编码风格违规。编码风格很重要，因为代码越易读，出现未注意到的错误的可能性就越小。（也参见下一个要点。）同样重要的是，编码风格对团队来说应该是统一的。所有团队成员都应该使用相同的风格。查看与我编写的代码风格不同的代码有点难以跟随和理解。这些差异可能会分散读者的注意力，团队成员必须能够阅读代码。代码属于团队，而不是单个开发者。任何团队成员都应该了解代码，并能够修改它。
- en: During code review, a lot of bugs can be discovered. The parties looking at
    the code and trying to understand the working of it may occasionally discover
    bugs from the structure of the code, which are otherwise hard to discover using
    tests. If you want, code review is the whitest white box test. People think differently
    and different mindsets catch different bugs.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码审查过程中，可以发现很多错误。审查代码并试图理解其工作原理的各方可能会偶尔从代码结构中发现错误，这些错误在其他情况下很难通过测试发现。如果您愿意，代码审查就是最纯粹的白盒测试。人们有不同的思维方式，不同的思维模式可以捕捉到不同的错误。
- en: Code review can be done online and offline. It can be done in teams or peer-to-peer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查可以在线上和线下进行。它可以在团队内部或对等之间进行。
- en: Most teams follow the code review process that GitHub supports, which is the
    simplest. Changes to the code are committed to a branch and are not merged with
    the code directly but, rather, a pull request is created on the web interface.
    The local policy may require that a different developer perform the pull. The
    web interface will highlight the changes and we can add comments to the changed
    code. If the comments are significant, then the original developer requesting
    the pull should modify the code to answer the comments and request the pull again.
    This ensures that at least two developers see any change; the knowledge is shared.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数团队遵循GitHub支持的代码审查流程，这是最简单的。代码更改被提交到一个分支，而不是直接与代码合并，而是在网页界面上创建一个拉取请求。本地政策可能要求不同的开发者执行拉取。网页界面将突出显示更改，我们可以在更改的代码上添加评论。如果评论很重要，那么请求拉取的原开发者应该修改代码以回应评论，并再次请求拉取。这确保至少有两个开发者看到任何更改；知识得到了共享。
- en: Feedback is peer-to-peer. It is not a senior teaching a junior. That needs a
    different channel. Comments in GitHub are not good for this purpose; at least,
    there are better channels. Perhaps talking face to face. Comments may come from
    a senior to a junior or from a junior to a senior. In this work, giving feedback
    on the quality of the code, seniors and juniors, are equal.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈是同侪之间的。这不是一个资深人士在教一个初级人士。这需要不同的渠道。GitHub上的评论并不适合这个目的；至少，有更好的渠道。也许面对面交谈更好。评论可能来自资深人士对初级人士或初级人士对资深人士。在这项工作中，对代码质量的反馈，资深人士和初级人士是平等的。
- en: 'The simplest and perhaps the most frequent comment is the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单也许是最常见的评论如下：
- en: '*I can see that Xyz.java was changed in the modification but I see no change
    made to **XyzTest.java.* This is almost an instant refusal for the merge. If a
    new feature is developed, unit tests have to be created to test that feature.
    If a bug is fixed, then unit tests have to be created to prevent the bug from
    coming back. I personally got this comment many times, even from juniors. One
    of them told me, "We know that you were testing us if we dared to give feedback."'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*我可以看到Xyz.java在修改中有所改变，但我看不到对**XyzTest.java**的任何更改。这几乎是对合并的即时拒绝。如果开发了一个新功能，必须创建单元测试来测试该功能。如果修复了一个错误，那么必须创建单元测试以防止错误再次出现。我个人收到了很多这样的评论，甚至来自初级人士。其中一个人告诉我，“我们知道如果你敢给出反馈，你是在考验我们。”'
- en: God knows I was not. They did not believe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上帝知道我并不是。他们不相信。
- en: While change review and GitHub is a good tool during development, it may not
    be appropriate when a larger chunk of code has to be reviewed. In such a case,
    other tools, such as **FishEye**, have to be used. In this tool, we can select
    the source files for review even if they were not recently changed. We can also
    select reviewers and deadlines. Commenting is similar to GitHub. Finally, this
    type of code review finishes with a code review session, where the developers
    gather and discuss the code in person.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在开发过程中，变更审查和GitHub是一个好工具，但当需要审查大量代码时，可能并不合适。在这种情况下，必须使用其他工具，例如**FishEye**。在这个工具中，我们可以选择要审查的源文件，即使它们最近没有更改。我们还可以选择审查人员和截止日期。评论与GitHub类似。最后，这种代码审查以代码审查会议结束，开发人员聚集在一起亲自讨论代码。
- en: While organizing such a session, it is important that a person who has experience
    managing other people mediates these sessions. Code and discussion on styles can
    get very personal. At the same time, when attending such a meeting, you should
    also pay attention so as not to get personal. There will be enough participants
    who may not know this or are less disciplined.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织此类会议时，一个有管理他人经验的人调解这些会议是很重要的。代码和关于风格的讨论可能会变得非常个人化。同时，在参加会议时，你也应该注意不要变得个人化。会有足够的参与者可能不知道这一点或纪律性较差。
- en: Never attend a review session without reviewing the code first using the online
    tools. When you make comments, the language should be very polite for the reason
    I have already mentioned. Finally, the mediator of the meeting should be able
    to separate important and not so important issues and to stop debate on bagatelle
    things. Somehow, the less important issues are more sensitive. I personally do
    not care about formatting the tab size if it is two or four spaces and if the
    file should contain only spaces or if tab characters are allowed, but people tend
    to like to waste time on such issues.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用在线工具审查代码之前，永远不要参加审查会议。当你发表评论时，语言应该非常礼貌，原因我已经提到。最后，会议的调解者应该能够区分重要和不那么重要的问题，并停止对琐事进行辩论。不知何故，不那么重要的问题更为敏感。我个人并不关心格式化制表符的大小，如果它是两个或四个空格，以及文件是否应仅包含空格或是否允许制表符字符，但人们往往喜欢在这些问题上浪费时间。
- en: The most important issue during code review sessions is that we are professional
    and it may happen that I review and comment your code today, but tomorrow, it
    will be just the opposite, and we work together and we have to work together as
    a team.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码审查会议期间，最重要的问题是我们要专业，可能发生的情况是，我今天会审查并评论你的代码，但明天情况可能正好相反，我们必须一起工作，并且我们必须作为一个团队一起工作。
- en: Knowledge base
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知识库
- en: Knowledge base was a buzzword a few years ago. Few companies were evangelizing
    the idea of wiki technology and nobody was using it. Today, the landscape of knowledge
    base is totally different. All enterprises use some kind of wiki implementation
    that is there to share knowledge. They mostly use Confluence, but there are also
    other wiki solutions available, commercial and free as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 知识库几年前还是一个热门词汇。当时很少有公司在宣扬维基技术的理念，也没有人使用它。如今，知识库的格局已经完全不同。所有企业都在使用某种维基实现，目的是为了分享知识。他们主要使用Confluence，但也有其他商业和免费的维基解决方案可供选择。
- en: Knowledge bases store information that you, as a developer, would write down
    in a paper notebook for your later reference, for example, the IP address of the
    development server, directories where to install the JAR files, what commands
    to use, what libraries you have collected, and why you use them. The major difference
    is that you write it in a formatted way into a wiki and it is available immediately
    for other developers. It is a bit of a burden on the developer to write these
    pages, and it needs some self-discipline first. Sticking to the example of the
    IP address of the development server and the install directories, you have to
    write not only the IP address of the server but also some text explaining what
    the information is, because the others may not understand it otherwise. It is
    also a bit of work to place the page with the information in the wiki system with
    a good name, linking it to other pages, or finding the appropriate position of
    the page in the tree of pages. If you were using the paper notebook, you could
    just write down the IP address and the directories on the first free page of the
    book and you would just remember all others.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 知识库存储的信息是你作为开发者可能会写在纸笔记本上以供日后参考的信息，例如，开发服务器的IP地址、安装JAR文件的目录、要使用的命令、你收集的库以及为什么使用它们。主要区别在于你以格式化的方式将其写入维基，这样其他开发者可以立即访问。对于开发者来说，编写这些页面是一种负担，并且首先需要一定的自律。以开发服务器的IP地址和安装目录为例，你必须不仅写下服务器的IP地址，还要写一些解释信息是什么的文字，因为其他人可能不理解。将包含信息的页面放置在维基系统中并取一个好名字、将其链接到其他页面或找到页面在页面树中的适当位置，也是一项工作。如果你使用的是纸笔记本，你只需在书的第一个空白页上写下IP地址和目录，然后你就可以记住所有其他信息。
- en: The wiki approach will pay back when coworkers do not need to find the information
    themselves; you can find the information in an easier way because other coworkers
    have also recorded their findings in the knowledge base and, last but not least,
    a few months later, you find the information you recorded yourself. In the case
    of a paper notebook, you would turn the pages to find the IP address and you may
    or may not remember which one is the primary and which is the secondary server.
    You may even forget by then that there are two servers (or was it a double cluster?).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当同事不需要自己寻找信息时，维基方法将得到回报；你可以通过更简单的方式找到信息，因为其他同事也已经将他们的发现记录在知识库中，最后但并非最不重要的是，几个月后，你找到了自己记录的信息。在纸笔记本的情况下，你会翻页以找到IP地址，你可能记得或不记得哪个是主服务器，哪个是辅助服务器。你甚至可能忘记那时有两个服务器（或者是一个双集群？）。
- en: To have a long list of available wiki software, visit [https://en.wikipedia.org/wiki/Comparison_of_wiki_software](https://en.wikipedia.org/wiki/Comparison_of_wiki_software).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的长列表的 wiki 软件，请访问[https://en.wikipedia.org/wiki/Comparison_of_wiki_software](https://en.wikipedia.org/wiki/Comparison_of_wiki_software)。
- en: Issue tracking
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题跟踪
- en: Issue tracking systems keep track of issues, bugs, and other tasks. The first
    issue tracking systems were created to maintain the list of bugs and also the
    state of the bug fixing process to ensure that a bug, identified and recorded,
    will not get forgotten. Later, these software solutions developed and became full-fledged
    issue trackers and are unavoidable project management tools in every enterprise.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 问题跟踪系统跟踪问题、错误和其他任务。最初的问题跟踪系统是为了维护错误列表以及错误修复过程的状况，以确保已识别和记录的错误不会遗忘。后来，这些软件解决方案发展并成为完整的跟踪器，成为每个企业中不可避免的项目管理工具。
- en: The most widely used issue tracking application used in many enterprises is
    Jira, but on the [https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems](https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems)
    page, you can find many other applications listed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多企业中，最广泛使用的跟踪问题应用是 Jira，但您可以在[https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems](https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems)页面上找到列出的许多其他应用。
- en: The most important feature of an issue tracker application is that it has to
    record an issue in detail in an editable manner. It has to record the person who
    recorded the issue in case more information is needed during issue handling. The
    source of the issue is important. Similarly, issues have to be assigned to some
    responsible person, who is accountable for the progress of issue handling.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 问题跟踪应用最重要的功能是必须以可编辑的方式详细记录问题。在处理问题期间需要更多信息时，必须记录记录问题的人员。问题的来源很重要。同样，问题必须分配给某个负责人员，该人员对问题处理进度负责。
- en: Modern issue tracking systems provide complex access control, workflow management,
    relation management, and integration with other systems.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现代问题跟踪系统提供复杂的访问控制、工作流程管理、关系管理和与其他系统的集成。
- en: Access control will only allow the person who has something to do with an issue
    access to it, so others cannot alter the state of an issue or even read the information
    attached to it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制只会允许与问题有关的人员访问该问题，因此其他人无法更改问题的状态，甚至无法阅读附加到其上的信息。
- en: 'An issue may go through different workflow steps depending on the type of issue:
    a bug may be reported or reproduced, a root cause analyzed, a fix developed or
    tested, a patch created, a fix merged with the next release version or published
    in the release. This is a simple workflow with a few states.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的处理步骤可能因问题的类型而异：错误可能被报告或重现，根本原因分析，修复开发或测试，补丁创建，修复与下一个发布版本合并或发布在发布中。这是一个具有几个状态简单的工作流程。
- en: Relation management allows setting different relations between issues and allowing
    the user to navigate from issue to issue along these relations. For example, a
    client reports a bug, and the bug is identified as being the same as another already
    fixed. In such a case, it would be insane to go through the original workflow
    and creating a new patch for the same bug. Instead, the issue gets a relation
    pointing to the original issue and sets the state to be closed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关系管理允许设置不同的问题关系，并允许用户通过这些关系从一个问题导航到另一个问题。例如，客户报告了一个错误，并且该错误被识别为与另一个已修复的错误相同。在这种情况下，通过原始工作流程并创建相同错误的新的补丁将是愚蠢的。相反，问题会得到一个指向原始问题的关系，并将状态设置为已关闭。
- en: Integration with other systems is also useful to keep a consistent development
    state. Version control may require that, for every commit, the commit message
    contains a reference to the issue that describes the requirement, bug, or change
    that the code modification supports. Issues may be linked to knowledge base articles
    or agile project management software tools using web links.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他系统的集成也有助于保持一致的开发状态。版本控制可能需要，对于每次提交，提交信息包含对描述代码修改支持的必要、错误或更改的问题的引用。问题可能通过网页链接链接到知识库文章或敏捷项目管理软件工具。
- en: Testing
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: We have already discussed testing when we talked about unit testing. Unit testing
    is extremely important in agile development and it helps keep the code clean and
    reduce the number of errors. But this is not the only type of testing that you
    will see in enterprise development.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论单元测试时，我们已经讨论了测试。单元测试在敏捷开发中非常重要，它有助于保持代码清洁并减少错误数量。但这是你在企业开发中看到的测试类型之一。
- en: Types of tests
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: Testing is performed for many reasons but there are at least two reasons that
    we have to mention. One is to hunt the bugs and create error-free code as much
    as possible. The other is to prove that the application is usable and can be utilized
    for the purpose it was meant for. It is important from the enterprise point of
    view and considers a lot of aspects that unit test does not. While unit test focuses
    on one unit and, thus, is an extremely good tool to point out where the error
    is, it is totally unusable when it comes to discovering bugs that come from erroneous
    interfaces between modules. The unit tests mock external modules and, thus, test
    that the unit works as expected. However, if there is an error in this expectation
    and the other modules do not behave in the same way as the unit test mock, the
    error will not be discovered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 进行测试的原因有很多，但至少有两个原因我们必须提到。一个是寻找错误并尽可能多地创建无错误代码。另一个是证明应用程序是可用的，并且可以用于其预期目的。从企业角度来看，这很重要，并考虑了许多单元测试没有考虑的方面。虽然单元测试专注于一个单元，因此是指出错误位置的极好工具，但在发现来自模块之间错误接口的错误时，它完全不可用。单元测试模拟外部模块，因此测试单元是否按预期工作。然而，如果这个期望有错误，并且其他模块的行为与单元测试模拟不同，错误将不会被发现。
- en: To discover the errors on this level, which is the next level above unit test,
    we have to use integration tests. During integration tests, we test how individual
    units can work together. When we program in Java, the units are usually classes;
    thus, the integration test will test how the different classes work together.
    While there is a consensus (more or less) about what a unit test is in Java programming,
    this is less so in the case of integration tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现这个层次上的错误，这是单元测试之上的下一个层次，我们必须使用集成测试。在集成测试期间，我们测试单个单元如何协同工作。当我们用Java编程时，单元通常是类；因此，集成测试将测试不同的类如何协同工作。虽然关于Java编程中的单元测试有一个共识（或多或少），但在集成测试的情况下则不然。
- en: In this regard, the external dependencies, such as other modules reachable via
    the network or database layers may be mocked, or may be set up using some test
    instance during integration testing. The argument is not about whether these parts
    should be mocked or not, only the terminology. Mocking some components such as
    the database has advantages as well as drawbacks. As in the case of any mock,
    the drawback is the cost of setting up the mock as well as the fact that the mock
    behaves differently from the real system. Such a difference may result in some
    bugs still remaining in the system and lurking there until a later case of testing
    or, God forgive, production is used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，外部依赖项，例如通过网络或数据库层可访问的其他模块，可能被模拟，或者可以在集成测试期间使用某些测试实例来设置。这个论点并不是关于这些部分是否应该被模拟，而仅仅是术语问题。模拟某些组件，如数据库，既有优点也有缺点。就像任何模拟一样，缺点是设置模拟的成本以及模拟的行为与真实系统不同。这种差异可能会导致系统中仍然存在一些错误，直到后来的测试案例或，愿上帝宽恕，在生产中使用时才会被发现。
- en: Integration tests are usually automated in a way similar to unit tests. However,
    they usually require more time to execute. This is the reason why these tests
    are not executed at each source code change. Usually, a separate maven or Gradle
    project is created that has a dependency on the application JAR and contains only
    integration test code. This project is usually compiled and executed daily.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常以类似于单元测试的方式自动化。然而，它们通常需要更多的时间来执行。这就是为什么这些测试不是在每次源代码更改时都执行的原因。通常，会创建一个单独的maven或Gradle项目，该项目依赖于应用程序JAR，并且只包含集成测试代码。这个项目通常每天编译和执行一次。
- en: It may happen that daily execution is not frequent enough to discover the integration
    issues in a timely manner, but a more frequent execution of the integration tests
    is still not feasible. In such a case, a subset of the integration test cases
    is executed more frequently, for example, every hour. This type of testing is
    called smoke testing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生的情况是，日常执行并不频繁，无法及时发现集成问题，但更频繁地执行集成测试仍然不可行。在这种情况下，会更频繁地执行集成测试用例的子集，例如，每小时一次。这种测试称为冒烟测试。
- en: 'The following diagram shows the position of the different testing types:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了不同测试类型的定位：
- en: '![](img/00066.gif)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.gif)'
- en: When the application is tested in a fully set up environment, the testing is
    called system testing. Such testing should discover all the integration bugs that
    may have been lurking and covered during the previous testing phases. The different
    type of system tests can also discover non-functional issues. Both functional
    testing and performance testing are done on this level.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在完全设置的环境中测试时，这种测试称为系统测试。这种测试应该发现之前测试阶段中潜伏和覆盖的所有集成错误。不同类型的系统测试也可以发现非功能性问题。功能测试和性能测试都在这个层面上进行。
- en: Functional testing checks the functions of the application. It ensures that
    the application functions as expected or at least has functions that are worth
    installing in the production environment and can lead to cost saving or profit
    increase. In real life, programs almost never deliver all the functions that were
    envisioned in any requirement documentation, but if the program is usable in a
    sane manner, it is worth installing it, assuming that there are no security issues
    or other issues.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试检查应用程序的功能。它确保应用程序按预期工作，或者至少具有在生产环境中安装的功能，可以导致成本节约或利润增加。在现实生活中，程序几乎从未实现任何需求文档中设想的所有功能，但如果程序以合理的方式可用，则值得安装，前提是没有安全问题或其他问题。
- en: In case there are a lot of functions in the application, functional testing
    may cost a lot. In such a case, some companies perform a sanity test. This test
    does not check the full functionality of the application, only a subset to ensure
    that the application reaches a minimal quality requirement and it is worth spending
    the money on the functional testing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序中有许多功能，功能测试可能会花费很多。在这种情况下，一些公司会进行合理性测试。这种测试并不检查应用程序的全部功能，而只是检查一部分，以确保应用程序达到最低质量要求，并且值得在功能测试上花钱。
- en: There may be some test cases that are not envisioned when the application was
    designed and thus there is no test case in the functional test plan. It may be
    some weird user action, a user pressing a button on the screen when nobody thought
    it was possible. Users, even if benevolent, happen to press or touch anything
    and enter all possible unrealistic inputs into a system. Ad-hoc testing tries
    to amend this shortage. A tester during ad-hoc testing tries all the possible
    ways of use of the application that he or she can imagine at the moment the test
    is executed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一些在设计应用程序时未设想到的测试用例，因此在功能测试计划中没有相应的测试用例。这可能是一些奇怪的用户行为，例如，当没有人认为可能时，用户按下屏幕上的按钮。用户，即使心地善良，也可能按下或触摸任何东西，并将所有可能的不切实际输入输入到系统中。即兴测试试图弥补这种不足。在即兴测试期间，测试人员尝试所有可能的、在测试执行时他能想象到的应用程序使用方式。
- en: This is also related to security testing, also called penetration testing when
    the vulnerabilities of the system are discovered. These are special types of tests
    that are performed by professionals who have their core area of expertise in security.
    Developers usually do not have that expertise, but at least, the developers should
    be able to discuss issues that are discovered during such a test and amend the
    program to fix the security holes. This is extremely important in the case of
    Internet applications.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这也与安全测试相关，当发现系统的漏洞时，也称为渗透测试。这些是专业人员进行的专业测试，他们的核心专业领域是安全。开发者通常没有这种专业知识，但至少，开发者应该能够讨论在测试期间发现的问题，并修改程序以修复安全漏洞。这在互联网应用程序的情况下尤为重要。
- en: Performance testing checks that the application, in a reasonable environment,
    can handle the expected load that the user puts on the system. A load test emulates
    the users who attack the system and measures the response times. If the response
    time is appropriate, that is, lower than the required maximum under the maximum
    load, then the test passes; otherwise, it fails. If a load test fails, it is not
    necessarily a software error. It may so happen that the application needs more
    or faster hardware. Load tests usually test the functionality of the application
    in only a limited way and only test use scenarios that pose read load on the application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试检查应用程序在合理的环境下能否处理用户对系统施加的预期负载。负载测试模拟攻击系统的用户并测量响应时间。如果响应时间合适，即低于最大负载下的所需最大值，则测试通过；否则，测试失败。如果负载测试失败，并不一定是软件错误。可能的情况是应用程序需要更多或更快的硬件。负载测试通常只以有限的方式测试应用程序的功能，并且只测试对应用程序产生读负载的使用场景。
- en: 'Many years ago, we were testing a web application that had to have a response
    time of 2 seconds. The load test was very simple: issue `GET` requests so that
    there are a maximum of 10,000 requests active at the same time. We started with
    10 clients, and then a script was increasing the concurrent users to 100, then
    1,000, and then stepping up by thousand every minute. This way, the load test
    was 12 minutes long. The script printed the average response time, and we were
    ready to execute the load test at 4:40 pm on a Friday.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，我们正在测试一个必须达到2秒响应时间的Web应用程序。负载测试非常简单：发出`GET`请求，使得同时最多有10,000个请求处于活动状态。我们开始时使用10个客户端，然后一个脚本将并发用户数增加到100，然后是1,000，之后每分钟增加1,000。这样，负载测试持续了12分钟。脚本打印出平均响应时间，我们准备在周五下午4:40执行负载测试。
- en: The average response time started from a few milliseconds and went up to 1.9
    seconds as the load was increased to 5,000 concurrent users, and from there, it
    was descending down to 1 second as the load was increased to 10,000 users. You
    can understand the attitude of the people on a Friday afternoon, being happy that
    we met the requirements. My colleagues left for the weekend happily. I remained
    testing a bit more because I was bothered by the phenomenon that the response
    time decreases as we increase the load above 5,000\. First, I reproduced the measurement
    and then started looking at the log files. At 7 pm, I already knew what the reason
    was.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 随着负载增加到5,000个并发用户，平均响应时间从几毫秒上升到1.9秒，然后随着负载增加到10,000用户，从那里下降到1秒。你可以理解周五下午人们的态度，因为我们的要求得到了满足而感到高兴。我的同事们高兴地离开了周末。我继续测试了一段时间，因为我被这样一个现象所困扰：当负载增加到5,000以上时，响应时间会下降。首先，我重复了测量，然后开始查看日志文件。晚上7点，我已经知道了原因。
- en: When the load went above 5,000, the connections the Apache server was managing
    started to exhaust and the web server started to send back 500 internal error
    codes. That is something that Apache can very effectively do. It is very fast
    in telling you that you cannot be served. When the load was around 10,000 concurrent
    users, 70% of the responses already had 500 errors. The average went down, but
    the users were actually not served. I reconfigured the Apache server so that it
    could serve all the requests and forward each to our application just to learn
    that the response time of our application was around 10 seconds at the maximum
    load. Around 10 pm, when my wife was calling my mobile the third time, I also
    knew how large a memory I should set in the Tomcat startup file in the options
    for the JVM to get the desired 2-second response time in case of 10,000 concurrent
    users.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当负载超过5,000时，Apache服务器管理的连接开始耗尽，Web服务器开始返回500内部错误代码。这是Apache可以非常有效地做到的事情。它非常快地告诉你你无法被服务。当负载大约为10,000个并发用户时，70%的响应已经出现了500错误。平均响应时间下降了，但实际上用户并没有得到服务。我重新配置了Apache服务器，使其能够处理所有请求并将每个请求转发到我们的应用程序，只是为了了解在最大负载下我们的应用程序的响应时间大约是10秒。大约晚上10点，当我的妻子第三次给我打电话时，我也知道了在JVM启动文件中为Tomcat设置多大的内存才能在10,000个并发用户的情况下获得所需的2秒响应时间。
- en: Stress test is also a type of performance test that you may also face. This
    type of test increases the load on the system until it cannot handle the load.
    That test should ensure that the system can recover from the extreme load automatically
    or manually but, in no case, will do something that it shouldn't at all. For example,
    a baking system should not ever commit an unconfirmed transaction, no matter how
    big the load there is. If the load is too high, then it should leave the dough
    raw but should not bake extra bread.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试也是一种你可能遇到的性能测试类型。这种测试会增加系统负载，直到系统无法处理。这个测试应该确保系统能够自动或手动从极端负载中恢复，但在任何情况下，都不应该做它不应该做的事情。例如，烘焙系统永远不应该提交未确认的交易，无论负载有多大。如果负载过高，那么它应该让面团保持原样，但不应该烤出额外的面包。
- en: The most important test at the top of the hierarchy is the user acceptance test.
    This is usually an official test that the customer, who buys the software, executes
    and in the case of successful execution, pays the price for the software. Thus,
    this is extremely important in professional development.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中最重要的测试是用户验收测试。这通常是一个官方测试，由购买软件的客户执行，如果执行成功，客户将支付软件的费用。因此，这在专业开发中非常重要。
- en: Test automation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Tests can be automated. It is not a question of whether it is possible to automatize
    a test, only whether it is worth doing so. Unit tests and integration tests are
    automated, and as time advances, more and more tests get automated as we move
    along to higher steps towards the **user acceptance test** (**UAT**). UAT is not
    likely to be automated. After all, this test checks the integration between the
    application and the user. While the user, as an external module, can be mocked
    using automation in lower levels, we should reach the level when the integration
    test happens without mocks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以自动化。这不是一个是否能够自动化测试的问题，而是一个是否值得这样做的问题。单元测试和集成测试已经自动化，随着时间的推移，越来越多的测试在向更高层次的**用户验收测试**（**UAT**）迈进的过程中被自动化。UAT不太可能被自动化。毕竟，这个测试检查的是应用程序与用户之间的集成。虽然用户作为一个外部模块，可以在较低级别使用自动化进行模拟，但我们应该达到集成测试发生时无需模拟的水平。
- en: There are many tools that help the automation of tests. The blocker for test
    automation, these days, is the cost of the tools to do so, the cost of learning
    and developing the tests, and the fear that the automated tests are not discovering
    some of the errors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助测试自动化。目前，测试自动化的障碍是进行测试的工具成本、学习和开发测试的成本，以及担心自动测试可能没有发现一些错误。
- en: It is true that it is easier to do something wrong with a program than without.
    This is so true for almost anything not only for testing. And still we do use
    programs; why else would you read this book? Some of the errors may not be discovered
    during automated functional testing, which would otherwise have been discovered
    using manual tests. At the same time, when the same test is executed the hundredth
    time by the same developer, it is extremely easy to skip an error. An automated
    test will not ever do that. And most importantly, the cost of the automated test
    is not 100 times the cost of running it once.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，用程序做错事情比不用程序更容易。这一点对于几乎所有的事情都适用，不仅仅是测试。尽管如此，我们仍然在使用程序；否则，你为何要读这本书？一些错误可能在自动功能测试中没有被发现，而这些错误本可以通过手动测试发现。同时，当同一个测试由同一个开发者执行第一百次时，很容易忽略一个错误。自动测试永远不会这样做。最重要的是，自动测试的成本并不是运行一次的成本的100倍。
- en: We have used test automation tools in this book. **SoapUI** is a tool that helps
    you create tests that can be executed automatically. Other testing tools that
    are worth looking at are **Cucumber**, **Concordion**, **Fintnesse**, and **JBehave**.
    There is a good comparison of tools at [https://www.qatestingtools.com/](https://www.qatestingtools.com/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中使用了测试自动化工具。**SoapUI**是一个帮助你创建可以自动执行的测试的工具。其他值得关注的测试工具有**Cucumber**、**Concordion**、**Fintnesse**和**JBehave**。在[https://www.qatestingtools.com/](https://www.qatestingtools.com/)上有一个很好的工具比较。
- en: Black box versus white box
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑盒与白盒
- en: 'You may have heard many times that a test is a black box test. This simply
    means that the test does not know anything about how the system under test (SUT)
    is implemented. The test relies only on the interface of the SUT that is exported
    for the outside world. A white box test, on the other end of the scale, tests
    the internal working of the SUT and very much relies on the implementation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能多次听说过测试是黑盒测试。这仅仅意味着测试不知道关于被测试系统（SUT）是如何实现的任何信息。测试仅依赖于SUT对外界公开的接口。在测试的另一端，白盒测试测试SUT的内部工作，并且非常依赖于实现：
- en: '![](img/00067.gif)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00067.gif)'
- en: Both the approaches have advantages and disadvantages. We should use one, or
    the mixture of the two approaches, a way that fits the purpose of the actual testing
    needs the most. A black box test not relying on the implementation does not need
    to change if the implementation changes. If the interface of the tested system
    changes, then the test should also be changed. A white box test may need changes
    if the implementation changes, even if the interface remains the same. The advantage
    of the white box test is that, many times, it is easier to create such a test
    and the testing can be more effective.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有优点和缺点。我们应该选择其中一种，或者两种方法的混合，最符合实际测试需求的方法。一个不依赖于实现的黑盒测试，如果实现发生变化，则不需要改变。如果被测试系统的接口发生变化，那么测试也应该随之改变。白盒测试在实现发生变化时可能需要改变，即使接口保持不变。白盒测试的优势在于，很多时候，创建这样的测试更容易，测试也可以更有效。
- en: 'To get the best of both worlds, systems are designed to be testable. Be careful,
    though. It means many times that the functionality internal to the tested system
    is propagated to the interface. That way, the test will use only the interface
    and, thus, can be declared to be a black box, but it does not help. If something
    changes in the internal working of the tested system, the test has to follow it.
    The only difference is that you may call it a black box test if the interface
    also changes. That does not save any work. Rather, it increases it: we have to
    check all the modules that rely on the interface if they also need any change.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼得两者之利，系统被设计成可测试的。但要注意，这意味着很多时候，被测试系统内部的函数被传播到接口。这样，测试将仅使用接口，因此可以声明为黑盒，但这并没有帮助。如果被测试系统的内部工作发生变化，测试必须跟随它。唯一的区别是，如果你认为接口也发生了变化，你可以称之为黑盒测试。这并不会节省任何工作，反而会增加工作量：我们必须检查所有依赖于接口的模块，看看它们是否也需要任何更改。
- en: I do not say that we should not pay attention to creating testable systems.
    Many times making a system testable results in cleaner and simpler code. If the
    code, however, gets messier and much longer because we want to make it testable,
    then we are probably not going in the right way.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说我们不应该注意创建可测试的系统。很多时候，使系统可测试会导致代码更干净、更简单。然而，如果代码因为我们要使其可测试而变得杂乱无章且过长，那么我们可能没有走对路。
- en: Selecting libraries
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择库
- en: Programming for the enterprise or even programming a moderately sized project
    cannot be done without the use of external libraries. In the Java world, most
    of the libraries that we use are open source and, more or less, free to use. When
    we buy a library that is sold for money, there is usually a standard process enforced
    by the purchasing department. In such a case, there is a written policy about
    how to select the vendor and the library. In the case of "free" software, they
    do not usually care, though they should. In such a case, the selection process
    mainly lies with the IT department and it is therefore important to know the major
    points to be considered before selecting a library even if for free.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为企业编程或甚至为一个中等规模的项目编程，没有使用外部库是不可能的。在Java领域，我们使用的多数库都是开源的，或多或少是免费使用的。当我们购买需要付费的库时，通常由采购部门强制执行一个标准流程。在这种情况下，有一个关于如何选择供应商和库的书面政策。在“免费”软件的情况下，他们通常不太关心，尽管他们应该关心。在这种情况下，选择过程主要取决于IT部门，因此了解在选择库之前需要考虑的主要因素非常重要，即使对于免费软件也是如此。
- en: In the previous paragraph, I put the word free between quotes. That is because
    there is no software, which is free. There is no such thing as a free lunch, as
    they say. You have heard this many times but it may not be obvious in the case
    of an open source code library or framework you are going to select. The major
    selection factor for any purchase or implementation is the cost, the price. If
    the software is free, it means that you do not need to pay an upfront fee for
    the software. However, there is a cost in integrating it and using it. Support
    costs money. Somebody may say that the support is community support and also available
    free of charge. The thing is that the time you spend hunting for a workaround
    that helps you to get over a bug is still money. It is your time, or in case you
    are a manager, it is the time of the professional in your department whose time
    you pay for, or, as a matter of fact, it can be an external contractor who will
    hand you a huge bill in case you do not have the expertise in-house to solve the
    issue.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段中，我把“免费”这个词放在了引号里。这是因为没有软件是免费的。正如他们所说，没有免费的午餐。你听过很多次，但在你将要选择的开源代码库或框架的情况下可能并不明显。任何购买或实施的最重要的选择因素是成本，即价格。如果软件是免费的，这意味着你不需要为软件支付预付费。然而，集成和使用它是有成本的。支持需要花钱。有人可能会说，支持是社区支持，也是免费的。问题是，你花费寻找解决方案以帮助你克服错误的时间仍然是钱。这是你的时间，或者如果你是经理，这是你部门的专业人员的时间，你为他们支付的时间，或者，实际上，它可能是一个外部承包商，如果你内部没有解决这个问题的专业知识，他将会给你开一张大账单。
- en: Since free software does not have a price tag attached, we have to look at the
    other factors that are important in the selection process. At the end of the day,
    they all will affect the cost in some way. Sometimes, the way a criterion alters
    the cost is not obvious or easily calculable. However, for each one, we can set
    no-go levels that are based on technology decisions, and we can compare libraries
    for being better or worse along with each of the criteria.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于免费软件没有价格标签，我们在选择过程中必须考虑其他重要因素。最终，它们都会以某种方式影响成本。有时，一个标准如何改变成本并不明显或难以计算。然而，对于每一个，我们都可以设定基于技术决策的不可接受水平，并且我们可以比较库在各个标准上的优劣。
- en: Fit for the purpose
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适合目的
- en: Perhaps, this is the most important factor. Other factors may be argued about
    in terms of the scale of importance, but if a library is not appropriate for the
    purpose we want to use, then this is certainly not something to select, no matter
    what. It may be obvious in many cases, but you may be surprised how many times
    I have seen a product selected because it was the favorite of a person in some
    other project and the library was forced for use in the new project even though
    the requirements were totally different.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，这是最重要的因素。其他因素可能在重要性规模上存在争议，但如果一个库不适合我们想要使用的目的，那么这绝对不是我们应该选择的东西，无论什么情况。在很多情况下，这可能是显而易见的，但你可能会惊讶于我见过多少次因为某个产品是其他项目的宠儿，而该库被强制用于新项目，尽管需求完全不同。
- en: License
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许可证
- en: The license is an important question as not all free software is free for all
    uses. Some of the licenses allow free use for hobby projects and education but
    require you to purchase the software for professional, profit-oriented use.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证是一个重要的问题，因为并非所有免费软件都对所有用途免费。一些许可证允许免费用于爱好项目和教育活动，但要求你在专业、盈利性使用时购买软件。
- en: The most widely used licenses and their explanation (and the whole text of the
    license) is available on the web page of the **Open Source Initiative** ([https://opensource.org/licenses](https://opensource.org/licenses)).
    It lists nine different licenses, and to make the situation a bit more complex,
    these licenses have versions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的许可证及其解释（以及许可证的全文）可在开源倡议组织的网页上找到（[https://opensource.org/licenses](https://opensource.org/licenses)）。它列出了九种不同的许可证，为了使情况更加复杂，这些许可证还有版本。
- en: 'One of the oldest licenses is the **General Public License** (**GPL**) standing
    for GNU. This license contains the following sentences:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最古老的许可证之一是代表GNU的**通用公共许可证**（**GPL**）。此许可证包含以下句子：
- en: For example, if you distribute copies of such a program, whether gratis or for
    a fee, you must pass on to the recipients the same freedoms that you received.
    You must make sure that they, too, receive or can get the source code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你分发此类程序的副本，无论是免费还是付费，你必须将你收到的相同自由传递给接收者。你必须确保他们也能收到或获取源代码。
- en: If you create software for a for-profit enterprise and the company intends to
    sell software, you probably cannot use any line of code that is from a GPL-licensed
    software. It would imply that you are required to pass on your own source code,
    which may not be the best sales strategy. Apache license, on the other hand, may
    be okay for your company. This is something that the lawyers should decide.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为盈利企业创建软件，并且公司打算销售软件，你可能不能使用任何来自GPL许可软件的代码行。这可能意味着你必须传递你自己的源代码，这可能不是最好的销售策略。另一方面，Apache许可证可能适合你的公司。这是律师应该决定的事情。
- en: Even though this is the lawyers' work, there is one important point that we
    developers must be aware of and pay close attention to. Sometimes, the libraries
    contain code from other projects and their license, as advertised, may not be
    the real one. A library may be distributed under the Apache license but contains
    code that is GPL-licensed. This is obviously a violation of the GPL license, which
    was committed by some open source developers. Why would you care? Here comes the
    explanation via an imagined situation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是律师的工作，但有一个重要的观点，我们作为开发者必须意识到并密切关注。有时，库包含来自其他项目的代码，其许可证，如广告中所说，可能不是真实的。一个库可能在Apache许可证下分发，但包含GPL许可的代码。这显然是违反GPL许可证的行为，这是由一些开源开发者犯下的。你为什么会关心？下面通过一个想象的情况来解释。
- en: You develop software for an enterprise. Let's say that this company is one of
    the largest car manufacturers of the world, or it is one of the largest banks,
    pharma, whatever. The owner of the GPL software seeks remedies for the misuse
    of her software. Will she sue the software developer, John Doe, who has a total
    wealth of 200K, or your company, claiming that you did not duly check the license
    of the code? She certainly will not dig for gold where there is none. Suing the
    company you work for may not be successful, but certainly not a good process you
    or anyone at the company wants.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你为一家企业开发软件。假设这家公司是世界上最大的汽车制造商之一，或者是一家最大的银行、制药公司，等等。GPL软件的所有者寻求对其软件滥用的补救措施。她会起诉拥有20K总财富的软件开发者John
    Doe，还是起诉你的公司，声称你没有妥善检查代码的许可证？她当然不会在没有金子的地方挖金子。起诉你所在的公司可能不会成功，但这绝对不是你或公司任何人都希望的过程。
- en: What can we as software professionals do?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为软件专业人士能做什么？
- en: We have to use libraries that are well known, used widely. We can check the
    source code of the library to see whether there is some copied code. Some package
    names may present some clue. You can Google some part of the source code to find
    matches. Last but not least, the company can subscribe to services that provide
    similar research for the libraries.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用广为人知、广泛使用的库。我们可以检查库的源代码，看看是否有抄袭的代码。一些包名可能提供一些线索。你可以通过谷歌搜索源代码的一部分来找到匹配项。最后但同样重要的是，公司可以订阅提供类似研究的库的服务。
- en: Documentation
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: Documentation is an important aspect. If the documentation is not appropriate,
    it will be hard to learn how to use the library. Some of the team members may
    have already known the library, but, again, this may not be the case for later
    team members. We should consider our colleagues, who are expected to be average
    programmers, and they will have to learn the use of the library. Thus documentation
    is important.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是一个重要的方面。如果文档不合适，将很难学习如何使用这个库。一些团队成员可能已经了解这个库，但再次强调，这可能并不适用于后来的团队成员。我们应该考虑我们的同事，他们预计是平均程序员，他们将不得不学习库的使用。因此，文档非常重要。
- en: When we speak about documentation, we should not only think about the *JavaDoc*
    reference documentation but also tutorials and books if they are available.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论文档时，我们不仅应该考虑*JavaDoc*参考文档，如果有的话，还应该考虑教程和书籍。
- en: Project alive
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目活跃
- en: It is important not to select a library for use that is not alive. Have a look
    at the roadmap of the library, the last time a release was shipped, and the frequency
    of the commits. If the library is not alive, we should consider not using it.
    Libraries work in an environment and the environment changes. The library may
    connect to a database. The new version of the database may provide new features
    that give us better performance only if the library is modified to accommodate
    these new features. The library communicates over HTTP; will it support the new
    2.0 version of the protocol? If nothing else, the version of the Java environment
    will change over the years and the library we use should sooner or later follow
    it to leverage the new features.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要选择一个不活跃的库来使用。看看库的路线图，最后一次发布的时间，以及提交的频率。如果一个库不活跃，我们应该考虑不使用它。库在一个环境中工作，环境会发生变化。库可能连接到数据库。如果库被修改以适应这些新功能，数据库的新版本可能只提供给我们更好的性能。库通过HTTP进行通信；它是否会支持新的2.0版本协议？至少，Java环境的版本会在几年内发生变化，我们使用的库迟早应该跟随它以利用新功能。
- en: There is no guarantee that an alive library will always stay alive. However,
    a library that is already dead will certainly not resurrect.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证一个活跃的库会一直保持活跃。然而，一个已经死亡的库肯定不会复活。
- en: Even if the project is alive at the moment, there are some points that may give
    some hints about the future of the library. If the company developing it is well-established
    and financially stable, and the library is developed with a reasonable business
    model, then there is a low risk that the project dies. If there are a lot of companies
    who use the library, then it is likely that the project will stay alive even if
    the original team stops working on it or the original financing structure changes.
    However, these are only small factors and not well-established facts. There is
    no guarantee, and telling the future is more an art than a science.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 即使项目目前是活跃的，也有一些可能预示着库未来发展的线索。如果开发该公司的建立稳固且财务状况良好，并且库是以合理的商业模式开发的，那么项目死亡的风险很低。如果有许多公司使用该库，那么即使原始团队停止工作或原始融资结构发生变化，项目也很可能保持活跃。然而，这些只是小因素，并不是确凿的事实。没有保证，预测未来更多的是艺术而非科学。
- en: Maturity
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成熟度
- en: Maturity is similar to the previous criterion. A project may very well be alive
    just starting up, but if it is in its infancy, we better not use the library for
    a large project. When a project is in its early phase, a lot of bugs can be in
    the code, the API may change radically, and presumably, there may only be a small
    number of companies relying on the code. This also means that the community support
    is lower.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟度与之前的标准类似。一个项目可能非常好地处于起步阶段，但如果它处于婴儿期，我们最好不要在大型项目中使用该库。当一个项目处于早期阶段时，代码中可能会有很多错误，API可能会发生根本性的变化，并且可能只有少数公司依赖该代码。这也意味着社区支持较低。
- en: Of course, if all the projects select only mature open source code, then no
    open source project would ever get to the mature state. We should assess the importance
    of the project. Is the project business-critical? Will the project become business-critical?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果所有项目只选择成熟的开源代码，那么没有任何开源项目会达到成熟状态。我们应该评估项目的重要性。项目是否是业务关键性的？项目是否会变得业务关键性？
- en: If the project is not business-critical, the company may afford to invent a
    fresh library that is not that mature. It may be reasonable if there are no mature
    libraries for the purpose because the technology you are going to use is relatively
    new. In such a case, the project in the company is probably also new and not business-critical
    yet. It will be business-critical, we hope, after some time, but by that time,
    the library will be mature, or may just die and we can select a competing solution
    before the project becomes too expensive to switch.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目不是业务关键性的，公司可能负担得起发明一个不那么成熟的全新库。如果没有成熟的库可用，因为你要使用的科技相对较新，这可能是有道理的。在这种情况下，公司中的项目可能也是新的，并且目前还不是业务关键性的。我们希望，在一段时间后，它将成为业务关键性的，但到那时，库将变得成熟，或者可能只是死亡，我们可以在项目变得过于昂贵之前选择一个竞争性解决方案。
- en: Judging the maturity of a library is always difficult and has to be aligned
    with the maturity and importance of the project that we want to use the library
    for.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个库的成熟度总是困难的，并且必须与我们要使用该库的项目成熟度和重要性相一致。
- en: Number of users
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户数量
- en: If the library is alive and mature but there are not many users, then something
    is smelly. Why don't people use the library if it is good? If the number of users
    for a library or framework is low and there are no large corporations among the
    users, then it is probably not a good one. Nobody using it may signal that our
    assessment of the other criteria may not be appropriate.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库活跃且成熟，但用户不多，那么就有问题。为什么人们不喜欢一个好的库呢？如果一个库或框架的用户数量很少，且用户中没有大型企业，那么它可能不是一个好的选择。没有人使用它可能意味着我们对其他标准的评估可能不合适。
- en: Also note that if there are only a few users of the library, then the knowledge
    in the community is also scarce and we may not be able to get community support.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果库的用户很少，那么社区中的知识也很稀缺，我们可能无法获得社区支持。
- en: The "I like it" factor
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “我喜欢它”这个因素
- en: Last but not least, the *I like it* factor is extremely important. The question
    is not whether you like the library but rather how much the developers like it.
    Developers will like a library that is easy to use and fun to work with, and this
    will result in low cost. If the library is hard to use and developers do not like
    it, then they will not learn to use it to the level of profession required for
    good quality, only to the level that is just needed. The end result will be suboptimal
    software.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，*我喜欢它*这个因素极其重要。问题不在于你是否喜欢这个库，而在于开发者有多喜欢它。开发者会喜欢易于使用且工作愉快的库，这将导致成本降低。如果库难以使用且开发者不喜欢它，那么他们不会学习到达到高质量所需的专业水平，而只会达到基本需求水平。最终结果将是次优的软件。
- en: Continuous integration and deployment
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和部署
- en: Continuous integration means that whenever a new version is pushed to the source
    code repository, the continuous integration server kicks in, pulls the code to
    its disk, and starts the build. It compiles the code first, then runs the unit
    tests, fires the static code analysis tools, and, if all goes right, it packages
    a snapshot release and deploys it on a development server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成意味着每当有新版本推送到源代码仓库时，持续集成服务器就会启动，将代码拉到其磁盘上，并开始构建。它首先编译代码，然后运行单元测试，启动静态代码分析工具，如果一切顺利，它将打包快照版本并在开发服务器上部署。
- en: CI servers have web interfaces that can be used to create a release. In such
    a case, the deployment can even go to the test servers or even to production depending
    on local business needs and on the policy that was created accordingly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: CI服务器有网络界面，可以用来创建发布。在这种情况下，部署甚至可以到测试服务器，甚至根据本地业务需求和相应创建的政策部署到生产环境。
- en: 'Automating the build and deployment process has the same advantages as any
    other automation: repeated tasks can be performed without manual intervention,
    which is tedious, boring, and, thus, error-prone if done by a human. The outstanding
    advantage is that if there is some error in the source code that can be discovered
    by the automated build process, it will be discovered. Novice developers say that
    it is cheaper and easier to build the code locally, which the developers do anyway,
    and then push the code to the server if the build process is already checked.
    It is partly true. Developers have to check that the code is of good quality and
    builds well, before sending it to the central repo. However, this cannot always
    be achieved. Some errors may not manifest on local environments.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化构建和部署过程与其他自动化一样具有相同的优势：重复的任务可以在没有人工干预的情况下执行，这既繁琐又无聊，如果由人来完成，则容易出错。突出的优势是，如果源代码中存在自动化构建过程可以发现的错误，那么它将被发现。新手开发者说，在本地构建代码更便宜、更容易，开发者通常也会这样做，如果构建过程已经过检查，那么只需将代码推送到服务器即可。这在一定程度上是正确的。在将代码发送到中央仓库之前，开发者必须检查代码的质量良好且构建良好。然而，这并不总是能够实现。一些错误可能不会在本地环境中表现出来。
- en: It may so happen that one developer accidentally uses a newer version of Java
    than the one supported and uses a new feature of the new version. Enterprises
    do not generally use the latest technology. They tend to use versions that are
    proven, have many users, and are mature. This year, in 2017, when Java 9 is going
    to be released in July, huge enterprises still use Java 1.6 and 1.7\. Since Java
    9 has many new features that are not trivial to implement, I expect that the adoption
    of the technology may take even longer than the adoption of Java 1.8, which gave
    us functional programming and lambda.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能发生这样的情况，一位开发者不小心使用了比支持版本更新的Java新版本，并使用了新版本的新特性。企业通常不会使用最新的技术。他们倾向于使用经过验证、用户众多且成熟的版本。今年，2017年，当Java
    9计划在7月份发布时，大型企业仍在使用Java 1.6和1.7。由于Java 9有许多新特性，这些特性并非易事实现，我预计技术的采用可能比Java 1.8的采用时间更长，Java
    1.8为我们带来了函数式编程和lambda表达式。
- en: It may also happen that a new library is added to the dependencies of the build
    and the developer who added it to the build file (`pom.xml`, or `build.gradle`)
    could use it without any problem on her local machine. It does not mean that the
    library is officially added to the project, and it may not be available in the
    central code repository (Artifactory, Nexus, or other implementations of the code
    repository). The library may have only been on the local repository of the developer,
    and she may have assumed that since the code compiles, the build is OK.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能发生这样的情况，一个新的库被添加到构建的依赖中，而添加它到构建文件（`pom.xml`或`build.gradle`）的开发者可以在她的本地机器上无任何问题地使用它。这并不意味着库被正式添加到项目中，它可能不在中央代码仓库（Artifactory、Nexus或其他代码仓库的实现）中。这个库可能只存在于开发者的本地仓库中，她可能认为既然代码可以编译，构建就是好的。
- en: Some large organizations use different code repositories for different projects.
    The libraries get into these repositories following meticulous examination and
    decisions. Some libraries may get there, while others may not. The reason to have
    different repositories could be numerous. Some project is developed for one customer
    who has a different policy about an open source project than the other. If the
    enterprise develops code for itself, it may so happen that some library is phased
    out or not supported anymore, and can only be used for projects that are old.
    A maintenance release may not need to replace a library, but new projects may
    be not be allowed to use a dying software library.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一些大型组织为不同的项目使用不同的代码仓库。库在经过细致的审查和决策后进入这些仓库。一些库可能进入其中，而另一些可能不会。拥有不同仓库的原因可能有很多。有些项目是为一个客户开发的，这个客户对开源项目的政策与其他客户不同。如果企业为自己开发代码，可能发生某些库被淘汰或不再支持的情况，并且只能用于旧项目。维护版本可能不需要替换库，但新项目可能不允许使用即将淘汰的软件库。
- en: The CI server can run on a single machine or it can run on several machines.
    In case it serves many projects, it may be set up as a central server with many
    agents running on different machines. When some build process has to be started,
    the central server delegates this task to one of the agents. The agents may have
    different loads, running several different build processes, and may have different
    hardware configuration. The build process may have requirements regarding the
    speed of the processor or about the available memory. Some agent may run simpler
    builds for smaller projects but would fail to execute the build of a large project
    or of some small project that still has a huge memory requirement to execute some
    tests.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: CI服务器可以运行在一台机器上，也可以运行在多台机器上。如果它服务于许多项目，它可能被设置为一个中央服务器，有多个代理在不同的机器上运行。当某个构建过程需要启动时，中央服务器将这个任务委托给一个代理。代理可能有不同的负载，运行几个不同的构建过程，并且可能有不同的硬件配置。构建过程可能有关于处理器速度或可用内存的要求。某些代理可能运行较小项目的简单构建，但可能无法执行大型项目的构建或某些小型项目的构建，这些小型项目仍然有巨大的内存需求来执行一些测试。
- en: When a build fails, the build server sends out e-mails to the developers, and
    the person who sent the last update to the code repository is obligated to fix
    the bug without delay. This encourages the developers to commit frequently. The
    smaller the change, the fewer chances there are of a build problem. The build
    server web interface can be used to see the actual state of the projects, which
    project is failing to build, and which is just fine. If a build fails, there is
    a red sign in the line of the build, and if the build is OK, the sign is green.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建失败时，构建服务器会向开发者发送电子邮件，并且最后向代码库发送更新的人有义务立即修复错误。这鼓励开发者频繁提交。更改越小，构建问题的可能性就越小。构建服务器网络界面可以用来查看项目的实际状态，哪个项目构建失败，哪个项目构建正常。如果构建失败，构建行上会有红色标志，如果构建正常，标志是绿色的。
- en: Many times, these reports are continually displayed on some old machine using
    a huge display so that every developer or just anybody who enters the room can
    see the actual state of the builds. There is even special hardware that you can
    buy that has red, yellow, and green lamps to follow the state of the build and
    ring a bell when the build fails.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，这些报告会持续显示在一些旧机器上，使用大屏幕，以便每个进入房间的人都能看到构建的实际状态。甚至还有专门的硬件可以购买，它有红色、黄色和绿色的灯来跟踪构建状态，并在构建失败时响起铃声。
- en: Release management
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布管理
- en: Developing software means a continuously changing code base. Not every version
    of the software is supposed to be installed in production. Most of the versions
    are pushed to the repository on a branch half complete. Some versions are meant
    only for testing and a few are meant to be installed in production even if only
    some of those will finally get to production.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 开发软件意味着代码库持续变化。并非每个软件版本都应安装在生产环境中。大多数版本都推送到分支上的半完成状态。有些版本仅用于测试，而只有少数版本打算安装在生产环境中，即使最终只有其中一些会进入生产。
- en: Almost all the time, the releases follow the semantic versioning that we discussed
    in an earlier section. The versions that are meant only to be tested usually have
    the `-SNAPSHOT` modifier at the end of the version number. For example, the `1.3.12-SNAPSHOT`
    version is the version that was once debugged, and is going to become the `1.3.12`
    version. The snapshot versions are not definite versions. They are the code as
    it is by then. Because a snapshot release never gets installed in production,
    it is not needed to reproduce a snapshot version for maintenance. Thus, the snapshot
    versions are not increased continually. Sometimes, they may be changed, but that
    is a rare exception.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有时候，发布都遵循我们在前面章节讨论的语义版本控制。仅用于测试的版本通常在版本号末尾带有 `-SNAPSHOT` 修饰符。例如，`1.3.12-SNAPSHOT`
    版本曾经是调试过的版本，并即将成为 `1.3.12` 版本。快照版本不是确定性的版本。它们是那时存在的代码。因为快照发布从未在生产环境中安装，所以不需要为维护重现快照版本。因此，快照版本不会持续增加。有时，它们可能会改变，但这是一种罕见的例外。
- en: It may so happen that we work on a bug fix, `1.3.12-SNAPSHOT`, and during the
    development, we change so much code that we decide that it has to be `1.4.0` when
    it is released, and we rename the snapshot as `1.4.0-SNAPSHOT`. This is a rare
    case. Many times, the release creation creates a `1.4.0` version from `1.3.12-SNAPSHOT`
    as the decision about the new release number is taken by the time the release
    is created.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能我们在修复一个错误，`1.3.12-SNAPSHOT`，在开发过程中，我们修改了太多代码，以至于我们决定在发布时它必须是 `1.4.0`，并将快照重命名为
    `1.4.0-SNAPSHOT`。这是一个罕见的情况。很多时候，发布创建是从 `1.3.12-SNAPSHOT` 创建 `1.4.0` 版本，因为新发布号的决策是在创建发布时做出的。
- en: When the release process is started, usually from the web interface of the CI
    server, the developer creating the release has to specify the release version.
    This is usually the same as the snapshot version without the `-SNAPSHOT` postfix.
    The build process not only creates the build in this case but also tags the source
    code repository version it was using and loads the packaged program (artifact)
    to the code repository. The tag can be used later to access the exact version
    of the source code that was used to create the release. If there is a bug in a
    specific version, then this version has to be checked out on a developer machine
    to reproduce the bug and find the root cause.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始发布流程时，通常是从CI服务器的Web界面开始的，创建发布的开发者必须指定发布版本。这通常与不带`-SNAPSHOT`后缀的快照版本相同。在这种情况下，构建过程不仅创建构建，还标记了使用的源代码仓库版本，并将打包的程序（工件）加载到代码仓库中。这个标签可以用来访问创建发布时使用的确切源代码版本。如果特定版本存在错误，那么这个版本必须在开发机上检出以重现错误并找到根本原因。
- en: If the build of a release fails, it can be rolled back, or you better just skip
    that release number and note it as a failed release build. An existing release
    can never have two versions. The source code is the only one that is for that
    release and the generated code has to be exactly the one in any storage. Subsequent
    compilation of the same source may result in slightly different code, for example,
    if a different version of Java is used to create the latter one. Even in such
    a case, the one that was created by the build server in the first place is the
    version that belongs to the release. When a bug is reproduced and the code is
    recompiled from the exact same source, it is already a snapshot version. Multiple
    releases may be possible from the same source version, for example, compiled with
    Java versions from 1.5 to 1.8 and version 9 but a single release always belongs
    to the exact same source code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个发布版本的构建失败，它可以被回滚，或者你最好直接跳过那个发布号，并注明为一个失败的发布构建。一个现有的发布版本永远不能有两个版本。源代码是唯一一个属于那个发布的，生成的代码必须与任何存储中的代码完全一致。使用相同源代码的后续编译可能会产生略微不同的代码，例如，如果使用不同版本的Java创建后者。即使在这样的情况下，最初由构建服务器创建的版本才是属于该发布的版本。当重现了一个错误，并且从完全相同的源代码重新编译代码时，它已经是一个快照版本。可能从同一个源版本产生多个发布版本，例如，使用Java版本从1.5到1.8和版本9编译，但一个发布版本总是属于完全相同的源代码。
- en: If a release that was supposed to be a release version fails during QA checks,
    then a new release has to be created and the failed release has to be noted as
    such. The version that marketing uses to name the different versions should not
    have a relation to the technical version numbers we work with. Many times, it
    is, and it causes much headache. If you realize that the two are totally different
    things and one does not have to do anything with the other, life gets simpler.
    Look at the different versioning of the Windows operating system or Java. As marketing,
    Java used 1.0 then 1.1, but Java 1.2 was advertised as Java 2 and still the code
    contained 1.2 (which now seven major releases later also becomes 9 instead of
    1.9)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个本应作为发布版本的发布版本在QA检查期间失败，那么必须创建一个新的发布版本，并将失败的发布版本注明为失败。营销用来命名不同版本的版本不应与我们所工作的技术版本号有联系。很多时候，它们是相关的，这会导致很多麻烦。如果你意识到这两者完全是不同的事情，一个不需要与另一个有任何关系，生活就会变得简单。看看Windows操作系统或Java的不同版本。作为营销，Java使用了1.0然后是1.1，但Java
    1.2被宣传为Java 2，代码仍然包含1.2（现在在七个主要版本发布后也变成了9而不是1.9）。
- en: The last part of release management is that deployments should register the
    version numbers. The company has to know which release is installed on which server,
    and of which client.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 发布管理的一部分是部署应该注册版本号。公司必须知道哪个版本发布安装在了哪个服务器上，以及哪个客户端。
- en: Code repository
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码仓库
- en: Code repository stores the libraries and helps manage the dependencies of the
    different libraries. In the old times, when Java projects used ANT as a build
    tool and without the later added Ivy dependency management, the libraries that
    were needed by a project were downloaded to the source code, usually to the `lib`
    library. If a library needed another library, then those were also downloaded
    and stored manually, and this continued until all the libraries that one of the
    already downloaded libraries needed were copied to the source code tree.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仓库存储库和帮助管理不同库的依赖关系。在旧时代，当Java项目使用ANT作为构建工具，并且没有后来添加的Ivy依赖关系管理时，项目需要的库被下载到源代码中，通常到`lib`库。如果一个库需要另一个库，那么这些库也会被下载并手动存储，这个过程会一直持续到所有已下载库需要的库都被复制到源代码树中。
- en: This was a lot of manual work and, also, the library code was stored in the
    source code repository in many copies. A compiled library is not source code and
    has nothing to do in the source code repository. Manual work that can be automated
    has to be automated. Not because developers are lazy (yes, we are and we have
    to be) but because manual work is error prone and, thus, expensive.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项大量的手动工作，而且，库代码以许多副本的形式存储在源代码仓库中。编译后的库不是源代码，与源代码仓库无关。可以自动化的手动工作必须自动化。不是因为开发者懒惰（是的，我们是，而且我们必须是）而是因为手动工作容易出错，因此成本高昂。
- en: This was when Apache Ivy was invented and Maven, following ANT, already supported
    repository management built in. They all stored the libraries structured in directories
    and supported metadata that described the dependencies to other libraries. Lucky
    that Gradle did not invent its own code repository. Instead, it supports both
    Maven and Ivy repositories.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Apache Ivy被发明的时候，Maven在ANT之后已经内置了仓库管理支持。它们都存储了结构化的库，并支持描述其他库依赖关系的元数据。幸运的是，Gradle没有发明自己的代码仓库。相反，它支持Maven和Ivy仓库。
- en: Using the repository, the build tools automatically download the libraries that
    are needed. In case a library has a new version, then the developer only has to
    update the version of the needed library in the build configuration and all tasks,
    including downloading all the new versions of the other libraries that are needed
    by that version, are done automatically.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仓库，构建工具会自动下载所需的库。如果一个库有新版本，那么开发者只需更新构建配置中所需库的版本，所有任务，包括下载该版本所需的所有其他库的新版本，都会自动完成。
- en: Walking up the ladder
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步攀登
- en: At this point, you have got a lot of information that will rocket your start
    as an enterprise Java developer. You have got a base knowledge that you can build
    on. There is a long way to become a professional Java developer. There is a lot
    of documentation to read, a lot of code to scan and understand, and also a lot
    of code to write till you can claim to be a professional Java developer. You may
    probably face many years of continuous education. The good thing is that even
    after that, you can continue your journey and you can educate yourself, as being
    a professional Java developer is rarely a job people retire from. No, no! Not
    because they die while at it! Rather, professional software developers gaining
    experience start to code less and less and support the development process in
    different ways, which leverages more of their experience. They can become business
    analysts, project managers, test engineers, subject-matter experts, architects,
    scrum masters, automation engineers, and so on. Is it a familiar list? Yes, these
    are the people you will work with as a developer. Many of them may have started
    as a developer themselves.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经获得了大量的信息，这将使你作为企业Java开发者的起步更加迅速。你已经获得了可以在此基础上构建的基础知识。要成为一名专业的Java开发者还有很长的路要走。有很多文档需要阅读，有很多代码需要扫描和理解，还有大量的代码需要编写，直到你可以声称自己是一名专业的Java开发者。你可能需要面对多年的持续教育。好事是，即使在那之后，你还可以继续你的旅程，你可以自学，因为成为一名专业的Java开发者很少是人们退休的工作。不，不！不是因为他们在做这件事的时候死了！而是因为随着经验的积累，专业的软件开发者开始越来越少地编写代码，并以不同的方式支持开发过程，这更多地利用了他们的经验。他们可以成为业务分析师、项目经理、测试工程师、领域专家、架构师、敏捷大师、自动化工程师等等。这是一个熟悉的列表吗？是的，这些是作为开发者你会与之共事的人。他们中的许多人可能自己就是从开发者开始的。
- en: 'The following diagram shows the relative position of these roles:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了这些角色之间的相对位置：
- en: '![](img/00068.gif)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00068.gif)'
- en: 'Let''s take a bit more detailed look into what these roles perform in enterprise
    development:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下这些角色在企业开发中的表现：
- en: Business analysts work with the client and create the documents, specifications,
    use cases, and user stories needed by the developers to develop the code.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务分析师与客户合作，创建开发者开发代码所需的文档、规范、用例和用户故事。
- en: Project managers administer the projects and help the team in getting things
    done in cooperation with other teams, caring for all the project matters that
    developers cannot attend to or would unnecessarily burn their time that they should
    have devoted to coding.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目经理负责管理项目，并与其他团队协作，帮助团队完成工作，关心所有开发者无法处理或会浪费他们本应用于编码时间的项目事务。
- en: Subject-matter experts are more advanced in knowing the business needs, so it
    is a bit rare for a developer to become one, but in case the industry you work
    in is technology oriented, it may not be incredible to become one.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题专家在了解业务需求方面更为先进，因此开发者成为主题专家的情况相对较少，但如果你所在的行业是技术导向的，那么成为主题专家可能并不令人惊讶。
- en: Test engineers control the QA process and understand not only the test methodologies
    and requirements of testing but also the development process so that they can
    support bug fixes and not only identify them, which would be poor.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试工程师控制着质量保证过程，不仅了解测试方法和测试要求，还了解开发过程，以便他们能够支持错误修复，而不仅仅是识别它们，这将是糟糕的。
- en: Architects work with BAs and design a high-level structure of the applications
    and code, and document it in a way that helps the developers to focus on the actual
    tasks they have to perform. Architects are also responsible for the solution to
    use technologies, solutions, and structures which fit the purpose, are future
    proof, affordable, and so on.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构师与业务分析师合作，设计应用程序和代码的高级结构，并以一种帮助开发者专注于他们必须执行的实际任务的方式进行文档记录。架构师还负责选择适合目的、具有前瞻性、经济实惠的技术、解决方案和结构等。
- en: Scrum mates help the development team to follow the agile methodology and help
    the team in controlling the administration and resolving problems.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scrum团队成员帮助开发团队遵循敏捷方法论，并帮助团队控制管理并解决问题。
- en: There are many ways to go as a software developer and I only listed some of
    the positions that you can find in an enterprise today. As technology develops,
    I can imagine that in 20 years from today, software developers will teach and
    curate artificial intelligence systems and that will be what we refer to as programming
    today. Who can tell?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，有众多的发展道路，我仅列出了今天在企业中可以找到的一些职位。随着技术的发展，我可以想象，从今天起20年后，软件开发者将教授和培育人工智能系统，而这将是今天我们所指的编程。谁能说得准呢？
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Going in this direction is a good choice. Being a Java developer and becoming
    a professional in it is a profession that will pay well in the coming 10 to 20
    years for sure and perhaps even later. At the same time, I personally find this
    technology fascinating and interesting, and after more than 10 years of Java programming
    and more than 35 years of programming, I still learn something new in it every
    day.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这个方向前进是一个不错的选择。成为一名Java开发者并成为该领域的专业人士，在未来10到20年内肯定能获得良好的回报，甚至可能更久。同时，我个人发现这项技术非常吸引人，有趣，在超过10年的Java编程和超过35年的编程生涯中，我每天都在其中学到新的东西。
- en: In this book, you learned the basics of Java programming. From time to time,
    I also mentioned issues, suggested directions, and warned you about pitfalls that
    are not Java-specific. However, we also did the homework of learning the Java
    language, the infrastructure, the libraries, development tools, and networking
    in Java. You also learned the most modern approaches that came only with Java
    8 and 9, such as functional programming in Java, streams, and reactive programming.
    If you know all that I have written in this book, you can start working as a Java
    developer. What's next? Go, and find your treasure in programming and in Java!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你学习了Java编程的基础知识。不时地，我也提到了问题、建议的方向，并警告你关于非Java特定的问题。然而，我们也完成了学习Java语言、基础设施、库、开发工具和Java网络的学习作业。你还学习了只有Java
    8和9才带来的最现代的方法，例如Java中的函数式编程、流和响应式编程。如果你知道这本书中我写的一切，你就可以开始作为Java开发者工作了。接下来是什么？去寻找你在编程和Java中的宝藏吧！
