<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Exploring the Features of WebDriver</h1>
                </header>
            
            <article>
                
<p>So far, we have looked at various basic and advanced interactions that a user can perform on a web page using WebDriver. In this chapter, we will discuss the different capabilities and features of WebDriver that enable test script developers to have better control over WebDriver, and consequently of the web application that is being tested. The features that we are going to cover in this chapter are as follows:</p>
<ul>
<li>Taking screenshots</li>
<li>Locating target windows and iFrames</li>
<li>Exploring Navigate</li>
<li>Waiting for WebElements to load</li>
<li>Handling cookies</li>
</ul>
<p>Let's get started without any further delay.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking screenshots</h1>
                </header>
            
            <article>
                
<p>Taking a screenshot of a web page is a very useful capability of WebDriver. This is very handy when your test case fails, and you want to see the state of the application when the test case failed. The <kbd>TakesScreenShot</kbd> interface in the WebDriver library is implemented by all of the different variants of WebDriver, such as Firefox Driver, Internet Explorer Driver, Chrome Driver, and so on. </p>
<p>The <kbd>TakesScreenShot</kbd> capability is enabled in all of the browsers by default. Because this is a read-only capability, a user cannot toggle it. Before we see a code example that uses this capability, we should look at an important method of the <kbd>TakesScreenShot</kbd> interface—<kbd>getScreenshotAs().</kbd></p>
<p class="mce-root"/>
<p>The API syntax for <kbd>getScreenshotAs()</kbd> is as follows:</p>
<pre>public X getScreenshotAs(OutputType target)           </pre>
<p>Here, <kbd>OutputType</kbd> is another interface of the WebDriver library. We can ask WebDriver to output the screenshot in three different formats : <kbd>BASE64</kbd>, <kbd>BYTES</kbd> (raw data), and <kbd>FILE</kbd>. If you choose the <kbd>FILE</kbd> format, it writes the data into a <kbd>.png</kbd> file, which will be deleted once the JVM is killed. So, you should always copy that file into a safe location so that it can be used for later reference.</p>
<p>The return type is a specific output that depends on the selected <kbd>OutputType</kbd>. For example, selecting <kbd>OutputType.BYTES</kbd> will return a <kbd>byte</kbd>array, and selecting <kbd>OutputType.FILE</kbd> will return a file object.</p>
<p>Depending on the browser used, the output screenshot will be one of the following, in order of preference:</p>
<ul>
<li>The entire page</li>
<li>The current window</li>
<li>A visible portion of the current frame</li>
<li>The screenshot of the entire display containing the browser</li>
</ul>
<p>For example, if you are using Firefox Driver, <kbd>getScreenshotAs()</kbd> takes a screenshot of the entire page, but Chrome Driver returns only the visible portion of the current frame.</p>
<p>It's time to take a look at the following code example:</p>
<pre><span>@BeforeMethod<br/></span><span>public void </span><span>setup</span>() <span>throws </span>IOException {<br/>    System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>            </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span>    </span><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>    </span><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com/"</span>)<span>;<br/></span><span><br/></span><span>    </span><strong>File scrFile  = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);<br/>    FileUtils.copyFile(scrFile, new File("./target/screenshot.png"));<br/></strong><span><br/></span>}</pre>
<p>In the preceding code, we used the <kbd>getScreenshotAs()</kbd> method to take the screenshot of the web page and save it to a file format. We can open the saved image from the target folder and examine it.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Locating target windows and Frames</h1>
                </header>
            
            <article>
                
<p>WebDriver enables the developers to switch between multiple child windows, browser tabs, and frames used in the application. For example, when you click on an internet banking link on a bank web application, it will open the internet banking application in a separate window or Tab. At this point, you may want to switch back to the original window to handle some events. Similarly, you may have to deal with a web application that is divided into two frames on the web page. The frame on the left may contain navigation items, and the frame on the right displays the appropriate web page, based on what is selected in the frame on the left. Using WebDriver, you can develop test cases that can easily handle such complex situations.</p>
<p>The <kbd>WebDriver.TargetLocator</kbd> interface is used to locate a given frame or window. In this section, we will see how WebDriver handles switching between browser windows and between two frames in the same window.                                                    </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Switching among windows</h1>
                </header>
            
            <article>
                
<p>First, we will see a code example for handling multiple windows. For this chapter, there is an HTML file provided with this book named <kbd>Window.html</kbd>. It is a very basic web page that links to Google's search page. When you click on the link, the Google's search page is opened in a different window. Every time you open a web page using WebDriver in a browser window, WebDriver assigns a window handle to that. WebDriver uses the window handle to identify the window. At this point, in WebDriver, there are two window handles registered. Now, on the screen, you can see that the Google's search page is in the front and has the focus. At this point, if you want to switch to the first browser window, you can use WebDriver's <kbd>switchTo()</kbd> method to do that.</p>
<p>The API syntax for <kbd>TargetLocator</kbd> is as follows:</p>
<pre>WebDriver.TargetLocator switchTo()</pre>
<p>This method returns the <kbd>WebDriver.TargetLocator</kbd> instance, where you can tell the WebDriver whether to switch between browser windows or frames. Let's see how WebDriver deals with this:</p>
<pre><span>public class </span>WindowHandlingTest {<br/><br/>    WebDriver <span>driver</span><span>;<br/></span><span><br/></span><span>    </span><span>@BeforeMethod<br/></span><span>    </span><span>public void </span><span>setup</span>() <span>throws </span>IOException {<br/>        System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span>        </span><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>        </span><span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Window.html"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Test<br/></span><span>    </span><span>public void </span><span>handleWindow</span>() {<br/><br/>        <strong>String firstWindow = driver.getWindowHandle()</strong><span><strong>;</strong><br/></span><span>        </span>System.<span>out</span>.println(<span>"First Window Handle is: " </span>+ firstWindow)<span>;<br/></span><span><br/></span><span>        </span>WebElement link = <span>driver</span>.findElement(By.<span>linkText</span>(<span>"Google Search"</span>))<span>;<br/></span><span>        </span>link.click()<span>;<br/></span><span><br/></span><span>        </span>String secondWindow = <span>driver</span>.getWindowHandle()<span>;<br/></span><span>        </span>System.<span>out</span>.println(<span>"Second Window Handle is: " </span>+ secondWindow)<span>;<br/></span><span>        </span>System.<span>out</span>.println(<span>"Number of Window Handles so for: "<br/></span><span>                </span>+ <span>driver</span>.getWindowHandles().size())<span>;<br/></span><span><br/></span><strong>        driver.switchTo().window(firstWindow)</strong><span><strong>;</strong><br/></span><span>    </span>}<br/><br/>    <span>@AfterMethod<br/></span><span>    </span><span>public void </span><span>tearDown</span>() {<br/>        <span>driver</span>.quit()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>Observe the following line in the preceding code:</p>
<pre>String firstWindow = driver.getWindowHandle();</pre>
<p>Here, the driver returns the assigned identifier for the window. Now, before we move on to a different window, it is better to store this value so that if we want to switch back to this window, we can use this handle or identifier. To retrieve all the window handles that are registered with your driver so far, you can use the following method:</p>
<pre>driver.getWindowHandles()</pre>
<p>This will return the set of identifiers of all of the browser window handles opened in the driver session so far. Now, in our example, after we open Google's search page, the window corresponding to it is shown in front with the focus. If you want to go back to the first window, you have to use the following code:</p>
<pre>driver.switchTo().window(firstWindow);</pre>
<p>This will bring the first window into focus.  </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Switching between frames            </h1>
                </header>
            
            <article>
                
<p>Let's now see how we can handle switching between the frames of a web page. In the HTML files supplied with this book, you will see a file named <kbd>Frames.html</kbd>. If you open that, you will see two HTML files loaded in two different frames. Let's see how we can switch between them and type into the text boxes available in each frame:</p>
<pre><span>public class </span>FrameHandlingTest {<br/>    WebDriver <span>driver</span><span>;<br/></span><span><br/></span><span>    </span><span>@BeforeMethod<br/></span><span>    </span><span>public void </span><span>setup</span>() <span>throws </span>IOException {<br/>        System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span>        </span><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>        </span><span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Frames.html"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Test<br/></span><span>    </span><span>public void </span><span>switchBetweenFrames</span>() {<br/><br/>        <span>// First Frame<br/></span><span>        </span><strong>driver.switchTo().frame(0)</strong><span><strong>;</strong><br/></span><span>        </span>WebElement firstField = <span>driver</span>.findElement(By.<span>name</span>(<span>"1"</span>))<span>;<br/></span><span>        </span>firstField.sendKeys(<span>"I'm Frame One"</span>)<span>;<br/></span><strong>        driver.switchTo().defaultContent()</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span><span>// Second Frame<br/></span><span>        </span><strong>driver.switchTo().frame(1)</strong><span><strong>;</strong><br/></span><span>        </span>WebElement secondField = <span>driver</span>.findElement(By.<span>name</span>(<span>"2"</span>))<span>;<br/></span><span>        </span>secondField.sendKeys(<span>"I'm Frame Two"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@AfterMethod<br/></span><span>    </span><span>public void </span><span>tearDown</span>() {<br/>        <span>driver</span>.quit()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>In the preceding code, we have used <kbd>switchTo().frame</kbd> instead of <kbd>switchTo().window</kbd> because we are moving across frames.</p>
<p>The API syntax for <kbd>frame</kbd> is as follows:</p>
<pre>WebDriver frame(int index)</pre>
<p class="mce-root"/>
<p>This method takes the index of the frame that you want to switch to. If your web page has three frames, WebDriver indexes them as 0, 1, and 2, where the zero index is assigned to the first frame encountered in the DOM. Similarly, you can switch between frames using their names by using the previous overloaded method. The API syntax is as follows:</p>
<pre>WebDriver frame(String frameNameOrframeID)</pre>
<p>You can pass the name of the frame or its ID. Using this, you can switch to the frame if you are not sure about the index of the target frame. The other overloaded method is as follows:</p>
<pre>WebDriver frame(WebElement frameElement)</pre>
<p>The input parameter is the WebElement of the frame. Let's consider our code example: First, we have switched to our first frame and typed into the text field. Then, instead of directly switching to the second frame, we have come to the main or default content and then switched to the second frame. The code for that is as follows:</p>
<pre>driver.switchTo().defaultContent();               </pre>
<p>This is very important. If you don't do this and try to switch to the second frame while you are still in the first frame, your WebDriver will complain, saying that it couldn't find a frame with index 1. This is because the WebDriver searches for the second frame in the context of the first frame, which is obviously not available. So, you have to first come to the top-level container and switch to the frame you are interested in.</p>
<p><span>After switching to the default content, you can now switch to the second frame using the following code:</span></p>
<pre><span>driver.switchTo().frame(1);</span></pre>
<p>Thus, you can switch between the frames and execute the corresponding WebDriver actions. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling alerts   </h1>
                </header>
            
            <article>
                
<p>Apart from switching between windows and frames, you may have to handle various modal dialogs in a web application. For this, WebDriver provides an API to handle alert dialogs. The API for that is as follows:</p>
<pre>Alert alert()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding method will switch to the currently active modal dialog on the web page. This returns an <kbd>Alert</kbd> instance, where appropriate actions can be taken on that dialog. If there is no dialog currently present, and you invoke this API, it throws back a <kbd>NoAlertPresentException</kbd>.</p>
<p>The <kbd>Alert</kbd> interface contains a number of APIs to execute different actions. The following list discusses them, one after the other:</p>
<ul>
<li><kbd>void accept()</kbd>: This is equivalent to the <strong>OK</strong> button action on the dialog. The corresponding <strong>OK</strong> button actions are invoked when the <kbd>accept()</kbd> action is taken on a dialog.</li>
<li><kbd>void dismiss()</kbd>: This is equivalent to clicking on the <strong>CANCEL</strong> action button.</li>
<li><kbd>java.lang.String getText()</kbd>: This will return the text that appears on the dialog. This can be used if you want to evaluate the text on the modal dialog.</li>
<li><kbd>void sendKeys(java.lang.String keysToSend)</kbd>: This will allow the developer to type in some text into the alert if the alert has some provision for it.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring Navigate</h1>
                </header>
            
            <article>
                
<p>As we know, WebDriver talks to individual browsers natively. This way it has better control, not just over the web page, but over the browser itself. <strong>Navigate</strong> is one such feature of WebDriver that allows the test script developer to work with the browser's back, forward, and refresh controls. As users of a web application, quite often, we use the browser's back and forward controls to navigate between the pages of a single application, or, sometimes, multiple applications. As a test-script developer, you may want to develop tests that observe the behavior of the application when browser navigation buttons are clicked, especially the <span class="packt_screen">back</span> button. For example, if you use your navigation button in a banking application, the session should expire and the user should be logged out. So, using the WebDriver's navigation feature, you can emulate those actions. </p>
<p>The method that is used for this purpose is <kbd>navigate()</kbd>. The following is its API syntax:</p>
<pre>WebDriver.Navigation navigate()</pre>
<p>Obviously, there is no input parameter for this method, but the return type is the <kbd>WebDriver.Navigation</kbd> interface, which contains all of the browser navigation options that help you navigate through your browser's history.</p>
<p class="mce-root"/>
<p>Now let's see a code example and then analyze the code:</p>
<pre><span>@Test<br/></span><span>public void </span><span>searchProduct</span>() {<br/>    <strong>driver.navigate().to("http://demo-store.seleniumacademy.com/")</strong><span><strong>;</strong><br/></span><span><br/></span><span>    </span><span>// find search box and enter search string<br/></span><span>    </span>WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span><br/></span><span>    </span>searchBox.sendKeys(<span>"Phones"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement searchButton =<br/>            <span>driver</span>.findElement(By.<span>className</span>(<span>"search-button"</span>))<span>;<br/></span><span><br/></span><span>    </span>searchButton.click()<span>;<br/></span><span><br/></span><span>    </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>            .isEqualTo(<span>"Search results for: 'Phones'"</span>)<span>;<br/></span><span><br/></span><span>    </span><strong>driver.navigate().back();<br/>    driver.navigate().forward();<br/>    driver.navigate().refresh()</strong><span><strong>;</strong><br/></span>}</pre>
<p>The preceding code opens the demo application's Homepage, and, at first, searches for <kbd>Phone</kbd>; then, after the search results are loaded. Now that we have a navigation history created in the browser, it uses WebDriver navigation to go back in the browser history, and then go forward and refresh the page.</p>
<p>Let's analyze the navigation methods used in the preceding code. The line of code that initially loads the <span>demo application's Homepage</span> uses the <kbd>to()</kbd> method of the <kbd>Navigation</kbd> class, as follows:</p>
<pre>driver.navigate().to("http://demo-store.seleniumacademy.com/");</pre>
<p>Here, the <kbd>driver.navigate()</kbd> method returns the <kbd>WebDriver.Navigation</kbd> interface on which the <kbd>to()</kbd> method is used to navigate to a web URL.</p>
<p>The API syntax is as follows:</p>
<pre>void to(java.lang.String url)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The input parameter for this method is the <kbd>url</kbd> string that has to be loaded in the browser. This method will load the page in the browser by using the <kbd>HTTP GET</kbd> operation, and it will block everything else until the page is completely loaded. This method is the same as the <kbd>driver.get(String url)</kbd> method.</p>
<p>The <kbd>WebDriver.Navigation</kbd> interface also provides an overloaded method of this <kbd>to()</kbd> method to make it easy to pass the URL. The API syntax for it is as follows:</p>
<pre>void to(java.net.URL url)</pre>
<p>Next, in the code example, we did a search for <kbd>Phone</kbd>. Then, we tried to use Navigation's <kbd>back()</kbd> method to emulate our browser's <span class="packt_screen">back</span> button, using the following line of code:</p>
<pre>driver.navigate().back();</pre>
<p>This will take the browser to the home page. The API syntax for this method is pretty straightforward; it's as follows:</p>
<pre>void back()</pre>
<p>This method doesn't take any input and doesn't return anything as well, but it takes the browser one level back in its history.</p>
<p>Then, the next method in the navigation is the <kbd>forward()</kbd> method, which is pretty much similar to the <kbd>back()</kbd> method, but it takes the browser one level in the opposite direction. In the preceding code example, the following is invoked:</p>
<pre> driver.navigate().forward();</pre>
<p>The API syntax for the method is as follows:</p>
<pre>void forward()</pre>
<p>This method doesn't take any input, and doesn't return anything either, but it takes the browser one level forward in its history.</p>
<p>The last line of code in the code example uses the <kbd>refresh()</kbd> method of WebDriver's navigation:</p>
<pre>driver.navigate().refresh();</pre>
<p>This method will reload the current URL to emulate the browser's <em>refresh</em> (<em>F5</em> key) action. The API syntax is as follows:</p>
<pre>void refresh()</pre>
<p class="mce-root"/>
<p>As you can see, the syntax is very similar to the <kbd>back()</kbd> and <kbd>forward()</kbd> methods, and this method will reload the current URL. Hence, these are the various methods WebDriver provides developers to emulate some browser actions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Waiting for WebElements to load</h1>
                </header>
            
            <article>
                
<p>If you have a previous UI automation experience, I'm sure you would have come across a situation where your test script couldn't find an element on the web page because the web page was still loading. This could happen due to various reasons. One classic example is when the application server or web server is serving the page too slowly due to resource constraints; the other could be when you are accessing the page on a very slow network. The reason could be that the element on the web page is not loaded by the time your test script tries to find it. This is where you have to calculate and configure the average wait time for your test scripts to wait for WebElements to load on the web page.</p>
<p>WebDriver provides test-script developers with a very handy feature to manage wait time. <em>Wait time</em> is the time your driver will wait for the WebElement to load, before it gives up and throws <kbd>NoSuchElementException</kbd>. Remember, in <a href="9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml">Chapter 1</a><em>, Introducing WebDriver and WebElements</em>, we discussed the <kbd>findElement(By by)</kbd> method that throws a   <kbd>NoSuchElementException</kbd> when it cannot find the target WebElement.</p>
<p>There are two ways by which you can make the WebDriver wait for WebElement. They are <strong>Implicit Wait</strong> <strong>Time</strong> and <strong>Explicit Wait</strong> <strong>Time</strong>. Implicit timeouts are common to all the WebElements and have a global timeout period associated with them, but the explicit timeouts can be configured to individual WebElements. Let's discuss each of them here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit wait time</h1>
                </header>
            
            <article>
                
<p>Implicit wait time is used when you want to configure the WebDriver's wait time as a whole for the application under test. Imagine you have hosted a web application on a local server and on a remote server. Obviously, the time to load for a web page hosted on a local server would be less than the time for the same page hosted on a remote server, due to network latency. Now, if you want to execute your test cases against each of them, you may have to configure the wait time accordingly, such that your test case doesn't end up spending more time waiting for the page, or spend nowhere near enough time, and timeout. To handle these kinds of wait-time issues, WebDriver provides an option to set the implicit wait time for all of the operations that the driver does using the <kbd>manage()</kbd> method.</p>
<p class="mce-root"/>
<p>Let's see a code example of implicit wait time:</p>
<pre><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>driver</span>.navigate().to(<span>"http://demo-store.seleniumacademy.com/"</span>)<span>;<br/></span><strong>driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);</strong></pre>
<p>Let's analyze the following highlighted line of code:</p>
<pre>driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);</pre>
<p>Here, <kbd>driver.manage().timeouts()</kbd> returns the <kbd>WebDriver.Timeouts</kbd> interface, which declares a method named <kbd>implicitlyWait</kbd>, which is where you specify the amount of time the driver should wait when searching for a WebElement on a web page if it is not immediately present. Periodically, the WebDriver will poll for the WebElement on the web page, until the maximum wait time specified to the previous method is over. In the preceding code, 10 seconds is the maximum wait time your driver will wait for any WebElement to load on your browser. If it loads within this time period, WebDriver proceeds with the rest of the code; otherwise, it will throw <kbd>NoSuchElementException</kbd>.</p>
<p>Use this method when you want to specify a maximum wait time, which is generally common for most of the WebElements on your web application. The various factors that influence the performance of your page are network bandwidth, server configuration, and so on. Based on those conditions, as a developer of your WebDriver test cases, you have to arrive at a value for the maximum implicit wait time, such that your test cases don't take too long to execute, and, at the same time, don't timeout very frequently. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explicit wait time</h1>
                </header>
            
            <article>
                
<p>Implicit timeout is generic to all the WebElements of a web page. But, if you have one specific WebElement in your application, where you want to wait for a very long time, this approach may not work. Setting the implicit wait time to the value of this very long time period will delay your entire test suite execution. So, you have to make an exception for only a particular case, such as this WebElement. To handle such scenarios, WebDriver has an explicit wait time for a WebElement.</p>
<p>So, let's see how you can wait for a particular WebElement using WebDriver, with the following code:</p>
<pre><strong>WebElement searchBox = (new WebDriverWait(driver, 20))</strong><br/><strong>        .until((ExpectedCondition&lt;WebElement&gt;) d -&gt; d.findElement(By.name("q")));</strong></pre>
<p class="mce-root"/>
<p>The highlighted code is where we have created a conditional wait for a particular WebElement. The <kbd>ExpectedCondition</kbd> interface can be used to apply the conditional wait to a WebElement. Here, WebDriver will wait for a maximum of 20 seconds for this particular WebElement. The implicit timeout doesn't get applied for this WebElement. If the WebElement doesn't load within the 20 seconds maximum wait time, as we know, the driver throws a <kbd>NoSuchElementException</kbd>. Thus, you can override the implicit wait time exclusively for the WebElements you think will take more time, by using this handy explicit wait time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling cookies</h1>
                </header>
            
            <article>
                
<p>Let's say you are automating the demo application. There could be many scenarios you want to automate, such as searching for products, adding products to the shopping cart, checkout, returns, and so on. For all these actions, one common thing is to have to log into the demo application in each of the test cases. So, logging into the application in every test case of yours will increase the overall test execution time significantly. To reduce the execution time of your test cases, you can actually skip signing in for every test case. This can be done by signing in once and writing all the cookies of that domain into a file. From the next login onward, you can actually load the cookies from the file and add them to the driver.</p>
<p>To fetch all the cookies that are loaded for a web page, WebDriver provides the following method:</p>
<pre>driver.manage().getCookies()</pre>
<p>This will return all the cookies that the web page stores in the current session. Each cookie is associated with a name, value, domain, path, expiry, and the status of whether it is secure or not. The server to validate a client cookie parses all of these values. Now, we will store all of this information for each cookie in a file so that our individual test cases read from this file and load that information into the driver. Hence, you can skip the login, because once your driver session has this information in it, the application server treats your browser session as authenticated and directly takes you to your requested URL. The following is a quick code to store the cookie information:</p>
<pre><span>public class </span>StoreCookieInfo {<br/>    WebDriver <span>driver</span><span>;<br/></span><span><br/></span><span>    </span><span>@BeforeMethod<br/></span><span>    </span><span>public void </span><span>setup</span>() <span>throws </span>IOException {<br/>        System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span>        </span><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>        </span><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com/customer/account/login/"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Test<br/></span><span>    </span><span>public void </span><span>storeCookies</span>() {<br/>        <span>driver</span>.findElement(By.<span>id</span>(<span>"email"</span>)).sendKeys(<span>"user@seleniumacademy.com"</span>)<span>;<br/></span><span>        </span><span>driver</span>.findElement(By.<span>id</span>(<span>"pass"</span>)).sendKeys(<span>"tester"</span>)<span>;<br/></span><span>        </span><span>driver</span>.findElement(By.<span>id</span>(<span>"send2"</span>)).submit()<span>;<br/></span><span><br/></span><span>        </span>File dataFile = <span>new </span>File(<span>"./target/browser.data"</span>)<span>;<br/></span><span>        try </span>{<br/>            dataFile.delete()<span>;<br/></span><span>            </span>dataFile.createNewFile()<span>;<br/></span><span>            </span>FileWriter fos = <span>new </span>FileWriter(dataFile)<span>;<br/></span><span>            </span>BufferedWriter bos = <span>new </span>BufferedWriter(fos)<span>;<br/></span><strong>            for (Cookie ck : driver.manage().getCookies()) {</strong><br/><strong>                bos.write((ck.getName() + ";" + ck.getValue() + ";" + ck.</strong><br/><strong>                        getDomain()</strong><br/><strong>                        + ";" + ck.getPath() + ";" + ck.getExpiry() + ";" + ck.</strong><br/><strong>                        isSecure()));<br/>                bos.newLine();<br/>            }</strong><br/>            bos.flush()<span>;<br/></span><span>            </span>bos.close()<span>;<br/></span><span>            </span>fos.close()<span>;<br/></span><span>        </span>} <span>catch </span>(Exception ex) {<br/>            ex.printStackTrace()<span>;<br/></span><span>        </span>}<br/>    }<br/><br/>    <span>@AfterMethod<br/></span><span>    </span><span>public void </span><span>tearDown</span>() {<br/>        <span>driver</span>.quit()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">From now on, for every test case or a set of test cases, load the cookie information from the <kbd>browser.data</kbd> file, and add it to the driver using the following method:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">driver.manage().addCookie(ck);</pre>
<p class="mce-root"/>
<p>After you add this information to your browser session and go to the dashboard page, it will automatically redirect you to the home page, without asking for a login, thus avoiding a login every time, for every test case. The code that adds all of the previous cookies to the driver is as follows:</p>
<pre><span>public class </span>LoadCookieInfo {<br/>    WebDriver <span>driver</span><span>;<br/></span><span><br/></span><span>    </span><span>@BeforeMethod<br/></span><span>    </span><span>public void </span><span>setup</span>() <span>throws </span>IOException {<br/>        System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span>        </span><span>driver </span>= <span>new </span>ChromeDriver()<span>;<br/></span><span>       </span><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Test<br/></span><span>    </span><span>public void </span><span>loadCookies</span>() {<br/>        <span>try </span>{<br/>            File dataFile = <span>new </span>File(<span>"./target/browser.data"</span>)<span>;<br/></span><span>            </span>FileReader fr = <span>new </span>FileReader(dataFile)<span>;<br/></span><span>            </span>BufferedReader br = <span>new </span>BufferedReader(fr)<span>;<br/></span><span>            </span>String line<span>;<br/></span><span>            while </span>((line = br.readLine()) != <span>null</span>) {<br/>                StringTokenizer str = <span>new </span>StringTokenizer(line<span>, </span><span>";"</span>)<span>;<br/></span><span>                while </span>(str.hasMoreTokens()) {<br/>                    String name = str.nextToken()<span>;<br/></span><span>                    </span>String value = str.nextToken()<span>;<br/></span><span>                    </span>String domain = str.nextToken()<span>;<br/></span><span>                    </span>String path = str.nextToken()<span>;<br/></span><span>                    </span>Date expiry = <span>null;<br/></span><span>                    </span>String dt<span>;<br/></span><span>                    if </span>(!(dt = str.nextToken()).equals(<span>"null"</span>)) {<br/>                        SimpleDateFormat formatter =<br/>                                <span>new </span>SimpleDateFormat(<span>"E MMM d HH:mm:ss z yyyy"</span>)<span>;<br/></span><span>                        </span>expiry = formatter.parse(dt)<span>;<br/></span><span>                    </span>}<br/><br/>                    <span>boolean </span>isSecure = <span>new </span>Boolean(str.nextToken()).<br/>                            booleanValue()<span>;<br/></span><strong>                    Cookie ck = new Cookie(name, value, domain, path, expiry, isSecure);<br/>                    driver.manage().addCookie(ck)</strong><span><strong>;</strong><br/></span><span>                </span>}<br/>            }<br/><br/>            <span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com/customer/account/index/"</span>)<span>;<br/></span><span>            </span><span>assertThat</span>(<span>driver</span>.findElement(By.<span>cssSelector</span>(<span>"div.page-title"</span>)).getText())<br/>                    .isEqualTo(<span>"MY DASHBOARD"</span>)<span>;<br/></span><span><br/></span><span>        </span>} <span>catch </span>(Exception ex) {<br/>            ex.printStackTrace()<span>;<br/></span><span>        </span>}<br/>    }<br/><br/>    <span>@AfterMethod<br/></span><span>    </span><span>public void </span><span>tearDown</span>() {<br/>        <span>driver</span>.quit()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>Hence, we can be directly taken to the home page without logging in again and again. As you can see, after creating the driver instance, we have the following line:</p>
<pre><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com"</span>)<span>;</span></pre>
<p>Ideally, this line should be visible after we have set the cookies to the driver. But the reason it is at the top is that the WebDriver doesn't allow you to set the cookies directly to this session, because it treats those cookies as if they were from a different domain. Try removing the previous line of code and execute it, and you will see the error. So, initially, you will try to visit the home page to set the domain value of the driver to the application server domain and load all the cookies. When you execute this code, initially, you will see the home page of the application.</p>
<p>Hence, you can avoid entering the username and the password on the server, validating them again and again for each test, and thereby save a lot of time, by using the WebDriver's cookies feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed various features of WebDriver, such as capturing screenshots and handling <kbd>Windows</kbd> and <kbd>Frames</kbd>. We also discussed implicit and explicit wait conditions for synchronization, and we used Navigation and the cookies API. Using these features will help you test your target web application more effectively, by designing more innovative test frameworks and test cases. In the next <a href="ff724e47-f410-4c90-bc11-cf0fbd340773.xhtml">chapter</a>, we will look at the <strong>Actions</strong> API to perform user interaction using keyboard and mouse events.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which are the different formats we can use to output a screenshot?</li>
<li>How can we switch to another browser tab with Selenium?</li>
<li>True or false: The <kbd>defaultContent()</kbd> method will switch to the previously selected frame.</li>
<li>What navigation methods are available with Selenium?</li>
<li>How can we add a cookie using Selenium?</li>
<li>Explain the difference between an implicit wait and an explicit wait.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further information</h1>
                </header>
            
            <article>
                
<p><span>You can check the following links for more information about the topics covered in this chapter:</span></p>
<ul>
<li>You can find out more about how you can use a set of predefined expected conditions while using an explicit wait at <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html">https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html</a></li>
<li>You can read more about WebDriver's features in Chapter 4<em>, Working with Selenium API</em> and Chapter 5 <em>, Synchronizing Tests,</em> in <em>Selenium Testing Tools Cookbook</em>, 2nd Edition, by Unmesh Gundecha, Packt Publications.</li>
</ul>


            </article>

            
        </section>
    </body></html>