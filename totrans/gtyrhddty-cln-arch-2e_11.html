<html><head></head><body>
<div id="_idContainer084">
<h1 class="hapter-number" id="_idParaDest-96"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.2.1">Taking Shortcuts Consciously</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the preface of this book, I cursed the fact that we feel forced to take shortcuts all the time, building up a great heap of technical debt we never have the chance to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">pay back.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">To prevent shortcuts, we must be able to identify them. </span><span class="koboSpan" id="kobo.5.2">So, the goal of this chapter is to raise awareness of some potential shortcuts and discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">their effects.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">With this information, we can identify and fix accidental shortcuts. </span><span class="koboSpan" id="kobo.7.2">Or, if justified, we can even consciously opt in to the effects of </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">a shortcut.</span></span><span class="No-Break"><span id="footnote-037-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-037"><span class="koboSpan" id="kobo.9.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-037">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-037-backlink"><span class="koboSpan" id="kobo.10.1">1</span></a><span class="koboSpan" id="kobo.11.1">	Imagine talking about shortcuts in a book about construction engineering or, even scarier, in a book about avionics! </span><span class="koboSpan" id="kobo.11.2">Most of us, however, are not building the software equivalent of a skyscraper or an airplane. </span><span class="koboSpan" id="kobo.11.3">And software is soft and can be changed more easily than hardware, so sometimes it’s actually more economic to (consciously!) take a shortcut first and fix it later (</span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">or never)</span></span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">.</span></span></p>
</div>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.14.1">Why shortcuts are like broken windows</span></h1>
<p><span class="koboSpan" id="kobo.15.1">In 1969, psychologist </span><em class="itali"><span class="koboSpan" id="kobo.16.1">Philip Zimbardo</span></em><span class="koboSpan" id="kobo.17.1"> conducted an experiment to test a theory that later became </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.18.1">known as the</span><a href="https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/"> <strong class="bold"><span class="koboSpan" id="kobo.19.1">Broken </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.20.1">Windows Theor</span></strong></span></a><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.21.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">.</span></span><span class="No-Break"><span id="footnote-036-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-036"><span class="koboSpan" id="kobo.23.1">2</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-036">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-036-backlink"><span class="koboSpan" id="kobo.24.1">2</span></a><span class="koboSpan" id="kobo.25.1">	The Broken Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Theory: </span></span><a href="https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.29.1">His team parked </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.30.1">one car without license plates in a Bronx neighborhood and another in an allegedly “better” neighborhood in Palo Alto. </span><span class="koboSpan" id="kobo.30.2">Then, </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">they waited.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The car in the Bronx was picked clean of valuable parts within 24 hours and then passersby started to randomly </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">destroy it.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">The car in Palo Alto was not touched for a week, so Zimbardo’s team smashed a window. </span><span class="koboSpan" id="kobo.34.2">From then on, the car had a similar fate to the car in the Bronx and was destroyed in the same short amount of time by people </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">walking by.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">The people taking part in looting and destroying the cars came from across all social classes and included people who were otherwise law-abiding and </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">well-behaved citizens.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">This human behavior has become known as the Broken Windows Theory. </span><span class="koboSpan" id="kobo.38.2">In my </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">own words:</span></span></p>
<p><em class="itali"><span class="koboSpan" id="kobo.40.1">As soon as something looks run-down, damaged, [insert negative adjective here], or generally untended, the human brain feels that it’s OK to make it more run-down, damaged, or [insert negative </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.41.1">adjective here].</span></em></span></p>
<p><span class="koboSpan" id="kobo.42.1">This theory applies to many areas </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">of life:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.44.1">In a neighborhood where vandalism is common, the threshold to loot or damage an untended car </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">is low.</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">When a car has a broken window, the threshold to damage it further is low, even in a “</span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">good” neighborhood.</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">In an untidy bedroom, the threshold to throw our clothes on the ground instead of putting them into the wardrobe </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">is low.</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">In a classroom where students often disrupt the lesson, the threshold to crack another joke to classmates </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">is low.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.52.1">Applied to </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.53.1">working with code, this means </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.55.1">When working on a low-quality code base, the threshold to add more low-quality code </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">is low.</span></span></li>
<li><span class="koboSpan" id="kobo.57.1">When working on a code base with a lot of coding violations, the threshold to add another coding violation </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">is low.</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">When working on a code base with a lot of shortcuts, the threshold to add another shortcut </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">is low.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.61.1">With all this in mind, is it really a surprise that the quality of many so-called “legacy” code bases has eroded so badly </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">over time?</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.63.1">The responsibility of starting clean</span></h1>
<p><span class="koboSpan" id="kobo.64.1">While</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.65.1"> working with code doesn’t really feel like looting a car, we all are unconsciously subject to the Broken Windows psychology. </span><span class="koboSpan" id="kobo.65.2">This makes it important to start a project clean, with as few shortcuts and as little technical debt as possible. </span><span class="koboSpan" id="kobo.65.3">This is because, as soon as a shortcut creeps in, it acts as a broken window and attracts </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">more shortcuts.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Since a software project often is a very expensive and long-running endeavor, keeping broken windows at bay is a huge responsibility for us as software developers. </span><span class="koboSpan" id="kobo.67.2">We may not even be the ones finishing the project and others have to take over. </span><span class="koboSpan" id="kobo.67.3">For them, it’s a legacy code base they don’t have a connection to yet, lowering the threshold for creating broken windows </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">even further.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">There are times, however, when</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.70.1"> we decide a shortcut is the pragmatic thing to do, be it because the part of the code we’re working on is not that important to the project as a whole, because we’re prototyping, or for </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">economical reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">We should take great care to document such consciously added shortcuts, for example, in the form </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.73.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">Architecture Decision Records</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">ADRs</span></strong><span class="koboSpan" id="kobo.77.1">), as proposed by </span><em class="itali"><span class="koboSpan" id="kobo.78.1">Michael Nygard</span></em><span class="koboSpan" id="kobo.79.1"> i</span><a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions"><span class="koboSpan" id="kobo.80.1">n hi</span></a><span class="koboSpan" id="kobo.81.1">s blog.</span><span id="footnote-035-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-035"><span class="koboSpan" id="kobo.82.1">3</span></a></span><span class="koboSpan" id="kobo.83.1"> We owe that to our future selves and our successors. </span><span class="koboSpan" id="kobo.83.2">If every member of the team is aware of this documentation, it will even reduce the Broken Windows effect because the team will know that the shortcuts have been taken consciously and for </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">good reason.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-035">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-035-backlink"><span class="koboSpan" id="kobo.85.1">3</span></a><span class="koboSpan" id="kobo.86.1">	Architecture Decision </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">Records: </span></span><a href="B19916_11.xhtml"><span class="No-Break"><span class="koboSpan" id="kobo.88.1">http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.89.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.90.1">The following sections each discuss a pattern that can be considered a shortcut in the Hexagonal Architecture style presented in this book. </span><span class="koboSpan" id="kobo.90.2">We’ll have a look at the effects of the shortcuts and the arguments that speak for and against </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">taking them.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.92.1">Sharing models between use cases</span></h1>
<p><span class="koboSpan" id="kobo.93.1">In </span><a href="B19916_05.xhtml#_idTextAnchor044"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.94.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.95.1">, </span><em class="itali"><span class="koboSpan" id="kobo.96.1">Implementing a Use Case</span></em><span class="koboSpan" id="kobo.97.1">, I argued that different use cases should have </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.98.1">different </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">input and output models</span></strong><span class="koboSpan" id="kobo.100.1">, meaning that the types of the input parameters and the types of the return values should </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">be different.</span></span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.102.1">Figure 11</span></em></span><em class="itali"><span class="koboSpan" id="kobo.103.1">.1</span></em><span class="koboSpan" id="kobo.104.1"> shows an example where two use cases share the same </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">input model:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.106.1"><img alt="Figure 11.1 – Sharing the input or output model between use cases leads to coupling between the use cases" src="image/Figure_11.1_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.107.1">Figure 11.1 – Sharing the input or output model between use cases leads to coupling between the use cases</span></p>
<p><span class="koboSpan" id="kobo.108.1">The effect of </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.109.1">sharing in this case is that </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.110.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.111.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.112.1">RevokeActivityUseCase</span></strong><span class="koboSpan" id="kobo.113.1"> are coupled to each other. </span><span class="koboSpan" id="kobo.113.2">If we change something within the shared </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.114.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.115.1"> class, both use cases are affected. </span><span class="koboSpan" id="kobo.115.2">They share a reason to change in terms of the Single Responsibility Principle (which should be named the “Single Reason to Change Principle,” as discussed in </span><a href="B19916_03.xhtml#_idTextAnchor029"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.116.1">Chapter 3</span></em></span></a><em class="itali"><span class="koboSpan" id="kobo.117.1">, Inverting Dependencies</span></em><span class="koboSpan" id="kobo.118.1">). </span><span class="koboSpan" id="kobo.118.2">The same is true if both use cases share the same </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">output model.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Sharing input and output models between use cases is valid if the use cases are functionally coupled, that is, if they share a certain requirement. </span><span class="koboSpan" id="kobo.120.2">In this case, we actually want both use cases to be affected if we change a </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">certain detail.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">If both use cases should be able to evolve separately from each other, however, this is a shortcut. </span><span class="koboSpan" id="kobo.122.2">In this case, we should separate the use cases from the start, even if it means duplicating input and output classes if they look the same at </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the start.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">So, when building multiple use cases around a similar concept, it’s worthwhile to regularly ask the</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.125.1"> question of whether the use cases should evolve separately from each other. </span><span class="koboSpan" id="kobo.125.2">As soon as the answer becomes “yes,” it’s time to separate the input and </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">output models.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.127.1">Using domain entities as the input or output model</span></h1>
<p><span class="koboSpan" id="kobo.128.1">If we </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.129.1">have an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.130.1">Account</span></strong><span class="koboSpan" id="kobo.131.1"> domain entity and an incoming port, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.132.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.133.1">, we might be tempted to use the entity as the</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.134.1"> input and/or output model of the incoming port, as </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.135.1">Figure </span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.136.1">11</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.137.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1"> shows.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.139.1"><img alt="Figure 11.2 – Using a domain entity as the input or output model of a use case couples the domain entity to the use case" src="image/Figure_11.2._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.140.1">Figure 11.2 – Using a domain entity as the input or output model of a use case couples the domain entity to the use case</span></p>
<p><span class="koboSpan" id="kobo.141.1">The incoming port has a dependency on the domain entity. </span><span class="koboSpan" id="kobo.141.2">The consequence of this is that we’ve added another reason for the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.142.1">Account</span></strong><span class="koboSpan" id="kobo.143.1"> entity </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Wait, the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.146.1">Account</span></strong><span class="koboSpan" id="kobo.147.1"> entity doesn’t have a dependency on the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.148.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.149.1"> incoming port (it’s the other way around), so how can the incoming port be a reason to change for </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the entity?</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">Say we need some information about an account in the use case that is not currently available in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.152.1">Account</span></strong><span class="koboSpan" id="kobo.153.1"> entity. </span><span class="koboSpan" id="kobo.153.2">This information is ultimately not to be stored in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.154.1">Account</span></strong><span class="koboSpan" id="kobo.155.1"> entity, however, but in a different domain or bounded context. </span><span class="koboSpan" id="kobo.155.2">We’re tempted to add a new field to the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.156.1">Account</span></strong><span class="koboSpan" id="kobo.157.1"> entity nevertheless, because it’s already available in the use </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">case interface.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">For simple create or </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.160.1">update use cases, a domain entity in the use case interface may be fine since the entity contains exactly the information we need to persist its state in </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">As soon as </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.163.1">a use case is not simply about updating a couple of fields in the database, but instead implements more complex domain logic (potentially delegating part of the domain logic to a rich domain entity), we should use a dedicated input and output model for the use case interface, because we don’t want changes in the use case to propagate to the </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">domain entity.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">What makes this shortcut dangerous is the fact that many use cases start their lives as a simple create or update use case only to become beasts of complex domain logic over time. </span><span class="koboSpan" id="kobo.165.2">This is especially true in an agile environment where we start with a minimum viable product and add complexity as we move forward. </span><span class="koboSpan" id="kobo.165.3">So, if we used a domain entity as the input model at the start, we must find the point in time to replace it with a dedicated input model that is independent of the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">domain entity.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.167.1">Skipping incoming ports</span></h1>
<p><span class="koboSpan" id="kobo.168.1">While </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.169.1">the outgoing ports are necessary to invert the dependency between the application layer and the outgoing adapters (to make the dependencies point inward), we don’t need the incoming ports for dependency inversion. </span><span class="koboSpan" id="kobo.169.2">We could decide to let the incoming adapters access our application or domain services directly, without incoming ports in between, as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.170.1">Figure 11</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.171.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.173.1"><img alt="Figure 11.3 – Without incoming ports, we lose clearly marked entry points to the domain logic" src="image/Figure_11.3._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.174.1">Figure 11.3 – Without incoming ports, we lose clearly marked entry points to the domain logic</span></p>
<p><span class="koboSpan" id="kobo.175.1">By </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.176.1">removing the incoming ports, we have reduced a layer of abstraction between incoming adapters and the application layer. </span><span class="koboSpan" id="kobo.176.2">Removing layers of abstraction usually feels </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">rather good.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">The incoming ports, however, define the entry points into our application core. </span><span class="koboSpan" id="kobo.178.2">Once we remove them, we must know more about the internals of our application to find out which service method we can call to implement a certain use case. </span><span class="koboSpan" id="kobo.178.3">By maintaining dedicated incoming ports, we can identify the entry points to the application at a glance. </span><span class="koboSpan" id="kobo.178.4">This makes it especially easy for new developers to get their bearings in the </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Another reason to keep the incoming ports is that they allow us to easily enforce architecture. </span><span class="koboSpan" id="kobo.180.2">With the enforcement options we’ll learn about in </span><a href="B19916_12.xhtml#_idTextAnchor105"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.181.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.182.1">, </span><em class="itali"><span class="koboSpan" id="kobo.183.1">Enforcing Architecture Boundaries</span></em><span class="koboSpan" id="kobo.184.1">, we can make certain that incoming adapters only call incoming ports and not application services. </span><span class="koboSpan" id="kobo.184.2">This makes every entry point into the application layer a very conscious decision. </span><span class="koboSpan" id="kobo.184.3">We can no longer accidentally call a service method that was not meant to be called from an </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">incoming adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">If an application is small enough or only has a single incoming adapter and we can grasp the whole control flow without the help of incoming ports, we might want to do without incoming ports. </span><span class="koboSpan" id="kobo.186.2">However, how often can we say that we know that an application will stay small or will only ever have a single incoming adapter over its </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">whole lifetime?</span></span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.188.1">Skipping services</span></h1>
<p><span class="koboSpan" id="kobo.189.1">Aside from the </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.190.1">incoming ports, for certain use cases, we might want to skip the service layer as a whole, as </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.191.1">Figure </span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.192.1">11</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.193.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1"> shows.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.195.1"><img alt="Figure 11.4 – Without services, we don’t have a representation of a use case in our code﻿ base anymore" src="image/Figure_11.4._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.196.1">Figure 11.4 – Without services, we don’t have a representation of a use case in our code base anymore</span></p>
<p><span class="koboSpan" id="kobo.197.1">Here, the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.198.1">AccountPersistenceAdapter</span></strong><span class="koboSpan" id="kobo.199.1"> class within an outgoing adapter directly implements an incoming port and replaces the service that usually implements an </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">incoming port.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">It is very tempting to do this for simple CRUD use cases since in this case a service usually only forwards a create, update, or delete request to the persistence adapter, without adding any domain logic. </span><span class="koboSpan" id="kobo.201.2">Instead of forwarding, we can let the persistence adapter implement the use </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">case directly.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">This, however, requires a shared model between the incoming adapter and the outgoing adapter, which is the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.204.1">Account</span></strong><span class="koboSpan" id="kobo.205.1"> domain entity in this case, so it usually means that we’re using the domain model as the input model, as </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">described previously.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Furthermore, we no longer have a representation of the use case within our application core. </span><span class="koboSpan" id="kobo.207.2">If a CRUD use case grows to something more complex over time, it’s tempting to add domain logic directly to the outgoing adapter since the use case has already been implemented there. </span><span class="koboSpan" id="kobo.207.3">This decentralizes the domain logic, making it harder to find </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">In the end, to prevent boilerplate pass-through services, we might choose to skip the services for simple CRUD use cases after all. </span><span class="koboSpan" id="kobo.209.2">Then, however, the team should develop clear guidelines to introduce a service as soon as the use case is expected to do more than just create, update, or delete </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">an entity.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.211.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.212.1">There are times when shortcuts make sense from an economic point of view. </span><span class="koboSpan" id="kobo.212.2">This chapter provided some insights into the consequences some shortcuts might have to help decide whether to take them </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">The discussion shows that it’s tempting to introduce shortcuts for simple CRUD use cases since, for them, implementing the whole architecture feels like overkill (and the shortcuts don’t feel like shortcuts). </span><span class="koboSpan" id="kobo.214.2">Since all applications start small, however, it’s very important for the team to agree on when a use case grows out of its CRUD state. </span><span class="koboSpan" id="kobo.214.3">Only then can the team replace the shortcuts with an architecture that is more maintainable in the </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">long run.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">Some use cases will never grow out of their CRUD state. </span><span class="koboSpan" id="kobo.216.2">For them, it might be more pragmatic to keep the shortcuts in place forever, as they don’t really entail a </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">maintenance overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">In any case, we should document the architecture and the decisions why we chose a certain shortcut so that we (or our successors) can re-evaluate the decisions in </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">Even though shortcuts may be acceptable at times, we want to make the decision to take a shortcut consciously. </span><span class="koboSpan" id="kobo.220.2">That means that we should define one “right” way of doing things and enforce this way, so that we can deviate from that way if there are good reasons to do so. </span><span class="koboSpan" id="kobo.220.3">In the next chapter, we’ll look at some ways of enforcing </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">our architecture.</span></span></p>
</div>
</body></html>