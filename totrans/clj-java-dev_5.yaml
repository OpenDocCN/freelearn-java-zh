- en: Chapter 5. Multimethods and Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a better understanding of how Clojure works; we understand how to
    perform simple operations with immutable data structures but we are missing some
    features that could make our lives much easier.
  prefs: []
  type: TYPE_NORMAL
- en: If you have been a Java programmer for a while, you are probably thinking about
    polymorphism and its particular flavor in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is one of the concepts that enable us to reuse a code. It gives
    us the ability to interact with different objects with the same API.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has a powerful polymorphism paradigm that allows us to write simple
    code, create code that interacts with types that don't exist yet, and extend code
    in ways it wasn't devised for when a programmer wrote it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us with polymorphism in Clojure, we have two important concepts that
    we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of them has its own use cases and things it is best at; we will look into
    them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn each of these different concepts by reviewing what we already
    know from Java and then we will learn similar concepts from Clojure that give
    us much more power.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java uses polymorphism heavily, its collection API is based on it. Probably
    the best examples of polymorphism in Java are the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.List`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know that depending on our use case we should use a particular implementation
    of these data structures.
  prefs: []
  type: TYPE_NORMAL
- en: If we prefer to use an ordered Set, we might use a TreeSet.
  prefs: []
  type: TYPE_NORMAL
- en: If we need a Map in a concurrent environment, we will use a `java.util.concurrent.ConcurrentHashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: The beautiful thing is that you can write your code using the `java.util.Map`
    and `java.util.Set` interfaces and if you need to change to another type of Set
    or Map, because the conditions have changed or someone has created a better version
    of the collection for you, you don't need to change any code!
  prefs: []
  type: TYPE_NORMAL
- en: Lets look at a very simple example of polymorphism in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a Shapes hierarchy; it might look similar to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You surely are aware of the power of this concept, you can now calculate the
    summation of all the areas of a collection of figures, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymorphism in Java](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `totalArea` method doesn't care about the specific types of shapes that
    you pass to it and you can add new types of shapes, such as rectangles or trapezoids.
    Your same code will now work with new data types.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the same Java code base, imagine that you wanted to add a new function
    to your shape interface, something simple, such as a `getPerimeter` method.
  prefs: []
  type: TYPE_NORMAL
- en: This seems quite simple; you will have to modify each class that implements
    the Shape interface. I'm sure you've faced this problem a lot of times when you
    don't have access to the base source. The solution is to write a wrapper around
    your Shape objects but this introduces more classes and incidental complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has its own idea of polymorphism, it is much simpler but also very powerful;
    you can in fact solve the perimeter problem with it in a very simple way.
  prefs: []
  type: TYPE_NORMAL
- en: One way to solve this is with multimethods; lets have a look at how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multimethods are similar to interfaces, they allow you to write a common contract
    and then a family of functions can fulfill that interface with a specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: They are extremely flexible, as you will see they grant you a very fine control
    over what function is going to get invoked for a specific data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multimethods consist of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A function (or method) declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dispatch function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each possible implementation of the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most interesting features of multimethods is that you can implement
    new functions for already existing types without having to write wrappers around
    your currently existing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multimethod declaration works the same way as the interface; you define
    a common contract for the polymorphic function, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defmulti` macro defines the contract for your multimethod, it consists
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: The multimethod's name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `doctstring` (this is the documentation string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dispatch-fn` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dispatch` function gets called for every piece of content; it generates
    a dispatch key that is later checked against its function implementation. When
    the dispatch key and the key in the function implementation match, the function
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `dispatch` function receives the same parameters that the function you are
    calling receives and returns a dispatch key that is used to determine the function
    that should dispatch the request.
  prefs: []
  type: TYPE_NORMAL
- en: Each implementation function must define a dispatch key, if it matches with
    the `dispatch` function's result, then this function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example should clarify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a multimethod called `area`; the `defmulti` statement
    has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the multimethod is called `area` and the `dispatch` function is
    the `:shape` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, keywords can be used as functions that look up themselves in maps.
    So, for example, the result of (`:shape {:shape :square}`) is `:square`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterwards, we define a method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `dispatch-key` is always the result of invoking the `dispatch-function`
    with `params` as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the invocation, `(area {:shape :square :side 5})` which
    is calling a multimethod. The first thing that happens is that we call the dispatch
    function `:shape`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `:square` function is now the dispatch key, we need to look for the method
    that has that dispatch key; in this case, the only method that we defined works.
    So, the function is executed and we get the result of `25`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is pretty simple to add the area and perimeter for both square and circle,
    lets check the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have defined how to calculate the perimeter and area of circles and
    squares with very little effort and without having to define a very strict object
    hierarchy. However, we are just starting to uncover the power of multimethods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keywords can be namespaced, it allows you to keep your code better organized.
    There are two ways to define a namespaced keyword, such as `:namespace/keyword`
    and `::keyword`. When using the `::` notation, the used namespace is the current
    namespace. So if you write `::test` in the REPL, you will be defining `:user/test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another example, copy the following code into your REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multimethods in Clojure](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it just works as you might expect it to. However, let's see
    how you can create a keyword hierarchy to be a little bit more flexible than this.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can declare that a keyword derives from another keyword and then respond
    to other dispatch keys, for that you can use the `derive` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining a keyword hierarchy, you have to use namespaced keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you are declaring that the `::hominid` key is derived from the `::animal`
    key and you can now use `::hominid` as `::animal`; let''s see that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We do have some problems when defining hierarchies, for instance what will
    happen if the same keyword were to be derived from two conflicting keywords? Let''s
    give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We get an error that says, there are two methods that match the dispatch value.
    Since our hominid derives both from animal and primate, it doesn't know which
    to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can work this out explicitly with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything works correctly. We know that we prefer to resolve to a primate
    when calling the walk multimethod with the hominid key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define a more specific method, just for the `hominid` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The derivation hierarchy can get a little complex and we might need some functions
    to introspect relationships. Clojure has the following functions to work with
    type hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: '`isa?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parents`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`descendants`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`underive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: isa?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `isa` function checks if a type derives from some other type, it works with
    Java classes as well as Clojure keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is simple to explain with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: parents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `parent` function returns a set of a type''s parents, they might be Java
    or Clojure keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: descendants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `descendants` function, as you can imagine, returns a set of descendants
    of the `passd` keyword; it is important to keep in mind that in this case only
    Clojure keywords are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: underive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `underive` function breaks the relation between two types, as you can imagine
    it only works with the Clojure keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function will normally be used at development time and they allow you to
    play around with your type hierarchy in a very simple and dynamic way.
  prefs: []
  type: TYPE_NORMAL
- en: A la carte dispatch functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we have used a keyword as a dispatch function but you can use any
    function you like with as many arguments as you want. Let''s take a look at some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple function, but it shows two important facts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `dispatch` function can receive more than one argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dispatch` key can be anything, not just a keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets have a look at how we can use this `dispatch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are getting to know the `dispatch` function a little bit better; now that
    you know that you can implement any `dispatch` function, you have a very fine
    grained control over what function gets called and when.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets look at one more example, so we can finally grasp the complete idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A la carte dispatch functions](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the true power of multimethods becomes apparent. You now have an adhoc way
    of defining polymorphic functions which has the possibility to define type hierarchies
    and even execute your own logic to determine the function that is going to be
    called finally.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multimethods are just one of the options for polymorphism you have in Clojure,
    there are other ways to implement polymorphic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols are a little easier to understand and they might feel more similar
    to Java interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets try to define our shape program using protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a protocol and it is called shaped and everything that
    implements this protocol must implement the following two functions: `perimeter`
    and `area`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to implement a protocol; one interesting feature
    is that you can even extend Java classes to implement a protocol without an access
    to the Java source and without having to recompile anything.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a record that implements the type.
  prefs: []
  type: TYPE_NORMAL
- en: Records in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Records work exactly like maps, but they are much faster if you stick to the
    predefined keys. Defining a record is similar to defining a class, Clojure knows
    beforehand about the fields that the record will have, so it can generate byte
    code on the fly and the code that uses the records is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets define a `Square` record, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining the `Square` record and it has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It has only one field, `size`; this is going to work as a map with only the
    side key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It implements the `Shape` protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets have a look at how a record is instantiated and how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see it works exactly like a map, you can even associate things to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The downside of doing this is that we no longer have the performance guarantees
    that we had when defining just the record fields; nonetheless, it is a great way
    of giving some structure to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have to check how we can use our perimeter and area functions, it
    is pretty simple. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to continue with the example, let''s define the `Circle` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: One of the promises was that we will be able to extend our existing records
    and types without having to touch the current code. Well, lets keep to that promise
    and check how to extend our records without having to touch existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine, we need to add a predicate telling us whether a shape has an area
    or not; we might then define the next protocol, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get directly to the extend type, which is going to help us define this
    `num-sides` function for our old protocols. Note that with `extend-type` we can
    even define functions for existing Java types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Protocols become much more interesting when you extend them for Java types.
    Lets create a protocol that includes some functions for list like structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And now you can use the positive values, negative values and `non-zero-values`
    with anything that extends from `java.util.List`, including Clojure''s vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It might not be very exciting to extend `java.util.List`, since you can define
    these three as functions and it works the same way but you can extend any custom
    Java type with this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we understand Clojure''s way a little bit better and we have a better grasp
    of what to look for when we need polymorphism. We understand that when needing
    a polymorphic function we have several options:'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement multimethods if we need a highly customized dispatching mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement multimethods if we need to define a complex inheritance structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement a protocol and define a custom type that implements that protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can define a protocol and extend existing Java or Clojure types with our
    custom functions for each type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism in Clojure is very powerful. It allows you to extend the functionality
    of Clojure or Java types that already exist; it feels like adding methods to an
    interface. The best thing about it is that you don't need to redefine or recompile
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about concurrency—one of the key features
    of Clojure. We will learn about the idea of what the identity and values are and
    how those key concepts make writing concurrent programs much easier.
  prefs: []
  type: TYPE_NORMAL
