- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Operators and Casting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符和类型转换
- en: In [*Chapter 2*](B19793_02.xhtml#_idTextAnchor051), we learned that variables
    are simply named pigeonholes and contain values. These values vary and Java provides
    eight primitive data types accordingly. These primitive types cater for whole
    numbers (`byte`, `char`, `short`, `int`, and `long`), decimal numbers (`float`
    and `double`), and the literals true and false (`boolean`).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B19793_02.xhtml#_idTextAnchor051)中，我们了解到变量只是命名的小鸽笼，并包含值。这些值是变化的，Java相应地提供了八个原始数据类型。这些原始类型包括整数（`byte`、`char`、`short`、`int`和`long`）、小数（`float`和`double`）以及布尔字面量（`boolean`）。
- en: We also learned how to declare a variable. As Java is a strongly typed language,
    this means you must give every variable a data type immediately upon declaration.
    This is where primitive data types are very useful.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何声明一个变量。由于Java是一种强类型语言，这意味着你必须在声明变量时立即为其指定一个数据类型。这正是原始数据类型非常有用的地方。
- en: Now that we know how to declare variables, let’s do something interesting with
    them. By the end of this chapter, you will be able to combine variables using
    Java’s various operators. In addition, you will understand Java casting, including
    what it is, and when and why it occurs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何声明变量，让我们用它们做一些有趣的事情。到本章结束时，你将能够使用Java的各种运算符组合变量。此外，你将理解Java类型转换，包括它是什么，以及何时以及为什么发生。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Learning how Java’s operators cooperate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Java运算符的协作方式
- en: Understanding Java’s operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Java的运算符
- en: Explaining Java casting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Java类型转换
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3)。
- en: Learning how Java’s operators cooperate
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Java运算符的协作方式
- en: Java provides numerous operators for us to work with. By way of definition,
    if we have an expression `3 + 4`, the `+` is the *operator*, whereas `3` and `4`
    are the *operands*. Since `+` has *two* operands, it is known as a *binary* operator.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java为我们提供了大量的运算符来使用。根据定义，如果我们有一个表达式 `3 + 4`，那么 `+` 是 *运算符*，而 `3` 和 `4` 是 *操作数*。由于
    `+` 有 *两个* 操作数，它被称为 *二元* 运算符。
- en: Before we discuss the operators themselves, we must first discuss two important
    features relating to Java operators, namely **order of precedence** and **associativity**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论运算符本身之前，我们必须首先讨论与Java运算符相关的两个重要特性，即**优先级顺序**和**结合性**。
- en: Order of precedence
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级顺序
- en: 'Order of precedence specifies how operands are grouped with operators. This
    becomes important when you have shared operands in a complex expression. In the
    following code segment, we have an expression of `2 + 3 * 4`, where `*` represents
    multiplication and `+` represents addition:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级顺序指定了操作数如何与运算符组合。当你在复杂表达式中共享操作数时，这一点变得很重要。在下面的代码段中，我们有一个表达式 `2 + 3 * 4`，其中
    `*` 代表乘法，`+` 代表加法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `3` is shared by both `2` and `4`. So, the question arises,
    do we group `3` with `2`, where the expression is `(2 + 3) * 4`, giving us `20`;
    or do we group `3` with `4`, where the expression is `2 + (3 * 4)`, giving us
    `14`? This is where the order of precedence applies. As `*` has higher precedence
    than `+`, `3` is grouped with `4` and therefore the expression evaluates to `2
    + (3 * 4)`. Note that the evaluation order is still left to right; it is just
    that `3` is grouped with `4` rather than with `2`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`3` 同时被 `2` 和 `4` 使用。因此，问题出现了，我们是将 `3` 与 `2` 组合在一起，表达式为 `(2 + 3) * 4`，得到
    `20`；还是将 `3` 与 `4` 组合在一起，表达式为 `2 + (3 * 4)`，得到 `14`？这就是优先级顺序发挥作用的地方。由于 `*` 的优先级高于
    `+`，`3` 与 `4` 组合在一起，因此表达式计算为 `2 + (3 * 4)`。请注意，计算顺序仍然是左到右；只是 `3` 与 `4` 组合在一起，而不是与
    `2` 组合在一起。
- en: Parentheses in an expression
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的括号
- en: Note that parentheses can change the default order of operator precedence. As
    we have seen, the default order of precedence, where `*` has higher precedence
    than `+`, means that `2 + 3 * 4` is `14`. This is the same as `2 + (3 *` `4)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，括号可以改变运算符的默认优先级顺序。正如我们所见，默认的优先级顺序，其中 `*` 的优先级高于 `+`，意味着 `2 + 3 * 4` 的结果是
    `14`。这等同于 `2 + (3 * 4)`。
- en: However, `(2 + 3) * 4` is `20`. In this case, the parentheses grouped `3` with
    `2`, so the expression evaluated to `5 * 4 =` `20`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`(2 + 3) * 4` 的结果是 `20`。在这种情况下，括号将 `3` 与 `2` 组合在一起，因此表达式计算为 `5 * 4 = 20`。
- en: This begs the question, what if you are evaluating an expression that contains
    operators at the same level of precedence? This is where associativity applies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了一个问题，如果你正在评估一个包含具有相同优先级的运算符的表达式，这时结合性就适用了。
- en: Associativity
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合性
- en: 'When an expression has two operators with the same level of precedence, operator
    associativity determines the groupings of operators and operands. For example,
    in the following code segment, we are evaluating a simple expression involving
    two divisions (which have the same level of precedence):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式包含两个具有相同优先级的运算符时，运算符的结合性决定了运算符和操作数的分组。例如，在以下代码段中，我们正在评估一个涉及两个除法（它们具有相同的优先级）的简单表达式：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As division associates left to right, `6` will be grouped with `72` and not
    `3`. Thus, the expression is the same as `(72 / 6) / 3`, which evaluates to `12
    / 3 = 4`. Parentheses can also be used to change the default associativity order.
    Take, for example, the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于除法运算符从左到右结合，`6` 将与 `72` 结合，而不是与 `3` 结合。因此，表达式等同于 `(72 / 6) / 3`，其结果为 `12 /
    3 = 4`。括号也可以用来改变默认的结合顺序。例如，以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, `6` is now grouped with `3` and the expression evaluates to `72
    / 2 =` `36`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`6` 现在将与 `3` 结合，表达式计算结果为 `72 / 2 =` `36`。
- en: '*Table 3.1* outlines the order of precedence and associativity rules:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 3.1* 概述了优先级和结合性规则：'
- en: '![Table 3.1 – Order of precedence and associativity rules](img/B19793_03_Table_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![表 3.1 – 优先级和结合性规则顺序](img/B19793_03_Table_01.jpg)'
- en: Table 3.1 – Order of precedence and associativity rules
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 优先级和结合性规则顺序
- en: Note that *Table 3.1* is simplified in that it refers to the operators that
    are commonly used. For example, the unsigned right shift operator, `>>>`, is omitted
    as it is rarely used. Also, note that the `instanceof` operator will be discussed
    in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*表 3.1* 是简化的，因为它只提到了常用的运算符。例如，无符号右移运算符 `>>>` 被省略，因为它很少使用。另外，请注意，`instanceof`
    运算符将在 [*第 8 章*](B19793_08.xhtml#_idTextAnchor168) 中讨论。
- en: 'It is interesting to note that the assignment operator, namely `=`, is at the
    bottom of the precedence table. This means that regardless of the expression on
    the right-hand side of the assignment, the assignment will always be done last.
    This makes sense. Also, while most of the operators associate left to right, the
    assignment associates right to left. This is demonstrated in the following code
    segment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，赋值运算符，即 `=`，在优先级表中位于底部。这意味着无论赋值右侧的表达式是什么，赋值总是最后进行的。这是有道理的。此外，虽然大多数运算符的结合性是从左到右的，但赋值运算符的结合性是从右到左的。这在下述代码段中得到了演示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code segment outputs `false` three times. The crucial line is
    `b3 = b2 = b1;`. Since the assignment associates right to left, the value in `b1`,
    which is `false`, is assigned to `b2`; then, the value in `b2`, which is now `false`,
    is assigned to `b3`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段输出了 `false` 三次。关键行是 `b3 = b2 = b1;`。由于赋值运算符的结合性是从右到左的，所以 `b1` 中的值，即 `false`，被赋值给
    `b2`；然后，`b2` 中的值，现在是 `false`，被赋值给 `b3`。
- en: Now that we understand these properties, let’s examine the operators themselves.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些属性，让我们来检查运算符本身。
- en: Understanding Java’s operators
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Java 的运算符
- en: 'Operators can be grouped into the following categories:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符可以分为以下几类：
- en: Unary operators
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符
- en: Arithmetic operators
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Relational operators
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Logical operators
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Ternary operator
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元运算符
- en: Compound assignment operators
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: We will now discuss each category in turn.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将依次讨论每一类。
- en: Unary operators
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一元运算符
- en: Unary operators have only one operand, hence the term *unary*. Let’s examine
    them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符只有一个操作数，因此称为*一元*。让我们来检查它们。
- en: Prefix and postfix unary operators
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前缀和后缀一元运算符
- en: '`++` and `--` denote these operators and they increment and decrement by 1,
    respectively. If the operator appears before the variable, it is known as *prefix*,
    while if the operator appears after the variable, it is called *postfix*. For
    example, *++x* is prefix increment, whereas *y--* is postfix decrement.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 和 `--` 表示这些运算符，它们分别增加和减少1。如果运算符出现在变量之前，它被称为*前缀*，而如果运算符出现在变量之后，它被称为*后缀*。例如，*++x*
    是前缀递增，而 *y--* 是后缀递减。'
- en: 'Depending on whether `++` or `--` appears before or after the variable can,
    in some situations, affect the overall expression. This is best explained with
    a code sample, as shown in *Figure 3**.1*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `++` 或 `--` 是出现在变量之前还是之后，在某些情况下可能会影响整个表达式的结果。这最好通过代码示例来解释，如 *图 3**.1* 所示：
- en: '![Figure 3.1 – Prefix and postfix increment and decrement operators](img/B19793_03_1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 前缀和后缀递增和递减运算符](img/B19793_03_1.jpg)'
- en: Figure 3.1 – Prefix and postfix increment and decrement operators
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 前缀和后缀递增和递减运算符
- en: In *Figure 3**.1*, on line 25, we can see that `x` is initialized to `3`. On
    line 26, `x` is incremented by 1 to `4`. Line 26 is a simple statement and because
    of that, whether it is prefix or postfix notation does not matter. Line 27 outputs
    the value of `x` to show that it is `4` at this point.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.1中，第25行我们可以看到`x`被初始化为`3`。在第26行，`x`增加1变为`4`。第26行是一个简单语句，因此，无论是前缀还是后缀表示法，都没有关系。第27行输出`x`的值，以显示此时它的值是`4`。
- en: Line 28 is where things get interesting. The postfix notation on line 28 has
    a real effect on the screen output. As it is the postfix notation in the `System.out.println`
    command, the current value of `x` is output, and *afterwards*, `x` is incremented
    by 1\. So, the output to the screen is `4`, and afterwards, `x` is incremented
    to `5`. Line 29 demonstrates that `x` is `5`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行是事情变得有趣的地方。第28行的后缀表示法对屏幕输出有实际影响。因为它是在`System.out.println`命令中的后缀表示法，所以输出的是`x`的当前值，然后`x`增加1。所以，屏幕上的输出是`4`，然后`x`增加到`5`。第29行演示了`x`是`5`。
- en: On line 31, `y` is initialized to `4`. On line 32, `y` is decremented by 1 to
    `3`. Again, as line 32 is a simple statement, prefix or postfix notation makes
    no difference. Line 33 outputs the value of `y` to show that it is `3` at this
    point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第31行，变量`y`被初始化为`4`。在第32行，`y`减去1变为`3`。再次强调，由于第32行是一个简单语句，前缀或后缀表示法没有区别。第33行输出`y`的值，以显示此时它的值是`3`。
- en: The prefix notation on line 34 has no real effect on the screen output. As it
    is the prefix notation in the `System.out.println` command, the current value
    of `y` is decremented `y` and the output to the screen match (both are `2`). Lastly,
    line 35 demonstrates that the current value of `y` is `2`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第34行的前缀表示法对屏幕输出没有实际影响。因为它是在`System.out.println`命令中的前缀表示法，所以先递减`y`的值，然后输出到屏幕的值匹配（两者都是`2`）。最后，第35行演示了`y`的当前值是`2`。
- en: Unary plus/minus operators
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一元加减运算符
- en: 'Now that we have discussed the prefix and postfix operators, let’s discuss
    other unary operators. The code in *Figure 3**.2* will help:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了前缀和后缀运算符，让我们来讨论其他一元运算符。图3.2中的代码将有所帮助：
- en: '![Figure 3.2 – Other unary operators](img/B19793_03_2.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 其他一元运算符](img/B19793_03_2.jpg)'
- en: Figure 3.2 – Other unary operators
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 其他一元运算符
- en: In *Figure 3**.2*, line 37 uses the unary plus sign, `+`, to initialize `x`
    to `6`. Here, `+` is the default as numbers without a sign are assumed to be positive
    numbers. Line 38 uses the unary minus sign, `-`, to initialize `y` to be the negative
    of `x`. Lines 39 and 40 demonstrate that `x` and `y` are `6` and `-``6`, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2中，第37行使用一元加号`+`将`x`初始化为`6`。在这里，`+`是默认的，因为不带符号的数字被认为是正数。第38行使用一元减号`-`将`y`初始化为`x`的相反数。第39和第40行演示了`x`和`y`分别是`6`和`-6`。
- en: Cast operator
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换运算符
- en: In *Figure 3**.2*, line 42 uses the cast operator. We will discuss casting in
    greater detail later in this chapter. For now, `3.45` is a `double` literal (8
    bytes) and cannot be stored in an `int` variable, `z`, as `int` variables are
    4 bytes in size. The compiler spots this and generates an error. To get around
    this error, we can use a cast, which takes the form of *(cast type)*. This cast
    enables us to override the compiler error. In this case, we are casting `3.45`
    to an `int` variable, which means we lose the decimal places. Thus, we store `3`
    in `z`, as shown by the output from line 43.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2中，第42行使用了类型转换运算符。我们将在本章后面更详细地讨论类型转换。现在，`3.45`是一个`double`字面量（8字节），不能存储在大小为4字节的`int`变量`z`中。编译器会检测到这一点并生成错误。为了绕过这个错误，我们可以使用类型转换，其形式为`(cast
    type)`。这种转换使我们能够覆盖编译器错误。在这种情况下，我们将`3.45`转换为一个`int`变量，这意味着我们失去了小数位。因此，我们将`3`存储在`z`中，如第43行的输出所示。
- en: Logical NOT operator
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑非运算符
- en: In *Figure 3**.2*, on line 45, we declare a boolean, `b`, and initialize it
    to `true`. On line 46, we output the inverted value of `b` by using the logical
    NOT operator. Note that we are not changing the value of `b` meaning, the value
    of `b` is still `true`. This is shown by the output from line 47.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2中，第45行声明了一个布尔变量`b`并将其初始化为`true`。在第46行，我们通过使用逻辑非运算符输出`b`的相反值。请注意，我们并没有改变`b`的值，也就是说，`b`的值仍然是`true`。这可以通过第47行的输出得到证明。
- en: Now, let’s examine the arithmetic operators.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查算术运算符。
- en: Arithmetic operators
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: There are five arithmetic operators, all of which we will examine now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种算术运算符，我们将在下面逐一考察。
- en: Addition/subtraction operators
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加法/减法运算符
- en: 'As in mathematics, the `+` operator represents addition and the `-` operator
    represents subtraction. Both are binary operators; in other words, there are two
    operands, one on either side of the operator. The following code example demonstrates
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如同数学一样，`+` 运算符代表加法，`-` 运算符代表减法。两者都是二元运算符；换句话说，有两个操作数，一个在运算符的左侧，一个在右侧。以下代码示例展示了这一点：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code segment, `res` has been assigned a value of `6 + 4 – 2`, which
    is `8`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码段中，`res` 被分配了 `6 + 4 – 2` 的值，即 `8`。
- en: Multiplication/division operators
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法/除法运算符
- en: 'The `*` operator represents multiplication and the `/` operator represents
    division. Both are binary operators. Note that *integer division truncates*. The
    following code segment demonstrates this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 运算符代表乘法，`/` 运算符代表除法。两者都是二元运算符。请注意，*整数除法会截断*。以下代码段展示了这一点：'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code segment outputs `3` because integer division truncates. We are dividing
    one integer, `10`, by another integer, `3`. The remainder is simply discarded.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码段输出 `3`，因为整数除法会截断。我们正在将一个整数 `10` 除以另一个整数 `3`，余数被简单地丢弃。
- en: Modulus operator
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 余数运算符
- en: 'The `%` operator is used for calculating the modulus (remainder). The following
    code example demonstrates the modulus operator in action:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 运算符用于计算余数（余数）。以下代码示例展示了余数运算符的作用：'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line initializes `mod1` to be the remainder of `10` divided by `3`,
    which is `1`. In other words, `3` goes into `10` three times and `1` is left over.
    Therefore, `1` is assigned to `mod1`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将 `mod1` 初始化为 `10` 除以 `3` 的余数，即 `1`。换句话说，`3` 可以整除 `10` 三次，剩下 `1`。因此，`1` 被分配给
    `mod1`。
- en: 'The initialization of `mod2` is interesting: `3` goes into `0` zero times and
    there is `0` (or nothing) left over. Hence, `0` is assigned to `mod2`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod2` 的初始化很有趣：`3` 不能整除 `0`，没有剩余。因此，`0` 被分配给 `mod2`。'
- en: The precedence of arithmetic operators
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符的优先级
- en: 'As per *Table 3.1*, `*`, `/`, and `%` have higher precedence than the `+` and
    `–` operators, and assignment has the lowest precedence. *Figure 3**.3* shows
    how this affects the evaluation of expressions in code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *表 3.1*，`*`、`/` 和 `%` 的优先级高于 `+` 和 `–` 运算符，赋值运算符的优先级最低。*图 3**.3* 展示了这如何影响代码中表达式的计算：
- en: '![Figure 3.3 – Arithmetic operators precedence](img/B19793_03_3.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 算术运算符优先级](img/B19793_03_3.jpg)'
- en: Figure 3.3 – Arithmetic operators precedence
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 算术运算符优先级
- en: Lines 61 demonstrates that `*` has higher precedence than `+`, in that the expression
    evaluates to `3 + (2 * 4) = 3 + 8 =` `11`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第 61 行展示了 `*` 的优先级高于 `+`，因为表达式的计算结果是 `3 + (2 * 4) = 3 + 8 =` `11`。
- en: Line 63 demonstrates that parentheses change the grouping. Now, the shared value,
    `2`, is grouped with `3` (as opposed to `4`, which was the case on line 61). The
    expression now evaluates to `5 * 4 =` `20`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第 63 行展示了括号会改变分组。现在，共享值 `2` 与 `3` 分组（而不是第 61 行的情况，那时是 `4`）。表达式现在计算结果为 `5 * 4
    =` `20`。
- en: Line 65 demonstrates that `+` and `-` associate left to right. The expression
    evaluates to
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第 65 行展示了 `+` 和 `-` 也是从左到右结合的。表达式的计算结果为
- en: '`10 - 2 =` `8`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`10 - 2 =` `8`。'
- en: Lines 67 demonstrates that `*`, `/`, and `%` also associate left to right. The
    expression evaluates to `2 * 6 % 10`, which, in turn, evaluates to `12 % 10`,
    which is `2`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第 67 行展示了 `*`、`/` 和 `%` 也从左到右结合。表达式计算结果为 `2 * 6 % 10`，这又转换为 `12 % 10`，结果是 `2`。
- en: Math operations involving `int` variables or smaller result in an `int`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及 `int` 变量或更小类型的数学运算结果为 `int`
- en: 'It is interesting to note that any math operation involving an `int` type or
    smaller results in `int`. This is demonstrated in the following code segment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，任何涉及 `int` 类型或更小类型的数学运算都会得到 `int` 类型。以下代码段展示了这一点：
- en: '`byte` `b1=2, b2=3;`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte` `b1=2, b2=3;`'
- en: '`byte b3 = b1 + b2; //` `compiler error`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte b3 = b1 + b2; //` `编译器错误`'
- en: '`byte b4 = (byte)(b1 +` `b2);// Ok`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte b4 = (byte)(b1 +` `b2);// 正确`'
- en: The first line declares 2 bytes, namely `b1` and `b2`. Notice that, even though
    `2` and `3` are integer literals, the compiler is aware that these values are
    within the range of `byte` (-128 to +127) and, consequently, allows the declarations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了两个字节，即 `b1` 和 `b2`。请注意，尽管 `2` 和 `3` 是整数文字，但编译器知道这些值在 `byte` 的范围（-128 到
    +127）内，因此允许这些声明。
- en: However, the next line is a problem. The compiler has a rule that all math operations
    involving `int` types or smaller result in an `int`. Therefore, even though the
    sum of the two bytes, 5, is well within the `byte` range, the compiler complains
    saying “possible loss of data converting from `int` to `byte`”.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下一行是一个问题。编译器有一个规则，即所有涉及 `int` 类型或更小类型的数学运算的结果都是 `int`。因此，即使两个字节之和 5 在 `byte`
    范围内，编译器也会报错，说“从 `int` 转换到 `byte` 可能会丢失数据”。
- en: The last line fixes this issue by casting the result of the addition (an `int`
    type) to a `byte` before the assignment. What this means is that the extra 3 bytes
    from the `int` (that do not fit into the `byte`) are simply discarded. Thus, the
    sum of `b1 + b2` is cast from `int` to `byte` and the resultant `byte` is assigned
    to `b4`. Casting is discussed in more detail later in the chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行通过在赋值之前将加法的结果（`int` 类型）强制转换为 `byte` 来解决这个问题。这意味着 `int` 类型的额外 3 个字节（无法放入
    `byte` 中）将被简单地丢弃。因此，`b1 + b2` 的和从 `int` 转换为 `byte`，结果 `byte` 被赋值给 `b4`。在后面的章节中会更详细地讨论强制转换。
- en: We will finish our discussion on arithmetic operators by examining `+` in a
    different context.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过考察 `+` 在不同上下文中的用法来结束对算术运算符的讨论。
- en: String append
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: As we have seen, Java uses `+` for mathematical addition. However, this occurs
    only if both operands are numbers. For example, 3 + 4 results in 7 because both
    operands, 3 and 4, are numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Java 使用 `+` 进行数学加法。然而，这仅在两个操作数都是数字时才会发生。例如，3 + 4 的结果是 7，因为两个操作数 3 和 4
    都是数字。
- en: 'However, if either operand (or both) are strings, Java performs a `String`
    append. A `String` literal is enclosed in double quotes – for example, `"abc"`,
    `"123"`, `"Sean"`, and `"Maaike"` are all `String` literals. So, just to be clear
    on what operation is performed and when, let’s take a look at some examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果任一操作数（或两个都是）是字符串，Java 会执行 `String` 连接。字符串字面量用双引号括起来——例如，`"abc"`、`"123"`、`"Sean"`
    和 `"Maaike"` 都是 `String` 字面量。所以，为了清楚地了解何时执行何种操作，让我们看看一些示例：
- en: 3 + 4 is mathematical addition. Thus, the result is 7.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 + 4 是数学加法。因此，结果是 7。
- en: “3” + 4 is a string append as there is a string on the left of `+`. The result
    is the string “34.”
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “3” + 4 是一个字符串连接操作，因为 `+` 的左边有一个字符串。结果是字符串 “34。”
- en: 3 + “4” is a string append as there is a string on the right of `+`. Again,
    the result is the string “34.”
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 + “4” 是一个字符串连接操作，因为 `+` 的右边有一个字符串。再次，结果是字符串 “34。”
- en: “3” + “4” is a string append as there is a string on both sides of `+`. The
    result is also the string “34.”
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “3” + “4” 是一个字符串连接操作，因为 `+` 的两边都有字符串。结果也是字符串 “34。”
- en: 'So, what exactly happens during a string append? *Java cannot perform any mathematical
    operations when the operands are of different types*. Let’s examine this with
    an example piece of code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在字符串连接操作中到底发生了什么？*Java 当操作数类型不同时无法执行任何数学运算*。让我们通过一段示例代码来分析：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing to note is that the first line of code only compiles because
    `"3" + 4` results in a `String` literal. When Java encounters a string on the
    left/right/both sides of `+`, it performs string concatenation (append). Essentially,
    as `+` associates left to right, Java appends (adds) the string on the right of
    `+` to the end of the string on the left of `+`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，第一行代码之所以能编译，是因为 `"3" + 4` 的结果是字符串字面量。当 Java 遇到 `+` 的左边/右边/两边都有字符串时，它会执行字符串连接（追加）。本质上，由于
    `+` 是从左到右结合的，Java 会将 `+` 右边的字符串追加到 `+` 左边的字符串的末尾。
- en: In this example, Java sees the `String` literal `"3"` and the `+` operator and
    realizes it must perform a `String` append. To do this, in memory, it creates
    a string version of 4 – in other words, `"4"`. The integer `4` literal is not
    touched. Thus, a new variable is created under the hood – it is a `String` variable,
    and `"4"` is its value. The expression is now `"3" + "4"`. As both operands on
    either side of `+` are now of the same type (both are strings), Java can perform
    the append. The new string is the result of `"3" + "4"`, which is `"34"`. This
    is what is assigned to `s`. The second line demonstrates this by outputting `"34"`
    for `s`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Java 看到了字符串字面量 `"3"` 和 `+` 操作符，并意识到它必须执行字符串连接。为此，在内存中，它创建了一个 4 的字符串版本——换句话说，`"4"`。整数字面量
    `4` 没有被修改。因此，在底层创建了一个新的变量——它是一个 `String` 变量，其值为 `"4"`。现在表达式是 `"3" + "4"`。由于 `+`
    的两边现在都是相同类型的操作数（都是字符串），Java 可以执行连接。新的字符串是 `"3" + "4"` 的结果，即 `"34"`。这就是被赋值给 `s`
    的内容。第二行通过输出 `s` 的 `"34"` 来演示这一点。
- en: 'In *Figure 3**.4*, a more substantial example is presented:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3**.4* 中，提供了一个更复杂的示例：
- en: '![Figure 3.4 – String append in action](img/B19793_03_4.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 字符串连接操作](img/B19793_03_4.jpg)'
- en: Figure 3.4 – String append in action
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 字符串连接操作
- en: On line 79, as both operands, `a` and `b`, are integers, Java initializes `res`
    to `5` (the sum of `3` and `2`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 79 行，由于两个操作数 `a` 和 `b` 都是整数，Java 将 `res` 初始化为 `5`（`3` 和 `2` 的和）。
- en: 'Line 82 is evaluated as follows: `3 + "abc" = "3" + "abc" = "3abc"`. In other
    words, Java realizes that it must do a string append due to the presence of `"abc"`
    on the right-hand side of `+`. Thus, somewhere in memory, a string version of
    the value of `a` is created. In other words, a variable with `"3"` is created.
    Note that `a` *remains an int with 3 as its value*. Now, Java can proceed since
    both operands are the same type (strings): `"3" + "abc"` results in `"3abc"`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第 82 行的评估方式如下：`3 + "abc" = "3" + "abc" = "3abc"`。换句话说，Java 认识到由于 `+` 的右侧存在 `"abc"`，它必须执行字符串连接。因此，在内存的某个地方，创建了一个包含
    `a` 值的字符串版本。换句话说，创建了一个值为 `"3"` 的变量。请注意，`a` 仍然是一个值为 3 的 `int` 类型。现在，Java 可以继续执行，因为两个操作数都是同一类型（字符串）：`"3"
    + "abc"` 结果为 `"3abc"`。
- en: 'Line 83 demonstrates that it does not matter which side of `+` the string is
    on. Plus, it does not matter if the string is a string literal or a string variable.
    The expression on line 83 is evaluated as follows: `"abc" + 3 = "abc" + "3" =
    "abc3"`. This is what `s2` is initialized to. Line 84 outputs the values of both
    `s1` and `s2` with a space between them. Note that `System.out.println` expects
    a string. The string output on line 84 is constructed as follows: `"3abc" + "
    " = "3abc " + "abc3" = "``3abc abc3"`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第 83 行演示了字符串在 `+` 的哪一侧并不重要。此外，字符串是字面量还是字符串变量也不重要。第 83 行的表达式评估方式如下：`"abc" + 3
    = "abc" + "3" = "abc3"`。这就是 `s2` 的初始化值。第 84 行输出 `s1` 和 `s2` 的值，它们之间有一个空格。请注意，`System.out.println`
    期望一个字符串。第 84 行的字符串输出构造方式如下：`"3abc" + " " = "3abc " + "abc3" = "3abc abc3"`。
- en: 'Lines 86 and 87 require special mention. The problem with line 86 is that the
    output string is constructed as follows: `"Output is "+ 3 = "Output is " + "3"
    = "Output is 3" + 2 = "Output is 3" + "2" = "Output is 32"`. This is not what
    we wanted.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第 86 和 87 行需要特别说明。第 86 行的问题在于输出字符串的构造方式如下：`"Output is "+ 3 = "Output is " +
    "3" = "Output is 3" + 2 = "Output is 3" + "2" = "Output is 32"`。这不是我们想要的结果。
- en: 'Line 87 rectifies this by using parentheses to ensure that `a + b` is grouped.
    Thus, the string is constructed as follows: `"Output is "+ 5 = "Output is "+ "5"
    = "Output` `is 5"`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第 87 行通过使用括号来确保 `a + b` 被分组，从而纠正了这个问题。因此，字符串的构造方式如下：`"Output is "+ 5 = "Output
    is "+ "5" = "Output is 5"`。
- en: That finishes the arithmetic operators. We will now examine relational operators.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了算术运算符的介绍。接下来，我们将研究关系运算符。
- en: Relational operators
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: 'Java has six relational operators, all of which result in a `boolean` value
    of `true` or `false`. They are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有六个关系运算符，它们都返回 `boolean` 类型的 `true` 或 `false` 值。具体如下：
- en: '`==` is the equivalence operator'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 是等价运算符'
- en: '`!=` is the not equivalent operator'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 是不等价运算符'
- en: '`>` is the greater than operator'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 是大于运算符'
- en: '`>=` is the greater than or equal to operator'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 是大于或等于运算符'
- en: '`<` is the less than operator'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 是小于运算符'
- en: '`<=` is the less than or equal to operator'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 是小于或等于运算符'
- en: '*Figure 3**.5* shows the relational operators in action in code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.5* 展示了关系运算符在代码中的实际应用：'
- en: '![Figure 3.5 – Relational operators in code](img/B19793_03_5.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 代码中的关系运算符](img/B19793_03_5.jpg)'
- en: Figure 3.5 – Relational operators in code
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 代码中的关系运算符
- en: Line 89 declares two `int` variables, namely `x` and `y`, and initializes them
    to `3` and `4`, respectively. Line 90 uses Java’s equivalence operator, `==`,
    to check if `x` and `y` are equivalent. As they are not, line 90 outputs `false`.
    Line 91 checks the exact opposite. As `x` is not equivalent to `y`, line 91 outputs
    `true`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第 89 行声明了两个 `int` 类型的变量，分别是 `x` 和 `y`，并将它们分别初始化为 `3` 和 `4`。第 90 行使用 Java 的等价运算符
    `==` 来检查 `x` 和 `y` 是否等价。由于它们不等价，第 90 行输出 `false`。第 91 行检查相反的情况。由于 `x` 不等价于 `y`，第
    91 行输出 `true`。
- en: Line 92 outputs whether `x` is greater than `y`. This is, of course, `false`
    as `3` is not greater than `4`. Similarly, line 93 outputs whether `x` is greater
    than or equal to `y`. Again, this is `false`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第 92 行输出 `x` 是否大于 `y`。当然，这是 `false`，因为 `3` 不大于 `4`。同样，第 93 行输出 `x` 是否大于或等于 `y`。这同样是
    `false`。
- en: Line 94 outputs whether `x` is less than `y`. This is `true` as `3` is less
    than `4`. Line 95 outputs whether `x` is less than or equal to `y`. Again, this
    is `true`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第 94 行输出 `x` 是否小于 `y`。这是 `true`，因为 `3` 小于 `4`。第 95 行输出 `x` 是否小于或等于 `y`。这同样是
    `true`。
- en: The relational operators and their boolean return values are going to be extremely
    useful going forward, particularly when we look at conditional statements in [*Chapter
    4*](B19793_04.xhtml#_idTextAnchor087).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符及其布尔返回值在以后将非常有用，尤其是当我们查看*第4章*（B19793_04.xhtml#_idTextAnchor087）中的条件语句时。
- en: Implicit promotion
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式提升
- en: 'While Java’s operators do not require the operands to be exactly the same type,
    the operands must be compatible. Consider the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java的运算符不需要操作数必须是完全相同的类型，但操作数必须是兼容的。考虑以下代码片段：
- en: '`System.out.println(3 + 4.0); //` `7.0`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(3 + 4.0); //` `7.0`'
- en: '`System.out.println(4 == 4.0); //` `true`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(4 == 4.0); //` `true`'
- en: The first line tries to add an `int` variable of `3` to a `double` variable.
    Java realizes that the types are not the same. However, Java can figure out a
    safe solution without bothering us. This is where *implicit promotion* comes in.
    `int` requires 4 bytes of storage whereas `double` requires 8 bytes. In the background,
    somewhere in memory, Java declares a temporary `double` variable and promotes
    `int 3` to `double 3.0`, and stores `3.0` in this temporary location. Now, Java
    can add `3.0` to `4.0` (as both are `double`s), resulting in the answer `7.0`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行尝试将一个`int`类型的`3`变量加到一个`double`类型的变量上。Java意识到这两个类型并不相同。然而，Java可以找出一个安全的解决方案而不打扰我们。这就是*隐式提升*的作用。`int`类型需要4个字节的存储空间，而`double`类型需要8个字节的存储空间。在后台，内存的某个地方，Java声明了一个临时的`double`变量，并将`int
    3`提升为`double 3.0`，然后将`3.0`存储在这个临时位置。现在，Java可以将`3.0`加到`4.0`上（因为两者都是`double`类型），得到的结果是`7.0`。
- en: The second line compares `int 4` with `double 4.0`. The same process happens.
    Java implicitly promotes `4` to `4.0` (in a new temporary location) and then compares
    `4.0` with `4.0`. This results in `true` being output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行比较`int 4`和`double 4.0`。发生同样的过程。Java隐式地将`4`提升为`4.0`（在新的临时位置），然后比较`4.0`和`4.0`。这导致输出`true`。
- en: Now, we will turn our attention to logical operators.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向逻辑运算符。
- en: Logical operators
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators enable us to build complex `boolean` expressions by combining
    sub-expressions. These operators are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符使我们能够通过组合子表达式来构建复杂的`boolean`表达式。这些运算符如下：
- en: '`&&` is the logical AND'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`是逻辑与'
- en: '`||` is the logical OR'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`是逻辑或'
- en: '`&` is the bitwise AND'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`是位与'
- en: '`|` is the bitwise OR'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`是位或'
- en: '`^` is the bitwise eXclusive OR (XOR)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`是位异或（XOR）'
- en: 'We will examine these in turn with code examples to help explain how they operate.
    But before we do that, it is worthwhile refreshing our truth tables, as shown
    in *Table 3.2*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次通过代码示例来检查这些运算符，但在这样做之前，回顾一下*表3.2*中的真值表是有益的，如下所示：
- en: '![Table 3.2 – Boolean truth tables](img/B19793_03_Table_02.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![表3.2 – 布尔真值表](img/B19793_03_Table_02.jpg)'
- en: Table 3.2 – Boolean truth tables
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 – 布尔真值表
- en: In *Table 3.2*, the first two columns, **P** and **Q**, represent two expressions,
    where **T** means true and **F** means false. For example, the logical AND column
    (the **P && Q** column) represents the result of the overall expression, **P &&
    Q**, depending on the values of **P** and **Q**. So, if **P** is true and **Q**
    is **T**, then **P && Q** is also true.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表3.2*中，前两列，**P**和**Q**，代表两个表达式，其中**T**表示真，**F**表示假。例如，逻辑与列（**P && Q**列）表示整体表达式**P
    && Q**的结果，这取决于**P**和**Q**的值。所以，如果**P**为真且**Q**为**T**，那么**P && Q**也为真。
- en: With this table in mind, let’s examine the operators in turn.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格的指导下，我们依次检查运算符。
- en: Logical AND (&&)
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑与（&&）
- en: The logical AND states that both boolean operands must be true for the overall
    expression to be true. This is represented by the **P && Q** column in *Table
    3.2*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与运算符表示两个布尔操作数都必须为真，整个表达式才为真。这由*表3.2*中的**P && Q**列表示。
- en: 'Note that this operator is known as a short-circuiting operator. For example,
    in an expression P && Q, if P evaluates to false, then && will *not* evaluate
    the expression Q because the overall expression will evaluate to false regardless.
    This is because F && F is false and F && T is also false. In effect, Java knows
    that once the expression P is false on the left-hand side of an && expression,
    the overall expression must be false. So, there is no need to evaluate the Q expression
    on the right-hand side, so it *short-circuits*. This is better explained with
    a code example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line initializes two boolean variables, `b1` and `b2`, to `false`
    and `true`, respectively. The second line is the important one. Note that the
    parentheses are required around the `b2=false` sub-expression to get the code
    to compile (otherwise, you will get a syntax error). So, when we plug in `false`
    for `b1`, the expression evaluates to `F && (b2=false)`. As the evaluation order
    is left to right, this will lead `&&` to short-circuit, because, regardless of
    what remains in the expression, there is no way the overall expression can evaluate
    to true. This means that the `(b2=false)` sub-expression is **not** executed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The last line outputs the values of the variables. The output is `false`, `true`,
    and `false` for `b1`, `b2`, and `res`, respectively. Crucially, `b2` is `true`,
    demonstrating that `&&` short-circuited.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Logical OR (||)
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logical OR states that either or both boolean operands can be true for the
    overall expression to be true. This is represented by the **P || Q** column in
    *Table 3.2*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator is also a short-circuiting operator. For example, in an expression
    P || Q, if P evaluates to true, then || will *not* evaluate the expression Q because
    the overall expression will evaluate to true regardless. This is because T ||
    F is true and T || T is also true. In effect, Java knows that once the expression
    P is true on the left-hand side of an || expression, the overall expression must
    be true. So, there is no need to evaluate the expression, Q, and hence it *short-circuits*.
    Again a code example will help:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line initializes two boolean variables, `b1` and `b2`, to `false`
    and `true`, respectively. The second line is the important one. Note again that
    the parentheses are required around the `b1=true` sub-expression to get the code
    to compile. So, when we plug in `true` for `b2`, the expression evaluates to `T
    || (b1=true)`. As the evaluation order is left to right, this will lead `||` to
    short-circuit because, regardless of what remains in the expression, there is
    no way the overall expression can evaluate to false.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The last line outputs the values of the variables. The output is `false`, `true`,
    and `true` for `b1`, `b2`, and `res`, respectively. Crucially, `b1` is `false`,
    demonstrating that `||` short-circuited.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Order of evaluation versus precedence
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'This topic often causes confusion and is best explained with some sample pieces
    of code. Let’s start with an example that can be deceptively simple:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题经常引起混淆，最好通过一些示例代码来解释。让我们从一个看似简单的例子开始：
- en: '`int x=2,` `y=3, z=4;`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`int x=2, y=3, z=4;`'
- en: '`int res = x + y * z; // x + (y *` `z)`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`int res = x + y * z; // x + (y * z)`'
- en: '`System.out.println(res);// 14`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(res); // 14`'
- en: As `*` has higher precedence than `+`, the common element `y`, is grouped with
    `z` and not `x`. Thus, the overall expression is `x + (y * z)` = 2 + 12 = 14.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `*` 的优先级高于 `+`，公共元素 `y` 与 `z` 而不是 `x` 组合在一起。因此，整个表达式是 `x + (y * z)` = 2 +
    12 = 14。
- en: 'What is important to note here is that the evaluation order is left to right
    and as evaluation order trumps precedence, `x` is evaluated first before the `(y
    * z)` sub-expression. While this makes no difference in this example, let’s look
    at an example where it does make a difference:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的重要一点是评估顺序是从左到右的，并且由于评估顺序高于优先级，`x` 在 `(y * z)` 子表达式之前被评估。虽然在这个例子中这没有区别，但让我们看看一个有区别的例子：
- en: '`boolean a=false,` `b=false, c=false;`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean a=false, b=false, c=false;`'
- en: '`// a || (b &&` `c)`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`// a || (b && c)`'
- en: '`// The next line evaluates to` `T ||`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 下行计算结果为 T ||`'
- en: '`boolean bool = (a = true) || (b = true) && (c =` `true);`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean bool = (a = true) || (b = true) && (c = true);`'
- en: '`System.out.print(a + ", " + b + ", " + c); // true,` `false, false`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.print(a + ", " + b + ", " + c); // true, false, false`'
- en: As `&&` has higher precedence than `||`, the expression evaluates to `(a = true)
    || ( (b = true) && (c =` `true) )`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `&&` 的优先级高于 `||`，表达式计算结果为 `(a = true) || ( (b = true) && (c = true) )`。
- en: 'In other words, the common sub-expression `(b = true)` is grouped with `(c
    = true)` rather than `(a = true)`. Now comes the crucial bit: *evaluation order
    trumps precedence*. Therefore, `(a = true)` is evaluated first, resulting in `T
    || ((b = true) && (c =` `true))`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，常见的子表达式 `(b = true)` 与 `(c = true)` 而不是 `(a = true)` 组合在一起。现在来谈谈关键点：*评估顺序高于优先级*。因此，`(a
    = true)` 首先被评估，结果为 `T || ((b = true) && (c = true))`。
- en: As `||` is a short-circuit operator, the rest of the expression (to the right
    of `||`) is `true`, `false`, `false`, for `a`, `b`, and `c`, respectively. The
    crucial thing to note here is that `b` and `c` are still `false`!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `||` 是短路运算符，表达式右侧的其余部分（`||` 右侧）为 `true`、`false`、`false`，分别对应 `a`、`b` 和 `c`。这里要注意的关键点是
    `b` 和 `c` 仍然是 `false`！
- en: Now that we have discussed the logical operators, we will move on to bitwise
    operators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了逻辑运算符，我们将继续讨论位运算符。
- en: Bitwise operators
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: Although some of the bitwise operators look very similar to the logical operators,
    they operate quite differently. The principle differences are that the bitwise
    operators can work with both boolean and integral (`byte`, `short`, `int`, `long`,
    and `char`) operands. In addition, bitwise operators do *not* short-circuit.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些位运算符看起来与逻辑运算符非常相似，但它们的操作方式却截然不同。主要区别在于位运算符可以与布尔和整型（`byte`、`short`、`int`、`long`
    和 `char`）操作数一起工作。此外，位运算符**不会**短路。
- en: Let’s examine the boolean bitwise operators first.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查布尔位运算符。
- en: Bitwise AND (&)
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位与（&）
- en: 'Comparing the bitwise AND (`&`) with the logical AND (`&&`), the difference
    is that the bitwise AND will *not* short-circuit. This is represented by the **P
    & Q** column in *Table 3.2*. If we take the sample code that we used for the logical
    AND but change it to use the bitwise AND operator, you will see the difference
    in the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 比较位与（`&`）与逻辑与（`&&`），区别在于位与**不会**短路。这由 *表 3.2* 中的 **P & Q** 列表示。如果我们使用逻辑与的示例代码，但将其更改为使用位与运算符，你将看到输出结果的不同：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the `(b2=false)` sub-expression is executed because `&` did not
    short-circuit. So we had `false` & `false`, which is `false`. Thus, the output
    is `false` for all the variables.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`(b2=false)` 子表达式被执行，因为 `&` 没有短路。因此，我们得到 `false & false`，结果是 `false`。因此，所有变量的输出都是
    `false`。
- en: Bitwise OR (|)
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位或（|）
- en: 'Comparing the bitwise OR (`|`) with the logical OR (`||`), the difference is
    that the bitwise OR will *not* short-circuit. This is represented by the **P |
    Q** column in *Table 3.2*. If we take the sample code that we used for the logical
    OR but change it to use the bitwise OR operator, you will see the difference in
    the output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 比较位或（`|`）与逻辑或（`||`），区别在于位或**不会**短路。这由 *表 3.2* 中的 **P | Q** 列表示。如果我们使用逻辑或的示例代码，但将其更改为使用位或运算符，你将看到输出结果的不同：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, the `(b1=true)` sub-expression is executed because `|` did not
    short-circuit. So, we had: `true` | `true`, which is `true`. Thus, the output
    is `true` for all the variables.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise XOR (^)
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is another non-short-circuiting operator. The bitwise XOR, represented
    by the `^` operator, evaluates to `true`, if and only if one of the operands is
    `true` but *not* both. This is represented by the **P ^ Q** column in *Table 3.2*.
    Let’s look at some examples in terms of code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `boolean` variable, `b1`, is initialized to `false` because both of the
    sub-expressions – `(5 > 1)` and `(10 < 20)` – are `true`. Similarly, `b4` is also
    initialized to `false` because both `(5 > 10)` and `(10 < 2)` are `false`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: However, `b2` is `true` because even though `(5 > 10)` is `false`, `(10 < 20)`
    is `true`, and `F ^ T` is `true`. Likewise, `b3` is `true` because `(5 > 1)` is
    `true`, `(10 < 2)` is `F`, and `T ^ F` is `true`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have examined the bitwise operators when used with `boolean` operands,
    we will now briefly examine how the same operators work when the operands are
    integral numbers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators (integral operands)
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though not commonly used, we have included them for completeness. A code example
    is useful here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the operands are integrals (as opposed to booleans), the bit patterns
    become important in evaluating the result. For the `&` operator, both bits must
    be 1 for that bit to be 1 in the result:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For the `|` operator, one of the bits, or both, must be 1 for that bit to be
    1 in the result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the `^` operator, one of the bits, but not both, must be 1 for that bit
    to be 1 in the result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That completes the bitwise operators. Now, let’s cover the ternary operator.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Ternary operator
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ternary operator, as its name suggests, is an operator that takes three
    operands. The ternary operator is used to evaluate boolean expressions and assign
    values accordingly to a variable. In other words, as boolean expressions evaluate
    to `true` or `false` only, the goal of the ternary operator is to decide which
    of the two values to assign to the variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is of the following form:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s look at an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the boolean expression to be evaluated is `x % 2==0`, which,
    because `x = 4`, evaluates to `true`. Thus, `is an even number` is assigned to
    the string, `s`, and is output. Had `x` been 5, then the boolean expression would
    have been `false`, and therefore, `is an odd number` would have been assigned
    to `s` and output.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The last group of operators we will examine are compound assignment operators.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Compound assignment operators
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These operators exist as a shorthand for more verbose expressions. For example,
    assuming `x` and `y` are both integers, `x = x + y` can be written as `x += y`.
    There are compound assignment operators for all of the mathematical operators:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`+=` Example: `x += y` is the same as `x = x + y`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-=` Example: `x -= y` is the same as `x = x - y`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*=` Example: `x *= y` is the same as `x = x * y`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/=` Example: `x /= y` is the same as `x = x / y`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%=` Example: `x %= y` is the same as `x = x % y`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indeed, there are compound assignment operators for the bitwise operators –
    for example, x &= 3 is the same as x = x & 3 but they are so rarely used that
    we will just mention that they exist.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'There are one or two subtleties to be aware of. As mentioned earlier, any mathematical
    operation involving an `int` type or smaller results in `int`. This can result
    in a cast being required to get the code to compile. With the compound assignment
    operators, the cast is in-built, so the explicit cast is not required. Take the
    following code for example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line initializes 2 bytes, `b1` and `b2`, to `3` and `4`, respectively.
    The second line is commented out as it generates a compiler error. The addition
    of `b1` and `b2` results in an `int` type that cannot be directly assigned to
    a `byte` variable, unless you cast it down from `int` to `byte`. This is what
    the third line is doing – using the cast (`byte`) to override the compiler error.
    We’ll cover casting very soon but for now, just realize that with the cast, you
    are overriding the compiler error, effectively saying “I know what I am doing,
    proceed.”
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The last line is interesting in that, in the background, it is the same as the
    third line. In other words, the compiler translates `b1 += b2` into `b1 = (byte)
    (b1 +` `b2)`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Another subtlety to be aware of is that whatever is on the right-hand side
    of the compound assignment operator is going to be grouped, regardless of precedence.
    An example will help here. Consider the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We know that `*` has higher precedence than `+` and that the order of evaluation
    is left to right. That said, what is on the right-hand side of `*=` is grouped
    by the compiler by surrounding `2 + 5` with parentheses (in the background). Thus,
    the expression becomes `2 * (2 + 5) = 2 * 7 = 14`. To further this point, had
    the compiler *not* inserted parentheses, the expression would have been evaluated
    to 9\. In other words, due to operator precedence, the expression would have been
    (2 * 2) + 5 = 4 + 5 = 9\. However, as we have seen, this is **not** the case.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another more complicated example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this example, the right-hand side is, once again, enclosed in parentheses:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Translating `+=` into its longer form gives us the following output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The order of evaluation is left to right, so plugging in the current value
    of `k`, which is `1`, results in:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, by plugging in the right-hand side expression, we get the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the order of evaluation is left to right, `k` is changed to `4` before we
    add `2`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That concludes our treatment of Java operators. Now, let’s examine Java casting,
    a topic we have touched on already in this chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Java casting
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To discuss casting properly, we need to explain both the widening and narrowing
    of Java’s primitive data types. With this in mind, it is helpful to remember the
    sizes of the primitive data types in bytes. *Table 3.3* represents this information:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.3 – The sizes of Java’s primitive types](img/B19793_03_Table_03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Table 3.3 – The sizes of Java’s primitive types
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table presents the sizes in bytes of Java’s various primitive
    data types. This will help us as we discuss both widening and narrowing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Widening
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Widening is done automatically; in other words, a cast is not needed. As the
    promotion is done in the background, widening is also known as *implicit promotion*.
    With *Table 3.3* in mind, the widening rules are as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: byte → short/char → int → long → float → double
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the sizes from *Table 3.3*, most of these rules should make sense. For
    example, a `byte` can automatically fit into a `short` because 1 byte fits into
    2 bytes automatically. The only interesting one is `long` → `float`, which is
    *widening* from 8 bytes to 4 bytes. This is possible because even though a `long`
    requires 8 bytes and a `float` requires only 4 bytes, their ranges differ – that
    is, a `float` type can accommodate any `long` value but not vice versa. This is
    shown in the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the scientific notation `E` used for floating point. `float` takes up less
    space, but due to its representation, it can hold larger and smaller numbers than
    `long`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Scientific notation
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Scientific notation is a shorthand way to represent decimal numbers and can
    be useful for representing very large and/or very small numbers. Here are some
    examples:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`double d1 = .``00000000123;`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '`double d2 =` `1.23e-9;`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println(d1==d2); //` `true`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`double d3 =` `120_000_000;`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '`double d4 =` `1.2e+8;`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println(d3==d4); //` `true`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: As the comparisons both return `true`, this means that `d1` is the internal
    representation of `d2`. Similarly, both `d3` and `d4` are equivalent.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine widening in code. *Figure 3**.6* demonstrates this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Implicit widening examples](img/B19793_03_6.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Implicit widening examples
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Line 14 is a regular `char` assignment – in other words, no widening is involved.
    Note that characters (represented by `char`) are simply small numbers (0..65,535).
    To represent a character, we enclose the character in single quotes. In contrast,
    a `String`, which is a sequence of characters, is represented in double quotes.
    Therefore, `"a"` is a `String`, whereas `'a'` is a character.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 is a widening from `char` (2 bytes) to `int` (4 bytes). Line 16 is a
    widening from `int` to `float`. Although both `int` and `float` require 4 bytes,
    as discussed earlier with `long`, `float` has a greater range, so there is no
    issue here. Line 17 is a widening from `float` to `double`. Lastly, line 18 is
    a widening from `long` to `float`. Note that there are no compiler errors anywhere
    and that the cast operator is not needed in any of the assignments.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss narrowing, where the cast operator *is* required.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cast operator is a type enclosed in parentheses – for example, `(int)`
    and `(byte)` are both cast operators that cast to `int` and `byte`, respectively.
    With *Table 3.3* in mind, the following figure, *Figure 3**.7*, presents assignments
    that require casting:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Casting examples](img/B19793_03_7.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Casting examples
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, line 23 is attempting to assign `3.3`, a `double` type
    (8 bytes), to an `int` type (4 bytes). Without the cast, this would be a compiler
    error. With the cast, you are overriding the compiler error. So, on line 23, we
    are casting `3.3` to `int` and assigning this `int` to the `i` variable. Therefore,
    after the assignment completes, `i` has a value of `3`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Line 24 is casting the `int` type, `233`, into the `byte` variable, `b`. This
    literal value is outside the range of `byte` (-128 to +127), so a cast is required.
    Line 25 is casting the `double` type, `3.5`, to `float`. Remember that, by default,
    a decimal number is `double`; to have it considered as a `float` as opposed to
    a `double`, you must suffix `f` or `F`. For example, `3.3f` is `float`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The output on line 26 is 3, -23, and 3.5 for `i`, `b`, and `f`, respectively.
    Note that in the output, the `float` variable appears without `f`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: How we arrived at `-23` is explained in the following callout.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Overflowing the byte
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the range of `byte` is -128 (10000000) to +127 (01111111). The
    leftmost bit is the sign bit, with 1 representing negative and 0 representing
    positive.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we did the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '`byte b` `= (``byte) 233;`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal value of `233` (an integer) is too big for `byte` but how was `b`
    assigned the value of -23? Mapping `233` as an `int` type gives us the following
    bit pattern:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`11101001 = 1 + 8 + 32 + 64 + 128 =` `233 (int)`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that as an `int` is 4 bytes, `233` is 00000000000000000000000011101001\.
    Mapping that bit pattern as a **byte** (the high order 3 bytes are truncated)
    gives us the following output:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`11101001 = 1 + 8 + 32 + 64 + (-128) = -``23 (byte)`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the leftmost bit is the sign bit. That is why `–128` is in the
    calculation. It is `-(2`7`) = -``128`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude this section by looking at some unusual examples where casting
    is/is not required.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: To cast or not to cast, that is the question
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are certain situations where, because the compiler applies rules in the
    background, a cast is *not* required. Let’s examine some of these situations with
    code examples. *Figure 3**.8* presents the code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Situations where casting is not always necessary](img/B19793_03_8.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Situations where casting is not always necessary
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Line 32 declares and initializes a `char` variable `c`, to an `int` value of
    `12`. Remember that `char` variables are essentially small positive numbers. Although
    we are assigning an `int` value (4 bytes) to a `char` variable (2 bytes), because
    the literal value is within the range of `char` (0 to 65,535), the compiler allows
    it. Had the literal value been out of the range of `char`, the compiler would
    have generated an error – this is what is happening on line 33.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Line 34 declares and initializes a `short` variable, `s`, to an `int` value
    of `12`. Again, although `short` can hold only 2 bytes, the compiler realizes
    it can store the literal value, `12`, and allows it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Note that, from the compiler’s perspective, assigning literal values into variables
    is different to assigning *variables* to variables. For example, lines 32 and
    37 are quite different. This will become apparent as we discuss the next few lines
    in the figure.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 35 to 38 demonstrate that while both `char` and `short` require 2 bytes,
    they have different ranges: `char` (0 to 65,535) and `short` (-32,768 to +32,767).
    This means that a `short` variable can hold a negative value such as -15, whereas
    a `char` variable cannot. Conversely, a `char` variable can hold a value such
    as 65,000 but a `short` variable cannot. Therefore, as lines 35 and 37 demonstrate,
    you cannot directly assign a `char` variable to a `short` variable and vice versa.
    You need a cast in both scenarios. Lines 36 and 38 demonstrate this.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time constants
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: However, lines 40 to 42 show a way around the requirement for the cast we just
    outlined. If you declare your variable as a *compile-time constant* (and assuming
    the value is in range), the compiler will allow the variable-to-variable assignment.
    Line 40 uses the `final` keyword to declare a compile-time constant. We will discuss
    `final` in detail in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), but in this
    context, it means that `c1` will always have a value of `12`. The value is fixed
    (or *constant*) for `c1` and this is done at *compile time*. If you try to change
    the value of `c1`, you will get a compiler error. Now that the compiler knows
    that `c1` will always have `12` as its value, the compiler can apply the same
    rules that it applies to literal values; in other words, is the value in range?
    This is why line 42 does *not* generate a compiler error.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on operators. Now, let’s apply them!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mesozoic Eden is doing great. The dinosaurs are healthy and the guests are happy.
    Now that you have some new skills, let’s go ahead and perform slightly more complicated
    tasks!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The caretakers want to be able to keep track of dinosaur weights. It’s your
    task to write a program that calculates the average weight of two dinosaurs. This
    will help our team of nutritionists in planning the correct food portions.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proper nutrition is essential for the health of our dinosaurs. The caretakers
    want to have a rough guideline of how much to feed a dinosaur. Write a program
    that determines the amount of food required for a dinosaur based on its weight.
    You can come up with the amount of food needed per weight unit of the dinosaurs.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our park, we need to have a leap year checker. In our commitment to scientific
    accuracy, use the modulus operator to determine if the current year is a leap
    year. We want to make sure our calendar-themed exhibits are always up to date.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a program that checks whether the park’s maximum capacity has been reached.
    The program only needs to print true or false after the words “Max capacity reached:”.
    This is crucial in maintaining safety standards and ensuring a positive visitor
    experience.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes visitors want to compare dinosaurs’ ages. And we get it – this could
    be interesting for educational purposes. Write a program that calculates the age
    difference between two dinosaurs.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Mesozoic Eden, we have a very strong safety-first policy. Write a program
    that checks whether the park’s safety rating is above a certain threshold. Maintaining
    a good safety rating is our utmost priority.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Dino meal planner
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a zookeeper in Mesozoic Eden, the crucial tasks include planning the meals
    for our beloved dinosaurs. While we’re not using conditionals and loops yet, we
    can still calculate some basic requirements!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Develop a simple program to help the zookeepers plan the meal portions for different
    dinosaurs. The program should use the dinosaur’s weight to calculate how much
    food it needs to eat per meal.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a bit more guidance, here’s how you can do it:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Declare variables for the dinosaur’s weight and the proportion of its weight
    it needs to eat per day. For instance, if a dinosaur needs to eat 5% of its body
    weight daily, and it weighs 2,000 kg, it would need to eat 100 kg of food.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s say you feed the dinosaur twice a day. Declare a variable for the
    number of feedings and calculate how much food you need to serve per feeding.
    In this example, it would be 50 kg per feeding.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print out the result in a meaningful way – for example, “Our 2,000 kg dinosaur
    needs to eat 100 kg daily, which means we need to serve 50 kg per feeding.”
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how Java’s operators work and how they cooperate.
    In addition, we learned how to cast in Java.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we discussed two important properties relating to operators: precedence
    and associativity. We saw that precedence dictates how common terms are grouped.
    Associativity comes into play when the operators have the same order of precedence.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We then examined the operators themselves. We started by looking at unary operators,
    which have one operand such as the prefix/postfix increment/decrement operators,
    `++` and `--`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'We then moved on to the arithmetic operators: `+`, `-`, `*`, `/`, and `%`.
    We noted that integer division truncates. In addition, we discussed that any math
    operations involving `int` types or smaller results in `int`. Lastly, we discussed
    in detail how the `+` operator works when one or both operands are strings. In
    these cases, a string append is performed.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed relational operators. The results of these operators are
    always boolean values and will be used when we construct conditional statements
    in [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: As Java cannot perform operations where the types are different, where possible,
    Java performs implicit promotion. This is where Java promotes the smaller type
    to the larger type somewhere in memory. This is Java’s way of invisibly continuing
    with the operation.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'We then discussed the logical operators: `&&`, `||`, `&`, `|`, and `^`. Truth
    tables were presented to aid in understanding. Both the logical `&&` and logical
    `||` operators are short-circuiting operators. Understanding this is important
    because the order of evaluation trumps precedence.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The bitwise operators, bitwise AND (`&`) and bitwise OR (`|`), are similar except
    that in contrast to `&&` and `||`, both `&` and `|` never short-circuit and can
    also work with integral operands.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator takes three operands. It evaluates a boolean expression
    and assigns one of two values to a variable, depending on whether the boolean
    expression was `true` or `false`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Regarding operators, the last group we covered were the compound assignment
    operators, of which there is one for each mathematical operator.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In our discussion on casting, we covered both widening and narrowing. Widening
    is done in the background and is often called *implicit promotion*. There is no
    risk here as the type being promoted fits easily into the target type.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing is where the cast is required. This is because, given that you are
    going from a type that requires more storage space to a type that requires less,
    there is a potential loss of data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use operators, in the next chapter, we will move on
    to conditional statements, where operators are commonly used.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
