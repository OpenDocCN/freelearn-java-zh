- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators and Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19793_02.xhtml#_idTextAnchor051), we learned that variables
    are simply named pigeonholes and contain values. These values vary and Java provides
    eight primitive data types accordingly. These primitive types cater for whole
    numbers (`byte`, `char`, `short`, `int`, and `long`), decimal numbers (`float`
    and `double`), and the literals true and false (`boolean`).
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to declare a variable. As Java is a strongly typed language,
    this means you must give every variable a data type immediately upon declaration.
    This is where primitive data types are very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to declare variables, let’s do something interesting with
    them. By the end of this chapter, you will be able to combine variables using
    Java’s various operators. In addition, you will understand Java casting, including
    what it is, and when and why it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how Java’s operators cooperate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Java’s operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining Java casting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: Learning how Java’s operators cooperate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java provides numerous operators for us to work with. By way of definition,
    if we have an expression `3 + 4`, the `+` is the *operator*, whereas `3` and `4`
    are the *operands*. Since `+` has *two* operands, it is known as a *binary* operator.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss the operators themselves, we must first discuss two important
    features relating to Java operators, namely **order of precedence** and **associativity**.
  prefs: []
  type: TYPE_NORMAL
- en: Order of precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Order of precedence specifies how operands are grouped with operators. This
    becomes important when you have shared operands in a complex expression. In the
    following code segment, we have an expression of `2 + 3 * 4`, where `*` represents
    multiplication and `+` represents addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `3` is shared by both `2` and `4`. So, the question arises,
    do we group `3` with `2`, where the expression is `(2 + 3) * 4`, giving us `20`;
    or do we group `3` with `4`, where the expression is `2 + (3 * 4)`, giving us
    `14`? This is where the order of precedence applies. As `*` has higher precedence
    than `+`, `3` is grouped with `4` and therefore the expression evaluates to `2
    + (3 * 4)`. Note that the evaluation order is still left to right; it is just
    that `3` is grouped with `4` rather than with `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses in an expression
  prefs: []
  type: TYPE_NORMAL
- en: Note that parentheses can change the default order of operator precedence. As
    we have seen, the default order of precedence, where `*` has higher precedence
    than `+`, means that `2 + 3 * 4` is `14`. This is the same as `2 + (3 *` `4)`.
  prefs: []
  type: TYPE_NORMAL
- en: However, `(2 + 3) * 4` is `20`. In this case, the parentheses grouped `3` with
    `2`, so the expression evaluated to `5 * 4 =` `20`.
  prefs: []
  type: TYPE_NORMAL
- en: This begs the question, what if you are evaluating an expression that contains
    operators at the same level of precedence? This is where associativity applies.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an expression has two operators with the same level of precedence, operator
    associativity determines the groupings of operators and operands. For example,
    in the following code segment, we are evaluating a simple expression involving
    two divisions (which have the same level of precedence):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As division associates left to right, `6` will be grouped with `72` and not
    `3`. Thus, the expression is the same as `(72 / 6) / 3`, which evaluates to `12
    / 3 = 4`. Parentheses can also be used to change the default associativity order.
    Take, for example, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `6` is now grouped with `3` and the expression evaluates to `72
    / 2 =` `36`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 3.1* outlines the order of precedence and associativity rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.1 – Order of precedence and associativity rules](img/B19793_03_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.1 – Order of precedence and associativity rules
  prefs: []
  type: TYPE_NORMAL
- en: Note that *Table 3.1* is simplified in that it refers to the operators that
    are commonly used. For example, the unsigned right shift operator, `>>>`, is omitted
    as it is rarely used. Also, note that the `instanceof` operator will be discussed
    in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to note that the assignment operator, namely `=`, is at the
    bottom of the precedence table. This means that regardless of the expression on
    the right-hand side of the assignment, the assignment will always be done last.
    This makes sense. Also, while most of the operators associate left to right, the
    assignment associates right to left. This is demonstrated in the following code
    segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code segment outputs `false` three times. The crucial line is
    `b3 = b2 = b1;`. Since the assignment associates right to left, the value in `b1`,
    which is `false`, is assigned to `b2`; then, the value in `b2`, which is now `false`,
    is assigned to `b3`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand these properties, let’s examine the operators themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Java’s operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators can be grouped into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Unary operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ternary operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compound assignment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now discuss each category in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Unary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unary operators have only one operand, hence the term *unary*. Let’s examine
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Prefix and postfix unary operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`++` and `--` denote these operators and they increment and decrement by 1,
    respectively. If the operator appears before the variable, it is known as *prefix*,
    while if the operator appears after the variable, it is called *postfix*. For
    example, *++x* is prefix increment, whereas *y--* is postfix decrement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on whether `++` or `--` appears before or after the variable can,
    in some situations, affect the overall expression. This is best explained with
    a code sample, as shown in *Figure 3**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Prefix and postfix increment and decrement operators](img/B19793_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Prefix and postfix increment and decrement operators
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.1*, on line 25, we can see that `x` is initialized to `3`. On
    line 26, `x` is incremented by 1 to `4`. Line 26 is a simple statement and because
    of that, whether it is prefix or postfix notation does not matter. Line 27 outputs
    the value of `x` to show that it is `4` at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Line 28 is where things get interesting. The postfix notation on line 28 has
    a real effect on the screen output. As it is the postfix notation in the `System.out.println`
    command, the current value of `x` is output, and *afterwards*, `x` is incremented
    by 1\. So, the output to the screen is `4`, and afterwards, `x` is incremented
    to `5`. Line 29 demonstrates that `x` is `5`.
  prefs: []
  type: TYPE_NORMAL
- en: On line 31, `y` is initialized to `4`. On line 32, `y` is decremented by 1 to
    `3`. Again, as line 32 is a simple statement, prefix or postfix notation makes
    no difference. Line 33 outputs the value of `y` to show that it is `3` at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: The prefix notation on line 34 has no real effect on the screen output. As it
    is the prefix notation in the `System.out.println` command, the current value
    of `y` is decremented `y` and the output to the screen match (both are `2`). Lastly,
    line 35 demonstrates that the current value of `y` is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Unary plus/minus operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have discussed the prefix and postfix operators, let’s discuss
    other unary operators. The code in *Figure 3**.2* will help:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Other unary operators](img/B19793_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Other unary operators
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.2*, line 37 uses the unary plus sign, `+`, to initialize `x`
    to `6`. Here, `+` is the default as numbers without a sign are assumed to be positive
    numbers. Line 38 uses the unary minus sign, `-`, to initialize `y` to be the negative
    of `x`. Lines 39 and 40 demonstrate that `x` and `y` are `6` and `-``6`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Cast operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Figure 3**.2*, line 42 uses the cast operator. We will discuss casting in
    greater detail later in this chapter. For now, `3.45` is a `double` literal (8
    bytes) and cannot be stored in an `int` variable, `z`, as `int` variables are
    4 bytes in size. The compiler spots this and generates an error. To get around
    this error, we can use a cast, which takes the form of *(cast type)*. This cast
    enables us to override the compiler error. In this case, we are casting `3.45`
    to an `int` variable, which means we lose the decimal places. Thus, we store `3`
    in `z`, as shown by the output from line 43.
  prefs: []
  type: TYPE_NORMAL
- en: Logical NOT operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Figure 3**.2*, on line 45, we declare a boolean, `b`, and initialize it
    to `true`. On line 46, we output the inverted value of `b` by using the logical
    NOT operator. Note that we are not changing the value of `b` meaning, the value
    of `b` is still `true`. This is shown by the output from line 47.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the arithmetic operators.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are five arithmetic operators, all of which we will examine now.
  prefs: []
  type: TYPE_NORMAL
- en: Addition/subtraction operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As in mathematics, the `+` operator represents addition and the `-` operator
    represents subtraction. Both are binary operators; in other words, there are two
    operands, one on either side of the operator. The following code example demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code segment, `res` has been assigned a value of `6 + 4 – 2`, which
    is `8`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication/division operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `*` operator represents multiplication and the `/` operator represents
    division. Both are binary operators. Note that *integer division truncates*. The
    following code segment demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code segment outputs `3` because integer division truncates. We are dividing
    one integer, `10`, by another integer, `3`. The remainder is simply discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Modulus operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `%` operator is used for calculating the modulus (remainder). The following
    code example demonstrates the modulus operator in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first line initializes `mod1` to be the remainder of `10` divided by `3`,
    which is `1`. In other words, `3` goes into `10` three times and `1` is left over.
    Therefore, `1` is assigned to `mod1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initialization of `mod2` is interesting: `3` goes into `0` zero times and
    there is `0` (or nothing) left over. Hence, `0` is assigned to `mod2`.'
  prefs: []
  type: TYPE_NORMAL
- en: The precedence of arithmetic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As per *Table 3.1*, `*`, `/`, and `%` have higher precedence than the `+` and
    `–` operators, and assignment has the lowest precedence. *Figure 3**.3* shows
    how this affects the evaluation of expressions in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Arithmetic operators precedence](img/B19793_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Arithmetic operators precedence
  prefs: []
  type: TYPE_NORMAL
- en: Lines 61 demonstrates that `*` has higher precedence than `+`, in that the expression
    evaluates to `3 + (2 * 4) = 3 + 8 =` `11`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 63 demonstrates that parentheses change the grouping. Now, the shared value,
    `2`, is grouped with `3` (as opposed to `4`, which was the case on line 61). The
    expression now evaluates to `5 * 4 =` `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 65 demonstrates that `+` and `-` associate left to right. The expression
    evaluates to
  prefs: []
  type: TYPE_NORMAL
- en: '`10 - 2 =` `8`.'
  prefs: []
  type: TYPE_NORMAL
- en: Lines 67 demonstrates that `*`, `/`, and `%` also associate left to right. The
    expression evaluates to `2 * 6 % 10`, which, in turn, evaluates to `12 % 10`,
    which is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Math operations involving `int` variables or smaller result in an `int`
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to note that any math operation involving an `int` type or
    smaller results in `int`. This is demonstrated in the following code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte` `b1=2, b2=3;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte b3 = b1 + b2; //` `compiler error`'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte b4 = (byte)(b1 +` `b2);// Ok`'
  prefs: []
  type: TYPE_NORMAL
- en: The first line declares 2 bytes, namely `b1` and `b2`. Notice that, even though
    `2` and `3` are integer literals, the compiler is aware that these values are
    within the range of `byte` (-128 to +127) and, consequently, allows the declarations.
  prefs: []
  type: TYPE_NORMAL
- en: However, the next line is a problem. The compiler has a rule that all math operations
    involving `int` types or smaller result in an `int`. Therefore, even though the
    sum of the two bytes, 5, is well within the `byte` range, the compiler complains
    saying “possible loss of data converting from `int` to `byte`”.
  prefs: []
  type: TYPE_NORMAL
- en: The last line fixes this issue by casting the result of the addition (an `int`
    type) to a `byte` before the assignment. What this means is that the extra 3 bytes
    from the `int` (that do not fit into the `byte`) are simply discarded. Thus, the
    sum of `b1 + b2` is cast from `int` to `byte` and the resultant `byte` is assigned
    to `b4`. Casting is discussed in more detail later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will finish our discussion on arithmetic operators by examining `+` in a
    different context.
  prefs: []
  type: TYPE_NORMAL
- en: String append
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen, Java uses `+` for mathematical addition. However, this occurs
    only if both operands are numbers. For example, 3 + 4 results in 7 because both
    operands, 3 and 4, are numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if either operand (or both) are strings, Java performs a `String`
    append. A `String` literal is enclosed in double quotes – for example, `"abc"`,
    `"123"`, `"Sean"`, and `"Maaike"` are all `String` literals. So, just to be clear
    on what operation is performed and when, let’s take a look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 3 + 4 is mathematical addition. Thus, the result is 7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “3” + 4 is a string append as there is a string on the left of `+`. The result
    is the string “34.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 + “4” is a string append as there is a string on the right of `+`. Again,
    the result is the string “34.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “3” + “4” is a string append as there is a string on both sides of `+`. The
    result is also the string “34.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, what exactly happens during a string append? *Java cannot perform any mathematical
    operations when the operands are of different types*. Let’s examine this with
    an example piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that the first line of code only compiles because
    `"3" + 4` results in a `String` literal. When Java encounters a string on the
    left/right/both sides of `+`, it performs string concatenation (append). Essentially,
    as `+` associates left to right, Java appends (adds) the string on the right of
    `+` to the end of the string on the left of `+`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, Java sees the `String` literal `"3"` and the `+` operator and
    realizes it must perform a `String` append. To do this, in memory, it creates
    a string version of 4 – in other words, `"4"`. The integer `4` literal is not
    touched. Thus, a new variable is created under the hood – it is a `String` variable,
    and `"4"` is its value. The expression is now `"3" + "4"`. As both operands on
    either side of `+` are now of the same type (both are strings), Java can perform
    the append. The new string is the result of `"3" + "4"`, which is `"34"`. This
    is what is assigned to `s`. The second line demonstrates this by outputting `"34"`
    for `s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.4*, a more substantial example is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – String append in action](img/B19793_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – String append in action
  prefs: []
  type: TYPE_NORMAL
- en: On line 79, as both operands, `a` and `b`, are integers, Java initializes `res`
    to `5` (the sum of `3` and `2`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 82 is evaluated as follows: `3 + "abc" = "3" + "abc" = "3abc"`. In other
    words, Java realizes that it must do a string append due to the presence of `"abc"`
    on the right-hand side of `+`. Thus, somewhere in memory, a string version of
    the value of `a` is created. In other words, a variable with `"3"` is created.
    Note that `a` *remains an int with 3 as its value*. Now, Java can proceed since
    both operands are the same type (strings): `"3" + "abc"` results in `"3abc"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 83 demonstrates that it does not matter which side of `+` the string is
    on. Plus, it does not matter if the string is a string literal or a string variable.
    The expression on line 83 is evaluated as follows: `"abc" + 3 = "abc" + "3" =
    "abc3"`. This is what `s2` is initialized to. Line 84 outputs the values of both
    `s1` and `s2` with a space between them. Note that `System.out.println` expects
    a string. The string output on line 84 is constructed as follows: `"3abc" + "
    " = "3abc " + "abc3" = "``3abc abc3"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 86 and 87 require special mention. The problem with line 86 is that the
    output string is constructed as follows: `"Output is "+ 3 = "Output is " + "3"
    = "Output is 3" + 2 = "Output is 3" + "2" = "Output is 32"`. This is not what
    we wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 87 rectifies this by using parentheses to ensure that `a + b` is grouped.
    Thus, the string is constructed as follows: `"Output is "+ 5 = "Output is "+ "5"
    = "Output` `is 5"`.'
  prefs: []
  type: TYPE_NORMAL
- en: That finishes the arithmetic operators. We will now examine relational operators.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java has six relational operators, all of which result in a `boolean` value
    of `true` or `false`. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`==` is the equivalence operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` is the not equivalent operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>` is the greater than operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=` is the greater than or equal to operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<` is the less than operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=` is the less than or equal to operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3**.5* shows the relational operators in action in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Relational operators in code](img/B19793_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Relational operators in code
  prefs: []
  type: TYPE_NORMAL
- en: Line 89 declares two `int` variables, namely `x` and `y`, and initializes them
    to `3` and `4`, respectively. Line 90 uses Java’s equivalence operator, `==`,
    to check if `x` and `y` are equivalent. As they are not, line 90 outputs `false`.
    Line 91 checks the exact opposite. As `x` is not equivalent to `y`, line 91 outputs
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 92 outputs whether `x` is greater than `y`. This is, of course, `false`
    as `3` is not greater than `4`. Similarly, line 93 outputs whether `x` is greater
    than or equal to `y`. Again, this is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 94 outputs whether `x` is less than `y`. This is `true` as `3` is less
    than `4`. Line 95 outputs whether `x` is less than or equal to `y`. Again, this
    is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The relational operators and their boolean return values are going to be extremely
    useful going forward, particularly when we look at conditional statements in [*Chapter
    4*](B19793_04.xhtml#_idTextAnchor087).
  prefs: []
  type: TYPE_NORMAL
- en: Implicit promotion
  prefs: []
  type: TYPE_NORMAL
- en: 'While Java’s operators do not require the operands to be exactly the same type,
    the operands must be compatible. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println(3 + 4.0); //` `7.0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println(4 == 4.0); //` `true`'
  prefs: []
  type: TYPE_NORMAL
- en: The first line tries to add an `int` variable of `3` to a `double` variable.
    Java realizes that the types are not the same. However, Java can figure out a
    safe solution without bothering us. This is where *implicit promotion* comes in.
    `int` requires 4 bytes of storage whereas `double` requires 8 bytes. In the background,
    somewhere in memory, Java declares a temporary `double` variable and promotes
    `int 3` to `double 3.0`, and stores `3.0` in this temporary location. Now, Java
    can add `3.0` to `4.0` (as both are `double`s), resulting in the answer `7.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The second line compares `int 4` with `double 4.0`. The same process happens.
    Java implicitly promotes `4` to `4.0` (in a new temporary location) and then compares
    `4.0` with `4.0`. This results in `true` being output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will turn our attention to logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators enable us to build complex `boolean` expressions by combining
    sub-expressions. These operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&` is the logical AND'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||` is the logical OR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&` is the bitwise AND'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|` is the bitwise OR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^` is the bitwise eXclusive OR (XOR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will examine these in turn with code examples to help explain how they operate.
    But before we do that, it is worthwhile refreshing our truth tables, as shown
    in *Table 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.2 – Boolean truth tables](img/B19793_03_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.2 – Boolean truth tables
  prefs: []
  type: TYPE_NORMAL
- en: In *Table 3.2*, the first two columns, **P** and **Q**, represent two expressions,
    where **T** means true and **F** means false. For example, the logical AND column
    (the **P && Q** column) represents the result of the overall expression, **P &&
    Q**, depending on the values of **P** and **Q**. So, if **P** is true and **Q**
    is **T**, then **P && Q** is also true.
  prefs: []
  type: TYPE_NORMAL
- en: With this table in mind, let’s examine the operators in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Logical AND (&&)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logical AND states that both boolean operands must be true for the overall
    expression to be true. This is represented by the **P && Q** column in *Table
    3.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this operator is known as a short-circuiting operator. For example,
    in an expression P && Q, if P evaluates to false, then && will *not* evaluate
    the expression Q because the overall expression will evaluate to false regardless.
    This is because F && F is false and F && T is also false. In effect, Java knows
    that once the expression P is false on the left-hand side of an && expression,
    the overall expression must be false. So, there is no need to evaluate the Q expression
    on the right-hand side, so it *short-circuits*. This is better explained with
    a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first line initializes two boolean variables, `b1` and `b2`, to `false`
    and `true`, respectively. The second line is the important one. Note that the
    parentheses are required around the `b2=false` sub-expression to get the code
    to compile (otherwise, you will get a syntax error). So, when we plug in `false`
    for `b1`, the expression evaluates to `F && (b2=false)`. As the evaluation order
    is left to right, this will lead `&&` to short-circuit, because, regardless of
    what remains in the expression, there is no way the overall expression can evaluate
    to true. This means that the `(b2=false)` sub-expression is **not** executed.
  prefs: []
  type: TYPE_NORMAL
- en: The last line outputs the values of the variables. The output is `false`, `true`,
    and `false` for `b1`, `b2`, and `res`, respectively. Crucially, `b2` is `true`,
    demonstrating that `&&` short-circuited.
  prefs: []
  type: TYPE_NORMAL
- en: Logical OR (||)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logical OR states that either or both boolean operands can be true for the
    overall expression to be true. This is represented by the **P || Q** column in
    *Table 3.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator is also a short-circuiting operator. For example, in an expression
    P || Q, if P evaluates to true, then || will *not* evaluate the expression Q because
    the overall expression will evaluate to true regardless. This is because T ||
    F is true and T || T is also true. In effect, Java knows that once the expression
    P is true on the left-hand side of an || expression, the overall expression must
    be true. So, there is no need to evaluate the expression, Q, and hence it *short-circuits*.
    Again a code example will help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first line initializes two boolean variables, `b1` and `b2`, to `false`
    and `true`, respectively. The second line is the important one. Note again that
    the parentheses are required around the `b1=true` sub-expression to get the code
    to compile. So, when we plug in `true` for `b2`, the expression evaluates to `T
    || (b1=true)`. As the evaluation order is left to right, this will lead `||` to
    short-circuit because, regardless of what remains in the expression, there is
    no way the overall expression can evaluate to false.
  prefs: []
  type: TYPE_NORMAL
- en: The last line outputs the values of the variables. The output is `false`, `true`,
    and `true` for `b1`, `b2`, and `res`, respectively. Crucially, `b1` is `false`,
    demonstrating that `||` short-circuited.
  prefs: []
  type: TYPE_NORMAL
- en: Order of evaluation versus precedence
  prefs: []
  type: TYPE_NORMAL
- en: 'This topic often causes confusion and is best explained with some sample pieces
    of code. Let’s start with an example that can be deceptively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int x=2,` `y=3, z=4;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`int res = x + y * z; // x + (y *` `z)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println(res);// 14`'
  prefs: []
  type: TYPE_NORMAL
- en: As `*` has higher precedence than `+`, the common element `y`, is grouped with
    `z` and not `x`. Thus, the overall expression is `x + (y * z)` = 2 + 12 = 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is important to note here is that the evaluation order is left to right
    and as evaluation order trumps precedence, `x` is evaluated first before the `(y
    * z)` sub-expression. While this makes no difference in this example, let’s look
    at an example where it does make a difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean a=false,` `b=false, c=false;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// a || (b &&` `c)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// The next line evaluates to` `T ||`'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean bool = (a = true) || (b = true) && (c =` `true);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.print(a + ", " + b + ", " + c); // true,` `false, false`'
  prefs: []
  type: TYPE_NORMAL
- en: As `&&` has higher precedence than `||`, the expression evaluates to `(a = true)
    || ( (b = true) && (c =` `true) )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the common sub-expression `(b = true)` is grouped with `(c
    = true)` rather than `(a = true)`. Now comes the crucial bit: *evaluation order
    trumps precedence*. Therefore, `(a = true)` is evaluated first, resulting in `T
    || ((b = true) && (c =` `true))`.'
  prefs: []
  type: TYPE_NORMAL
- en: As `||` is a short-circuit operator, the rest of the expression (to the right
    of `||`) is `true`, `false`, `false`, for `a`, `b`, and `c`, respectively. The
    crucial thing to note here is that `b` and `c` are still `false`!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the logical operators, we will move on to bitwise
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although some of the bitwise operators look very similar to the logical operators,
    they operate quite differently. The principle differences are that the bitwise
    operators can work with both boolean and integral (`byte`, `short`, `int`, `long`,
    and `char`) operands. In addition, bitwise operators do *not* short-circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the boolean bitwise operators first.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise AND (&)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comparing the bitwise AND (`&`) with the logical AND (`&&`), the difference
    is that the bitwise AND will *not* short-circuit. This is represented by the **P
    & Q** column in *Table 3.2*. If we take the sample code that we used for the logical
    AND but change it to use the bitwise AND operator, you will see the difference
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `(b2=false)` sub-expression is executed because `&` did not
    short-circuit. So we had `false` & `false`, which is `false`. Thus, the output
    is `false` for all the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise OR (|)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comparing the bitwise OR (`|`) with the logical OR (`||`), the difference is
    that the bitwise OR will *not* short-circuit. This is represented by the **P |
    Q** column in *Table 3.2*. If we take the sample code that we used for the logical
    OR but change it to use the bitwise OR operator, you will see the difference in
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `(b1=true)` sub-expression is executed because `|` did not
    short-circuit. So, we had: `true` | `true`, which is `true`. Thus, the output
    is `true` for all the variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise XOR (^)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is another non-short-circuiting operator. The bitwise XOR, represented
    by the `^` operator, evaluates to `true`, if and only if one of the operands is
    `true` but *not* both. This is represented by the **P ^ Q** column in *Table 3.2*.
    Let’s look at some examples in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `boolean` variable, `b1`, is initialized to `false` because both of the
    sub-expressions – `(5 > 1)` and `(10 < 20)` – are `true`. Similarly, `b4` is also
    initialized to `false` because both `(5 > 10)` and `(10 < 2)` are `false`.
  prefs: []
  type: TYPE_NORMAL
- en: However, `b2` is `true` because even though `(5 > 10)` is `false`, `(10 < 20)`
    is `true`, and `F ^ T` is `true`. Likewise, `b3` is `true` because `(5 > 1)` is
    `true`, `(10 < 2)` is `F`, and `T ^ F` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have examined the bitwise operators when used with `boolean` operands,
    we will now briefly examine how the same operators work when the operands are
    integral numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators (integral operands)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though not commonly used, we have included them for completeness. A code example
    is useful here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the operands are integrals (as opposed to booleans), the bit patterns
    become important in evaluating the result. For the `&` operator, both bits must
    be 1 for that bit to be 1 in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `|` operator, one of the bits, or both, must be 1 for that bit to be
    1 in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `^` operator, one of the bits, but not both, must be 1 for that bit
    to be 1 in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That completes the bitwise operators. Now, let’s cover the ternary operator.
  prefs: []
  type: TYPE_NORMAL
- en: Ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ternary operator, as its name suggests, is an operator that takes three
    operands. The ternary operator is used to evaluate boolean expressions and assign
    values accordingly to a variable. In other words, as boolean expressions evaluate
    to `true` or `false` only, the goal of the ternary operator is to decide which
    of the two values to assign to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the boolean expression to be evaluated is `x % 2==0`, which,
    because `x = 4`, evaluates to `true`. Thus, `is an even number` is assigned to
    the string, `s`, and is output. Had `x` been 5, then the boolean expression would
    have been `false`, and therefore, `is an odd number` would have been assigned
    to `s` and output.
  prefs: []
  type: TYPE_NORMAL
- en: The last group of operators we will examine are compound assignment operators.
  prefs: []
  type: TYPE_NORMAL
- en: Compound assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These operators exist as a shorthand for more verbose expressions. For example,
    assuming `x` and `y` are both integers, `x = x + y` can be written as `x += y`.
    There are compound assignment operators for all of the mathematical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+=` Example: `x += y` is the same as `x = x + y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-=` Example: `x -= y` is the same as `x = x - y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*=` Example: `x *= y` is the same as `x = x * y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/=` Example: `x /= y` is the same as `x = x / y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%=` Example: `x %= y` is the same as `x = x % y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indeed, there are compound assignment operators for the bitwise operators –
    for example, x &= 3 is the same as x = x & 3 but they are so rarely used that
    we will just mention that they exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are one or two subtleties to be aware of. As mentioned earlier, any mathematical
    operation involving an `int` type or smaller results in `int`. This can result
    in a cast being required to get the code to compile. With the compound assignment
    operators, the cast is in-built, so the explicit cast is not required. Take the
    following code for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first line initializes 2 bytes, `b1` and `b2`, to `3` and `4`, respectively.
    The second line is commented out as it generates a compiler error. The addition
    of `b1` and `b2` results in an `int` type that cannot be directly assigned to
    a `byte` variable, unless you cast it down from `int` to `byte`. This is what
    the third line is doing – using the cast (`byte`) to override the compiler error.
    We’ll cover casting very soon but for now, just realize that with the cast, you
    are overriding the compiler error, effectively saying “I know what I am doing,
    proceed.”
  prefs: []
  type: TYPE_NORMAL
- en: The last line is interesting in that, in the background, it is the same as the
    third line. In other words, the compiler translates `b1 += b2` into `b1 = (byte)
    (b1 +` `b2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another subtlety to be aware of is that whatever is on the right-hand side
    of the compound assignment operator is going to be grouped, regardless of precedence.
    An example will help here. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We know that `*` has higher precedence than `+` and that the order of evaluation
    is left to right. That said, what is on the right-hand side of `*=` is grouped
    by the compiler by surrounding `2 + 5` with parentheses (in the background). Thus,
    the expression becomes `2 * (2 + 5) = 2 * 7 = 14`. To further this point, had
    the compiler *not* inserted parentheses, the expression would have been evaluated
    to 9\. In other words, due to operator precedence, the expression would have been
    (2 * 2) + 5 = 4 + 5 = 9\. However, as we have seen, this is **not** the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another more complicated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the right-hand side is, once again, enclosed in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Translating `+=` into its longer form gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of evaluation is left to right, so plugging in the current value
    of `k`, which is `1`, results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, by plugging in the right-hand side expression, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As the order of evaluation is left to right, `k` is changed to `4` before we
    add `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our treatment of Java operators. Now, let’s examine Java casting,
    a topic we have touched on already in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Java casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To discuss casting properly, we need to explain both the widening and narrowing
    of Java’s primitive data types. With this in mind, it is helpful to remember the
    sizes of the primitive data types in bytes. *Table 3.3* represents this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.3 – The sizes of Java’s primitive types](img/B19793_03_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.3 – The sizes of Java’s primitive types
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table presents the sizes in bytes of Java’s various primitive
    data types. This will help us as we discuss both widening and narrowing.
  prefs: []
  type: TYPE_NORMAL
- en: Widening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Widening is done automatically; in other words, a cast is not needed. As the
    promotion is done in the background, widening is also known as *implicit promotion*.
    With *Table 3.3* in mind, the widening rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: byte → short/char → int → long → float → double
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the sizes from *Table 3.3*, most of these rules should make sense. For
    example, a `byte` can automatically fit into a `short` because 1 byte fits into
    2 bytes automatically. The only interesting one is `long` → `float`, which is
    *widening* from 8 bytes to 4 bytes. This is possible because even though a `long`
    requires 8 bytes and a `float` requires only 4 bytes, their ranges differ – that
    is, a `float` type can accommodate any `long` value but not vice versa. This is
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note the scientific notation `E` used for floating point. `float` takes up less
    space, but due to its representation, it can hold larger and smaller numbers than
    `long`.
  prefs: []
  type: TYPE_NORMAL
- en: Scientific notation
  prefs: []
  type: TYPE_NORMAL
- en: 'Scientific notation is a shorthand way to represent decimal numbers and can
    be useful for representing very large and/or very small numbers. Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double d1 = .``00000000123;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`double d2 =` `1.23e-9;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println(d1==d2); //` `true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`double d3 =` `120_000_000;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`double d4 =` `1.2e+8;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println(d3==d4); //` `true`'
  prefs: []
  type: TYPE_NORMAL
- en: As the comparisons both return `true`, this means that `d1` is the internal
    representation of `d2`. Similarly, both `d3` and `d4` are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine widening in code. *Figure 3**.6* demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Implicit widening examples](img/B19793_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Implicit widening examples
  prefs: []
  type: TYPE_NORMAL
- en: Line 14 is a regular `char` assignment – in other words, no widening is involved.
    Note that characters (represented by `char`) are simply small numbers (0..65,535).
    To represent a character, we enclose the character in single quotes. In contrast,
    a `String`, which is a sequence of characters, is represented in double quotes.
    Therefore, `"a"` is a `String`, whereas `'a'` is a character.
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 is a widening from `char` (2 bytes) to `int` (4 bytes). Line 16 is a
    widening from `int` to `float`. Although both `int` and `float` require 4 bytes,
    as discussed earlier with `long`, `float` has a greater range, so there is no
    issue here. Line 17 is a widening from `float` to `double`. Lastly, line 18 is
    a widening from `long` to `float`. Note that there are no compiler errors anywhere
    and that the cast operator is not needed in any of the assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss narrowing, where the cast operator *is* required.
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cast operator is a type enclosed in parentheses – for example, `(int)`
    and `(byte)` are both cast operators that cast to `int` and `byte`, respectively.
    With *Table 3.3* in mind, the following figure, *Figure 3**.7*, presents assignments
    that require casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Casting examples](img/B19793_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Casting examples
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, line 23 is attempting to assign `3.3`, a `double` type
    (8 bytes), to an `int` type (4 bytes). Without the cast, this would be a compiler
    error. With the cast, you are overriding the compiler error. So, on line 23, we
    are casting `3.3` to `int` and assigning this `int` to the `i` variable. Therefore,
    after the assignment completes, `i` has a value of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 24 is casting the `int` type, `233`, into the `byte` variable, `b`. This
    literal value is outside the range of `byte` (-128 to +127), so a cast is required.
    Line 25 is casting the `double` type, `3.5`, to `float`. Remember that, by default,
    a decimal number is `double`; to have it considered as a `float` as opposed to
    a `double`, you must suffix `f` or `F`. For example, `3.3f` is `float`.
  prefs: []
  type: TYPE_NORMAL
- en: The output on line 26 is 3, -23, and 3.5 for `i`, `b`, and `f`, respectively.
    Note that in the output, the `float` variable appears without `f`.
  prefs: []
  type: TYPE_NORMAL
- en: How we arrived at `-23` is explained in the following callout.
  prefs: []
  type: TYPE_NORMAL
- en: Overflowing the byte
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the range of `byte` is -128 (10000000) to +127 (01111111). The
    leftmost bit is the sign bit, with 1 representing negative and 0 representing
    positive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte b` `= (``byte) 233;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal value of `233` (an integer) is too big for `byte` but how was `b`
    assigned the value of -23? Mapping `233` as an `int` type gives us the following
    bit pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`11101001 = 1 + 8 + 32 + 64 + 128 =` `233 (int)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that as an `int` is 4 bytes, `233` is 00000000000000000000000011101001\.
    Mapping that bit pattern as a **byte** (the high order 3 bytes are truncated)
    gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`11101001 = 1 + 8 + 32 + 64 + (-128) = -``23 (byte)`'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the leftmost bit is the sign bit. That is why `–128` is in the
    calculation. It is `-(2`7`) = -``128`.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude this section by looking at some unusual examples where casting
    is/is not required.
  prefs: []
  type: TYPE_NORMAL
- en: To cast or not to cast, that is the question
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are certain situations where, because the compiler applies rules in the
    background, a cast is *not* required. Let’s examine some of these situations with
    code examples. *Figure 3**.8* presents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Situations where casting is not always necessary](img/B19793_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Situations where casting is not always necessary
  prefs: []
  type: TYPE_NORMAL
- en: Line 32 declares and initializes a `char` variable `c`, to an `int` value of
    `12`. Remember that `char` variables are essentially small positive numbers. Although
    we are assigning an `int` value (4 bytes) to a `char` variable (2 bytes), because
    the literal value is within the range of `char` (0 to 65,535), the compiler allows
    it. Had the literal value been out of the range of `char`, the compiler would
    have generated an error – this is what is happening on line 33.
  prefs: []
  type: TYPE_NORMAL
- en: Line 34 declares and initializes a `short` variable, `s`, to an `int` value
    of `12`. Again, although `short` can hold only 2 bytes, the compiler realizes
    it can store the literal value, `12`, and allows it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, from the compiler’s perspective, assigning literal values into variables
    is different to assigning *variables* to variables. For example, lines 32 and
    37 are quite different. This will become apparent as we discuss the next few lines
    in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 35 to 38 demonstrate that while both `char` and `short` require 2 bytes,
    they have different ranges: `char` (0 to 65,535) and `short` (-32,768 to +32,767).
    This means that a `short` variable can hold a negative value such as -15, whereas
    a `char` variable cannot. Conversely, a `char` variable can hold a value such
    as 65,000 but a `short` variable cannot. Therefore, as lines 35 and 37 demonstrate,
    you cannot directly assign a `char` variable to a `short` variable and vice versa.
    You need a cast in both scenarios. Lines 36 and 38 demonstrate this.'
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time constants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: However, lines 40 to 42 show a way around the requirement for the cast we just
    outlined. If you declare your variable as a *compile-time constant* (and assuming
    the value is in range), the compiler will allow the variable-to-variable assignment.
    Line 40 uses the `final` keyword to declare a compile-time constant. We will discuss
    `final` in detail in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), but in this
    context, it means that `c1` will always have a value of `12`. The value is fixed
    (or *constant*) for `c1` and this is done at *compile time*. If you try to change
    the value of `c1`, you will get a compiler error. Now that the compiler knows
    that `c1` will always have `12` as its value, the compiler can apply the same
    rules that it applies to literal values; in other words, is the value in range?
    This is why line 42 does *not* generate a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on operators. Now, let’s apply them!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mesozoic Eden is doing great. The dinosaurs are healthy and the guests are happy.
    Now that you have some new skills, let’s go ahead and perform slightly more complicated
    tasks!
  prefs: []
  type: TYPE_NORMAL
- en: The caretakers want to be able to keep track of dinosaur weights. It’s your
    task to write a program that calculates the average weight of two dinosaurs. This
    will help our team of nutritionists in planning the correct food portions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proper nutrition is essential for the health of our dinosaurs. The caretakers
    want to have a rough guideline of how much to feed a dinosaur. Write a program
    that determines the amount of food required for a dinosaur based on its weight.
    You can come up with the amount of food needed per weight unit of the dinosaurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our park, we need to have a leap year checker. In our commitment to scientific
    accuracy, use the modulus operator to determine if the current year is a leap
    year. We want to make sure our calendar-themed exhibits are always up to date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a program that checks whether the park’s maximum capacity has been reached.
    The program only needs to print true or false after the words “Max capacity reached:”.
    This is crucial in maintaining safety standards and ensuring a positive visitor
    experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes visitors want to compare dinosaurs’ ages. And we get it – this could
    be interesting for educational purposes. Write a program that calculates the age
    difference between two dinosaurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Mesozoic Eden, we have a very strong safety-first policy. Write a program
    that checks whether the park’s safety rating is above a certain threshold. Maintaining
    a good safety rating is our utmost priority.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Dino meal planner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a zookeeper in Mesozoic Eden, the crucial tasks include planning the meals
    for our beloved dinosaurs. While we’re not using conditionals and loops yet, we
    can still calculate some basic requirements!
  prefs: []
  type: TYPE_NORMAL
- en: Develop a simple program to help the zookeepers plan the meal portions for different
    dinosaurs. The program should use the dinosaur’s weight to calculate how much
    food it needs to eat per meal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a bit more guidance, here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare variables for the dinosaur’s weight and the proportion of its weight
    it needs to eat per day. For instance, if a dinosaur needs to eat 5% of its body
    weight daily, and it weighs 2,000 kg, it would need to eat 100 kg of food.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s say you feed the dinosaur twice a day. Declare a variable for the
    number of feedings and calculate how much food you need to serve per feeding.
    In this example, it would be 50 kg per feeding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print out the result in a meaningful way – for example, “Our 2,000 kg dinosaur
    needs to eat 100 kg daily, which means we need to serve 50 kg per feeding.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how Java’s operators work and how they cooperate.
    In addition, we learned how to cast in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we discussed two important properties relating to operators: precedence
    and associativity. We saw that precedence dictates how common terms are grouped.
    Associativity comes into play when the operators have the same order of precedence.'
  prefs: []
  type: TYPE_NORMAL
- en: We then examined the operators themselves. We started by looking at unary operators,
    which have one operand such as the prefix/postfix increment/decrement operators,
    `++` and `--`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then moved on to the arithmetic operators: `+`, `-`, `*`, `/`, and `%`.
    We noted that integer division truncates. In addition, we discussed that any math
    operations involving `int` types or smaller results in `int`. Lastly, we discussed
    in detail how the `+` operator works when one or both operands are strings. In
    these cases, a string append is performed.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed relational operators. The results of these operators are
    always boolean values and will be used when we construct conditional statements
    in [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087).
  prefs: []
  type: TYPE_NORMAL
- en: As Java cannot perform operations where the types are different, where possible,
    Java performs implicit promotion. This is where Java promotes the smaller type
    to the larger type somewhere in memory. This is Java’s way of invisibly continuing
    with the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then discussed the logical operators: `&&`, `||`, `&`, `|`, and `^`. Truth
    tables were presented to aid in understanding. Both the logical `&&` and logical
    `||` operators are short-circuiting operators. Understanding this is important
    because the order of evaluation trumps precedence.'
  prefs: []
  type: TYPE_NORMAL
- en: The bitwise operators, bitwise AND (`&`) and bitwise OR (`|`), are similar except
    that in contrast to `&&` and `||`, both `&` and `|` never short-circuit and can
    also work with integral operands.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator takes three operands. It evaluates a boolean expression
    and assigns one of two values to a variable, depending on whether the boolean
    expression was `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding operators, the last group we covered were the compound assignment
    operators, of which there is one for each mathematical operator.
  prefs: []
  type: TYPE_NORMAL
- en: In our discussion on casting, we covered both widening and narrowing. Widening
    is done in the background and is often called *implicit promotion*. There is no
    risk here as the type being promoted fits easily into the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing is where the cast is required. This is because, given that you are
    going from a type that requires more storage space to a type that requires less,
    there is a potential loss of data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use operators, in the next chapter, we will move on
    to conditional statements, where operators are commonly used.
  prefs: []
  type: TYPE_NORMAL
