- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Operators and Casting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符和类型转换
- en: In [*Chapter 2*](B19793_02.xhtml#_idTextAnchor051), we learned that variables
    are simply named pigeonholes and contain values. These values vary and Java provides
    eight primitive data types accordingly. These primitive types cater for whole
    numbers (`byte`, `char`, `short`, `int`, and `long`), decimal numbers (`float`
    and `double`), and the literals true and false (`boolean`).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B19793_02.xhtml#_idTextAnchor051)中，我们了解到变量只是命名的小鸽笼，并包含值。这些值是变化的，Java相应地提供了八个原始数据类型。这些原始类型包括整数（`byte`、`char`、`short`、`int`和`long`）、小数（`float`和`double`）以及布尔字面量（`boolean`）。
- en: We also learned how to declare a variable. As Java is a strongly typed language,
    this means you must give every variable a data type immediately upon declaration.
    This is where primitive data types are very useful.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何声明一个变量。由于Java是一种强类型语言，这意味着你必须在声明变量时立即为其指定一个数据类型。这正是原始数据类型非常有用的地方。
- en: Now that we know how to declare variables, let’s do something interesting with
    them. By the end of this chapter, you will be able to combine variables using
    Java’s various operators. In addition, you will understand Java casting, including
    what it is, and when and why it occurs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何声明变量，让我们用它们做一些有趣的事情。到本章结束时，你将能够使用Java的各种运算符组合变量。此外，你将理解Java类型转换，包括它是什么，以及何时以及为什么发生。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Learning how Java’s operators cooperate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Java运算符的协作方式
- en: Understanding Java’s operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Java的运算符
- en: Explaining Java casting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Java类型转换
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3)。
- en: Learning how Java’s operators cooperate
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Java运算符的协作方式
- en: Java provides numerous operators for us to work with. By way of definition,
    if we have an expression `3 + 4`, the `+` is the *operator*, whereas `3` and `4`
    are the *operands*. Since `+` has *two* operands, it is known as a *binary* operator.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java为我们提供了大量的运算符来使用。根据定义，如果我们有一个表达式 `3 + 4`，那么 `+` 是 *运算符*，而 `3` 和 `4` 是 *操作数*。由于
    `+` 有 *两个* 操作数，它被称为 *二元* 运算符。
- en: Before we discuss the operators themselves, we must first discuss two important
    features relating to Java operators, namely **order of precedence** and **associativity**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论运算符本身之前，我们必须首先讨论与Java运算符相关的两个重要特性，即**优先级顺序**和**结合性**。
- en: Order of precedence
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级顺序
- en: 'Order of precedence specifies how operands are grouped with operators. This
    becomes important when you have shared operands in a complex expression. In the
    following code segment, we have an expression of `2 + 3 * 4`, where `*` represents
    multiplication and `+` represents addition:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级顺序指定了操作数如何与运算符组合。当你在复杂表达式中共享操作数时，这一点变得很重要。在下面的代码段中，我们有一个表达式 `2 + 3 * 4`，其中
    `*` 代表乘法，`+` 代表加法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `3` is shared by both `2` and `4`. So, the question arises,
    do we group `3` with `2`, where the expression is `(2 + 3) * 4`, giving us `20`;
    or do we group `3` with `4`, where the expression is `2 + (3 * 4)`, giving us
    `14`? This is where the order of precedence applies. As `*` has higher precedence
    than `+`, `3` is grouped with `4` and therefore the expression evaluates to `2
    + (3 * 4)`. Note that the evaluation order is still left to right; it is just
    that `3` is grouped with `4` rather than with `2`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`3` 同时被 `2` 和 `4` 使用。因此，问题出现了，我们是将 `3` 与 `2` 组合在一起，表达式为 `(2 + 3) * 4`，得到
    `20`；还是将 `3` 与 `4` 组合在一起，表达式为 `2 + (3 * 4)`，得到 `14`？这就是优先级顺序发挥作用的地方。由于 `*` 的优先级高于
    `+`，`3` 与 `4` 组合在一起，因此表达式计算为 `2 + (3 * 4)`。请注意，计算顺序仍然是左到右；只是 `3` 与 `4` 组合在一起，而不是与
    `2` 组合在一起。
- en: Parentheses in an expression
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的括号
- en: Note that parentheses can change the default order of operator precedence. As
    we have seen, the default order of precedence, where `*` has higher precedence
    than `+`, means that `2 + 3 * 4` is `14`. This is the same as `2 + (3 *` `4)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，括号可以改变运算符的默认优先级顺序。正如我们所见，默认的优先级顺序，其中 `*` 的优先级高于 `+`，意味着 `2 + 3 * 4` 的结果是
    `14`。这等同于 `2 + (3 * 4)`。
- en: However, `(2 + 3) * 4` is `20`. In this case, the parentheses grouped `3` with
    `2`, so the expression evaluated to `5 * 4 =` `20`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`(2 + 3) * 4` 的结果是 `20`。在这种情况下，括号将 `3` 与 `2` 组合在一起，因此表达式计算为 `5 * 4 = 20`。
- en: This begs the question, what if you are evaluating an expression that contains
    operators at the same level of precedence? This is where associativity applies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了一个问题，如果你正在评估一个包含具有相同优先级的运算符的表达式，这时结合性就适用了。
- en: Associativity
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合性
- en: 'When an expression has two operators with the same level of precedence, operator
    associativity determines the groupings of operators and operands. For example,
    in the following code segment, we are evaluating a simple expression involving
    two divisions (which have the same level of precedence):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式包含两个具有相同优先级的运算符时，运算符的结合性决定了运算符和操作数的分组。例如，在以下代码段中，我们正在评估一个涉及两个除法（它们具有相同的优先级）的简单表达式：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As division associates left to right, `6` will be grouped with `72` and not
    `3`. Thus, the expression is the same as `(72 / 6) / 3`, which evaluates to `12
    / 3 = 4`. Parentheses can also be used to change the default associativity order.
    Take, for example, the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于除法运算符从左到右结合，`6` 将与 `72` 结合，而不是与 `3` 结合。因此，表达式等同于 `(72 / 6) / 3`，其结果为 `12 /
    3 = 4`。括号也可以用来改变默认的结合顺序。例如，以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, `6` is now grouped with `3` and the expression evaluates to `72
    / 2 =` `36`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`6` 现在将与 `3` 结合，表达式计算结果为 `72 / 2 =` `36`。
- en: '*Table 3.1* outlines the order of precedence and associativity rules:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 3.1* 概述了优先级和结合性规则：'
- en: '![Table 3.1 – Order of precedence and associativity rules](img/B19793_03_Table_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![表 3.1 – 优先级和结合性规则顺序](img/B19793_03_Table_01.jpg)'
- en: Table 3.1 – Order of precedence and associativity rules
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 优先级和结合性规则顺序
- en: Note that *Table 3.1* is simplified in that it refers to the operators that
    are commonly used. For example, the unsigned right shift operator, `>>>`, is omitted
    as it is rarely used. Also, note that the `instanceof` operator will be discussed
    in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*表 3.1* 是简化的，因为它只提到了常用的运算符。例如，无符号右移运算符 `>>>` 被省略，因为它很少使用。另外，请注意，`instanceof`
    运算符将在 [*第 8 章*](B19793_08.xhtml#_idTextAnchor168) 中讨论。
- en: 'It is interesting to note that the assignment operator, namely `=`, is at the
    bottom of the precedence table. This means that regardless of the expression on
    the right-hand side of the assignment, the assignment will always be done last.
    This makes sense. Also, while most of the operators associate left to right, the
    assignment associates right to left. This is demonstrated in the following code
    segment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，赋值运算符，即 `=`，在优先级表中位于底部。这意味着无论赋值右侧的表达式是什么，赋值总是最后进行的。这是有道理的。此外，虽然大多数运算符的结合性是从左到右的，但赋值运算符的结合性是从右到左的。这在下述代码段中得到了演示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code segment outputs `false` three times. The crucial line is
    `b3 = b2 = b1;`. Since the assignment associates right to left, the value in `b1`,
    which is `false`, is assigned to `b2`; then, the value in `b2`, which is now `false`,
    is assigned to `b3`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段输出了 `false` 三次。关键行是 `b3 = b2 = b1;`。由于赋值运算符的结合性是从右到左的，所以 `b1` 中的值，即 `false`，被赋值给
    `b2`；然后，`b2` 中的值，现在是 `false`，被赋值给 `b3`。
- en: Now that we understand these properties, let’s examine the operators themselves.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些属性，让我们来检查运算符本身。
- en: Understanding Java’s operators
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Java 的运算符
- en: 'Operators can be grouped into the following categories:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符可以分为以下几类：
- en: Unary operators
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符
- en: Arithmetic operators
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Relational operators
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Logical operators
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Ternary operator
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元运算符
- en: Compound assignment operators
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: We will now discuss each category in turn.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将依次讨论每一类。
- en: Unary operators
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一元运算符
- en: Unary operators have only one operand, hence the term *unary*. Let’s examine
    them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符只有一个操作数，因此称为*一元*。让我们来检查它们。
- en: Prefix and postfix unary operators
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前缀和后缀一元运算符
- en: '`++` and `--` denote these operators and they increment and decrement by 1,
    respectively. If the operator appears before the variable, it is known as *prefix*,
    while if the operator appears after the variable, it is called *postfix*. For
    example, *++x* is prefix increment, whereas *y--* is postfix decrement.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 和 `--` 表示这些运算符，它们分别增加和减少1。如果运算符出现在变量之前，它被称为*前缀*，而如果运算符出现在变量之后，它被称为*后缀*。例如，*++x*
    是前缀递增，而 *y--* 是后缀递减。'
- en: 'Depending on whether `++` or `--` appears before or after the variable can,
    in some situations, affect the overall expression. This is best explained with
    a code sample, as shown in *Figure 3**.1*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `++` 或 `--` 是出现在变量之前还是之后，在某些情况下可能会影响整个表达式的结果。这最好通过代码示例来解释，如 *图 3**.1* 所示：
- en: '![Figure 3.1 – Prefix and postfix increment and decrement operators](img/B19793_03_1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 前缀和后缀递增和递减运算符](img/B19793_03_1.jpg)'
- en: Figure 3.1 – Prefix and postfix increment and decrement operators
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 前缀和后缀递增和递减运算符
- en: In *Figure 3**.1*, on line 25, we can see that `x` is initialized to `3`. On
    line 26, `x` is incremented by 1 to `4`. Line 26 is a simple statement and because
    of that, whether it is prefix or postfix notation does not matter. Line 27 outputs
    the value of `x` to show that it is `4` at this point.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.1中，第25行我们可以看到`x`被初始化为`3`。在第26行，`x`增加1变为`4`。第26行是一个简单语句，因此，无论是前缀还是后缀表示法，都没有关系。第27行输出`x`的值，以显示此时它的值是`4`。
- en: Line 28 is where things get interesting. The postfix notation on line 28 has
    a real effect on the screen output. As it is the postfix notation in the `System.out.println`
    command, the current value of `x` is output, and *afterwards*, `x` is incremented
    by 1\. So, the output to the screen is `4`, and afterwards, `x` is incremented
    to `5`. Line 29 demonstrates that `x` is `5`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行是事情变得有趣的地方。第28行的后缀表示法对屏幕输出有实际影响。因为它是在`System.out.println`命令中的后缀表示法，所以输出的是`x`的当前值，然后`x`增加1。所以，屏幕上的输出是`4`，然后`x`增加到`5`。第29行演示了`x`是`5`。
- en: On line 31, `y` is initialized to `4`. On line 32, `y` is decremented by 1 to
    `3`. Again, as line 32 is a simple statement, prefix or postfix notation makes
    no difference. Line 33 outputs the value of `y` to show that it is `3` at this
    point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第31行，变量`y`被初始化为`4`。在第32行，`y`减去1变为`3`。再次强调，由于第32行是一个简单语句，前缀或后缀表示法没有区别。第33行输出`y`的值，以显示此时它的值是`3`。
- en: The prefix notation on line 34 has no real effect on the screen output. As it
    is the prefix notation in the `System.out.println` command, the current value
    of `y` is decremented `y` and the output to the screen match (both are `2`). Lastly,
    line 35 demonstrates that the current value of `y` is `2`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第34行的前缀表示法对屏幕输出没有实际影响。因为它是在`System.out.println`命令中的前缀表示法，所以先递减`y`的值，然后输出到屏幕的值匹配（两者都是`2`）。最后，第35行演示了`y`的当前值是`2`。
- en: Unary plus/minus operators
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一元加减运算符
- en: 'Now that we have discussed the prefix and postfix operators, let’s discuss
    other unary operators. The code in *Figure 3**.2* will help:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了前缀和后缀运算符，让我们来讨论其他一元运算符。图3.2中的代码将有所帮助：
- en: '![Figure 3.2 – Other unary operators](img/B19793_03_2.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 其他一元运算符](img/B19793_03_2.jpg)'
- en: Figure 3.2 – Other unary operators
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 其他一元运算符
- en: In *Figure 3**.2*, line 37 uses the unary plus sign, `+`, to initialize `x`
    to `6`. Here, `+` is the default as numbers without a sign are assumed to be positive
    numbers. Line 38 uses the unary minus sign, `-`, to initialize `y` to be the negative
    of `x`. Lines 39 and 40 demonstrate that `x` and `y` are `6` and `-``6`, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2中，第37行使用一元加号`+`将`x`初始化为`6`。在这里，`+`是默认的，因为不带符号的数字被认为是正数。第38行使用一元减号`-`将`y`初始化为`x`的相反数。第39和第40行演示了`x`和`y`分别是`6`和`-6`。
- en: Cast operator
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换运算符
- en: In *Figure 3**.2*, line 42 uses the cast operator. We will discuss casting in
    greater detail later in this chapter. For now, `3.45` is a `double` literal (8
    bytes) and cannot be stored in an `int` variable, `z`, as `int` variables are
    4 bytes in size. The compiler spots this and generates an error. To get around
    this error, we can use a cast, which takes the form of *(cast type)*. This cast
    enables us to override the compiler error. In this case, we are casting `3.45`
    to an `int` variable, which means we lose the decimal places. Thus, we store `3`
    in `z`, as shown by the output from line 43.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2中，第42行使用了类型转换运算符。我们将在本章后面更详细地讨论类型转换。现在，`3.45`是一个`double`字面量（8字节），不能存储在大小为4字节的`int`变量`z`中。编译器会检测到这一点并生成错误。为了绕过这个错误，我们可以使用类型转换，其形式为`(cast
    type)`。这种转换使我们能够覆盖编译器错误。在这种情况下，我们将`3.45`转换为一个`int`变量，这意味着我们失去了小数位。因此，我们将`3`存储在`z`中，如第43行的输出所示。
- en: Logical NOT operator
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑非运算符
- en: In *Figure 3**.2*, on line 45, we declare a boolean, `b`, and initialize it
    to `true`. On line 46, we output the inverted value of `b` by using the logical
    NOT operator. Note that we are not changing the value of `b` meaning, the value
    of `b` is still `true`. This is shown by the output from line 47.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2中，第45行声明了一个布尔变量`b`并将其初始化为`true`。在第46行，我们通过使用逻辑非运算符输出`b`的相反值。请注意，我们并没有改变`b`的值，也就是说，`b`的值仍然是`true`。这可以通过第47行的输出得到证明。
- en: Now, let’s examine the arithmetic operators.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查算术运算符。
- en: Arithmetic operators
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: There are five arithmetic operators, all of which we will examine now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种算术运算符，我们将在下面逐一考察。
- en: Addition/subtraction operators
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加法/减法运算符
- en: 'As in mathematics, the `+` operator represents addition and the `-` operator
    represents subtraction. Both are binary operators; in other words, there are two
    operands, one on either side of the operator. The following code example demonstrates
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如同数学一样，`+` 运算符代表加法，`-` 运算符代表减法。两者都是二元运算符；换句话说，有两个操作数，一个在运算符的左侧，一个在右侧。以下代码示例展示了这一点：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code segment, `res` has been assigned a value of `6 + 4 – 2`, which
    is `8`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码段中，`res` 被分配了 `6 + 4 – 2` 的值，即 `8`。
- en: Multiplication/division operators
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法/除法运算符
- en: 'The `*` operator represents multiplication and the `/` operator represents
    division. Both are binary operators. Note that *integer division truncates*. The
    following code segment demonstrates this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 运算符代表乘法，`/` 运算符代表除法。两者都是二元运算符。请注意，*整数除法会截断*。以下代码段展示了这一点：'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code segment outputs `3` because integer division truncates. We are dividing
    one integer, `10`, by another integer, `3`. The remainder is simply discarded.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码段输出 `3`，因为整数除法会截断。我们正在将一个整数 `10` 除以另一个整数 `3`，余数被简单地丢弃。
- en: Modulus operator
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 余数运算符
- en: 'The `%` operator is used for calculating the modulus (remainder). The following
    code example demonstrates the modulus operator in action:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 运算符用于计算余数（余数）。以下代码示例展示了余数运算符的作用：'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line initializes `mod1` to be the remainder of `10` divided by `3`,
    which is `1`. In other words, `3` goes into `10` three times and `1` is left over.
    Therefore, `1` is assigned to `mod1`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将 `mod1` 初始化为 `10` 除以 `3` 的余数，即 `1`。换句话说，`3` 可以整除 `10` 三次，剩下 `1`。因此，`1` 被分配给
    `mod1`。
- en: 'The initialization of `mod2` is interesting: `3` goes into `0` zero times and
    there is `0` (or nothing) left over. Hence, `0` is assigned to `mod2`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod2` 的初始化很有趣：`3` 不能整除 `0`，没有剩余。因此，`0` 被分配给 `mod2`。'
- en: The precedence of arithmetic operators
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符的优先级
- en: 'As per *Table 3.1*, `*`, `/`, and `%` have higher precedence than the `+` and
    `–` operators, and assignment has the lowest precedence. *Figure 3**.3* shows
    how this affects the evaluation of expressions in code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *表 3.1*，`*`、`/` 和 `%` 的优先级高于 `+` 和 `–` 运算符，赋值运算符的优先级最低。*图 3**.3* 展示了这如何影响代码中表达式的计算：
- en: '![Figure 3.3 – Arithmetic operators precedence](img/B19793_03_3.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 算术运算符优先级](img/B19793_03_3.jpg)'
- en: Figure 3.3 – Arithmetic operators precedence
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 算术运算符优先级
- en: Lines 61 demonstrates that `*` has higher precedence than `+`, in that the expression
    evaluates to `3 + (2 * 4) = 3 + 8 =` `11`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第 61 行展示了 `*` 的优先级高于 `+`，因为表达式的计算结果是 `3 + (2 * 4) = 3 + 8 =` `11`。
- en: Line 63 demonstrates that parentheses change the grouping. Now, the shared value,
    `2`, is grouped with `3` (as opposed to `4`, which was the case on line 61). The
    expression now evaluates to `5 * 4 =` `20`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第 63 行展示了括号会改变分组。现在，共享值 `2` 与 `3` 分组（而不是第 61 行的情况，那时是 `4`）。表达式现在计算结果为 `5 * 4
    =` `20`。
- en: Line 65 demonstrates that `+` and `-` associate left to right. The expression
    evaluates to
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第 65 行展示了 `+` 和 `-` 也是从左到右结合的。表达式的计算结果为
- en: '`10 - 2 =` `8`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`10 - 2 =` `8`。'
- en: Lines 67 demonstrates that `*`, `/`, and `%` also associate left to right. The
    expression evaluates to `2 * 6 % 10`, which, in turn, evaluates to `12 % 10`,
    which is `2`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第 67 行展示了 `*`、`/` 和 `%` 也从左到右结合。表达式计算结果为 `2 * 6 % 10`，这又转换为 `12 % 10`，结果是 `2`。
- en: Math operations involving `int` variables or smaller result in an `int`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及 `int` 变量或更小类型的数学运算结果为 `int`
- en: 'It is interesting to note that any math operation involving an `int` type or
    smaller results in `int`. This is demonstrated in the following code segment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，任何涉及 `int` 类型或更小类型的数学运算都会得到 `int` 类型。以下代码段展示了这一点：
- en: '`byte` `b1=2, b2=3;`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte` `b1=2, b2=3;`'
- en: '`byte b3 = b1 + b2; //` `compiler error`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte b3 = b1 + b2; //` `编译器错误`'
- en: '`byte b4 = (byte)(b1 +` `b2);// Ok`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte b4 = (byte)(b1 +` `b2);// 正确`'
- en: The first line declares 2 bytes, namely `b1` and `b2`. Notice that, even though
    `2` and `3` are integer literals, the compiler is aware that these values are
    within the range of `byte` (-128 to +127) and, consequently, allows the declarations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了两个字节，即 `b1` 和 `b2`。请注意，尽管 `2` 和 `3` 是整数文字，但编译器知道这些值在 `byte` 的范围（-128 到
    +127）内，因此允许这些声明。
- en: However, the next line is a problem. The compiler has a rule that all math operations
    involving `int` types or smaller result in an `int`. Therefore, even though the
    sum of the two bytes, 5, is well within the `byte` range, the compiler complains
    saying “possible loss of data converting from `int` to `byte`”.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下一行是一个问题。编译器有一个规则，即所有涉及 `int` 类型或更小类型的数学运算的结果都是 `int`。因此，即使两个字节之和 5 在 `byte`
    范围内，编译器也会报错，说“从 `int` 转换到 `byte` 可能会丢失数据”。
- en: The last line fixes this issue by casting the result of the addition (an `int`
    type) to a `byte` before the assignment. What this means is that the extra 3 bytes
    from the `int` (that do not fit into the `byte`) are simply discarded. Thus, the
    sum of `b1 + b2` is cast from `int` to `byte` and the resultant `byte` is assigned
    to `b4`. Casting is discussed in more detail later in the chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行通过在赋值之前将加法的结果（`int` 类型）强制转换为 `byte` 来解决这个问题。这意味着 `int` 类型的额外 3 个字节（无法放入
    `byte` 中）将被简单地丢弃。因此，`b1 + b2` 的和从 `int` 转换为 `byte`，结果 `byte` 被赋值给 `b4`。在后面的章节中会更详细地讨论强制转换。
- en: We will finish our discussion on arithmetic operators by examining `+` in a
    different context.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过考察 `+` 在不同上下文中的用法来结束对算术运算符的讨论。
- en: String append
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: As we have seen, Java uses `+` for mathematical addition. However, this occurs
    only if both operands are numbers. For example, 3 + 4 results in 7 because both
    operands, 3 and 4, are numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Java 使用 `+` 进行数学加法。然而，这仅在两个操作数都是数字时才会发生。例如，3 + 4 的结果是 7，因为两个操作数 3 和 4
    都是数字。
- en: 'However, if either operand (or both) are strings, Java performs a `String`
    append. A `String` literal is enclosed in double quotes – for example, `"abc"`,
    `"123"`, `"Sean"`, and `"Maaike"` are all `String` literals. So, just to be clear
    on what operation is performed and when, let’s take a look at some examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果任一操作数（或两个都是）是字符串，Java 会执行 `String` 连接。字符串字面量用双引号括起来——例如，`"abc"`、`"123"`、`"Sean"`
    和 `"Maaike"` 都是 `String` 字面量。所以，为了清楚地了解何时执行何种操作，让我们看看一些示例：
- en: 3 + 4 is mathematical addition. Thus, the result is 7.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 + 4 是数学加法。因此，结果是 7。
- en: “3” + 4 is a string append as there is a string on the left of `+`. The result
    is the string “34.”
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “3” + 4 是一个字符串连接操作，因为 `+` 的左边有一个字符串。结果是字符串 “34。”
- en: 3 + “4” is a string append as there is a string on the right of `+`. Again,
    the result is the string “34.”
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 + “4” 是一个字符串连接操作，因为 `+` 的右边有一个字符串。再次，结果是字符串 “34。”
- en: “3” + “4” is a string append as there is a string on both sides of `+`. The
    result is also the string “34.”
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “3” + “4” 是一个字符串连接操作，因为 `+` 的两边都有字符串。结果也是字符串 “34。”
- en: 'So, what exactly happens during a string append? *Java cannot perform any mathematical
    operations when the operands are of different types*. Let’s examine this with
    an example piece of code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在字符串连接操作中到底发生了什么？*Java 当操作数类型不同时无法执行任何数学运算*。让我们通过一段示例代码来分析：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing to note is that the first line of code only compiles because
    `"3" + 4` results in a `String` literal. When Java encounters a string on the
    left/right/both sides of `+`, it performs string concatenation (append). Essentially,
    as `+` associates left to right, Java appends (adds) the string on the right of
    `+` to the end of the string on the left of `+`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，第一行代码之所以能编译，是因为 `"3" + 4` 的结果是字符串字面量。当 Java 遇到 `+` 的左边/右边/两边都有字符串时，它会执行字符串连接（追加）。本质上，由于
    `+` 是从左到右结合的，Java 会将 `+` 右边的字符串追加到 `+` 左边的字符串的末尾。
- en: In this example, Java sees the `String` literal `"3"` and the `+` operator and
    realizes it must perform a `String` append. To do this, in memory, it creates
    a string version of 4 – in other words, `"4"`. The integer `4` literal is not
    touched. Thus, a new variable is created under the hood – it is a `String` variable,
    and `"4"` is its value. The expression is now `"3" + "4"`. As both operands on
    either side of `+` are now of the same type (both are strings), Java can perform
    the append. The new string is the result of `"3" + "4"`, which is `"34"`. This
    is what is assigned to `s`. The second line demonstrates this by outputting `"34"`
    for `s`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Java 看到了字符串字面量 `"3"` 和 `+` 操作符，并意识到它必须执行字符串连接。为此，在内存中，它创建了一个 4 的字符串版本——换句话说，`"4"`。整数字面量
    `4` 没有被修改。因此，在底层创建了一个新的变量——它是一个 `String` 变量，其值为 `"4"`。现在表达式是 `"3" + "4"`。由于 `+`
    的两边现在都是相同类型的操作数（都是字符串），Java 可以执行连接。新的字符串是 `"3" + "4"` 的结果，即 `"34"`。这就是被赋值给 `s`
    的内容。第二行通过输出 `s` 的 `"34"` 来演示这一点。
- en: 'In *Figure 3**.4*, a more substantial example is presented:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3**.4* 中，提供了一个更复杂的示例：
- en: '![Figure 3.4 – String append in action](img/B19793_03_4.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 字符串连接操作](img/B19793_03_4.jpg)'
- en: Figure 3.4 – String append in action
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 字符串连接操作
- en: On line 79, as both operands, `a` and `b`, are integers, Java initializes `res`
    to `5` (the sum of `3` and `2`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 79 行，由于两个操作数 `a` 和 `b` 都是整数，Java 将 `res` 初始化为 `5`（`3` 和 `2` 的和）。
- en: 'Line 82 is evaluated as follows: `3 + "abc" = "3" + "abc" = "3abc"`. In other
    words, Java realizes that it must do a string append due to the presence of `"abc"`
    on the right-hand side of `+`. Thus, somewhere in memory, a string version of
    the value of `a` is created. In other words, a variable with `"3"` is created.
    Note that `a` *remains an int with 3 as its value*. Now, Java can proceed since
    both operands are the same type (strings): `"3" + "abc"` results in `"3abc"`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第 82 行的评估方式如下：`3 + "abc" = "3" + "abc" = "3abc"`。换句话说，Java 认识到由于 `+` 的右侧存在 `"abc"`，它必须执行字符串连接。因此，在内存的某个地方，创建了一个包含
    `a` 值的字符串版本。换句话说，创建了一个值为 `"3"` 的变量。请注意，`a` 仍然是一个值为 3 的 `int` 类型。现在，Java 可以继续执行，因为两个操作数都是同一类型（字符串）：`"3"
    + "abc"` 结果为 `"3abc"`。
- en: 'Line 83 demonstrates that it does not matter which side of `+` the string is
    on. Plus, it does not matter if the string is a string literal or a string variable.
    The expression on line 83 is evaluated as follows: `"abc" + 3 = "abc" + "3" =
    "abc3"`. This is what `s2` is initialized to. Line 84 outputs the values of both
    `s1` and `s2` with a space between them. Note that `System.out.println` expects
    a string. The string output on line 84 is constructed as follows: `"3abc" + "
    " = "3abc " + "abc3" = "``3abc abc3"`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第 83 行演示了字符串在 `+` 的哪一侧并不重要。此外，字符串是字面量还是字符串变量也不重要。第 83 行的表达式评估方式如下：`"abc" + 3
    = "abc" + "3" = "abc3"`。这就是 `s2` 的初始化值。第 84 行输出 `s1` 和 `s2` 的值，它们之间有一个空格。请注意，`System.out.println`
    期望一个字符串。第 84 行的字符串输出构造方式如下：`"3abc" + " " = "3abc " + "abc3" = "3abc abc3"`。
- en: 'Lines 86 and 87 require special mention. The problem with line 86 is that the
    output string is constructed as follows: `"Output is "+ 3 = "Output is " + "3"
    = "Output is 3" + 2 = "Output is 3" + "2" = "Output is 32"`. This is not what
    we wanted.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第 86 和 87 行需要特别说明。第 86 行的问题在于输出字符串的构造方式如下：`"Output is "+ 3 = "Output is " +
    "3" = "Output is 3" + 2 = "Output is 3" + "2" = "Output is 32"`。这不是我们想要的结果。
- en: 'Line 87 rectifies this by using parentheses to ensure that `a + b` is grouped.
    Thus, the string is constructed as follows: `"Output is "+ 5 = "Output is "+ "5"
    = "Output` `is 5"`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第 87 行通过使用括号来确保 `a + b` 被分组，从而纠正了这个问题。因此，字符串的构造方式如下：`"Output is "+ 5 = "Output
    is "+ "5" = "Output is 5"`。
- en: That finishes the arithmetic operators. We will now examine relational operators.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了算术运算符的介绍。接下来，我们将研究关系运算符。
- en: Relational operators
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: 'Java has six relational operators, all of which result in a `boolean` value
    of `true` or `false`. They are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有六个关系运算符，它们都返回 `boolean` 类型的 `true` 或 `false` 值。具体如下：
- en: '`==` is the equivalence operator'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 是等价运算符'
- en: '`!=` is the not equivalent operator'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 是不等价运算符'
- en: '`>` is the greater than operator'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 是大于运算符'
- en: '`>=` is the greater than or equal to operator'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 是大于或等于运算符'
- en: '`<` is the less than operator'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 是小于运算符'
- en: '`<=` is the less than or equal to operator'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 是小于或等于运算符'
- en: '*Figure 3**.5* shows the relational operators in action in code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.5* 展示了关系运算符在代码中的实际应用：'
- en: '![Figure 3.5 – Relational operators in code](img/B19793_03_5.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 代码中的关系运算符](img/B19793_03_5.jpg)'
- en: Figure 3.5 – Relational operators in code
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 代码中的关系运算符
- en: Line 89 declares two `int` variables, namely `x` and `y`, and initializes them
    to `3` and `4`, respectively. Line 90 uses Java’s equivalence operator, `==`,
    to check if `x` and `y` are equivalent. As they are not, line 90 outputs `false`.
    Line 91 checks the exact opposite. As `x` is not equivalent to `y`, line 91 outputs
    `true`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第 89 行声明了两个 `int` 类型的变量，分别是 `x` 和 `y`，并将它们分别初始化为 `3` 和 `4`。第 90 行使用 Java 的等价运算符
    `==` 来检查 `x` 和 `y` 是否等价。由于它们不等价，第 90 行输出 `false`。第 91 行检查相反的情况。由于 `x` 不等价于 `y`，第
    91 行输出 `true`。
- en: Line 92 outputs whether `x` is greater than `y`. This is, of course, `false`
    as `3` is not greater than `4`. Similarly, line 93 outputs whether `x` is greater
    than or equal to `y`. Again, this is `false`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第 92 行输出 `x` 是否大于 `y`。当然，这是 `false`，因为 `3` 不大于 `4`。同样，第 93 行输出 `x` 是否大于或等于 `y`。这同样是
    `false`。
- en: Line 94 outputs whether `x` is less than `y`. This is `true` as `3` is less
    than `4`. Line 95 outputs whether `x` is less than or equal to `y`. Again, this
    is `true`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第 94 行输出 `x` 是否小于 `y`。这是 `true`，因为 `3` 小于 `4`。第 95 行输出 `x` 是否小于或等于 `y`。这同样是
    `true`。
- en: The relational operators and their boolean return values are going to be extremely
    useful going forward, particularly when we look at conditional statements in [*Chapter
    4*](B19793_04.xhtml#_idTextAnchor087).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符及其布尔返回值在以后将非常有用，尤其是当我们查看*第4章*（B19793_04.xhtml#_idTextAnchor087）中的条件语句时。
- en: Implicit promotion
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式提升
- en: 'While Java’s operators do not require the operands to be exactly the same type,
    the operands must be compatible. Consider the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java的运算符不需要操作数必须是完全相同的类型，但操作数必须是兼容的。考虑以下代码片段：
- en: '`System.out.println(3 + 4.0); //` `7.0`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(3 + 4.0); //` `7.0`'
- en: '`System.out.println(4 == 4.0); //` `true`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(4 == 4.0); //` `true`'
- en: The first line tries to add an `int` variable of `3` to a `double` variable.
    Java realizes that the types are not the same. However, Java can figure out a
    safe solution without bothering us. This is where *implicit promotion* comes in.
    `int` requires 4 bytes of storage whereas `double` requires 8 bytes. In the background,
    somewhere in memory, Java declares a temporary `double` variable and promotes
    `int 3` to `double 3.0`, and stores `3.0` in this temporary location. Now, Java
    can add `3.0` to `4.0` (as both are `double`s), resulting in the answer `7.0`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行尝试将一个`int`类型的`3`变量加到一个`double`类型的变量上。Java意识到这两个类型并不相同。然而，Java可以找出一个安全的解决方案而不打扰我们。这就是*隐式提升*的作用。`int`类型需要4个字节的存储空间，而`double`类型需要8个字节的存储空间。在后台，内存的某个地方，Java声明了一个临时的`double`变量，并将`int
    3`提升为`double 3.0`，然后将`3.0`存储在这个临时位置。现在，Java可以将`3.0`加到`4.0`上（因为两者都是`double`类型），得到的结果是`7.0`。
- en: The second line compares `int 4` with `double 4.0`. The same process happens.
    Java implicitly promotes `4` to `4.0` (in a new temporary location) and then compares
    `4.0` with `4.0`. This results in `true` being output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行比较`int 4`和`double 4.0`。发生同样的过程。Java隐式地将`4`提升为`4.0`（在新的临时位置），然后比较`4.0`和`4.0`。这导致输出`true`。
- en: Now, we will turn our attention to logical operators.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向逻辑运算符。
- en: Logical operators
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators enable us to build complex `boolean` expressions by combining
    sub-expressions. These operators are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符使我们能够通过组合子表达式来构建复杂的`boolean`表达式。这些运算符如下：
- en: '`&&` is the logical AND'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`是逻辑与'
- en: '`||` is the logical OR'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`是逻辑或'
- en: '`&` is the bitwise AND'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`是位与'
- en: '`|` is the bitwise OR'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`是位或'
- en: '`^` is the bitwise eXclusive OR (XOR)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`是位异或（XOR）'
- en: 'We will examine these in turn with code examples to help explain how they operate.
    But before we do that, it is worthwhile refreshing our truth tables, as shown
    in *Table 3.2*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次通过代码示例来检查这些运算符，但在这样做之前，回顾一下*表3.2*中的真值表是有益的，如下所示：
- en: '![Table 3.2 – Boolean truth tables](img/B19793_03_Table_02.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![表3.2 – 布尔真值表](img/B19793_03_Table_02.jpg)'
- en: Table 3.2 – Boolean truth tables
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 – 布尔真值表
- en: In *Table 3.2*, the first two columns, **P** and **Q**, represent two expressions,
    where **T** means true and **F** means false. For example, the logical AND column
    (the **P && Q** column) represents the result of the overall expression, **P &&
    Q**, depending on the values of **P** and **Q**. So, if **P** is true and **Q**
    is **T**, then **P && Q** is also true.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表3.2*中，前两列，**P**和**Q**，代表两个表达式，其中**T**表示真，**F**表示假。例如，逻辑与列（**P && Q**列）表示整体表达式**P
    && Q**的结果，这取决于**P**和**Q**的值。所以，如果**P**为真且**Q**为**T**，那么**P && Q**也为真。
- en: With this table in mind, let’s examine the operators in turn.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格的指导下，我们依次检查运算符。
- en: Logical AND (&&)
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑与（&&）
- en: The logical AND states that both boolean operands must be true for the overall
    expression to be true. This is represented by the **P && Q** column in *Table
    3.2*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与运算符表示两个布尔操作数都必须为真，整个表达式才为真。这由*表3.2*中的**P && Q**列表示。
- en: 'Note that this operator is known as a short-circuiting operator. For example,
    in an expression P && Q, if P evaluates to false, then && will *not* evaluate
    the expression Q because the overall expression will evaluate to false regardless.
    This is because F && F is false and F && T is also false. In effect, Java knows
    that once the expression P is false on the left-hand side of an && expression,
    the overall expression must be false. So, there is no need to evaluate the Q expression
    on the right-hand side, so it *short-circuits*. This is better explained with
    a code example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个操作符被称为短路操作符。例如，在一个表达式 P && Q 中，如果 P 评估为假，那么 `&&` 将**不会**评估表达式 Q，因为整体表达式将评估为假。这是因为
    F && F 是假，F && T 也是假。实际上，Java 知道一旦在 `&&` 表达式的左侧表达式 P 为假，整体表达式必须是假。因此，没有必要评估右侧的表达式
    Q，所以它**短路**了。这最好用一个代码示例来解释：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line initializes two boolean variables, `b1` and `b2`, to `false`
    and `true`, respectively. The second line is the important one. Note that the
    parentheses are required around the `b2=false` sub-expression to get the code
    to compile (otherwise, you will get a syntax error). So, when we plug in `false`
    for `b1`, the expression evaluates to `F && (b2=false)`. As the evaluation order
    is left to right, this will lead `&&` to short-circuit, because, regardless of
    what remains in the expression, there is no way the overall expression can evaluate
    to true. This means that the `(b2=false)` sub-expression is **not** executed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化了两个布尔变量，`b1` 和 `b2`，分别设置为 `false` 和 `true`。第二行是重要的一行。请注意，在 `b2=false`
    子表达式中需要括号来使代码能够编译（否则，你会得到一个语法错误）。因此，当我们为 `b1` 插入 `false` 时，表达式计算为 `F && (b2=false)`。由于评估顺序是从左到右，这将导致
    `&&` 短路，因为无论表达式中剩下什么，整体表达式都无法评估为真。这意味着 `(b2=false)` 子表达式**不会**被执行。
- en: The last line outputs the values of the variables. The output is `false`, `true`,
    and `false` for `b1`, `b2`, and `res`, respectively. Crucially, `b2` is `true`,
    demonstrating that `&&` short-circuited.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行输出了变量的值。输出分别是 `false`、`true` 和 `false`，对应于 `b1`、`b2` 和 `res`。关键的是，`b2` 是
    `true`，这证明了 `&&` 短路了。
- en: Logical OR (||)
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑或（||）
- en: The logical OR states that either or both boolean operands can be true for the
    overall expression to be true. This is represented by the **P || Q** column in
    *Table 3.2*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或表示，只要有一个或两个布尔操作数是真，整体表达式就是真。这由 *表3.2* 中的 **P || Q** 列表示。
- en: 'This operator is also a short-circuiting operator. For example, in an expression
    P || Q, if P evaluates to true, then || will *not* evaluate the expression Q because
    the overall expression will evaluate to true regardless. This is because T ||
    F is true and T || T is also true. In effect, Java knows that once the expression
    P is true on the left-hand side of an || expression, the overall expression must
    be true. So, there is no need to evaluate the expression, Q, and hence it *short-circuits*.
    Again a code example will help:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符也是一个短路操作符。例如，在一个表达式 P || Q 中，如果 P 评估为真，那么 `||` 将**不会**评估表达式 Q，因为整体表达式将评估为真。这是因为
    T || F 是真，T || T 也是真。实际上，Java 知道一旦在 `||` 表达式的左侧表达式 P 为真，整体表达式必须是真。因此，没有必要评估右侧的表达式
    Q，所以它**短路**了。再次用一个代码示例来帮助说明：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line initializes two boolean variables, `b1` and `b2`, to `false`
    and `true`, respectively. The second line is the important one. Note again that
    the parentheses are required around the `b1=true` sub-expression to get the code
    to compile. So, when we plug in `true` for `b2`, the expression evaluates to `T
    || (b1=true)`. As the evaluation order is left to right, this will lead `||` to
    short-circuit because, regardless of what remains in the expression, there is
    no way the overall expression can evaluate to false.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化了两个布尔变量，`b1` 和 `b2`，分别设置为 `false` 和 `true`。第二行是重要的一行。再次请注意，在 `b1=true`
    子表达式中需要括号来使代码能够编译。因此，当我们为 `b2` 插入 `true` 时，表达式计算为 `T || (b1=true)`。由于评估顺序是从左到右，这将导致
    `||` 短路，因为无论表达式中剩下什么，整体表达式都无法评估为假。
- en: The last line outputs the values of the variables. The output is `false`, `true`,
    and `true` for `b1`, `b2`, and `res`, respectively. Crucially, `b1` is `false`,
    demonstrating that `||` short-circuited.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行输出了变量的值。输出分别是 `false`、`true` 和 `true`，对应于 `b1`、`b2` 和 `res`。关键的是，`b1` 是
    `false`，这证明了 `||` 短路了。
- en: Order of evaluation versus precedence
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 评估顺序与优先级
- en: 'This topic often causes confusion and is best explained with some sample pieces
    of code. Let’s start with an example that can be deceptively simple:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题经常引起混淆，最好通过一些示例代码来解释。让我们从一个看似简单的例子开始：
- en: '`int x=2,` `y=3, z=4;`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`int x=2, y=3, z=4;`'
- en: '`int res = x + y * z; // x + (y *` `z)`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`int res = x + y * z; // x + (y * z)`'
- en: '`System.out.println(res);// 14`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(res); // 14`'
- en: As `*` has higher precedence than `+`, the common element `y`, is grouped with
    `z` and not `x`. Thus, the overall expression is `x + (y * z)` = 2 + 12 = 14.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `*` 的优先级高于 `+`，公共元素 `y` 与 `z` 而不是 `x` 组合在一起。因此，整个表达式是 `x + (y * z)` = 2 +
    12 = 14。
- en: 'What is important to note here is that the evaluation order is left to right
    and as evaluation order trumps precedence, `x` is evaluated first before the `(y
    * z)` sub-expression. While this makes no difference in this example, let’s look
    at an example where it does make a difference:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的重要一点是评估顺序是从左到右的，并且由于评估顺序高于优先级，`x` 在 `(y * z)` 子表达式之前被评估。虽然在这个例子中这没有区别，但让我们看看一个有区别的例子：
- en: '`boolean a=false,` `b=false, c=false;`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean a=false, b=false, c=false;`'
- en: '`// a || (b &&` `c)`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`// a || (b && c)`'
- en: '`// The next line evaluates to` `T ||`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 下行计算结果为 T ||`'
- en: '`boolean bool = (a = true) || (b = true) && (c =` `true);`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean bool = (a = true) || (b = true) && (c = true);`'
- en: '`System.out.print(a + ", " + b + ", " + c); // true,` `false, false`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.print(a + ", " + b + ", " + c); // true, false, false`'
- en: As `&&` has higher precedence than `||`, the expression evaluates to `(a = true)
    || ( (b = true) && (c =` `true) )`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `&&` 的优先级高于 `||`，表达式计算结果为 `(a = true) || ( (b = true) && (c = true) )`。
- en: 'In other words, the common sub-expression `(b = true)` is grouped with `(c
    = true)` rather than `(a = true)`. Now comes the crucial bit: *evaluation order
    trumps precedence*. Therefore, `(a = true)` is evaluated first, resulting in `T
    || ((b = true) && (c =` `true))`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，常见的子表达式 `(b = true)` 与 `(c = true)` 而不是 `(a = true)` 组合在一起。现在来谈谈关键点：*评估顺序高于优先级*。因此，`(a
    = true)` 首先被评估，结果为 `T || ((b = true) && (c = true))`。
- en: As `||` is a short-circuit operator, the rest of the expression (to the right
    of `||`) is `true`, `false`, `false`, for `a`, `b`, and `c`, respectively. The
    crucial thing to note here is that `b` and `c` are still `false`!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `||` 是短路运算符，表达式右侧的其余部分（`||` 右侧）为 `true`、`false`、`false`，分别对应 `a`、`b` 和 `c`。这里要注意的关键点是
    `b` 和 `c` 仍然是 `false`！
- en: Now that we have discussed the logical operators, we will move on to bitwise
    operators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了逻辑运算符，我们将继续讨论位运算符。
- en: Bitwise operators
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: Although some of the bitwise operators look very similar to the logical operators,
    they operate quite differently. The principle differences are that the bitwise
    operators can work with both boolean and integral (`byte`, `short`, `int`, `long`,
    and `char`) operands. In addition, bitwise operators do *not* short-circuit.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些位运算符看起来与逻辑运算符非常相似，但它们的操作方式却截然不同。主要区别在于位运算符可以与布尔和整型（`byte`、`short`、`int`、`long`
    和 `char`）操作数一起工作。此外，位运算符**不会**短路。
- en: Let’s examine the boolean bitwise operators first.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查布尔位运算符。
- en: Bitwise AND (&)
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位与（&）
- en: 'Comparing the bitwise AND (`&`) with the logical AND (`&&`), the difference
    is that the bitwise AND will *not* short-circuit. This is represented by the **P
    & Q** column in *Table 3.2*. If we take the sample code that we used for the logical
    AND but change it to use the bitwise AND operator, you will see the difference
    in the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 比较位与（`&`）与逻辑与（`&&`），区别在于位与**不会**短路。这由 *表 3.2* 中的 **P & Q** 列表示。如果我们使用逻辑与的示例代码，但将其更改为使用位与运算符，你将看到输出结果的不同：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the `(b2=false)` sub-expression is executed because `&` did not
    short-circuit. So we had `false` & `false`, which is `false`. Thus, the output
    is `false` for all the variables.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`(b2=false)` 子表达式被执行，因为 `&` 没有短路。因此，我们得到 `false & false`，结果是 `false`。因此，所有变量的输出都是
    `false`。
- en: Bitwise OR (|)
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位或（|）
- en: 'Comparing the bitwise OR (`|`) with the logical OR (`||`), the difference is
    that the bitwise OR will *not* short-circuit. This is represented by the **P |
    Q** column in *Table 3.2*. If we take the sample code that we used for the logical
    OR but change it to use the bitwise OR operator, you will see the difference in
    the output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 比较位或（`|`）与逻辑或（`||`），区别在于位或**不会**短路。这由 *表 3.2* 中的 **P | Q** 列表示。如果我们使用逻辑或的示例代码，但将其更改为使用位或运算符，你将看到输出结果的不同：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, the `(b1=true)` sub-expression is executed because `|` did not
    short-circuit. So, we had: `true` | `true`, which is `true`. Thus, the output
    is `true` for all the variables.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`(b1=true)` 子表达式被执行，因为 `|` 没有短路。所以，我们有：`true` | `true`，结果是 `true`。因此，所有变量的输出都是
    `true`。
- en: Bitwise XOR (^)
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按位异或 (^)
- en: 'This is another non-short-circuiting operator. The bitwise XOR, represented
    by the `^` operator, evaluates to `true`, if and only if one of the operands is
    `true` but *not* both. This is represented by the **P ^ Q** column in *Table 3.2*.
    Let’s look at some examples in terms of code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非短路运算符。按位异或运算符，用 `^` 表示，当且仅当其中一个操作数是 `true` 但 **不是** 两个都为 `true` 时，结果为 `true`。这由
    *表 3.2* 中的 **P ^ Q** 列表示。让我们通过代码来看一些示例：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `boolean` variable, `b1`, is initialized to `false` because both of the
    sub-expressions – `(5 > 1)` and `(10 < 20)` – are `true`. Similarly, `b4` is also
    initialized to `false` because both `(5 > 10)` and `(10 < 2)` are `false`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 变量 `b1` 被初始化为 `false`，因为两个子表达式——`(5 > 1)` 和 `(10 < 20)`——都是 `true`。同样，`b4`
    也被初始化为 `false`，因为 `(5 > 10)` 和 `(10 < 2)` 都是 `false`。'
- en: However, `b2` is `true` because even though `(5 > 10)` is `false`, `(10 < 20)`
    is `true`, and `F ^ T` is `true`. Likewise, `b3` is `true` because `(5 > 1)` is
    `true`, `(10 < 2)` is `F`, and `T ^ F` is `true`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`b2` 是 `true`，因为尽管 `(5 > 10)` 是 `false`，`(10 < 20)` 是 `true`，且 `F ^ T` 是
    `true`。同样，`b3` 是 `true`，因为 `(5 > 1)` 是 `true`，`(10 < 2)` 是 `F`，且 `T ^ F` 是 `true`。
- en: Now that we have examined the bitwise operators when used with `boolean` operands,
    we will now briefly examine how the same operators work when the operands are
    integral numbers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了按位运算符与 `boolean` 操作数一起使用的情况，我们现在将简要地检查当操作数是整数时，这些运算符是如何工作的。
- en: Bitwise operators (integral operands)
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按位运算符（整数操作数）
- en: 'Though not commonly used, we have included them for completeness. A code example
    is useful here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常用，但我们为了完整性而包括它们。一个代码示例在这里很有用：
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the operands are integrals (as opposed to booleans), the bit patterns
    become important in evaluating the result. For the `&` operator, both bits must
    be 1 for that bit to be 1 in the result:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作数是整数（而不是布尔值）时，位模式在评估结果时变得重要。对于 `&` 运算符，结果中的该位必须两个位都为 1 才能是 1：
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For the `|` operator, one of the bits, or both, must be 1 for that bit to be
    1 in the result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `|` 运算符，结果中的该位必须为 1，至少有一个位或两个位必须为 1：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the `^` operator, one of the bits, but not both, must be 1 for that bit
    to be 1 in the result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `^` 运算符，结果中的该位必须至少有一个位为 1，但不能两个都为 1：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That completes the bitwise operators. Now, let’s cover the ternary operator.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了按位运算符。现在，让我们来介绍三元运算符。
- en: Ternary operator
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: The ternary operator, as its name suggests, is an operator that takes three
    operands. The ternary operator is used to evaluate boolean expressions and assign
    values accordingly to a variable. In other words, as boolean expressions evaluate
    to `true` or `false` only, the goal of the ternary operator is to decide which
    of the two values to assign to the variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，三元运算符是一个接受三个操作数的运算符。三元运算符用于评估布尔表达式，并根据结果相应地给变量赋值。换句话说，由于布尔表达式只评估为 `true`
    或 `false`，三元运算符的目标是决定将哪个值赋给变量。
- en: 'The syntax is of the following form:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 语法形式如下：
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s look at an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the boolean expression to be evaluated is `x % 2==0`, which,
    because `x = 4`, evaluates to `true`. Thus, `is an even number` is assigned to
    the string, `s`, and is output. Had `x` been 5, then the boolean expression would
    have been `false`, and therefore, `is an odd number` would have been assigned
    to `s` and output.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，要评估的布尔表达式是 `x % 2==0`，由于 `x = 4`，它评估为 `true`。因此，`是偶数` 被分配给字符串 `s` 并输出。如果
    `x` 是 5，那么布尔表达式将是 `false`，因此，`是奇数` 将被分配给 `s` 并输出。
- en: The last group of operators we will examine are compound assignment operators.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一批运算符是复合赋值运算符。
- en: Compound assignment operators
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: 'These operators exist as a shorthand for more verbose expressions. For example,
    assuming `x` and `y` are both integers, `x = x + y` can be written as `x += y`.
    There are compound assignment operators for all of the mathematical operators:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符作为更冗长的表达式的简写而存在。例如，假设 `x` 和 `y` 都是整数，`x = x + y` 可以写成 `x += y`。所有数学运算符都有相应的复合赋值运算符：
- en: '`+=` Example: `x += y` is the same as `x = x + y`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=` 示例：`x += y` 等同于 `x = x + y`'
- en: '`-=` Example: `x -= y` is the same as `x = x - y`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-=` 示例：`x -= y` 等同于 `x = x - y`'
- en: '`*=` Example: `x *= y` is the same as `x = x * y`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*=` 示例：`x *= y` 等同于 `x = x * y`'
- en: '`/=` Example: `x /= y` is the same as `x = x / y`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/=` 示例：`x /= y` 等同于 `x = x / y`'
- en: '`%=` Example: `x %= y` is the same as `x = x % y`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%=` 示例：`x %= y` 等同于 `x = x % y`'
- en: Indeed, there are compound assignment operators for the bitwise operators –
    for example, x &= 3 is the same as x = x & 3 but they are so rarely used that
    we will just mention that they exist.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，对于位运算符也有复合赋值运算符——例如，`x &= 3` 等同于 `x = x & 3`，但它们很少使用，所以我们只是提一下它们的存在。
- en: 'There are one or two subtleties to be aware of. As mentioned earlier, any mathematical
    operation involving an `int` type or smaller results in `int`. This can result
    in a cast being required to get the code to compile. With the compound assignment
    operators, the cast is in-built, so the explicit cast is not required. Take the
    following code for example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细微之处需要注意。如前所述，任何涉及 `int` 类型或更小类型的数学运算都会得到 `int` 类型。这可能会导致需要类型转换才能使代码编译。对于复合赋值运算符，类型转换是内置的，因此不需要显式转换。以下代码为例：
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line initializes 2 bytes, `b1` and `b2`, to `3` and `4`, respectively.
    The second line is commented out as it generates a compiler error. The addition
    of `b1` and `b2` results in an `int` type that cannot be directly assigned to
    a `byte` variable, unless you cast it down from `int` to `byte`. This is what
    the third line is doing – using the cast (`byte`) to override the compiler error.
    We’ll cover casting very soon but for now, just realize that with the cast, you
    are overriding the compiler error, effectively saying “I know what I am doing,
    proceed.”
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化了两个字节，`b1` 和 `b2`，分别设置为 `3` 和 `4`。第二行被注释掉，因为它会生成编译器错误。`b1` 和 `b2` 的相加结果是一个
    `int` 类型，不能直接赋值给 `byte` 变量，除非你将其从 `int` 类型转换为 `byte` 类型。这就是第三行所做的工作——使用类型转换（`byte`）来覆盖编译器错误。我们很快就会介绍类型转换，但到目前为止，只需意识到，使用类型转换，你正在覆盖编译器错误，实际上是在说“我知道我在做什么，继续。”
- en: The last line is interesting in that, in the background, it is the same as the
    third line. In other words, the compiler translates `b1 += b2` into `b1 = (byte)
    (b1 +` `b2)`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行很有趣，因为在幕后，它与第三行相同。换句话说，编译器将 `b1 += b2` 转换为 `b1 = (byte) (b1 + b2)`。
- en: 'Another subtlety to be aware of is that whatever is on the right-hand side
    of the compound assignment operator is going to be grouped, regardless of precedence.
    An example will help here. Consider the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的细微之处是，复合赋值运算符右侧的内容将被分组，无论其优先级如何。以下是一个例子。考虑以下内容：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We know that `*` has higher precedence than `+` and that the order of evaluation
    is left to right. That said, what is on the right-hand side of `*=` is grouped
    by the compiler by surrounding `2 + 5` with parentheses (in the background). Thus,
    the expression becomes `2 * (2 + 5) = 2 * 7 = 14`. To further this point, had
    the compiler *not* inserted parentheses, the expression would have been evaluated
    to 9\. In other words, due to operator precedence, the expression would have been
    (2 * 2) + 5 = 4 + 5 = 9\. However, as we have seen, this is **not** the case.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `*` 的优先级高于 `+`，且评估顺序是从左到右。话虽如此，`*=` 右侧的内容被编译器通过将 `2 + 5` 括起来（在幕后）进行分组。因此，表达式变为
    `2 * (2 + 5) = 2 * 7 = 14`。为了进一步说明这一点，如果编译器没有插入括号，表达式将被评估为 9。换句话说，由于运算符优先级，表达式将被评估为
    (2 * 2) + 5 = 4 + 5 = 9。然而，正如我们所看到的，这**不是**情况。
- en: 'Let’s look at another more complicated example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个更复杂的例子：
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this example, the right-hand side is, once again, enclosed in parentheses:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，右侧再次被括号包围：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Translating `+=` into its longer form gives us the following output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `+=` 转换为其较长的形式，我们得到以下输出：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The order of evaluation is left to right, so plugging in the current value
    of `k`, which is `1`, results in:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 评估顺序是从左到右，所以插入当前 `k` 的值，即 `1`，结果如下：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, by plugging in the right-hand side expression, we get the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过插入右侧的表达式，我们得到以下结果：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the order of evaluation is left to right, `k` is changed to `4` before we
    add `2`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于评估顺序是从左到右，我们在加上 `2` 之前将 `k` 改为 `4`：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That concludes our treatment of Java operators. Now, let’s examine Java casting,
    a topic we have touched on already in this chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Java 运算符的处理。现在，让我们来探讨 Java 类型转换，这是我们已经在本章中提到过的主题。
- en: Explaining Java casting
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 Java 类型转换
- en: 'To discuss casting properly, we need to explain both the widening and narrowing
    of Java’s primitive data types. With this in mind, it is helpful to remember the
    sizes of the primitive data types in bytes. *Table 3.3* represents this information:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地讨论类型转换，我们需要解释 Java 原始数据类型的类型提升和类型缩小。考虑到这一点，记住原始数据类型的大小（以字节为单位）是有帮助的。*表
    3.3* 表示了这些信息：
- en: '![Table 3.3 – The sizes of Java’s primitive types](img/B19793_03_Table_03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![表 3.3 – Java 的原始数据类型大小](img/B19793_03_Table_03.jpg)'
- en: Table 3.3 – The sizes of Java’s primitive types
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3 – Java 的原始数据类型大小
- en: The preceding table presents the sizes in bytes of Java’s various primitive
    data types. This will help us as we discuss both widening and narrowing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格展示了 Java 各种原始数据类型的大小（以字节为单位）。这将在我们讨论类型提升和类型缩小时有所帮助。
- en: Widening
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提升
- en: 'Widening is done automatically; in other words, a cast is not needed. As the
    promotion is done in the background, widening is also known as *implicit promotion*.
    With *Table 3.3* in mind, the widening rules are as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提升是自动完成的；换句话说，不需要类型转换。由于提升是在后台完成的，因此类型提升也被称为 *隐式提升*。考虑到 *表 3.3*，类型提升的规则如下：
- en: byte → short/char → int → long → float → double
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: byte → short/char → int → long → float → double
- en: 'Given the sizes from *Table 3.3*, most of these rules should make sense. For
    example, a `byte` can automatically fit into a `short` because 1 byte fits into
    2 bytes automatically. The only interesting one is `long` → `float`, which is
    *widening* from 8 bytes to 4 bytes. This is possible because even though a `long`
    requires 8 bytes and a `float` requires only 4 bytes, their ranges differ – that
    is, a `float` type can accommodate any `long` value but not vice versa. This is
    shown in the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表 3.3 中的大小，大多数这些规则应该是有意义的。例如，`byte` 可以自动适应 `short`，因为 1 个字节可以自动适应 2 个字节。唯一有趣的一个是
    `long` → `float`，这是从 8 个字节到 4 个字节的类型提升。这是可能的，因为尽管 `long` 需要 8 个字节，而 `float` 只需要
    4 个字节，但它们的范围不同 – 即 `float` 类型可以容纳任何 `long` 值，但反之则不行。这在下述代码片段中显示：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the scientific notation `E` used for floating point. `float` takes up less
    space, but due to its representation, it can hold larger and smaller numbers than
    `long`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意用于浮点数的科学记数法 `E`。`float` 占用的空间更少，但由于其表示方式，它可以容纳比 `long` 更大和更小的数字。
- en: Scientific notation
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 科学记数法
- en: 'Scientific notation is a shorthand way to represent decimal numbers and can
    be useful for representing very large and/or very small numbers. Here are some
    examples:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 科学记数法是一种表示十进制数字的简写方式，可以用于表示非常大和/或非常小的数字。以下是一些示例：
- en: '`double d1 = .``00000000123;`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`double d1 = .``00000000123;`'
- en: '`double d2 =` `1.23e-9;`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`double d2 =` `1.23e-9;`'
- en: '`System.out.println(d1==d2); //` `true`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(d1==d2); //` `true`'
- en: '`double d3 =` `120_000_000;`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`double d3 =` `120_000_000;`'
- en: '`double d4 =` `1.2e+8;`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`double d4 =` `1.2e+8;`'
- en: '`System.out.println(d3==d4); //` `true`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(d3==d4); //` `true`'
- en: As the comparisons both return `true`, this means that `d1` is the internal
    representation of `d2`. Similarly, both `d3` and `d4` are equivalent.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个比较都返回 `true`，这意味着 `d1` 是 `d2` 的内部表示。同样，`d3` 和 `d4` 也是等效的。
- en: 'Let’s examine widening in code. *Figure 3**.6* demonstrates this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码来检查类型提升。*图 3**.6* 展示了这一点：
- en: '![Figure 3.6 – Implicit widening examples](img/B19793_03_6.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 隐式类型提升示例](img/B19793_03_6.jpg)'
- en: Figure 3.6 – Implicit widening examples
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 隐式类型提升示例
- en: Line 14 is a regular `char` assignment – in other words, no widening is involved.
    Note that characters (represented by `char`) are simply small numbers (0..65,535).
    To represent a character, we enclose the character in single quotes. In contrast,
    a `String`, which is a sequence of characters, is represented in double quotes.
    Therefore, `"a"` is a `String`, whereas `'a'` is a character.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第 14 行是一个常规的 `char` 赋值 – 换句话说，没有类型提升。注意字符（由 `char` 表示）只是简单的数字（0..65,535）。为了表示一个字符，我们将字符放在单引号内。相比之下，`String`（字符序列）用双引号表示。因此，`"a"`
    是一个 `String`，而 `'a'` 是一个字符。
- en: Line 15 is a widening from `char` (2 bytes) to `int` (4 bytes). Line 16 is a
    widening from `int` to `float`. Although both `int` and `float` require 4 bytes,
    as discussed earlier with `long`, `float` has a greater range, so there is no
    issue here. Line 17 is a widening from `float` to `double`. Lastly, line 18 is
    a widening from `long` to `float`. Note that there are no compiler errors anywhere
    and that the cast operator is not needed in any of the assignments.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行是从`char`（2字节）到`int`（4字节）的扩展。第16行是从`int`到`float`的扩展。尽管`int`和`float`都需要4字节，如前所述，与`long`一样，`float`有更大的范围，所以这里没有问题。第17行是从`float`到`double`的扩展。最后，第18行是从`long`到`float`的扩展。注意，任何地方都没有编译器错误，并且在这些赋值中不需要使用转换运算符。
- en: Now, let’s discuss narrowing, where the cast operator *is* required.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论需要转换的窄化。
- en: Narrowing
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窄化
- en: 'The cast operator is a type enclosed in parentheses – for example, `(int)`
    and `(byte)` are both cast operators that cast to `int` and `byte`, respectively.
    With *Table 3.3* in mind, the following figure, *Figure 3**.7*, presents assignments
    that require casting:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 转换运算符是一个括号内的类型 – 例如，`(int)`和`(byte)`都是转换运算符，分别将值转换为`int`和`byte`。考虑到*表3.3*，以下图，*图3**.7*，展示了需要转换的赋值：
- en: '![Figure 3.7 – Casting examples](img/B19793_03_7.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 转换示例](img/B19793_03_7.jpg)'
- en: Figure 3.7 – Casting examples
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 转换示例
- en: In the preceding figure, line 23 is attempting to assign `3.3`, a `double` type
    (8 bytes), to an `int` type (4 bytes). Without the cast, this would be a compiler
    error. With the cast, you are overriding the compiler error. So, on line 23, we
    are casting `3.3` to `int` and assigning this `int` to the `i` variable. Therefore,
    after the assignment completes, `i` has a value of `3`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第23行试图将`3.3`，一个`double`类型（8字节），赋值给一个`int`类型（4字节）。没有转换，这将是一个编译器错误。有了转换，你将覆盖编译器错误。因此，在第23行，我们将`3.3`转换为`int`，并将这个`int`赋值给`i`变量。因此，赋值完成后，`i`的值为`3`。
- en: Line 24 is casting the `int` type, `233`, into the `byte` variable, `b`. This
    literal value is outside the range of `byte` (-128 to +127), so a cast is required.
    Line 25 is casting the `double` type, `3.5`, to `float`. Remember that, by default,
    a decimal number is `double`; to have it considered as a `float` as opposed to
    a `double`, you must suffix `f` or `F`. For example, `3.3f` is `float`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第24行是将`int`类型的`233`转换为`byte`变量`b`。这个字面值超出了`byte`的范围（-128到+127），因此需要转换。第25行是将`double`类型的`3.5`转换为`float`。记住，默认情况下，十进制数是`double`；要将其视为`float`而不是`double`，必须后缀`f`或`F`。例如，`3.3f`是`float`。
- en: The output on line 26 is 3, -23, and 3.5 for `i`, `b`, and `f`, respectively.
    Note that in the output, the `float` variable appears without `f`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第26行的输出是`i`为3，`b`为-23，`f`为3.5。注意，在输出中，`float`变量没有`f`。
- en: How we arrived at `-23` is explained in the following callout.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何得到`-23`的，将在以下说明中解释。
- en: Overflowing the byte
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 字节溢出
- en: Remember that the range of `byte` is -128 (10000000) to +127 (01111111). The
    leftmost bit is the sign bit, with 1 representing negative and 0 representing
    positive.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`byte`的范围是-128（10000000）到+127（01111111）。最左边的位是符号位，其中1表示负数，0表示正数。
- en: 'In the preceding example, we did the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们做了以下操作：
- en: '`byte b` `= (``byte) 233;`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte b = (byte) 233;`'
- en: 'The literal value of `233` (an integer) is too big for `byte` but how was `b`
    assigned the value of -23? Mapping `233` as an `int` type gives us the following
    bit pattern:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`233`（一个整数）的值对于`byte`来说太大，但`b`是如何被赋予-23的值的呢？将`233`映射为`int`类型会得到以下位模式：'
- en: '`11101001 = 1 + 8 + 32 + 64 + 128 =` `233 (int)`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`11101001 = 1 + 8 + 32 + 64 + 128 =` `233 (int)`'
- en: 'Note that as an `int` is 4 bytes, `233` is 00000000000000000000000011101001\.
    Mapping that bit pattern as a **byte** (the high order 3 bytes are truncated)
    gives us the following output:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`int`是4字节，`233`的位模式是00000000000000000000000011101001。将该位模式映射为**byte**（高阶3字节被截断）会得到以下输出：
- en: '`11101001 = 1 + 8 + 32 + 64 + (-128) = -``23 (byte)`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`11101001 = 1 + 8 + 32 + 64 + (-128) = -23 (byte)`'
- en: Remember that the leftmost bit is the sign bit. That is why `–128` is in the
    calculation. It is `-(2`7`) = -``128`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，最左边的位是符号位。这就是为什么计算中包含`-128`的原因。它是`-(2^7) = -128`。
- en: We will conclude this section by looking at some unusual examples where casting
    is/is not required.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看一些需要/不需要转换的非常规示例来结束本节。
- en: To cast or not to cast, that is the question
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 是要转换还是要不转换，这是一个问题
- en: 'There are certain situations where, because the compiler applies rules in the
    background, a cast is *not* required. Let’s examine some of these situations with
    code examples. *Figure 3**.8* presents the code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，由于编译器在后台应用规则，不需要进行类型转换。让我们通过代码示例来检查这些情况。*图3.8*展示了代码：
- en: '![Figure 3.8 – Situations where casting is not always necessary](img/B19793_03_8.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 不总是需要类型转换的情况](img/B19793_03_8.jpg)'
- en: Figure 3.8 – Situations where casting is not always necessary
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 不总是需要类型转换的情况
- en: Line 32 declares and initializes a `char` variable `c`, to an `int` value of
    `12`. Remember that `char` variables are essentially small positive numbers. Although
    we are assigning an `int` value (4 bytes) to a `char` variable (2 bytes), because
    the literal value is within the range of `char` (0 to 65,535), the compiler allows
    it. Had the literal value been out of the range of `char`, the compiler would
    have generated an error – this is what is happening on line 33.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第32行声明并初始化了一个名为`c`的`char`变量，将其赋值为`int`类型的`12`。记住，`char`变量本质上是很小的正数。尽管我们将一个`int`类型的值（4字节）赋给了一个`char`变量（2字节），但由于字面值在`char`的范围内（0到65,535），编译器允许这样做。如果字面值超出了`char`的范围，编译器将生成错误——这就是第33行发生的情况。
- en: Line 34 declares and initializes a `short` variable, `s`, to an `int` value
    of `12`. Again, although `short` can hold only 2 bytes, the compiler realizes
    it can store the literal value, `12`, and allows it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第34行声明并初始化了一个名为`s`的`short`变量，将其赋值为`int`类型的`12`。同样，尽管`short`只能存储2字节，但编译器意识到它可以存储字面值`12`，并允许这样做。
- en: Note that, from the compiler’s perspective, assigning literal values into variables
    is different to assigning *variables* to variables. For example, lines 32 and
    37 are quite different. This will become apparent as we discuss the next few lines
    in the figure.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从编译器的角度来看，将字面值赋给变量与将*变量*赋给变量是不同的。例如，第32和37行是相当不同的。当我们讨论图中的下一几行时，这一点将变得明显。
- en: 'Lines 35 to 38 demonstrate that while both `char` and `short` require 2 bytes,
    they have different ranges: `char` (0 to 65,535) and `short` (-32,768 to +32,767).
    This means that a `short` variable can hold a negative value such as -15, whereas
    a `char` variable cannot. Conversely, a `char` variable can hold a value such
    as 65,000 but a `short` variable cannot. Therefore, as lines 35 and 37 demonstrate,
    you cannot directly assign a `char` variable to a `short` variable and vice versa.
    You need a cast in both scenarios. Lines 36 and 38 demonstrate this.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第35到38行展示了尽管`char`和`short`都需要2字节，但它们的范围不同：`char`（0到65,535）和`short`（-32,768到+32,767）。这意味着`short`变量可以存储负值，例如-15，而`char`变量则不能。相反，`char`变量可以存储如65,000这样的值，但`short`变量则不能。因此，正如第35和37行所展示的，你不能直接将`char`变量赋给`short`变量，反之亦然。在这两种情况下，你需要进行类型转换。第36和38行展示了这一点。
- en: Compile-time constants
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译时常量
- en: However, lines 40 to 42 show a way around the requirement for the cast we just
    outlined. If you declare your variable as a *compile-time constant* (and assuming
    the value is in range), the compiler will allow the variable-to-variable assignment.
    Line 40 uses the `final` keyword to declare a compile-time constant. We will discuss
    `final` in detail in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), but in this
    context, it means that `c1` will always have a value of `12`. The value is fixed
    (or *constant*) for `c1` and this is done at *compile time*. If you try to change
    the value of `c1`, you will get a compiler error. Now that the compiler knows
    that `c1` will always have `12` as its value, the compiler can apply the same
    rules that it applies to literal values; in other words, is the value in range?
    This is why line 42 does *not* generate a compiler error.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第40到42行展示了绕过我们刚才概述的类型转换要求的方法。如果你将变量声明为*编译时常量*（并且假设值在范围内），编译器将允许变量到变量的赋值。第40行使用`final`关键字声明了一个编译时常量。我们将在[*第9章*](B19793_09.xhtml#_idTextAnchor205)中详细讨论`final`，但在这个上下文中，它意味着`c1`将始终具有`12`的值。对于`c1`来说，值是固定的（或*常量*），这是在*编译时*完成的。如果你尝试更改`c1`的值，你将得到编译器错误。现在编译器知道`c1`将始终具有`12`作为其值，编译器可以应用与字面值相同的规则；换句话说，值是否在范围内？这就是为什么第42行不会生成编译器错误。
- en: This concludes our discussion on operators. Now, let’s apply them!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对运算符的讨论。现在，让我们应用它们！
- en: Exercises
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Mesozoic Eden is doing great. The dinosaurs are healthy and the guests are happy.
    Now that you have some new skills, let’s go ahead and perform slightly more complicated
    tasks!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 侏罗纪乐园做得很好。恐龙很健康，客人也很高兴。现在你有一些新技能，让我们继续进行稍微复杂一些的任务！
- en: The caretakers want to be able to keep track of dinosaur weights. It’s your
    task to write a program that calculates the average weight of two dinosaurs. This
    will help our team of nutritionists in planning the correct food portions.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 饲养员们希望能够跟踪恐龙的体重。你的任务是编写一个程序，计算两只恐龙的平均体重。这将帮助我们的营养师团队规划正确的食物分量。
- en: Proper nutrition is essential for the health of our dinosaurs. The caretakers
    want to have a rough guideline of how much to feed a dinosaur. Write a program
    that determines the amount of food required for a dinosaur based on its weight.
    You can come up with the amount of food needed per weight unit of the dinosaurs.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适当的营养对于我们恐龙的健康至关重要。饲养员们希望有一个大致的指导，了解应该给恐龙喂食多少食物。编写一个程序，根据恐龙的体重来确定所需的食物量。你可以根据恐龙每单位体重的食物需求量来计算。
- en: For our park, we need to have a leap year checker. In our commitment to scientific
    accuracy, use the modulus operator to determine if the current year is a leap
    year. We want to make sure our calendar-themed exhibits are always up to date.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的公园，我们需要有一个闰年检查器。在我们对科学准确性的承诺中，使用取模运算符来确定当前年份是否是闰年。我们想确保我们的以日历为主题的展览总是最新的。
- en: Create a program that checks whether the park’s maximum capacity has been reached.
    The program only needs to print true or false after the words “Max capacity reached:”.
    This is crucial in maintaining safety standards and ensuring a positive visitor
    experience.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个程序，检查公园的最大容量是否已达到。程序只需在“最大容量达到：”之后打印出true或false。这对于维护安全标准和确保良好的游客体验至关重要。
- en: Sometimes visitors want to compare dinosaurs’ ages. And we get it – this could
    be interesting for educational purposes. Write a program that calculates the age
    difference between two dinosaurs.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时游客想要比较恐龙的年龄。我们理解——这可能在教育目的上很有趣。编写一个程序，计算两只恐龙之间的年龄差异。
- en: In Mesozoic Eden, we have a very strong safety-first policy. Write a program
    that checks whether the park’s safety rating is above a certain threshold. Maintaining
    a good safety rating is our utmost priority.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中生代伊甸园，我们有一个非常强的以安全为第一的政策。编写一个程序，检查公园的安全评级是否高于某个阈值。保持良好的安全评级是我们的首要任务。
- en: Project – Dino meal planner
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 - 恐龙餐食规划器
- en: As a zookeeper in Mesozoic Eden, the crucial tasks include planning the meals
    for our beloved dinosaurs. While we’re not using conditionals and loops yet, we
    can still calculate some basic requirements!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 作为中生代伊甸园的饲养员，关键任务包括为我们心爱的恐龙规划餐食。虽然我们还没有使用条件语句和循环，但我们仍然可以计算一些基本需求！
- en: Develop a simple program to help the zookeepers plan the meal portions for different
    dinosaurs. The program should use the dinosaur’s weight to calculate how much
    food it needs to eat per meal.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个简单的程序，帮助饲养员为不同的恐龙规划餐食分量。该程序应使用恐龙的体重来计算每餐需要吃多少食物。
- en: 'If you need a bit more guidance, here’s how you can do it:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多指导，以下是你可以这样做的方法：
- en: Declare variables for the dinosaur’s weight and the proportion of its weight
    it needs to eat per day. For instance, if a dinosaur needs to eat 5% of its body
    weight daily, and it weighs 2,000 kg, it would need to eat 100 kg of food.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为恐龙的体重和它每天需要摄入的体重比例声明变量。例如，如果一个恐龙每天需要摄入其体重的5%，而它重2,000公斤，那么它就需要摄入100公斤的食物。
- en: Now, let’s say you feed the dinosaur twice a day. Declare a variable for the
    number of feedings and calculate how much food you need to serve per feeding.
    In this example, it would be 50 kg per feeding.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，假设你每天给恐龙喂食两次。声明一个变量来表示喂食次数，并计算每次喂食需要提供多少食物。在这个例子中，每次喂食将是50公斤。
- en: Print out the result in a meaningful way – for example, “Our 2,000 kg dinosaur
    needs to eat 100 kg daily, which means we need to serve 50 kg per feeding.”
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以有意义的方式打印出结果——例如，“我们的2,000公斤恐龙每天需要吃100公斤食物，这意味着我们每次喂食需要提供50公斤。”
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how Java’s operators work and how they cooperate.
    In addition, we learned how to cast in Java.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了Java运算符的工作原理以及它们是如何协作的。此外，我们还学习了如何在Java中进行类型转换。
- en: 'Initially, we discussed two important properties relating to operators: precedence
    and associativity. We saw that precedence dictates how common terms are grouped.
    Associativity comes into play when the operators have the same order of precedence.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们讨论了与运算符相关的两个重要属性：优先级和结合性。我们了解到优先级决定了常见项是如何分组的。当运算符具有相同的优先级顺序时，结合性就会发挥作用。
- en: We then examined the operators themselves. We started by looking at unary operators,
    which have one operand such as the prefix/postfix increment/decrement operators,
    `++` and `--`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查了运算符本身。我们首先查看一元运算符，它们有一个操作数，例如前缀/后缀增量/减量运算符`++`和`--`。
- en: 'We then moved on to the arithmetic operators: `+`, `-`, `*`, `/`, and `%`.
    We noted that integer division truncates. In addition, we discussed that any math
    operations involving `int` types or smaller results in `int`. Lastly, we discussed
    in detail how the `+` operator works when one or both operands are strings. In
    these cases, a string append is performed.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向算术运算符：`+`、`-`、`*`、`/`和`%`。我们指出，整数除法会截断。此外，我们还讨论了涉及`int`类型或更小类型的任何数学运算都会导致结果为`int`。最后，我们详细讨论了当其中一个或两个操作数是字符串时`+`运算符的工作方式。在这些情况下，执行字符串连接操作。
- en: Next, we discussed relational operators. The results of these operators are
    always boolean values and will be used when we construct conditional statements
    in [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了关系运算符。这些运算符的结果始终是布尔值，当我们在[*第4章*](B19793_04.xhtml#_idTextAnchor087)中构建条件语句时将使用它们。
- en: As Java cannot perform operations where the types are different, where possible,
    Java performs implicit promotion. This is where Java promotes the smaller type
    to the larger type somewhere in memory. This is Java’s way of invisibly continuing
    with the operation.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java无法执行不同类型之间的操作，因此尽可能进行隐式提升。这就是Java在内存中的某个位置将较小的类型提升为较大的类型的方式。这是Java在操作中无意识地继续下去的方式。
- en: 'We then discussed the logical operators: `&&`, `||`, `&`, `|`, and `^`. Truth
    tables were presented to aid in understanding. Both the logical `&&` and logical
    `||` operators are short-circuiting operators. Understanding this is important
    because the order of evaluation trumps precedence.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了逻辑运算符：`&&`、`||`、`&`、`|`和`^`。为了帮助理解，我们展示了真值表。逻辑`&&`和逻辑`||`运算符都是短路运算符。理解这一点很重要，因为求值的顺序优于优先级。
- en: The bitwise operators, bitwise AND (`&`) and bitwise OR (`|`), are similar except
    that in contrast to `&&` and `||`, both `&` and `|` never short-circuit and can
    also work with integral operands.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符，位与运算符（`&`）和位或运算符（`|`），与`&&`和`||`类似，但不同之处在于，与`&&`和`||`不同，`&`和`|`永远不会短路，并且也可以与整型操作数一起工作。
- en: The ternary operator takes three operands. It evaluates a boolean expression
    and assigns one of two values to a variable, depending on whether the boolean
    expression was `true` or `false`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符有三个操作数。它评估一个布尔表达式，并根据布尔表达式是`true`还是`false`将两个值之一赋给一个变量。
- en: Regarding operators, the last group we covered were the compound assignment
    operators, of which there is one for each mathematical operator.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 关于运算符，我们最后讨论的是复合赋值运算符，每个数学运算符都有一个。
- en: In our discussion on casting, we covered both widening and narrowing. Widening
    is done in the background and is often called *implicit promotion*. There is no
    risk here as the type being promoted fits easily into the target type.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论类型转换时，我们涵盖了宽化和狭义转换。宽化是在后台进行的，通常被称为*隐式提升*。这里没有风险，因为被提升的类型可以轻松地适应目标类型。
- en: Narrowing is where the cast is required. This is because, given that you are
    going from a type that requires more storage space to a type that requires less,
    there is a potential loss of data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 狭义转换需要使用类型转换。这是因为，既然你正在从一个需要更多存储空间的类型转换到一个需要较少存储空间的类型，那么可能会丢失数据。
- en: Now that we know how to use operators, in the next chapter, we will move on
    to conditional statements, where operators are commonly used.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用运算符，在下一章中，我们将转向条件语句，其中经常使用运算符。
