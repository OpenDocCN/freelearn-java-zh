<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Patterns of Advanced Functional Programming</h1>
                </header>
            
            <article>
                
<p>We are probably already familiar with the concept of patterns from object-oriented programming. Patterns are common solutions to common problems. Whenever you have a problem that repeats from project to project, solutions also tend to repeat. Similar problems are solved similarly. And hence, such solutions become patterns that are widely accepted.</p>
<p>Functional programming also has its own patterns. Since it has certain problems and challenges unique to it, it will also have unique solutions. In this chapter, we will discuss solutions to common functional programming problems.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Monad Transformers</li>
<li>Tagless Final</li>
<li>Type-level programming</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monad Transformers</h1>
                </header>
            
            <article>
                
<p>Monad Transformers is an important pattern of purely functional programming that allows us to combine effect types. Let's now discuss it in detail.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The specialization of effect types</h1>
                </header>
            
            <article>
                
<p>We've discussed how effect types are ubiquitous in purely functional programming and are used in order to abstract away side effects. You may have also noticed that these types are highly specialized, which means we have almost one-to-one mapping between side effects and effect types. For example, the ability of an application to return null is represented by an <kbd>Option</kbd> side effect type. <kbd>Option</kbd> is good for such null situations. However, it does not perform well when tasked with modeling errors and exceptions. This is because it does not preserve the information of the nature of the failure.</p>
<p>A data type that is good for modeling erroneous computation that can fail is <kbd>Either</kbd>. However, if you try to model a computation that returns null with <kbd>Either</kbd>, you will find that this data type is redundant for these purposes. This is because whenever you have a computation that does not return a value, you will still need to return something from it. In the erroneous scenario, we could have done the following:</p>
<pre>def foo(x: Int): Option[Int] =<br/>  if (x &lt; 0) None<br/>  else Some(math.sqrt(x))</pre>
<p>However, what do you return in the same scenario with <kbd>Either</kbd>? If the correct result is to be modeled by <kbd>Right</kbd>, we should model an empty result with <kbd>Left</kbd>:</p>
<pre>def foo(x: Int): Either[???, Int] =<br/>  if (x &lt; 0) Left(???)<br/>  else Right(math.sqrt(x))</pre>
<p>However, <kbd>Left</kbd> is also supposed to contain a value. What do we return in <kbd>Left</kbd>? Our best bet would be to return a string that explicitly says that the computation did not produce any result:</p>
<pre>def foo(x: Int): Either[String, Int] =<br/>  if (x &lt; 0) Left("Can't take square root of a negative value")<br/><span><span>  </span></span>else Right(math.sqrt(x))</pre>
<p>As you can see, this usage of <kbd>Either</kbd> is rather contrived in this example. This means we have a situation where side effects are fine-grained, and every side effect has its own representing effect type. This is a natural situation for Scala, as for any strongly-typed language. The finer your type system matches the side effects, the more side effects you can model out of the box.</p>
<p>This also means that when we have more than one side effect, we need to think about how are we going to present and combine them.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An application with multiple side effects</h1>
                </header>
            
            <article>
                
<p>Modern applications aim for asynchrony. This means that whenever you need to compute anything, and it may take a long time, you do not compute it in a synchronous manner. That is, you do not wait for the computation to produce a result. Instead, you program in a non-blocking style. This means that you schedule computations to run at some point in the future and wait for the result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchrony</h1>
                </header>
            
            <article>
                
<p>Consider an example of a web server tasked with handling incoming HTTP requests in a setting of a web application that manages an online forum. Consider that the requests in question are to be responded to with the data about all of the forum posts present in the database. This means that in order to reply to any given HTTP request, we first need to obtain the required data from the database. The solution may look as follows:</p>
<pre class="mce-root">def handle(request: Request): Response = {<br/>  val posts: List[Post] = allPosts()<br/>  respond(posts)<br/>}</pre>
<p>In the preceding example, the types and methods are declared as follows:</p>
<pre>type Request<br/>type Response<br/>type Post<br/><br/>def allPosts(): List[Post]<br/><br/>def respond[A](a: A): Response</pre>
<p>However, this is not the only task that our application needs to do. Consider also that our forum is private, which means we need to authenticate a user prior to giving them access to the forum.</p>
<p>Nowadays, a popular way to authenticate is to use a cloud solution for authentication. This means that people do not implement the authentication mechanism themselves on the server side, but outsource it to some  provider. Such a mechanism is known as <strong>Authentication as a Service</strong> (<strong>AaaS</strong>). A number of companies provide out-of-the-box services that you can use in your application to authenticate. There are many benefits to the approach since you do not need to waste your time implementing authentication logic, and it can include not only password authentication, but also social authentications and fancy security mechanisms such as two-factor authentication.</p>
<p class="mce-root"/>
<p>However, if we are using a cloud-based solution for our authentication, this means that we most likely need to contact the cloud every time a user tries to log in. Modern authentication methods, such as JWT, imply a stateless authentication. It is possible to produce a JSON tag that the user can pass to a server, and the server can verify its authenticity using a cryptography mechanism. So you do not need to keep a state to authenticate a person. However, even in this scenario, you are most likely going to need to contact your cloud-based authentication platform to obtain keys that you are using as well as to verify that the user is indeed present in their databases.</p>
<p>How is all of the this relevant to our functional programming example? The thing to notice here is that we need to contact the web. The operation of contacting the cloud is a long-running one. For the time being, let's assume this operation is done in a synchronous manner, as follows:</p>
<pre>def handle(request: Request): Response = {<br/>  val userToken: Token = request.token<br/>  val authenticated: Boolean = authenticate(userToken)<br/><br/>  if (authenticated) {<br/>    val posts: List[Post] = allPosts()<br/>    respond(posts)<br/>  }<br/>  else respond("You are not authorized to perform this action")<br/>}</pre>
<p>The following declarations were added to our environment:</p>
<pre>type Token<br/>type Request &lt;: { def token: Token }<br/><br/>def authenticate(token: Token): Boolean</pre>
<p>In the preceding code snippet, we ask the cloud-based authentication service whether the user is authorized to perform the action, and if they are, we reply with the forum post.</p>
<p>Imagine the preceding server under a high load. Immediately, questions arise about the number of threads that can be used in handling the <kbd>HTTP</kbd> request. Also, a question arises about how fast a web server can handle any given request. Imagine we have four threads on the task. Imagine also that it takes roughly one second to handle a given request as there is latency involved in contacting the database and the cloud-based authentication service. How much of a load can a server tolerate?</p>
<p class="mce-root"/>
<p>If the load is more than four requests per second, the server will start running out of threads. Imagine the server handles four requests simultaneously. This means that all of its four threads that are allocated for handling HTTP requests will be busy for one second. Consequently, the server will not be able to handle further requests until it handles those four requests. This means that if, for example, five requests arrive at the same time, the first four of them will be handled in one second, and the fifth one will take two seconds to handle. This is because it will not be started until the first four requests are handled.</p>
<p>The threads that handle this request do not really do anything the majority of the time. During the first call to the cloud authentication solution, the majority of the handling time is waiting to receive a reply from the server. And when it subsequently calls a database, that majority of the time it waits for the database to reply. If the thread spends the majority of its time waiting for the replies, this means that the processor does not do anything useful, that it has some free power and free capacity to work on some other tasks, such as maybe handling the other incoming requests.</p>
<p>This reasoning is precisely why the synchronous way of handling is not desirable in applications that are designed for high loads. An alternative is an asynchronous approach. In the asynchronous approach, whenever you have a long-running computation, you dispatch it to a thread pool using an asynchronous primitive, for example, a <kbd>Future</kbd>. And then, you specify what to do once the task is completed. The trick in an asynchronous application is to build it from asynchronous primitives that do not block. So, for example, the act of requesting information from the database should not involve blocking or waiting for a response, even on a thread within a future. The point is that the thread that makes a request is free to do other tasks once the request is made and it has nothing else to do.</p>
<p>The point is to utilize a non-blocking API to perform HTTP requests and requests to the database so that your threads, which are quite heavyweight primitives in the Java world, do not block and do not wait for responses and are not wasted, rather, they should do something useful.</p>
<p>An application handler in an asynchronous style would look as follows:</p>
<pre>def allPosts(): Future[List[Post]]<br/><br/>def authenticate(token: Token): Future[Boolean]<br/><br/>def handle(request: Request): Future[Response] =<br/>  for {<br/>    authenticated &lt;- authenticate(request.token)<br/>    response &lt;- </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre>      if (authenticated) allPosts.map(respond)<br/>      else Future { respond("You are not authorized to perform this<br/>      action") }<br/>  } yield response</pre>
<p>It still takes about one second for a single request to get handled, because the delay that you experience once requesting external resources still exists. However, now the server will perform much better under high loads. This is because the threads themselves do not wait this entire one second on a single request. Instead, for them, the only time that counts is the time when they actually do the job, and not the time they wait on the external resource to reply to them.</p>
<p>So, for example, if the real processing time of a given request, meaning the time the thread is actually doing the work and not waiting for a reply, constitutes 10 milliseconds, then a single thread is capable of accepting and handling 100 requests per second.</p>
<p>The preceding discussion describes why you might need the side effect of asynchrony and programming with callbacks in practice. And asynchrony is a side effect that you might want to hide behind some primitives, such as a future.</p>
<p>However, asynchrony is not the only side effect that you might want to abstract away in the case of writing an HTTP handler. Another side effect that you might want to abstract is the side effect of an error. Now, let's discuss this side effect in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The side effect of errors</h1>
                </header>
            
            <article>
                
<p>In the preceding example, we saw that thing do not always go smoothly. Things can go wrong on multiple levels. So when we connect to the cloud authentication service, the connection itself may go wrong. For example, the server reply times out. Or, your application credentials are wrong and you do not end up accessing the feature of the cloud authentication service that you would like to access.</p>
<p>When contacting the database, things can also go wrong. For example, you may fail to establish a connection with the database. Or, for some reason, the data is not present in the database or is not in the correct format.</p>
<p>Finally, the business logic of the application allows for an error. This one happens when the person making the request to the server is not authorized to view the data they request. In such a situation, we will need to reply with an error message instead of the data they requested:</p>
<pre>if (authenticated) allPosts.map(respond)<br/>else Future { respond("You are not authorized to perform this action") }</pre>
<p>All of the cases discussed here are a clear evidence that we have a side effect of an error here as a potential. Normally, we would abstract away this side effect into an effect type. Then, we'd use the <kbd>flatMap</kbd> function in order to combine these computations. However, we already have one effect type, <kbd>Future</kbd>, that abstracts away the asynchronous nature of request-handling. How do we introduce another side effect here?</p>
<p>First of all, a note should be made that <kbd>Future</kbd> itself provides a capability for error reporting. However, this is a detail specific to the Future's implementation. It is perfectly possible to imagine asynchronous primitives that provide you with the abstraction of asynchrony but do not catch the errors that happen inside them. So here, we will be viewing the situation as if the Future does not provide the capability of error-handling.</p>
<p>A naive way to handle that scenario would be to make the computation return a <kbd>Future</kbd> of an <kbd>Either</kbd> of a result. So, for example, the query to the database and the cloud service would look as follows:</p>
<pre>def allPosts(): Future[Either[String, List[Post]]]<br/><br/>def authenticate(token: Token): Future[Either[String, Boolean]]</pre>
<p>In the preceding code, we stack the side effects one on top of another. Will that work in practice? In principle, it is possible to imagine a computation that returns an <kbd>Either</kbd> under a <kbd>Future</kbd>. Let's have a look at how we will be using it in combination with other complications. Previously, we used the <kbd>flatMap</kbd> function to combine the computations sequentially. How would such a combination look in the case of nested side effects?</p>
<pre>for {<br/>  authenticated &lt;- authenticate(request.token)<br/>  response &lt;- <br/>    if (authenticated) allPosts.map(respond)<br/>    else Future { Left("You are not authorized to perform this action") }<br/>} yield response</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The preceding code does not compile. The error is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/304daf7c-6009-442c-b238-bb47c4118f40.png"/></p>
<p>As you can see, the compiler says that we are using <kbd>Either</kbd> in position where <kbd>Boolean</kbd> is expected. So <kbd>authenticated</kbd> variable in the snippet above is <kbd>Either</kbd>  instead of <kbd>Boolean</kbd>. However, why would we be working on <kbd>Either</kbd> under the Monadic flow? Is that not a purpose of Monadic flow to abstract away the effect types so that we are able to deal with the computed values directly without having to worry about the effect types?</p>
<p>Actually, we can rewrite the preceding example in terms of <kbd>flatMap</kbd> for better readability:</p>
<pre>authenticate(request.token).flatMap { authenticated =&gt;<br/>  if (authenticated) allPosts.map(respond)<br/>  else Future { Left("You are not authorized to perform this action") }<br/>}</pre>
<p>Let's now check the signatures and types of all the values involved. First, let's check the type that we are calling <kbd>flatMap</kbd> on, <kbd>Future[Either[/*...*/]]</kbd>. After, we are working with the result as if it were the user object retrieved from the cloud authentication service. However, let's take another look at the signature of <kbd>flatMap</kbd> as defined by <kbd>Future</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8811b158-4d18-4dc4-b28e-0a3b6524fb6c.png" style="width:44.75em;height:31.08em;"/></p>
<p>So the function already has a familiar signature: <kbd>A =&gt; Future[B]</kbd>. What is <kbd>A</kbd>? It is the type parameter of <kbd>Future</kbd>. What is the type parameter of our particular <kbd>Future</kbd>? This type parameter is <kbd>Either[String, User]</kbd>.</p>
<p>That means that <kbd>flatMap</kbd> does not give us the user object, but <kbd>Either</kbd>. Using this information, we can alter the example:</p>
<pre>def handle(request: Request): Future[Either[String, Response]] =<br/>  authenticate(request.token).flatMap {<br/>    case Right(authenticated) if authenticated =&gt;<br/>      allPosts.map { eitherPosts =&gt;<br/>        eitherPosts.map(respond)<br/>      }<br/><br/>    case Right(authenticated) if !authenticated =&gt;<br/>      Future { Left("You are not authorized to perform this action") }<br/><br/>    case Left(error) =&gt; Future(Left(error))<br/>  }</pre>
<p>Here, we manually extract the result value from <kbd>Either</kbd>. Immediately, we can say that something is very wrong and needs to be corrected. The feeling of something wrong arises because previously we have discussed that the very point of having Monadic flows and the <kbd>flatMap</kbd> function is to abstract away effect types. Yet here, we need to work with them explicitly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monad Transformers</h1>
                </header>
            
            <article>
                
<p>The problem here is that the <kbd>flatMap</kbd> function is defined on the Future. It knows nothing about the type parameter of Future. This can be anything you can imagine. Implementation does not place any constraints on the type parameter. It also means that it knows nothing about this type signature and its properties. Hence, neither the Monad nor the Future default implementation of <kbd>flatMap</kbd> for Future is aware of the possibility that the type parameter to Future will be another effect type. So, when you stack our effect types in the manner discussed earlier, only the topmost effect type gets abstracted when we are using the <kbd>flatMap</kbd> function.</p>
<p>This behavior is unnatural. We didn't get what we expected. What did we expect to get? We expected that not only would the side effect be unwrapped, but its inner side effect would also be unwrapped.</p>
<p>When we have nested effect types, and when we expect them to be treated as one effect, we need Monad Transformers.</p>
<p>Monad Transformers is actually a pattern that can be used to define stackable versions of already-existing effect types. For example, let's have a look at how such a Monad Transformer is defined for the <kbd>Either</kbd> type in the <kbd>cats</kbd> library:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dc4d33d9-d278-4e58-9eea-5715e0042fb0.png"/></p>
<p class="mce-root"/>
<p>Let's have a look at the signature of this Monad Transformer to understand what it is. First of all, notice the type parameters of this case class. Instead of the usual two type parameters of an ordinary <kbd>Either</kbd>, we have three type parameters. The first parameter is an <kbd>F[_]</kbd> effect type, and the last two parameters are ordinary left and right types. That effect type is precisely what gives this Monad Transformer its stackability. So, we can stack it with other effect types by pumping these effect types into the type variable. Notice also the argument to the constructor of <kbd>EitherT</kbd>. The argument in question has the <kbd>F[Either[A, B]]</kbd> type.</p>
<p>Let's imagine that the variable effect type in the preceding example is <kbd>Future</kbd>. Then, the value of <kbd>EitherT</kbd> will be <kbd>Future[Either[A, B]]</kbd>. This is precisely the signature that we had in our preceding examples when we were trying to stack these two effects types.</p>
<p>So the pattern essentially builds up on top of the naive stacking of effect types. However, here we have a case class defined specifically for stacking. How does it work, and how does it allow us to combine effect types?</p>
<p>First of all, let's have a look at how the <kbd>flatMap</kbd> function is defined by this data type:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/131e54f2-1857-4d05-891d-f87760099a3b.png"/></p>
<p>As we can see in the preceding screenshot, the method takes the continuation function as an argument, which is something we already know. However, pay attention to the first argument of the continuation function. It is <kbd>B</kbd> here. <kbd>B</kbd> is the type of the <kbd>Right</kbd> value of <kbd>Either</kbd>. <kbd>Either</kbd> is wrapped under the <kbd>F</kbd> type. So, if we are going to use <kbd>EitherT</kbd> instead of a naive combination of <kbd>Future</kbd> and <kbd>Either</kbd>, we are going to end up with a <kbd>flatMap</kbd> function that does exactly what we are looking for.</p>
<p>However, also notice that this function implicitly depends on a Monad for the side effect type. Which means that in order to extract the result from <kbd>EitherT</kbd>, we need to know how to extract the result from the effect type you are combining it with:</p>
<pre>def flatMap[AA &gt;: A, D](f: B =&gt; EitherT[F, AA, D])(implicit F: Monad[F]): EitherT[F, AA, D] =<br/>  EitherT(F.flatMap(value) {<br/>    case l @ Left(_) =&gt; F.pure(l.rightCast)<br/>    case Right(b) =&gt; f(b).value<br/>  })<br/><br/></pre>
<p class="mce-root"/>
<p>So, arming ourselves with <kbd>EitherT</kbd>, let's rewrite the previous example:</p>
<pre>def handle(request: Request): EitherT[Future, String, Response] =<br/>  for {<br/>    authenticated &lt;- authenticate(request.token)<br/>      .ensure("You are not authorized to perform this action")(identity)<br/>    posts &lt;- allPosts()<br/>    response = respond(posts)<br/>  } yield response</pre>
<p>As you can see, we now have all of our computations defined in terms of the combined effects types. Also, we are able to leave our Monadic flow unchanged, meaning that we do not need to worry about extracting the results of our side effecting computations manually.</p>
<p>If you have a look at the <kbd>EitherT</kbd> documentation, you will see that it also provides you with a bunch of other convenience methods that you can use in the setting of nested effect types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generalizing the pattern</h1>
                </header>
            
            <article>
                
<p>Obviously, the pattern we discussed previously is not specific to <kbd>EitherT</kbd>. It is something we are frequently going to encounter when dealing with effect types. It is not about <kbd>Future</kbd> and <kbd>Either</kbd>, but about combining two independent types.</p>
<p>Since this task repeats from effect type to effect type, it was generalized into a pattern. The pattern goes as follows. First, you pick up an effect type that you would like to be combinable with other arbitrary effect types. Then, you define the alternative combinable version of this type. This way, for <kbd>Either</kbd>, we have defined a combinable version of it, <kbd>EitherT</kbd>.</p>
<p>After that, you define all of the necessary type classes of the given effect type, optionally depending on whatever you need to make it work, including the type classes for the effect type you are going to combine this effect with.</p>
<p>If you have a look at the data package of the cats library, you will find that it has a number of other effects ending with the letter <kbd>T</kbd>. These are implementations of Monad Transformers for the respective effect types.</p>
<p class="mce-root"/>
<p>The significance of having Monad Transformers in your toolbox is that now you are able to construct effect types from existing effect types like you would from Lego blocks. This greatly increases your flexibility; now you do not need to define dedicated effect types that would express the side effects you would like to capture. If these side effects are expressible as a combination of several other side effects, you can use Transformers to create a combined effect type and use it in your applications.</p>
<p>We were observing the combination of two effect types. But, you are not limited to the combination of only two effects. In fact, the pattern is sufficient to combine any number of effect types into one. For example, this is how such a combination might look:</p>
<pre>type Config<br/>type Ef[A] = ReaderT[EitherT[Future, String, ?], Config, A]</pre>
<p>Since <kbd>ReaderT</kbd> expects an effect type, <kbd>F[_]</kbd>, as its first argument, we manually make a <strong>hole</strong> in <kbd>EitherT</kbd> by the means of the question mark—<kbd>EitherT[Future, String, ?]</kbd>. The syntax is not standard to Scala and comes from the Kind Projector plugin that is imported in the project's <kbd>build.sbt</kbd>:</p>
<pre>addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.4")</pre>
<p>The <kbd>?</kbd> in the type signature creates an unbound type variable in a type signature, which can be used to give the type the shape of <kbd>F[_]</kbd>.</p>
<p><kbd>ReaderT[EitherT[Future, String, ?], Config, A]</kbd> is a Transformer way to express the following type:</p>
<pre>Config =&gt; Future[Either[String, A]]</pre>
<p>So, when talking about the Monad Transformers pattern, first and foremost we are talking about flexibility. However, this is not the only pattern that can provide you with extra flexibility when writing your programs in a purely functional manner. Next, we will have a look at the Tagless Final.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tagless Final</h1>
                </header>
            
            <article>
                
<p>Tagless Final is a popular pattern of advanced functional programming that can be used to abstract away capabilities and side effects you do not know ahead of time and cannot predict. As usual, the best way to see how it works and why it is useful is to look at some examples.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Programming to capabilities</h1>
                </header>
            
            <article>
                
<p>Imagine you are writing an application that is to be executed against more than one environment. Such scenarios are common in the real world. A good example is mobile applications. You can have multiple mobile platforms. However, you would like to publish your applications to all of them. The platforms that exist are quite different from each another. And usually, it is pretty tedious to reimplement your application for every platform separately. So, you would like to write our application once, and somehow make it run against all of the platforms that currently exist.</p>
<p>Another example is programming server-side software that should work against a wide variety of configurations. For example, the same server-side software is executed against different databases. Relational databases are different, and procedures that are applicable to one database may not be applicable to another database.</p>
<p>In all of the preceding scenarios, you wanted your application's business logic not to be affected by the peculiarities of the system you are running your code on. In object-oriented programming, a standard way to tackle such an issue is to apply a Facade pattern. You declare an interface that lists all of the capabilities that you need from the underlying system your application is supposed to be run against. After that, for every specific system, you are going to provide an implementation of the interface.</p>
<p>The key points to notice from this discussion are the capabilities. Your application depends on some capabilities. It is built in terms of the methods exposed by the interface that specifies the capabilities in question. This idea also reiterates in the Tagless Final pattern.</p>
<p>To make it easier to understand the pattern, let's come up with a simple example of an application depending on some capabilities. The first one would be to read a resource from the data storage of a system. A resource is a wide notion that may include files on one filesystem, access to data over the network on other environments, or access to data that is stored in a database and other environments. Another capability will be the notification capability, which means the application is able to notify the end user of whatever job it is doing with the data retrieved from the storage.</p>
<p>Given these two capabilities, it is possible to write a wide range of processing applications. Once we have abstracted away the effects of reading and notifying, we can build a processing application in terms of these effects.</p>
<p>How would we define such capabilities in a functional manner? What would make the most sense? Previously, we discussed the idea of a type class. We have also noted that a type class is very similar to a toolbox, which means it provides you with a set of tools that you can use for a certain purpose. That analogy is ideal for our case of storing capabilities. Capabilities are also, in a sense, tools, and tools can be united into toolboxes. So, it is conceivable to define a type class with the capabilities we need as follows:</p>
<pre>trait Capabilities[F[_]] {<br/>  def resource[A](name: String): F[A]<br/>  def notify(target: String, text: String): F[Unit]<br/>}</pre>
<p>Notice that we define the type class for an <kbd>f</kbd> effect type. Since we are working in the functional paradigm, and the capabilities are likely to produce side effects, we are going to describe these side effects by some effect type that we may not know ahead of time.</p>
<p>Next, we can define an application in terms of these capabilities provided by the type class. Imagine the resources that we are going to retrieve with the help of our capabilities are reports of the sales of some online shopping:</p>
<pre>Name,Price<br/>Bread,2<br/>Butter,4<br/>Cabbage,3<br/>Water,2</pre>
<p>Consider that this document is updated every day, and the objective of our application is to calculate the amount of money the business has made over the day and to notify the owner about the income. We can implement it as follows:</p>
<pre>def income[F[_]](implicit M: Monad[F], C: Capabilities[F]): F[Unit] =<br/>  for {<br/>    contents &lt;- C.resource("sales.csv")<br/>    total = contents<br/>      .split("\n").toList.tail // Collection of lines, drop the CSV header<br/>      .map { _.split(",").toList match // List[Double] - prices of each<br/>       of the entries<br/>        { case name :: price :: Nil =&gt; price.toDouble }<br/>      }<br/>      .sum<br/>    _ &lt;- C.notify("admin@shop.com", s"Total income made today: $total")<br/>  } yield ()</pre>
<p>Notice how the preceding method is defined in terms of the <kbd>F</kbd> effect type and its subclasses. Notice how we do not know ahead of time which effect type we are going to use here. However, we know exactly which capabilities this effect type must have<span>—</span>the capabilities that we defined earlier, but we also need a Monad. This is because we need to sequentially combine capabilities defined in our custom type class. Then, we define our application in terms of our capabilities.</p>
<p>An important thing to notice here is how our capabilities become defined in the same language as the other type classes. This means that, potentially, we have the entire power of the <kbd>cats</kbd> library or any other libraries for functional programming.</p>
<p>This is what makes the Tagless Final pattern different from the Facade pattern. In Facade, you have the interfaces that hide the complex functionality that is platform-specific and that you do not care about. However, this is it. Whenever we call such a capability, we get the result you are requesting and nothing else.</p>
<p>In the Tagless Final pattern, whenever you are calling a capability method, you are getting a result under an effect type. An effect type is a data structure that has certain properties. You may not have control over exactly what result the capability returns because it is system-specific. However, you have control over the data structure in which this result is returned. The data structure in question is specified by the type parameter. Different data structures have different capabilities. In other functions, when we specified that we implicitly needed a Monad, we stated something about the structure we are going to work under. We can state that our effect type is to be sequentially composable. In the same way, by specifying implicit dependencies on other cats type classes, we can state other requirements of our data structure.</p>
<p>This control over the data structure we are working under gives us control over how we can compose our computation. So, in the Facade pattern, only the platform-specific capabilities themselves get abstracted away, and that's it. However, in the Tagless Final pattern, not only do the computations get abstracted away, but the way we compose our program gets abstracted away under the <kbd>f</kbd> effect type.</p>
<p>Now, once we have the abstract program composed, a reasonable question to ask would be how do we actually run it against different environments?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementations</h1>
                </header>
            
            <article>
                
<p>In order to run this application against a given environment, we need to specify the effect type we are going to be working under. Besides the target effect type, we need to find the implementation for all of the implicit dependencies that our function requires. The beauty of the Tagless Final pattern is that we can run the function against any environment, as long as we can provide the implementation of our implicit dependencies for this environment and for the effect type of our choice.</p>
<p>The first step is to specify the effect type. A good choice would be Future, since it is a concurrency primitive, and capable of representing a wide range of computations. So, with the effect type set to Future, we will have our method called as follows:</p>
<pre>import scala.concurrent.{ Future, Await }<br/>import scala.concurrent.ExecutionContext.Implicits.global<br/>import scala.concurrent.duration.Duration<br/><br/>import cats._, cats.implicits._<br/><br/>/*...*/<br/>Await.result(income[Future], Duration.Inf) // Block so that the application does not exit prematurely</pre>
<p>However, the preceding code will not compile since we do not yet have an implementation of the  <kbd>Capabilities</kbd> type class for Future.</p>
<p>Now when we are talking about the capabilities we need, we need to ask ourselves against which environment we are working in. Remember that the capabilities abstract the operations that are different from environment to environment. First, let's imagine we are working against an ordinary desktop environment and a command-line application scenario. In this case, our retrieve resource capability would be simply reading a file with a given name from a standard directory. Our notification capability will print the output to the command line:</p>
<pre>implicit val capabilities: Capabilities[Future] = new Capabilities[Future] {<br/>  import java.io.File<br/>  import org.apache.commons.io.FileUtils<br/><br/>  def resource(name: String): Future[String] =<br/>    Future { FileUtils.readFileToString(new File(name)) }<br/><br/>  def notify(target: String, text: String): Future[Unit] =<br/>    Future { println(s"Notifying $target: $text") }<br/>}</pre>
<p>We are using an Apache Commons IO library to read a file, conveniently. We are doing everything under the concurrency primitive future because this is the requirement of our application. Notice how all the technical details of notifying and reading the file are concentrated in that type class only, to the point where we can import the <kbd>File</kbd> and <kbd>FileUtils</kbd> classes only in the scope of this type class and not the scope of the entire file.</p>
<p>Once we run the preceding application against the given file, we are going to receive the following output:</p>
<pre><strong>Notifying admin@shop.com: Total income made today: 11.0</strong></pre>
<p>What if we now need to run the application against an environment that uses a database to store the data? What if that notification is done via email and not via the command line? No problem, we still can use the same application. However, we will need to provide a custom implementation of the capabilities for this environment:</p>
<pre>implicit val anotherEnvironmentCapabilities: Capabilities[Future] = new Capabilities[Future] {<br/>  def resource(name: String): Future[String] = ???<br/>  def notify(target: String, text: String): Future[Unit] = ???<br/>}</pre>
<p>In the preceding code, we have implemented a type class in terms of stubs, because implementing the database query logic and an email notification logic can be pretty tedious. However, our application now compiles. So, if you substitute the implementation of the database query and email dispatch in the preceding type class, you will also be able to run the application successfully. Since this implementation is outside the scope of this book and does not bring any value to the discussion of the Tagless Final pattern, we will not provide the implementation here.</p>
<p>In a similar manner, we are able to provide the implementation for almost any platform that you can imagine.</p>
<p>You can also do the preceding really well with the Facade pattern. So how is Tagless Final more powerful than the Facade pattern? Why would you use it instead of the object-oriented pattern? The crucial detail in discussing the power of the Tagless Final pattern is to notice that our application depends not only on the capabilities type class but also on the Monad type class. So how does that bring more power than a Facade pattern? Let's have a look at it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Execution semantics abstraction</h1>
                </header>
            
            <article>
                
<p>The capabilities type class is on equal ground with the <kbd>Monad</kbd> type class. The <kbd>Monad</kbd> type class defines how you would compose the computation sequentially. There is a saying that Monad is the semicolon of functional programming. Why would people say that? What is the role of a semicolon in object-oriented programming? In ordinary imperative programming, a semicolon is a symbol that separates one statement from another. The meaning of a semicolon is that one statement should be executed after another statement. In a sense, you can treat a semicolon as an operator of the sequential combination of two computation.</p>
<p class="mce-root"/>
<p>The <kbd>flatMap</kbd> function does exactly that for the functional programming world. <kbd>flatMap</kbd> defines how to sequentially composed two computations. So, this makes it a semicolon of functional programming. Also, earlier in the book, we looked at the Monadic flow pattern. We know that Monadic flow relies on <kbd>flatMap</kbd> under the hood to represent the functional code that is composed sequentially. In this way, it is very similar to the imperative semicolons.</p>
<p>How is that important for our discussion of the advantage of the Tagless Final pattern? The point is that an application that depends on Facade does not usually depend on any anything similar to a Monad.</p>
<p>This means that you may substitute a different Facade in your application for different environments. However, you will never be able to change the semantics of the sequential execution of your statements.</p>
<p>Let's see how it works on an example. Let's say that we need to perform logging while executing the preceding application. What do we do to make it possible? We can provide a custom implementation of Monad with its <kbd>flatMap</kbd> function, the sequential composition operator, been overloaded to log everything we need:</p>
<pre>implicit val logMonad: Monad[Future] = new Monad[Future] {<br/>  def flatMap[A, B](fa: Future[A])(f: (A) ⇒ Future[B]): Future[B] =<br/>    fa.flatMap { x =&gt;<br/>      println(s"Trace of the Future's result: $x")<br/>      f(x) }</pre>
<p>You can run the application by pointing the <kbd>income</kbd> method explicitly to which type classes to use:</p>
<pre>Await.result(income[Future](logMonad, capabilities), Duration.Inf) // Block so that the application does not exit prematurely</pre>
<p>And the output will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a0228057-b872-4f7f-bca7-a3e59eae04b8.png"/></p>
<p>Here, we are able to overload the very semantics of sequential composition.</p>
<p>Can a similar effect be achieved in the imperative world? Let's have a look at how the preceding example could be implemented with the Facade pattern:</p>
<pre>trait Capabilities {<br/>  def resource(name: String): String<br/>  def notify(target: String, text: String): Unit<br/>}<br/><br/>def income(c: Capabilities): Unit = {<br/>  val contents = c.resource("sales.csv")<br/>  val total = contents<br/>    .split("\n").toList.tail // Collection of lines, drop the CSV header<br/>    .map { _.split(",").toList match // List[Double] - prices of each of the entries<br/>      { case name :: price :: Nil =&gt; price.toDouble }<br/>    }<br/>    .sum<br/>  c.notify("admin@shop.com", s"Total income made today: $total")<br/>}</pre>
<p>In the preceding code, we have an interface, and the method <kbd>income</kbd> depends on the type class that performs the computation.</p>
<p>We are not able to override sequential composition, because the only point of control is the interface. We do not have control over how the computations are executed and combined with one another.</p>
<p>But why is that possible in the functional world and not in the imperative world? What makes the functional approach so special that we are able to do this kind of abstraction of combinational semantics?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computation as a value</h1>
                </header>
            
            <article>
                
<p>When discussing side effects and abstraction, we argued that functional programming aims for purity. And whenever we have some computation that has a side effect, we are reifying this computation into some value. Here, the value is <kbd>Future</kbd>. All our computations are reified into Future. And we are able to combine <kbd>Future</kbd> using the operators defined for it.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the imperative world, we are not able to perform the similar combination of computations, since the computations are not reified to values. We are not able to play around with computations in the imperative world because computations are not a thing there. There is no way for us to refer to a computation. At least no obvious way. Of course, in Java, we can stuff the computation under the Runnable interface. However, it will be quite cumbersome. In the functional world, Monads are ubiquitous in sequential composition. Everything is composed using <kbd>flatMap</kbd>. In Java, wrapping everything in Runnable would introduce too much architectural overhead, so it is not worth it.</p>
<p>However, one might argue that Futures are not pure. Whenever we instantiate Future, we give an instruction for a computation to start. Is there an even stronger version of the Tagless Final pattern that provides us with some more expressive power?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Free Monad</h1>
                </header>
            
            <article>
                
<p>The Free Monad <span> pattern</span> is a stronger version of the Tagless Final pattern. Actually, the free object is a structure from abstract algebra. Hence the name comes from this domain.</p>
<p>The application of the pattern is rather limited, and most likely we will not encounter any real necessity for the pattern while only starting purely functional programming. So we will not go in depth about the Free Monad here. However, we will describe in general how it works.</p>
<p>Basically, the idea behind the Free Monad is that all of our computations become a value. The idea is that whenever we define our application, it does not really execute itself, but constructs an abstract syntax tree that describes the application that we can run later. <span>And it is our responsibility to execute it afterward.</span></p>
<p>The pattern is quite heavyweight, so the preceding example offers only the gist of it. Another thing to notice is that whenever we need to apply the Free Monad pattern, we can still leverage the Tagless Final pattern. Here, we saw how defining a custom implementation for the Monad can be helpful to inject custom functionality, such as logging. The same idea can be used to construct a tree out of our application. Ordinarily, the meaning of the sequential composition is to run one statement after another. It is easy to imagine an implementation of the sequential composition where the statements are not executed one after another but are reified into tree nodes and get injected into a tree that represents your application. Remember that <kbd>flatMap</kbd> has full control over how it continues the computation. So it is perfectly normal to imagine a <kbd>flatMap</kbd> function that does not run statements but uses them to construct a tree.</p>
<p class="mce-root"/>
<p>Why might we want to use the Free Monad pattern? The idea here is to be able to run the computation against more than one interpreter. A concrete example comes from the <kbd>doobie</kbd> library for working with SQL. In Doobie, a SQL statement can be written as follows:</p>
<pre>sql"""select * from customers where id = $id""")</pre>
<p>Here, we are using string interpolation, a feature of Scala that allows us to generate objects from strings on compile-time.</p>
<p>After executing this statement, we will perform several calls on the object specifying what we want to do with the SQL statement, such as whether we want to query or update the database. For example, if we want to query the database, we can do the following:</p>
<pre>sql"""select * from customers where id = $id""")<br/>  .query[User].unique.transact(tr)</pre>
<p>One common task when working with SQL from programming languages is to provide as much safety as possible while calling the database. For example, we might want to answer the question of whether our query is formed correctly. We might want to have an entire test suite where we have all of our queries that we are using, and we test them to check whether they are formed correctly and whether their return types are the ones that we expect.</p>
<p>Internally, Doobie represents its SQL queries with free objects, which means that they are just data structures that specify the computation to be performed against a database. Since it is just a description of the computation and not the computation itself, we can either run it or do anything else with it. One of the things that we might want to do is to check whether it is correct against certain rules. This is done in Doobie. Here, we can either run our queries against an interpreter that will query the database, or that will check their correctness.</p>
<p>So basically, in such situation when we have a computation that we might want to run against different interpreters, or we might want to pass around and modify by other computational, we might want to use a Free Monad.</p>
<p>A word of caution should be said as the pattern is heavyweight, it should not be used without a good reason, or else the overhead in terms of architecture will be pretty high.</p>
<p class="mce-root"/>
<p>Speaking of the safety of your application, you can achieve a high grade of safety and stability if you perform as many computations as possible at compile-time. The very basics of programming to type classes is having a strong compiler with a strong type system that is capable of injecting proper type classes for you. Can such a strong compiler be harnessed to perform more than just injecting capabilities and type classes into your computations? Let's step into the world of type-level programming in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type-level programming</h1>
                </header>
            
            <article>
                
<p>The job of the compiler is to translate your program from one set of instructions into another. In high-level languages, you translate higher-level instructions that are easy to read and write for people to lower-level instructions that are easy for machines to execute.</p>
<p>Since the compiler needs to perform a conversion of one set of symbols into another set of symbols, it builds some internal model of the program that you are writing. In a sense, we can say that the compiler understands the program, for some definition of <strong>understands</strong>.</p>
<p>If the compiler builds an internal model or understands your program in some other way, we can also harness the power of compiler to make the compiler check for the correctness of the program. We can make the compiler impose and enforce certain styles or guarantees that your program must obey. We have already seen an example of <kbd>annotation.tailrec</kbd>. The job of the annotation was to instruct the compiler to check the annotated function to have certain guarantees about it. Concretely, the compiler checked the function to be tail-recursive.</p>
<p><span>To ensure correctness of your program, we may well use a strongly typed language, and encode</span> the guarantees and the semantics of your program in types. The types are known to the compilers, and hence, it can perform certain checks on these types. For example, it can make sure that you supplied an argument of the correct type to a function because it knows the input type of the function. So, in a strongly-typed language, no longer can you make the mistake of passing an argument of the wrong type to a function.</p>
<p>The advantage of having strong compilers that check the program for mistakes is that you are able to catch more errors at compile-time. In general, errors that are caught at compile-time are much easier to debug and fix. If an error happens at runtime, it means that it is not discovered right away. You may release your application to the end user, and for particularly tricky bugs, months and even years can pass before they are discovered. Once they are discovered, you need to investigate the erroneous behavior yourself throughout the codebase and try to reproduce it so that you can fix it.</p>
<p class="mce-root"/>
<p>Compile-time errors are manifested right away. When you compile the code, you see exactly how and where you went wrong. So there is an obvious advantage to making sure the compiler can catch as many errors as possible.</p>
<p>Can we push our compiler even further? Let's have a look at an example of the type-level programming in Scala. It is called type-level because we aim to encode as many guarantees about our program as possible in the types. This way, these guarantees are checked at compile-time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A naive implementation of the heterogeneous list</h1>
                </header>
            
            <article>
                
<p>Consider that we have the following list:</p>
<pre>val list: List[Any] = List(0, 2.0, "3", Fraction(4, 2))</pre>
<p>So, in the preceding list, we have elements of different types, and hence we are forced to declare this list as <kbd>List[Any]</kbd>. <kbd>Fraction</kbd> is defined for the purpose of our example as follows:</p>
<pre>case class Fraction(numerator: Int, denominator: Int)</pre>
<p>Notice that in the preceding list, each element can be represented as a floating-point number. They have different types, but it is possible to define certain common behavior on all of these types. Since the elements are very similar to each other, we might want to perform a common operation on them. For example, we may want to find the sum of all the numbers in the list:</p>
<pre>val sum = list.map {<br/>  case x: Int =&gt; x.toDouble<br/>  case x: Double =&gt; x<br/>  case x: String =&gt; x.toDouble<br/>  case Fraction(n, d) =&gt; n / d.toDouble<br/>}.sum</pre>
<p>Notice that we are not able to sum all elements right away because the type of the list is <kbd>List[Any]</kbd>. We can only add up a list composed of numbers. Hence, we map our list so that it becomes <kbd>List[Double]</kbd>. After that, we call the same method on this list, which is a standard method defined for all numeric collections defined by the Scala collections framework.</p>
<p><span>In the screenshot below, we can see the </span>output<span> of the program:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/01ddaf44-f7b8-42fb-b81a-8321149931b6.png"/></p>
<p>However, notice the body of the <kbd>map</kbd> method. The body of the <kbd>map</kbd> method is actually a partial function. A partial function is a function that is not guaranteed to be able to handle an entire domain on which it is defined. Let's look at the signature of the <kbd>map</kbd> function, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6dd64495-778e-488a-9d1a-24c83f9df650.png"/></p>
<p>In the preceding screenshot, you can see that it expects a function from the type of the elements of the list to some other type, <kbd>B</kbd>. The type of our elements is any. However, the function that we have passed to our function is a partial function, meaning that it is only capable of handling a subset of all possible object in Scala.</p>
<p>That problem with partial functions is that they are computed at runtime. This means, if you forget to specify a certain clause in the partial function, you will not find out about that until the runtime when the application will throw a match error signifying that the partial function was not able to handle its input. Let's simulate this situation:</p>
<pre>val sum = list.map {<br/>  case x: Int =&gt; x.toDouble<br/>  case x: Double =&gt; x<br/>  case x: String =&gt; x.toDouble<br/>  // case Fraction(n, d) =&gt; n / d.toDouble<br/>}.sum</pre>
<p>We have commented out one of the <kbd>case</kbd> clauses of our partial function that we used to map the list. What happens if we run this application? See the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c3d10b5a-4c72-42c1-9299-09e167e6b7f5.png"/></p>
<p>As you can see, an exception was thrown. The program was compiled successfully, however, when we tried to run it, we had an exception. This means something went wrong at runtime. Is there a way to make the compiler track these kinds of errors, and handle them at compile-time?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type-level solution to the heterogeneous list problem</h1>
                </header>
            
            <article>
                
<p>The strategy for solving this problem is to encode the guarantees that we want to have in types. We will leverage the highly-developed mechanism of implicit resolution to enforce that guarantee on a certain type. The general idea is to have a guarantee presented by an implicit value. And if we need a certain guarantee about our program, we make our program implicitly depend on the value that represents this guarantee.</p>
<p>The catch is that the application will not compile if the compiler does not find any of the implicits the program depends on. So, by making the program depend on the implicits that represent our guarantees, and making sure these values are present in scope only if the guarantee is satisfied, we can make sure is that the compiler will not compile a program that does not satisfy this guarantees.</p>
<p>However, first of all, we need types. The preceding solution of a <kbd>List[Any]</kbd> is not good for our application because the compiler does not have the information about the precise types of the elements of the list. Instead, we can define a data structure called a heterogeneous list. The code for this new list is as follows:</p>
<pre>package jvm<br/>/*...*/<br/>sealed trait HList {<br/>  def :::[H](h: H): H ::: this.type = jvm.:::(h, this)<br/>}<br/>case class :::[+H, +T &lt;: HList](head: H, tail: T) extends HList {<br/>  override def toString() = s"$head ::: $tail"<br/>}<br/>trait HNil extends HList<br/>case object HNil extends HNil<br/><br/></pre>
<p>Above, <kbd>jvm</kbd> is a package under which the JVM examples of this book are implemented.</p>
<p>A heterogeneous list is a recursive data structure. If you have a look at the <kbd>:::</kbd> value, this <kbd>case</kbd> class is composed of a head and a tail. The head can be anything you like, and the tail must be another instance of the heterogeneous list. The terminal case of the recursive data type is <kbd>HNil</kbd>.</p>
<p class="mce-root"/>
<p>Here is how we can define such a list in your application:</p>
<pre>val hlist: String ::: Int ::: Fraction ::: HNil =<br/>  "1" ::: 2 ::: Fraction(3, 4) ::: HNil</pre>
<p>Notice how this list is aware of the types of each of its arguments. Also, notice how in Scala, we can leverage the infix notation that allows us to use names of types as operators. Take a look at the following type:</p>
<pre>String ::: Int ::: Fraction ::: HNil</pre>
<p>It is equivalent to the following standard notation:</p>
<pre>:::[String, :::[Int, :::[Fraction, HNil]]]</pre>
<p>This is syntactic sugar to facilitate so-called algebraic data types. Algebraic data types are data types that are composed of other data types in a type-safe manner.</p>
<p>Next, how would we define an application that will compute a sum on a heterogeneous list? Previously, in a partial function example, we saw that another problem was compile-time safety. And here, we would like to include certain guarantees into our code. We want the compiler to check these guarantees. What guarantees would you like to impose? First of all, we need to make sure that our list can be mapped to a list where everything is a double. Previously, we did it using a partial function that is only run on the runtime. Here, we have agreed to use implicit to specify the guarantees about our application. Hence, we can have our summation method as follows:</p>
<pre>def sumSimple[L &lt;: HList](hlist: L)(implicit m: MapToDouble[L]): Double</pre>
<p><kbd>MapToDouble</kbd> is a type class that we have just come up with. The job of the type class is to convert a heterogeneous list so that all of its elements are doubles. Notice that we pass a type parameter to this type class. It is the <kbd>L</kbd> type, which extends the heterogeneous list. <kbd>L</kbd> extends the heterogeneous list and is an algebraic data type, which means it is a composite data type that is composed of the types of all of the elements of this list. This means that at compile-time, the type class will be aware of the types of all the elements present in this heterogeneous list, which means it is possible to define the type class so that we will not be able to resolve it if the members of the list are not convertible to double.</p>
<p>Are those all the guarantees we need? In principle, once we have a guarantee and a way to convert our heterogeneous list to a list of doubles, it may not be difficult to traverse the data structure recursively and sum up all of its values. So, the summation method using the <kbd>MapToDouble</kbd> type class only can be implemented as follows:</p>
<pre>def sumSimple[L &lt;: HList](hlist: L)(implicit m: MapToDouble[L]): Double = {<br/>  val mapped: m.Result = m.map(hlist)<br/>  def loop(l: HList): Double = l match {<br/>    case :::(h: Double, t) =&gt; h + loop(t)<br/>    case HNil =&gt; 0<br/>  }<br/>  loop(mapped)<br/>}</pre>
<p>Notice that we again are using a partial function to abstract the values from the recursive data structure of the heterogeneous list. We terminate our or question once we reach <kbd>HNil</kbd>. However, we have argued previously that partial functions are bad because they can fail at runtime. Therefore, it can be instructive to see how we can avoid usage of a partial function here.</p>
<p>So, let's introduce a new type class responsible for computing a sum on a heterogeneous list. We can do so as follows:</p>
<pre>def sum[L &lt;: HList, LR &lt;: HList](hlist: L)(implicit m: MapToDouble.Aux[L, LR], s: Sum[LR]): Double =<br/>  s.sum(m.map(hlist))</pre>
<p>So, we make our mapping capability and summation capability outsourced to the type classes we have just discussed. However, what is <kbd>Aux</kbd> at the end of the <kbd>MapToDouble</kbd> type class all about? Also, what is that new <kbd>LR</kbd> type parameter added to the type of the sum function?</p>
<p>Basically,  <kbd>LR</kbd> is the type of this list mapped to by <kbd>MapToDouble</kbd>. So, for our list of the following type:</p>
<pre>String ::: Int ::: Fraction ::: HNil</pre>
<p>This type will be as follows:</p>
<pre>Double ::: Double ::: Double ::: HNil</pre>
<p>In the preceding code, you can see the auxiliary pattern. The entire point of it is that we do not know the <kbd>LR</kbd> type variable and rely on the Scala compiler to compute it. Compiler  computes the <kbd>LR</kbd> type is by means of implicitly resolving the <kbd>MapToDouble</kbd> type class. The big picture is that the Scala compiler is able to leverage the implicit mechanism to compute entire types and store the result in a type argument variable, and then, we can reuse it in the implicit resolution of other type classes. So, we are using this type computed by the auxiliary mechanism to resolve the <kbd>Sum</kbd> type class.</p>
<p>Why do we need to compute the <kbd>HList</kbd> type if we know ahead of time that all of its elements are doubles? We may know the type of the elements, but we still need the compiler's help to know how many doubles to stack into the resulting <kbd>HList</kbd>. Remember that <kbd>HList</kbd> stores the type of every element, so if we say that all of the elements are doubles, we still need to know the length of the list to construct it. Here, the compiler is able to help us with this task.</p>
<p>So how exactly does the auxiliary pattern work and how exactly is the compiler capable of computing new types? To answer this question, let's proceed to the definition of our type classes. Let's start with the <kbd>MapToDouble</kbd> type class:</p>
<pre>trait MapToDouble[L &lt;: HList] {<br/>  type Result &lt;: HList<br/>  def map(l: L): Result<br/>}</pre>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Notice that the type class has two members. The first is the <kbd>Result</kbd> type, which represents the result type of mapping a given heterogeneous list so that all of its members are doubles. Then, we have the method that performs <kbd>map</kbd> in itself. Notice also that <kbd>MapToDouble</kbd> has only one type parameter, <kbd>L</kbd>.</p>
<p>The <kbd>Result</kbd> type is an abstract type, which means it is up to implementations of the type class to define it. We'll see in a moment how to leverage this ability to compute the result type.</p>
<p>The catch is that, technically, the result type is not reflected in the type of the type class. Which means, whenever we need this type class, for some <kbd>L</kbd> type, we can resolve it as follows:</p>
<pre>type L = String ::: Int ::: Fraction ::: HNil<br/>val mapper: MapToDouble[L] = implicitly[MapToDouble[L]]</pre>
<p>In the preceding code, the implicit method is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2a36e255-bccf-4b15-8c45-3361e27af4e8.png" style="width:20.92em;height:4.83em;"/></p>
<p>So basically, the method is a utility to resolve an implicit value of a certain type.</p>
<p>Notice that when we request the implicit dependency on this type class, we do not specify the result type, which means we are not required to know this type when we resolve their implicit dependency. Now, imagine that you had your type class defined as follows:</p>
<pre>trait MapToDoubleNoAux[L &lt;: HList, Result &lt;: HList] {<br/>  def map(l: L): Result<br/>}</pre>
<p>Now, with the preceding type class defined, we are no longer able to resolve it without knowing the result it is going to compute. Indeed, we have no other way to refer to this type class but as follows:</p>
<pre>type In = String ::: Int ::: Fraction ::: HNil<br/>type Out = Double ::: Double ::: Double ::: HNil<br/>val mapper: MapToDoubleNoAux[In, Out] = implicitly[MapToDoubleNoAux[In, Out]]</pre>
<p>Since the type class has two type arguments, we must to provide it with both of them. We might know the first type argument, however, because it is present in our program, in the type of our <kbd>HList</kbd>. The type of our heterogeneous list is constructed for us by the compiler when we construct the list itself. However, the result of the conversion of this list to a list of doubles is not currently known to the compiler. And we must provide it to resolve the implicit dependency. Hence, we are forced to compute it ourselves.</p>
<p>Is there a way to make the compiler compute that, similarly to how it computes the type of the list when you construct it? For this, we have the Aux pattern.</p>
<p>The auxiliary pattern looks as follows:</p>
<pre>object MapToDouble {<br/>  type Aux[L &lt;: HList, LR &lt;: HList] = MapToDouble[L] { type Result = LR }<br/>  /*...*/<br/>}</pre>
<p>So, it is nothing more than a type definition inside the companion object of our type class. Notice that here we are using structural types to define our auxiliary type. The preceding program says that the Aux type of is <kbd>MapToDouble</kbd>, whose body will contain a type member of <kbd>Result</kbd> set to a certain type variable.</p>
<p>The catch is that we still are able to capture both of the type variables that are significant to us, the input and output types, in a single <kbd>Aux</kbd> type. However, when we are trying to resolve the type class implicitly, we are no longer obliged to know both of the types.</p>
<p>And so, we can implicitly depend on the <kbd>Aux</kbd> type, and the compiler resolves this type without the knowledge of the second type parameter:</p>
<pre>def sum[L &lt;: HList, LR &lt;: HList](hlist: L)(<strong>implicit m: MapToDouble.Aux[L, LR]</strong>, s: Sum[LR]): Double</pre>
<p>Instead, the resolution will go as follows in this case:</p>
<ol>
<li>The compiler will infer the first type parameter, <kbd>L</kbd>. It will infer it by looking at the input argument. So, you do not need to provide it explicitly.</li>
<li>It will start the implicit resolution. First, we need <kbd>MapToDouble.Aux</kbd>. This type expands to the <kbd>MapToDouble[L] { type Result = LR }</kbd> type.</li>
<li>The compiler will interpret this as a command to resolve the <kbd>MapToDouble</kbd> type, whose first type argument must be <kbd>L</kbd>. The second type parameter of the <kbd>Aux</kbd> type is unknown, but it is not a problem, because, as we have discussed previously, the compiler does not need it to resolve the type class. However, this second type parameter has a name and is bound to a certain type, which is a member of the type class we are about to resolve. The compiler will, therefore, infer this second type parameter from the <kbd>Result</kbd> type of <kbd>MapToDouble</kbd>.</li>
<li>After this type class is resolved, we now have the <kbd>LR</kbd> type parameter. We can now use it as an input to the next implicit resolution<span>—</span>that of <kbd>Sum[LR]</kbd>.</li>
</ol>
<p>The reason the preceding logic works, and that the compiler does not need the second type parameter, <kbd>LR</kbd>, of <kbd>MapToDouble.Aux</kbd> is as follows. The type of the type <kbd>MapToDouble</kbd> does not include the second type parameter <kbd>LR</kbd>, and <kbd>MapToDouble.Aux</kbd> is an alias for <kbd>MapToDouble</kbd>. The type <kbd>L</kbd>, which is a type parameter to <kbd>MapToDouble</kbd>, is all that the compiler needs to resolve the type class. If you think about it, when resolving something implicitly, or specifying a type of some variable, you do not need to explicitly specify the members of this variable. Since the second type parameter is a member of an object to be resolved, we do not need to know it when resolving our type.</p>
<p>The Aux pattern is used to capture the types that are structural members of type classes into type arguments that can be referred to from the implicit group of a method signature.</p>
<p>So basically, it is all about having the types that we do not know on call-time as structural members of the type classes, not the type parameters of these type classes. This way, the types that we will not know ourselves and will need to be computed will not be members of the signature the type signature of the type class. And hence, we can resolve these type classes without knowing their member types. So, we can compute these types on implicit-resolution time, leveraging algebraic data types principle. We will see how exactly we can compute these types using the mechanism of implicit resolution in the following code snippet.</p>
<p>This is how the function that we have just defined can be applied to a heterogeneous list:</p>
<pre>val s = sum(hlist)<br/>println(s"Sum of $hlist is $s")</pre>
<p>The output of running the program is as follows:</p>
<pre><strong>Sum of 1 ::: 2 ::: Fraction(3,4) ::: HNil is 3.75</strong></pre>
<p>Next, let's have a look at how the implicit mechanism resolves all of the dependencies we need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reclusive implicit resolution</h1>
                </header>
            
            <article>
                
<p>Let's get a big picture understanding of what the members of the <kbd>MapToDouble</kbd> companion object look like:</p>
<pre class="mce-root">object MapToDouble {<br/>  type Aux[L &lt;: HList, LR &lt;: HList] = MapToDouble[L] { type Result = LR }<br/>  def apply[L &lt;: HList](implicit m: MapToDouble[L]) = m<br/><br/>  implicit def hcons[H, T &lt;: HList, TR &lt;: HList](implicit<br/>    td: ToDouble[H]<br/>  , md: MapToDouble.Aux[T, TR]<br/>  ): Aux[H ::: T, Double ::: TR]<br/><br/>  implicit def hnil[H &lt;: HNil]: MapToDouble.Aux[H, HNil]<br/>}</pre>
<p>So as you can see, we have an Aux type, and <kbd>apply</kbd> function definitions, which are common for the type class pattern. Also, we have two implicit members, which define implementations for the <kbd>MapToDouble</kbd> type class for <kbd>hlist</kbd>. Since there are two possible instances of <kbd>hlist</kbd>, we have two possible implementations of MapToDouble, both for <kbd> :::</kbd> and <kbd>HNil</kbd>.</p>
<p>Notice the implicit dependencies that these two implicit values have. First of all, <kbd>hnil</kbd> does not depend on anything. Let's have a look at its body:</p>
<pre>implicit def hnil[H &lt;: HNil]: MapToDouble.Aux[H, HNil] = new MapToDouble[H] {<br/><br/>  type Result = HNil<br/>  def map(h: H) = HNil<br/>}</pre>
<p>The result of mapping an empty heterogeneous list is just another empty heterogeneous list. This is because we do not have anything to map.</p>
<p><kbd>hcons</kbd>, however, has implicit dependencies. As you can see in the preceding example, it implicitly depends on two other type classes: <kbd>ToDouble</kbd> and <kbd>MapToDouble</kbd>. As you can see, <kbd>ToDouble</kbd> is parametrized by the <kbd>H</kbd> type. The <kbd>H</kbd> type is the head type of our heterogeneous list. Any heterogeneous list is defined in terms of its head type and its tail type only.</p>
<p>The meaning of all these implicit dependencies is that we are able to convert any heterogeneous list that is not empty to a list of doubles if we are able to convert its head to double, and if we are able to map its tail to a list of doubles. The definition of the <kbd>ToDouble</kbd> type class is as follows:</p>
<pre>trait ToDouble[T] {<br/>  def toDouble(t: T): Double<br/>}</pre>
<p>One critical thing to notice about these implicit dependencies is that they are recursive. <kbd>hcons</kbd> itself is of the <kbd>MapToDouble.Aux</kbd> type. But in order to generate this <kbd>MapToDouble</kbd>, we need to also have <kbd>MapToDouble</kbd> for the tail of the heterogeneous list in question.</p>
<p>Since the Scala compiler is capable of resolving implicit dependencies recursively, we are able to make an implicit dependency of one type depend recursively on the implicit dependency of the same type. The only thing to watch out for here, as with any other recursion, is for it to be able to terminate. This means, on every step of recursion, we must get closer, in some defined sense, to the terminal case of this recursion. That terminal case of recursion in our case is <kbd>HNil</kbd>. And with every step, we resolve the <kbd>MapToDouble</kbd> type class for a heterogeneous list that is one element shorter than the previous list because we take only the tail without the head. This guarantees that recursion will terminate.</p>
<p>Now, let's have a look at the implementation of <kbd>hcons</kbd>:</p>
<pre>implicit def hcons[H, T &lt;: HList, TR &lt;: HList](implicit<br/>  td: ToDouble[H]<br/>, md: MapToDouble.Aux[T, TR]<br/>): Aux[H ::: T, Double ::: TR] = new MapToDouble[H ::: T] {<br/><br/>  type Result = Double ::: TR<br/>  def map(l: H ::: T): Double ::: TR =<br/>    td.toDouble(l.head) ::: md.map(l.tail)<br/>}</pre>
<p>The body of the <kbd>map</kbd> function is defined in terms of the <kbd>ToDouble</kbd> type class that converts the head to double, and then uses the <kbd>MapToDouble</kbd> type class in order to convert the tail to double.</p>
<p>In a similar fashion, we can define the <kbd>Sum</kbd> type class that we will be using in order to compute the sum of the heterogeneous list with all doubles:</p>
<pre>trait Sum[L] {<br/>  def sum(l: L): Double<br/>}<br/><br/>object Sum {<br/>  def apply[L &lt;: HList](implicit s: Sum[L]) = s<br/><br/>  implicit def hcons[T &lt;: HList](implicit st: Sum[T]): Sum[Double ::: T] =<br/>    { (l: Double ::: T) =&gt; l.head + st.sum(l.tail) }<br/><br/>  implicit def hnil[H &lt;: HNil]: Sum[H] =<br/>    { (x: HNil) =&gt; 0 }<br/>}</pre>
<p>In the companion object, we also have two cases of recursive implicit resolution<span>—</span>one terminal and one non-terminal case. The terminal case is <kbd>hnil</kbd>, and the non-terminal case is <kbd>hcons</kbd>. The terminal case is simple because if we take an empty list, its sum is always <kbd>0</kbd> because there are no elements in this list. However, if we have a non-empty list, our ability to compute its sum depends on our ability to compute the sum of its tail. If we are able to compute the sum of its tail, as notified by its implicit dependency, we can compute the sum of the tail, and add the value of the head to it.</p>
<p>Finally, the last piece that we have not yet discussed is the implementation of the <kbd>ToDouble</kbd> type class:</p>
<pre>trait ToDouble[T] {<br/>  def toDouble(t: T): Double<br/>}<br/><br/>object ToDouble {<br/>  def apply[T](implicit t: ToDouble[T]) = t<br/><br/>  implicit def double: ToDouble[Double] = identity<br/>  implicit def int : ToDouble[Int ] = _.toDouble<br/>  implicit def string: ToDouble[String] = _.toDouble<br/><br/>  implicit def fraction: ToDouble[Fraction] =<br/>    f =&gt; f.numerator / f.denominator.toDouble<br/>}</pre>
<p>As we can see, the <kbd>ToDouble</kbd> type class is implemented for every type that we are going to use in practice.</p>
<p>What are the benefits of using the type class approach and the type-level computations instead of simply doing a recursive pattern-matching using a recursive function? The answer is compile-time safety. Remember how at the beginning of this chapter, we argued that in case of recursive pattern-matching when we forgot to perform a pattern match on a single instance, we only found out about our mistake on runtime? Let's have a look at what happens if we fail to specify one case in the situation of type-level computations.</p>
<p>The equivalent of pattern-matching for the type-level computation scenario are the <kbd>ToDouble</kbd> type class implementations. If you have a look at them, they specify how exactly to convert every type. Let's have a look at what happens if you comment out one of the implementations that we need:</p>
<pre>implicit def double: ToDouble[Double] = identity<br/>implicit def int : ToDouble[Int ] = _.toDouble<br/>implicit def string: ToDouble[String] = _.toDouble<br/><br/>// implicit def fraction: ToDouble[Fraction] =<br/>// f =&gt; f.numerator / f.denominator.toDouble</pre>
<p>Now let's have a look at what happens when we run the program:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a942029e-2622-44d5-b9ff-ca39f59d7548.png" style="width:44.67em;height:16.83em;"/></p>
<p>The error is a compile-time error this time, so the application did not even compile. However, notice also that the error message is rather cryptic and hard to read. Next, we will have a look at how you can debug this kind of compile-time message. Type-level computations give rise to an entirely new style of programming in advanced languages such as Scala, so it is imperative that you know how to work with the compile-time errors in this setting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging type-level computations</h1>
                </header>
            
            <article>
                
<p>Currently, type-level computations represent the leading edge of modern programming technology. The technology is rather experimental, and hence, it still does not have much support in terms of comprehensive error messages and tools for debugging.</p>
<p>So, the preceding error message can be debugged step by step by leveraging algebraic data types. This means that you trace every step of recursion, and make sure that every implicit during every step is resolved correctly. At some point, you come to the place where the resolution produces errors, and then you can see which case produces an error.</p>
<p>These checks can be done with <kbd>implicitly</kbd> keyword in Scala. The process of debugging with the <kbd>implicitly</kbd> function may look as follows:</p>
<pre>implicitly[MapToDouble[String ::: Int ::: Fraction ::: HNil]]<br/>implicitly[MapToDouble[Int ::: Fraction ::: HNil]]<br/>implicitly[MapToDouble[Fraction ::: HNil]]<br/>implicitly[ToDouble[Fraction]]</pre>
<p>The output of the preceding program's compilation will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/20a2629f-10e4-46cb-98cd-e313ebb74fbe.png"/></p>
<p class="mce-root"/>
<p>So, the error is caused because the compiler is not able to find the implicit <kbd>ToDouble</kbd> type class for Fraction. Notice how with each statement, we gradually shrink the search space by reducing the size of our <kbd>HList</kbd> algebraic type. At each step, we are looking at whether the error will manifest itself. Finally, we arrive at <kbd>implicitly[ToDouble[Fraction]]</kbd>, and realize there is no such implicit type-class implementation in scope. Notice also that all the preceding errors happen at compile-time.</p>
<p>The current state of affairs for the type-level computations may be not as good as you might want in Scala. However, you should keep in mind that the technology is still experimental. Scala itself is a language that is a playground for experimenting with new technologies. So, the main catch is the power of this new technology to bring the runtime errors in the scope of compile-time by leveraging the power of the type system and implicit resolution to specify certain guarantees about your program in terms of types. In Future, it is reasonable to expect that such kinds of technologies will get better tooling as they become more widely adopted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Libraries for type-level programming</h1>
                </header>
            
            <article>
                
<p>As in the case of cats being a library for purely functional programming in Scala, there exist libraries that facilitate type-level programming in Scala. One such library is <kbd>Shapeless</kbd>. In fact, <kbd>Shapeless</kbd> is a part of the same ecosystem of libraries as <kbd>cats</kbd>. It provides a set of classes and types, including the heterogeneous list type, that facilitate some advanced purely functional programming on the type level.</p>
<p>This approach deserves its own book, so we will not be going much deeper into it in this chapter. If you would like to learn more about this approach, please consult the official documentation and learning resources on <kbd>Shapeless</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the patterns of advanced functional programming.</p>
<p>First, we looked at Monad Transformers. These are used to construct compound effect types. Given two independent effect types that describe their own side effects, you can stack them one on top of another to get a combined type from them.</p>
<p>After that, we explored the Tagless Final pattern. The main benefit is inversion of control when you can have a single implementation of your business logic run against different effects systems to gain different semantics.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Finally, we learned about a pattern of type-level computations in functional programming. The main benefit of these is that they allow you to impose guarantees on your program encoded in terms of types, and have these guarantees checked at compile-time. This checking can be achieved with the mechanism of type-level computational, such as Scala implicit-conversion resolution, or any similar mechanisms that allows for type-level programming.</p>
<p>The techniques for purely functional programming covered so far are powerful and promising, but are not yet widely accepted in the industry. The current de facto standard for concurrent programming is the actor model. In the next chapters, we will look at it. We will start with introduction of the model in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Explain the benefits of Monad Transformers.</li>
<li>Explain the benefits of the Tagless Final pattern.</li>
<li>Explain the benefits of type-level computations.</li>
</ol>


            </article>

            
        </section>
    </body></html>