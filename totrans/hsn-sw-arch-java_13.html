<html><head></head><body>
		<div id="_idContainer113">
			<h1 id="_idParaDest-269"><a id="_idTextAnchor271"/>Chapter 11: Dealing with Data</h1>
			<p>You should know that no matter what your application does, you will end up dealing with persistence sooner or later. Whether it's a payment, a post on social media, or anything else, information has no value if it's not stored, retrieved, aggregated, modified, and so on.</p>
			<p>For this reason, data is very much a point of concern when designing an application. The wrong modeling (as we saw in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, when talking about <strong class="bold">Domain-Driven Development</strong>) can lead to a weak application, which will be hard to develop and maintain.</p>
			<p>In this chapter, we are taking data modeling a step further and discussing the ways your objects and values can be stored (also known as <em class="italic">data at rest</em>, as opposed to <em class="italic">data in motion</em>, where objects are still being actively manipulated by your application code).</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Exploring relational databases</li>
				<li>Introducing key/value stores</li>
				<li>Exploring NoSQL repositories</li>
				<li>Looking at filesystem storage</li>
				<li>Modern approaches – a multi-tier storage strategy</li>
			</ul>
			<p>As we have seen with many topics in this book so far, data persistence has also evolved a lot. Similar to what happened to the software development models and the <strong class="bold">Java Enterprise Edition</strong> (<strong class="bold">JEE</strong>) framework, when we deal with data, we also have a lot of different options to implement in several use cases.</p>
			<p>However, just as we have seen elsewhere (namely, in JEE applications versus cloud-native alternatives), the old ways have not been abandoned (because they are still relevant in some cases); instead, they are being complemented by more modern approaches that are suited for other use cases. And this is exactly what happened with the first technology that we are going to discuss – relational databases.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor272"/>Exploring relational databases</h1>
			<p><strong class="bold">Relational databases</strong> are<a id="_idIndexMarker1447"/> hardly a new idea. The idea was first introduced by Edgar F. Codd in 1970. Omitting the mathematical concepts behind it (for brevity), it says that data in a relational database is, as everybody knows, arranged into <em class="italic">tables</em> (we had a quick look at this in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>, in the <em class="italic">Persistence</em> section).</p>
			<p>Roughly<a id="_idIndexMarker1448"/> speaking, each table can be seen as one of the objects in our business model, with the columns mapping to the object fields and the rows (also known as <em class="italic">records</em>) representing the different object instances.</p>
			<p>In the following sections, we are going to review the basics of relational databases, starting with keys and relationships, the concept of transactionality, and stored procedures.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor273"/>Keys and relationships</h2>
			<p>Depending<a id="_idIndexMarker1449"/> on the database technology, it's a common idea to have a way to identify each row. This is commonly done by identifying a field (or a set of fields) that is unique to each record. This is the concept of a <strong class="bold">primary key</strong>. Primary keys<a id="_idIndexMarker1450"/> can be considered a constraint, meaning that they represent some rules with which the data inserted into the table must comply. Those rules need to be maintained for the table (and its records) to stay in a valid state (in this case, by having each record associated with a unique ID). However, other constraints are usually implemented in a relational database. Depending on the specific technology of the database system, these constraints may be really complex validation formulas.</p>
			<p>Another core concept of the database world is the <a id="_idIndexMarker1451"/>concept of <strong class="bold">relations</strong>. This is, as you can imagine, a way to model links between different objects (similar to what happens in the world <a id="_idIndexMarker1452"/>of <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>), where an object can contain references to other objects). The relations can fall into one of the following three cardinalities:</p>
			<ul>
				<li>A <strong class="bold">one-to-one</strong> relationship<a id="_idIndexMarker1453"/> represents a mapping of <a id="_idIndexMarker1454"/>each record to one, and only one, record from another table. This is usually referring to a relationship in which each row points to a row containing further information, such as a user record pointing to a row representing the user's living address in another table.</li>
				<li>A <strong class="bold">one-to-many</strong> relationship<a id="_idIndexMarker1455"/> is where <a id="_idIndexMarker1456"/>we model a relation in which each record maps to a set of records in another table. In this case, the relation between the two tables is unbalanced. One record in a table refers to a set of related records in another table, while the reverse is not valid (each record maps to one and only one record in the source table). A practical example is a user versus payment relationship. Each user is associated with one or more payments, while each payment is linked to only one user.</li>
				<li>A <strong class="bold">many-to-many</strong> relationship<a id="_idIndexMarker1457"/> is the last <a id="_idIndexMarker1458"/>option. Basically, in this case, multiple rows from a table can relate to multiple rows in the related tables, and vice versa. An example of this kind of relationship is movies and actors. A record in a movie table will link to more than one row in the actor table (implementing the relation of actors starring in a movie). And the reverse is true – a row in the actor table will link to many records in the movie table, as each actor will most likely be part of more than one movie.</li>
			</ul>
			<p>Here is a diagram of the<a id="_idIndexMarker1459"/> three types of relationship cardinalities:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_11.1_B16354.jpg" alt="Figure 11.1 – Table relationships&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Table relationships</p>
			<p>As you can see in the preceding diagram, there is a graphical representation of three examples of <a id="_idIndexMarker1460"/>relationships:</p>
			<ul>
				<li><strong class="bold">One to One</strong>, as in a person with address – each person can have just one primary home address.</li>
				<li><strong class="bold">One to Many</strong>, as in a person with transactions – each person can be associated with more than one payment transaction.</li>
				<li><strong class="bold">Many to Many</strong>, as in people with devices – each person can have many devices, and a device can be used by more than one person.</li>
			</ul>
			<p>These relationships are nothing new; the same is true for Java objects, with which you can model the same kinds of relationship:</p>
			<ul>
				<li>A class can be linked one-to-one with another one, by having a field of it.</li>
				<li>A class can be linked in a one-to-many scenario by having a field containing a list (or a set) of objects of the target class type.</li>
				<li>A class can implement a many-to-many scenario by extending the previous scenario and having the target class type with a field containing a list (or set) of objects of the source class type (hence linking back and forth).</li>
			</ul>
			<p>All of those models can then be propagated into SQL databases, and this is indeed done by JPA, which we introduced in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>.</p>
			<p>It used to be common (and it still happens in some cases) to define the domain model of an application, starting with the design of the database that will store the data. It's quite a simplistic approach since it cannot easily model every aspect of object-oriented applications (such as inheritance, interfaces, and many other constructs), but it works for some simple scenarios. </p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor274"/>Transactionality</h2>
			<p>One of the <a id="_idIndexMarker1461"/>more interesting (and widely used) capabilities<a id="_idIndexMarker1462"/> of a relational database is related to <strong class="bold">transactionality</strong>. Transactionality refers to a set of characteristics of relational databases that are the basis for maintaining data integrity (especially in the case of failures). These characteristics are united under the <strong class="bold">ACID</strong> acronym (which stands for <strong class="bold">Atomicity</strong>, <strong class="bold">Consistency</strong>, <strong class="bold">Isolation</strong>, and <strong class="bold">Durability</strong>):</p>
			<ul>
				<li><strong class="bold">Atomicity</strong>: Each <a id="_idIndexMarker1463"/>transaction (which is typically a set of different operations, such as the creation, modification, or deletion of records in one or more tables) is treated as a single unit; it will be successful as a whole, or it will fail completely (leaving all the tables as they were before the transaction started).</li>
				<li><strong class="bold">Consistency</strong>: Each <a id="_idIndexMarker1464"/>transaction can only change the database into a valid state by maintaining all the existing constraints (such as primary keys).</li>
				<li><strong class="bold">Isolation</strong>: The <a id="_idIndexMarker1465"/>concurrent transactions must be executed correctly with no interference from other transactions. This basically means that the final effect of a number of transactions executed in parallel should be the same as the same transactions being executed sequentially.</li>
				<li><strong class="bold">Durability</strong>: This<a id="_idIndexMarker1466"/> simply refers to the guarantee that a persisted transaction will be maintained (and can be retrieved) after a failure of the database system. In other words, the database should persist the data into non-volatile storage (a disk or similar technology). <p class="callout-heading">Tip</p><p class="callout">Consider that the concept of transactionality is usually not very well suited to heavily distributed environments, such as microservices and cloud-native architecture. We will discuss this more in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>.</p></li>
			</ul>
			<p>Last but not least, many different technologies allow us to execute custom code directly on the database.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor275"/>Stored procedures</h2>
			<p>Many <a id="_idIndexMarker1467"/>widely used databases can run complex programs. There is no standard for this kind of feature, even if the languages that are often used are similar to extensions of SQL, including conditions, loops, and similar statements. Occasionally, some general-purpose languages (such as <strong class="bold">Java</strong> and <strong class="bold">.NET</strong>) are available on some database systems.</p>
			<p>The reason<a id="_idIndexMarker1468"/> for storing code in a database is mainly data locality. By executing code in a database, the system has complete control over execution and transactional behavior (such as locking mechanisms); hence, you may end up getting very good performance. This may be particularly useful if you are doing batch operations and calculations on a large amount of data. But if you ask me, the advantages stop here and are not very worthwhile anyway.</p>
			<p>When<a id="_idIndexMarker1469"/> using stored procedures on a database system, you will observe small performance improvements, but the overall solution will be ugly from an architectural point of view and hard to maintain. Putting business logic in the data layer is never a good idea from a design point of view, and using special, procedural languages (such as the ones often available on such platforms) can only make things worse. Moreover, such languages are almost always impossible to port from one database system to another, hence strongly coupling your application with a specific technology and making it hard to change technology if needed.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Unless it's really needed, I advise avoiding stored procedures at all costs. </p>
			<p>Now that we have seen a summary of the basic features, let's see the commonly used implementations of relational databases.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor276"/>Commonly used implementations of relation databases</h2>
			<p>Let's <a id="_idIndexMarker1470"/>quickly discuss some commonly used products that provide the relational database features we have seen so far:</p>
			<ul>
				<li>We cannot <a id="_idIndexMarker1471"/>talk about relational databases without mentioning <strong class="bold">Oracle</strong> (<a href="https://www.oracle.com/database/">https://www.oracle.com/database/</a>). The name of this vendor has become synonymous<a id="_idIndexMarker1472"/> with databases. They provide many variants, including versions with clustering and embedded caching. This database is considered a de facto standard in many enterprises, and most commercially available software packages are compatible with Oracle databases. Oracle <a id="_idIndexMarker1473"/>databases support Java and PL/SQL (a proprietary language) as ways to define stored procedures.</li>
				<li><strong class="bold">Microsoft SQL Server</strong> (<a href="https://www.microsoft.com/sql-server/">https://www.microsoft.com/sql-server/</a>) is another widely <a id="_idIndexMarker1474"/>used database server. It became popular for its<a id="_idIndexMarker1475"/> complete features and proximity with the Microsoft ecosystem, as many widespread Microsoft applications use it. It also offers extensions for running .NET languages as part of stored procedures. It's worth noting that for a couple of years, SQL Server has also been supported on Linux servers, widening the use cases for SQL Server, especially in cloud environments.</li>
				<li><strong class="bold">MySQL</strong> (<a href="https://www.mysql.com/">https://www.mysql.com/</a>) is <a id="_idIndexMarker1476"/>another widely used database technology. It's<a id="_idIndexMarker1477"/> one of the first examples of an open source database and provides advanced features comparable to commercial databases. After the MySQL project was acquired by Oracle, a couple of forks have been created in order to keep the project autonomous. The most important fork currently available<a id="_idIndexMarker1478"/> is called <strong class="bold">MariaDB</strong>.</li>
				<li><strong class="bold">PostgreSQL</strong> (<a href="https://www.postgresql.org/">https://www.postgresql.org/</a>) is <a id="_idIndexMarker1479"/>another open source<a id="_idIndexMarker1480"/> relational database and has been available for a very long time (it was released shortly after the first release of MySQL). In contrast with MySQL, however, it's still independent, meaning that it hasn't been acquired by a major software vendor. For this reason and because of the completeness of its features, it is still a widely used option in many setups. Also, it's worth noting that many different third-party vendors provide commercial support and extensions to cover some specific use cases (such as clustering and monitoring).</li>
				<li><strong class="bold">H2</strong> (<a href="https://www.h2database.com/">https://www.h2database.com/</a>) is an <a id="_idIndexMarker1481"/>open source database written in Java. We<a id="_idIndexMarker1482"/> played with this technology in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>. It's very interesting to use because, being written in Java and released as a <strong class="source-inline">.jar</strong> file, it's easy to use it in an <em class="italic">in-memory</em> setup as part of the development process of Java applications.</li>
			</ul>
			<p>This includes scenarios such as embedding the database as part of a development pipeline or a Maven task, when it can be programmatically destroyed, created, and launched any time you want. This makes it particularly useful in testing scenarios. Despite more complex setups being available (such as client servers), H2 is<a id="_idIndexMarker1483"/> usually considered unsuitable for production usage. The most common use case, other than testing and development, is to ship it embedded with applications in order to provide a demo mode when an application is first started, suggesting that a different database should be set up and used before going into production.</p>
			<ul>
				<li><strong class="bold">SQLite</strong> (<a href="https://www.sqlite.org/">https://www.sqlite.org/</a>) is<a id="_idIndexMarker1484"/> another type of embeddable database. In<a id="_idIndexMarker1485"/> contrast with H2, it's written in the <strong class="bold">C</strong> language and does not offer any setup other than embedded. Moreover, SQLite lacks some features (for example, it doesn't support some advanced features of SQL). However, due to its robustness and exceptional performance, SQLite is widely used in production environments. The most widespread use case is to embed it as part of a client application. Many web browsers (such as Firefox and Chrome) and desktop applications (such as Adobe Photoshop) are known to use SQLite to store information. It's also widely used in Android applications.</li>
			</ul>
			<p>Now that we have seen a brief selection of commonly used databases, let's have a look at the use cases where it's beneficial to use a relational database and when other options would be better.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor277"/>Advantages and disadvantages of relational databases</h2>
			<p><strong class="bold">Transactionality</strong> is the<a id="_idIndexMarker1486"/> key feature of relational databases and is one of the advantages of using the technology. While other storage technologies can be configured to offer features similar to ACID transactions, if you need to reliably store structured data consistently, it's likely that a relational database is your best bet, both from a performance and a functionality standpoint. Moreover, through the SQL language, databases offer an expressive way to retrieve, combine, and manipulate data, which is critical for many use cases.</p>
			<p>Of course, there are downsides too. A database needs a rigid structure to be defined upfront for tables, relations, and constraints (that's pretty much essential and inherent to the technology). Later changes are of course possible, but they can have a lot of side effects (typically in terms of performance and potential constraint violations), and for this reason, they are impactful and expensive. On the other hand, we will see that alternative technologies (such as NoSQL storage) can implement changes in the data structure more easily.</p>
			<p>For this reason, a relational database may not be suitable in cases where we don't exactly know the shape of the data objects we are going to store. Another potential issue is that, given the complexity and rigidity of the technology, you may end up with performance and functional issues, which are not always easy to troubleshoot.</p>
			<p>A typical <a id="_idIndexMarker1487"/>example relates to complex queries. A relational database typically uses indexes to achieve better performance (each specific implementation may use different techniques, but the core concepts are often the same). Indexes must be maintained over time, with operations such as defragmentation and other similar ones (depending on each specific database implementation). If we fail to properly perform such maintenances, this may end up impacting heavily on the performance. And even if our indexes are working correctly, complex queries may still perform poorly.</p>
			<p>This is <a id="_idIndexMarker1488"/>because, in most practical implementations, you will need to combine and filter data from many different tables (an operation generally known as a join). These operations may be interpreted in many different ways by databases that will try to optimize the query times but will not guarantee good results in every case (especially when many tables and rows are involved).</p>
			<p>Moreover, when doing complex queries, you may end up not correctly using the indexes, and small changes in a working query may put you in the same situation. For this reason, my suggestion is, in complex application environments, to make sure to always double-check your queries in advance with the database administrators, who are likely to have tools and experience for identifying potential issues before they slip into production environments.</p>
			<p>As we have seen in this section, relational databases, while not being the most modern option, are still a very widespread and useful technology for storing data, especially when you have requirements regarding data integrity and structure. However, this comes at the cost of needing to define the data structure upfront and in having some discipline in the maintenance and usage of the database.</p>
			<p>You should also consider that, sometimes, relational databases may simply be overkill for simple use cases, where you just need simple queries and maybe not even persistence. We are going to discuss this scenario in the next section.</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor278"/>Introducing key/value stores</h1>
			<p>There<a id="_idIndexMarker1489"/> are scenarios in which you simply need temporary storage and are going to access it in a simple way, such as by a <a id="_idIndexMarker1490"/>known <strong class="bold">unique key</strong>, which will be associated with your object. This scenario is the best for key/value stores. Within this concept, you can find a lot of different implementations, which usually share some common features. The basic one is<a id="_idIndexMarker1491"/> the <strong class="bold">access model</strong> – almost every key/value store provides APIs for retrieving data by using a key. This is basically the same mechanism <a id="_idIndexMarker1492"/>as <strong class="bold">hash tables</strong> in Java, which guarantee maximum performance. Data retrieved in this way can be serialized in many different ways. The most basic way, for simple values, is strings, but <strong class="bold">Protobuf</strong> is <a id="_idIndexMarker1493"/>another common choice (see <a href="B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing Application Integration and Business Automation</em>, where we discussed this and other serialization technologies).</p>
			<p>A key/value store may not offer persistent storage options, as that is not the typical use case. Data is simply kept in memory to be optimized for performance. Modern implementations, however, compromise by serializing data on disk or in an external store (such as a relational database). This is commonly done asynchronously to reduce the impact on access and save times.</p>
			<p>Whether the technology you are using is providing persistent storage or not, there are other features for enhancing the reliability of a system. The most common one is based on data replication. Basically, you will have more than one system (also called <em class="italic">nodes</em>) running in a clustered way (meaning that they are talking to each other). Such nodes may be running on the same machine or, better yet, in different locations (to increase the reliability even more).</p>
			<p>Then, the technology running your key/value store may be configured to propagate each change (adding, removing, or modifying data) into a number of different nodes (optionally, all of them). In this way, in case of the failure of a node, your data will still be present in one or more other nodes. This <a id="_idIndexMarker1494"/>replication can be done synchronously (reducing the possibility of data loss but increasing the latency of each write operation) or asynchronously (the other way around).</p>
			<p>In the upcoming sections, we are going to see some common scenarios relating to caching data and the life cycle of records stored in the key/value store. Let's start looking at some techniques to implement data caching.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor279"/>Data caching techniques</h2>
			<p>A typical <a id="_idIndexMarker1495"/>use case for key/value stores is <strong class="bold">caching</strong>. You can <a id="_idIndexMarker1496"/>use a cache as a centralized location to store disposable data that's quickly accessible from your applications. Such data is typically considered disposable because it can be retrieved in other ways (such as from a relational database) if the key/value store is unavailable or doesn't have the data.</p>
			<p>So, in an average <a id="_idIndexMarker1497"/>case (sometimes referred to as a <em class="italic">cache hit</em>), you will have better performance and will avoid going into other storage (such as relational databases), which may be slow, overloaded, or expensive to access. In a worst-case scenario (sometimes referred to as a <em class="italic">cache miss</em>), you <a id="_idIndexMarker1498"/>will still have other ways to access your data.</p>
			<p>Some common scenarios are as follows:</p>
			<ul>
				<li><strong class="bold">Cache aside</strong>: The <a id="_idIndexMarker1499"/>key/value store is considered part of the application, which will decide programmatically which data should be stored on it, which data will go into persistent storage (such as a database), and how to keep the two in sync. This is, of course, the scenario providing the maximum flexibility, but it may be complex to manage.</li>
				<li><strong class="bold">Read-through</strong> and <strong class="bold">write-through</strong>: The synchronization between the key/value store <a id="_idIndexMarker1500"/>and the <a id="_idIndexMarker1501"/>persistent storage is done by the key/value store itself. This can be only for read operations (read-through), only for write operations (write-through), or for both. What<a id="_idIndexMarker1502"/> happens <a id="_idIndexMarker1503"/>from a practical point of view is that the application interacts with the key/value store only. Each change in the store is then propagated to the persistent storage.</li>
				<li><strong class="bold">Read-behind</strong> and <strong class="bold">write-behind</strong>: Basically, this is the same as read-through and write-through, but<a id="_idIndexMarker1504"/> the sync <a id="_idIndexMarker1505"/>with the persistent storage is not completed immediately (it's asynchronous). Of course, some inconsistency may happen, especially if you have other applications accessing the persistent storage directly, which may see incorrect or old data.</li>
				<li><strong class="bold">Write-around</strong>: In<a id="_idIndexMarker1506"/> this scenario, your application reads from the key/value store (by using a read-through or read-behind approach) and directly writes on the persistence store, or maybe other applications perform the write on the persistence store. Of course, this scenario can be dangerous, as your application may end up reading incorrect things on the key/value store.</li>
			</ul>
			<p>This scenario can be managed by notifying the key/value store about any change occurring in the persistent storage. This can be done by the application writing data, or it can be done directly by the persistent storage (if it is a feature provided by the technology) using a<a id="_idIndexMarker1507"/> pattern known as <strong class="bold">change data capture</strong>. The key/value store may then decide to update the changed data or simply delete it from the cached view (forcing a retrieve from the persistent store when your application will look again for the same key).</p>
			<p>Another common topic when talking about key/value stores is the life cycle of the data. </p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor280"/>Data life cycle</h2>
			<p>Since<a id="_idIndexMarker1508"/> they use memory heavily, with huge datasets you may want to avoid having everything in memory, especially if the access patterns are<a id="_idIndexMarker1509"/> identifiable (for example, you can foresee with reasonable accuracy which data will be accessed by your application). Common patterns for deciding what to keep in memory and what to delete are as follows:</p>
			<ul>
				<li><strong class="bold">Least recently used</strong>: The <a id="_idIndexMarker1510"/>system keeps track of the time of last access for each record and ditches the records that haven't been accessed for a set amount of time.</li>
				<li><strong class="bold">Tenure</strong>: A variant<a id="_idIndexMarker1511"/> of the previous scenario that simply uses the creation time instead of the last access time.</li>
				<li><strong class="bold">Least frequently used</strong>: The<a id="_idIndexMarker1512"/> system keeps a count of how many times a record is accessed and then, when it needs to free up some memory, it will delete the least accessed records.</li>
				<li><strong class="bold">Most recently used</strong>: The<a id="_idIndexMarker1513"/> opposite of least recently used, this deletes the most recently accessed records. This can be particularly useful in some scenarios, such as when it's unlikely that the same key will be accessed twice in a short amount of time.</li>
			</ul>
			<p>Key/value stores lack a standard language, such as SQL. It's also for this reason that key/value stores are a big family, including many different products and libraries, often offering more features than just key/value management. In the next section, we are going to see a few of the most famous implementations of key/value stores.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor281"/>Commonly used implementations of key/value stores</h2>
			<p>As previously <a id="_idIndexMarker1514"/>mentioned, it's not easy to build a list of key/value store technology implementations. As we will see in the next few<a id="_idIndexMarker1515"/> sections, this way of operating a database is considered to be a subcategory of a bigger family of storage systems, called NoSQL databases, offering more options and alternatives than just key/value storage. However, for the purpose of this section, let's see a list of what is commonly used in terms of key/value stores:</p>
			<ul>
				<li><strong class="bold">Redis</strong> is<a id="_idIndexMarker1516"/> likely the most <a id="_idIndexMarker1517"/>famous key/value store currently available. It's open source, and one of the reasons for its success is that, despite offering a lot of advanced features and tunings, it just works well enough in its default setting, making adopting it very easy. It provides client libraries for almost every language, including Java. It offers a lot of advanced features, such as clustering, transactions, and embedded<a id="_idIndexMarker1518"/> scripting (using the <strong class="bold">Lua language</strong>). It can operate on in-memory only, or persist the data on the filesystem using a configurable approach in order to balance performance impact and reliability.</li>
				<li><strong class="bold">Oracle Coherence</strong> is a <a id="_idIndexMarker1519"/>widely used commercial key/value storage. It's particularly used<a id="_idIndexMarker1520"/> in conjunction with other Oracle products, in particular with the database. It offers a wide range of features, including a complete set of APIs and a custom query language. Since 2020, a community edition of Coherence is available as open source software.</li>
				<li><strong class="bold">Memcached</strong> is a<a id="_idIndexMarker1521"/> simple<a id="_idIndexMarker1522"/> key/value store that is light and easy to operate. However, it lacks some features, such as persistence. Moreover, it provides only the cache-aside use case, so other scenarios must be implemented manually.</li>
				<li><strong class="bold">Infinispan</strong> is an<a id="_idIndexMarker1523"/> open<a id="_idIndexMarker1524"/> source key/value store that provides features such as persistence, events, querying, and caching. It's worth noting that Infinispan can be used both in an embedded and a client/server setup. In the embedded setup, Infinispan is part<a id="_idIndexMarker1525"/> of the <strong class="bold">WildFly JEE application server</strong>, providing caching services to Java Enterprise applications.</li>
			</ul>
			<p>Now that we have seen some widespread key/value stores, let's see when they are a good fit and when they are not.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor282"/>The pros and cons of key/value stores</h2>
			<p>The <a id="_idIndexMarker1526"/>most important advantage of key/value stores is the performance. The access time can be incredibly fast, especially when used without any persistent storage (in-memory only). This makes them particularly suitable for low-latency applications. Another advantage is simplicity, both from an architectural and a usage point of view.</p>
			<p>Architecturally speaking, if your use case doesn't require clustering and other complex settings, a key/value store can be as simple as a single application exposing an API to retrieve and store records. From a usage point of view, most use cases can be implemented with primitives as simple as <strong class="source-inline">get</strong>, <strong class="source-inline">put</strong>, and <strong class="source-inline">delete</strong>. However, some of these points can become limitations of key/value stores, especially when you have different requirements. If your application needs to be reliable (as in losing as little data as possible when there's a failure), you may end up with complex multi-node setups and persistence techniques. This may, in turn, mean that in some cases, you can have inconsistency in data that may need to be managed from an application point of view.</p>
			<p>Another <a id="_idIndexMarker1527"/>common issue is that, usually, data is not structured in key/value stores. This means that it is only possible to retrieve data searching by key (or at least, that's the most appropriate scenario). While some implementations allow it, it can be hard, performance-intensive, or in some cases impossible to retrieve data with complex queries on the object values, in contrast with what you can do with SQL in relational databases.</p>
			<p>In this section, we have covered the basics of data caching and key/value stores. Such techniques are increasingly used in enterprise environments, for both their positive impact on performances and their scalability, which fit well with cloud-native architectures. Topics such as data caching techniques and the life cycles of objects are common considerations to be made when adopting key/value stores.</p>
			<p>Key/value stores are considered to be part of a broader family of storage technologies that are alternatives to relational databases, called NoSQL. In the next section, we will go into more detail about this technology.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor283"/>Exploring NoSQL repositories</h1>
			<p>NoSQL is <a id="_idIndexMarker1528"/>an umbrella term comprising a number of very different data storage technologies. The term was coined mostly for marketing purposes in order to distinguish them from relational databases. Some NoSQL databases even support SQL-like query languages. NoSQL databases<a id="_idIndexMarker1529"/> claim to outdo relational databases in terms of performance. However, this assurance only exists because of some compromises, namely the lack of some features, usually in terms of transactionality and reliability. But to discuss these limitations, it is worth having an overview of the CAP theorem.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor284"/>The CAP theorem</h2>
			<p>The <strong class="bold">CAP theorem</strong> was <a id="_idIndexMarker1530"/>theorized by Eric Brewer in 1998 and formally proven valid in 2002 by Seth Gilbert and Nancy Lynch. It refers to a distributed data store, regardless of the underlying technology, so it's also applicable to relational databases when instantiated in a multi-server setup (so, running in two or more different processes, communicating through a network, for clustering and high-availability purposes). The theorem focuses on the concept of a <em class="italic">network split</em>, when the system becomes partitioned into two (or more) subsets that are unable to communicate with each other due to connectivity loss.</p>
			<p>The CAP theorem describes three core characteristics of distributed data stores:</p>
			<ul>
				<li><strong class="bold">Consistency</strong> refers<a id="_idIndexMarker1531"/> to keeping the stored data complete, updated, and formally correct.</li>
				<li><strong class="bold">Availability</strong> refers <a id="_idIndexMarker1532"/>to providing access to all the functionalities of the data store, especially the reads and writes of the data itself.</li>
				<li><strong class="bold">Partition tolerance</strong> refers<a id="_idIndexMarker1533"/> to the system functioning correctly, even in a case of network failure between servers.</li>
			</ul>
			<p>The CAP theorem states that, when a partition occurs, you can only preserve consistency or availability. While a mathematical explanation is available (and beyond the scope of this book), the underlying idea can be understood easily:</p>
			<ul>
				<li>If a system preserves availability, it may be that two conflicting operations (such as two writes with two different values) arrive in two different partitions of the system (such as two servers, unable to communicate between each other). With availability in mind, both servers will accept the operation, and the end result will be data being inconsistent.</li>
				<li>If a system preserves consistency, in case of a network split, it cannot accept operations that will change the status of the data (to avoid the risk of conflicts damaging the data consistency); hence, it will sacrifice availability.</li>
			</ul>
			<p>However, it's <a id="_idIndexMarker1534"/>worth noticing that this theorem, while being the basis for understanding the distributed data store limits, must be considered and contextualized in each particular scenario. In many enterprise contexts, it is possible to make the event of a network split extremely unlikely (for example, by providing multiple network connections between each server).</p>
			<p>Moreover, it's common to have mechanisms to elect a primary partition when there's a network split. This basically means that if you are able to define which part of the cluster is primary (typically, the one with the greater number of survival nodes, and this is why it's usually recommended to have an odd number of nodes), this partition can keep working as usual, while the remaining partition can shut down or switch to a degraded mode (such as read-only). So, basically, it's crucial to understand the basics of the CAP theorem, but it's also important to understand that there are a number of ways to work around the consequences.</p>
			<p>This is exactly the reasoning behind NoSQL databases. These<a id="_idIndexMarker1535"/> databases shift their point of view, <em class="italic">stretching</em> a bit over the CAP capabilities. This means that, while traditional relational databases focus on consistency and availability, they are often unreliable to operate in a heavily distributed fashion. Conversely, NoSQL databases can operate better in horizontally distributed architectures, favoring scalability, throughput, and performance at the expense of availability (as we saw, becoming read-only when there are network partitions) or consistency (not providing ACID transaction capabilities).</p>
			<p>And this brings us to another <a id="_idIndexMarker1536"/>common point of NoSQL stores – the <strong class="bold">eventual consistency</strong>.</p>
			<p>Indeed, most NoSQL stores, while not providing full transactionality (compared to relational databases) can still offer some data integrity by using the pattern of eventual consistency. Digging into the details and impacts of this pattern would require a lot of time. For the sake of this section, it's sufficient to consider that a system implementing eventual consistency may have some periods of time in which data is not coherent (in particular, enquiring for the same data on two different nodes can lead to two different results).</p>
			<p>With that said, it's usually possible to tune a NoSQL store in order to preserve consistency and provide full transactionality as a traditional relational database does. But in my personal experience, the impacts in terms of reduced performance and availability are not a worthwhile compromise. In other words, if you are looking for transactionality and data consistency, it's usually better to rely on relational databases.</p>
			<p>With that said, let's have an overview of the different NoSQL database categories.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor285"/>NoSQL database categories</h2>
			<p>As we discussed<a id="_idIndexMarker1537"/> in the previous sections, NoSQL is an umbrella term. There are a number of different categories of NoSQL stores:</p>
			<ul>
				<li><strong class="bold">Key/value stores</strong>: This<a id="_idIndexMarker1538"/> is the easiest one, as we have already discussed the characteristics of this technology. As should be clear by now, key/value stores share some core characteristics with NoSQL databases – they are generally designed to be horizontally scalable, to focus on performance over transactionality, and to lack full SQL compliance.</li>
				<li><strong class="bold">Document stores</strong>: This<a id="_idIndexMarker1539"/> is one of the most widespread categories of NoSQL databases. The core concept of a document store is that instead of rows, it stores documents, serialized into various formats (commonly JSON and XML). This often gives the flexibility of storing documents with a different set of fields or, in other words, it avoids defining a strict schema in advance for the data we are going to store. Documents then can be searched by their contents. Some notable examples of document stores include MongoDB, Couchbase, and Elasticsearch.</li>
				<li><strong class="bold">Graph databases</strong>: This<a id="_idIndexMarker1540"/> category of stores is modeled around the concept of a graph. It provides storage and querying capabilities optimized around graph concepts, such as nodes and vertex. In this way, concepts such as roads, links, and social relationships can be modeled, stored, and retrieved easily and efficiently. A famous implementation of a graph <a id="_idIndexMarker1541"/>database is <strong class="bold">Neo4j</strong>.</li>
				<li><strong class="bold">Wide-column databases</strong>: These<a id="_idIndexMarker1542"/> stores are similar to relational databases, except that in a table, each row can have a different set of fields in terms of the number, name, and type of each one. Two known implementations of wide-column databases are Apache Cassandra and Apache Accumulo.</li>
			</ul>
			<p>Of course, as you can imagine, there is a lot more to say about NoSQL databases. I hope the pointers I gave in this section will help you quickly understand the major features of NoSQL databases, and I hope one of the examples I've provided will be useful for your software architecture. In the next section, we are going to have a look at filesystem storage.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor286"/>Looking at filesystem storage</h1>
			<p><strong class="bold">Filesystems</strong> are<a id="_idIndexMarker1543"/> a bit of a borderline concept when it comes to data storage systems. To be clear, filesystem storage<a id="_idIndexMarker1544"/> is a barely structured system providing APIs, schemas, and advanced features, like the other storage systems that we have seen so far. However, it is still a very relevant layer in many applications, and there are some new storage infrastructures that provide advanced features, so I think it's worth having a quick overview of some core concepts.</p>
			<p>Filesystem storage should not be an alien concept to most of us. It is a persistent storage system backed by specific hardware (spinning or solid-state disks). There are many different filesystems, which can be considered the protocol used to abstract the read and write operations from and to such specific hardware. Other than creating, updating, and deleting files, and the arrangement of these files into folders, filesystems can provide other advanced features, such as journaling (to reduce the risk of data corruption) and locking (in order to provide exclusive access to files).</p>
			<p>Some common filesystems are<a id="_idIndexMarker1545"/> the <strong class="bold">New Technology File System</strong> (<strong class="bold">NTFS</strong>) (used in Windows environments) and<a id="_idIndexMarker1546"/> the <strong class="bold">Extended File System</strong> (<strong class="bold">ext</strong>) (used in Linux environments). However, these filesystems are designed for working on a single machine. A more important concept relates to the filesystems that allow interactions between different systems. One such<a id="_idIndexMarker1547"/> widespread implementation is networked filesystems, which is a family of filesystem protocols providing access to files and directories <a id="_idIndexMarker1548"/>over a network. The most notable example here is NFS, which is a <a id="_idIndexMarker1549"/>protocol that provides multi-server access to a shared filesystem. The <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>) and the <strong class="bold">SSH File Transfer Protocol</strong> (<strong class="bold">SFTP</strong>) are <a id="_idIndexMarker1550"/>other famous examples, and even if they are outdated, they are still widely used.</p>
			<p>A recent addition to the family of network storage<a id="_idIndexMarker1551"/> systems is <strong class="bold">Amazon S3</strong>. While it's technically an object filesystem, it's a way to interact with Amazon facilities using APIs in order to store and retrieve files. It started as a proprietary implementation for providing filesystem services on AWS infrastructure over the internet; since then, S3 has become a standard, and there are a lot of other implementations, both open source and commercial, aiming to provide S3-compliant storage on-premises and in the cloud.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor287"/>The advantages and disadvantages of filesystems</h2>
			<p>It's hard to talk <a id="_idIndexMarker1552"/>about the <a id="_idIndexMarker1553"/>disadvantages of filesystems because they are an essential requirement in every application, and it will stay like this for a long time. However, it's important to contextualize and think logically about the pros and cons of filesystems to better understand where to use them.</p>
			<p>Application interaction over shared filesystems is particularly convenient when it comes to exchanging large amounts of data. In banking systems (especially legacy ones), it's common to exchange large numbers of operations (such as payments) to be performed in batches, in the form of huge <strong class="source-inline">.csv</strong> files. The advantage is that the files can be safely chunked, signed, and efficiently transferred over a network.</p>
			<p>On the other hand, filesystems don't usually offer native indexing and full-text search, so these capabilities must be implemented on top. Moreover, filesystems (especially networked filesystems) can perform badly, especially when it comes to concurrent access and the locking of files.</p>
			<p>With this section, we have completed our overview of storage systems.</p>
			<p>In the next section, we are going to see how, in modern architecture, it is common to use more than one storage solution to address different use cases with the most suitable technology.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor288"/>Modern approaches – a multi-tier storage strategy</h1>
			<p>In the final section of the chapter, we'll be exploring a concept that may seem obvious, but it's still worth mentioning. <strong class="bold">Modern architecture</strong> tends<a id="_idIndexMarker1554"/> to use multiple data storage solutions, and I think that this could be a particularly interesting solution.</p>
			<p>In the past, it was common to start by defining a persistence strategy (typically on a relational database or on another legacy persistence system) and build the application functionalities around it. This is no longer the case. Cloud-native technologies, through microservices, developed the idea that each microservice should own its own data, and we can extend this concept in that each microservice could choose its own persistent storage technology. This is better suited for the particular characteristics of that business domain and the related use cases. Some services may need to focus on performance, while others will have a strong need for transactionality and data consistency.</p>
			<p>However, even if you are dealing with a less innovative architecture, it's still worthwhile evaluating different ideas around data persistence solutions. Here are some discussion points about it:</p>
			<ul>
				<li>Relational databases are your best bet when data is structured upfront and such a structure doesn't change very often. Moreover, if you will need ACID-compliant transactions, relational databases are generally the most performant solution.</li>
				<li>Key/value stores, especially in their in-memory setup, are useful in a number of use cases. The more common scenarios include the storage of user sessions, which will demand high performance (as it's related to web and mobile use cases, where there is heavy user interaction and high expectation in terms of availability) and consistency/reliability is less of an issue (in a worst-case scenario, the user will be logged out and will need to log in again). Another widely used scenario is database offloading – implementing some of the described scenarios (read-through, write-through, and so on) where cached entries will boost the overall performance and reduce the load on the database.</li>
				<li>NoSQL databases can be used for scenarios particularly suited to the specific technology of choice. In particular, if some entities in our architecture have a variable or unstructured representation, they can be suitable for document repositories. Graph databases can be useful for other scenarios in which algorithms on graphs are needed (such as the shortest path calculation).</li>
				<li>As previously mentioned, filesystems are almost always a fundamental infrastructure. They may be needed by some middleware (such as message brokers) for writing journals, and they can be used explicitly by an application as a data exchange area for large amounts of information (especially when dealing with legacy systems).</li>
			</ul>
			<p>So, once again, choosing the right data storage technology can be crucial to have a performant and well-written application, and it's a common practice to rely on more than one technology to meet the different needs that different parts of our application will require.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor289"/>Summary</h1>
			<p>In this chapter, we have seen an overview of different possibilities on the data layer, ranging from traditional SQL databases to more modern alternatives.</p>
			<p>While most of us are already familiar with relational databases, we have had a useful examination of the pros and cons of using this technology. We then broadened our view with alternative, widespread storage technologies, such as key/value stores, NoSQL, and even filesystems.</p>
			<p>Eventually, we looked at how the choice of a particular way of storing data may affect both the application design and the performance of our system. Indeed, in modern architecture, we may want to pick the right storage solution for each use case by choosing different solutions where needed.</p>
			<p>In the next chapter, we are going to discuss some architectural cross-cutting concerns. Topics such as security, resilience, usability, and observability are crucial to successful application architecture and will be analyzed to see their impacts and best practices.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor290"/>Further reading</h1>
			<ul>
				<li><em class="italic">Database Systems: Concepts, Languages, &amp; Architectures</em>, by Paolo Atzeni, Stefano Ceri, Stefano Paraboschi, and Riccardo Torlone</li>
				<li><em class="italic">Relational Databases 101: Looking at the Whole Picture</em>, by Scott W. Ambler (<a href="http://www.agiledata.org/essays/relationalDatabases.html">http://www.agiledata.org/essays/relationalDatabases.html</a>)</li>
				<li>NoSQL database list – Edlich (<a href="https://hostingdata.co.uk/nosql-database/">https://hostingdata.co.uk/nosql-database/</a>)</li>
				<li><em class="italic">Making Sense of NoSQL: A guide for managers and the rest of us</em>, by Dan McCreary and Ann Kelly</li>
			</ul>
		</div>
	</body></html>