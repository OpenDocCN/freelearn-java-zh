- en: Building Applications Using the MicroProfile API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MicroProfile API 构建应用程序
- en: At this point, you should have a good understanding of how to use the most common
    Java APIs (CDI, REST, JSON, JPA) in a Quarkus application. In this chapter, we
    will be adding a whole bunch of APIs called the MicroProfile specification. By
    mastering the topics in this chapter, you will be able to shape up components
    that have built upon the core features of the Java EE, which allows for a straightforward
    development experience when implementing microservices, increasing the robustness
    of your applications, and reducing the risk of over-designing and reinventing
    the same patterns. Topics you will learn to include how to add fault tolerance
    and health checks to your services, how to check your service's metrics, how to
    trace and document them, and how to create lean REST clients for your endpoints.
    Other features, such as configuration, security, and Reactive Messaging, will
    be covered in upcoming chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经很好地理解了如何在 Quarkus 应用程序中使用最常用的 Java API（CDI、REST、JSON、JPA）。在本章中，我们将添加一大堆被称为
    MicroProfile 规范的 API。通过掌握本章中的主题，您将能够构建基于 Java EE 核心功能的组件，这允许在实现微服务时获得直接的开发体验，提高应用程序的健壮性，并减少过度设计和重复创造相同模式的风险。您将学习到的话题包括如何为您的服务添加容错性和健康检查，如何检查您的服务指标，如何跟踪和记录它们，以及如何为您的端点创建精简的
    REST 客户端。其他功能，如配置、安全和反应式消息传递，将在后续章节中介绍。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of the MicroProfile API and how it can complement the Enterprise
    API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile API 概述及其如何补充企业 API
- en: How the MicroProfile API can fit into your Quarkus projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile API 如何适应您的 Quarkus 项目
- en: Some exposure on how to run the MicroProfile API in the cloud
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关于如何在云中运行 MicroProfile API 的介绍
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06)[.](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上的本章中找到项目的源代码：[https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06)[.](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06)
- en: Getting started with the MicroProfile API
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 MicroProfile API
- en: The Java Enterprise API is a great set of technologies for building applications,
    but it has historically lacked some features that are needed if you want to move
    your application to the cloud. For instance, there is no specific API to handle
    configuration properties that can be injected into your services, nor is there
    a formal way to describe how clients can interact with REST endpoints. Also, it
    would definitely help to include some features so that we can monitor an application's
    health or load-balance requests; these are currently managed by vendors with custom
    technologies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java 企业 API 是构建应用程序的一套优秀技术，但它历史上缺乏一些如果您想将应用程序迁移到云中所需的特性。例如，没有特定的 API 来处理可以注入到您的服务中的配置属性，也没有正式的方式来描述客户端如何与
    REST 端点交互。此外，包括一些功能来监控应用程序的健康状况或负载均衡请求肯定会有所帮助；这些目前由供应商使用自定义技术管理。
- en: The Eclipse MicroProfile project is a collaboration initiative that's driven
    by top application vendors and aims to optimize the Enterprise API for Java applications,
    including all the features we have mentioned here.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile 项目是一个由顶级应用程序供应商推动的合作倡议，旨在优化 Java 应用程序的企业 API，包括我们在此处提到的所有功能。
- en: 'A bird''s-eye view of the Eclipse MicroProfile specification shows how rich
    this environment is in the 3.2 release:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从 3.2 版本的角度来看，Eclipse MicroProfile 规范的鸟瞰图显示了该环境是多么丰富：
- en: '![](img/351b4899-58e2-40a9-aef0-aa01b8b7acb7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/351b4899-58e2-40a9-aef0-aa01b8b7acb7.png)'
- en: 'In this chapter, we will delve into the following areas of the MicroProfile
    specification:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 MicroProfile 规范的以下领域：
- en: '**The Eclipse MicroProfile Configuration**: Provides a unified way to configure
    your services by injecting the configuration data from a static file or from environment
    variables.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile 配置**：提供了一种统一的方式，通过注入来自静态文件或环境变量的配置数据来配置您的服务。'
- en: '**The Eclipse MicroProfile Health Check**: Provides the ability to probe the
    state of a service; for example, whether it''s running or not, whether it lacks
    disk space, or whether there is an issue with the database connection.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile Health Check**：提供了探测服务状态的能力；例如，它是否正在运行，是否缺少磁盘空间，或者是否存在数据库连接问题。'
- en: '**The Eclipse MicroProfile Fault Tolerance**: Allows you to define a strategy
    in the event of your services failing, for example, configuring timeouts, retry
    policies, fallback methods, and Circuit Breaker processing.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile Fault Tolerance**：允许您在服务失败的情况下定义策略，例如配置超时、重试策略、回退方法和断路器处理。'
- en: '**The Eclipse MicroProfile Metrics**: Provides a standard way for MicroProfile
    services to export monitoring data to external agents. Metrics also provide a
    common Java API that exposes their telemetry data.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile Metrics**：为MicroProfile服务提供了一种标准方式，可以将监控数据导出到外部代理。度量还提供了一个公共Java
    API，用于公开其遥测数据。'
- en: '**The Eclipse MicroProfile OpenAPI**: Provides a set of Java interfaces to
    document your services in a standard way.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile OpenAPI**：提供了一套Java接口，以标准方式记录您的服务。'
- en: '**The Eclipse MicroProfile OpenTracing**: Provides a set of instrumentation
    libraries for tracing components such as JAX-RS and CDI.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile OpenTracing**：提供了一套用于跟踪组件（如JAX-RS和CDI）的仪器库。'
- en: '**The Eclipse MicroProfile Rest Client**: This builds upon the JAX-RS API and
    provides a type safe, unified approach for invoking RESTful services over HTTP.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile Rest Client**：它基于JAX-RS API，提供了一种类型安全的、统一的方法来通过HTTP调用RESTful服务。'
- en: Although not discussed in this chapter, Quarkus also supports MicroProfile **JWT
    RBAC**, which outlines a proposal for using **OpenID Connect** (**OIDC**)-based
    **JSON Web Tokens** (**JWTs**) for **role-based access control** (**RBAC**) in
    your service endpoints. In the next chapter, which is about security, we will
    cover this topic in more detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章没有讨论，但Quarkus也支持MicroProfile **JWT RBAC**，它概述了一个使用基于**OpenID Connect**（**OIDC**）的**JSON
    Web Tokens**（**JWTs**）在您的服务端点进行**基于角色的访问控制**（**RBAC**）的提案。在下一章，关于安全性的章节中，我们将更详细地介绍这个主题。
- en: Getting started with MicroProfile projects
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用MicroProfile项目
- en: 'To learn about the single MicroProfile API, you will need the following projects,
    which can be found under the `Chapter06` folder in this book''s GitHub repository:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解单个MicroProfile API，您需要以下项目，这些项目可以在本书GitHub仓库的`Chapter06`文件夹中找到：
- en: '`fault-tolerance`: A project that shows us how to use the MicroProfile Fault
    Tolerance API'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fault-tolerance`：一个展示如何使用MicroProfile Fault Tolerance API的项目'
- en: '`health`: A project that focuses on the MicroProfile Health Check API'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`health`：一个专注于MicroProfile Health Check API的项目'
- en: '`openapi-swagger`: A project that implements OpenAPI interfaces'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openapi-swagger`：一个实现OpenAPI接口的项目'
- en: '`opentracing`: A project that implements the OpenTracing API'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opentracing`：一个实现OpenTracing API的项目'
- en: '`rest-client`: A project that focuses on the MicroProfile REST Client API'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest-client`：一个专注于MicroProfile REST Client API的项目'
- en: 'Most of the preceding projects are derived from the **customer service** Hibernate
    application that we discussed in [Chapter 5](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml),
    *Managing Data Persistence with Quarkus*. Therefore, a basic requirement is to
    have a PostgreSQL database up and running so that we can run our projects. We
    remind you that this can be done with just a one-line script:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前面的项目都是源自我们在[第5章](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml)“使用Quarkus管理数据持久性”中讨论的**客户服务**Hibernate应用程序。因此，一个基本的要求是必须有一个运行中的PostgreSQL数据库，这样我们才能运行我们的项目。我们提醒您，这可以通过一条简单的脚本完成：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we recommend importing the whole `Chapter06` folder into your IDE so that
    you can have the full set of projects at your fingertips as you continue with
    this chapter. That being said, we will start by discussing the MicroProfile Health
    Check API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们建议将整个`Chapter06`文件夹导入到您的IDE中，这样您就可以在继续本章内容时轻松访问所有项目。话虽如此，我们将从讨论MicroProfile
    Health Check API开始。
- en: The Eclipse MicroProfile Health Check
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile Health Check
- en: In the cloud environment, it is essential to allow services to report, and eventually
    publish, the overall health status to a defined endpoint. This can be achieved
    through MicroProfile Health Check, which allows a service to report the overall
    status as `"UP"` if it is available and `"DOWN"` if it is unavailable. This information
    can be collected by a service orchestrator, which can then use the health reports
    to make decisions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，允许服务向定义的端点报告并最终发布整体健康状况是至关重要的。这可以通过 MicroProfile 健康检查实现，它允许服务在可用时报告整体状态为
    `"UP"`，在不可用时报告为 `"DOWN"`。这些信息可以被服务编排器收集，然后使用健康报告来做出决策。
- en: 'Let''s put these concepts into practice with the `Chapter06/health` example.
    First off, in order to use the health extension, we have included the following
    dependency in the `pom.xml` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `Chapter06/health` 示例将这些概念付诸实践。首先，为了使用健康扩展，我们在 `pom.xml` 文件中包含了以下依赖项：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the preceding library is available, we can add an implementation of the
    `org.eclipse.microprofile.health.HealthCheck` interface, which allows us to check
    the service status. The following is the `DBHealthCheck` class, which verifies
    the status of the PostgreSQL database connection:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的库可用，我们就可以添加 `org.eclipse.microprofile.health.HealthCheck` 接口的实现，这允许我们检查服务状态。以下是一个
    `DBHealthCheck` 类，它验证 PostgreSQL 数据库连接的状态：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This class contains two core implementations of the MicroProfile specifications:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含了 MicroProfile 规范的两个核心实现：
- en: First of all, we have the `@Health` annotation, which works in combination with
    the `@ApplicationScoped` CDI context to return the health status check each time
    a request to `http://localhost:9080/health` is received.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有 `@Health` 注解，它与 `@ApplicationScoped` CDI 上下文结合使用，在每次收到对 `http://localhost:9080/health`
    的请求时返回健康状态检查。
- en: 'This class also uses the **MicroProfile Configuration API** to inject the PostgreSQL
    database host and port it into the bean. The following is an excerpt from the
    `application.properties` file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类还使用 **MicroProfile 配置 API** 将 PostgreSQL 数据库的主机和端口注入到 bean 中。以下是从 `application.properties`
    文件中的摘录：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, if the `POSTGRESQL_SERVICE_HOST` and `POSTGRESQL_SERVICE_PORT`
    environment variables aren't set, the default values (`localhost` and `5432`)
    are used and stored in the `db.host` and `db.port` variables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果 `POSTGRESQL_SERVICE_HOST` 和 `POSTGRESQL_SERVICE_PORT` 环境变量未设置，则使用默认值（`localhost`
    和 `5432`）并在 `db.host` 和 `db.port` 变量中存储。
- en: The target host and port are reached via a TCP socket and, on a successful attempt,
    a `responseBuilder.up()` will be returned. Otherwise, `responseBuilder.down()`
    will indicate a failure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目标主机和端口通过 TCP 套接字连接，在成功尝试后，将返回 `responseBuilder.up()`。否则，`responseBuilder.down()`
    将指示失败。
- en: 'You can start the Quarkus project with the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令启动 Quarkus 项目：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, assuming that the database is up and running, let''s try to access the
    `http://localhost:9080/health` endpoint:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，假设数据库正在运行，让我们尝试访问 `http://localhost:9080/health` 端点：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The response acknowledges the status of the database connection. Let''s also
    verify the condition where the database is unavailable. A simple *Ctrl* + *C*
    from the PostgreSQL shell will send the appropriate signal to stop the process.
    You should see the following output on the console:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 响应确认了数据库连接的状态。让我们也验证数据库不可用的情况。从 PostgreSQL 命令行界面简单地进行 *Ctrl* + *C* 将会发送适当的信号来停止进程。你应该在控制台上看到以下输出：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, check the status of the database connection through the `/health` endpoint
    once more:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次通过 `/health` 端点检查数据库连接的状态：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see from the preceding output, the JSON that was returned changed
    the status to `"DOWN"` and set the error message in the error field. This example
    sets our first milestone: checking the application''s health. We can further refine
    our health check policies by using liveness and readiness checks, which we will
    discuss in the next section.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的输出中看到的，返回的 JSON 将状态更改为 `"DOWN"` 并在错误字段中设置了错误消息。这个例子设定了我们的第一个里程碑：检查应用程序的健康状况。我们可以通过使用存活性和就绪性检查来进一步细化我们的健康检查策略，这些将在下一节中讨论。
- en: Using liveness and readiness checks
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存活性和就绪性检查
- en: 'According to the newest MicroProfile specifications, health checks are now
    to be used with a more specific model to help us determine the cause of potential
    issues. Therefore, it''s recommended you migrate the legacy `@HealthCheck` to
    one of the following checks:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最新的MicroProfile规范，健康检查现在应使用更具体的模型来帮助我们确定潜在问题的原因。因此，建议您将遗留的`@HealthCheck`迁移到以下检查之一：
- en: '**Readiness checks**: This check can indicate that a service is *temporarily*
    unable to serve traffic. This can be due to, for example, the fact that an application
    may be loading some configuration or data. In such cases, you don''t want to shut
    down the application but, at the same time, you don''t want to send it requests
    either. Readiness checks are supposed to cover this scenario.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性检查**：此检查可以指示服务**暂时**无法处理流量。这可能是因为，例如，应用程序可能正在加载一些配置或数据。在这种情况下，您不希望关闭应用程序，但同时也不要向其发送请求。可用性检查旨在涵盖这种场景。'
- en: '**Liveness checks**: Services running 24/7 can sometimes undergo a transition
    to broken states, for example, because they have hit `OutOfMemoryError`. Therefore,
    they cannot recover except by being restarted. You can, however, be notified of
    this scenario by defining a liveness check that probes the liveness of the service.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存活检查**：24/7运行的服务有时可能会过渡到损坏状态，例如，因为它们遇到了`OutOfMemoryError`。因此，除非重新启动，否则它们无法恢复。然而，您可以通过定义一个探测服务存活的存活检查来通知此场景。'
- en: In order to implement both checks, you can simply replace the `@org.eclipse.microprofile.health.HealthCheck`
    annotation with more specific ones, such as `@org.eclipse.microprofile.health.Liveness`
    and `@org.eclipse.microprofile.health.Readiness`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这两个检查，您只需将`@org.eclipse.microprofile.health.HealthCheck`注解替换为更具体的注解，例如`@org.eclipse.microprofile.health.Liveness`和`@org.eclipse.microprofile.health.Readiness`。
- en: 'In the following example, we have implemented a `@Readiness` check to verify
    whether a lock file exists (for example, due to a pending task) and emit a `"DOWN"`
    status when this file is detected:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们实现了一个`@Readiness`检查来验证是否存在锁文件（例如，由于挂起的任务）并在检测到该文件时发出`"DOWN"`状态：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Readiness checks are verified through the `"/health/ready"` URI. You can check
    this by requesting the following URL: `http://localhost:8080/health/ready`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性检查通过`"/health/ready"` URI进行验证。您可以通过请求以下URL来检查：`http://localhost:8080/health/ready`：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If no file has been detected, you will see something similar to the following
    output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有检测到文件，您将看到以下类似的输出：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s learn how to add a **liveness check** to our services. We will
    check the amount of free memory that''s needed to run the service and return a
    liveness check based on a certain memory threshold, which we have set to one gigabyte:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将**存活检查**添加到我们的服务中。我们将检查运行服务所需的空闲内存量，并根据我们设置为1GB的特定内存阈值返回存活检查：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can now verify the service''s liveness with cURL, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用cURL验证服务的存活状态，如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since the default Quarkus JVM settings don''t permit the amount of memory we
    have set in the threshold, the status of the service will indicate `"DOWN"`, as
    follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认的Quarkus JVM设置不允许我们设置的阈值内存量，因此服务的状态将指示`"DOWN"`，如下所示：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before we move on to the next API in our checklist, it is worth checking how
    health checks can be triggered in a cloud environment using Kubernetes probe checks.
    We'll learn how to do this in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续检查清单中的下一个API之前，值得检查如何在云环境中使用Kubernetes探针检查触发健康检查。我们将在下一节中学习如何做到这一点。
- en: Letting OpenShift manage unhealthy services
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让OpenShift管理不健康的服务
- en: 'In the examples so far, we have seen how to detect different health checks
    scenarios. One of the greatest advantages of running a Kubernetes native environment
    is that you can react automatically to changes in an application''s status. More
    specifically, it is possible to probe the following checks through the application''s
    deployment descriptors:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的示例中，我们已经看到了如何检测不同的健康检查场景。运行Kubernetes原生环境的一个最大优点是您可以自动对应用程序状态的变化做出反应。更具体地说，可以通过应用程序的部署描述符来探测以下检查：
- en: '**Liveness probe**: Kubernetes provides a liveness probe to determine whether
    the container that it''s been configured in is still running. Should the liveness
    probe fail, the `kubelet` agent kills and restarts the container.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存活探针**：Kubernetes提供了一个存活探针来确定配置在其上的容器是否仍在运行。如果存活探针失败，`kubelet`代理将终止并重新启动容器。'
- en: '**Readiness probe**: Kubernetes provides the readiness probe to signal that
    an application is temporarily unable to serve traffic, for example, because a
    configuration is being loaded. In such cases, you don''t want to stop the application,
    but you don''t want to allow any requests in either.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**就绪性探针**：Kubernetes提供了就绪性探针来指示应用程序暂时无法处理流量，例如，因为正在加载配置。在这种情况下，您不希望停止应用程序，但也不希望允许任何请求。'
- en: 'As you can see, the preceding probes match the MicroProfile Health Checks that
    were defined in the latest specifications. As a proof of concept, we will be deploying
    our example application into MiniShift as a binary build. As usual, we will start
    by creating a new project from the shell (or the web console, if you prefer doing
    things this way):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的探针与在最新规范中定义的MicroProfile健康检查相匹配。作为一个概念验证，我们将以二进制构建的形式将我们的示例应用程序部署到MiniShift中。像往常一样，我们将从shell（或如果您更喜欢这种方式，可以从Web控制台）创建一个新的项目：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you may remember, we need to add a PostgreSQL application to our project
    that will be found by our checks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能记得，我们需要将一个PostgreSQL应用程序添加到我们的项目中，这样我们的检查就可以找到它：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, you can finally push the Quarkus MicroProfile Health application we have
    just built onto the cloud. The following script will be used for this purpose:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将我们刚刚构建的Quarkus MicroProfile健康应用程序推送到云上。以下脚本将用于此目的：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding script should be nothing new for you, so let''s move on to the
    OpenShift console, where we can check the status of our project:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本对您来说应该没有什么新意，所以让我们继续转到OpenShift控制台，在那里我们可以检查我们项目的状态：
- en: '![](img/eef95c5f-57dd-4533-a4a0-80598369ae3d.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eef95c5f-57dd-4533-a4a0-80598369ae3d.png)'
- en: 'Now, check the Deployments configuration of your project and select Edit Health
    Checks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查您项目的部署配置并选择编辑健康检查：
- en: '![](img/348a0741-0c6f-4edf-ae16-1e287bf36a25.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/348a0741-0c6f-4edf-ae16-1e287bf36a25.png)'
- en: 'Within the Health Checks UI, you can choose which health check you want to
    add:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在健康检查UI中，您可以选择要添加哪个健康检查：
- en: '![](img/d4f8967f-2381-47f9-94b6-65276b858b5a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4f8967f-2381-47f9-94b6-65276b858b5a.png)'
- en: 'Let''s start with the Readiness Probe. By selecting it, you will be taken to
    the following UI:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从就绪性探针开始。通过选择它，您将被带到以下用户界面：
- en: '![](img/e2c33096-b028-4abc-a5d9-7919c20e2abf.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2c33096-b028-4abc-a5d9-7919c20e2abf.png)'
- en: 'The key parameter to select is Path, which should match our MicroProfile readiness
    URI (`health/ready`). Apart from that, you can also configure the following properties:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择的键参数是路径，它应该匹配我们的MicroProfile就绪性URI（`health/ready`）。除此之外，您还可以配置以下属性：
- en: '`initialDelaySeconds`: The number of seconds after the container has started
    before liveness or readiness probes are initiated.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialDelaySeconds`：容器启动后，在启动存活性或就绪性探针之前经过的秒数。'
- en: '`timeoutSeconds`: The number of seconds after which the probe times out. Defaults
    to 1 second. The minimum value is `1`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeoutSeconds`：探针超时的秒数。默认为1秒。最小值为`1`。'
- en: 'Now, let''s configure the Liveness Probe:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置存活性探针：
- en: '![](img/c71efc35-bf5a-4a38-a28f-00737791e70b.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c71efc35-bf5a-4a38-a28f-00737791e70b.png)'
- en: 'Except for Path, which will be `health/live`, we can leave the other default
    values. Save your changes as-is. Now, let''s try to break a few things. For example,
    we will create a lock file in the Pod where the application is running. This will
    immediately trigger a failure in the readiness probe. Let''s check a list of Pods
    from the shell with the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路径，它将是`health/live`之外，我们可以保留其他默认值。按原样保存您的更改。现在，让我们尝试破坏一些东西。例如，我们将在应用程序运行所在的Pod中创建一个锁文件。这将立即触发就绪性探针的失败。让我们使用以下命令从shell中检查Pod列表：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output that''s returned is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的输出如下：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Okay, we will now run a remote shell against this running Pod:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在将对这个正在运行的Pod运行一个远程shell：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We're in. Now, create a file named `/tmp/tmp.lck`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进入。现在，创建一个名为`/tmp/tmp.lck`的文件
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In a couple of seconds (depending on the initial delay setting), your Pod won''t
    be available anymore. You can see this from the Overview panel:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在几秒钟内（取决于初始延迟设置），您的Pod将不再可用。您可以从概览面板中看到这一点：
- en: '![](img/a963448a-8234-4c0d-905a-a05137b354dc.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a963448a-8234-4c0d-905a-a05137b354dc.png)'
- en: 'This change will also be reflected in system events, which can be captured
    through the `oc get events` command, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化也将反映在系统事件中，这些事件可以通过`oc get events`命令捕获，如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, it''s worth mentioning that our application also includes a liveness
    check, which verifies that the amount of available memory is greater than a certain
    threshold. Whether you have hit the threshold or not, the liveness probe depends
    on the amount of memory allowed at startup for MiniShift. A digression into OpenShift''s
    application memory sizing would take us beyond the scope of this book, but it''s
    worth reading more about it by looking at the official docs: [https://docs.openshift.com/container-platform/3.9/dev_guide/application_memory_sizing.html](https://docs.okd.io/latest/dev_guide/application_memory_sizing.html).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，我们的应用程序还包括一个存活检查，该检查验证可用内存量是否大于某个特定阈值。无论你是否达到了阈值，存活探测都取决于MiniShift启动时允许的内存量。关于OpenShift应用程序内存大小的深入探讨将超出本书的范围，但通过查看官方文档了解更多信息是值得的：[https://docs.openshift.com/container-platform/3.9/dev_guide/application_memory_sizing.html](https://docs.okd.io/latest/dev_guide/application_memory_sizing.html)。
- en: Maintaining your application's status so that it's healthy is a key element
    to consider when designing your applications. On the other hand, enabling your
    services to react to failures or performance degradation is no less important.
    Don't worry, though – the next section will teach you how to handle failures using
    the MicroProfile Fault Tolerance API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 维护应用程序的状态，使其保持健康是设计应用程序时需要考虑的关键要素。另一方面，使你的服务能够对故障或性能退化做出反应同样重要。不过，别担心——下一节将教你如何使用MicroProfile容错API来处理故障。
- en: The Eclipse MicroProfile Fault Tolerance API
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile 容错 API
- en: 'The **Fault Tolerance** specification is a fundamental API that can be used
    to handle the unavailability of your microservices by endorsing a set of policies
    that can improve the resiliency of your applications. The following fault tolerance
    policies are available:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**容错**规范是一个基本的API，可以通过支持一组可以提高应用程序弹性的策略来处理你的微服务的不可用性。以下可用的容错策略有：'
- en: '**Timeout**: Defines a timeout for the execution of a service call'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：为服务调用的执行定义超时时间'
- en: '**Fallback**: Provides a contingency solution when a failure occurs'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退**：在发生故障时提供应急解决方案'
- en: '**Retry**: Allows you to retry execution based on criteria'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试**：允许你根据标准重试执行'
- en: '**Bulkhead**: Isolates partial service failures while the rest of the system
    can still work'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离舱**：在系统其余部分仍能工作的情况下隔离部分服务故障'
- en: '**Circuit Breaker**: Defines criteria for automatic fast-fails to prevent system
    degradation caused by overloading'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：定义了自动快速失败的准则，以防止系统因过载而退化'
- en: '**Asynchronous**: Allows us to invoke an operation asynchronously'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步**：允许我们异步调用操作'
- en: 'Let''s look at these concepts in practice by using the `Chapter06/fault-tolerance`
    example. First off, in order to use the fault-tolerance extension, we have included
    the following dependency in the `pom.xml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`Chapter06/fault-tolerance`示例来实际看看这些概念。首先，为了使用容错扩展，我们在`pom.xml`文件中包含了以下依赖项：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's start with the Timeout, Fallback, and Retry policies, which are commonly
    used together since they complement each other.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从超时、回退和重试策略开始，这些策略通常一起使用，因为它们相互补充。
- en: Using Timeout, Fallback, and Retry to create resilient services
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超时、回退和重试创建具有弹性的服务
- en: 'In simple terms, the `@org.eclipse.microprofile.faulttolerance.Timeout` annotation
    can be used to specify the maximum time (in ms) allowed for returning a response
    in a method. Here is an example `findAll` method that times out after 250 ms:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`@org.eclipse.microprofile.faulttolerance.Timeout`注解可以用来指定方法返回响应允许的最大时间（以毫秒为单位）。以下是一个在250毫秒后超时的`findAll`方法示例：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The random sleep that's triggered by the finder method can be used to allow
    some occasional execution failures.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由查找方法触发的随机睡眠可以用来允许一些偶尔的执行失败。
- en: 'In order to mitigate time-outs or other failures, you can decorate your methods
    with the `@Fallback` policy so that you can specify an alternate execution path
    in the case of failure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻超时或其他失败，你可以用`@Fallback`策略装饰你的方法，这样你就可以在失败的情况下指定一个替代执行路径：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we are redirecting the execution to the `findAllStatic` method
    if any failure arises in the `findAll` method. The `findAllStatic` method will
    return a static list of `Customer` objects (please check the source code example
    for this chapter to see the implementation of this).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，如果`findAll`方法中发生任何故障，我们将执行重定向到`findAllStatic`方法。`findAllStatic`方法将返回一个静态的`Customer`对象列表（请查看本章的源代码示例以查看此实现的实现）。
- en: Applying a retry policy to your failures
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将重试策略应用于你的故障
- en: Sometimes, failures in the execution of your methods are caused by temporary
    issues such as network congestion. If we are confident that the issue can be resolved
    in accordance with our business SLA, we can include a `@Retry` annotation to allow
    us to reiterate the execution of failed methods a certain number of times.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的方法执行中的故障是由临时问题，如网络拥塞引起的。如果我们有信心问题可以按照我们的业务SLA解决，我们可以包含一个`@Retry`注解，以允许我们重新执行失败的特定次数。
- en: 'For example, by adding the `@Retry(maxRetries = 3)` annotation, we will attempt
    to load data from the database three more times before using a static list of
    customers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过添加`@Retry(maxRetries = 3)`注解，我们将在使用静态客户列表之前尝试从数据库加载数据三次：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is worth mentioning that the `@Retry` annotation can be configured to retry
    only a subset of specific exceptions. This can be seen in the following example,
    where we''re using `@Retry` over `RuntimeException` and `TimeoutException`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`@Retry`注解可以配置为仅重试特定异常的子集。这可以在以下示例中看到，其中我们使用`@Retry`覆盖`RuntimeException`和`TimeoutException`：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let's learn how to apply a fault tolerance pattern named **Circuit Breaker**
    to our services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将名为**断路器**的容错模式应用于我们的服务。
- en: Circuit Breaker
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: '**Circuit Breaker** is a core pattern for creating resilient services. It can
    be used to prevent repeatable exceptions by instantly denying new requests. The
    MicroProfile Fault Tolerance API uses the `@CircuitBreaker` annotation to control
    incoming requests. A software Circuit Breaker is similar to an electrical circuit
    breaker since it has the following states:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**断路器**是创建弹性服务的一个核心模式。它可以用来通过立即拒绝新请求来防止重复异常。MicroProfile容错API使用`@CircuitBreaker`注解来控制传入请求。软件断路器与电路断路器类似，因为它具有以下状态：'
- en: '**Closed state**: A closed-circuit represents a fully functional system that''s
    available to its clients.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭状态**：闭合电路表示一个完全功能且可供其客户端使用的系统。'
- en: '**Half-open circuit**: When some failures are detected, the state can change
    to half-open. In this state, it checks whether the failed component is restored.
    If so, it closes the circuit. Otherwise, it moves to an open state.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开电路**：当检测到某些故障时，状态可以变为半开。在此状态下，它会检查失败的组件是否已恢复。如果是，则关闭电路。否则，它将移动到开路状态。'
- en: '**Open state**: An open state means the service is temporarily disabled. After
    checks have been made, you can verify whether it''s safe to switch to a half-open
    state.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开路状态**：开路状态意味着服务暂时不可用。经过检查后，你可以验证是否可以安全地切换到半开路状态。'
- en: 'Here is an example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, the `@CircuitBreaker` policy applies to the `findAll`
    method of the `OrderRepository` class. Because of that, if, within the last four
    invocations, 75% failed, then the circuit transits to an open state. The circuit
    will stay open for 1,000 ms. When a circuit is open, a `CircuitBreakerOpenException`
    will be thrown instead of actually invoking the method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`@CircuitBreaker`策略应用于`OrderRepository`类的`findAll`方法。因此，如果在最后四次调用中，有75%失败，则电路将过渡到开路状态。电路将保持开路状态1,000毫秒。当电路处于开路状态时，将抛出`CircuitBreakerOpenException`而不是实际调用方法。
- en: 'Please note that, like the retry method, the `@CircuitBreaker` also allows
    us to define failure criteria through the `failon` annotation parameter. This
    can be seen in the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与重试方法一样，`@CircuitBreaker`也允许我们通过`failon`注解参数定义失败标准。这可以在以下示例中看到：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, if a `RuntimeException` is thrown in the method, then
    the execution is counted by the `CircuitBreaker` as a failure; otherwise, it is
    counted as a success.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果在方法中抛出`RuntimeException`，则`CircuitBreaker`将其计为一个失败；否则，计为一个成功。
- en: Now that we know about the background of the core Fault Tolerance API, let's
    learn how to further enhance our application's robustness with bulkhead and asynchronous
    patterns.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了核心容错API的背景，让我们学习如何通过bulkhead和异步模式进一步增强我们应用程序的健壮性。
- en: Using asynchronous and bulkhead policies
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步和 Bulkhead 策略
- en: Asynchronous programming is not a new pattern for Enterprise developers. However,
    when used in combination with the `BulkHead` policy, you can achieve a powerful
    fault tolerance pattern for your microservices. In a nutshell, if you annotate
    a method with `@Asynchronous`, it will be executed asynchronously on a separate
    thread.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程对于企业开发者来说并不是一种新模式。然而，当与 `BulkHead` 策略结合使用时，你可以为你的微服务实现一个强大的容错模式。简而言之，如果你用
    `@Asynchronous` 注解一个方法，它将在一个单独的线程上异步执行。
- en: 'In the following example, we are performing some logic in the `createOrder`
    method, which spins off some debugging in a separate thread by means of the `writeSomeLogging`
    method, which returns a `CompletableFuture` instance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在 `createOrder` 方法中执行一些逻辑，通过 `writeSomeLogging` 方法在单独的线程中生成一些调试信息，该方法返回一个
    `CompletableFuture` 实例：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When `@Bulkhead` is used with `@Asynchronous`, the thread pool isolation approach
    will be used. The thread pool approach allows us to configure the maximum concurrent
    requests together with a certain queue size, just like a semaphore. Here is the
    updated example, which includes the `@Bulkhead` policy:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `@Bulkhead` 一起使用 `@Asynchronous` 时，将采用线程池隔离方法。线程池方法允许我们配置最大并发请求以及一定的队列大小，就像一个信号量。以下是更新后的示例，其中包含了
    `@Bulkhead` 策略：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That was a whirlwind tour of the fault tolerance policies that are available
    in the MicroProfile API. Let's move on to the next section, which is about capturing
    service metrics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 MicroProfile API 中可用的容错策略的快速浏览。让我们继续到下一节，该节是关于捕获服务指标。
- en: The Eclipse MicroProfile Metrics API
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile Metrics API
- en: The MicroProfile Metrics specification provides us with a unified way of exporting
    your services' monitored data to management agents. This helps us perform proactive
    checks on some key statistics indicators, such as the number of times and the
    rate at which a service has been requested, the duration of each request, and
    so on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Metrics 规范为我们提供了一种统一的方式，将您的服务监控数据导出到管理代理。这有助于我们执行对一些关键统计指标的前瞻性检查，例如服务被请求的次数和速率、每次请求的持续时间等等。
- en: 'Let''s get coding. Here, we will focus on the `Chapter06/metrics` example.
    First off, in order to use the metrics extension, we have included the following
    dependency in the `pom.xml` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编码。在这里，我们将关注 `Chapter06/metrics` 示例。首先，为了使用指标扩展，我们在 `pom.xml` 文件中包含了以下依赖项：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we''ll provide an overview of the metrics annotations that have been added
    on top of our REST service. Let''s start with the `@Counted` annotation, which
    tracks how many times a request has been made:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将概述添加到我们的 REST 服务之上的指标注解。让我们从 `@Counted` 注解开始，它跟踪请求被调用的次数：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Within the `@Counted` annotation, we have provided a description and set the
    `absolute` flag to `true`, which means the class's package name will not be prepended
    to the metric name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@Counted` 注解中，我们提供了一个描述并设置了 `absolute` 标志为 `true`，这意味着类的包名将不会添加到指标名称前。
- en: 'Let''s compile and run the application:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行应用程序：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s reload the home page, which will trigger a list of customers. Next,
    we''ll gather some metrics. There are two entry points for our metrics:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新加载主页，这将触发客户列表。接下来，我们将收集一些指标。我们的指标有两个入口点：
- en: '`http://localhost:8080/metrics`: This endpoint will return all the metrics,
    including system metrics where the application is running.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/metrics`：此端点将返回所有指标，包括应用程序运行时的系统指标。'
- en: '`http://localhost:8080/metrics/application`: This endpoint will just return
    metrics that are emitted by the applications that have been deployed.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/metrics/application`：此端点将仅返回已部署的应用程序发出的指标。'
- en: 'We will choose the latter option here, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择后面的选项，如下所示：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since we have loaded the home page twice, the expected output should be as
    follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经加载了主页两次，预期的输出应该如下所示：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next annotation is the `@Timed` annotation, which keeps track of the duration
    of an event. Let''s apply it to the `getAll` method as well:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个注解是 `@Timed` 注解，它跟踪事件的持续时间。让我们将其应用到 `getAll` 方法上：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should be able to retrieve a detailed report about the invocation rates
    of the preceding method (which includes rate/sec, rate/min rate/5 min, plus statistics
    quantile metrics). For the sake of brevity, here is an excerpt from it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够检索关于前述方法调用频率的详细报告（包括每秒、每分钟、每5分钟的速率以及统计分位数指标）。为了简洁起见，以下是其中的一段摘录：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the other hand, if you need just a basic metric that records a single unit
    of data, you can use the `@Gauge` annotation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The Gauge metric will display the following metric after two requests have
    landed on the preceding method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After this fast-paced introduction to MicroProfile metrics, let's learn how
    to document our endpoint resources with OpenAPI and Swagger.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OpenAPI and the Swagger UI
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenAPI specification aims to provide a set of Java interfaces and programming
    models that can natively produce OpenAPI v3 documents from JAX-RS services. The
    default OpenAPI implementation in Quarkus provides an out-of-the-box standard
    documentation for all the exposed services that can be generated through the `/openapi`
    endpoint.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, you can augment JAX-RS services even further using specific annotations
    to provide more insights about the endpoint, its parameters, and the response.
    Moving on to the code, we will focus on the `Chapter06/openapi-swagger` example.
    As you can check from its configuration, we have added the following extension
    to the project:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since we have several REST endpoints available in our project, we can check
    the generated OpenAPI document at `http://localhost:8080/openapi`. Here is the
    (truncated) output for our customer service application:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, with minimal effort we have produced a JSON document that describes
    the functionalities of our service without requiring direct access to the underlying
    source code or any other documentation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, the OpenAPI can be used as a foundation for powerful UIs such
    as **Swagger**, which is a great tool for visualizing and interacting with your
    APIs. Its UI is automatically generated from your OpenAPI specification.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get rolling with Swagger, you just need to point to `http://localhost:8080/swagger-ui/`.
    By doing this, you will end up on the Swagger home page:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1942eb14-4dad-43ba-8e5a-314f26f77855.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'From there, you can easily test any available operation by expanding it and
    clicking on the Try it out button:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06531d2f-64d8-4344-b902-700c831b7335.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'A default Response body will be generated. Adjust it to your needs and click
    on Execute. As a result, you will see the returned value (if any) from our operation
    in the Response body text area:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3f519f9-8d83-4db2-baf9-aa6ecf4ca03b.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Optionally, you can click on the Download button to save the response locally.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the output of OpenAPI
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the OpenAPI specification ([https://swagger.io/specification/](https://swagger.io/specification/)),
    it is possible to customize the full schema of objects that are returned by the
    `/openapi` Servlet. This can be done by adding specific annotations to your endpoints
    classes and methods. Although none of these annotations are mandatory, we will
    mention some common ones that can improve the readability of your OpenAPI schema.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `@org.eclipse.microprofile.openapi.annotations.tags.Tag` annotation
    can be used as a qualifier to describe a group of specific operations related
    to the endpoint. This annotation can be applied at the class level. In order to
    describe a single resource method, you can use the `org.eclipse.microprofile.openapi.annotations.Operation`
    tag, which can be applied at the method level. Then, a description of the operation
    parameters can be included with the `org.eclipse.microprofile.openapi.annotations.parameters.Parameter`
    tag. Finally, the `org.eclipse.microprofile.openapi.annotations.responses.APIResponse`
    tag describes a single response from an API operation. You can attach multiple
    `APIResponse` annotations to a single method to control the response for each
    response code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the customization being applied to the `CustomerEndpoint`
    class in practice:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For the sake of brevity, we have just tagged the `CustomerEndpoint` service
    with OpenAPI annotations. We leave it to you to update the `OrderEndpoint` service
    so that you can verify your new skills.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile OpenTracing API
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed tracing plays a key role in the era of microservices as it lets
    you trace the flow of a request across different services. In order to accomplish
    microservice tracing, we can instrument our services to log messages to a distributed
    tracing server that can collect, store, and display this information in various
    formats.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenTracing` specification does not address which distributed system is
    in charge of collecting the tracing data, but a widely adopted end-to-end open
    source solution is **Jaeger** ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)),which
    fully implements the `OpenTracing` standard.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see OpenTracing in action by switching to the `Chapter06/opentracing`
    example. First off, in order to use the opentracing extension, the following dependency
    must be added to your project:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As a matter of fact, when adding this extension, an implementation of an `io.opentracing.Tracer`
    object will be made available to your application. This means that all your HTTP
    requests will be automatically traced.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of configuration, we need to provide some details about the Jaeger
    endpoint. This can be done either with the `application.properties` file or using
    environment variables. The following shows how we have configured the `application.properties`
    file to emit a tracing notification to a Jaeger endpoint running on localhost
    and listening to port `14268`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Within the preceding configuration, we have also defined the service name (`quarkus-service`)
    and the sampler type. In the sampler type definition, `"` always makes the same
    decision for all traces. It either samples all the traces (`sampler-param=1`)
    or none of them (`sampler-param=2`).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start the Jaeger service. The simplest way to do this is by running
    it as a Docker container. The following command will start the `jaegertracing/all-in-one`
    container image, forwarding the UDP/TCP port of the Docker container to localhost:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can start using our customer service application and execute some operations
    with it. Then, we can log into the Jaeger console, which is available at `http://localhost:16686`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72bfbd3e-f95b-437c-b209-19486cc6bb9e.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, in the left panel of the Jaeger UI you
    can see a combo box named Service, which contains a list of the services that
    are available for tracing. You should see in it the default jaeger query service,
    which allows us to trace the query service. Provided that you have configured
    your Quarkus application to emit notifications, you should be able to see quarkus-service
    enlisted. Select it and then check the next combo box, which is Operation. This
    combo box contains all the operations that have been traced for that particular
    service. Here is a partial view of the UI that contains the combo box:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48b7e635-2b1b-4f4c-b45e-26d633a4da4d.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'If you select all, on the screen you should be able to see all the traces for
    all the HTTP requests to `quarkus-service`, as shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/987aa7b9-6cae-46fd-b2ee-c646f35ef20f.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'From there, you can choose to gather more details about a single trace by clicking
    on it. You will see a comprehensive timeline with details such as the execution
    time, remote caller, and errors reported:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/283fb5ff-3c3d-4ffd-a78c-8507dc2dd1c1.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: If you want to download and elaborate on the trace file, you can also choose
    to trace your operation as JSON by selecting Trace JSON in the top-right corner.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of possibilities for tracing your application with Jaeger.
    We advise referring to [https://www.jaegertracing.io/](https://www.jaegertracing.io/)
    if you want to become a ninja at tracing your microservices!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile REST Client API
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last MicroProfile extension we will discuss in this chapter is the REST
    client extension. The goal of this API is to provide you with a type safe way
    to invoke REST services in a microservice architecture.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t confuse the MicroProfile REST client API with the JAX-RS Client API!
    They implement different standards: the JAX-RS Client API is implemented according
    to JSR 370 ( [https://www.jcp.org/en/jsr/detail?id=370](https://www.jcp.org/en/jsr/detail?id=370)),
    while the MicroProfile REST Client API follows the standard specified here: [http://microprofile.io/project/eclipse/microprofile-rest-client](http://microprofile.io/project/eclipse/microprofile-rest-client).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to learn about the REST client API, we will be using it as a template
    for the `Chapter06/rest-client` application. This project is nothing but a cut-down
    version of our customer service, which just contains interfaces instead of service
    implementations. In terms of configuration, we have added the following dependency
    to the `pom.xml` file of our `rest-client` project:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we have replaced the concrete service implementations with two interfaces:
    one named `CustomerEndpointItf` and another named `OrdersEndpointItf`. Here is
    `CustomerEndpointITf`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is `OrdersEndpointItf`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note the `@org.eclipse.microprofile.rest.client.inject.RegisterRestClient`
    annotation, which makes the REST client injectable through the CDI using the `@org.eclipse.microprofile.rest.client.inject.RestClient`
    annotation. Let''s learn how to do this in practice in the `CustomerEndpoint`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, we have replaced the REST client implementation by delegating
    the execution to the interface we have registered as a REST client. At this point,
    you may be wondering how the REST client knows about the remote endpoint. That''s
    a good question, and the answer is contained in the `application.properties` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see from the first line, all the requests to the REST client interface
    will result in a call to the remote endpoint base URL, which is qualified using
    the following expression:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Also, the default scope of the REST client interface has been configured as
    a **singleton**, which instructs Quarkus to instantiate the singleton once, passing
    its reference to other objects during the injection. Other supported scope values
    are `@Dependent`, `@ApplicationScoped`, and `@RequestScoped`, the latter being
    the default one. Check the CDI specifications for more details about the different
    scopes ([http://www.cdi-spec.org/](http://www.cdi-spec.org/)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run the test, we need an application that returns a list of `Customers`
    through the `http://localhost:8080/customers` endpoint and a list of `Orders`
    through the `http://localhost:8080/orders` endpoint. For this purpose, we can
    launch any version of our customer service application that implements the preceding
    endpoints, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s go back to our example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can run the REST Client test with the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see the following output in the console:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This means that you managed to run full CRUD operations against the remote
    customer endpoint. As proof of this, you should be able to see the SQL statements
    that were executed on the service console:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Please note that the preceding log requires that you have turned on SQL tracing,
    as discussed in [Chapter 5](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml), *Managing
    Data Persistence with Quarkus*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a comprehensive overview of the MicroProfile specification
    and how to integrate it with Quarkus applications.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We started with an overview of the MicroProfile API and how it fits into the
    overall picture of cloud-based microservices. Then, we covered the major MicroProfile
    specifications.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 MicroProfile API 的概述开始，讨论了它如何融入基于云的微服务整体图景。然后，我们介绍了主要的 MicroProfile 规范。
- en: First, we looked at the Health API and how it can report the liveness and readiness
    of your services. Then, we covered the Fault Tolerance API, which can be used
    to design resilient services. Next, we discussed the application's telemetry data
    and how it can be collected using the Metrics API. Another key aspect we covered
    was documenting of services and tracing the flow of requests, which can be carried
    out using the OpenAPI and tracing specifications. Finally, we learned how to create
    REST clients to simplify our interaction with remote services.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们探讨了 Health API 以及它如何报告你服务的存活状态和就绪状态。然后，我们介绍了容错 API，它可以用来设计具有弹性的服务。接下来，我们讨论了应用程序的遥测数据以及如何使用
    Metrics API 收集这些数据。我们还涉及了另一个关键方面，即服务的文档化和跟踪请求流，这可以通过 OpenAPI 和跟踪规范来实现。最后，我们学习了如何创建
    REST 客户端以简化我们与远程服务的交互。
- en: 'By now, you should have a clear picture of how to design a complete Quarkus
    Enterprise application, although we still haven''t mastered a key aspect: Quarkus
    application security. That''s what we are going to learn about in the next chapter.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对如何设计一个完整的 Quarkus 企业应用程序有了清晰的认识，尽管我们还没有掌握一个关键方面：Quarkus 应用程序安全。这正是我们将在下一章中学习的内容。
