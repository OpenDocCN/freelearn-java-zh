- en: Building Applications Using the MicroProfile API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should have a good understanding of how to use the most common
    Java APIs (CDI, REST, JSON, JPA) in a Quarkus application. In this chapter, we
    will be adding a whole bunch of APIs called the MicroProfile specification. By
    mastering the topics in this chapter, you will be able to shape up components
    that have built upon the core features of the Java EE, which allows for a straightforward
    development experience when implementing microservices, increasing the robustness
    of your applications, and reducing the risk of over-designing and reinventing
    the same patterns. Topics you will learn to include how to add fault tolerance
    and health checks to your services, how to check your service's metrics, how to
    trace and document them, and how to create lean REST clients for your endpoints.
    Other features, such as configuration, security, and Reactive Messaging, will
    be covered in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the MicroProfile API and how it can complement the Enterprise
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the MicroProfile API can fit into your Quarkus projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some exposure on how to run the MicroProfile API in the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06)[.](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter06)
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the MicroProfile API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Enterprise API is a great set of technologies for building applications,
    but it has historically lacked some features that are needed if you want to move
    your application to the cloud. For instance, there is no specific API to handle
    configuration properties that can be injected into your services, nor is there
    a formal way to describe how clients can interact with REST endpoints. Also, it
    would definitely help to include some features so that we can monitor an application's
    health or load-balance requests; these are currently managed by vendors with custom
    technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile project is a collaboration initiative that's driven
    by top application vendors and aims to optimize the Enterprise API for Java applications,
    including all the features we have mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bird''s-eye view of the Eclipse MicroProfile specification shows how rich
    this environment is in the 3.2 release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/351b4899-58e2-40a9-aef0-aa01b8b7acb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we will delve into the following areas of the MicroProfile
    specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Eclipse MicroProfile Configuration**: Provides a unified way to configure
    your services by injecting the configuration data from a static file or from environment
    variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Eclipse MicroProfile Health Check**: Provides the ability to probe the
    state of a service; for example, whether it''s running or not, whether it lacks
    disk space, or whether there is an issue with the database connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Eclipse MicroProfile Fault Tolerance**: Allows you to define a strategy
    in the event of your services failing, for example, configuring timeouts, retry
    policies, fallback methods, and Circuit Breaker processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Eclipse MicroProfile Metrics**: Provides a standard way for MicroProfile
    services to export monitoring data to external agents. Metrics also provide a
    common Java API that exposes their telemetry data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Eclipse MicroProfile OpenAPI**: Provides a set of Java interfaces to
    document your services in a standard way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Eclipse MicroProfile OpenTracing**: Provides a set of instrumentation
    libraries for tracing components such as JAX-RS and CDI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Eclipse MicroProfile Rest Client**: This builds upon the JAX-RS API and
    provides a type safe, unified approach for invoking RESTful services over HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although not discussed in this chapter, Quarkus also supports MicroProfile **JWT
    RBAC**, which outlines a proposal for using **OpenID Connect** (**OIDC**)-based
    **JSON Web Tokens** (**JWTs**) for **role-based access control** (**RBAC**) in
    your service endpoints. In the next chapter, which is about security, we will
    cover this topic in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with MicroProfile projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn about the single MicroProfile API, you will need the following projects,
    which can be found under the `Chapter06` folder in this book''s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fault-tolerance`: A project that shows us how to use the MicroProfile Fault
    Tolerance API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`health`: A project that focuses on the MicroProfile Health Check API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openapi-swagger`: A project that implements OpenAPI interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opentracing`: A project that implements the OpenTracing API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rest-client`: A project that focuses on the MicroProfile REST Client API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the preceding projects are derived from the **customer service** Hibernate
    application that we discussed in [Chapter 5](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml),
    *Managing Data Persistence with Quarkus*. Therefore, a basic requirement is to
    have a PostgreSQL database up and running so that we can run our projects. We
    remind you that this can be done with just a one-line script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we recommend importing the whole `Chapter06` folder into your IDE so that
    you can have the full set of projects at your fingertips as you continue with
    this chapter. That being said, we will start by discussing the MicroProfile Health
    Check API.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile Health Check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the cloud environment, it is essential to allow services to report, and eventually
    publish, the overall health status to a defined endpoint. This can be achieved
    through MicroProfile Health Check, which allows a service to report the overall
    status as `"UP"` if it is available and `"DOWN"` if it is unavailable. This information
    can be collected by a service orchestrator, which can then use the health reports
    to make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put these concepts into practice with the `Chapter06/health` example.
    First off, in order to use the health extension, we have included the following
    dependency in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding library is available, we can add an implementation of the
    `org.eclipse.microprofile.health.HealthCheck` interface, which allows us to check
    the service status. The following is the `DBHealthCheck` class, which verifies
    the status of the PostgreSQL database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This class contains two core implementations of the MicroProfile specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have the `@Health` annotation, which works in combination with
    the `@ApplicationScoped` CDI context to return the health status check each time
    a request to `http://localhost:9080/health` is received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This class also uses the **MicroProfile Configuration API** to inject the PostgreSQL
    database host and port it into the bean. The following is an excerpt from the
    `application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if the `POSTGRESQL_SERVICE_HOST` and `POSTGRESQL_SERVICE_PORT`
    environment variables aren't set, the default values (`localhost` and `5432`)
    are used and stored in the `db.host` and `db.port` variables.
  prefs: []
  type: TYPE_NORMAL
- en: The target host and port are reached via a TCP socket and, on a successful attempt,
    a `responseBuilder.up()` will be returned. Otherwise, `responseBuilder.down()`
    will indicate a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start the Quarkus project with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, assuming that the database is up and running, let''s try to access the
    `http://localhost:9080/health` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The response acknowledges the status of the database connection. Let''s also
    verify the condition where the database is unavailable. A simple *Ctrl* + *C*
    from the PostgreSQL shell will send the appropriate signal to stop the process.
    You should see the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check the status of the database connection through the `/health` endpoint
    once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding output, the JSON that was returned changed
    the status to `"DOWN"` and set the error message in the error field. This example
    sets our first milestone: checking the application''s health. We can further refine
    our health check policies by using liveness and readiness checks, which we will
    discuss in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Using liveness and readiness checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the newest MicroProfile specifications, health checks are now
    to be used with a more specific model to help us determine the cause of potential
    issues. Therefore, it''s recommended you migrate the legacy `@HealthCheck` to
    one of the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readiness checks**: This check can indicate that a service is *temporarily*
    unable to serve traffic. This can be due to, for example, the fact that an application
    may be loading some configuration or data. In such cases, you don''t want to shut
    down the application but, at the same time, you don''t want to send it requests
    either. Readiness checks are supposed to cover this scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liveness checks**: Services running 24/7 can sometimes undergo a transition
    to broken states, for example, because they have hit `OutOfMemoryError`. Therefore,
    they cannot recover except by being restarted. You can, however, be notified of
    this scenario by defining a liveness check that probes the liveness of the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to implement both checks, you can simply replace the `@org.eclipse.microprofile.health.HealthCheck`
    annotation with more specific ones, such as `@org.eclipse.microprofile.health.Liveness`
    and `@org.eclipse.microprofile.health.Readiness`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have implemented a `@Readiness` check to verify
    whether a lock file exists (for example, due to a pending task) and emit a `"DOWN"`
    status when this file is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Readiness checks are verified through the `"/health/ready"` URI. You can check
    this by requesting the following URL: `http://localhost:8080/health/ready`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If no file has been detected, you will see something similar to the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s learn how to add a **liveness check** to our services. We will
    check the amount of free memory that''s needed to run the service and return a
    liveness check based on a certain memory threshold, which we have set to one gigabyte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now verify the service''s liveness with cURL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the default Quarkus JVM settings don''t permit the amount of memory we
    have set in the threshold, the status of the service will indicate `"DOWN"`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on to the next API in our checklist, it is worth checking how
    health checks can be triggered in a cloud environment using Kubernetes probe checks.
    We'll learn how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Letting OpenShift manage unhealthy services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the examples so far, we have seen how to detect different health checks
    scenarios. One of the greatest advantages of running a Kubernetes native environment
    is that you can react automatically to changes in an application''s status. More
    specifically, it is possible to probe the following checks through the application''s
    deployment descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Liveness probe**: Kubernetes provides a liveness probe to determine whether
    the container that it''s been configured in is still running. Should the liveness
    probe fail, the `kubelet` agent kills and restarts the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readiness probe**: Kubernetes provides the readiness probe to signal that
    an application is temporarily unable to serve traffic, for example, because a
    configuration is being loaded. In such cases, you don''t want to stop the application,
    but you don''t want to allow any requests in either.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, the preceding probes match the MicroProfile Health Checks that
    were defined in the latest specifications. As a proof of concept, we will be deploying
    our example application into MiniShift as a binary build. As usual, we will start
    by creating a new project from the shell (or the web console, if you prefer doing
    things this way):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may remember, we need to add a PostgreSQL application to our project
    that will be found by our checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can finally push the Quarkus MicroProfile Health application we have
    just built onto the cloud. The following script will be used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script should be nothing new for you, so let''s move on to the
    OpenShift console, where we can check the status of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eef95c5f-57dd-4533-a4a0-80598369ae3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, check the Deployments configuration of your project and select Edit Health
    Checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/348a0741-0c6f-4edf-ae16-1e287bf36a25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the Health Checks UI, you can choose which health check you want to
    add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4f8967f-2381-47f9-94b6-65276b858b5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the Readiness Probe. By selecting it, you will be taken to
    the following UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2c33096-b028-4abc-a5d9-7919c20e2abf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The key parameter to select is Path, which should match our MicroProfile readiness
    URI (`health/ready`). Apart from that, you can also configure the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialDelaySeconds`: The number of seconds after the container has started
    before liveness or readiness probes are initiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeoutSeconds`: The number of seconds after which the probe times out. Defaults
    to 1 second. The minimum value is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s configure the Liveness Probe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c71efc35-bf5a-4a38-a28f-00737791e70b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Except for Path, which will be `health/live`, we can leave the other default
    values. Save your changes as-is. Now, let''s try to break a few things. For example,
    we will create a lock file in the Pod where the application is running. This will
    immediately trigger a failure in the readiness probe. Let''s check a list of Pods
    from the shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output that''s returned is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we will now run a remote shell against this running Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We're in. Now, create a file named `/tmp/tmp.lck`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In a couple of seconds (depending on the initial delay setting), your Pod won''t
    be available anymore. You can see this from the Overview panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a963448a-8234-4c0d-905a-a05137b354dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This change will also be reflected in system events, which can be captured
    through the `oc get events` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s worth mentioning that our application also includes a liveness
    check, which verifies that the amount of available memory is greater than a certain
    threshold. Whether you have hit the threshold or not, the liveness probe depends
    on the amount of memory allowed at startup for MiniShift. A digression into OpenShift''s
    application memory sizing would take us beyond the scope of this book, but it''s
    worth reading more about it by looking at the official docs: [https://docs.openshift.com/container-platform/3.9/dev_guide/application_memory_sizing.html](https://docs.okd.io/latest/dev_guide/application_memory_sizing.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining your application's status so that it's healthy is a key element
    to consider when designing your applications. On the other hand, enabling your
    services to react to failures or performance degradation is no less important.
    Don't worry, though â€“ the next section will teach you how to handle failures using
    the MicroProfile Fault Tolerance API.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile Fault Tolerance API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Fault Tolerance** specification is a fundamental API that can be used
    to handle the unavailability of your microservices by endorsing a set of policies
    that can improve the resiliency of your applications. The following fault tolerance
    policies are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeout**: Defines a timeout for the execution of a service call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fallback**: Provides a contingency solution when a failure occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retry**: Allows you to retry execution based on criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulkhead**: Isolates partial service failures while the rest of the system
    can still work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit Breaker**: Defines criteria for automatic fast-fails to prevent system
    degradation caused by overloading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous**: Allows us to invoke an operation asynchronously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at these concepts in practice by using the `Chapter06/fault-tolerance`
    example. First off, in order to use the fault-tolerance extension, we have included
    the following dependency in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with the Timeout, Fallback, and Retry policies, which are commonly
    used together since they complement each other.
  prefs: []
  type: TYPE_NORMAL
- en: Using Timeout, Fallback, and Retry to create resilient services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simple terms, the `@org.eclipse.microprofile.faulttolerance.Timeout` annotation
    can be used to specify the maximum time (in ms) allowed for returning a response
    in a method. Here is an example `findAll` method that times out after 250 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The random sleep that's triggered by the finder method can be used to allow
    some occasional execution failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mitigate time-outs or other failures, you can decorate your methods
    with the `@Fallback` policy so that you can specify an alternate execution path
    in the case of failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are redirecting the execution to the `findAllStatic` method
    if any failure arises in the `findAll` method. The `findAllStatic` method will
    return a static list of `Customer` objects (please check the source code example
    for this chapter to see the implementation of this).
  prefs: []
  type: TYPE_NORMAL
- en: Applying a retry policy to your failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, failures in the execution of your methods are caused by temporary
    issues such as network congestion. If we are confident that the issue can be resolved
    in accordance with our business SLA, we can include a `@Retry` annotation to allow
    us to reiterate the execution of failed methods a certain number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, by adding the `@Retry(maxRetries = 3)` annotation, we will attempt
    to load data from the database three more times before using a static list of
    customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth mentioning that the `@Retry` annotation can be configured to retry
    only a subset of specific exceptions. This can be seen in the following example,
    where we''re using `@Retry` over `RuntimeException` and `TimeoutException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's learn how to apply a fault tolerance pattern named **Circuit Breaker**
    to our services.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit Breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Circuit Breaker** is a core pattern for creating resilient services. It can
    be used to prevent repeatable exceptions by instantly denying new requests. The
    MicroProfile Fault Tolerance API uses the `@CircuitBreaker` annotation to control
    incoming requests. A software Circuit Breaker is similar to an electrical circuit
    breaker since it has the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closed state**: A closed-circuit represents a fully functional system that''s
    available to its clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half-open circuit**: When some failures are detected, the state can change
    to half-open. In this state, it checks whether the failed component is restored.
    If so, it closes the circuit. Otherwise, it moves to an open state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open state**: An open state means the service is temporarily disabled. After
    checks have been made, you can verify whether it''s safe to switch to a half-open
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `@CircuitBreaker` policy applies to the `findAll`
    method of the `OrderRepository` class. Because of that, if, within the last four
    invocations, 75% failed, then the circuit transits to an open state. The circuit
    will stay open for 1,000 ms. When a circuit is open, a `CircuitBreakerOpenException`
    will be thrown instead of actually invoking the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that, like the retry method, the `@CircuitBreaker` also allows
    us to define failure criteria through the `failon` annotation parameter. This
    can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if a `RuntimeException` is thrown in the method, then
    the execution is counted by the `CircuitBreaker` as a failure; otherwise, it is
    counted as a success.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the background of the core Fault Tolerance API, let's
    learn how to further enhance our application's robustness with bulkhead and asynchronous
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous and bulkhead policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is not a new pattern for Enterprise developers. However,
    when used in combination with the `BulkHead` policy, you can achieve a powerful
    fault tolerance pattern for your microservices. In a nutshell, if you annotate
    a method with `@Asynchronous`, it will be executed asynchronously on a separate
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are performing some logic in the `createOrder`
    method, which spins off some debugging in a separate thread by means of the `writeSomeLogging`
    method, which returns a `CompletableFuture` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When `@Bulkhead` is used with `@Asynchronous`, the thread pool isolation approach
    will be used. The thread pool approach allows us to configure the maximum concurrent
    requests together with a certain queue size, just like a semaphore. Here is the
    updated example, which includes the `@Bulkhead` policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That was a whirlwind tour of the fault tolerance policies that are available
    in the MicroProfile API. Let's move on to the next section, which is about capturing
    service metrics.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile Metrics API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MicroProfile Metrics specification provides us with a unified way of exporting
    your services' monitored data to management agents. This helps us perform proactive
    checks on some key statistics indicators, such as the number of times and the
    rate at which a service has been requested, the duration of each request, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get coding. Here, we will focus on the `Chapter06/metrics` example.
    First off, in order to use the metrics extension, we have included the following
    dependency in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll provide an overview of the metrics annotations that have been added
    on top of our REST service. Let''s start with the `@Counted` annotation, which
    tracks how many times a request has been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Within the `@Counted` annotation, we have provided a description and set the
    `absolute` flag to `true`, which means the class's package name will not be prepended
    to the metric name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile and run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s reload the home page, which will trigger a list of customers. Next,
    we''ll gather some metrics. There are two entry points for our metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/metrics`: This endpoint will return all the metrics,
    including system metrics where the application is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/metrics/application`: This endpoint will just return
    metrics that are emitted by the applications that have been deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will choose the latter option here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have loaded the home page twice, the expected output should be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The next annotation is the `@Timed` annotation, which keeps track of the duration
    of an event. Let''s apply it to the `getAll` method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to retrieve a detailed report about the invocation rates
    of the preceding method (which includes rate/sec, rate/min rate/5 min, plus statistics
    quantile metrics). For the sake of brevity, here is an excerpt from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you need just a basic metric that records a single unit
    of data, you can use the `@Gauge` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The Gauge metric will display the following metric after two requests have
    landed on the preceding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After this fast-paced introduction to MicroProfile metrics, let's learn how
    to document our endpoint resources with OpenAPI and Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OpenAPI and the Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenAPI specification aims to provide a set of Java interfaces and programming
    models that can natively produce OpenAPI v3 documents from JAX-RS services. The
    default OpenAPI implementation in Quarkus provides an out-of-the-box standard
    documentation for all the exposed services that can be generated through the `/openapi`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, you can augment JAX-RS services even further using specific annotations
    to provide more insights about the endpoint, its parameters, and the response.
    Moving on to the code, we will focus on the `Chapter06/openapi-swagger` example.
    As you can check from its configuration, we have added the following extension
    to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have several REST endpoints available in our project, we can check
    the generated OpenAPI document at `http://localhost:8080/openapi`. Here is the
    (truncated) output for our customer service application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with minimal effort we have produced a JSON document that describes
    the functionalities of our service without requiring direct access to the underlying
    source code or any other documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, the OpenAPI can be used as a foundation for powerful UIs such
    as **Swagger**, which is a great tool for visualizing and interacting with your
    APIs. Its UI is automatically generated from your OpenAPI specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get rolling with Swagger, you just need to point to `http://localhost:8080/swagger-ui/`.
    By doing this, you will end up on the Swagger home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1942eb14-4dad-43ba-8e5a-314f26f77855.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, you can easily test any available operation by expanding it and
    clicking on the Try it out button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06531d2f-64d8-4344-b902-700c831b7335.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A default Response body will be generated. Adjust it to your needs and click
    on Execute. As a result, you will see the returned value (if any) from our operation
    in the Response body text area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3f519f9-8d83-4db2-baf9-aa6ecf4ca03b.png)'
  prefs: []
  type: TYPE_IMG
- en: Optionally, you can click on the Download button to save the response locally.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the output of OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the OpenAPI specification ([https://swagger.io/specification/](https://swagger.io/specification/)),
    it is possible to customize the full schema of objects that are returned by the
    `/openapi` Servlet. This can be done by adding specific annotations to your endpoints
    classes and methods. Although none of these annotations are mandatory, we will
    mention some common ones that can improve the readability of your OpenAPI schema.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `@org.eclipse.microprofile.openapi.annotations.tags.Tag` annotation
    can be used as a qualifier to describe a group of specific operations related
    to the endpoint. This annotation can be applied at the class level. In order to
    describe a single resource method, you can use the `org.eclipse.microprofile.openapi.annotations.Operation`
    tag, which can be applied at the method level. Then, a description of the operation
    parameters can be included with the `org.eclipse.microprofile.openapi.annotations.parameters.Parameter`
    tag. Finally, the `org.eclipse.microprofile.openapi.annotations.responses.APIResponse`
    tag describes a single response from an API operation. You can attach multiple
    `APIResponse` annotations to a single method to control the response for each
    response code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the customization being applied to the `CustomerEndpoint`
    class in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of brevity, we have just tagged the `CustomerEndpoint` service
    with OpenAPI annotations. We leave it to you to update the `OrderEndpoint` service
    so that you can verify your new skills.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile OpenTracing API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed tracing plays a key role in the era of microservices as it lets
    you trace the flow of a request across different services. In order to accomplish
    microservice tracing, we can instrument our services to log messages to a distributed
    tracing server that can collect, store, and display this information in various
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenTracing` specification does not address which distributed system is
    in charge of collecting the tracing data, but a widely adopted end-to-end open
    source solution is **Jaeger** ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)),which
    fully implements the `OpenTracing` standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see OpenTracing in action by switching to the `Chapter06/opentracing`
    example. First off, in order to use the opentracing extension, the following dependency
    must be added to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As a matter of fact, when adding this extension, an implementation of an `io.opentracing.Tracer`
    object will be made available to your application. This means that all your HTTP
    requests will be automatically traced.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of configuration, we need to provide some details about the Jaeger
    endpoint. This can be done either with the `application.properties` file or using
    environment variables. The following shows how we have configured the `application.properties`
    file to emit a tracing notification to a Jaeger endpoint running on localhost
    and listening to port `14268`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Within the preceding configuration, we have also defined the service name (`quarkus-service`)
    and the sampler type. In the sampler type definition, `"` always makes the same
    decision for all traces. It either samples all the traces (`sampler-param=1`)
    or none of them (`sampler-param=2`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start the Jaeger service. The simplest way to do this is by running
    it as a Docker container. The following command will start the `jaegertracing/all-in-one`
    container image, forwarding the UDP/TCP port of the Docker container to localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start using our customer service application and execute some operations
    with it. Then, we can log into the Jaeger console, which is available at `http://localhost:16686`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72bfbd3e-f95b-437c-b209-19486cc6bb9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, in the left panel of the Jaeger UI you
    can see a combo box named Service, which contains a list of the services that
    are available for tracing. You should see in it the default jaeger query service,
    which allows us to trace the query service. Provided that you have configured
    your Quarkus application to emit notifications, you should be able to see quarkus-service
    enlisted. Select it and then check the next combo box, which is Operation. This
    combo box contains all the operations that have been traced for that particular
    service. Here is a partial view of the UI that contains the combo box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48b7e635-2b1b-4f4c-b45e-26d633a4da4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you select all, on the screen you should be able to see all the traces for
    all the HTTP requests to `quarkus-service`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/987aa7b9-6cae-46fd-b2ee-c646f35ef20f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, you can choose to gather more details about a single trace by clicking
    on it. You will see a comprehensive timeline with details such as the execution
    time, remote caller, and errors reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/283fb5ff-3c3d-4ffd-a78c-8507dc2dd1c1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to download and elaborate on the trace file, you can also choose
    to trace your operation as JSON by selecting Trace JSON in the top-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of possibilities for tracing your application with Jaeger.
    We advise referring to [https://www.jaegertracing.io/](https://www.jaegertracing.io/)
    if you want to become a ninja at tracing your microservices!
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile REST Client API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last MicroProfile extension we will discuss in this chapter is the REST
    client extension. The goal of this API is to provide you with a type safe way
    to invoke REST services in a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t confuse the MicroProfile REST client API with the JAX-RS Client API!
    They implement different standards: the JAX-RS Client API is implemented according
    to JSR 370 ( [https://www.jcp.org/en/jsr/detail?id=370](https://www.jcp.org/en/jsr/detail?id=370)),
    while the MicroProfile REST Client API follows the standard specified here: [http://microprofile.io/project/eclipse/microprofile-rest-client](http://microprofile.io/project/eclipse/microprofile-rest-client).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to learn about the REST client API, we will be using it as a template
    for the `Chapter06/rest-client` application. This project is nothing but a cut-down
    version of our customer service, which just contains interfaces instead of service
    implementations. In terms of configuration, we have added the following dependency
    to the `pom.xml` file of our `rest-client` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have replaced the concrete service implementations with two interfaces:
    one named `CustomerEndpointItf` and another named `OrdersEndpointItf`. Here is
    `CustomerEndpointITf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `OrdersEndpointItf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `@org.eclipse.microprofile.rest.client.inject.RegisterRestClient`
    annotation, which makes the REST client injectable through the CDI using the `@org.eclipse.microprofile.rest.client.inject.RestClient`
    annotation. Let''s learn how to do this in practice in the `CustomerEndpoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have replaced the REST client implementation by delegating
    the execution to the interface we have registered as a REST client. At this point,
    you may be wondering how the REST client knows about the remote endpoint. That''s
    a good question, and the answer is contained in the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the first line, all the requests to the REST client interface
    will result in a call to the remote endpoint base URL, which is qualified using
    the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Also, the default scope of the REST client interface has been configured as
    a **singleton**, which instructs Quarkus to instantiate the singleton once, passing
    its reference to other objects during the injection. Other supported scope values
    are `@Dependent`, `@ApplicationScoped`, and `@RequestScoped`, the latter being
    the default one. Check the CDI specifications for more details about the different
    scopes ([http://www.cdi-spec.org/](http://www.cdi-spec.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run the test, we need an application that returns a list of `Customers`
    through the `http://localhost:8080/customers` endpoint and a list of `Orders`
    through the `http://localhost:8080/orders` endpoint. For this purpose, we can
    launch any version of our customer service application that implements the preceding
    endpoints, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the REST Client test with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that you managed to run full CRUD operations against the remote
    customer endpoint. As proof of this, you should be able to see the SQL statements
    that were executed on the service console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding log requires that you have turned on SQL tracing,
    as discussed in [Chapter 5](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml), *Managing
    Data Persistence with Quarkus*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a comprehensive overview of the MicroProfile specification
    and how to integrate it with Quarkus applications.
  prefs: []
  type: TYPE_NORMAL
- en: We started with an overview of the MicroProfile API and how it fits into the
    overall picture of cloud-based microservices. Then, we covered the major MicroProfile
    specifications.
  prefs: []
  type: TYPE_NORMAL
- en: First, we looked at the Health API and how it can report the liveness and readiness
    of your services. Then, we covered the Fault Tolerance API, which can be used
    to design resilient services. Next, we discussed the application's telemetry data
    and how it can be collected using the Metrics API. Another key aspect we covered
    was documenting of services and tracing the flow of requests, which can be carried
    out using the OpenAPI and tracing specifications. Finally, we learned how to create
    REST clients to simplify our interaction with remote services.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should have a clear picture of how to design a complete Quarkus
    Enterprise application, although we still haven''t mastered a key aspect: Quarkus
    application security. That''s what we are going to learn about in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
