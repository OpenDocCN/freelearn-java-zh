- en: An Introduction to the Akka and Actor Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about the actor model and how it is implemented
    in Akka. We'll make ourselves familiar with Akka by building a simple yet complete
    actor system. We will then learn how to create an actor system and actors, pass
    messages between them, make use of location transparency and remoting, properly
    structure the system for effective supervision, and look at how **finite-state
    machine** (**FSM**) actors work. Finally, we'll show you how to test actor-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The actor model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of Akka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Akka FSM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Akka remoting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the installation instructions in [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you need to perform a first-time
    setup of Java or SBT.
  prefs: []
  type: TYPE_NORMAL
- en: The source code is available on our GitHub repository at: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the actor model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the first days of computing applications of all kinds, they have faced
    growing demands for processing increasing volumes of data within diminishing processing
    times. Up until recently, these challenges were addressed by scaling applications
    vertically, by adding more memory and higher speed processors. This approach was
    possible because of growing processor speed, which is described by Moore''s law
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Moore''s law is the observation that the number of transistors in a dense
    integrated circuit doubles about every two years. ... Moore''s prediction proved
    accurate for several decades, and has been used in the semiconductor industry
    to guide long-term planning and to set targets for research and development. ....
    Moore''s law is an observation and projection of a historical trend and not a
    physical or natural law."'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the pace of advancement in hardware started to slow down, as stated by
    Intel in 2015\. This trend made it obvious that the only way to scale applications
    from now on was via horizontal scalability—by increasing the number of processing
    cores and machines which are to process data in parallel by using multiple application
    threads. Two obvious challenges in this situation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent concurrent modification and, as a result, corruption of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide access to the data for processes running on different cores or machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first challenge is traditionally solved by using shared memory and different
    locking approaches. Unfortunately, this approach effectively makes the parts of
    the application that are synchronizing with each other pseudo-sequential, which
    in turn limits possible speedup in accordance with Amdahl''s law:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Amdahl''s law is a formula that gives theoretical speedup in terms of latency in the
    execution of a task at the fixed workload that can be expected of a system whose
    resources have been improved.  ... Amdahl''s law is often used in parallel computing to
    predict the theoretical speedup when using multiple processors."'
  prefs: []
  type: TYPE_NORMAL
- en: The most important corollary is that the speedup is limited by the serial part
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are other solutions that make it possible for different parts
    of the program to work together toward the same goal in parallel. One of these
    approaches is the actor model. Fortunately, the actor model also addresses the
    second challenge with a concept known as **location transparency**.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of actors was first introduced in 1973 by *Carl Hewitt*, *Peter
    Bishop*, and *Richard Steiger*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Carl Hewitt, Peter Bishop, and Richard Steiger: A Universal Modular Actor Formalism
    for Artificial Intelligence. In: Proceeding IJCAI''73 Proceedings of the 3rd International
    Joint Conference on Artificial Intelligence. 1973, S. 235–245 ([https://dl.acm.org/citation.cfm?id=1624804](https://dl.acm.org/citation.cfm?id=1624804)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that everything is represented as an actor, which is a basic computational
    entity. Actors communicate with each other using messages. In response to a message,
    an actor can undertake any of the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Send a finite number of messages to other actor(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a finite number of other actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change its behavior for the next message to be processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This definition is quite abstract, but already allows you to recognize a couple
    of constraints that the implementation must satisfy:'
  prefs: []
  type: TYPE_NORMAL
- en: Actors communicate using messages and are not allowed to expose or inspect the
    internal states of each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared mutable state has no place in the actor model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Side-effects are not mentioned in this definition, but they are obviously the
    end goal of any system. Therefore, an actor''s response to the message might be
    any combination of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing internal state
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifying behavior
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Producing side-effects
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Actors need to be able to address each other. Consequently, a naming system
    is expected to exist. Having an appropriate naming system is a prerequisite for
    location transparency, meaning that every actor can be addressed by some canonical
    name regarding its actual location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding definition also leaves the following questions unanswered, among
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: What would be an effect of the limitations of the underlying hardware, operating
    system, and runtime environment?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do actors coexist and how is the first actor created?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are messages delivered from one actor to another?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are actors mortal, and if yes, how do they die?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most prominent languages that use the actor model are Erlang, Io, D, Pony,
    and Scala.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a closer look at the Scala implementation—Akka—by building an enterprise bakery
    application. Our bakery will be crowded by different actors, each with their own
    responsibilities, producing cookies as a result of their teamwork.
  prefs: []
  type: TYPE_NORMAL
- en: Akka basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by adding an Akka dependency into the `build.sbt` file of an
    empty Scala SBT project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `akkaVersion` could be looked upon the Akka website. At the time of writing
    this book, it was 2.5.13, so we would prepend `val akkaVersion = "2.5.13"` to
    the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SBT can create a minimal Akka project for you via a giter8 template: `sbt
    new https://github.com/akka/akka-quickstart-scala.g8`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can instantiate an `ActorSystem`, which is the place where Akka''s
    actors live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Avoid defining multiple actor systems in the same JVM or even on the same machine.
    An actor system is not very lightweight and is usually configured to closely reflect
    the hardware configuration it is running on. Thus, multiple actor systems will
    not only consume more resources than needed but, in the worst case, they will
    compete for these resources.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to create a default actor system without providing a name,
    but it would be best if you don't do this. Naming the actor system and actors
    will make your life easier while you reason about it and debug existing code.
  prefs: []
  type: TYPE_NORMAL
- en: As a next step, let's define an actor.
  prefs: []
  type: TYPE_NORMAL
- en: Defining actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An actor in Akka must extend traits of the same name and implement the `receive` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The type of the `receive` action is defined as `type Receive = PartialFunction[Any,
    Unit]`, which closely resembles the abstract definition of an actor model. In
    Akka, actors can receive any message, and any of the actor's activities are manifested
    as a change in its state or as a side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: Our defined actor accepts any message and does nothing. This is probably the
    simplest and laziest actor possible.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make it useful, let's define its behavior and vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''re building an enterprise bakery, our actors will have a single responsibility,
    which is also a good idea in any kind of system, not just one that''s actor-based.
    Our cook actor will take a ready-made dough and make raw cookies out of it. First,
    we must define the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And then the behavior of the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things going on in this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Our actor understands only one message type, `Dough`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It *makes* raw cookies out of dough by calculating their number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're using `sender()` to obtain a reference to the actor from which the received
    message is originating and send the response to this reference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, some more subtle details are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: If, by coincidence, our `Cook` will get any other message except `Dough`, this
    message won't be handled by the actor and will be lost. Akka has a special mechanism
    for such messages called *dead message queue*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined case classes for each message type to make understanding the code
    less complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actor's logic is decoupled from the protocol and can be extracted into the
    companion object. This is done to make testing easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a definition of the actor, it is time to instantiate it and
    send some messages to it. In Akka, we have to use a special `Prop` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to pass any constructor parameters to the actor in this case and
    therefore we can benefit from using the `Props` form, which takes a sole type
    of an actor as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Don't construct actors directly using a class constructor. It is possible to
    do so and then obtain the *ActorRef* from the actor, but this will result in an
    error at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can bring everything together and send out our first message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a named actor using an actor system and sent one message to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a couple of other actors to make our bakery lively. We will separate
    the responsibilities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A boy will visit the groceries store and get the necessary ingredients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He will hand them over to the bakery manager so that they can check the amount
    and quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ingredients are then given to the chef, who prepares a dough out of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chef uses one or more mixers depending on the volume of the dough.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ready dough is given to the cook, who prepares the raw cookies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The raw cookies are baked by the baker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The baker uses the oven for baking. It might take a couple of rounds to bake
    all of the cookies because of the oven's limited size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cookies are returned to the manager as soon as they are ready.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we need to figure out the relationships between actors, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5611e12b-1d43-48ae-86fa-bcbe72d7e94d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And then we need to build and show the message flow among them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d1d019c-d38b-4eba-b523-2a61324d2cdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll build our actor hierarchy from the bottom up, starting from the oven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a number of new features here.
  prefs: []
  type: TYPE_NORMAL
- en: First, we defined two new message types that will be used to command an oven
    to return cookies and make a container for the ready cookies. In the actor itself,
    we're using a constructor parameter to specify how many cookies will fit inside
    it. We're also using Akka's `LoggingReceive`, which writes incoming messages into
    the log. In the `receive` method itself, we stick to the principle of separating
    Akka semantics from the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: The `insert` method checks whether the oven is empty and places as many raw
    cookies as possible into it, optionally returning these which don't fit inside back,
    so that we can forward them to the sender.
  prefs: []
  type: TYPE_NORMAL
- en: In the `extract` method, we modify the number of cookies inside the oven and
    return them to the sender.
  prefs: []
  type: TYPE_NORMAL
- en: Having `var` inside of an actor is absolutely safe and illustrates one of the
    core features of Akka features—messages are processed by actors one-by-one in
    the order they are received. Even in a highly concurrent environment, Akka shields
    actor code from any concurrency-related matters.
  prefs: []
  type: TYPE_NORMAL
- en: Always use deeply immutable messages. Using mutable structures will allow two
    different actors to access the same data from different threads, which can lead
    to concurrent modifications and corrupt data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instantiate an oven, we''ll use another flavor of the `Prop` constructor,
    which allows us to define constructor parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By convention, it is placed into the companion object of an actor. The `size`
    of the oven is defined here as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, we''ll describe the user of the oven, that
    is, the `Baker` actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a closer look at what is going on here. First, we need to use yet
    another kind of `Props` constructor because Akka does not support constructors
    with default parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '`Props`, along with the instance, is a very powerful construct that allows
    you to create anonymous actors which in turn can close over the internal state
    of another actor. Try to avoid using it, if possible.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Baker` actor receives an `ActorRef` of the `Oven` as a parameter. This
    reference is used by the baker to send cookies to the `Oven` and extract them.
  prefs: []
  type: TYPE_NORMAL
- en: After receiving the baked cookies from the `Oven`, the `Baker` looks up the
    `Manager` actor and sends the `Cookies` to it. After that, it puts another batch
    of raw cookies into the `Oven`, if needed. We will discuss the intrinsics of `context.actorSelection`
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `Baker` maintains an internal queue of raw cookies and periodically puts
    them into the oven. This is an old oven, and to use it, we need set up a kitchen
    timer in order to extract the baked cookies at the proper time. Finally, we include
    a `postStop` life cycle hook for the timer in order to cancel it if our actor
    stops. We have done this because, if the actor is no longer there, there will
    be no one around to listen out for the timer signal.
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle of an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actors in Akka define a number of methods which are called at different moments
    during their lifetime, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`preStart`: Called after the actor is started or during restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preRestart`: Called on the actor which is about to be destroyed because of
    the restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postRestart`: Called on the actor who was just created after the restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postStop`: Called after the actor is stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The order of execution, given two instances of the same actor—one that has
    failed and another one that has been created as a replacement—is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Actor A, stopping: `constructor` | `preStart` | `preRestart` | `postStop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actor B, starting: `constructor` | `postRestart` | `preStart` | `postStop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can implement a `Chef` actor.
  prefs: []
  type: TYPE_NORMAL
- en: This actor will combine ingredients to produce dough. It will use its magical
    powers to create a `Mixer` and will use this `Mixer` to do the actual blending
    work. One `Mixer` has limited capacity, and so the `Chef` will need to create
    multiple mixers for bigger shopping lists and use them in parallel in order to
    speed up the preparation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining a mixer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Mixer` only understands a single type of message, `Groceries`. After getting
    this type of message, it produces a certain amount of `Dough` by mixing all of
    the ingredients together and returns it to the sender. `Thread.sleep` represents
    blocking—waiting for the hardware to complete its operation.
  prefs: []
  type: TYPE_NORMAL
- en: Try to avoid blocking. Blocking in the actor consumes a thread, and if many
    actors have blocked, other actors will be starved for threads and won't be able
    to process messages.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, in our case, blocking is unavoidable during the mixing operation
    because of hardware limitations. Akka offers a solution to this problem in the
    form of dispatchers.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dispatchers are the machinery that makes actors work. They are responsible
    for assigning CPU to the actors, managing actor''s mailboxes, and passing over
    messages from the mailbox to an actor. There are four commonly used types of dispatchers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default dispatcher: **This dispatcher creates one mailbox per actor and may
    be shared by any number of actors. It uses `java.util.concurrent.ExecutorService`
    for this process. It is designed to be used in combination with actors having
    a nonblocking code. The dispatcher selects an idle thread and assigns it to an
    actor of its choice. The actor then processes a certain number of messages before
    releasing the thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Balanced dispatcher: **This dispatcher creates a single mailbox that can
    be shared by multiple actors of the same kind. Messages from the mailbox are distributed
    among actors sharing the dispatcher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pinned dispatcher: **This dispatcher uses a thread pool with a single thread.
    This thread is assigned to a single actor. Thus, each actor has its own thread
    and mailbox, and can perform blocking or long-running activities without starving
    other actors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CallingThread dispatcher: **This dispatcher assigns one thread per actor.
    This is mainly used for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, the `Mixer` has a blocking call in its implementation. Because
    of this, we are better off with the pinned dispatcher. First, we''ll add a dispatcher
    configuration to `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The name of the dispatcher is defined at the root level of the configuration
    and isn't nested into the `akka` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Akka uses Typesafe Config as a configuration library. It is a very powerful
    and useful configuration facility that's absolutely worth checking out. You can
    find it at [https://github.com/lightbend/config](https://github.com/lightbend/config).
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we can use the configured dispatcher at the moment we create an actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This way, each of the mixers will have its own thread, and blocking will not
    affect its siblings and other actors in the system.
  prefs: []
  type: TYPE_NORMAL
- en: After waiting, the mixer returns the produced dough to the `sender()` and sends
    itself a `PoisonPill` so that it can terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of ways to stop an actor in Akka. The most direct approach
    involves calling the `stop` method of the context, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The actor terminates asynchronously after it finishes processing its current
    message, but not after other messages in the inbox. This contrasts to sending
    an actor a `PoisonPill` or `Kill` message, which is enqueued into the mailbox
    and processed in an orderly fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The `Kill` message will cause an actor to throw an `ActorKilledException`, which
    in turn will involve its supervision chain (more on that topic later in this chapter)
    to decide how this actor's *failure* should be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping an actor using a `context` or `PoisonPill` in contrast to `Kill` is
    done gracefully. The actor will stop all of its children, execute life cycle hooks,
    and inform its supervisor appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The actor's termination is propagated top-down, but the actual stopping occurs
    bottom-up. One slow actor that takes a long (or infinite) time to stop can prevent
    the whole chain of actors from being terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our blocking `Mixer`, it is time to define a `Chef`:'
  prefs: []
  type: TYPE_NORMAL
- en: The ask pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `Chef`, we will introduce another popular pattern in Akka—the ask
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of things happening here, so let's go over the code line by line
    and describe what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Chef` actor is not only an `Actor`—but it also extends `ActorLogging` and
    `Stash`. The `ActorLogging` trait gives an actor a predefined `logger`.  It is
    also possible to define the `Logger` directly, for example, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Akka uses a special message-based logging facility internally to minimize blocking
    inside of an actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Akka logging supports SLF4J as a backend. The official documentation ([https://doc.akka.io/docs/akka/2.5/logging.html](https://doc.akka.io/docs/akka/2.5/logging.html))
    has a detailed explanation on how to extend the configuration to enable SLF4J
    logging into an Akka application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a timeout of 5 seconds, which will be necessary the moment
    we start working with mixers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `receive` method, our actor only accepts `Groceries` messages and uses
    pattern matching to extract field values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our mixers are small, so we need to split the groceries at hand into portions
    of one egg so that the portion fits into the mixer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `Mixer` actor using the `props` defined earlier (which in
    turn assigns the proper dispatcher to it) and named it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following two lines of code, we can see implicit `ask` magic at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Having to `ask` in scope allows us implicitly to convert an `ActorRef` into
    `AskableActorRef`, which is then used as a target for the message. The `actor
    ? message` syntax represents the ask pattern. Akka sends a message to the target
    actor and creates an expectation of the response as a `Future[Any]`. This `Future`
    can be worked with like any other `Future`. For convenience, Akka provides a `mapTo[T]` method,
    which allows you to convert it into the `Future[T]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of code in the `for` comprehension uses another implicit conversion
    provided by Akka, this time acting on the `Future`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're bringing in scope a `pipe` which transforms the normal `Future` into
    the `PipeableFuture`. The latter can be piped into one or multiple actors, as
    shown in the third line of the preceding code, by using an implicit execution
    context that was imported in the second line.
  prefs: []
  type: TYPE_NORMAL
- en: The third line of code pipes the result of the `Future` execution to the sender
    in the case of it being a success.
  prefs: []
  type: TYPE_NORMAL
- en: We could use `job.recoverWith` to resend the job to the mixer if the first attempt
    fails. This is a simple way to implement "at least once" semantics using the ask
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having created all of the mixers and sent them work packages, the `Chef` actor
    writes a log entry and starts to wait for the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There is a special syntax in Akka logging. The first argument is a `String` that
    incorporates `{}` placeholders to denote other arguments. The substitution is
    done in a separate thread, but only if the respective log level is enabled. This
    is done to minimize the logging work done by the actor's thread.
  prefs: []
  type: TYPE_NORMAL
- en: Changing an actor's behavior using context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last line of code, the actor changes its behavior by using the `context.become` construct.
  prefs: []
  type: TYPE_NORMAL
- en: '`become` and `unbecome` is an Akka way of changing the behavior of the actor
    in response to a message. `become` takes a `Receive` argument (which is a type
    alias for `PartialFunction[Any, Unit]`, which is also just a normal sign of the `receive` method)
    which becomes a new actor''s behavior starting from the next message (this change
    in behavior is not preserved across actor restarts). The `discardOld` parameter
    controls whether this new behavior should replace an old one or whether it should
    just push it down to the stack of behaviors that actors maintain internally. We''ll
    see how this stack works in a minute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over the `waitingForResults` method, which became a new behavior
    of the actor a moment ago. The first line puts any `Groceries` messages on hold
    because we are already waiting for jobs to be finished. This is done by using
    the `stash()` method of the `Stash` trait, which puts the current message into
    an internal stash of the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Chef` actor watches over the `Mixer` actors it has created. In this case,
    if a child actor dies, the watching actor will receive a `Terminated` message
    with an actor reference of the victim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The actor checks whether all of the children are terminated by using `context.children`,
    and if this is the case, it prepends all of the stashed messages to the message
    box by using `unstashAll()` and returns to its previous behavior by using `context.unbecome()`.
  prefs: []
  type: TYPE_NORMAL
- en: Unbalanced `context.become()` and `context.unbecome()` operations might introduce
    the source of a memory leak in long-running applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our `Chef` is ready, let's move on and implement a `Manager`.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have implemented our bakery by relying on basic Akka concepts.
    It is time to deepen our knowledge and start to use higher level concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Akka FSM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Manager` pushes the cookie-making process forward by coordinating all other
    inhabitants of the bakery. It does so by taking the messages representing job
    results from one actor and passing them further along to an appropriate successor.
    It is important that this process is consequent, that is, it should be impossible
    to make raw cookies at the moment since we only have a shopping list and no dough.
    We'll represent this behavior as a state machine.
  prefs: []
  type: TYPE_NORMAL
- en: An FSM is an abstraction defined by a set of states the machine can be in. For
    each state, it also defines which message types can be accepted in this state
    and the possible reaction of the machine, including its new state.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into the code and see how this approach is implemented with Akka
    FSM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actor is defined by extending the `FSM` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The type parameter, `State`, represents the type of states the actor can be
    in, and the `Data` represents the possible associated internal state.
  prefs: []
  type: TYPE_NORMAL
- en: There is an obvious confusion between the term *State*, referring to the state
    of the FSM our actor represents, and a *State* referring to the data which is
    associated with each of the steps in the process. To avoid ambiguity, we'll further refer
    to the state of the actor as *Data* and the state of the FSM as *State*.
  prefs: []
  type: TYPE_NORMAL
- en: 'States of the actor reflect the processes that occur in the bakery: the goods
    moving from the shop boy over to the chef and cook, which then move over to the
    baker and back to the manager (note that because of the sequential art of work-passing
    done by the manager, there will be only one worker actor active in our bakery
    at the moment, even if they could work in parallel with a more sophisticated manager).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following messages represent the state of the managed bakery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The messages we defined previously also need to be extended to represent the possible
    types of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The FSM itself is defined by describing three primary aspects of the state
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: States
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An initial state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the actor''s code to see how this is done. The states
    are defined within the `when` block, which accepts a state name and a state function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When there are multiple `when` blocks for the same states, the state functions
    that constitute them are concatenated.
  prefs: []
  type: TYPE_NORMAL
- en: The state function is a `PartialFunction[Event, State]`, and describes a new
    state for each event type received in a particular state. Akka FSM provides a
    nice domain specific language (DLS) for this. For example, in the preceding code,
    the actor reacts to the `ShoppingList` event by transitioning to the `Shopping` state
    with a timeout of 5 seconds. The shopping list is used as new state data.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of any other message, the actor stays in the same state and replies
    to the sender with a friendly remark.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Shopping` state, the `Manager` reacts differently depending upon whether
    the groceries conform to the shopping list or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, it uses `Groceries` as a new state and goes to the next state.
    In the second case, it goes back to the `Idle` state and sets its state to `Uninitialized`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other states are described in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re just moving on to the next state and updating the state data in the
    process. The most obvious observation at the moment would be that `This actor
    does nothing but enjoying himself`, and we''re going to fix this by using the
    `onTransition` block, which describes the behavior of the actor at the moment
    state transition occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `Manager` already knows its subordinates, so it only needs to look up a
    `Boy`. Then, for each of the state transitions, it obtains the necessary state
    by using either `stateData` or `nextStateData`, which references the actor's state
    data before and after the respective state transition. This data is sent to the
    appropriate subordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all that's missing is an optional `whenUnhandled` block, which is executed
    in all states. The timer setting and a mandatory `initiate()` call sets up the
    defined timer and performs a state transition to the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Akka FSM forces you to mix business logic with actor-related code, which makes
    it hard to test and support it. It also locks you into the provided implementation
    and makes it impossible to bring in another state machine realization. Always
    consider another possibility before fixing upon Akka FSM.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, by separating the definition of states separately from behavior, Akka
    FSM allows for clean structuring of the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Akka remoting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can implement the final piece of the puzzle—the shop boy and the `sendBoy` function
    that we left uncovered until now. The `Boy` does not belong to the `Bakery`. The
    `Manager` will need to send the `Boy` to the grocery `Store`, which is represented
    by another actor system.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we'll rely on Akka's location transparency and remote capabilities.
    First, the manager will deploy a boy actor to the remote system. The deployed
    actor will get a reference to the `Seller` actor in the store so that it can get
    groceries as and when required.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to use remoting in Akka—either by using actor lookup or actor
    creation. Both are used in the same way that we did locally until now, that is,
    by calling `actorSelection` and `actorOf`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will demonstrate both ways that the manager will look up a seller from
    whom the boy should get groceries (imagine this seller is working with the bakery
    on a prepaid basis) and then require the boy to interact with this specific actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the code, we need to augment the setup of our application.
    Remoting is a separate dependency in Akka which we will put into the `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to replace the local actor provider with the remote one and configure
    the network settings in `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The same configuration, but with a necessarily different port, is provided
    for the second actor system that''s representing the grocery store. This is done
    by reusing the `application.conf` via inclusion and redefining the TCP port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to define the grocery store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can't use the default configuration as it is already taken by the bakery
    system, so we need to load a custom `grocery.conf` by using `ConfigFactory.load`.
    Next, we need to create an anonymous (but named!) actor whose sole responsibility
    is to return groceries, as described by the `ShoppingList`, to the sender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''re ready to implement the `sendBoy` function in the `Manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we must define the address of the grocery store. Then, we need to look
    up a seller by using its address on the remote system. Akka''s documentation specifies
    the following pattern for remote actor lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We'll take a look at this template and especially the actor path in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to create a boy by using our usual `actorOf` method. To tell
    Akka to deploy this actor remotely, we need to put the following configuration
    into `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This instructs Akka not to instantiate a local actor but to contact the remote
    daemon running in the actor system with the name `Store` with a network address
    of `127.0.0.1:2553` and to tell this daemon to create a remote actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could achieve the same result without extending configuration by providing
    deployment configuration directly in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This snippet creates a store address from the string we defined earlier and
    explicitly tells Akka to use it while creating the actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `Boy` is trivial now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Boy` constructor's takes a parameter of type `ActorSelection`, which is
    the result of the remote lookup that was done by the `Manager` previously. By
    receiving a `ShoppingList`, our implementation uses `forward` to, well, forward
    the message directly to the seller. Because of this forwarding, the seller will
    receive a message with the original actor (who is a manager) as a sender.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will take into the account that the boy was created by the manager
    just for the purpose of going shopping once, and we need to clean up the resources.
    This can be done by the manager actor, but we prefer self-cleanup here. The `Boy`
    sends himself a `PoisonPill` immediately after forwarding the original message and
    terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re done defining all of the inhabitants of our bakery, we can
    wire them together and bake some cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Before we run our app and enjoy some cookies, let's take a break from coding
    and look at the actor path we saw in the remote actor lookup pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The actor path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In accordance with the actor model, Akka actors are hierarchical.
  prefs: []
  type: TYPE_NORMAL
- en: The actor path is built by taking the names of each actor in the hierarchy up
    to the root actor and concatenating them right-to-left using slashes. In the beginning
    of the path, there is an address part identifying the protocol and location of
    the actor system. This address part is called the **anchor** and its representation
    is different for local and remote systems.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the whole path for the `Boy` which is described by the local
    path `/Manager/Boy` in the deployment configuration will be `akka://user/Bakery/Manager/Boy` (purely
    local path) for the `Boy` actor and an akka.tcp://Store@127.0.0.1:2553/user/Seller (remote
    path) for the `Seller` actor in the remote `Store` actor system, as shown from
    the `Bakery` side.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, remoting introduces the necessary differences in the way the
    actor path is built and used.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of the actor path is to address an actor we are about to send
    messages to. On a technical level, we have an abstraction for sending messages
    to an actor, which is `ActorRef`. For each actor, its `ActorRef` provides access
    to its local reference through the `self` field and to the sender of the current
    message via the `context.sender()`. Each `ActorRef` references exactly one actor.
    `ActorRef` also incorporates a dispatcher and a mailbox for the actor. The dispatcher
    is responsible for queueing messages in the actor's mailbox and dequeueing them
    at a certain time before passing them to the actors' `receive` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen both ways to create an `ActorRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: By creating an actor using `context.actorOf`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By looking up one or multiple actors using `context.actorSelection`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are different ways to provide an actor path for the lookup in the second
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path**: `context.actorSelection("/user/Manager/Boy")` returns a
    single actor with a path specified or empty selection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relative path**: `context.actorSelection("../sibling")` goes up to the parent
    in the hierarchy and then down to the "sibling" in the case that it exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wildcards**: `context.actorSelection("../*")` goes up in the hierarchy and
    selects all of the children of the actor''s parent, including the current actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor supervision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's explain another strangeness in the actor path that you are probably
    wondering about—the leading `/user` part in the actors paths we've seen before.
    The existence of this part is Akka's answer to the question we stated at the beginning
    of this chapter—*How is the very first actor created?*
  prefs: []
  type: TYPE_NORMAL
- en: In Akka, the very first actor is created by the library itself. It represents
    a root actor and is called the root guardian accordingly (we'll explain the *guardian* part
    in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Akka creates three guardian actors for each actor system, as shown
    in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: The `/` root guardian is a parent for two other guardians and thus an ancestor
    of any other actor in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The `/user` guardian is a root actor for all user-created actors in the system.
    Thus, every actor created by any user of the Akka library has two parents in the
    hierarchy and therefore has `/user/` as a prefix in its path.
  prefs: []
  type: TYPE_NORMAL
- en: The `/system` is a root actor for internal actors that have been created by
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend our actor diagram with the guardian actors we just learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad82fdc8-a14d-4c0a-9940-6f5cfc664e96.png)'
  prefs: []
  type: TYPE_IMG
- en: We instantiate all of our actors except mixers by using `system.context`. Because
    of this, they are created as children of the user guardian. The root guardian
    is on the top of the hierarchy and has a user guardian and a system guardian as
    its children.
  prefs: []
  type: TYPE_NORMAL
- en: The guardians are a part of another important feature of Akka—supervision. To
    understand what supervision is and why it is important, let's finally run our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sanitized output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What happened? The actor system has started and communication between actors
    begun, but then an `AssertionError` was thrown and the whole system terminated!
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this exception is a trivial programming error in the `Baker` actor
    we described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The assertion that the timer is empty is wrong, and so it throws an exception
    at runtime. The exception is not caught and leads to termination of the program.
    Obviously, in this case, the rules of the actor model (as described at the beginning
    of this chapter) are not respected. One actor affects all other actors and the
    system as a whole without sending any messages.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is not some deficiency of Akka. The reason our application behaves
    as it does is that we ignored the very important aspect of actor-based systems—supervision.
  prefs: []
  type: TYPE_NORMAL
- en: Supervision in Akka means that any actor creating a child is responsible for
    its management in case problems occur.
  prefs: []
  type: TYPE_NORMAL
- en: An actor detecting erroneous conditions is expected to suspend all of its descendants
    and itself and report a failure to its parent. This failure reporting has a form
    of exception throwing.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, expected erroneous conditions, for example, an absence of a record
    in the database, are modelled on the protocol level via messages and errors of
    a technical nature, such as unavailable database connections modelled with exceptions.
    To better differentiate between erroneous conditions, developers are encouraged
    to define a rich set of exception classes, similar to that of normal message classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions thrown by the child actor are delivered to the parent, who then
    needs to handle the situation in one of four possible ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Resume the child and let it process messages in the message box, starting from
    the next one. The message that caused the actor to fail is lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart the child. This will clean up its internal state and recursively stop
    all of its descendants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the child completely. This is also recursively propagated to the descendants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propagate the failure to its own parent. By doing this, the supervisor is failing
    itself with the same cause as the subordinate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before delving into the technical aspects of defining a supervision strategy,
    let's revisit our actor's structure. Currently, all of our actors (with the exception
    of dynamic mixers) are created as direct children of the user guardian. This leads
    to the necessity to define the supervision strategy in one place for the whole
    actor hierarchy. This is a clear violation of the principle of separation of concerns,
    and is known in Akka as a *Flat Actor Hierarchy* anti-pattern. What we should
    aim for instead is creating a structure where failure handling happens close to
    the place the error occurred by the actor that is most capable of handling such
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this goal in mind, let''s restructure our application so that the `Baker`
    actor is responsible for the supervision of the `Oven` and the `Manager` is responsible
    for all of the actors in the system. This structure is represented in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49c75977-26b5-403f-94af-1149487839e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have a sane hierarchical structure where each supervisor has the best
    knowledge about possible failures of its children and how to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a technical level, the supervision strategy is defined by overriding the `supervisorStrategy`
    field of the corresponding actor. To demonstrate how this is done, let''s extend
    our `Mixer` actor with the capability to report different hardware failures. First,
    we must define a rich set of exceptions in the companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we need to throw them randomly during message processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll override a supervision strategy in the `Chef` actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `OneForOneStrategy` instructs the `Chef` to deal with any children's failures
    on an individual basis.
  prefs: []
  type: TYPE_NORMAL
- en: For `MotorOverheatException`, we decide to stop the failing `Mixer`. The `Chef`
    sends an empty `Dough` message to itself which is counted as the response from
    the broken child.
  prefs: []
  type: TYPE_NORMAL
- en: The `SlowRotationSpeedException` means that something went wrong during the
    placement of groceries into the `Mixer`. The original message was lost by the
    `Mixer` at the moment it threw an `Exception`, so we're resending this message
    and restarting the `Mixer`.
  prefs: []
  type: TYPE_NORMAL
- en: We can tolerate `StrongVibrationException`, so we just compensate for the lost
    message by resending it and resuming the child.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of any other exception, the `Chef` has no knowledge of how to handle
    it and just propagates failure to the `Manager`. The `Manager` does not have any
    `supervisorStrategy` defined and the exception is ultimately propagated to the
    user guardian.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user guardian handles exceptions as specified by the default strategy.
    The default strategy is the same for all actors in the userspace if not overridden,
    and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ActorInitializationException`: Stops the failing child actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ActorKilledException`: Stops the failing child actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeathPactException`: Stops the failing child actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception`: Restarts the failing child actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Throwable`: Escalates to the parent actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root guardian is configured with `SupervisorStrategy.stoppingStrategy`,
    which differentiates between the `Exception` and other throwables. The former
    leads to the termination of the failing actor (which effectively means all of
    the actors in the `/user` or `/system` space), while the latter is propagated
    further and leads to the termination of the actor system. This is what happened
    when our earlier implementation threw an `AssertionError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supervision strategy for the user guardian can be overridden by using its
    configuration property. Let''s demonstrate how to use it to handle the occasional
    `LazinessException`, which could be thrown by any actor in the system. First,
    we augment `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we implement the configured strategy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Laziness is contagious, so we use `AllForOneStrategy` to replace the whole team
    by restarting all of the children of the user guardian.
  prefs: []
  type: TYPE_NORMAL
- en: Testing actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actor-based systems are different from systems that are built using a traditional
    approach. Naturally, testing actors is different from regular testing. Actors
    send and receive messages in an asynchronous manner and are usually examined via
    message flow analysis. A typical setup will include three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The source of the messages
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actor under test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The receiver of the actor's responses
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Luckily, Akka includes a testing module that abstracts a lot of setup logic
    and provides useful helpers for common testing activities. The name of the module
    is Akka `TestKit` and it is contained in a separate module that needs to be added
    to the project''s test scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Having this dependency allows us to extend a `TestKit` class. The `TestKit`
    implements a special testing environment that mimics the internals of a normal
    actor system but provides access to some of the details that are hidden in a production
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `ScalaTest` specification that extends `TestKit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we extend a `TestKit` with usual the `ScalaTest` matchers and `WordSpec`,
    but also mix a `BeforeAndAfterAll` and an `ImplicitSender` in. Then, we implement
    the default constructor by instantiating a `BakerySpec` actor system. Lastly,
    we override an `afterAll` method to make sure that our test actor system is properly
    terminated after the test.
  prefs: []
  type: TYPE_NORMAL
- en: In SBT, tests are usually run in parallel. In this case, it is important to
    name an actor system properly and in this case, remoting is also used to override
    the default port to avoid conflicts between simultaneously executing tests. Also,
    we should not forget to shut down the actor system gracefully to ensure that our
    resources are cleaned up properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `TestKit` implements and brings into scope a `testActor` field, which we
    can use to send messages from the test code. Usually, we'd like these messages
    to be sent from a well-known actor. The `ImplicitSender` trait implements a reference
    to the `testActor` that is attached to the message at the moment it is sent.
  prefs: []
  type: TYPE_NORMAL
- en: The `TestKit` also maintains an internal queue of the messages sent to the `testActor`
    and defines a host of useful methods to inspect this queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how some of these predefined methods can be used to test our `Boy`
    actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Recapping the logic of the `Boy` actor, all it is doing is forwarding `ShoppingList`
    to another actor provided as a constructor parameter. In order to test this behaviour,
    we first create an `ActorSelection` as required by the boy's constructor, use
    our default `testActor` as a target, and create a boy actor as a child of the
    test actor system that the `TestKit` provides us with.
  prefs: []
  type: TYPE_NORMAL
- en: In the first test, we send a `ShoppingList` to the `Boy` and expect it to forward
    the list to the `testActor` within a predefined time interval between 3 and 30
    milliseconds. We verify that the message is indeed a `ShoppingList` and that the
    sender is a `testActor`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second test, we verify that the `Boy` ignores other messages. To check
    this, we send it a message with a `Symbol` type and expect our `testActor` to
    receive nothing within 500 milliseconds. As normal forwarding is expected to take
    no more than 20 milliseconds by our first test, we can be sure that the message
    has been ignored by the `Boy`.
  prefs: []
  type: TYPE_NORMAL
- en: '`testActor`, `lastSender`, `within`, `expectMsg`, and `expectNoMsg` are implemented
    by the `TestKit` and save us from writing boilerplate code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of other helpful methods in the `TestKit` that we will take
    a look at shortly. Most of them exist in two forms: one takes a timeout as a parameter
    and another uses a default timeout. The timeout defines how long `TestKit` will
    wait for the condition to happen. The default timeout can be overridden by using
    the `within` wrapper, as shown previously, by changing the configuration or by
    using a `timescale` parameter that will affect all durations within the scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are already familiar with the `expectMsg` and `expectNoMessage` assertions.
    Let''s take a look at some of the other available helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def expectMsgClass[C](c: Class[C])`: `C` expects and returns a single message
    of type C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectMsgType[T](implicit t: ClassTag[T])`: `T` does the same as the previous
    helper, but uses implicit to construct the type parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectMsgAnyOf[T](obj: T*): T` This expects one message and verifies that
    it is equal to one of the constructor parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectMsgAnyClassOf[C](obj: Class[_ <: C]*)`: `C` does the same as before,
    but verifies the type of the message instead of the actual message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectMsgAllOf[T](obj: T*)`: `Seq[T]` expects the number of messages and
    verifies that all of them are equal to the constructor parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectMsgAllClassOf[T](obj: Class[_ <: T]*)`: `Seq[T]` does the same as
    before, but verifies types of messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectMsgAllConformingOf[T](obj: Class[_ <: T]*)`: `Seq[T]` does the same
    as `expectMsgAllClassOf`, but checks conformity (instanceOf) instead of class
    equality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectNoMessage()`: `Unit` verifies that no message is received during
    the specified or default timeout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def receiveN(n: Int)`: `Seq[AnyRef]` receives N messages and returns them
    to the caller for further verification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectMsgPF[T](max: Duration = Duration.Undefined, hint: String = "")(f:
    PartialFunction[Any, T])`: `T` expects a single message and verifies that a given
    partial function is defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def expectTerminated(target: ActorRef, max: Duration = Duration.Undefined)`:
    `Terminated` expects a single `Terminated` message from a specified `target`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def fishForMessage(max: Duration = Duration.Undefined, hint: String = "")(f:
    PartialFunction[Any, Boolean])`: `Any` expects multiple messages for which given
    partial function is defined. It returns the first message for which `f` returns
    true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `Baker` actor is designed in such a way that it sends messages to its parent,
    which means that we will be unable to receive responses from the `Baker` if we
    create it using the test actor system. Let''s take a look at how `TestKit` can
    help us in this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're constructing a test actor using `TestProbe()`. The `TestProbe` is
    another nice feature provided by the `TestKit` that allows you to send, receive,
    and reply to messages, and is useful in testing scenarios when multiple test actors
    are required. In our case, we're using its ability to create child actors to create
    a `Baker` actor as a child.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to generate a number of `RawCookies` so that it requires a number
    of turns to bake them. We expect this number of messages to be sent to the `parent`
    in the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up until now, we have tested actors in isolation. Our grocery `Store` is built
    in a way that it instantiates an anonymous actor. This makes the approach of testing
    an actor in isolation impossible. Let''s demonstrate how we can verify that the
    `Seller` actor returns the expected `Groceries` if given a `ShoppingList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We will construct our test class like we did previously, but with one subtle
    difference. The `Seller` actor is defined anonymously and therefore is only constructed
    as a part of the whole actor system. Because of this, we instantiate the `Store` in
    the default constructor and use the underlying actor system that's accessible
    via the `store` field as a constructor parameter for the `TestKit` instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the test itself, we're sending test inputs directly to the `seller` `ActorRef`
    using the `store` that we constructed previously. We have not extended `ImplicitSender`
    and need to provide a `testActor` as a sender reference explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our application implemented and tested, let's run it!
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please refer to  [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you don't have Java and SBT installed
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run our application in the terminal by using two separate terminal
    sessions for `Shop` and `Bakery`. It is possible to run both by issuing one of
    the two following commands in the corresponding shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt "runMain ch11.Store"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sbt "runMain ch11.Bakery"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our code, we do not handle the `StateTimeout` for the `Shopping/ShoppingList`
    state. Therefore, it is mandatory to start the store session first and after it
    loads and starts to accept connections stating that the bakery session can be
    started.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use an approach documented in [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, to run the code from within the SBT
    session and choose the appropriate main class after that. This approach is represented
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a897de3-2ade-41c7-b645-e0245266b108.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see how two SBT sessions are initiated in the `ch11` folder. On
    the right-hand side of the screen, the main class for the store was already selected
    and run by SBT. The logs show that the `Store` is listening for connections, so
    it is safe to start the main `Bakery` session.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens after we enter `1` in the left Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c436493b-db61-420f-be10-295ff655470e.png)'
  prefs: []
  type: TYPE_IMG
- en: The store side reflects that the connection was established and the bakery side
    starts to output log statements about current activities. It keeps running and
    logging what is happening until stopped by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recap what we've learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Current scaling demands are hard to meet using traditional approaches. The actor
    model with its shared nothing paradigm offers a solution to this problem. Akka
    is a library for building actor-based applications on the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Actors communicate by sending and receiving messages and change their internal
    state and produce side-effects in response. Each actor has an address in the form
    of an `ActorRef`, which also encapsulates ab actor's mailbox and a dispatcher.
    Actors are organized into hierarchies where parent actors are responsible for
    the supervision of their children.
  prefs: []
  type: TYPE_NORMAL
- en: Actors have a well-defined life cycle and implement a number of methods, which
    are called at appropriate moments during their lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: Akka provides additional modules that extend provided functionality even further.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at Akka FSM, which gives us the possibility to represent an actor
    as an FSM by encoding its possible states and state transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Akka remoting implements the location transparency principle in practice and
    allows you to access remote Akka systems easily.
  prefs: []
  type: TYPE_NORMAL
- en: Testing actors is different from testing regular code. Akka `TestKit` is a library
    that's provided by the Akka team, which simplifies and streamlines the testing
    process. It does so by placing a tested actor in a controlled—but close to the
    real—environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will rebuild our bakery using different actor-based
    approach and different Akka library—Akka Typed.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name two ways in which an actor can change itself in response to the received
    message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the purpose of `ActorRef`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup is in the official documentation description of the system guardian.
    What is the main purpose of it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages and disadvantages of using Akka FSM?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In how many ways can an actor in another actor system be accessed? Describe
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why does testing actors require a special toolkit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Christian Baxter, *Mastering Akka*: Master the art of creating scalable, concurrent,
    and reactive applications using Akka.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Héctor Veiga Ortiz and Piyush Mishra, *Akka Cookbook*: Learn how to use the
    Akka framework to build effective applications in Scala.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
