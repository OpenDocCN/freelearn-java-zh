- en: An Introduction to the Akka and Actor Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka 和 Actor 模型简介
- en: In this chapter, we'll learn about the actor model and how it is implemented
    in Akka. We'll make ourselves familiar with Akka by building a simple yet complete
    actor system. We will then learn how to create an actor system and actors, pass
    messages between them, make use of location transparency and remoting, properly
    structure the system for effective supervision, and look at how **finite-state
    machine** (**FSM**) actors work. Finally, we'll show you how to test actor-based
    applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 actor 模型及其在 Akka 中的实现方式。我们将通过构建一个简单而完整的 actor 系统来熟悉 Akka。然后，我们将学习如何创建
    actor 系统，以及 actors，如何在它们之间传递消息，如何利用位置透明性和远程通信，如何为有效的监督合理地构建系统，以及如何查看**有限状态机**（**FSM**）actors
    的工作原理。最后，我们将向您展示如何测试基于 actor 的应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The actor model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor 模型
- en: The basics of Akka
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka 基础
- en: Akka FSM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka FSM
- en: Akka remoting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka 远程通信
- en: Testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保您已安装以下内容：
- en: Java 1.8+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 1.8+
- en: SBT 1.2+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: Please refer to the installation instructions in [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you need to perform a first-time
    setup of Java or SBT.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要执行 Java 或 SBT 的首次设置，请参阅[附录 A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml)中的安装说明，*准备环境和运行代码示例*。
- en: The source code is available on our GitHub repository at: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可在我们的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter11)。
- en: Introduction to the actor model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor 模型简介
- en: 'From the first days of computing applications of all kinds, they have faced
    growing demands for processing increasing volumes of data within diminishing processing
    times. Up until recently, these challenges were addressed by scaling applications
    vertically, by adding more memory and higher speed processors. This approach was
    possible because of growing processor speed, which is described by Moore''s law
    as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从各种计算应用的第一天起，它们就面临着在减少的处理时间内处理日益增长的数据量的需求。直到最近，这些挑战通过垂直扩展应用程序来解决，即通过增加内存和更快的处理器。这种方法之所以可行，是因为处理器速度的增长，这被摩尔定律描述如下：
- en: '"Moore''s law is the observation that the number of transistors in a dense
    integrated circuit doubles about every two years. ... Moore''s prediction proved
    accurate for several decades, and has been used in the semiconductor industry
    to guide long-term planning and to set targets for research and development. ....
    Moore''s law is an observation and projection of a historical trend and not a
    physical or natural law."'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “摩尔定律是观察到的现象，即密集集成电路中的晶体管数量大约每两年翻一番。... 摩尔的预测在几十年的时间里被证明是准确的，并在半导体行业中用于指导长期规划，并为研究和开发设定目标。....
    摩尔定律是对历史趋势的观察和预测，而不是物理或自然法则。”
- en: 'But the pace of advancement in hardware started to slow down, as stated by
    Intel in 2015\. This trend made it obvious that the only way to scale applications
    from now on was via horizontal scalability—by increasing the number of processing
    cores and machines which are to process data in parallel by using multiple application
    threads. Two obvious challenges in this situation are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如英特尔在 2015 年所陈述的那样，硬件进步的速度开始放缓。这种趋势使得很明显，从现在开始，唯一扩展应用程序的方法是通过横向扩展——通过增加处理核心和机器的数量，使用多个应用程序线程并行处理数据。在这种情况下有两个明显的挑战：
- en: To prevent concurrent modification and, as a result, corruption of data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止并发修改，从而避免数据损坏
- en: To provide access to the data for processes running on different cores or machines
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提供对在不同核心或机器上运行的过程的数据访问
- en: 'The first challenge is traditionally solved by using shared memory and different
    locking approaches. Unfortunately, this approach effectively makes the parts of
    the application that are synchronizing with each other pseudo-sequential, which
    in turn limits possible speedup in accordance with Amdahl''s law:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的第一个挑战是通过使用共享内存和不同的锁定方法来解决的。不幸的是，这种方法实际上使得应用程序中相互同步的部分变成了伪顺序的，这反过来又根据 Amdahl
    的定律限制了可能的加速：
- en: '"Amdahl''s law is a formula that gives theoretical speedup in terms of latency in the
    execution of a task at the fixed workload that can be expected of a system whose
    resources have been improved.  ... Amdahl''s law is often used in parallel computing to
    predict the theoretical speedup when using multiple processors."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “阿姆达尔定律是一个公式，它以固定工作负载下执行任务的延迟为理论速度提升。  ... 阿姆达尔定律常用于并行计算，以预测使用多个处理器时的理论速度提升。”
- en: The most important corollary is that the speedup is limited by the serial part
    of the program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的推论是，加速受到程序串行部分的限制。
- en: Fortunately, there are other solutions that make it possible for different parts
    of the program to work together toward the same goal in parallel. One of these
    approaches is the actor model. Fortunately, the actor model also addresses the
    second challenge with a concept known as **location transparency**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有其他解决方案可以使程序的不同部分并行工作，共同实现同一目标。其中一种方法就是演员模型。幸运的是，演员模型还通过一个称为**位置透明性**的概念解决了第二个挑战。
- en: The concept of actors was first introduced in 1973 by *Carl Hewitt*, *Peter
    Bishop*, and *Richard Steiger*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 演员的概念最早由*卡尔·休伊特*、*彼得·毕晓普*和*理查德·斯蒂格*在1973年提出。
- en: 'Carl Hewitt, Peter Bishop, and Richard Steiger: A Universal Modular Actor Formalism
    for Artificial Intelligence. In: Proceeding IJCAI''73 Proceedings of the 3rd International
    Joint Conference on Artificial Intelligence. 1973, S. 235–245 ([https://dl.acm.org/citation.cfm?id=1624804](https://dl.acm.org/citation.cfm?id=1624804)).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔·休伊特、彼得·毕晓普和理查德·斯蒂格：人工智能的通用模块化演员形式。在：IJCAI'73国际人工智能联合会议论文集。1973年，第235–245页 ([https://dl.acm.org/citation.cfm?id=1624804](https://dl.acm.org/citation.cfm?id=1624804))。
- en: 'The idea is that everything is represented as an actor, which is a basic computational
    entity. Actors communicate with each other using messages. In response to a message,
    an actor can undertake any of the following actions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，一切都被表示为演员，这是一种基本的计算实体。演员通过消息相互通信。在接收到消息后，演员可以执行以下任何一项操作：
- en: Send a finite number of messages to other actor(s)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向其他演员发送有限数量的消息
- en: Create a finite number of other actors
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有限数量的其他演员
- en: Change its behavior for the next message to be processed
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变下一个要处理的消息的行为
- en: 'This definition is quite abstract, but already allows you to recognize a couple
    of constraints that the implementation must satisfy:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义相当抽象，但已经允许你识别出实现必须满足的一些约束：
- en: Actors communicate using messages and are not allowed to expose or inspect the
    internal states of each other.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员通过消息进行通信，并且不允许暴露或检查彼此的内部状态。
- en: A shared mutable state has no place in the actor model.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在演员模型中，没有共享的可变状态的位置。
- en: 'Side-effects are not mentioned in this definition, but they are obviously the
    end goal of any system. Therefore, an actor''s response to the message might be
    any combination of the following:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个定义中没有提到副作用，但它们显然是任何系统的最终目标。因此，演员对消息的响应可能是以下组合中的任何一种：
- en: Changing internal state
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变内部状态
- en: Modifying behavior
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改行为
- en: Producing side-effects
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产生副作用
- en: Actors need to be able to address each other. Consequently, a naming system
    is expected to exist. Having an appropriate naming system is a prerequisite for
    location transparency, meaning that every actor can be addressed by some canonical
    name regarding its actual location.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员需要能够相互定位。因此，预期存在一个命名系统。拥有适当的命名系统是位置透明性的先决条件，这意味着每个演员都可以通过一个关于其实际位置的规范名称进行定位。
- en: 'The preceding definition also leaves the following questions unanswered, among
    others:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义也未能回答以下问题，以及其他问题：
- en: What would be an effect of the limitations of the underlying hardware, operating
    system, and runtime environment?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础硬件、操作系统和运行时环境的限制会产生什么影响？
- en: Where do actors coexist and how is the first actor created?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员在哪里共存，第一个演员是如何被创建的？
- en: How are messages delivered from one actor to another?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息是如何从一个演员传递到另一个演员的？
- en: Are actors mortal, and if yes, how do they die?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员是会死亡的，如果是的话，他们是如何死亡的？
- en: The most prominent languages that use the actor model are Erlang, Io, D, Pony,
    and Scala.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用演员模型的最为突出的语言包括Erlang、Io、D、Pony和Scala。
- en: We will take a closer look at the Scala implementation—Akka—by building an enterprise bakery
    application. Our bakery will be crowded by different actors, each with their own
    responsibilities, producing cookies as a result of their teamwork.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过构建一个企业烘焙应用来更详细地研究Scala实现——Akka。我们的烘焙店将被不同的演员占据，每个演员都有自己的职责，通过团队合作生产饼干。
- en: Akka basics
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka基础知识
- en: 'We will start by adding an Akka dependency into the `build.sbt` file of an
    empty Scala SBT project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将Akka依赖项添加到空Scala SBT项目的`build.sbt`文件中：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `akkaVersion` could be looked upon the Akka website. At the time of writing
    this book, it was 2.5.13, so we would prepend `val akkaVersion = "2.5.13"` to
    the preceding snippet.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Akka网站上查看`akkaVersion`。在撰写本书时，它是2.5.13，因此我们将在前面的代码片段前添加`val akkaVersion =
    "2.5.13"`。
- en: 'The SBT can create a minimal Akka project for you via a giter8 template: `sbt
    new https://github.com/akka/akka-quickstart-scala.g8`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SBT可以通过giter8模板为您创建一个最小的Akka项目：`sbt new https://github.com/akka/akka-quickstart-scala.g8`。
- en: 'Now, we can instantiate an `ActorSystem`, which is the place where Akka''s
    actors live:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实例化一个`ActorSystem`，这是Akka演员的居住地：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Avoid defining multiple actor systems in the same JVM or even on the same machine.
    An actor system is not very lightweight and is usually configured to closely reflect
    the hardware configuration it is running on. Thus, multiple actor systems will
    not only consume more resources than needed but, in the worst case, they will
    compete for these resources.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在同一个JVM或同一台机器上定义多个actor系统。actor系统并不轻量级，通常配置得与它运行的硬件配置紧密相关。因此，多个actor系统不仅会消耗比所需更多的资源，而且在最坏的情况下，它们将竞争这些资源。
- en: It is also possible to create a default actor system without providing a name,
    but it would be best if you don't do this. Naming the actor system and actors
    will make your life easier while you reason about it and debug existing code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以创建一个不带名称的默认actor系统，但最好不要这样做。命名actor系统和actor将使您在推理和调试现有代码时更容易。
- en: As a next step, let's define an actor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们定义一个actor。
- en: Defining actors
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义actor
- en: 'An actor in Akka must extend traits of the same name and implement the `receive` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Akka中的actor必须扩展同名特质并实现`receive`方法：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The type of the `receive` action is defined as `type Receive = PartialFunction[Any,
    Unit]`, which closely resembles the abstract definition of an actor model. In
    Akka, actors can receive any message, and any of the actor's activities are manifested
    as a change in its state or as a side-effect.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`receive`动作的类型定义为`type Receive = PartialFunction[Any, Unit]`，这与actor模型的抽象定义非常相似。在Akka中，演员可以接收任何消息，任何演员的活动都表现为其状态的变化或副作用。'
- en: Our defined actor accepts any message and does nothing. This is probably the
    simplest and laziest actor possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的演员接受任何消息而不做任何事情。这可能是最简单、最懒惰的演员了。
- en: In order to make it useful, let's define its behavior and vocabulary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其有用，让我们定义其行为和词汇。
- en: 'As we''re building an enterprise bakery, our actors will have a single responsibility,
    which is also a good idea in any kind of system, not just one that''s actor-based.
    Our cook actor will take a ready-made dough and make raw cookies out of it. First,
    we must define the messages:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建一个企业烘焙店，我们的演员将只有一个职责，这在任何类型的系统中都是一个好主意，而不仅仅是基于演员的系统。我们的厨师演员将取一块现成的面团，并从中制作出原始饼干。首先，我们必须定义消息：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And then the behavior of the actor:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是actor的行为：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are a couple of things going on in this definition:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中，有几件事情正在进行：
- en: Our actor understands only one message type, `Dough`
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的actor只理解一种消息类型，`Dough`
- en: It *makes* raw cookies out of dough by calculating their number
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过计算数量将面团制作成原始饼干
- en: We're using `sender()` to obtain a reference to the actor from which the received
    message is originating and send the response to this reference
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`sender()`来获取发送消息的演员的引用，并将响应发送到这个引用
- en: 'Also, some more subtle details are worth mentioning:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些更微妙但值得注意的细节：
- en: If, by coincidence, our `Cook` will get any other message except `Dough`, this
    message won't be handled by the actor and will be lost. Akka has a special mechanism
    for such messages called *dead message queue*.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果，出于巧合，我们的`Cook`收到除`Dough`以外的任何其他消息，这个消息将不会被actor处理，并会丢失。Akka有一个专门处理此类消息的机制，称为*死信队列*。
- en: We defined case classes for each message type to make understanding the code
    less complicated.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每种消息类型定义了案例类，以使代码理解更加简单。
- en: The actor's logic is decoupled from the protocol and can be extracted into the
    companion object. This is done to make testing easier.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员的逻辑与协议解耦，可以提取到伴随对象中。这样做是为了使测试更容易。
- en: 'Now that we have a definition of the actor, it is time to instantiate it and
    send some messages to it. In Akka, we have to use a special `Prop` constructor:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了演员，是时候实例化它并向其发送一些消息了。在Akka中，我们必须使用特殊的`Prop`构造函数：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We don't need to pass any constructor parameters to the actor in this case and
    therefore we can benefit from using the `Props` form, which takes a sole type
    of an actor as its parameter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要向演员传递任何构造函数参数，因此我们可以从使用`Props`形式中受益，它将演员的唯一类型作为其参数。
- en: Don't construct actors directly using a class constructor. It is possible to
    do so and then obtain the *ActorRef* from the actor, but this will result in an
    error at runtime.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接使用类构造函数来构建演员。虽然可以这样做，然后从演员中获取*ActorRef*，但这将在运行时导致错误。
- en: 'Now, we can bring everything together and send out our first message:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将所有这些放在一起并发送我们的第一条消息：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have created a named actor using an actor system and sent one message to
    it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用演员系统创建了一个命名演员并向其发送了一条消息。
- en: 'Let''s define a couple of other actors to make our bakery lively. We will separate
    the responsibilities, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义其他一些演员，使我们的面包店更加活跃。我们将按照以下方式分离责任：
- en: A boy will visit the groceries store and get the necessary ingredients.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个男孩将访问杂货店并获取必要的原料。
- en: He will hand them over to the bakery manager so that they can check the amount
    and quality.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他将把它们交给面包店经理，以便他们可以检查数量和质量。
- en: The ingredients are then given to the chef, who prepares a dough out of them.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将配料交给厨师，厨师将它们制成面团。
- en: The chef uses one or more mixers depending on the volume of the dough.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 厨师根据面团的体积使用一个或多个搅拌机。
- en: The ready dough is given to the cook, who prepares the raw cookies.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备好的面团交给厨师，厨师将其制成原始饼干。
- en: The raw cookies are baked by the baker.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始饼干由面包师烘焙。
- en: The baker uses the oven for baking. It might take a couple of rounds to bake
    all of the cookies because of the oven's limited size.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包师使用烤箱进行烘焙。由于烤箱的大小有限，可能需要几轮才能烘焙完所有的饼干。
- en: The cookies are returned to the manager as soon as they are ready.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼干一准备好就返回给经理。
- en: 'Then, we need to figure out the relationships between actors, like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要找出演员之间的关系，如下所示：
- en: '![](img/5611e12b-1d43-48ae-86fa-bcbe72d7e94d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5611e12b-1d43-48ae-86fa-bcbe72d7e94d.png)'
- en: 'And then we need to build and show the message flow among them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要构建并展示它们之间的消息流：
- en: '![](img/6d1d019c-d38b-4eba-b523-2a61324d2cdd.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d1d019c-d38b-4eba-b523-2a61324d2cdd.png)'
- en: 'We''ll build our actor hierarchy from the bottom up, starting from the oven:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从底部向上构建我们的演员层次结构，从烤箱开始：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We introduced a number of new features here.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引入了许多新功能。
- en: First, we defined two new message types that will be used to command an oven
    to return cookies and make a container for the ready cookies. In the actor itself,
    we're using a constructor parameter to specify how many cookies will fit inside
    it. We're also using Akka's `LoggingReceive`, which writes incoming messages into
    the log. In the `receive` method itself, we stick to the principle of separating
    Akka semantics from the business logic.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了两种新的消息类型，这些类型将被用来命令烤箱返回饼干并为准备好的饼干制作容器。在演员本身中，我们使用构造函数参数来指定可以放入其中的饼干数量。我们还使用了Akka的`LoggingReceive`，它将传入的消息写入日志。在`receive`方法本身中，我们坚持将Akka语义与业务逻辑分离的原则。
- en: The `insert` method checks whether the oven is empty and places as many raw
    cookies as possible into it, optionally returning these which don't fit inside back,
    so that we can forward them to the sender.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`方法检查烤箱是否为空，并将尽可能多的原始饼干放入其中，可选地返回那些放不进去的饼干，这样我们就可以将它们转发给发送者。'
- en: In the `extract` method, we modify the number of cookies inside the oven and
    return them to the sender.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`extract`方法中，我们修改烤箱内的饼干数量并将它们返回给发送者。
- en: Having `var` inside of an actor is absolutely safe and illustrates one of the
    core features of Akka features—messages are processed by actors one-by-one in
    the order they are received. Even in a highly concurrent environment, Akka shields
    actor code from any concurrency-related matters.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在演员内部使用`var`绝对安全，并说明了Akka的核心特性之一——消息按接收顺序逐个由演员处理。即使在高度并发的环境中，Akka也会保护演员代码免受任何并发相关问题的困扰。
- en: Always use deeply immutable messages. Using mutable structures will allow two
    different actors to access the same data from different threads, which can lead
    to concurrent modifications and corrupt data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用深度不可变的消息。使用可变结构将允许两个不同的actor从不同的线程访问相同的数据，这可能导致并发修改并损坏数据。
- en: 'To instantiate an oven, we''ll use another flavor of the `Prop` constructor,
    which allows us to define constructor parameters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实例化一个烤箱，我们将使用另一种`Prop`构造函数的版本，它允许我们定义构造函数参数：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By convention, it is placed into the companion object of an actor. The `size`
    of the oven is defined here as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，它被放置在actor的伴生对象中。这里也定义了烤箱的`size`。
- en: 'As shown in the following code, we''ll describe the user of the oven, that
    is, the `Baker` actor:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，我们将描述烤箱的使用者，即`Baker`actor：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's take a closer look at what is going on here. First, we need to use yet
    another kind of `Props` constructor because Akka does not support constructors
    with default parameters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这里发生了什么。首先，我们需要使用另一种类型的`Props`构造函数，因为Akka不支持具有默认参数的构造函数。
- en: '`Props`, along with the instance, is a very powerful construct that allows
    you to create anonymous actors which in turn can close over the internal state
    of another actor. Try to avoid using it, if possible.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Props`，连同实例一起，是一个非常强大的构造，允许你创建匿名actor，这些actor反过来可以封装另一个actor的内部状态。如果可能，尽量避免使用它。'
- en: The `Baker` actor receives an `ActorRef` of the `Oven` as a parameter. This
    reference is used by the baker to send cookies to the `Oven` and extract them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Baker`actor接收一个`Oven`的`ActorRef`作为参数。这个引用被面包师用来向`Oven`发送饼干并从中提取它们。'
- en: After receiving the baked cookies from the `Oven`, the `Baker` looks up the
    `Manager` actor and sends the `Cookies` to it. After that, it puts another batch
    of raw cookies into the `Oven`, if needed. We will discuss the intrinsics of `context.actorSelection`
    later in this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`Oven`接收烘焙好的饼干后，`Baker`actor查找`Manager`actor并发送`Cookies`给它。之后，如果需要，它会将另一批生饼干放入`Oven`中。我们将在本章后面讨论`context.actorSelection`的内在特性。
- en: The `Baker` maintains an internal queue of raw cookies and periodically puts
    them into the oven. This is an old oven, and to use it, we need set up a kitchen
    timer in order to extract the baked cookies at the proper time. Finally, we include
    a `postStop` life cycle hook for the timer in order to cancel it if our actor
    stops. We have done this because, if the actor is no longer there, there will
    be no one around to listen out for the timer signal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Baker`actor维护一个生饼干的内部队列，并定期将它们放入烤箱中。这是一个老式烤箱，为了使用它，我们需要设置一个厨房计时器以便在适当的时间提取烘焙好的饼干。最后，我们为计时器添加一个`postStop`生命周期钩子，以便在actor停止时取消它。我们这样做是因为，如果actor不再存在，就没有人会在那里监听计时器的信号。'
- en: The life cycle of an actor
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor的生命周期
- en: 'Actors in Akka define a number of methods which are called at different moments
    during their lifetime, specifically:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Akka中的Actors定义了在它们生命周期不同时刻被调用的方法，具体如下：
- en: '`preStart`: Called after the actor is started or during restart'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preStart`: 在actor启动后或重启期间调用'
- en: '`preRestart`: Called on the actor which is about to be destroyed because of
    the restart'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preRestart`: 在即将因重启而被销毁的actor上调用'
- en: '`postRestart`: Called on the actor who was just created after the restart'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postRestart`: 在重启后刚刚创建的actor上调用'
- en: '`postStop`: Called after the actor is stopped'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postStop`: 在actor停止后调用'
- en: 'The order of execution, given two instances of the same actor—one that has
    failed and another one that has been created as a replacement—is shown as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个相同actor的实例——一个已经失败，另一个作为替代被创建——它们的执行顺序如下所示：
- en: 'Actor A, stopping: `constructor` | `preStart` | `preRestart` | `postStop`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor A，停止：`constructor` | `preStart` | `preRestart` | `postStop`
- en: 'Actor B, starting: `constructor` | `postRestart` | `preStart` | `postStop`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor B，启动：`constructor` | `postRestart` | `preStart` | `postStop`
- en: Now, we can implement a `Chef` actor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现一个`Chef`actor。
- en: This actor will combine ingredients to produce dough. It will use its magical
    powers to create a `Mixer` and will use this `Mixer` to do the actual blending
    work. One `Mixer` has limited capacity, and so the `Chef` will need to create
    multiple mixers for bigger shopping lists and use them in parallel in order to
    speed up the preparation process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个actor将结合原料制作面团。它将使用它的神奇力量来创建一个`Mixer`，并使用这个`Mixer`来完成实际的混合工作。一个`Mixer`的容量有限，因此`Chef`需要为更大的购物清单创建多个搅拌器，并并行使用它们以加快准备过程。
- en: 'We''ll start by defining a mixer:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个搅拌器：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Mixer` only understands a single type of message, `Groceries`. After getting
    this type of message, it produces a certain amount of `Dough` by mixing all of
    the ingredients together and returns it to the sender. `Thread.sleep` represents
    blocking—waiting for the hardware to complete its operation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mixer` 只理解一种消息类型，即 `Groceries`。在接收到这种类型的消息后，它会通过混合所有原料产生一定量的 `Dough` 并将其返回给发送者。`Thread.sleep`
    表示阻塞——等待硬件完成其操作。'
- en: Try to avoid blocking. Blocking in the actor consumes a thread, and if many
    actors have blocked, other actors will be starved for threads and won't be able
    to process messages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免阻塞。在演员中的阻塞会消耗一个线程，如果许多演员都阻塞了，其他演员将因线程不足而无法处理消息。
- en: Unfortunately, in our case, blocking is unavoidable during the mixing operation
    because of hardware limitations. Akka offers a solution to this problem in the
    form of dispatchers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在我们的案例中，由于硬件限制，在混合操作期间阻塞是不可避免的。Akka 以分派器的形式提供了解决这个问题的方案。
- en: Dispatchers
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分派器
- en: 'Dispatchers are the machinery that makes actors work. They are responsible
    for assigning CPU to the actors, managing actor''s mailboxes, and passing over
    messages from the mailbox to an actor. There are four commonly used types of dispatchers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分派器是使演员工作的机器。它们负责分配 CPU 给演员，管理演员的邮箱，并将邮箱中的消息传递给演员。有四种常用的分派器类型：
- en: '**Default dispatcher: **This dispatcher creates one mailbox per actor and may
    be shared by any number of actors. It uses `java.util.concurrent.ExecutorService`
    for this process. It is designed to be used in combination with actors having
    a nonblocking code. The dispatcher selects an idle thread and assigns it to an
    actor of its choice. The actor then processes a certain number of messages before
    releasing the thread.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认分派器：**这种分派器为每个演员创建一个邮箱，并且可以被任何数量的演员共享。它使用 `java.util.concurrent.ExecutorService`
    来完成这个过程。它设计用于与非阻塞代码的演员一起使用。分派器选择一个空闲的线程并将其分配给它选择的演员。然后演员处理一定数量的消息，之后释放线程。'
- en: '**Balanced dispatcher: **This dispatcher creates a single mailbox that can
    be shared by multiple actors of the same kind. Messages from the mailbox are distributed
    among actors sharing the dispatcher.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平衡分派器：**这种分派器创建一个可以被同一类型的多个演员共享的单个邮箱。来自邮箱的消息在共享分派器的演员之间进行分配。'
- en: '**Pinned dispatcher: **This dispatcher uses a thread pool with a single thread.
    This thread is assigned to a single actor. Thus, each actor has its own thread
    and mailbox, and can perform blocking or long-running activities without starving
    other actors.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定分派器：**这种分派器使用一个线程池的单个线程。这个线程被分配给一个演员。因此，每个演员都有自己的线程和邮箱，可以在不影响其他演员的情况下执行阻塞或长时间运行的活动。'
- en: '**CallingThread dispatcher: **This dispatcher assigns one thread per actor.
    This is mainly used for testing.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用线程分派器：**这种分派器为每个演员分配一个线程。这主要用于测试。'
- en: 'In our case, the `Mixer` has a blocking call in its implementation. Because
    of this, we are better off with the pinned dispatcher. First, we''ll add a dispatcher
    configuration to `application.conf`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`Mixer` 的实现中有一个阻塞调用。正因为如此，我们更倾向于使用固定分派器。首先，我们将向 `application.conf` 添加一个分派器配置：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The name of the dispatcher is defined at the root level of the configuration
    and isn't nested into the `akka` namespace.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 分派器的名称在配置的根级别定义，并且不嵌套在 `akka` 命名空间中。
- en: Akka uses Typesafe Config as a configuration library. It is a very powerful
    and useful configuration facility that's absolutely worth checking out. You can
    find it at [https://github.com/lightbend/config](https://github.com/lightbend/config).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 使用 Typesafe Config 作为配置库。这是一个非常强大且有用的配置设施，绝对值得一看。您可以在 [https://github.com/lightbend/config](https://github.com/lightbend/config)
    找到它。
- en: 'And then we can use the configured dispatcher at the moment we create an actor:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在创建演员时使用配置的分派器：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way, each of the mixers will have its own thread, and blocking will not
    affect its siblings and other actors in the system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个混合器都将有自己的线程，阻塞不会影响其兄弟姐妹和其他系统中的演员。
- en: After waiting, the mixer returns the produced dough to the `sender()` and sends
    itself a `PoisonPill` so that it can terminate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待后，混合器将生产的面团返回给 `sender()` 并给自己发送一个 `PoisonPill` 以便终止。
- en: Terminating actors
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止演员
- en: 'There are a couple of ways to stop an actor in Akka. The most direct approach
    involves calling the `stop` method of the context, like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Akka 中停止一个演员有几种方法。最直接的方法是调用上下文的 `stop` 方法，如下所示：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The actor terminates asynchronously after it finishes processing its current
    message, but not after other messages in the inbox. This contrasts to sending
    an actor a `PoisonPill` or `Kill` message, which is enqueued into the mailbox
    and processed in an orderly fashion.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当演员处理完当前消息后，它会异步终止，但不会在收件箱中的其他消息之后终止。这与向演员发送`PoisonPill`或`Kill`消息不同，这些消息会被排队到邮箱中，并按顺序处理。
- en: The `Kill` message will cause an actor to throw an `ActorKilledException`, which
    in turn will involve its supervision chain (more on that topic later in this chapter)
    to decide how this actor's *failure* should be handled.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kill`消息将导致演员抛出`ActorKilledException`异常，这反过来又涉及其监管链（关于这个话题，在本章后面将详细介绍）以决定如何处理这个演员的*失败*。'
- en: Stopping an actor using a `context` or `PoisonPill` in contrast to `Kill` is
    done gracefully. The actor will stop all of its children, execute life cycle hooks,
    and inform its supervisor appropriately.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`Kill`相比，使用`context`或`PoisonPill`停止演员是优雅的。演员将停止其所有子演员，执行生命周期钩子，并适当地通知其监管者。
- en: The actor's termination is propagated top-down, but the actual stopping occurs
    bottom-up. One slow actor that takes a long (or infinite) time to stop can prevent
    the whole chain of actors from being terminated.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 演员的终止是自上而下传播的，但实际的停止是自下而上的。一个慢速演员可能需要很长时间（或无限时间）来停止，这可能会阻止整个演员链的终止。
- en: 'Now that we have our blocking `Mixer`, it is time to define a `Chef`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的阻塞`Mixer`，是时候定义一个`Chef`了：
- en: The ask pattern
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ask模式
- en: 'With the `Chef`, we will introduce another popular pattern in Akka—the ask
    pattern:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Chef`，我们将介绍Akka中另一个流行的模式——ask模式：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are lots of things happening here, so let's go over the code line by line
    and describe what's going on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们逐行分析代码，并描述正在发生的事情。
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our `Chef` actor is not only an `Actor`—but it also extends `ActorLogging` and
    `Stash`. The `ActorLogging` trait gives an actor a predefined `logger`.  It is
    also possible to define the `Logger` directly, for example, as shown in the following
    code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Chef`演员不仅是一个`Actor`——它还扩展了`ActorLogging`和`Stash`。`ActorLogging`特质为演员提供了一个预定义的`logger`。也可以直接定义`Logger`，例如，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Akka uses a special message-based logging facility internally to minimize blocking
    inside of an actor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Akka内部使用基于消息的特殊日志记录设施，以最小化演员内部的阻塞。
- en: 'Akka logging supports SLF4J as a backend. The official documentation ([https://doc.akka.io/docs/akka/2.5/logging.html](https://doc.akka.io/docs/akka/2.5/logging.html))
    has a detailed explanation on how to extend the configuration to enable SLF4J
    logging into an Akka application:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Akka日志记录支持SLF4J作为后端。官方文档（[https://doc.akka.io/docs/akka/2.5/logging.html](https://doc.akka.io/docs/akka/2.5/logging.html)）详细解释了如何扩展配置以启用SLF4J日志记录到Akka应用程序中：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we have defined a timeout of 5 seconds, which will be necessary the moment
    we start working with mixers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个5秒的超时，当我们开始使用混合器时将需要这个超时：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `receive` method, our actor only accepts `Groceries` messages and uses
    pattern matching to extract field values:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`receive`方法中，我们的演员只接受`Groceries`消息，并使用模式匹配来提取字段值：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our mixers are small, so we need to split the groceries at hand into portions
    of one egg so that the portion fits into the mixer:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的混合器很小，所以我们需要将手头的杂货分成一个鸡蛋的份量，以便这部分可以放入混合器中：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we created a `Mixer` actor using the `props` defined earlier (which in
    turn assigns the proper dispatcher to it) and named it appropriately.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用之前定义的`props`创建了一个`Mixer`演员（这反过来又为它分配了正确的分发器），并适当地为其命名。
- en: 'In the following two lines of code, we can see implicit `ask` magic at work:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下两行代码中，我们可以看到隐式`ask`魔法的应用：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Having to `ask` in scope allows us implicitly to convert an `ActorRef` into
    `AskableActorRef`, which is then used as a target for the message. The `actor
    ? message` syntax represents the ask pattern. Akka sends a message to the target
    actor and creates an expectation of the response as a `Future[Any]`. This `Future`
    can be worked with like any other `Future`. For convenience, Akka provides a `mapTo[T]` method,
    which allows you to convert it into the `Future[T]`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域内需要`ask`允许我们隐式地将`ActorRef`转换为`AskableActorRef`，然后将其用作消息的目标。`actor ? message`语法表示ask模式。Akka向目标演员发送消息，并创建一个响应的期望作为`Future[Any]`。这个`Future`可以像其他任何`Future`一样处理。为了方便，Akka提供了一个`mapTo[T]`方法，允许你将其转换为`Future[T]`。
- en: 'The final piece of code in the `for` comprehension uses another implicit conversion
    provided by Akka, this time acting on the `Future`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`理解中的最后一行代码，使用了Akka提供的另一个隐式转换，这次是针对`Future`的：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we're bringing in scope a `pipe` which transforms the normal `Future` into
    the `PipeableFuture`. The latter can be piped into one or multiple actors, as
    shown in the third line of the preceding code, by using an implicit execution
    context that was imported in the second line.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了一个`pipe`作用域，它将正常的`Future`转换为`PipeableFuture`。后者可以通过使用第二行导入的隐式执行上下文，像前述代码的第三行那样，被管道传输到一个或多个演员。
- en: The third line of code pipes the result of the `Future` execution to the sender
    in the case of it being a success.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行代码在成功的情况下将`Future`执行的结果管道传输给发送者。
- en: We could use `job.recoverWith` to resend the job to the mixer if the first attempt
    fails. This is a simple way to implement "at least once" semantics using the ask
    pattern.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一次尝试失败，我们可以使用`job.recoverWith`将作业重新发送到混音器（mixer）。这是使用ask模式实现“至少一次”语义的简单方法。
- en: 'Having created all of the mixers and sent them work packages, the `Chef` actor
    writes a log entry and starts to wait for the results:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建所有混音器并发送工作包后，`Chef`演员写入日志条目并开始等待结果：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There is a special syntax in Akka logging. The first argument is a `String` that
    incorporates `{}` placeholders to denote other arguments. The substitution is
    done in a separate thread, but only if the respective log level is enabled. This
    is done to minimize the logging work done by the actor's thread.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Akka日志中有一个特殊的语法。第一个参数是一个`String`，其中包含`{}`占位符来表示其他参数。替换是在单独的线程中完成的，但只有当相应的日志级别被启用时。这样做是为了最小化演员线程的日志工作。
- en: Changing an actor's behavior using context
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文改变演员的行为
- en: In the last line of code, the actor changes its behavior by using the `context.become` construct.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的最后一行，演员通过使用`context.become`构造来改变其行为。
- en: '`become` and `unbecome` is an Akka way of changing the behavior of the actor
    in response to a message. `become` takes a `Receive` argument (which is a type
    alias for `PartialFunction[Any, Unit]`, which is also just a normal sign of the `receive` method)
    which becomes a new actor''s behavior starting from the next message (this change
    in behavior is not preserved across actor restarts). The `discardOld` parameter
    controls whether this new behavior should replace an old one or whether it should
    just push it down to the stack of behaviors that actors maintain internally. We''ll
    see how this stack works in a minute.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`become`和`unbecome`是Akka在接收到消息时改变演员行为的常用方法。`become`接受一个`Receive`参数（它是`PartialFunction[Any,
    Unit]`的类型别名，也是`receive`方法的正常签名），它从下一个消息开始成为新的演员行为（这种行为的变化在演员重启时不会保留）。`discardOld`参数控制这个新行为是否应该替换旧行为，或者是否应该仅仅将其推到演员内部维护的行为堆栈中。我们将在下一分钟看到这个堆栈是如何工作的。'
- en: 'Let''s go over the `waitingForResults` method, which became a new behavior
    of the actor a moment ago. The first line puts any `Groceries` messages on hold
    because we are already waiting for jobs to be finished. This is done by using
    the `stash()` method of the `Stash` trait, which puts the current message into
    an internal stash of the actor:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`waitingForResults`方法，这是演员刚才获得的新行为。第一行将任何`Groceries`消息挂起，因为我们已经在等待作业完成。这是通过使用`Stash`特质的`stash()`方法完成的，该方法将当前消息放入演员的内部存储中：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Chef` actor watches over the `Mixer` actors it has created. In this case,
    if a child actor dies, the watching actor will receive a `Terminated` message
    with an actor reference of the victim:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chef`演员监视它所创建的混音器（Mixer）演员。在这种情况下，如果一个孩子演员死亡，监视演员将接收到一个包含受害者演员引用的`Terminated`消息：'
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The actor checks whether all of the children are terminated by using `context.children`,
    and if this is the case, it prepends all of the stashed messages to the message
    box by using `unstashAll()` and returns to its previous behavior by using `context.unbecome()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 演员（actor）通过使用`context.children`检查所有孩子（children）是否都已终止，如果是这样，它将使用`unstashAll()`将所有存储的消息（stashed
    messages）添加到消息框中，并通过使用`context.unbecome()`返回到其先前的行为。
- en: Unbalanced `context.become()` and `context.unbecome()` operations might introduce
    the source of a memory leak in long-running applications.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不平衡的`context.become()`和`context.unbecome()`操作可能会在长时间运行的应用程序中引入内存泄漏的源头。
- en: Now that our `Chef` is ready, let's move on and implement a `Manager`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`Chef`，让我们继续并实现一个`Manager`。
- en: Advanced topics
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: Up until now, we have implemented our bakery by relying on basic Akka concepts.
    It is time to deepen our knowledge and start to use higher level concepts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过依赖基本Akka概念来实现我们的面包店。现在是时候深化我们的知识并开始使用高级概念了。
- en: Akka FSM
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka FSM
- en: The `Manager` pushes the cookie-making process forward by coordinating all other
    inhabitants of the bakery. It does so by taking the messages representing job
    results from one actor and passing them further along to an appropriate successor.
    It is important that this process is consequent, that is, it should be impossible
    to make raw cookies at the moment since we only have a shopping list and no dough.
    We'll represent this behavior as a state machine.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Manager`通过协调面包店的其他居民来推进饼干制作过程。它通过从演员那里获取表示工作结果的短信并将它们传递给适当的后续者来实现这一点。这个过程应该是连续的，也就是说，在目前只有购物清单而没有面团的情况下，应该不可能制作生饼干。我们将这种行为表示为状态机。'
- en: An FSM is an abstraction defined by a set of states the machine can be in. For
    each state, it also defines which message types can be accepted in this state
    and the possible reaction of the machine, including its new state.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机（FSM）是由机器可以处于的一组状态定义的抽象。对于每个状态，它还定义了在此状态下可以接受的消息类型以及机器的可能反应，包括其新状态。
- en: Let's dive into the code and see how this approach is implemented with Akka
    FSM.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究代码，看看如何使用Akka FSM实现这种方法。
- en: 'The actor is defined by extending the `FSM` trait:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 演员是通过扩展`FSM`特质来定义的：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The type parameter, `State`, represents the type of states the actor can be
    in, and the `Data` represents the possible associated internal state.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数`State`表示演员可以处于的状态类型，而`Data`表示可能的关联内部状态。
- en: There is an obvious confusion between the term *State*, referring to the state
    of the FSM our actor represents, and a *State* referring to the data which is
    associated with each of the steps in the process. To avoid ambiguity, we'll further refer
    to the state of the actor as *Data* and the state of the FSM as *State*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*State*（指代演员所代表的FSM的状态）和*State*（指代与过程中每个步骤相关联的数据）之间有一个明显的混淆。为了避免歧义，我们将进一步将演员的状态称为*Data*，将FSM的状态称为*State*。
- en: 'States of the actor reflect the processes that occur in the bakery: the goods
    moving from the shop boy over to the chef and cook, which then move over to the
    baker and back to the manager (note that because of the sequential art of work-passing
    done by the manager, there will be only one worker actor active in our bakery
    at the moment, even if they could work in parallel with a more sophisticated manager).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 演员的状态反映了面包店中发生的过程：商品从店员转移到厨师和厨师，然后转移到面包师，再回到经理（注意，由于经理执行的工作传递的顺序艺术，在我们面包店中此时只有一个工作演员是活跃的，即使他们可以与更复杂的经理并行工作）。
- en: 'The following messages represent the state of the managed bakery:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下消息表示受管理面包店的状态：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The messages we defined previously also need to be extended to represent the possible
    types of data:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的消息也需要扩展以表示可能的数据类型：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The FSM itself is defined by describing three primary aspects of the state
    machine:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机（FSM）本身是通过描述状态机的三个主要方面来定义的：
- en: States
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: State transitions
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态转换
- en: An initial state
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态
- en: 'Let''s take a look at the actor''s code to see how this is done. The states
    are defined within the `when` block, which accepts a state name and a state function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看演员的代码，看看这是如何实现的。状态是在`when`块中定义的，它接受一个状态名称和一个状态函数：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When there are multiple `when` blocks for the same states, the state functions
    that constitute them are concatenated.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一状态下有多个`when`块时，构成它们的州函数将被连接。
- en: The state function is a `PartialFunction[Event, State]`, and describes a new
    state for each event type received in a particular state. Akka FSM provides a
    nice domain specific language (DLS) for this. For example, in the preceding code,
    the actor reacts to the `ShoppingList` event by transitioning to the `Shopping` state
    with a timeout of 5 seconds. The shopping list is used as new state data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 状态函数是一个`PartialFunction[Event, State]`，它描述了在特定状态下接收到的每个事件类型的新状态。Akka FSM为此提供了一个很好的领域特定语言（DLS）。例如，在先前的代码中，演员通过在5秒超时的情况下将状态转换为`Shopping`状态来响应`ShoppingList`事件。购物清单用作新的状态数据。
- en: In the case of any other message, the actor stays in the same state and replies
    to the sender with a friendly remark.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他消息的情况下，演员保持同一状态，并以友好的评论回复发送者。
- en: 'In the `Shopping` state, the `Manager` reacts differently depending upon whether
    the groceries conform to the shopping list or not:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Shopping`状态中，`Manager`根据杂货是否符合购物单而做出不同的反应：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the first case, it uses `Groceries` as a new state and goes to the next state.
    In the second case, it goes back to the `Idle` state and sets its state to `Uninitialized`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，它使用`Groceries`作为新的状态并进入下一个状态。在第二种情况下，它回到`Idle`状态并将状态设置为`Uninitialized`。
- en: 'Other states are described in a similar fashion:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其他状态以类似的方式描述：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''re just moving on to the next state and updating the state data in the
    process. The most obvious observation at the moment would be that `This actor
    does nothing but enjoying himself`, and we''re going to fix this by using the
    `onTransition` block, which describes the behavior of the actor at the moment
    state transition occurs:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在进入下一个状态的过程中移动并更新状态数据。目前最明显的观察结果是`这个演员除了自得其乐之外什么都不做`，我们将通过使用`onTransition`块来解决这个问题，该块描述了演员在状态转换发生时的行为：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `Manager` already knows its subordinates, so it only needs to look up a
    `Boy`. Then, for each of the state transitions, it obtains the necessary state
    by using either `stateData` or `nextStateData`, which references the actor's state
    data before and after the respective state transition. This data is sent to the
    appropriate subordinate.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Manager` 已经知道其下属，因此它只需要查找一个`Boy`。然后，对于每个状态转换，它通过使用`stateData`或`nextStateData`来获取必要的状态，这些数据引用了在相应状态转换之前和之后的演员状态数据。这些数据被发送到适当的下属。'
- en: Now, all that's missing is an optional `whenUnhandled` block, which is executed
    in all states. The timer setting and a mandatory `initiate()` call sets up the
    defined timer and performs a state transition to the initial state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一缺少的是可选的`whenUnhandled`块，它在所有状态下执行。定时器设置和强制`initiate()`调用设置了定义的定时器并执行到初始状态的状态转换。
- en: Akka FSM forces you to mix business logic with actor-related code, which makes
    it hard to test and support it. It also locks you into the provided implementation
    and makes it impossible to bring in another state machine realization. Always
    consider another possibility before fixing upon Akka FSM.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Akka FSM 强迫你将业务逻辑与演员相关代码混合，这使得测试和支持它变得困难。它还使你锁定在提供的实现中，使得引入另一个状态机实现变得不可能。在决定使用
    Akka FSM 之前，始终考虑其他可能性。
- en: At the same time, by separating the definition of states separately from behavior, Akka
    FSM allows for clean structuring of the business logic.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，通过将状态的定义与行为分开，Akka FSM 允许对业务逻辑进行清晰的构建。
- en: Akka remoting
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka 远程操作
- en: Now, we can implement the final piece of the puzzle—the shop boy and the `sendBoy` function
    that we left uncovered until now. The `Boy` does not belong to the `Bakery`. The
    `Manager` will need to send the `Boy` to the grocery `Store`, which is represented
    by another actor system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现拼图的最后一部分——商店男孩和之前未覆盖的`sendBoy`函数。男孩不属于`Bakery`。管理者需要将男孩发送到代表另一个演员系统的杂货`Store`。
- en: In order to do so, we'll rely on Akka's location transparency and remote capabilities.
    First, the manager will deploy a boy actor to the remote system. The deployed
    actor will get a reference to the `Seller` actor in the store so that it can get
    groceries as and when required.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将依赖 Akka 的位置透明性和远程功能。首先，管理者将部署一个男孩演员到远程系统中。部署的演员将获得商店中`Seller`演员的引用，以便它可以在需要时获取杂货。
- en: There are two ways to use remoting in Akka—either by using actor lookup or actor
    creation. Both are used in the same way that we did locally until now, that is,
    by calling `actorSelection` and `actorOf`, respectively.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Akka 中使用远程操作有两种方式——要么通过使用演员查找，要么通过使用演员创建。这两种方式与我们迄今为止在本地使用的方式相同，即通过调用`actorSelection`和`actorOf`分别实现。
- en: Here, we will demonstrate both ways that the manager will look up a seller from
    whom the boy should get groceries (imagine this seller is working with the bakery
    on a prepaid basis) and then require the boy to interact with this specific actor.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将演示管理者如何查找男孩应该从他那里获取杂货的卖家（想象这个卖家与面包店以预付费为基础合作），然后要求男孩与这个特定的演员进行交互。
- en: 'Before we dive into the code, we need to augment the setup of our application.
    Remoting is a separate dependency in Akka which we will put into the `build.sbt`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们需要增强我们应用程序的设置。远程操作是 Akka 中的一个独立依赖项，我们将将其放入`build.sbt`：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we need to replace the local actor provider with the remote one and configure
    the network settings in `application.conf`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将本地演员提供者替换为远程的一个，并在 `application.conf` 中配置网络设置：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The same configuration, but with a necessarily different port, is provided
    for the second actor system that''s representing the grocery store. This is done
    by reusing the `application.conf` via inclusion and redefining the TCP port:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的配置，但端口必须不同，是为代表杂货店的第二个演员系统提供的。这是通过包含 `application.conf` 并重新定义 TCP 端口来完成的：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we need to define the grocery store:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义杂货店：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can't use the default configuration as it is already taken by the bakery
    system, so we need to load a custom `grocery.conf` by using `ConfigFactory.load`.
    Next, we need to create an anonymous (but named!) actor whose sole responsibility
    is to return groceries, as described by the `ShoppingList`, to the sender.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用默认配置，因为它已经被面包店系统占用，所以我们需要使用 `ConfigFactory.load` 加载一个自定义的 `grocery.conf`。接下来，我们需要创建一个匿名（但命名！）演员，其唯一责任是根据
    `ShoppingList` 将杂货返回给发送者。
- en: 'Finally, we''re ready to implement the `sendBoy` function in the `Manager`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备在 `Manager` 中实现 `sendBoy` 函数：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we must define the address of the grocery store. Then, we need to look
    up a seller by using its address on the remote system. Akka''s documentation specifies
    the following pattern for remote actor lookup:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义杂货店的地址。然后，我们需要使用远程系统上的地址查找卖家。Akka 的文档指定了以下远程演员查找的模式：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We'll take a look at this template and especially the actor path in a moment.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后查看这个模板，特别是演员路径。
- en: 'Then, we need to create a boy by using our usual `actorOf` method. To tell
    Akka to deploy this actor remotely, we need to put the following configuration
    into `application.conf`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用我们常用的 `actorOf` 方法创建一个男孩。为了告诉 Akka 远程部署这个演员，我们需要将以下配置放入 `application.conf`：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This instructs Akka not to instantiate a local actor but to contact the remote
    daemon running in the actor system with the name `Store` with a network address
    of `127.0.0.1:2553` and to tell this daemon to create a remote actor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 Akka 不要实例化一个本地演员，而是通过名为 `Store` 的网络地址 `127.0.0.1:2553` 的远程守护进程来联系演员系统，并告诉这个守护进程创建一个远程演员。
- en: 'We could achieve the same result without extending configuration by providing
    deployment configuration directly in the code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不扩展配置的情况下实现相同的结果，直接在代码中提供部署配置：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This snippet creates a store address from the string we defined earlier and
    explicitly tells Akka to use it while creating the actor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段创建了一个从我们之前定义的字符串中创建的商店地址，并明确告诉 Akka 在创建演员时使用它。
- en: 'The implementation of `Boy` is trivial now:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boy` 的实现现在很简单：'
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Boy` constructor's takes a parameter of type `ActorSelection`, which is
    the result of the remote lookup that was done by the `Manager` previously. By
    receiving a `ShoppingList`, our implementation uses `forward` to, well, forward
    the message directly to the seller. Because of this forwarding, the seller will
    receive a message with the original actor (who is a manager) as a sender.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boy` 构造函数接受一个类型为 `ActorSelection` 的参数，这是之前由 `Manager` 执行的远程查找的结果。通过接收一个 `ShoppingList`，我们的实现使用
    `forward` 将消息直接转发给卖家。正因为这种转发，卖家将收到一个由原始演员（即管理者）作为发送者的消息。'
- en: Finally, we will take into the account that the boy was created by the manager
    just for the purpose of going shopping once, and we need to clean up the resources.
    This can be done by the manager actor, but we prefer self-cleanup here. The `Boy`
    sends himself a `PoisonPill` immediately after forwarding the original message and
    terminates.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将考虑到男孩是由管理者仅为一次购物而创建的，我们需要清理资源。这可以通过管理者演员完成，但我们更倾向于在这里进行自我清理。`Boy` 在转发原始消息后立即发送给自己一个
    `PoisonPill` 并终止。
- en: 'Now that we''re done defining all of the inhabitants of our bakery, we can
    wire them together and bake some cookies:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了面包店的全部居民，我们可以将它们连接起来，做一些饼干：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Before we run our app and enjoy some cookies, let's take a break from coding
    and look at the actor path we saw in the remote actor lookup pattern.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行我们的应用程序并享受一些饼干之前，让我们暂时放下编码，看看我们在远程演员查找模式中看到的演员路径。
- en: The actor path
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员路径
- en: In accordance with the actor model, Akka actors are hierarchical.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 根据演员模型，Akka 演员是分层的。
- en: The actor path is built by taking the names of each actor in the hierarchy up
    to the root actor and concatenating them right-to-left using slashes. In the beginning
    of the path, there is an address part identifying the protocol and location of
    the actor system. This address part is called the **anchor** and its representation
    is different for local and remote systems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 角色路径是通过将层次结构中每个角色的名称向上到根角色，然后使用斜杠从右到左连接它们来构建的。在路径的开始部分，有一个地址部分用于标识协议和角色的系统位置。这个地址部分被称为
    **锚点**，其表示方式对于本地和远程系统是不同的。
- en: In our example, the whole path for the `Boy` which is described by the local
    path `/Manager/Boy` in the deployment configuration will be `akka://user/Bakery/Manager/Boy` (purely
    local path) for the `Boy` actor and an akka.tcp://Store@127.0.0.1:2553/user/Seller (remote
    path) for the `Seller` actor in the remote `Store` actor system, as shown from
    the `Bakery` side.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`Boy` 的整个路径，由部署配置中的本地路径 `/Manager/Boy` 描述，对于 `Boy` 演员将是 `akka://user/Bakery/Manager/Boy`（纯本地路径），而对于远程
    `Store` 演员系统中的 `Seller` 演员将是 akka.tcp://Store@127.0.0.1:2553/user/Seller（远程路径），如从
    `Bakery` 方面所示。
- en: As you can see, remoting introduces the necessary differences in the way the
    actor path is built and used.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，远程引入了构建和使用演员路径的方式所必需的差异。
- en: The main purpose of the actor path is to address an actor we are about to send
    messages to. On a technical level, we have an abstraction for sending messages
    to an actor, which is `ActorRef`. For each actor, its `ActorRef` provides access
    to its local reference through the `self` field and to the sender of the current
    message via the `context.sender()`. Each `ActorRef` references exactly one actor.
    `ActorRef` also incorporates a dispatcher and a mailbox for the actor. The dispatcher
    is responsible for queueing messages in the actor's mailbox and dequeueing them
    at a certain time before passing them to the actors' `receive` method.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 角色路径的主要目的是定位我们即将发送消息给的角色。在技术层面上，我们有一个用于向演员发送消息的抽象，即 `ActorRef`。对于每个演员，其 `ActorRef`
    通过 `self` 字段提供对其本地引用的访问，并通过 `context.sender()` 提供对当前消息发送者的访问。每个 `ActorRef` 指向一个演员。`ActorRef`
    还包含演员的调度器和邮箱。调度器负责在演员的邮箱中排队消息，并在将它们传递给演员的 `receive` 方法之前在特定时间将其出队。
- en: 'We''ve already seen both ways to create an `ActorRef`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了创建 `ActorRef` 的两种方式：
- en: By creating an actor using `context.actorOf`
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `context.actorOf` 创建一个角色
- en: By looking up one or multiple actors using `context.actorSelection`
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `context.actorSelection` 查找一个或多个角色
- en: 'There are different ways to provide an actor path for the lookup in the second
    case:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，有不同方式提供演员路径进行查找：
- en: '**Absolute path**: `context.actorSelection("/user/Manager/Boy")` returns a
    single actor with a path specified or empty selection'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对路径**：`context.actorSelection("/user/Manager/Boy")` 返回一个具有指定路径或空选择的单个演员'
- en: '**Relative path**: `context.actorSelection("../sibling")` goes up to the parent
    in the hierarchy and then down to the "sibling" in the case that it exists.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对路径**：`context.actorSelection("../sibling")` 向上到层次结构中的父级，然后在存在的情况下向下到 "sibling"。'
- en: '**Wildcards**: `context.actorSelection("../*")` goes up in the hierarchy and
    selects all of the children of the actor''s parent, including the current actor'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通配符**：`context.actorSelection("../*")` 向上到层次结构，并选择演员父级的所有子代，包括当前演员'
- en: Actor supervision
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色监督
- en: Now, let's explain another strangeness in the actor path that you are probably
    wondering about—the leading `/user` part in the actors paths we've seen before.
    The existence of this part is Akka's answer to the question we stated at the beginning
    of this chapter—*How is the very first actor created?*
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解释另一个你可能想知道的演员路径中的奇怪之处——我们之前看到的演员路径中的前导 `/user` 部分。这一部分的存在是 Akka 对我们在本章开头提出的问题的回答——*第一个角色是如何创建的？*
- en: In Akka, the very first actor is created by the library itself. It represents
    a root actor and is called the root guardian accordingly (we'll explain the *guardian* part
    in a moment).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Akka 中，第一个角色是由库本身创建的。它代表一个根角色，因此被称为根守护者（我们将在稍后解释 *守护者* 部分的内容）。
- en: In fact, Akka creates three guardian actors for each actor system, as shown
    in the following diagram.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Akka 为每个演员系统创建了三个守护者演员，如下面的图所示。
- en: The `/` root guardian is a parent for two other guardians and thus an ancestor
    of any other actor in the system.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 根守护者是两个其他守护者的父级，因此是系统中任何其他角色的祖先。'
- en: The `/user` guardian is a root actor for all user-created actors in the system.
    Thus, every actor created by any user of the Akka library has two parents in the
    hierarchy and therefore has `/user/` as a prefix in its path.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`/user` 守护者是系统中所有用户创建的演员的根演员。因此，由 Akka 库的任何用户创建的每个演员在层次结构中都有两个父演员，因此其路径前缀为
    `/user/`。'
- en: The `/system` is a root actor for internal actors that have been created by
    the system.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`/system` 是系统创建的内部演员的根演员。'
- en: 'Let''s extend our actor diagram with the guardian actors we just learned about:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们刚刚学到的守护者演员扩展我们的演员图：
- en: '![](img/ad82fdc8-a14d-4c0a-9940-6f5cfc664e96.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad82fdc8-a14d-4c0a-9940-6f5cfc664e96.png)'
- en: We instantiate all of our actors except mixers by using `system.context`. Because
    of this, they are created as children of the user guardian. The root guardian
    is on the top of the hierarchy and has a user guardian and a system guardian as
    its children.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `system.context` 实例化所有演员，除了混合器。因此，它们被创建为用户守护者的子演员。根守护者在层次结构的顶部，其子演员是用户守护者和系统守护者。
- en: The guardians are a part of another important feature of Akka—supervision. To
    understand what supervision is and why it is important, let's finally run our
    application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 守护者是 Akka 另一个重要功能——监督的一部分。为了了解什么是监督以及为什么它很重要，让我们最终运行我们的应用程序。
- en: 'The following is the sanitized output in the console:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在控制台中的清理输出：
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What happened? The actor system has started and communication between actors
    begun, but then an `AssertionError` was thrown and the whole system terminated!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？演员系统已启动，演员之间的通信也已开始，但随后抛出了一个 `AssertionError` 并导致整个系统终止！
- en: 'The reason for this exception is a trivial programming error in the `Baker` actor
    we described previously:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异常的原因是我们之前描述的 `Baker` 演员中的简单编程错误：
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The assertion that the timer is empty is wrong, and so it throws an exception
    at runtime. The exception is not caught and leads to termination of the program.
    Obviously, in this case, the rules of the actor model (as described at the beginning
    of this chapter) are not respected. One actor affects all other actors and the
    system as a whole without sending any messages.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 断言“计时器为空”是错误的，因此在运行时抛出异常。该异常没有被捕获，导致程序终止。显然，在这种情况下，演员模型（如本章开头所述）的规则没有得到尊重。一个演员在没有发送任何消息的情况下影响了所有其他演员和整个系统。
- en: In fact, this is not some deficiency of Akka. The reason our application behaves
    as it does is that we ignored the very important aspect of actor-based systems—supervision.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这并不是 Akka 的缺陷。我们的应用程序之所以表现如此，是因为我们忽略了基于演员系统的非常重要的一个方面——监督。
- en: Supervision in Akka means that any actor creating a child is responsible for
    its management in case problems occur.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Akka 中，监督意味着任何创建子演员的演员在出现问题的情况下负责其管理。
- en: An actor detecting erroneous conditions is expected to suspend all of its descendants
    and itself and report a failure to its parent. This failure reporting has a form
    of exception throwing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 检测到错误条件的演员应暂停其所有后代和自身，并向其父演员报告失败。这种失败报告具有异常抛出的形式。
- en: By convention, expected erroneous conditions, for example, an absence of a record
    in the database, are modelled on the protocol level via messages and errors of
    a technical nature, such as unavailable database connections modelled with exceptions.
    To better differentiate between erroneous conditions, developers are encouraged
    to define a rich set of exception classes, similar to that of normal message classes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，预期的错误条件，例如数据库中记录的缺失，通过技术性质的消息和错误在协议级别进行建模，例如使用异常来模拟不可用的数据库连接。为了更好地区分错误条件，鼓励开发人员定义一组丰富的异常类，类似于正常消息类。
- en: 'Exceptions thrown by the child actor are delivered to the parent, who then
    needs to handle the situation in one of four possible ways:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 子演员抛出的异常被传递给父演员，然后父演员需要以四种可能的方式之一来处理这种情况：
- en: Resume the child and let it process messages in the message box, starting from
    the next one. The message that caused the actor to fail is lost.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复子演员，并让它从下一个开始处理消息框中的消息。导致演员失败的该消息已丢失。
- en: Restart the child. This will clean up its internal state and recursively stop
    all of its descendants.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动子演员。这将清理其内部状态，并递归地停止其所有后代。
- en: Stop the child completely. This is also recursively propagated to the descendants.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全停止子演员。这也会递归地传播到其后代。
- en: Propagate the failure to its own parent. By doing this, the supervisor is failing
    itself with the same cause as the subordinate.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将故障传播给其父组件。通过这样做，监督者以与下属相同的原因为自己失败。
- en: Before delving into the technical aspects of defining a supervision strategy,
    let's revisit our actor's structure. Currently, all of our actors (with the exception
    of dynamic mixers) are created as direct children of the user guardian. This leads
    to the necessity to define the supervision strategy in one place for the whole
    actor hierarchy. This is a clear violation of the principle of separation of concerns,
    and is known in Akka as a *Flat Actor Hierarchy* anti-pattern. What we should
    aim for instead is creating a structure where failure handling happens close to
    the place the error occurred by the actor that is most capable of handling such
    errors.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究定义监督策略的技术细节之前，让我们回顾一下我们的演员结构。目前，我们所有的演员（除了动态混合器）都是作为用户守护者的直接子组件创建的。这导致有必要在演员层次结构的整个位置定义监督策略。这是对分离关注点原则的明显违反，在Akka中被称为*扁平演员层次结构*反模式。我们应该追求的是创建一个结构，其中错误处理发生在最接近错误发生位置的演员处，该演员最有能力处理此类错误。
- en: 'With this goal in mind, let''s restructure our application so that the `Baker`
    actor is responsible for the supervision of the `Oven` and the `Manager` is responsible
    for all of the actors in the system. This structure is represented in the following
    diagram:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以此目标为指导，让我们重构我们的应用程序，使`Baker`演员负责监督`Oven`，而`Manager`负责系统中所有的演员。这种结构在以下图中表示：
- en: '![](img/49c75977-26b5-403f-94af-1149487839e0.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49c75977-26b5-403f-94af-1149487839e0.png)'
- en: Now, we have a sane hierarchical structure where each supervisor has the best
    knowledge about possible failures of its children and how to deal with them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个合理的层次结构，其中每个监督者都对其子组件可能出现的故障以及如何处理它们有最佳的了解。
- en: 'On a technical level, the supervision strategy is defined by overriding the `supervisorStrategy`
    field of the corresponding actor. To demonstrate how this is done, let''s extend
    our `Mixer` actor with the capability to report different hardware failures. First,
    we must define a rich set of exceptions in the companion object:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术层面上，监督策略是通过覆盖相应演员的`supervisorStrategy`字段来定义的。为了演示如何实现这一点，让我们扩展我们的`Mixer`演员，使其能够报告不同的硬件故障。首先，我们必须在伴随对象中定义一个丰富的异常集：
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And then we need to throw them randomly during message processing:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要在消息处理过程中随机抛出它们：
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we''ll override a supervision strategy in the `Chef` actor:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`Chef`演员中覆盖一个监督策略：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `OneForOneStrategy` instructs the `Chef` to deal with any children's failures
    on an individual basis.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`OneForOneStrategy`指示`Chef`个别处理任何子组件的故障。'
- en: For `MotorOverheatException`, we decide to stop the failing `Mixer`. The `Chef`
    sends an empty `Dough` message to itself which is counted as the response from
    the broken child.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MotorOverheatException`，我们决定停止失败的`Mixer`。`Chef`向自己发送一个空的`Dough`消息，这被视为来自损坏子组件的响应。
- en: The `SlowRotationSpeedException` means that something went wrong during the
    placement of groceries into the `Mixer`. The original message was lost by the
    `Mixer` at the moment it threw an `Exception`, so we're resending this message
    and restarting the `Mixer`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`SlowRotationSpeedException`表示在将食品放入`Mixer`的过程中出现了问题。原始消息在`Mixer`抛出异常时丢失，所以我们正在重新发送此消息并重新启动`Mixer`。'
- en: We can tolerate `StrongVibrationException`, so we just compensate for the lost
    message by resending it and resuming the child.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以容忍`StrongVibrationException`，所以我们只需通过重新发送丢失的消息并恢复子组件来补偿。
- en: In the case of any other exception, the `Chef` has no knowledge of how to handle
    it and just propagates failure to the `Manager`. The `Manager` does not have any
    `supervisorStrategy` defined and the exception is ultimately propagated to the
    user guardian.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他异常的情况下，`Chef`不知道如何处理它，只是将故障传播给`Manager`。`Manager`没有定义任何`supervisorStrategy`，异常最终传播到用户守护者。
- en: 'The user guardian handles exceptions as specified by the default strategy.
    The default strategy is the same for all actors in the userspace if not overridden,
    and is defined as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 用户守护者按照默认策略处理异常。如果没有覆盖，默认策略对所有用户空间中的演员都是相同的，定义如下：
- en: '`ActorInitializationException`: Stops the failing child actor'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActorInitializationException`：停止失败的子演员'
- en: '`ActorKilledException`: Stops the failing child actor'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActorKilledException`：停止失败的子演员'
- en: '`DeathPactException`: Stops the failing child actor'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeathPactException`：停止失败的子演员'
- en: '`Exception`: Restarts the failing child actor'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`：重启失败的子演员'
- en: '`Throwable`: Escalates to the parent actor'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Throwable`：升级到父演员'
- en: The root guardian is configured with `SupervisorStrategy.stoppingStrategy`,
    which differentiates between the `Exception` and other throwables. The former
    leads to the termination of the failing actor (which effectively means all of
    the actors in the `/user` or `/system` space), while the latter is propagated
    further and leads to the termination of the actor system. This is what happened
    when our earlier implementation threw an `AssertionError`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 根守护者配置为`SupervisorStrategy.stoppingStrategy`，它区分了`Exception`和其他可抛出物。前者导致失败演员的终止（这实际上意味着`/user`或`/system`空间中的所有演员），而后者进一步传播并导致演员系统的终止。这就是我们早期实现抛出`AssertionError`时发生的情况。
- en: 'The supervision strategy for the user guardian can be overridden by using its
    configuration property. Let''s demonstrate how to use it to handle the occasional
    `LazinessException`, which could be thrown by any actor in the system. First,
    we augment `application.conf`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用其配置属性来覆盖用户守护者的监督策略。让我们演示如何使用它来处理偶尔抛出的`LazinessException`，这可能是系统中的任何演员抛出的。首先，我们增强`application.conf`：
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And then we implement the configured strategy, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现配置的策略，如下所示：
- en: '[PRE49]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Laziness is contagious, so we use `AllForOneStrategy` to replace the whole team
    by restarting all of the children of the user guardian.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰具有传染性，所以我们使用`AllForOneStrategy`通过重启用户守护者的所有子代来替换整个团队。
- en: Testing actors
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试演员
- en: 'Actor-based systems are different from systems that are built using a traditional
    approach. Naturally, testing actors is different from regular testing. Actors
    send and receive messages in an asynchronous manner and are usually examined via
    message flow analysis. A typical setup will include three parts:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 基于演员的系统与传统方法构建的系统不同。自然地，测试演员与常规测试不同。演员以异步方式发送和接收消息，通常通过消息流分析来检查。典型的设置将包括三个部分：
- en: The source of the messages
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息的来源
- en: The actor under test
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 待测试的演员
- en: The receiver of the actor's responses
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演员的响应接收者
- en: 'Luckily, Akka includes a testing module that abstracts a lot of setup logic
    and provides useful helpers for common testing activities. The name of the module
    is Akka `TestKit` and it is contained in a separate module that needs to be added
    to the project''s test scope:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Akka包括一个测试模块，它抽象了大量的设置逻辑，并为常见的测试活动提供了有用的辅助工具。该模块的名称是Akka `TestKit`，它包含在一个需要添加到项目测试范围的独立模块中：
- en: '[PRE50]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Having this dependency allows us to extend a `TestKit` class. The `TestKit`
    implements a special testing environment that mimics the internals of a normal
    actor system but provides access to some of the details that are hidden in a production
    implementation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个依赖项，我们可以扩展`TestKit`类。`TestKit`实现了一个特殊的测试环境，它模仿了正常演员系统的内部结构，但提供了访问一些在生产实现中隐藏的细节。
- en: 'Here is an example of the `ScalaTest` specification that extends `TestKit`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个扩展`TestKit`的`ScalaTest`规范的示例：
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we extend a `TestKit` with usual the `ScalaTest` matchers and `WordSpec`,
    but also mix a `BeforeAndAfterAll` and an `ImplicitSender` in. Then, we implement
    the default constructor by instantiating a `BakerySpec` actor system. Lastly,
    we override an `afterAll` method to make sure that our test actor system is properly
    terminated after the test.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用通常的`ScalaTest`匹配器和`WordSpec`扩展`TestKit`，但还混合了`BeforeAndAfterAll`和`ImplicitSender`。然后，我们通过实例化一个`BakerySpec`演员系统来实现默认构造函数。最后，我们覆盖一个`afterAll`方法，以确保测试后的测试演员系统被正确终止。
- en: In SBT, tests are usually run in parallel. In this case, it is important to
    name an actor system properly and in this case, remoting is also used to override
    the default port to avoid conflicts between simultaneously executing tests. Also,
    we should not forget to shut down the actor system gracefully to ensure that our
    resources are cleaned up properly.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在SBT中，测试通常并行运行。在这种情况下，正确命名演员系统很重要，并且在这种情况下，远程通信也用于覆盖默认端口，以避免同时执行的测试之间的冲突。此外，我们不应忘记优雅地关闭演员系统，以确保我们的资源被正确清理。
- en: The `TestKit` implements and brings into scope a `testActor` field, which we
    can use to send messages from the test code. Usually, we'd like these messages
    to be sent from a well-known actor. The `ImplicitSender` trait implements a reference
    to the `testActor` that is attached to the message at the moment it is sent.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestKit`实现并引入了`testActor`字段，我们可以用它从测试代码中发送消息。通常，我们希望这些消息来自一个知名的演员。`ImplicitSender`特质实现了一个引用`testActor`，它在消息发送时附加到消息上。'
- en: The `TestKit` also maintains an internal queue of the messages sent to the `testActor`
    and defines a host of useful methods to inspect this queue.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestKit`还维护一个发送到`testActor`的消息的内部队列，并定义了一系列有用的方法来检查这个队列。'
- en: 'This is how some of these predefined methods can be used to test our `Boy`
    actor:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一些预定义方法如何用来测试我们的`Boy`演员：
- en: '[PRE52]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Recapping the logic of the `Boy` actor, all it is doing is forwarding `ShoppingList`
    to another actor provided as a constructor parameter. In order to test this behaviour,
    we first create an `ActorSelection` as required by the boy's constructor, use
    our default `testActor` as a target, and create a boy actor as a child of the
    test actor system that the `TestKit` provides us with.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾`Boy`演员的逻辑，它所做的只是将`ShoppingList`转发到作为构造函数参数提供的另一个演员。为了测试这种行为，我们首先创建一个`ActorSelection`，这是男孩构造函数所必需的，使用我们的默认`testActor`作为目标，并在`TestKit`为我们提供的测试演员系统中创建一个男孩演员。
- en: In the first test, we send a `ShoppingList` to the `Boy` and expect it to forward
    the list to the `testActor` within a predefined time interval between 3 and 30
    milliseconds. We verify that the message is indeed a `ShoppingList` and that the
    sender is a `testActor`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，我们向`Boy`发送一个`ShoppingList`，并期望它在3到30毫秒的预定义时间间隔内将其转发给`testActor`。我们验证消息确实是一个`ShoppingList`，发送者是`testActor`。
- en: In the second test, we verify that the `Boy` ignores other messages. To check
    this, we send it a message with a `Symbol` type and expect our `testActor` to
    receive nothing within 500 milliseconds. As normal forwarding is expected to take
    no more than 20 milliseconds by our first test, we can be sure that the message
    has been ignored by the `Boy`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们验证`Boy`忽略了其他消息。为了检查这一点，我们向它发送一个`Symbol`类型的消息，并期望我们的`testActor`在500毫秒内没有收到任何消息。由于正常的转发在我们的第一个测试中预计不会超过20毫秒，我们可以确信消息已被`Boy`忽略。
- en: '`testActor`, `lastSender`, `within`, `expectMsg`, and `expectNoMsg` are implemented
    by the `TestKit` and save us from writing boilerplate code.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`testActor`、`lastSender`、`within`、`expectMsg`和`expectNoMsg`由`TestKit`实现，并帮助我们避免编写样板代码。'
- en: 'There are lots of other helpful methods in the `TestKit` that we will take
    a look at shortly. Most of them exist in two forms: one takes a timeout as a parameter
    and another uses a default timeout. The timeout defines how long `TestKit` will
    wait for the condition to happen. The default timeout can be overridden by using
    the `within` wrapper, as shown previously, by changing the configuration or by
    using a `timescale` parameter that will affect all durations within the scope.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TestKit`中还有许多其他有用的方法，我们很快就会查看它们。大多数方法存在两种形式：一种接受超时作为参数，另一种使用默认超时。超时定义了`TestKit`等待条件发生的时长。默认超时可以通过使用`within`包装器来覆盖，如前所述，通过更改配置或使用会影响作用域内所有持续时间的`timescale`参数。
- en: 'We are already familiar with the `expectMsg` and `expectNoMessage` assertions.
    Let''s take a look at some of the other available helpers:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了`expectMsg`和`expectNoMessage`断言。让我们看看其他一些可用的辅助工具：
- en: '`def expectMsgClass[C](c: Class[C])`: `C` expects and returns a single message
    of type C.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgClass[C](c: Class[C])`: `C`期望并返回一个类型为C的单条消息。'
- en: '`def expectMsgType[T](implicit t: ClassTag[T])`: `T` does the same as the previous
    helper, but uses implicit to construct the type parameter.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgType[T](implicit t: ClassTag[T])`: `T`与之前的辅助工具相同，但使用隐式构造类型参数。'
- en: '`def expectMsgAnyOf[T](obj: T*): T` This expects one message and verifies that
    it is equal to one of the constructor parameters.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgAnyOf[T](obj: T*): T` 这期望一条消息并验证它是否等于构造函数参数之一。'
- en: '`def expectMsgAnyClassOf[C](obj: Class[_ <: C]*)`: `C` does the same as before,
    but verifies the type of the message instead of the actual message.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgAnyClassOf[C](obj: Class[_ <: C]*)`: `C`与之前相同，但验证的是消息的类型而不是实际的消息。'
- en: '`def expectMsgAllOf[T](obj: T*)`: `Seq[T]` expects the number of messages and
    verifies that all of them are equal to the constructor parameters.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgAllOf[T](obj: T*)`: `Seq[T]`期望消息的数量并验证它们是否都等于构造函数参数。'
- en: '`def expectMsgAllClassOf[T](obj: Class[_ <: T]*)`: `Seq[T]` does the same as
    before, but verifies types of messages.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgAllClassOf[T](obj: Class[_ <: T]*)`: `Seq[T]`与之前的功能相同，但验证消息的类型。'
- en: '`def expectMsgAllConformingOf[T](obj: Class[_ <: T]*)`: `Seq[T]` does the same
    as `expectMsgAllClassOf`, but checks conformity (instanceOf) instead of class
    equality.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgAllConformingOf[T](obj: Class[_ <: T]*)`: `Seq[T]`与`expectMsgAllClassOf`的功能相同，但检查的是一致性（instanceOf）而不是类相等。'
- en: '`def expectNoMessage()`: `Unit` verifies that no message is received during
    the specified or default timeout.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectNoMessage()`: `Unit`验证在指定的或默认的超时时间内没有接收到任何消息。'
- en: '`def receiveN(n: Int)`: `Seq[AnyRef]` receives N messages and returns them
    to the caller for further verification.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def receiveN(n: Int)`: `Seq[AnyRef]`接收N条消息并将它们返回给调用者以进行进一步验证。'
- en: '`def expectMsgPF[T](max: Duration = Duration.Undefined, hint: String = "")(f:
    PartialFunction[Any, T])`: `T` expects a single message and verifies that a given
    partial function is defined.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectMsgPF[T](max: Duration = Duration.Undefined, hint: String = "")(f:
    PartialFunction[Any, T])`: `T`期望接收一个消息，并验证给定的部分函数是定义的。'
- en: '`def expectTerminated(target: ActorRef, max: Duration = Duration.Undefined)`:
    `Terminated` expects a single `Terminated` message from a specified `target`.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def expectTerminated(target: ActorRef, max: Duration = Duration.Undefined)`:
    `Terminated`期望从指定的`target`接收一个`Terminated`消息。'
- en: '`def fishForMessage(max: Duration = Duration.Undefined, hint: String = "")(f:
    PartialFunction[Any, Boolean])`: `Any` expects multiple messages for which given
    partial function is defined. It returns the first message for which `f` returns
    true.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def fishForMessage(max: Duration = Duration.Undefined, hint: String = "")(f:
    PartialFunction[Any, Boolean])`: `Any`期望接收多个消息，其中给定的部分函数是定义的。它返回第一个使`f`返回true的消息。'
- en: 'Our `Baker` actor is designed in such a way that it sends messages to its parent,
    which means that we will be unable to receive responses from the `Baker` if we
    create it using the test actor system. Let''s take a look at how `TestKit` can
    help us in this situation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Baker`演员设计成向其父演员发送消息，这意味着如果我们使用测试演员系统创建它，我们将无法接收来自`Baker`的响应。让我们看看`TestKit`如何帮助我们解决这个问题：
- en: '[PRE53]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we're constructing a test actor using `TestProbe()`. The `TestProbe` is
    another nice feature provided by the `TestKit` that allows you to send, receive,
    and reply to messages, and is useful in testing scenarios when multiple test actors
    are required. In our case, we're using its ability to create child actors to create
    a `Baker` actor as a child.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`TestProbe()`构建一个测试演员。`TestProbe`是`TestKit`提供的另一个很好的功能，允许你发送、接收和回复消息，在需要多个测试演员的测试场景中非常有用。在我们的情况下，我们使用其创建子演员的能力来创建一个`Baker`演员作为子演员。
- en: Then, we need to generate a number of `RawCookies` so that it requires a number
    of turns to bake them. We expect this number of messages to be sent to the `parent`
    in the next line.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要生成多个`RawCookies`，这样就需要多次翻烤。我们预计在下一行会向`parent`发送这么多条消息。
- en: 'Up until now, we have tested actors in isolation. Our grocery `Store` is built
    in a way that it instantiates an anonymous actor. This makes the approach of testing
    an actor in isolation impossible. Let''s demonstrate how we can verify that the
    `Seller` actor returns the expected `Groceries` if given a `ShoppingList`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在隔离状态下测试了演员。我们的`Store`是以一种方式构建的，它会实例化一个匿名演员。这使得在隔离状态下测试演员的方法变得不可能。让我们演示一下我们如何验证`Seller`演员在给定`ShoppingList`时返回预期的`Groceries`：
- en: '[PRE54]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will construct our test class like we did previously, but with one subtle
    difference. The `Seller` actor is defined anonymously and therefore is only constructed
    as a part of the whole actor system. Because of this, we instantiate the `Store` in
    the default constructor and use the underlying actor system that's accessible
    via the `store` field as a constructor parameter for the `TestKit` instance.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像之前一样构建我们的测试类，但有一个细微的区别。`Seller`演员是匿名定义的，因此它只作为整个演员系统的一部分被构建。因此，我们在默认构造函数中实例化`Store`，并使用通过`store`字段可访问的底层演员系统作为`TestKit`实例的构造函数参数。
- en: In the test itself, we're sending test inputs directly to the `seller` `ActorRef`
    using the `store` that we constructed previously. We have not extended `ImplicitSender`
    and need to provide a `testActor` as a sender reference explicitly.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试本身中，我们直接通过我们之前构建的`store`将测试输入发送到`seller` `ActorRef`。我们没有扩展`ImplicitSender`，需要显式提供一个`testActor`作为发送者引用。
- en: Now that we have our application implemented and tested, let's run it!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了并测试了我们的应用程序，让我们运行它吧！
- en: Running the application
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Please refer to  [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you don't have Java and SBT installed
    yet.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装Java和SBT，请参阅[附录A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml)，*准备环境和运行代码示例*。
- en: 'We will run our application in the terminal by using two separate terminal
    sessions for `Shop` and `Bakery`. It is possible to run both by issuing one of
    the two following commands in the corresponding shell:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用两个独立的终端会话来在终端中运行我们的应用程序，一个用于`Shop`，另一个用于`Bakery`。可以通过在相应的shell中发出以下两个命令之一来运行这两个命令：
- en: '`sbt "runMain ch11.Store"`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt "runMain ch11.Store"`'
- en: '`sbt "runMain ch11.Bakery"`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt "runMain ch11.Bakery"`'
- en: In our code, we do not handle the `StateTimeout` for the `Shopping/ShoppingList`
    state. Therefore, it is mandatory to start the store session first and after it
    loads and starts to accept connections stating that the bakery session can be
    started.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们没有处理`Shopping/ShoppingList`状态的`StateTimeout`。因此，必须首先启动存储会话，然后它加载并开始接受连接，表示可以启动面包店会话。
- en: 'It is also possible to use an approach documented in [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, to run the code from within the SBT
    session and choose the appropriate main class after that. This approach is represented
    in the following screenshot:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用在[附录A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml)，*准备环境和运行代码示例*中记录的方法来在SBT会话中运行代码，并在之后选择适当的主类。这种方法在以下屏幕截图中表示：
- en: '![](img/4a897de3-2ade-41c7-b645-e0245266b108.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a897de3-2ade-41c7-b645-e0245266b108.png)'
- en: Here, we can see how two SBT sessions are initiated in the `ch11` folder. On
    the right-hand side of the screen, the main class for the store was already selected
    and run by SBT. The logs show that the `Store` is listening for connections, so
    it is safe to start the main `Bakery` session.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如何在`ch11`文件夹中启动两个SBT会话。在屏幕的右侧，存储的主要类已经被SBT选中并运行。日志显示`Store`正在监听连接，因此可以安全地启动主`Bakery`会话。
- en: 'This happens after we enter `1` in the left Terminal window:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们在左侧终端窗口中输入`1`之后发生的：
- en: '![](img/c436493b-db61-420f-be10-295ff655470e.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c436493b-db61-420f-be10-295ff655470e.png)'
- en: The store side reflects that the connection was established and the bakery side
    starts to output log statements about current activities. It keeps running and
    logging what is happening until stopped by pressing *Ctrl* + *C*.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 存储端反映了连接已建立，面包店端开始输出关于当前活动的日志语句。它持续运行并记录所发生的事情，直到通过按下*Ctrl* + *C*停止。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's recap what we've learned in this chapter.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在本章中学到的内容。
- en: Current scaling demands are hard to meet using traditional approaches. The actor
    model with its shared nothing paradigm offers a solution to this problem. Akka
    is a library for building actor-based applications on the JVM.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统方法很难满足当前的扩展需求。无共享模式的actor模型为解决这个问题提供了解决方案。Akka是一个用于在JVM上构建基于actor的应用程序的库。
- en: Actors communicate by sending and receiving messages and change their internal
    state and produce side-effects in response. Each actor has an address in the form
    of an `ActorRef`, which also encapsulates ab actor's mailbox and a dispatcher.
    Actors are organized into hierarchies where parent actors are responsible for
    the supervision of their children.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Actor通过发送和接收消息进行通信，并改变其内部状态以及产生副作用。每个actor都有一个地址，形式为`ActorRef`，它还封装了一个actor的邮箱和调度器。actor被组织成层次结构，其中父actor负责对其子actor的监督。
- en: Actors have a well-defined life cycle and implement a number of methods, which
    are called at appropriate moments during their lifetimes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Actor有一个定义良好的生命周期，并在其生命周期中的适当时刻实现了一系列方法。
- en: Akka provides additional modules that extend provided functionality even further.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Akka提供了额外的模块，这些模块进一步扩展了提供的功能。
- en: We also looked at Akka FSM, which gives us the possibility to represent an actor
    as an FSM by encoding its possible states and state transitions.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了Akka FSM，它允许我们通过编码actor的可能状态和状态转换来将actor表示为FSM。
- en: Akka remoting implements the location transparency principle in practice and
    allows you to access remote Akka systems easily.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Akka远程实现实际上的位置透明原则，并允许您轻松访问远程Akka系统。
- en: Testing actors is different from testing regular code. Akka `TestKit` is a library
    that's provided by the Akka team, which simplifies and streamlines the testing
    process. It does so by placing a tested actor in a controlled—but close to the
    real—environment.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 测试演员与测试常规代码不同。Akka `TestKit` 是由 Akka 团队提供的库，它简化并加速了测试过程。它通过将测试的演员置于一个受控但接近真实环境的场景中来实现这一点。
- en: In the next chapter, we will rebuild our bakery using different actor-based
    approach and different Akka library—Akka Typed.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用不同的基于演员的方法和不同的 Akka 库——Akka Typed，重新构建我们的面包店。
- en: Questions
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name two ways in which an actor can change itself in response to the received
    message.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举两种演员在接收到消息后可以改变自己的方式。
- en: What is the purpose of `ActorRef`?
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActorRef` 的目的是什么？'
- en: Lookup is in the official documentation description of the system guardian.
    What is the main purpose of it?
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统守护者的官方文档描述中，查找的主要目的是什么？
- en: What are the advantages and disadvantages of using Akka FSM?
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Akka FSM 的优缺点是什么？
- en: In how many ways can an actor in another actor system be accessed? Describe
    them.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个演员系统中，演员可以通过多少种方式被访问？描述它们。
- en: Why does testing actors require a special toolkit?
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么测试演员需要特殊的工具包？
- en: Further reading
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Christian Baxter, *Mastering Akka*: Master the art of creating scalable, concurrent,
    and reactive applications using Akka.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Christian Baxter，*精通 Akka*：掌握使用 Akka 创建可扩展、并发和响应式应用程序的艺术。
- en: Héctor Veiga Ortiz and Piyush Mishra, *Akka Cookbook*: Learn how to use the
    Akka framework to build effective applications in Scala.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Héctor Veiga Ortiz 和 Piyush Mishra，*Akka 烹饪秘籍*：学习如何使用 Akka 框架在 Scala 中构建有效的应用程序。
