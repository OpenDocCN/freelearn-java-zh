["```java\n(defn iterate-range [] (iterate inc 0))\n```", "```java\nuser> (take 5 (iterate-range))\n(0 1 2 3 4)\n```", "```java\nuser> (defn our-range [n]\n        (lazy-seq\n          (cons n (our-range (inc n)))))\n#'user/our-range\n```", "```java\nuser> (take 5 (our-range 0))\n(0 1 2 3 4)\n```", "```java\n[24.2 420031]\n```", "```java\n    (def sample-data\n      [[24.2 420031]\n       [25.8 492657]\n       [25.9 589014]\n       [23.8 691995]\n       [24.7 734902]\n       [23.2 794243]\n       [23.1 836204]\n       [23.5 884120]])\n    ```", "```java\n    (defn local-max? [[a b c]]\n      (and (< (first a) (first b)) (< (first c) (first b))))\n    (defn local-min? [[a b c]]\n      (and (> (first a) (first b)) (> (first c) (first b))))\n    ```", "```java\n    (defn local-max? [[[a _] [b _] [c _]]]\n      (and (< a b) (< c b)))\n    (defn local-min? [[[a _] [b _] [c _]]]\n      (and (> a b) (> c b)))\n    user> (local-max? (take 3 sample-data))\n    false\n    user> (local-min? (take 3 sample-data))\n    false\n    ```", "```java\n    user> (local-min? (take 3 (drop 2 sample-data)))\n    true\n    ```", "```java\n    (defn inflection-points [data]\n      (lazy-seq\n        (let [current-series (take 3 data)]\n          (cond (< (count current-series) 3)\n                :no-more-data-so-stop\n                (local-max? current-series)\n                :peak\n                (local-min? current-series)\n                :valley\n                :otherwise\n                :neither-so-keep-moving))))\n    ```", "```java\n    (< (count current-series) 3)\n    '()\n    ```", "```java\n    (conj (second current-series) :peak)\n    ```", "```java\n    [24.7 734902 :peak]\n    ```", "```java\n    (local-max? current-series)\n    (cons\n      (conj (second current-series) :peak)\n      (inflection-points (rest data)))\n    (local-min? current-series)\n    (cons\n      (conj (second current-series) :valley)\n      (inflection-points (rest data)))\n    ```", "```java\n     :otherwise\n    (inflection-points (rest data))\n    ```", "```java\n     (defn inflection-points [data]\n      (lazy-seq\n        (let [current-series (take 3 data)]\n          (cond (< (count current-series) 3)\n                '()\n                (local-max? current-series)\n                (cons\n                  (conj (second current-series) :peak)\n                  (inflection-points (rest data)))\n                (local-min? current-series)\n                (cons\n                  (conj (second current-series) :valley)\n                  (inflection-points (rest data)))\n                :otherwise\n                (inflection-points (rest data))))))\n    ```", "```java\n    user> (inflection-points sample-data)\n    ([25.9 589014 :peak]\n     [23.8 691995 :valley]\n     [24.7 734902 :peak]\n     [23.1 836204 :valley])\n    ```", "```java\n    user> (take 15 (inflection-points (cycle sample-data)))\n    ([25.9 589014 :peak]\n     [23.8 691995 :valley]\n     [24.7 734902 :peak]\n     [23.1 836204 :valley]\n     [25.9 589014 :peak]\n     [23.8 691995 :valley]\n     [24.7 734902 :peak]\n     [23.1 836204 :valley]\n     [25.9 589014 :peak]\n     [23.8 691995 :valley]\n     [24.7 734902 :peak]\n     [23.1 836204 :valley]\n     [25.9 589014 :peak]\n     [23.8 691995 :valley]\n     [24.7 734902 :peak])\n    It just keeps going and going!\n    ```", "```java\n    user> (def endless-potatoes (repeatedly (fn [] (+ 10 (rand-int 390)))))\n    #'user/endless-potatoes\n    ```", "```java\n    user> (take 5 endless-potatoes)\n    (205 349 97 250 18)\n    user> (take 10 endless-potatoes)\n    (205 349 97 250 18 219 68 186 196 68)\n    ```", "```java\n    [200 5 784]\n    ```", "```java\n    ([59 1 59] [134 2 193] [358 3 551])\n    ```", "```java\n    (defn average-potatoes [prev arrivals]\n      (lazy-seq\n        ))\n    ```", "```java\n    (defn average-potatoes [prev arrivals]\n      (lazy-seq\n        (if-not arrivals\n          '()\n          )))\n    ```", "```java\n    (defn average-potatoes [prev arrivals]\n      (lazy-seq\n        (if-not arrivals\n          '()\n          (let [[_ n total] prev\n                current [(first arrivals)\n                          (inc (or n 0))\n                          (+ (first arrivals) (or total 0))]]\n            ;; TODO: the actual recursion\n            ))))\n    ```", "```java\n    (defn average-potatoes [prev arrivals]\n      (lazy-seq\n        (if-not arrivals\n          '()\n          (let [[_ n total] prev\n                current [(first arrivals)\n                         (inc (or n 0))\n                         (+ (first arrivals) (or total 0))]]\n            (cons\n              current\n              (average-potatoes\n                current\n                (next arrivals)))))))\n    ```", "```java\n    user> (take 3 (average-potatoes '() endless-potatoes))\n    ([321 1 321] [338 2 659] [318 3 977])\n    ```", "```java\n    user> (last (take 500000 (average-potatoes '() endless-potatoes)))\n    [43 500000 102132749]\n    ```", "```java\n(->> xs\n     (map some-func)\n     (reduce some-reducing-func)\n     (filter some-predicate?))\n```", "```java\n(->> xs\n     (map some-func)\n     (filter some-predicate?)\n     (take-while another-predicate?)\n     (reduce +))\n```", "```java\n(nth (filter even? (range)) 3)\n```", "```java\n(filter even? (range))\n```", "```java\nuser> (nth (filter even? (range)) 3)\n6\n```", "```java\nuser> (nth (filter even? (range)) 7000000)\n14000000\n```", "```java\n    {:paths [\"src\" \"resources\"]\n     :deps\n     {org.clojure/data.csv {:mvn/version \"0.1.4\"}\n      semantic-csv {:mvn/version \"0.2.1-alpha1\"}\n      org.clojure/math.numeric-tower {:mvn/version \"0.0.4\"}}}\n    ```", "```java\n    (ns packt-clojure.lazy-tennis\n      (:require [clojure.math.numeric-tower :as math]\n                [clojure.java.io :as io]\n                [clojure.data.csv :as csv]\n                [semantic-csv.core :as sc]))\n    ```", "```java\n    (reduce (fn [{:keys [players] :as acc} {:keys [winner_name winner_slug\n                                                   loser_name loser_slug] :as match}]\n              ;; TODO: content temporarily unavailable\n              )\n            {:players {}\n             :match-count 0\n             :predictable-match-count 0\n             :correct-predictions 0})\n    ```", "```java\n    (reduce (fn [{:keys [players] :as acc} {:keys [winner_name winner_slug\n                                                   loser_name loser_slug] :as match}]\n              ;; TODO: your content will be restored shortly\n              )\n            {:players {}\n             :matches []})\n    ```", "```java\n    (-> acc\n        ;; TODO: more missing code\n        (update :match-count inc))\n    ```", "```java\n    (-> acc\n        (assoc-in [:players winner_slug] (recalculate-rating k winner-rating winner-probability 1))\n        (assoc-in [:players loser_slug] (recalculate-rating k loser-rating loser-probability 0))\n        (update :matches (fn [ms]\n                           (conj ms (assoc match\n                                           :winner_rating winner-rating\n                                           :loser_rating loser-rating)))))\n    ```", "```java\n    (->>\n      ;; calls to reduce, etc.\n      :matches\n      reverse)\n    ```", "```java\n    tennis_history.clj\n    16 (defn elo-db\n    17   ([csv k]\n    18    (with-open [r (io/reader csv)]\n    19      (->> (csv/read-csv r)\n    20           sc/mappify\n    21           (sc/cast-with {:winner_sets_won sc/->int\n    22                          :loser_sets_won sc/->int\n    23                          :winner_games_won sc/->int\n    24                          :loser_games_won sc/->int}\n    The full code for this step can be found at https://packt.live/2GffSKv\n    ```", "```java\n    packt-clojure.lazy-tennis> (def ratings (elo-db \"match_scores_1991-2016_unindexed_csv.csv\" 35))\n    #'packt-clojure.lazy-tennis/db\n    ```", "```java\n    packt-clojure.lazy-tennis> (map #(select-keys % [:winner_rating :loser_rating]) (take 5 ratings))\n    ({:winner_rating 985.2418497337458, :loser_rating 927.9839328429639}\n     {:winner_rating 1265.3903009991964, :loser_rating 875.8644912132612}\n     {:winner_rating 1012.6267015729657, :loser_rating 969.5966741618663}\n     {:winner_rating 1311.801159776237, :loser_rating 1002.1872608853402}\n     {:winner_rating 853.6200747439426, :loser_rating 950.2283493122825})\n    ```", "```java\n    (defn player-in-match? [{:keys [winner_slug loser_slug]} player-slug]\n      ((hash-set winner_slug loser_slug) player-slug))\n    packt-clojure.lazy-tennis> (player-in-match? (first ratings) \"gael-monfils\")\n    \"gael-monfils\"\n    packt-clojure.lazy-tennis> (player-in-match? (first ratings) \"boris-becker\")\n    nil\n    ```", "```java\n    (defn match-tree-by-player [m player-name]\n      (lazy-seq\n        (cond (empty? m)\n              ;; No more matches\n              (player-in-match? (first m) player-name)\n              ;; Build the tree!\n              ::otherwise\n              ;; Keep walking through the tree\n              )))\n    ```", "```java\n     (match-tree-by-player (rest m) player-slug)\n    ```", "```java\n    (cons (first ms)\n          (cons\n            [(match-tree-by-player (rest ms) (:Winner (first ms)))\n             (match-tree-by-player (rest ms) (:Loser (first ms)))]\n            '()))\n    ```", "```java\n    (defn match-tree-by-player [m player-slug]\n      (lazy-seq\n        (cond (empty? m)\n              '()\n              (player-in-match?  (first m) player-slug)\n              (cons (first m)\n                    (cons\n                      [(match-tree-by-player (rest m) (:winner_slug (first m)))\n                       (match-tree-by-player (rest m) (:loser_slug (first m)))]\n                      '()))\n              ::otherwise\n              (match-tree-by-player (rest m) player-slug))))\n    ```", "```java\n    packt-clojure.tennis> (match-tree-by-player ratings \"non-tennis-player\")\n    ()\n    ```", "```java\n    packt-clojure.tennis> (def federer (match-tree-by-player ratings \"roger-federer\"))\n    #'packt-clojure.lazy-tennis/federer\n    packt-clojure.lazy-tennis> (type federer)\n    clojure.lang.LazySeq\n    ```", "```java\n    packt-clojure.lazy-tennis> (:winner_rating (first federer))\n    1129.178155312036\n    ```", "```java\npackt-clojure.lazy-tennis> (count federer)\n2\n```", "```java\npackt-clojure.lazy-tennis> (realized? (first (second federer)))\nfalse\n```", "```java\n    (defn take-matches [limit tree]\n      (cond (zero? limit)\n            '()))\n    ```", "```java\n    packt-clojure.lazy-tennis> (take-matches 0 federer)\n    ()\n    ```", "```java\n    (defn take-matches [limit tree]\n      (cond (zero? limit)\n            '()\n            (= 1 limit)\n            (first tree)))\n    ```", "```java\n    packt-clojure.lazy-tennis> (select-keys (take-matches 1 federer) [:winner_slug :loser_slug])\n    {:winner_slug \"roger-federer\", :loser_slug \"guido-pella\"}\n    ```", "```java\n    (defn take-matches [limit tree]\n      (cond (zero? limit)\n            '()\n            (= 1 limit)\n            (first tree)\n            :otherwise-continue\n            (cons\n              (first tree)\n              (cons\n                [(take-matches (dec limit) (first (second tree)))\n                 (take-matches (dec limit) (second (second tree)))]\n                '()))))\n    ```", "```java\n    (take-matches 3 federer)\n    ```", "```java\n    ({}\n     [({}\n       [{} {}])\n      ({}\n       [{} {}])])\n    ```", "```java\n    (defn take-matches [limit tree f]\n      (cond (zero? limit)\n            '()\n            (= 1 limit)\n            (f (first tree))\n            :otherwise-continue\n            (cons\n              (f (first tree))\n              (cons\n                [(take-matches (dec limit) (first (second tree)) f)\n                 (take-matches (dec limit) (second (second tree)) f)]\n                '()))))\n    ```", "```java\n    (def federer (match-tree-by-player matches \"roger-federer\"))\n    ```", "```java\n    packt-clojure.lazy-tennis> (take-matches 3 federer #(select-keys % [:winner_slug :loser_slug]))\n    ({:winner_slug \"roger-federer\", :loser_slug \"guido-pella\"}\n     [({:winner_slug \"roger-federer\", :loser_slug \"marcus-willis\"}\n       [{:winner_slug \"roger-federer\", :loser_slug \"daniel-evans\"}\n        {:winner_slug \"pierre-hugues-herbert\",\n         :loser_slug \"marcus-willis\"}])\n      ({:winner_slug \"benjamin-becker\", :loser_slug \"guido-pella\"}\n       [{:winner_slug \"dudi-sela\", :loser_slug \"benjamin-becker\"}\n        {:winner_slug \"guido-pella\", :loser_slug \"diego-schwartzman\"}])])\n    ```", "```java\n    (defn matches-with-ratings [limit tree]\n      (take-matches limit\n                    tree\n                    (fn [match]\n                      (-> match\n                          (update :winner_rating int)\n                          (update :loser_rating int)\n                          (select-keys [:winner_name :loser_name :winner_rating :loser_rating])\n                          (assoc :winner_probability_percentage\n                                 (->> (match-probability (:winner_rating match)\n                                                         (:loser_rating match))\n                                      (* 100)\n                                      int))))))\n    ```"]