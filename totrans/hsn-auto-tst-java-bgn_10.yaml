- en: The Importance of the final Keyword, Packages, and Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final chapter in our book. Here, we will be dealing with some more
    important concepts that will help us write and execute better code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The final keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifiers in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a new class. If we declare any variable as `final`, that
    means the value cannot be changed again. Let''s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have declared the integer value as `4`. This means we cannot
    change this value to another number. If we try to do that, it throws an error
    saying `Remove 'final' modifier of 'i'`. This keyword is useful if we want a value
    to be constant.
  prefs: []
  type: TYPE_NORMAL
- en: If we mark a class as `final`, it will throw an error because when we change
    the access mode to `final`, we are not able to use that as a parent class. In
    other words, we will not be able to inherit our properties from it. If we want
    to inherit our properties, we need to change it back to `public`. The key logic
    for the final keyword is that, once written, we cannot override `final` methods.
    So these are unique and cannot be used again with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The `final` keyword can be used at the method level to make sure that the method
    is not overridden. It is used at the variable level to make sure we're not changing
    it, and it can also be used at the class level to ensure that we are not inheriting
    that parent class.
  prefs: []
  type: TYPE_NORMAL
- en: But remember not to confuse `final` and `finally`. `finally` is something that
    is related to `try...catch` exceptions. Once you execute the `try` or `catch`
    block, and preface any error, the controller will still come to this log and execute
    the code, no matter whether the script is pass or fail. `finally` is all about
    restricting access, such as we cannot use that, inherit that, or even change the
    values. We have explored packages, and how to import packages into other classes.
    We have explored the inheritance of interfaces, runtime polymorphism, strings,
    and many more. This is all about keywords.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about packages.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When scripts are written for each Java class, there is a pre-populated line
    that is present automatically. It is `package coreJava`. Since we have created
    a package in Java and placed all the Java classes into that `coreJava` package,
    we see it as `package coreJava`.
  prefs: []
  type: TYPE_NORMAL
- en: Packages are nothing but a set of classes and interfaces. For example, Java
    comes with a few built-in packages, such as `java.length`; if we import this package,
    only then can we access a basic fundamental method, such as `public static void
    main`, integer, or array. All these classes come from this `java.lang` package.
    It is important to define the package name, because without it, we cannot access
    the classes present inside the package. This is because `java.lang` is a default
    package and it comes within the Java compiler itself.
  prefs: []
  type: TYPE_NORMAL
- en: We have another package as well, `java.util`. We used this package when we worked
    on collections; we imported a `java.util` package. In order to work on `ArrayList`,
    this class is present in the `java.util` package. Therefore, if we remove `import
    java.util.ArrayList`, it throws an error because it does not belong to `java.lang`.
    All collection interfaces come from the `util` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do we know what keyword to use? The following screenshot displays what
    Eclipse will display if we hover the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e544ea6b-85b3-4d6d-9a42-d78acde26018.png)'
  prefs: []
  type: TYPE_IMG
- en: Quick fixes drop down with suggestions to correct the code error
  prefs: []
  type: TYPE_NORMAL
- en: 'We are importing the `java.util` package. And from that package, we are importing
    the `ArrayList` class. The syntax for it will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the reason why we are using `ArrayList` in this Java class is because
    we know that `ArrayList` is in the `java.util` package. But we need not remember
    it when we are working with Eclipse. When you just hover the mouse, it suggests we
    import the package and we can just click on it. It will automatically import that
    particular test.
  prefs: []
  type: TYPE_NORMAL
- en: '`HashSet` imports the `HashSet` class from the same `util` package. If we go
    to `HashMap`, it brings `HashMap`. Thus, whenever we want to work on some tests,
    we need to import that package or class. `System.out.println()` also comes from
    one package only, but they come from `java.lang`, which is a built-in compiler.
    These are inbuilt inside the Java packages.'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we can also define a user-defined Java package. In this case,
    all our test cases are in a different package called `coreJava`. If someone wants
    to use our classes, all they need to do is run `import coreJava.classname`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the public modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four types of access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not discuss the theory here as you can find it on Google. We need a
    practical approach as to where exactly these access modifiers are used, or where
    exactly the packages are imported. Whenever we've created a method throughout
    this book, every time we just used `public` and wrote the method. The three other
    access modifiers work similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's try to understand how each of these access modifiers can help us.
  prefs: []
  type: TYPE_NORMAL
- en: default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we do not mention any access modifier, our Java class automatically thinks
    it has a `default` access modifier. If it is `default`, that means you can access
    this method anywhere in your package. But if you go out of this package, then
    you cannot access this method. Even if we import the `package.classname` into
    our new package, we will not be able to access this method if we have not specified
    it as `public`. If you don't specify it, then by default it thinks it's a `default`
    access modifier. The `default` access modifier can be accessed anywhere in the
    package, but not outside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Packages* section, we imported this package and we tried to use it.
    As you can see in the following screenshot, there is an error showing up in line
    15:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9dfca50-0720-409c-bd0f-5457b9af0d7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Quick fixes drop down with suggestions to correct the code error for default
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t specify anything, we cannot access it, therefore it is the same
    as that of the default feature. This applies to variables as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in the preceding code we have declared an integer. However, it
    will not be `public`; it is `default`. Thus, we cannot access the variable outside
    the package. If we import it, we will have access to the class but not the methods.
    If we want access, we have to write it as a `public`. So what does a `public`
    access modifier do?
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On making the method or variable `public`, we will have access to it across
    all the packages. That means basically everywhere. There is no restriction for
    this package of this class. The error observed in the preceding screenshot is
    also goes once we make the method/variable `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the `int` value after we made it `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd7b7481-22ae-445e-bfb6-22257a6f5ef9.png)'
  prefs: []
  type: TYPE_IMG
- en: Quick fixes drop down with suggestions to correct the code error for public
  prefs: []
  type: TYPE_NORMAL
- en: In the next class, we'll look at what `private` and `protected` access modifiers
    are. There are two more access modifiers after this one, let's see what they do.
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we mark our method or variable as `private`, then we cannot access either
    of them outside the class. They cannot be accessed outside the package, or outside
    the same class. If we want to access this in our `ArraysDemo` example, we cannot
    do that. Even if we try to, it throws an error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50710110-dc12-4e9a-8739-6c1ace39fac8.png)'
  prefs: []
  type: TYPE_IMG
- en: Quick fixes drop down with a suggestion to correct the code error for private
  prefs: []
  type: TYPE_NORMAL
- en: This is so because, if we mark any method or variable as `private`, we cannot
    access it outside that particular class. Until and unless we change it to something
    else, it throws an error. This applies to the variable as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a real-time scenario, let's say you are making a payment and buying
    a product; all the credit card details will go as `private` because they will
    not be accessed outside of that buy class. If they can be accessed, that's a security
    breach, right? So to make credit card details restricted to that particular class,
    the developers give the `private` variable to all the card details so other classes
    cannot use it. Even if they have used inheritance or are importing a package,
    they will not have access to those sensitive details. There are a lot of real-time
    scenarios; if you are working on test frameworks, there might be some variables
    which you should not change, and always keep it private.
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we define a variable or method as `private`, we can access them in subclasses
    only. This means if we define it as `protected`; then, whichever class is inheriting
    the parent class, only those subclasses can have access to the method, and no
    other classes. This can be understood with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The difference between `default` and `protected` is that in `default` we can
    access a class only within the same package of classes. Even `protected` can access
    all classes in the same package, except it has an additional feature. This additional
    feature says that, if we want to access it in other packages, only subclasses
    that inherit the properties of the parent class can access it.
  prefs: []
  type: TYPE_NORMAL
- en: The same concept is applied to variables.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned concepts that help us understand the importance
    of packages, modifiers, and the `final` keyword in Java.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have a better understanding of these concepts now that you've read
    all the chapters.
  prefs: []
  type: TYPE_NORMAL
