["```java\n        if (problem size > default size){ \n          tasks=divide(task); \n          execute(tasks); \n        } else { \n          resolve problem using another algorithm; \n        } \n\n```", "```java\n        public class Product { \n\n```", "```java\n        private String name; \n        private double price; \n\n```", "```java\n        public class ProductListGenerator { \n\n```", "```java\n        public List<Product> generate (int size) { \n\n```", "```java\n        List<Product> ret=new ArrayList<Product>(); \n\n```", "```java\n          for (int i=0; i<size; i++){ \n            Product product=new Product(); \n            product.setName(\"Product \"+i); \n            product.setPrice(10); \n            ret.add(product); \n          } \n          return ret; \n        } \n\n```", "```java\n        public class Task extends RecursiveAction { \n\n```", "```java\n        private List<Product> products; \n\n```", "```java\n        private int first; \n        private int last; \n\n```", "```java\n        private double increment; \n\n```", "```java\n        public Task (List<Product> products, int first, int last,\n                     double increment) { \n          this.products=products; \n          this.first=first; \n          this.last=last; \n          this.increment=increment; \n        } \n\n```", "```java\n        @Override \n        protected void compute() { \n\n```", "```java\n        if (last - first<10) { \n          updatePrices(); \n\n```", "```java\n        } else { \n          int middle=(last+first)/2; \n          System.out.printf(\"Task: Pending tasks:%s\\n\",\n                            getQueuedTaskCount()); \n          Task t1=new Task(products, first,middle+1, increment); \n          Task t2=new Task(products, middle+1,last, increment); \n          invokeAll(t1, t2);   \n        } \n\n```", "```java\n        private void updatePrices() { \n          for (int i=first; i<last; i++){ \n            Product product=products.get(i); \n            product.setPrice(product.getPrice()*(1+increment)); \n          } \n        } \n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n\n```", "```java\n        ProductListGenerator generator=new ProductListGenerator(); \n        List<Product> products=generator.generate(10000); \n\n```", "```java\n        Task task=new Task(products, 0, products.size(), 0.20); \n\n```", "```java\n        ForkJoinPool pool=new ForkJoinPool(); \n\n```", "```java\n        pool.execute(task); \n\n```", "```java\n        do { \n          System.out.printf(\"Main: Thread Count:%d\\n\",\n                            pool.getActiveThreadCount()); \n          System.out.printf(\"Main: Thread Steal:%d\\n\",\n                            pool.getStealCount()); \n          System.out.printf(\"Main: Parallelism:%d\\n\",\n                            pool.getParallelism()); \n          try { \n            TimeUnit.MILLISECONDS.sleep(5); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } while (!task.isDone()); \n\n```", "```java\n        pool.shutdown(); \n\n```", "```java\n        if (task.isCompletedNormally()){ \n          System.out.printf(\"Main: The process has completed\n                             normally.\\n\"); \n        } \n\n```", "```java\n        for (int i=0; i<products.size(); i++){ \n          Product product=products.get(i); \n          if (product.getPrice()!=12) { \n            System.out.printf(\"Product %s: %f\\n\",\n                              product.getName(),product.getPrice()); \n          } \n        } \n\n```", "```java\n        System.out.println(\"Main: End of the program.\\n\"); \n\n```", "```java\n    if (problem size > size){ \n      tasks=Divide(task); \n      execute(tasks); \n      joinResults() \n      return result; \n    } else { \n      resolve problem; \n      return result; \n    } \n\n```", "```java\n        public class DocumentMock { \n\n```", "```java\n        private String words[]={\"the\",\"hello\",\"goodbye\",\"packt\",\n                                \"java\",\"thread\",\"pool\",\"random\",\n                                \"class\",\"main\"}; \n\n```", "```java\n        public String[][] generateDocument(int numLines, int numWords,\n                                           String word){ \n\n```", "```java\n        int counter=0; \n        String document[][]=new String[numLines][numWords]; \n        Random random=new Random(); \n\n```", "```java\n        for (int i=0; i<numLines; i++){ \n          for (int j=0; j<numWords; j++) { \n            int index=random.nextInt(words.length); \n            document[i][j]=words[index]; \n            if (document[i][j].equals(word)){ \n              counter++; \n            } \n          } \n        } \n\n```", "```java\n        System.out.println(\"DocumentMock: The word appears \"+ counter+\"\n                            times in the document\"); \n        return document; \n\n```", "```java\n        public class DocumentTask extends RecursiveTask<Integer> { \n\n```", "```java\n        private String document[][]; \n        private int start, end; \n        private String word; \n\n```", "```java\n        public DocumentTask (String document[][], int start, int end,\n                             String word){ \n          this.document=document; \n          this.start=start; \n          this.end=end; \n          this.word=word; \n        } \n\n```", "```java\n        @Override \n        protected Integer compute() { \n          Integer result=null; \n          if (end-start<10){ \n            result=processLines(document, start, end, word); \n\n```", "```java\n        } else { \n          int mid=(start+end)/2; \n          DocumentTask task1=new DocumentTask(document,start,mid,word); \n          DocumentTask task2=new DocumentTask(document,mid,end,word); \n          invokeAll(task1,task2); \n\n```", "```java\n          try { \n            result=groupResults(task1.get(),task2.get()); \n          } catch (InterruptedException | ExecutionException e) { \n            e.printStackTrace(); \n          } \n        } \n        return result; \n\n```", "```java\n        private Integer processLines(String[][] document, int start,\n                                     int end,String word) { \n\n```", "```java\n        List<LineTask> tasks=new ArrayList<LineTask>(); \n        for (int i=start; i<end; i++){ \n          LineTask task=new LineTask(document[i], 0,\n                                     document[i].length, word); \n          tasks.add(task); \n        } \n\n```", "```java\n        invokeAll(tasks); \n\n```", "```java\n        int result=0; \n        for (int i=0; i<tasks.size(); i++) { \n          LineTask task=tasks.get(i); \n          try { \n            result=result+task.get(); \n          } catch (InterruptedException | ExecutionException e) { \n            e.printStackTrace(); \n          } \n        } \n        return result; \n\n```", "```java\n        private Integer groupResults(Integer number1,Integer number2) { \n          Integer result; \n          result=number1+number2; \n          return result; \n        } \n\n```", "```java\n        public class LineTask extends RecursiveTask<Integer>{ \n\n```", "```java\n        private String line[]; \n        private int start, end; \n        private String word; \n\n```", "```java\n        public LineTask(String line[],int start,int end,String word) { \n          this.line=line; \n          this.start=start; \n          this.end=end; \n          this.word=word; \n        } \n\n```", "```java\n        @Override \n        protected Integer compute() { \n          Integer result=null; \n          if (end-start<100) { \n            result=count(line, start, end, word); \n\n```", "```java\n        } else { \n          int mid=(start+end)/2; \n          LineTask task1=new LineTask(line, start, mid, word); \n          LineTask task2=new LineTask(line, mid, end, word); \n          invokeAll(task1, task2); \n\n```", "```java\n          try { \n            result=groupResults(task1.get(),task2.get()); \n          } catch (InterruptedException | ExecutionException e) { \n            e.printStackTrace(); \n          } \n        } \n        return result; \n\n```", "```java\n        private Integer count(String[] line, int start, int end,\n                              String word) { \n\n```", "```java\n        int counter; \n        counter=0; \n        for (int i=start; i<end; i++){ \n          if (line[i].equals(word)){ \n            counter++; \n          } \n        } \n\n```", "```java\n        try { \n          Thread.sleep(10); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n\n```", "```java\n        return counter; \n\n```", "```java\n        private Integer groupResults(Integer number1,Integer number2) { \n          Integer result; \n          result=number1+number2; \n          return result; \n        } \n\n```", "```java\n        public class Main{ \n          public static void main(String[] args) { \n\n```", "```java\n        DocumentMock mock=new DocumentMock(); \n        String[][] document=mock.generateDocument(100, 1000, \"the\"); \n\n```", "```java\n        DocumentTask task=new DocumentTask(document, 0, 100, \"the\"); \n\n```", "```java\n        ForkJoinPool commonPool=ForkJoinPool.commonPool(); \n        commonPool.execute(task); \n\n```", "```java\n        do { \n          System.out.printf(\"*************************\n                             *****************\\n\"); \n          System.out.printf(\"Main: Active Threads: %d\\n\",\n                            commonPool.getActiveThreadCount()); \n          System.out.printf(\"Main: Task Count: %d\\n\",\n                            commonPool.getQueuedTaskCount()); \n          System.out.printf(\"Main: Steal Count: %d\\n\",\n                            commonPool.getStealCount()); \n          System.out.printf(\"***********************************\n                             *******\\n\"); \n          try { \n            TimeUnit.SECONDS.sleep(1); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } while (!task.isDone()); \n\n```", "```java\n        pool.shutdown(); \n\n```", "```java\n        try { \n          pool.awaitTermination(1, TimeUnit.DAYS); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n\n```", "```java\n        try { \n          System.out.printf(\"Main: The word appears %d in the\n                             document\",task.get()); \n        } catch (InterruptedException | ExecutionException e) { \n          e.printStackTrace(); \n        } \n\n```", "```java\n        public class FolderProcessor extends\n                                CountedCompleter<List<String>> { \n\n```", "```java\n        private String path; \n\n```", "```java\n        private String extension; \n\n```", "```java\n        private List<FolderProcessor> tasks; \n        private List<String> resultList;      \n\n```", "```java\n        protected FolderProcessor (CountedCompleter<?> completer,\n                                   String path, String extension) { \n          super(completer); \n          this.path=path; \n          this.extension=extension; \n        } \n\n```", "```java\n        public FolderProcessor (String path, String extension) { \n          this.path=path; \n          this.extension=extension; \n        } \n\n```", "```java\n        @Override \n        public void compute() { \n\n```", "```java\n        resultList=new ArrayList<>(); \n        tasks=new ArrayList<>(); \n\n```", "```java\n        File file=new File(path); \n        File content[] = file.listFiles(); \n\n```", "```java\n        if (content != null) { \n          for (int i = 0; i < content.length; i++) { \n            if (content[i].isDirectory()) { \n              FolderProcessor task=new FolderProcessor(this,\n                              content[i].getAbsolutePath(), extension); \n              task.fork(); \n              addToPendingCount(1); \n              tasks.add(task); \n\n```", "```java\n          } else { \n            if (checkFile(content[i].getName())){ \n              resultList.add(content[i].getAbsolutePath()); \n            } \n          } \n        } \n\n```", "```java\n          if (tasks.size()>50) { \n            System.out.printf(\"%s: %d tasks ran.\\n\",\n                              file.getAbsolutePath(),tasks.size()); \n          } \n        } \n\n```", "```java\n          tryComplete(); \n        } \n\n```", "```java\n        @Override \n        public void onCompletion(CountedCompleter<?> completer) { \n          for (FolderProcessor childTask : tasks) { \n            resultList.addAll(childTask.getResultList()); \n          } \n        } \n\n```", "```java\n        private boolean checkFile(String name) { \n          return name.endsWith(extension); \n        } \n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n\n```", "```java\n        ForkJoinPool pool=new ForkJoinPool(); \n\n```", "```java\n        FolderProcessor system=new FolderProcessor(\"C:\\\\Windows\",\n                                                   \"log\"); \n        FolderProcessor apps=new FolderProcessor(\"C:\\\\Program Files\",\n                                                 \"log\"); \n        FolderProcessor documents=new FolderProcessor(\"C:\\\\Documents\n                                                 And Settings\",\"log\"); \n\n```", "```java\n        pool.execute(system); \n        pool.execute(apps); \n        pool.execute(documents); \n\n```", "```java\n        do { \n          System.out.printf(\"**********************************\n                             ********\\n\"); \n          System.out.printf(\"Main: Active Threads: %d\\n\",\n                            pool.getActiveThreadCount()); \n          System.out.printf(\"Main: Task Count: %d\\n\",\n                            pool.getQueuedTaskCount()); \n          System.out.printf(\"Main: Steal Count: %d\\n\",\n                            pool.getStealCount()); \n          System.out.printf(\"**********************************\n                             ********\\n\"); \n          try { \n            TimeUnit.SECONDS.sleep(1); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } while ((!system.isDone())||(!apps.isDone())||\n                 (!documents.isDone())); \n\n```", "```java\n        pool.shutdown(); \n\n```", "```java\n        List<String> results; \n\n        results=system.join(); \n        System.out.printf(\"System: %d files found.\\n\",results.size()); \n\n        results=apps.join(); \n        System.out.printf(\"Apps: %d files found.\\n\",results.size()); \n\n        results=documents.join(); \n        System.out.printf(\"Documents: %d files found.\\n\",\n                           results.size()); \n\n```", "```java\n        public class Task extends RecursiveTask<Integer> { \n\n```", "```java\n        private int array[]; \n\n```", "```java\n        private int start, end; \n\n```", "```java\n        public Task(int array[], int start, int end){ \n          this.array=array; \n          this.start=start; \n          this.end=end; \n        } \n\n```", "```java\n        @Override \n        protected Integer compute() { \n          System.out.printf(\"Task: Start from %d to %d\\n\",start,end);  \n\n```", "```java\n        if (end-start<10) { \n          if ((3>start)&&(3<end)){ \n            throw new RuntimeException(\"This task throws an\"+\n                            \"Exception: Task from  \"+start+\" to \"+end); \n          } \n          try { \n            TimeUnit.SECONDS.sleep(1); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n\n```", "```java\n        } else { \n          int mid=(end+start)/2; \n          Task task1=new Task(array,start,mid); \n          Task task2=new Task(array,mid,end); \n          invokeAll(task1, task2); \n          System.out.printf(\"Task: Result form %d to %d: %d\\n\",\n                            start,mid,task1.join()); \n          System.out.printf(\"Task: Result form %d to %d: %d\\n\",\n                            mid,end,task2.join()); \n        } \n\n```", "```java\n        System.out.printf(\"Task: End form %d to %d\\n\",start,end); \n\n```", "```java\n        return 0; \n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n\n```", "```java\n        int array[]=new int[100]; \n\n```", "```java\n        Task task=new Task(array,0,100); \n\n```", "```java\n        ForkJoinPool pool=new ForkJoinPool(); \n\n```", "```java\n        pool.execute(task); \n\n```", "```java\n        pool.shutdown(); \n\n```", "```java\n        try { \n          pool.awaitTermination(1, TimeUnit.DAYS); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n\n```", "```java\n        if (task.isCompletedAbnormally()) { \n          System.out.printf(\"Main: An exception has ocurred\\n\"); \n          System.out.printf(\"Main: %s\\n\",task.getException()); \n        } \n        System.out.printf(\"Main: Result: %d\",task.join()); \n\n```", "```java\n    Task: Starting form 0 to 100 \n    Task: Starting form 0 to 50 \n    Task: Starting form 0 to 25 \n    Task: Starting form 0 to 12 \n    Task: Starting form 0 to 6 \n\n```", "```java\n    Exception e=new Exception(\"This task throws an Exception: \"+\n                              \"Task from  \"+start+\" to \"+end); \n    completeExceptionally(e); \n\n```", "```java\n        public class ArrayGenerator { \n          public int[] generateArray(int size) { \n            int array[]=new int[size]; \n            Random random=new Random(); \n            for (int i=0; i<size; i++){ \n              array[i]=random.nextInt(10); \n            } \n            return array; \n          } \n\n```", "```java\n        public class TaskManager { \n\n```", "```java\n        private final ConcurrentLinkedDeque<SearchNumberTask> tasks; \n\n```", "```java\n        public TaskManager(){ \n          tasks=new ConcurrentLinkedDeque<>(); \n        } \n\n```", "```java\n        public void addTask(ForkJoinTask<Integer> task){ \n          tasks.add(task); \n        } \n\n```", "```java\n        public void cancelTasks(SearchNumberTask cancelTask){ \n          for (SearchNumberTask task  :tasks) { \n            if (task!=cancelTask) { \n              task.cancel(true); \n              task.logCancelMessage(); \n            } \n          } \n        } \n\n```", "```java\n        public class SearchNumberTask extends RecursiveTask<Integer> { \n\n```", "```java\n        private int numbers[]; \n\n```", "```java\n        private int start, end; \n\n```", "```java\n        private int number; \n\n```", "```java\n        private TaskManager manager; \n\n```", "```java\n        private final static int NOT_FOUND=-1; \n\n```", "```java\n        public SearchNumberTask(int numbers[], int start, int end,\n                                int number, TaskManager manager){ \n          this.numbers=numbers; \n          this.start=start; \n          this.end=end; \n          this.number=number; \n          this.manager=manager; \n        } \n\n```", "```java\n        @Override \n        protected Integer compute() { \n          System.out.println(\"Task: \"+start+\":\"+end); \n\n```", "```java\n        int ret; \n        if (end-start>10) { \n          ret=launchTasks(); \n\n```", "```java\n        } else { \n          ret=lookForNumber(); \n        } \n\n```", "```java\n        return ret; \n\n```", "```java\n        private int lookForNumber() { \n\n```", "```java\n        for (int i=start; i<end; i++){ \n          if (numbers[i]==number) { \n            System.out.printf(\"Task: Number %d found in position %d\\n\",\n                              number,i); \n            manager.cancelTasks(this); \n            return i; \n          } \n\n```", "```java\n          try { \n            TimeUnit.SECONDS.sleep(1); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } \n\n```", "```java\n          return NOT_FOUND; \n        } \n\n```", "```java\n        private int launchTasks() { \n          int mid=(start+end)/2; \n\n          Task task1=new Task(numbers,start,mid,number,manager); \n          Task task2=new Task(numbers,mid,end,number,manager); \n\n```", "```java\n        manager.addTask(task1); \n        manager.addTask(task2); \n\n```", "```java\n        task1.fork(); \n        task2.fork(); \n\n```", "```java\n        int returnValue; \n        returnValue=task1.join(); \n        if (returnValue!=-1) { \n          return returnValue; \n        } \n\n        returnValue=task2.join(); \n        return returnValue; \n\n```", "```java\n        public void logCancelMessage(){ \n          System.out.printf(\"Task: Canceled task from %d to %d\",\n                            start,end); \n        } \n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n\n```", "```java\n        ArrayGenerator generator=new ArrayGenerator(); \n        int array[]=generator.generateArray(1000); \n\n```", "```java\n        TaskManager manager=new TaskManager(); \n\n```", "```java\n        ForkJoinPool pool=new ForkJoinPool(); \n\n```", "```java\n        SearchNumberTask task=new SearchNumberTask (array,0,1000,\n                                                    5,manager); \n\n```", "```java\n        pool.execute(task); \n\n```", "```java\n        pool.shutdown(); \n\n```", "```java\n        try { \n          pool.awaitTermination(1, TimeUnit.DAYS); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n\n```", "```java\n        System.out.printf(\"Main: The program has finished\\n\"); \n\n```"]