<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Extending Microservices"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Extending Microservices</h1></div></div></div><p>We built a basic component offering a few services in Lesson 1, <span class="emphasis"><em>Building Microservices with Spring Boot</em></span>. In this lesson, we will focus on adding more features to make our microservice production ready.</p><p>We will discuss how to add these features to our microservice:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exception handling</li><li class="listitem" style="list-style-type: disc">HATEOAS</li><li class="listitem" style="list-style-type: disc">Caching</li><li class="listitem" style="list-style-type: disc">Internationalization</li></ul></div><p>We will also discuss how to document our microservice using Swagger. We will look at the basics of securing the microservice with Spring Security.</p><div class="section" title="Exception Handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Exception Handling</h1></div></div></div><p>Exception handling is one of the important parts of developing web services. When something goes wrong, we would want to return a good description of what went wrong to the service consumer. You would not want the service to crash without returning anything useful to the service consumer.</p><p>Spring Boot provides good default exception handling. We will start with looking at the default exception handling features provided by Spring Boot before moving on to customizing them.</p><div class="section" title="Spring Boot Default Exception Handling"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Spring Boot Default Exception Handling</h2></div></div></div><p>To understand the default exception handling provided by Spring Boot, let's start with firing a request to a nonexistent URL.</p><div class="section" title="Non-Existent Resource"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec25"/>Non-Existent Resource</h3></div></div></div><p>Let's send a <code class="literal">GET</code> request to <code class="literal">http://localhost:8080/non-existing-resource</code> using a header (<code class="literal">Content-Type:application/json</code>).</p><p>The following screenshot shows the response when we execute the request:</p><div class="mediaobject"><img alt="Non-Existent Resource" src="graphics/02_01.jpg"/></div><p>The response is as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    {
      "timestamp": 1484027734491,
      "status": 404,
      "error": "Not Found",
      "message": "No message available",
      "path": "/non-existing-resource"
    }</pre></div><p>Some important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The response header has an HTTP status of <code class="literal">404 - Resource Not Found</code></li><li class="listitem" style="list-style-type: disc">Spring Boot returns a valid JSON message as a response with the message stating that the resource is not found</li></ul></div></div><div class="section" title="Resource Throwing an Exception"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec26"/>Resource Throwing an Exception</h3></div></div></div><p>Let's create a resource that throws an exception, and send a <code class="literal">GET</code> request to it in order to understand how the application reacts to runtime exceptions.</p><p>Let's create a dummy service that throws an exception. The following code snippet shows a simple service:</p><div class="informalexample"><pre class="programlisting">    @GetMapping(path = "/users/dummy-service")
    public Todo errorService() {
      throw new RuntimeException("Some Exception Occured");
    }</pre></div><p>Some important things to note are as follows:</p><p>We are creating a <code class="literal">GET</code> service with the URI <code class="literal">/users/dummy-service</code>.</p><p>The service throws a <code class="literal">RuntimeException</code>. We chose <code class="literal">RuntimeException</code> to be able to create the exception easily. We can easily replace it with a custom exception; if needed.</p><p>Let's fire a <code class="literal">GET</code> request to the preceding service at <code class="literal">http://localhost:8080/users/dummy-service</code> using Postman. The response is as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    {
      "timestamp": 1484028119553,
      "status": 500,
      "error": "Internal Server Error",
      "exception": "java.lang.RuntimeException",
      "message": "Some Exception Occured",
      "path": "/users/dummy-service"
   }</pre></div><p>Some important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The response header has an HTTP status of <code class="literal">500</code>; <code class="literal">Internal server error</code></li><li class="listitem" style="list-style-type: disc">Spring Boot also returns the message with which the exception is thrown</li></ul></div><p>As we can see in the preceding two examples, Spring Boot provides good default exception handling. In the next section, we will focus on understanding how the application reacts to custom exceptions.</p></div><div class="section" title="Throwing a Custom Exception"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec27"/>Throwing a Custom Exception</h3></div></div></div><p>Let's create a custom exception and throw it from a service. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">    public class TodoNotFoundException extends RuntimeException {
      public TodoNotFoundException(String msg) {
        super(msg);
      }
    }</pre></div><p>It's a very simple piece of code that defines <code class="literal">TodoNotFoundException</code>.</p><p>Now let's enhance our <code class="literal">TodoController</code> class to throw <code class="literal">TodoNotFoundException</code> when a <code class="literal">todo</code> with a given ID is not found:</p><div class="informalexample"><pre class="programlisting">    @GetMapping(path = "/users/{name}/todos/{id}")
    public Todo retrieveTodo(@PathVariable String name, 
    @PathVariable int id) {
      Todo todo = todoService.retrieveTodo(id);
      if (todo == null) {
        throw new TodoNotFoundException("Todo Not Found");
       }

     return todo;
    }</pre></div><p>If <code class="literal">todoService</code> returns a null <code class="literal">todo</code>, we throw; <code class="literal">TodoNotFoundException</code>.</p><p>When we execute the service with a <code class="literal">GET</code> request to a nonexistent: <code class="literal">todo</code>(<code class="literal">http://localhost:8080/users/Jack/todos/222</code>), we get the response shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    {
      "timestamp": 1484029048788,
      "status": 500,
      "error": "Internal Server Error",
      "exception":    
      "com.mastering.spring.springboot.bean.TodoNotFoundException",
      "message": "Todo Not Found",
      "path": "/users/Jack/todos/222"
    }</pre></div><p>As we can see, a clear exception response is sent back to the service consumer. However, there is one thing that can be improved further--the response status. When a resource is not found, it is recommended that you return a <code class="literal">404 - Resource Not Found</code> status. We will look at how to customize the response status in the next example.</p></div><div class="section" title="Customizing the Exception Message"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec28"/>Customizing the Exception Message</h3></div></div></div><p>Let's look at how to customize the preceding exception and return the proper response status with a customized message.</p><p>Let's create a bean to define the structure of our custom exception message:</p><div class="informalexample"><pre class="programlisting">    public class ExceptionResponse {
      private Date timestamp = new Date();
      private String message;
      private String details;

      public ExceptionResponse(String message, String details) {
        super();
        this.message = message;
        this.details = details;
       }

      public Date getTimestamp() {
        return timestamp;
      }

      public String getMessage() {
        return message;
      }

      public String getDetails() {
        return details;
      }
     }</pre></div><p>We have created a simple exception response bean with an auto-populated timestamp with a few additional properties namely messages and details.</p><p>When; <code class="literal">TodoNotFoundException</code> is thrown, we would want to return a response using the <code class="literal">ExceptionResponse</code> bean. The following code shows how we can create a global exception handling for <code class="literal">TodoNotFoundException.class</code>:</p><div class="informalexample"><pre class="programlisting">    @ControllerAdvice
    @RestController
    public class RestResponseEntityExceptionHandler 
      extends  ResponseEntityExceptionHandler 
      {
        @ExceptionHandler(TodoNotFoundException.class)
        public final ResponseEntity&lt;ExceptionResponse&gt; 
        todoNotFound(TodoNotFoundException ex) {
           ExceptionResponse exceptionResponse = 
           new ExceptionResponse(  ex.getMessage(), 
           "Any details you would want to add");
           return new ResponseEntity&lt;ExceptionResponse&gt;
           (exceptionResponse, new HttpHeaders(), 
           HttpStatus.NOT_FOUND);
         }
     }</pre></div><p>Some important things to note are as follows:</p><p>
<code class="literal">RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler</code>: We are extending <code class="literal">ResponseEntityExceptionHandler</code>, which the base class is provided by Spring MVC for centralised exception handling <code class="literal">ControllerAdvice</code> classes.</p><p>
<code class="literal">@ExceptionHandler(TodoNotFoundException.class)</code>: This defines that the method to follow will handle the specific exception <code class="literal">TodoNotFoundException.class</code>. Any other exceptions for which custom exception handling is not defined will follow the default exception handling provided by Spring Boot.</p><p>
<code class="literal">ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(), "Any details you would want to add")</code>: This creates a custom exception response.</p><p>
<code class="literal">new ResponseEntity&lt;ExceptionResponse&gt;(exceptionResponse,new HttpHeaders(), HttpStatus.NOT_FOUND)</code>: This is the definition to return a <code class="literal">404 Resource Not Found</code> response with the custom exception defined earlier.</p><p>When we execute the service with a <code class="literal">GET</code> request to a nonexistent; <code class="literal">todo</code>(<code class="literal">http://localhost:8080/users/Jack/todos/222</code>), we get the following response:</p><div class="informalexample"><pre class="programlisting">    {
      "timestamp": 1484030343311,
      "message": "Todo Not Found",
      "details": "Any details you would want to add"
    }</pre></div><p>If you want to create a generic exception message for all exceptions, we can add a method to <code class="literal">RestResponseEntityExceptionHandler</code> with the <code class="literal">@ExceptionHandler(Exception.class)</code> annotation.</p><p>The following code snippet shows how we can do this:</p><div class="informalexample"><pre class="programlisting">    @ExceptionHandler(Exception.class)
    public final ResponseEntity&lt;ExceptionResponse&gt; todoNotFound(
    Exception ex) {
       //Customize and return the response
    }</pre></div><p>Any exception for which a custom exception handler is not defined; will be handled by the preceding method.</p></div><div class="section" title="Response Status"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec29"/>Response Status</h3></div></div></div><p>One of the important things to focus on with REST services is the response status of an error response. The following table shows the scenarios and the error response status to use:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Situation</p>
</th><th style="text-align: left" valign="bottom">
<p>Response Status</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>The request body does not meet the API specification. It does not contain enough details or contains validation errors.</p>
</td><td style="text-align: left" valign="top">
<p>;400 BAD REQUEST</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Authentication or authorization failure.</p>
</td><td style="text-align: left" valign="top">
<p>401 UNAUTHORIZED</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The user cannot perform the operation due to various factor, such as exceeding limits.</p>
</td><td style="text-align: left" valign="top">
<p>403 FORBIDDEN</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The resource does not exist.</p>
</td><td style="text-align: left" valign="top">
<p>404 NOT FOUND</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Unsupported operation, for example, trying POST on a resource where only GET is allowed.</p>
</td><td style="text-align: left" valign="top">
<p>405 METHOD NOT ALLOWED</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Error on a server. Ideally, this should not happen. The consumer; would not be able to fix this.</p>
</td><td style="text-align: left" valign="top">
<p>500 INTERNAL SERVER ERROR</p>
</td></tr></tbody></table></div><p>In this section, we looked at the default exception handling provided by Spring Boot and how we can customize it further to suit our needs.</p></div></div></div></div>
<div class="section" title="HATEOAS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>HATEOAS</h1></div></div></div><p>
<span class="strong"><strong>HATEOAS</strong></span> (<span class="strong"><strong>Hypermedia as the Engine of Application State</strong></span>) is one of the constraints of the REST application architecture.</p><p>Let's consider a situation where a service consumer is consuming numerous services from a service provider. The easiest way to develop this kind of system is to have the service consumer store the individual resource URIs of every resource they need from the service provider. However, this would create tight coupling between the service provider and the service consumer. Whenever any of the resource URIs change on the service provider, the service consumer needs to be updated.</p><p>Consider a; typical web application. Let's say I navigate to my bank account details page. Almost all banking websites would show links to all the transactions that are possible on my bank account on the screen so that I can easily navigate using the link.</p><p>What if we can bring a; similar concept to RESTful services so that a service returns not only the data about the requested resource, but also provides details of other related resources?</p><p>HATEOAS brings this concept of displaying related links for a given resource to RESTful services. When we return the details of a specific resource, we also return links to operations that can be performed on the resource, as well as links to related resources. If a service consumer can use the links from the response to perform transactions, then it would not need to hardcode all links.</p><p>An extract of constraints related to HATEOAS presented by Roy Fielding (<a class="ulink" href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a>) is as follows:</p><p>
<span class="emphasis"><em>A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types and link relations.</em></span>
</p><p>
<span class="emphasis"><em>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user's manipulation of those representations. The transitions may be determined (or limited by) the client's knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).</em></span>
</p><p>An example response with HATEOAS link is shown here. This is the response to the <code class="literal">/todos</code> request in order to retrieve all todos:</p><div class="informalexample"><pre class="programlisting">    {
      "_embedded" : {
        "todos" : [ {
          "user" : "Jill",
          "desc" : "Learn Hibernate",
          "done" : false,
         "_links" : {
          "self" : {
                 "href" : "http://localhost:8080/todos/1"
                 },
          "todo" : {
                 "href" : "http://localhost:8080/todos/1"
                  }
            }
     } ]
    },
     "_links" : {
     "self" : {
              "href" : "http://localhost:8080/todos"
              },
     "profile" : {
              "href" : "http://localhost:8080/profile/todos"
              },
     "search" : {
              "href" : "http://localhost:8080/todos/search"
              }
       },
     }</pre></div><p>The preceding response includes links to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Specific <code class="literal">todos</code> (<code class="literal">http://localhost:8080/todos/1</code>)</li><li class="listitem" style="list-style-type: disc">Search resource (<code class="literal">http://localhost:8080/todos/search</code>)</li></ul></div><p>If the service consumer wants to do a search, it has the option of taking the search URL from the response and sending the search request to it. This would reduce coupling between the service provider and the service consumer.</p><div class="section" title="Sending HATEOAS Links in Response"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Sending HATEOAS Links in Response</h2></div></div></div><p>Now that we understand what HATEOAS is, let's look at how we can send links related to a resource in the response.</p><div class="section" title="Spring Boot Starter HATEOAS"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec30"/>Spring Boot Starter HATEOAS</h3></div></div></div><p>Spring Boot has a specific starter for HATEOAS called <code class="literal">spring-boot-starter-hateoas</code>. We need to add it to the <code class="literal">pom.xml</code> file.</p><p>The following code snippet shows the dependency block:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;
    &lt;/dependency&gt;</pre></div><p>One of the important dependencies of <code class="literal">spring-boot-starter-hateoas</code> is <code class="literal">spring-hateoas</code>, which provides the HATEOAS features:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.hateoas&lt;/groupId&gt;
      &lt;artifactId&gt;spring-hateoas&lt;/artifactId&gt;
    &lt;/dependency&gt;</pre></div><p>Let's enhance the <code class="literal">retrieveTodo</code> resource (<code class="literal">/users/{name}/todos/{id}</code>) to return a link to retrieve all <code class="literal">todos</code> (<code class="literal">/users/{name}/todos</code>) in the response:</p><div class="informalexample"><pre class="programlisting">    @GetMapping(path = "/users/{name}/todos/{id}")
    public Resource&lt;Todo&gt; retrieveTodo(
    @PathVariable String name, @PathVariable int id) {
    Todo todo = todoService.retrieveTodo(id);
      if (todo == null) {
           throw new TodoNotFoundException("Todo Not Found");
        }

     Resource&lt;Todo&gt; todoResource = new Resource&lt;Todo&gt;(todo);
     ControllerLinkBuilder linkTo = 
     linkTo(methodOn(this.getClass()).retrieveTodos(name));
     todoResource.add(linkTo.withRel("parent"));

     return todoResource;
    }</pre></div><p>Some important points to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ControllerLinkBuilder linkTo = linkTo(methodOn(this.getClass()).retrieveTodos(name))</code>: We want to get a link to the <code class="literal">retrieveTodos</code> method on the current class</li><li class="listitem" style="list-style-type: disc"><code class="literal">linkTo.withRel("parent")</code>: Relationship with the current resource is parent</li></ul></div><p>The following snippet shows the response when a <code class="literal">GET</code> request is sent to <code class="literal">http://localhost:8080/users/Jack/todos/1</code>:</p><div class="informalexample"><pre class="programlisting">   {
     "id": 1,
     "user": "Jack",
     "desc": "Learn Spring MVC",
     "targetDate": 1484038262110,
     "done": false,
     "_links": {
               "parent": {
               "href": "http://localhost:8080/users/Jack/todos"
               }
        }
   }</pre></div><p>The <code class="literal">_links</code> section will contain all the links. Currently, we have one link with the relation parent and <code class="literal">href</code> as <code class="literal">http://localhost:8080/users/Jack/todos</code>.:</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>If you have problems executing the preceding request, try executing using an Accept header--<code class="literal">application/json</code>.</p></div></div><p>HATEOAS is not something that is commonly used in most of the resources today. However, it has the potential to be really useful in reducing the coupling between the service provider and the consumer.</p></div></div></div>
<div class="section" title="Validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Validation</h1></div></div></div><p>A good service always validates data before processing it. In this section, we will look at the Bean Validation API and use its reference implementation to implement validation in our services.</p><p>The Bean Validation API provides a number of annotations that can be used to validate beans. The <span class="strong"><strong>JSR 349</strong></span> specification defines Bean Validation API 1.1. Hibernate-validator is the reference implementation; both are already defined as dependencies in the <code class="literal">spring-boot-web-starter</code> project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hibernate-validator-5.2.4.Final.jar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">validation-api-1.1.0.Final.jar</code></li></ul></div><p>We will create a simple validation for the <code class="literal">createTodo</code> service method.</p><p>Creating validations involves two steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Enabling validation on the controller method.</li><li class="listitem">Adding validations on the bean.</li></ol></div><div class="section" title="Enabling Validation on the Controller Method"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Enabling Validation on the Controller Method</h2></div></div></div><p>It's very simple to enable validation on the controller method. The following snippet shows an example:</p><div class="informalexample"><pre class="programlisting">    @RequestMapping(method = RequestMethod.POST, 
    path = "/users/{name}/todos")     ResponseEntity&lt;?&gt; add(@PathVariable String name
    @Valid @RequestBody Todo todo) {</pre></div><p>The <code class="literal">@Valid(package javax.validation)</code> annotation is used to mark a parameter for validation. Any validation that is defined in the <code class="literal">Todo</code> bean is executed before the <code class="literal">add</code> method is executed.</p></div><div class="section" title="Defining validations on the Bean"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Defining validations on the Bean</h2></div></div></div><p>Let's define a few validations on the <code class="literal">Todo</code> bean:</p><div class="informalexample"><pre class="programlisting">   public class Todo {
     private int id; 

     @NotNull
     private String user;

     @Size(min = 9, message = "Enter atleast 10 Characters.")
     private String desc;</pre></div><p>Some important points to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@NotNull</code>: Validates that the user field is not empty</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Size(min = 9, message = "Enter atleast 10 Characters.")</code>: Checks whether the <code class="literal">desc</code> field has at least nine characters</li><li class="listitem" style="list-style-type: disc">There are a number of other annotations that can be used to validate beans. The following are some of the Bean Validation annotations:</li><li class="listitem" style="list-style-type: disc"><code class="literal">@AssertFalse</code>, <code class="literal">@AssertTrue</code>: For Boolean elements. Checks the annotated element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@AssertFalse</code>: Checks for false. <code class="literal">@Assert</code> checks for true.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Future</code>: The annotated element must be a date in the future.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Past</code>: The annotated element must be a date in the past.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Max</code>: The annotated element must be a number whose value must be lower or equal to the specified maximum.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Min</code>: The annotated element must be a number whose value must be higher or equal to the specified minimum.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@NotNull</code>: The annotated element cannot be null.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Pattern</code>: The annotated <code class="literal">{@code CharSequence}</code> element must match the specified regular expression. The regular expression follows the Java regular expression conventions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Size</code>: The annotated element size must be within the specified boundaries.</li></ul></div></div><div class="section" title="Unit Testing Validations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Unit Testing Validations</h2></div></div></div><p>The following example shows how we can unit test the validations we added in:</p><div class="informalexample"><pre class="programlisting">     @Test
     public void createTodo_withValidationError() throws Exception {
       Todo mockTodo = new Todo(CREATED_TODO_ID, "Jack", 
       "Learn Spring MVC", new Date(), false);

       String todo = "{"user":"Jack","desc":"Learn","done":false}";

       when( service.addTodo(
         anyString(), anyString(), isNull(), anyBoolean()))
        .thenReturn(mockTodo);

         MvcResult result = mvc.perform(
         MockMvcRequestBuilders.post("/users/Jack/todos")
        .content(todo)
        .contentType(MediaType.APPLICATION_JSON))
        .andExpect(
           status().is4xxClientError()).andReturn();
     }</pre></div><p>Some important points to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">"desc":"Learn"</code>: We are using a <code class="literal">desc</code> value of length <code class="literal">5</code>. This would cause a validation failure for the <code class="literal">@Size(min = 9, message = "Enter atleast 10 Characters.")</code> check.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.andExpect(status().is4xxClientError())</code>: Checks for validation error status.</li></ul></div></div></div>
<div class="section" title="Documenting REST Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Documenting REST Services</h1></div></div></div><p>Before a service provider can consume a service, they need a service contract. A service contract defines all the; details about a service:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How can I call a service? What is the URI of the service?</li><li class="listitem" style="list-style-type: disc">What should be the request format?</li><li class="listitem" style="list-style-type: disc">What kind of response should I expect?</li></ul></div><p>There are multiple options to define a service contract for RESTful services. The most popular one in the last couple of years is <span class="strong"><strong>Swagger</strong></span>. Swagger is gaining a lot of ground, with support from major vendors in the last couple of years. In this section, we will generate Swagger documentation for our services.</p><p>The following quote from the Swagger website (<a class="ulink" href="http://swagger.io">http://swagger.io</a>) defines the purpose of the Swagger specification:</p><p>Swagger specification creates the RESTful contract for your API, detailing all of its resources and operations in a human and machine readable format for easy development, discovery, and integration.</p><div class="section" title="Generating a Swagger Specification"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Generating a Swagger Specification</h2></div></div></div><p>One of the interesting developments in the last few years of RESTful services development is the evolution of tools to generate service documentation (specification) from the code. This ensures that the code and documentation are always in sync.</p><p>
<span class="strong"><strong>Springfox Swagger</strong></span> can be used to generate Swagger documentation from the RESTful services code. What's more, there is a wonderful tool called <span class="strong"><strong>Swagger UI</strong></span>, which, when integrated into the application, provides human-readable documentation.</p><p>The following code snippet shows how we can add both these tools; to the; <code class="literal">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
     &lt;groupId&gt;io.springfox&lt;/groupId&gt;
     &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
     &lt;version&gt;2.4.0&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
     &lt;groupId&gt;io.springfox&lt;/groupId&gt;
     &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
     &lt;version&gt;2.4.0&lt;/version&gt;
    &lt;/dependency&gt;</pre></div><p>The next step is to add the configuration class to enable and generate Swagger documentation. The following snippet shows how to do it:</p><div class="informalexample"><pre class="programlisting">    @Configuration
    @EnableSwagger2
    public class SwaggerConfig {
      @Bean
      public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
        .select()
        .apis(RequestHandlerSelectors.any())
        .paths(PathSelectors.any()).build();
      }
    }</pre></div><p>Some important points to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@Configuration</code>: Defines a Spring configuration file</li><li class="listitem" style="list-style-type: disc"><code class="literal">@EnableSwagger2</code>: The annotation to enable Swagger support</li><li class="listitem" style="list-style-type: disc"><code class="literal">Docket</code>: A simple builder class to configure the generation of Swagger documentation using the Swagger Spring MVC framework</li><li class="listitem" style="list-style-type: disc"><code class="literal">new Docket(DocumentationType.SWAGGER_2)</code>: Configures Swagger 2 as the Swagger version to be used</li><li class="listitem" style="list-style-type: disc"><code class="literal">.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())</code>: Includes all APIs and paths in the documentation</li></ul></div><p>When we bring the server up, we can launch the API Docs URL (<code class="literal">http://localhost:8080/v2/api-docs</code>). The following screenshot shows some of the generated documentation:</p><div class="mediaobject"><img alt="Generating a Swagger Specification" src="graphics/02_02.jpg"/></div><p>Let's look at some of the generated documentation. Listed here is the documentation to retrieve the; <code class="literal">todos</code> service:</p><div class="informalexample"><pre class="programlisting">    "/users/{name}/todos": {
      "get": {
      "tags": [
             "todo-controller"
             ],
      "summary": "retrieveTodos",
      "operationId": "retrieveTodosUsingGET",
      "consumes": [
               "application/json"
               ],
      "produces": [
               "*/*"
               ],
      "parameters": [
              {
                "name": "name",
                "in": "path",
                "description": "name",
                "required": true,
                "type": "string"
              }
             ],
       "responses": {
       "200": {
              "description": "OK",
              "schema": {
                      "type": "array",
                      items": {
                          "$ref": "#/definitions/Todo"
                        }
                       }
               },
       "401": {
                "description": "Unauthorized"
               },
       "403": {
                "description": "Forbidden"
              },
       "404": {
                "description": "Not Found"
              } 
        }
     }</pre></div><p>The service definition clearly defines the request; and response; of the service. Also defined are the different response statuses that the service can return in different situations.</p><p>The following code snippet shows the definition of the <code class="literal">Todo</code> bean:</p><div class="informalexample"><pre class="programlisting">    "Resource«Todo»": {
      "type": "object",
      "properties": {
      "desc": {
               "type": "string"
             },
     "done": {
               "type": "boolean"
             },
     "id": {
              "type": "integer",
              "format": "int32"
           },
     "links": {
              "type": "array",
              "items": {
                         "$ref": "#/definitions/Link"
                       }
              },
     "targetDate": {
                    "type": "string",
                    "format": "date-time"
                },
     "user": {
              "type": "string"
            }
        }
      }</pre></div><p>It defines all the elements in the <code class="literal">Todo</code> bean, along with their formats.</p><div class="section" title="Swagger UI"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec31"/>Swagger UI</h3></div></div></div><p>Swagger UI (<code class="literal">http://localhost:8080/swagger-ui.html</code>) can also be used to look at the documentation. Swagger UI is enabled by the dependency (<code class="literal">io.springfox:springfox-swagger-ui</code>) that was added in our <code class="literal">pom.xml</code>, in the previous step.</p><p>Swagger UI (<a class="ulink" href="http://petstore.swagger.io">http://petstore.swagger.io</a>) is also available online. We can visualize any Swagger documentation (swagger JSON) using Swagger UI.</p><p>The following screenshot shows the list of controller-exposing services. When we click on any controller, it expands to show the list of request methods and URIs each controller supports:</p><div class="mediaobject"><img alt="Swagger UI" src="graphics/02_03.jpg"/></div><p>The following screenshot shows the details for the POST service to create a <code class="literal">todo</code> for the user in Swagger UI:</p><div class="mediaobject"><img alt="Swagger UI" src="graphics/02_04.jpg"/></div><p>Some important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Parameters</code> show all the important parameters including the request body</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Parameter Type</code> body (for the <code class="literal">todo</code> parameter) shows the expected structure for the body of the request</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Response Messages</code> sections show different HTTP status codes returned by the service</li><li class="listitem" style="list-style-type: disc">The Swagger UI provides an excellent way to expose service definitions for your API without a lot of additional effort.</li></ul></div></div><div class="section" title="Customizing Swagger Documentation Using Annotations"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec32"/>Customizing Swagger Documentation Using Annotations</h3></div></div></div><p>The Swagger UI also provides annotations to further customize your documentation.</p><p>Listed here is some of the documentation to retrieve the <code class="literal">todos</code> service:</p><div class="informalexample"><pre class="programlisting">    "/users/{name}/todos": {
      "get": {
      "tags": [
             "todo-controller"
             ],
      "summary": "retrieveTodos",
      "operationId": "retrieveTodosUsingGET",
      "consumes": [
               "application/json"
               ],
      "produces": [
                "*/*"
               ],</pre></div><p>As you can see, the documentation generated is very raw. There are a number of things we can improve in the documentation to describe the services better. Here are a couple of examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Provide a better summary</li><li class="listitem" style="list-style-type: disc">Add application/JSON to produces</li></ul></div><p>Swagger provides annotations we can add to our RESTful services in order to customize the documentation. Let's add a few annotations to the controller in order to improve the documentation:</p><div class="informalexample"><pre class="programlisting">    @ApiOperation(
      value = "Retrieve all todos for a user by passing in his name", 
      notes = "A list of matching todos is returned. Current pagination   
      is not supported.",
      response = Todo.class, 
      responseContainer = "List", 
      produces = "application/json")
      @GetMapping("/users/{name}/todos")
      public List&lt;Todo&gt; retrieveTodos(@PathVariable String name) {
        return todoService.retrieveTodos(name);
     }</pre></div><p>A few important points to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@ApiOperation(value = "Retrieve all todos for a user by passing in his name")</code>: Produced in the documentation as a summary of the service</li><li class="listitem" style="list-style-type: disc"><code class="literal">notes = "A list of matching todos is returned. Current pagination is not supported."</code>: Produced in the documentation as a description of the service</li><li class="listitem" style="list-style-type: disc"><code class="literal">produces = "application/json"</code>: Customizes the <code class="literal">produces</code> section of the service documentation</li></ul></div><p>Here is an extract of the documentation after the update:</p><div class="informalexample"><pre class="programlisting">    get": {
         "tags": [
                   "todo-controller"
                 ],
         "summary": "Retrieve all todos for a user by passing in his 
          name",
         "description": "A list of matching todos is returned. Current 
          pagination is not supported.",
         "operationId": "retrieveTodosUsingGET",
         "consumes": [
                     "application/json"
                   ],
         "produces": [
                     "application/json",
                     "*/*"
                   ],</pre></div><p>Swagger provides a lot of other annotations to customize the documentation. Listed here are some of the important annotations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@Api</code>: Marks a class as a Swagger resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ApiModel</code>: Provides additional information about Swagger models</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ApiModelProperty</code>: Adds and manipulates the data of a model property</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ApiOperation</code>: Describes an operation or an HTTP method against a specific path</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ApiParam</code>: Adds additional metadata for operation parameters</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ApiResponse</code>: Describes an example response of an operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ApiResponses</code>: A wrapper to allow a list of multiple <code class="literal">ApiResponse</code> objects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Authorization</code>: Declares an authorization scheme to be used on a resource or an operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">@AuthorizationScope</code>: Describes an OAuth 2 authorization scope</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ResponseHeader</code>: Represents a header that can be provided as part of the response</li></ul></div><p>Swagger provides a few Swagger definition annotations that can be used to customize high-level information about a group of services--contacts, licensing, and other general information. Listed here are some of the important ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@SwaggerDefinition</code>: Definition-level properties to be added to the generated Swagger definition</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Info</code>: General metadata for a Swagger definition</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Contact</code>: Properties to describe the person to be contacted for a Swagger definition</li><li class="listitem" style="list-style-type: disc"><code class="literal">@License</code>: Properties to describe the license for a Swagger definition</li></ul></div></div></div></div>
<div class="section" title="Securing REST Services with Spring Security"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Securing REST Services with Spring Security</h1></div></div></div><p>All the services we have created up until now are unsecured. A consumer does not need to provide any credentials to access these services. However, all services in the real world are usually secured.</p><p>In this section, we will discuss two ways of authenticating REST services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic authentication</li><li class="listitem" style="list-style-type: disc">OAuth 2.0 authentication</li></ul></div><p>We will implement these two types of authentication with Spring Security.</p><p>Spring Boot provides a starter for Spring Security using <code class="literal">spring-boot-starter-security</code>. We will start with adding Spring Security starter to our <code class="literal">pom.xml</code> file.</p><div class="section" title="Adding Spring Security Starter"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Adding Spring Security Starter</h2></div></div></div><p>Add the following dependency to your file <code class="literal">pom.xml</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
    &lt;/dependency&gt;</pre></div><p>The <code class="literal">Spring-boot-starter-security</code> dependency brings in three important Spring Security dependencies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">spring-security-config</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">spring-security-core</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">spring-security-web</code></li></ul></div></div><div class="section" title="Basic Authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Basic Authentication</h2></div></div></div><p>The <code class="literal">Spring-boot-starter-security</code> dependency also auto-configures basic authentication for all services by default.</p><p>If we try to access any of the services now, we would get <code class="literal">"Access Denied"</code>.</p><p>The response when we send a request to <code class="literal">http://localhost:8080/users/Jack/todos</code> is shown as an example in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    {
      "timestamp": 1484120815039,
      "status": 401,
      "error": "Unauthorized",
      "message": "Full authentication is required to access this 
       resource",
       "path": "/users/Jack/todos"
    }</pre></div><p>The response status is <code class="literal">401 - Unauthorized</code>.</p><p>When a resource is secured with basic authentication, we would need to send a user ID and password to authenticate our request. Since we did not configure a user ID and password, Spring Boot auto-configures a default user ID and password. The default user ID is <code class="literal">user</code>. The default password is usually printed in the log.</p><p>An example is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">2017-01-11 13:11:58.696 INFO 3888 --- [restartedMain] b.a.s.AuthenticationManagerConfiguration :

Using default security password: 3fb5564a-ce53-4138-9911-8ade17b2f478

2017-01-11 13:11:58.771 INFO 3888 --- [restartedMain] o.s.s.web.DefaultSecurityFilterChain : Creating filter chain: Ant [pattern='/css/**'], []</pre></div><p>Underlined in the preceding code snippet is the default security password printed in the log.</p><p>We can use Postman to fire a request with basic authentication. The following screenshot shows how basic authentication details can be sent along with a request:</p><div class="mediaobject"><img alt="Basic Authentication" src="graphics/02_05.jpg"/></div><p>As you can see, authentication succeeds and we get a proper response back.</p><p>We can configure the user ID and password of our choice in <code class="literal">application.properties</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">   security.user.name=user-name
   security.user.password=user-password</pre></div><p>Spring Security also provides options to authenticate with LDAP or JDBC or any other data source with user credentials.</p><div class="section" title="Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec33"/>Integration Testing</h3></div></div></div><p>The integration test we wrote for the service earlier will start failing because of invalid credentials. We will now update the integration test to supply basic authentication credentials:</p><div class="informalexample"><pre class="programlisting">    private TestRestTemplate template = new TestRestTemplate();
    HttpHeaders headers = createHeaders("user-name", "user-password");

    HttpHeaders createHeaders(String username, String password) {
      return new HttpHeaders() {
       {
         String auth = username + ":" + password;
         byte[] encodedAuth = Base64.getEncoder().encode
         (auth.getBytes(Charset.forName("US-ASCII")));
         String authHeader = "Basic " + new String(encodedAuth);
         set("Authorization", authHeader);
        }
      };
     }

    @Test
    public void retrieveTodos() throws Exception {
      String expected = "["
      + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" + ","
      + "{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]";
      ResponseEntity&lt;String&gt; response = template.exchange(
      createUrl("/users/Jack/todos"), HttpMethod.GET,
      new HttpEntity&lt;String&gt;(null, headers),
      String.class);
      JSONAssert.assertEquals(expected, response.getBody(), false);
    }</pre></div><p>Some important things to note are as follows:</p><p>
<code class="literal">createHeaders("user-name", "user-password")</code>: This method creates <code class="literal">Base64. getEncoder().encode</code> basic authentication headers</p><p>
<code class="literal">ResponseEntity&lt;String&gt; response = template.exchange(createUrl("/users/Jack/todos"), ;HttpMethod.GET,new HttpEntity&lt;String&gt;(null, headers), String.class)</code>: The key change is the use of <code class="literal">HttpEntity</code> to supply the headers that we created earlier to the REST template</p></div><div class="section" title="Unit Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec34"/>Unit Testing</h3></div></div></div><p>We would not want to use security for our unit tests. The following code snippet shows how we can disable security for the unit test:</p><div class="informalexample"><pre class="programlisting">   @RunWith(SpringRunner.class)
   @WebMvcTest(value = TodoController.class, secure = false)
   public class TodoControllerTest {</pre></div><p>The key part is the <code class="literal">secure = false</code> parameter on the <code class="literal">WebMvcTest</code> annotation. This will disable Spring Security for the unit test.</p></div></div><div class="section" title="OAuth 2 Authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>OAuth 2 Authentication</h2></div></div></div><p>OAuth is a protocol that provides flows in order to exchange authorization and authentication information between a range of web-enabled applications and services. It enables third-party applications to get restricted access to user information from a service, for example, Facebook, Twitter, or GitHub.</p><p>Before we get into the details, it would be useful to review the terminology typically used with respect to OAuth 2 authentication.</p><p>Let's consider an example. Let's say we want to expose the <code class="literal">Todo</code> API to third-party applications on the internet.</p><p>The following are the important players in a typical OAuth 2 exchange:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resource owner</strong></span>: This is the user of the third-party application that wants to use our Todo API. It decides how much of the information available with our API can be made available to the third-party application.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resource server</strong></span>: This hosts the Todo API, the resource we want to secure.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>: This is the third-party application that wants to consume our API.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Authorization server</strong></span>: This is the server that provides the OAuth service.</li></ul></div><div class="section" title="High-level flow"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec35"/>High-level flow</h3></div></div></div><p>The following steps show a; high-level flow of a typical OAuth authentication:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The application requests that the user authorizes access to API resources.</li><li class="listitem">When the user provides access, the application receives an authorization grant.</li><li class="listitem">The application provides user authorization grant and its own client credentials to the authorization server.</li><li class="listitem">If the authentication is successful, the authorization server responds with an access token.</li><li class="listitem">The application calls the API (the resource server) that provides the access token for authentication.</li><li class="listitem">If the access token is valid, the resource server returns the details of the resource.</li></ol></div></div><div class="section" title="Implementing OAuth 2 authentication for Our Service"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec36"/>Implementing OAuth 2 authentication for Our Service</h3></div></div></div><p>OAuth 2 for Spring Security (<code class="literal">spring-security-oauth2</code>) is the module to provide OAuth 2 support to Spring Security. We will add it as a dependency in our <code class="literal">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
      &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
    &lt;/dependency&gt;</pre></div></div><div class="section" title="Setting up Authorization and Resource Servers:"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec37"/>Setting up Authorization and Resource Servers:</h3></div></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The <code class="literal">spring-security-oauth2</code> has not yet been (June 2017) been updated with the changes for Spring Framework 5.x and Spring Boot 2.x. We will use Spring Boot 1.5.x for examples related to OAuth 2 authentication. Code examples are here in the GitHub repository: <a class="ulink" href="https://github.com/PacktPublishing/Mastering-Spring-5.0">https://github.com/PacktPublishing/Mastering-Spring-5.0</a>.</p></div></div><p>Typically, an authorization server would be a different server from the application where the API is exposed. To keep things simple, we will make our current API server act both as the resource server and as the authorization server.</p><p>The following code snippet shows how we can enable our application to act as the resource and authorization server:</p><div class="informalexample"><pre class="programlisting">   @EnableResourceServer
   @EnableAuthorizationServer
   @SpringBootApplication
   public class Application {</pre></div><p>Here are a couple of important things to note:</p><p>
<code class="literal">@EnableResourceServer</code>: A convenient annotation for OAuth 2 resource servers, enabling a Spring Security filter that authenticates requests via an incoming OAuth 2 token</p><p>
<code class="literal">@EnableAuthorizationServer</code>: A convenience annotation to enable an authorization server with; <code class="literal">AuthorizationEndpoint</code> and; <code class="literal">TokenEndpoint</code> in the current application context, which must be a <code class="literal">DispatcherServlet</code> context</p><p>Now we can configure the access details in <code class="literal">application.properties</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    security.user.name=user-name
    security.user.password=user-password
    security.oauth2.client.clientId: clientId
    security.oauth2.client.clientSecret: clientSecret
    security.oauth2.client.authorized-grant-types:     
    authorization_code,refresh_token,password
    security.oauth2.client.scope: openid</pre></div><p>A few important details are as follows:</p><p>
<code class="literal">security.user.name</code> and <code class="literal">security.user.password</code> are the authentication details of the resource owner that is an end user of a third-party application</p><p>
<code class="literal">security.oauth2.client.clientId</code> and <code class="literal">security.oauth2.client.clientSecret</code> are the authentication details of the client that is the third-party application (the service consumer)</p></div></div><div class="section" title="Executing OAuth Requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Executing OAuth Requests</h2></div></div></div><p>We need a two-step process to access the APIs:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Obtain an access token.</li><li class="listitem">Execute the request using the access token.</li></ol></div><div class="section" title="Obtaining an Access Token"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec38"/>Obtaining an Access Token</h3></div></div></div><p>To get an access token, we call the authorization server (<code class="literal">http://localhost:8080/oauth/token</code>), providing the client authentication details in the basic authentication mode and the user credentials as part of the form data. The following screenshot shows how we can configure the client authentication details in basic authentication:</p><div class="mediaobject"><img alt="Obtaining an Access Token" src="graphics/02_06.jpg"/></div><p>The following screenshot shows how to configure the user authentication details as part of the <code class="literal">POST</code> parameters:</p><div class="mediaobject"><img alt="Obtaining an Access Token" src="graphics/02_07.jpg"/></div><p>We are using <code class="literal">grant_type</code> as the password, indicating that we are sending the user authentication details to get the access token. When we execute the request, we get a response similar to the one shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    {
      "access_token": "a633dd55-102f-4f53-bcbd-a857df54b821",
      "token_type": "bearer",
      "refresh_token": "d68d89ec-0a13-4224-a29b-e9056768c7f0",
      "expires_in": 43199,
      "scope": "openid"
    }</pre></div><p>Here are a couple of important details:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">access_token</code>: Client application can use the access token to authenticate further API calls. However, the access token will expire, typically in a very short time period.</li><li class="listitem" style="list-style-type: disc"><code class="literal">refresh_token</code>: Client application can submit a new request to the authentication server with the <code class="literal">refresh_token</code> to get a new <code class="literal">access_token</code>.</li></ul></div></div><div class="section" title="Executing the Request Using the Access Token"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec39"/>Executing the Request Using the Access Token</h3></div></div></div><p>Once we have <code class="literal">access_token</code>, we can execute the request using <code class="literal">access_token</code>, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Executing the Request Using the Access Token" src="graphics/02_08.jpg"/></div><p>As you can see in the preceding screenshot, we provide the access token in the request header called <code class="literal">Authorization</code>. We use the value of the format <code class="literal">"Bearer {access_token}"</code>. Authentication succeeds and we get the expected resource details.</p></div><div class="section" title="Integration Test"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec40"/>Integration Test</h3></div></div></div><p>We will now update our integration test to provide the OAuth 2 credentials. The following test highlights the important details:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void retrieveTodos() throws Exception {
      String expected = "["
      + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" + ","
      +"{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]";
      String uri = "/users/Jack/todos";
      ResourceOwnerPasswordResourceDetails resource = 
      new ResourceOwnerPasswordResourceDetails();
      resource.setUsername("user-name");
      resource.setPassword("user-password");
      resource.setAccessTokenUri(createUrl("/oauth/token"));
      resource.setClientId("clientId");
      resource.setClientSecret("clientSecret");
      resource.setGrantType("password");
      OAuth2RestTemplate oauthTemplate = new 
      OAuth2RestTemplate(resource,new 
      DefaultOAuth2ClientContext());
      ResponseEntity&lt;String&gt; response = 
      oauthTemplate.getForEntity(createUrl(uri), String.class);
     JSONAssert.assertEquals(expected, response.getBody(), false);
    }</pre></div><p>Some important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails()</code>: We set up <code class="literal">ResourceOwnerPasswordResourceDetails</code> with the user credentials and the client credentials</li><li class="listitem" style="list-style-type: disc"><code class="literal">resource.setAccessTokenUri(createUrl("/oauth/token"))</code>: Configures the URL of the authentication server</li><li class="listitem" style="list-style-type: disc"><code class="literal">OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource,new DefaultOAuth2ClientContext())</code>: The <code class="literal">OAuth2RestTemplate</code> is an extension of <code class="literal">RestTemplate</code>, which supports the OAuth 2 protocol</li></ul></div><p>In this section, we looked at how to enable OAuth 2 authentication in our resources.</p></div></div></div>
<div class="section" title="Internationalization"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Internationalization</h1></div></div></div><p>
<span class="strong"><strong>Internationalization</strong></span> (<span class="strong"><strong>i18n</strong></span>) is the process of developing applications and services so that they can be customized for different languages and cultures across the world. It is also called <span class="strong"><strong>localization</strong></span>. The goal of internationalization or localization is to build applications that can offer content in multiple languages and formats.</p><p>Spring Boot has built-in support for internationalization.</p><p>Let's build a simple service to understand how we can build internationalization in our APIs.</p><p>We would need to add a <code class="literal">LocaleResolver</code> and a message source to our Spring Boot application. The following code snippet should be included in <code class="literal">Application.java</code>:</p><div class="informalexample"><pre class="programlisting">    @Bean
    public LocaleResolver localeResolver() {
      SessionLocaleResolver sessionLocaleResolver = 
      new SessionLocaleResolver();
      sessionLocaleResolver.setDefaultLocale(Locale.US);
      return sessionLocaleResolver;
    }

   @Bean
   public ResourceBundleMessageSource messageSource() {
     ResourceBundleMessageSource messageSource = 
     new ResourceBundleMessageSource();
     messageSource.setBasenames("messages");
     messageSource.setUseCodeAsDefaultMessage(true);
    return messageSource;
   }</pre></div><p>Some important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sessionLocaleResolver.setDefaultLocale(Locale.US)</code>: We are a setting a default locale of <code class="literal">Locale.US</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">messageSource.setBasenames("messages")</code>: We're setting the base name of the message source as <code class="literal">messages</code>. If we are in fr locale (France), we would use messages from <code class="literal">message_fr.properties</code>. If a message is not available in <code class="literal">message_fr.properties</code>, it would be searched for in the default <code class="literal">message.properties</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">messageSource.setUseCodeAsDefaultMessage(true)</code>: If a message is not found, then the code is returned as the default message.</li></ul></div><p>Let's configure the messages in the respective files. Let's start with the <code class="literal">messages</code> properties. The messages in this file would act as the defaults:</p><div class="informalexample"><pre class="programlisting">    welcome.message=Welcome in English</pre></div><p>Let's also configure <code class="literal">messages_fr.properties</code>. The messages in this file would be used for the locale. If a message is not present here, then the defaults from <code class="literal">messages.properties</code> will be used:</p><div class="informalexample"><pre class="programlisting">   welcome.message=Welcome in French</pre></div><p>Let's create a service that returns a specific message using the locale specified in the <code class="literal">"Accept-Language"</code> header:</p><div class="informalexample"><pre class="programlisting">    @GetMapping("/welcome-internationalized")
    public String msg(@RequestHeader(value = "Accept-Language", 
    required = false) Locale locale) {
      return messageSource.getMessage("welcome.message", null, 
      locale);
    }</pre></div><p>Here are a couple of things to note:</p><p>
<code class="literal">@RequestHeader(value = "Accept-Language", required = false) Locale locale</code>: The locale is picked up from the request header <code class="literal">Accept-Language</code>. It is not required. If a locale is not specified, the default locale is used.</p><p>
<code class="literal">messageSource.getMessage("welcome.message", null, locale)</code>: <code class="literal">messageSource</code> is autowired into the controller. We get the welcome message based on the given locale.</p><p>The following screenshot shows the response when the preceding service is called without specifying a default <code class="literal">Accept-Language</code>:</p><div class="mediaobject"><img alt="Internationalization" src="graphics/02_09.jpg"/></div><p>The default message from <code class="literal">messages.properties</code> is returned.</p><p>The following screenshot shows the response when the preceding service is called with <code class="literal">Accept-Language fr</code>:</p><div class="mediaobject"><img alt="Internationalization" src="graphics/02_10.jpg"/></div><p>The localized message from <code class="literal">messages_fr.properties</code> is returned.</p><p>In the preceding example, we customized the service to return localized messages based on the locale in the request. A similar approach can be used to internationalize all services in a component.</p></div>
<div class="section" title="Caching"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Caching</h1></div></div></div><p>Caching data from services plays a crucial role in improving the performance and scalability of applications. In this section, we will look at the implementation options that Spring Boot provides.</p><p>Spring provides a caching abstraction based on annotations. We will start with using Spring caching annotations. Later, we will introduce <span class="strong"><strong>JSR-107</strong></span> caching annotations and compare them with Spring abstractions.</p><div class="section" title="Spring-boot-starter-cache"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Spring-boot-starter-cache</h2></div></div></div><p>Spring Boot provides a starter project for caching <code class="literal">spring-boot-starter-cache</code>. Adding this to an application brings in all the dependencies to enable <span class="strong"><strong>JSR-107</strong></span> and Spring caching annotations. The following code snippet shows the dependency details for <code class="literal">spring-boot-starter-cache</code>. Let's add this to our file <code class="literal">pom.xml</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
    &lt;/dependency&gt;</pre></div></div><div class="section" title="Enabling Caching"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Enabling Caching</h2></div></div></div><p>Before we can start using caching, we need to enable caching on the application. The following code snippet shows how we can enable caching:</p><div class="informalexample"><pre class="programlisting">    @EnableCaching
    @SpringBootApplication
    public class Application {</pre></div><p>
<code class="literal">@EnableCaching</code> would enable caching in a Spring Boot application.</p><p>Spring Boot automatically configures a suitable CacheManager framework to serve as a provider for the relevant cache. We will look at the details of how Spring Boot decides the CacheManager a little later.</p></div><div class="section" title="Caching Data"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Caching Data</h2></div></div></div><p>Now that we have enabled caching, we can add the <code class="literal">@Cacheable</code> annotation to the methods where we want to cache the data. The following code snippet shows how to enable caching on <code class="literal">retrieveTodos</code>:</p><div class="informalexample"><pre class="programlisting">    @Cacheable("todos")
    public List&lt;Todo&gt; retrieveTodos(String user) {</pre></div><p>In the preceding example, the <code class="literal">todos</code> for a specific user are cached. On the first call to the method for a specific user, the <code class="literal">todos</code> will be retrieved from the service. On subsequent calls for the same user, the data will be returned from the cache.</p><p>Spring also provides conditional caching. In the following snippet, caching is enabled only if the specified condition is satisfied:</p><div class="informalexample"><pre class="programlisting">    @Cacheable(cacheNames="todos", condition="#user.length &lt; 10")
    public List&lt;Todo&gt; retrieveTodos(String user) {</pre></div><p>Spring also provides additional annotations to evict data from the cache and add some custom data to cache. A few important ones are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@CachePut</code>: Used to explicitly add data to the cache</li><li class="listitem" style="list-style-type: disc"><code class="literal">@CacheEvict</code>: Used to remove stale data from the cache</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Caching</code>: Allows multiple nested <code class="literal">@Cacheable</code>, <code class="literal">@CachePut</code>, and <code class="literal">@CacheEvict</code> annotations to be used on the same method</li></ul></div></div><div class="section" title="JSR-107 Caching Annotations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>JSR-107 Caching Annotations</h2></div></div></div><p>
<span class="strong"><strong>JSR-107</strong></span> aims to standardize caching annotations. Listed here are some of the important <span class="strong"><strong>JSR-107</strong></span> annotations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@CacheResult</code>: Similar to <code class="literal">@Cacheable</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">@CacheRemove</code>: Similar to <code class="literal">@CacheEvict</code> <code class="literal">@CacheRemove</code> supports conditional eviction if an exception occurs</li><li class="listitem" style="list-style-type: disc"><code class="literal">@CacheRemoveAll</code>: Similar to <code class="literal">@CacheEvict(allEntries=true)</code>; used to remove all entries from the cache</li></ul></div><p>
<span class="strong"><strong>JSR-107</strong></span> and Spring's caching annotations are fairly similar in terms of the features they offer. Either of them is a good choice. We lean slightly toward <span class="strong"><strong>JSR-107</strong></span> because it's a standard. However, make sure you are not using both in the same project.</p><div class="section" title="Auto-Detection Order"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec41"/>Auto-Detection Order</h3></div></div></div><p>When caching is enabled, Spring Boot auto-configuration starts looking for a caching provider. The following list shows the order in which Spring Boot searches for caching providers. The list is in order of decreasing preference:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JCache (<span class="strong"><strong>JSR-107</strong></span>) (EhCache 3, Hazelcast, Infinispan, and so on)</li><li class="listitem" style="list-style-type: disc">EhCache 2.x</li><li class="listitem" style="list-style-type: disc">Hazelcast</li><li class="listitem" style="list-style-type: disc">Infinispan Couchbase</li><li class="listitem" style="list-style-type: disc">Redis</li><li class="listitem" style="list-style-type: disc">Caffeine</li><li class="listitem" style="list-style-type: disc">Guava</li><li class="listitem" style="list-style-type: disc">Simple</li></ul></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>Spring Boot makes developing Spring-based applications easy. It enables us to create production-ready applications very quickly.</p><p>In this lesson, we covered how to add features such as exception handling, caching, and internationalization to our application. We discussed the best practices of documenting REST services using Swagger. We looked at the basics of securing our microservice with Spring Security.</p><p>In the next lesson, we will shift our attention toward advanced features in Spring Boot. We will look at how to provide monitoring on top of our REST services, learn how to deploy the microservice to the Cloud, and understand how to become more productive when developing applications with Spring Boot.</p></div>
<div class="section" title="Assessments"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Assessments</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The _________ provides a number of annotations that can be used to validate beans.</li><li class="listitem">Which of the following is an annotated element size that must be within the specified boundaries?<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">@SizeOf</code></li><li class="listitem"><code class="literal">@SizeBoundary</code></li><li class="listitem"><code class="literal">@SizeTo</code></li><li class="listitem"><code class="literal">@Size</code></li></ol></div></li><li class="listitem">State whether True or False: HATEOAS is one of the key features of the REST application architecture.</li><li class="listitem">Which of the following is a simple builder class to configure the generation of Swagger documentation using the Swagger Spring MVC framework?<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Docket</li><li class="listitem">Swagger</li><li class="listitem">REST</li><li class="listitem">QAuth</li></ol></div></li><li class="listitem">Which of the following is a convenient annotation for OAuth 2 resource servers that enable a Spring Security filter which authenticates requests via an incoming OAuth 2 token?<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">@enableResourceServer</code></li><li class="listitem"><code class="literal">@enablesResourcesServer</code></li><li class="listitem"><code class="literal">@EnableResourceServer</code></li><li class="listitem"><code class="literal">@EnableResourceServers</code></li></ol></div></li></ol></div></div></body></html>