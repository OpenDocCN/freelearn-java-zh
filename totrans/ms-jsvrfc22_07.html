<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;JSF and AJAX"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. JSF and AJAX</h1></div></div></div><p>JSF and AJAX have been a great team for a long time. The potential of this combination has been heavily exploited by many JSF extensions (Ajax4Jsf, OmniFaces, PrimeFaces, RichFaces, ICEfaces, and so on) that provide many AJAX built-in components, extend AJAX default capabilities, increase AJAX security and reliability, and add more control to developers who need to manipulate the <span class="emphasis"><em>bowels</em></span> of AJAX mechanism.</p><p>By default, JSF contains a JavaScript library that encapsulates AJAX methods for dealing with AJAX requests or responses. This library can be loaded in the following two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">&lt;f:ajax&gt;</code> tag, the built-in AJAX library is loaded implicitly.</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">jsf.ajax.request()</code>, the AJAX library is loaded explicitly and developers have access to AJAX code. This approach is commonly used when the default AJAX behavior must be altered. It should be performed only by developers with high expertise, because modifying the default AJAX behavior may lead to undesirable issues and gaps.</li></ul></div><p>In this chapter, you will learn the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A brief overview of the JSF-AJAX lifecycle</li><li class="listitem" style="list-style-type: disc">A simple JSF-AJAX example</li><li class="listitem" style="list-style-type: disc">How the <code class="literal">execute</code>, <code class="literal">render</code>, <code class="literal">listener</code>, and <code class="literal">event</code> attributes work</li><li class="listitem" style="list-style-type: disc">Monitoring AJAX state on client</li><li class="listitem" style="list-style-type: disc">Monitoring AJAX errors on client</li><li class="listitem" style="list-style-type: disc">Grouping components under the <code class="literal">&lt;f:ajax&gt;</code> tag</li><li class="listitem" style="list-style-type: disc">Updating input fields with AJAX after a validation error</li><li class="listitem" style="list-style-type: disc">Mixing AJAX and flow scope</li><li class="listitem" style="list-style-type: disc">How postback and AJAX work together</li><li class="listitem" style="list-style-type: disc">How to determine whether a request is AJAX or non-AJAX</li><li class="listitem" style="list-style-type: disc">How AJAX and <code class="literal">&lt;f:param&gt;</code> work</li><li class="listitem" style="list-style-type: disc">Queue control for AJAX requests</li><li class="listitem" style="list-style-type: disc">How <code class="literal">jsf.js</code> can be loaded explicitly</li><li class="listitem" style="list-style-type: disc">How to write an AJAX progress bar / indicator</li></ul></div><div class="section" title="A brief overview of the JSF-AJAX lifecycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>A brief overview of the JSF-AJAX lifecycle</h1></div></div></div><p>AJAX's request-response cycle is characterized by <span class="strong"><strong>partial processing</strong></span><a id="id907" class="indexterm"/> and <span class="strong"><strong>partial rendering</strong></span> stages; this<a id="id908" class="indexterm"/> means that AJAX partially affects the current view. As such, requests are not typical JSF requests, they follow a different lifecycle dictated by the <code class="literal">javax.faces.context.PartialViewContext</code> class. The methods of this class know how to deal <a id="id909" class="indexterm"/>with AJAX requests, which means that they are responsible for solving partial processing and rendering of the component tree.</p><p>The kernel of an AJAX request is represented by two attributes of the <code class="literal">&lt;f:ajax&gt;</code> tag: <code class="literal">execute</code> and <code class="literal">render</code>. The <code class="literal">execute</code> attribute<a id="id910" class="indexterm"/> indicates the components that should be processed on the server (partial processing), while the <code class="literal">render</code> attribute<a id="id911" class="indexterm"/> indicates the components that should be rendered (or re-rendered) on the client (partial rendering).</p><p>In the upcoming sections, you will see many examples of how these attributes works.</p></div></div>
<div class="section" title="A simple JSF-AJAX example to get started"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>A simple JSF-AJAX example to get started</h1></div></div></div><p>The simplest JSF-AJAX example<a id="id912" class="indexterm"/> can be written in a matter of a few seconds. Let's consider a JSF form with an input text and a button that sends the user input to the server. The user input (a string) is converted by the server to uppercase and is displayed to the user in an output text component. Next, you can ajaxify this scenario as shown in the following example code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText id="nameInputId" value="#{ajaxBean.name}"/&gt;
  &lt;h:commandButton value="Send" action="#{ajaxBean.ajaxAction()}"&gt;
    <span class="strong"><strong>&lt;f:ajax/&gt;</strong></span>
  &lt;/h:commandButton&gt;
  &lt;h:outputText id="nameOutputId" value="#{ajaxBean.name}"/&gt;
&lt;/h:form&gt;</pre></div><p>The presence of the <code class="literal">&lt;f:ajax&gt;</code> tag is sufficient to transform this request into an AJAX request. Well, it is true that this request is not very useful because we did not specify which components should be executed and what components should be re-rendered. But the good part is that you will not receive any errors; JSF will use the default values for the <code class="literal">execute</code> and <code class="literal">render</code> attributes, which ask JSF to process the element that triggered the request and to re-render nothing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note137"/>Note</h3><p>When the <code class="literal">execute</code> or <code class="literal">render</code> attribute is missing, JSF will process the element that triggered the request and re-render nothing.</p></div></div><p>Adding the <code class="literal">execute</code> attribute with the value of the <code class="literal">inputText</code> ID (<code class="literal">nameInputId</code>) tag will tell JSF to pass to the server the user input. This means that the user input will be available in the <code class="literal">ajaxAction</code> method and will be converted to uppercase. You can check the effect of this method in the<a id="id913" class="indexterm"/> application server log because it is not visible on the client side, since the <code class="literal">render</code> attribute still defaults to nothing. Therefore, you need to add the <code class="literal">render</code> attribute and indicate the IDs of the components that should be re-rendered; in this case, the output text with the ID <code class="literal">nameOutputId</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText id="nameInputId" value="#{ajaxBean.name}"/&gt;
  &lt;h:commandButton value="Send" action="#{ajaxBean.ajaxAction()}"&gt;
    <span class="strong"><strong>&lt;f:ajax execute ="nameInputId" render="nameOutputId"/&gt;</strong></span>
  &lt;/h:commandButton&gt;
  &lt;h:outputText id="nameOutputId" value="#{ajaxBean.name}"/&gt;
&lt;/h:form&gt;</pre></div><p>Done! This is a simple and functional AJAX application. You can find the complete code in the code bundle of this chapter, named <code class="literal">ch7_1</code>.</p></div>
<div class="section" title="The JSF-AJAX attributes"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>The JSF-AJAX attributes</h1></div></div></div><p>In this section, you will see what the main attributes supported by <code class="literal">&lt;f:ajax&gt;</code> are. We start with <code class="literal">execute</code> and <code class="literal">render</code>, continue with <code class="literal">listener</code> and <code class="literal">event</code>, and finish with <code class="literal">onevent</code> and <code class="literal">onerror</code>.</p><div class="section" title="The execute and render attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec74"/>The execute and render attributes</h2></div></div></div><p>In the previous example, the <code class="literal">execute</code> and <code class="literal">render</code> attributes affect a single component indicated by its ID. When multiple <a id="id914" class="indexterm"/>components are affected, we can <a id="id915" class="indexterm"/>specify a list of IDs separated<a id="id916" class="indexterm"/> by space, or we can use the following keywords:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@form</code>: This keyword<a id="id917" class="indexterm"/> refers to all component IDs<a id="id918" class="indexterm"/> in the form that contains the AJAX component. If it <a id="id919" class="indexterm"/>is present in the <code class="literal">execute</code> attribute, then the entire <code class="literal">&lt;h:form&gt;</code> is submitted and processed. In case of the <code class="literal">render</code> attribute, the entire <code class="literal">&lt;h:form&gt;</code> is rendered.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@this</code>: This keyword <a id="id920" class="indexterm"/>refers to the ID of the element that triggers the request (default when <code class="literal">execute</code> is missing). For the <code class="literal">execute</code> attribute, <code class="literal">@this</code> will submit and<a id="id921" class="indexterm"/> process only the component that <a id="id922" class="indexterm"/>contains the AJAX component, while for the <code class="literal">render</code> attribute, it will render only the component that contains the AJAX component.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@none</code>: No component<a id="id923" class="indexterm"/> will be processed/re-rendered. But for the <code class="literal">execute</code> attribute, JSF will still execute the lifecycle, including<a id="id924" class="indexterm"/> its phase listeners; while<a id="id925" class="indexterm"/> for the <code class="literal">render</code> attribute, JSF will perform the <span class="emphasis"><em>Render Response</em></span> phase, including firing any <code class="literal">preRenderView</code> events. This is the default value for the <code class="literal">render</code> attribute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@all</code>: This keyword<a id="id926" class="indexterm"/> represents all components IDs. For <code class="literal">execute</code>, all components<a id="id927" class="indexterm"/> in a page are submitted and processed—like a<a id="id928" class="indexterm"/> full page submit. For the <code class="literal">render</code> attribute, JSF will render all components in the page; this will update the page, but will allow preserving some client-side states outside the JSF.</li></ul></div><p>Depending on the<a id="id929" class="indexterm"/> application's needs, these <a id="id930" class="indexterm"/>keywords and component IDs can be mixed to obtain cool AJAX requests. For example, go through the<a id="id931" class="indexterm"/> following AJAX requests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Process and re-render the current form using the following code:<div class="informalexample"><pre class="programlisting">&lt;f:ajax execute="@form" render="@form"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Process form, re-render none, as follows:<div class="informalexample"><pre class="programlisting">&lt;f:ajax execute="@form" render="@none"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Process the element that triggers the request and re-renders the form, as follows:<div class="informalexample"><pre class="programlisting">&lt;f:ajax execute="@this" render="@form"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Process the form and re-render all as follows:<div class="informalexample"><pre class="programlisting">&lt;f:ajax execute="@form" render="@all"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Process the form and re-render the components with IDs <code class="literal">nameInputId phoneInputId</code> inside the form as follows:<div class="informalexample"><pre class="programlisting">&lt;f:ajax execute="@form" render="nameInputId phoneInputId"/&gt;</pre></div></li></ul></div><p>We can continue with many other examples, but I think you got the idea.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note138"/>Note</h3><p>The keywords (<code class="literal">@form</code>, <code class="literal">@this</code>, <code class="literal">@all</code>, and <code class="literal">@none</code>) and component IDs can be mixed in the same value of the <code class="literal">render</code> and <code class="literal">execute</code> attribute. Don't forget to separate them with spaces.</p></div></div><p>The complete application can be seen in the code bundle of this chapter, and is named as <code class="literal">ch7_2</code>.</p><p>A special case consists in re-rendering components outside the form that contains the AJAX element that triggers the request. Take a look at the following example:</p><div class="informalexample"><pre class="programlisting">&lt;h:message id="msgId" showDetail="true" showSummary="true"
                      for="nameId" style="color: red;"/&gt;      
&lt;h:form&gt;                                  
 &lt;h:inputText id="nameId" value="#{ajaxBean.name}" 
                          validator="nameValidator"/&gt;
 &lt;h:commandButton value="Submit"&gt;
  <span class="strong"><strong>&lt;f:ajax execute="@form" listener="#{ajaxBean.upperCaseName()}"</strong></span> 
          <span class="strong"><strong>render="@form :msgId :trackRequestId:trackId"/&gt;</strong></span>
 &lt;/h:commandButton&gt;           
&lt;/h:form&gt; 
&lt;h:form id="trackRequestId"&gt;
 Request number: &lt;h:outputText id="trackId" value="#{ajaxBean.request}"/&gt;
&lt;/h:form&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note139"/>Note</h3><p>Use the <code class="literal">:</code> notation for updating components outside the form, which contains the element that triggers the AJAX request. This notation represents the default separator returned by the <code class="literal">UINamingContainer.getSeparatorChar</code> method. This can be specified via the <code class="literal">javax.faces.SEPARATOR_CHAR</code> context parameter.</p></div></div><p>The complete application can be found<a id="id932" class="indexterm"/> in the code bundle<a id="id933" class="indexterm"/> of this chapter, and is named <code class="literal">ch7_3</code>.</p></div><div class="section" title="The listener attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec75"/>The listener attribute</h2></div></div></div><p>Another<a id="id934" class="indexterm"/> important attribute of <code class="literal">&lt;f:ajax&gt;</code> is named <code class="literal">listener</code>. This attribute indicates a server-side method<a id="id935" class="indexterm"/> that should be executed when an AJAX request is fired by a client action. For example, you can do this using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText value="#{ajaxBean.name}"/&gt;
  &lt;h:commandButton value="Send" action="#{ajaxBean.upperCaseName()}"&gt;
  &lt;f:ajax execute="@form" render="@form"/&gt;
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p>Well, using the <code class="literal">listener</code> attribute <a id="id936" class="indexterm"/>you can transform the preceding code into the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText value="#{ajaxBean.name}"/&gt;
  &lt;h:commandButton value="Send"&gt;
    &lt;f:ajax listener="#{ajaxBean.upperCaseName()}" 
          execute="@form" render="@form"/&gt;          
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p>An obvious question arises<a id="id937" class="indexterm"/> here. What is the difference between these two and why should I use <code class="literal">listener</code> and not <code class="literal">action</code>? Well, there are a few differences between these two, and the following are the most important ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A server-side method called through the <code class="literal">action</code> attribute can return <code class="literal">String</code> representing a navigation<a id="id938" class="indexterm"/> case (outcome), while a server-side method called through <code class="literal">listener</code> cannot provide a navigation case.</li><li class="listitem" style="list-style-type: disc">If the client disables JavaScript in the browser configuration, the <code class="literal">listener</code> attribute will not work anymore—the server-side method will not be called. The <code class="literal">action</code> attribute still works.</li><li class="listitem" style="list-style-type: disc">Components that do not support the <code class="literal">action</code> attribute can use <code class="literal">listener</code> instead.</li><li class="listitem" style="list-style-type: disc">The server-side method called through the <code class="literal">listener</code> attribute accepts an argument of type <code class="literal">AjaxBehaviorEvent</code>, which represents the component behavior specific to AJAX. This is not accepted in case of the <code class="literal">action</code> attribute. For example, refer to the following code:<div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText value="#{ajaxBean.name}"/&gt;
  &lt;h:commandButton value="Send"&gt;
    &lt;f:ajax listener="#{ajaxBean.upperCaseName}" 
          execute="@form" render="@form"/&gt;          
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;
...

public void upperCaseName(AjaxBehaviorEvent event){         
...
}</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note140"/>Note</h3><p>Remember that the client behavior (the <code class="literal">ClientBehavior</code> interface) is responsible for generating reusable JavaScript code that can be added to JSF components. The AJAX (<code class="literal">&lt;f:ajax&gt;</code>) is a client-side behavior, which means it is always attached as a behavior to another UI component(s). You can find more details about <code class="literal">ClientBehavior</code> in the <span class="emphasis"><em>Working with client behavior functionality</em></span> section in <a class="link" href="ch05.html" title="Chapter 5. JSF Configurations Using XML Files and Annotations – Part 2">Chapter 5</a>, <span class="emphasis"><em>JSF Configurations Using XML Files and Annotations – Part 2</em></span>.</p></div></div><p>The complete application<a id="id939" class="indexterm"/> can be found in the code bundle<a id="id940" class="indexterm"/> of this chapter, and is named <code class="literal">ch7_4</code>.</p></div><div class="section" title="The event attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec76"/>The event attribute</h2></div></div></div><p>Each AJAX request is <a id="id941" class="indexterm"/>fired by an event indicating a user or programmatic action. JSF defines default events based <a id="id942" class="indexterm"/>on the parent components; according to documentation "The default event is <code class="literal">action</code> for <code class="literal">ActionSource</code> components such as <code class="literal">&lt;h:commandButton&gt;</code>, and <code class="literal">valueChange</code> for <code class="literal">EditableValueHolder</code> components such as <code class="literal">&lt;h:inputText&gt;</code>". Most of the time, the default events are exactly what you need, but in case that you want to explicitly set an event for a component, you can use the <code class="literal">event</code> attribute. Some of the most common values<a id="id943" class="indexterm"/> for this attribute are <code class="literal">click</code>, <code class="literal">focus</code>, <code class="literal">blur</code>, <code class="literal">keyup</code>, and <code class="literal">mouseover</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note141"/>Note</h3><p>Do not confuse these events with JavaScript events, which are prefixed with the <code class="literal">on</code> notation (<code class="literal">onclick</code>, <code class="literal">onkeyup</code>, <code class="literal">onblur</code>, and so on). The JavaScript events are <span class="emphasis"><em>behind</em></span> AJAX events; or, with other words, AJAX events are based on JavaScript events. For example, AJAX <code class="literal">click</code> event is based on the <code class="literal">onclick</code> JavaScript event.</p></div></div><p>In the following code, the event<a id="id944" class="indexterm"/> that triggers the AJAX action is <code class="literal">keyup</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText value="#{ajaxBean.name}"&gt;
  &lt;f:ajax event="keyup" listener="#{ajaxBean.upperCaseName()}" render="@this"/&gt;
  &lt;/h:inputText&gt;            
&lt;/h:form&gt;  </pre></div><p>The complete application can be found in the code bundle of this chapter, and is named <code class="literal">ch7_5</code>.</p></div><div class="section" title="The onevent attribute – monitoring AJAX state on client"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec77"/>The onevent attribute – monitoring AJAX state on client</h2></div></div></div><p>During an<a id="id945" class="indexterm"/> AJAX request, JSF is capable of calling a client-defined JavaScript method <a id="id946" class="indexterm"/>and passing an object named <code class="literal">data</code> to it, containing information about<a id="id947" class="indexterm"/> the current state of the request. The JavaScript function is called <a id="id948" class="indexterm"/>when the request begins, completes, and succeeds.</p><p>The <code class="literal">data</code> objects encapsulate the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">type</code>: This <a id="id949" class="indexterm"/>property gives the type of the AJAX <a id="id950" class="indexterm"/>call, <code class="literal">event</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: This<a id="id951" class="indexterm"/> property <a id="id952" class="indexterm"/>returns the <code class="literal">begin</code>, <code class="literal">complete</code>, or <code class="literal">success</code> status (can be used to implement an indeterminate progress bar).<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note142"/>Note</h3><p>When the <code class="literal">status</code> property has the value <code class="literal">begin</code>, which means that the AJAX request has not been sent yet. When it equals <code class="literal">complete</code>, it means that the AJAX response has successfully reached to the client, but it hasn't been processed yet. If the received response is successfully processed (without errors), the <code class="literal">status</code> value becomes <code class="literal">success</code>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">source</code>: This property <a id="id953" class="indexterm"/>returns the DOM element representing the source<a id="id954" class="indexterm"/> of the AJAX event</li><li class="listitem" style="list-style-type: disc"><code class="literal">responseXML</code>: This is<a id="id955" class="indexterm"/> the AJAX response<a id="id956" class="indexterm"/> in XML format</li><li class="listitem" style="list-style-type: disc"><code class="literal">responseText</code>: This<a id="id957" class="indexterm"/> is the AJAX response<a id="id958" class="indexterm"/> in text format</li><li class="listitem" style="list-style-type: disc"><code class="literal">responseCode</code>: This is<a id="id959" class="indexterm"/> the AJAX<a id="id960" class="indexterm"/> response code</li></ul></div><p>You need to indicate the name of the JavaScript method through the <code class="literal">onevent</code> attribute (in <code class="literal">jsf.js</code>, the JavaScript method representing implementation of this attribute is named <code class="literal">addOnEvent</code>(callback)):</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Submit"&gt;
  &lt;f:ajax <span class="strong"><strong>onevent="ajaxMonitoring"</strong></span> execute="@form"
         listener="#{ajaxBean.upperCaseName()}" render="@form"/&gt;
&lt;/h:commandButton&gt;  </pre></div><p>Next, the <code class="literal">ajaxMonitoring</code> function<a id="id961" class="indexterm"/> can use the <code class="literal">data</code> object and its properties to accomplish <a id="id962" class="indexterm"/>different client-side tasks. For example, the following implementation feeds up some <code class="literal">div</code> tags with details<a id="id963" class="indexterm"/> about the AJAX request:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
  function ajaxMonitoring(data) {              
    document.getElementById("statusId").innerHTML += data.status + " | ";
    document.getElementById("responseCodeId").innerHTML += 
    status.responseCode + "| ";
    if(data.status === "complete") {
      document.getElementById("typeId").innerHTML += data.type;
      document.getElementById("sourceId").innerHTML += data.source;
  ...
&lt;/script&gt;</pre></div><p>In the<a id="id964" class="indexterm"/> following figure, you can see a possible output:</p><div class="mediaobject"><img src="graphics/6466EN_07_01.jpg" alt="The onevent attribute – monitoring AJAX state on client"/></div><p>The<a id="id965" class="indexterm"/> complete application<a id="id966" class="indexterm"/> can be found in the code bundle of this chapter, and is named <code class="literal">ch7_21</code>.</p></div><div class="section" title="The onerror attribute – monitoring AJAX errors on client"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec78"/>The onerror attribute – monitoring AJAX errors on client</h2></div></div></div><p>In the preceding section, you saw how to<a id="id967" class="indexterm"/> monitor the state of AJAX requests using a client-defined JavaScript function and the <code class="literal">data</code> object. Based on the same technique, we can obtain information<a id="id968" class="indexterm"/> about the possible errors that can occur during AJAX requests. The passed <code class="literal">data</code> object encapsulates the following properties (notice that this is the same <code class="literal">data</code> object from the preceding section; therefore you still have access to those properties): <code class="literal">description</code>, <code class="literal">errorName</code>, and <code class="literal">errorMessage</code>.</p><p>The <code class="literal">data.type</code> property will be <code class="literal">error</code> and the <code class="literal">data.status</code> property will be one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">serverError</code>: This<a id="id969" class="indexterm"/> is the response of the AJAX request that contains an error</li><li class="listitem" style="list-style-type: disc"><code class="literal">malformedXML</code>: This <a id="id970" class="indexterm"/>is an XML well-formed error</li><li class="listitem" style="list-style-type: disc"><code class="literal">httpError</code>: This is<a id="id971" class="indexterm"/> a valid HTTP error</li><li class="listitem" style="list-style-type: disc"><code class="literal">emptyResponse</code>: This is a server-side code<a id="id972" class="indexterm"/> that did not provide a response</li></ul></div><p>The name of the JavaScript method is indicated through the <code class="literal">onerror</code> attribute (in <code class="literal">jsf.js</code>, the JavaScript method representing implementation of this attribute is named <code class="literal">addOnError</code> (callback)). So at this point, we can update the application from the previous<a id="id973" class="indexterm"/> section to report errors on the client as well, as shown in the following code (note that <code class="literal">onevent</code> and <code class="literal">onerror</code> calls the same method, <code class="literal">ajaxMonitoring</code>; however this is not mandatory as you can use separate JavaScript methods as well):</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
  function ajaxMonitoring(data) {
    document.getElementById("statusId").innerHTML += data.status + " | ";
    if(data.status === "serverError" || data.status === "malformedXML" || 
      data.status === "httpError" || data.status === "emptyResponse"){
      document.getElementById("descriptionId").innerHTML += 
        data.description;
      document.getElementById("errorNameId").innerHTML += data.errorName;
      document.getElementById("errorMessageId").innerHTML += 
        data.errorMessage;
  }
  document.getElementById("responseCodeId").innerHTML += 
       status.responseCode + "| ";
  if (data.status === "complete") {
      document.getElementById("typeId").innerHTML += data.type;
      document.getElementById("sourceId").innerHTML += data.source + 
      "&lt;br/&gt;&lt;xmp&gt;" + new XMLSerializer().serializeToString(data.source) + 
      "&lt;/xmp&gt;";
      document.getElementById("responseXMLId").innerHTML += 
      data.responseXML + "&lt;br/&gt;&lt;xmp&gt;" + new 
      XMLSerializer().serializeToString(data.responseXML) + "&lt;/xmp&gt;";
      document.getElementById("responseTextId").innerHTML += "&lt;xmp&gt;" + 
      data.responseText + "&lt;/xmp&gt;";
  }
 }
&lt;/script&gt;</pre></div><p>Now, you can test <a id="id974" class="indexterm"/>this code by adding an intentional error, such as calling nonexistent server-side method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Submit"&gt;
  &lt;f:ajax onevent ="ajaxMonitoring" <span class="strong"><strong>onerror="ajaxMonitoring"</strong></span> 
         execute="@form" listener="#{ajaxBean.unexistedMethod()}" 
         render="@form"/&gt;
&lt;/h:commandButton&gt;</pre></div><p>A possible output is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_07_02.jpg" alt="The onerror attribute – monitoring AJAX errors on client"/></div><p>The complete application<a id="id975" class="indexterm"/> can be found in code bundle<a id="id976" class="indexterm"/> of this chapter, and is named <code class="literal">ch7_6</code>.</p></div></div>
<div class="section" title="Grouping components under &lt;f:ajax&gt; tag"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Grouping components under &lt;f:ajax&gt; tag</h1></div></div></div><p>Sometimes, it<a id="id977" class="indexterm"/> may be useful to group multiple <a id="id978" class="indexterm"/>components under the same <code class="literal">&lt;f:ajax&gt;</code> tag. For example, the following code snippet groups two <code class="literal">&lt;h:inputText&gt;</code> components under the <a id="id979" class="indexterm"/>same <code class="literal">&lt;f:ajax&gt;</code> tag (you can nest other components as well):</p><div class="informalexample"><pre class="programlisting">&lt;f:ajax event="click" execute="submitFormId" render="submitFormId"&gt;
  &lt;h:form id="submitFormId"&gt; 
    Name:
    &lt;h:inputText id="nameId" value="#{ajaxBean.name}" 
                           validator="nameValidator"/&gt;
    &lt;h:message id="msgNameId" showDetail="true" showSummary="true" 
                           for="nameId" style="color: red;"/&gt;
    Surname:            
    &lt;h:inputText id="surnameId" value="#{ajaxBean.surname}" 
                           validator="nameValidator"/&gt;
    &lt;h:message id="msgSurnameId" showDetail="true" showSummary="true"   
                           for="surnameId" style="color: red;"/&gt;
    &lt;/h:form&gt;
&lt;/f:ajax&gt;</pre></div><p>So, how does it work? When you click either of the input components, an AJAX request is fired for the input component and one for the form (two requests in our example) and all the components in the form are re-rendered. Since the <code class="literal">click</code> event will generate AJAX requests/responses, you will not be able to enter keys in those <code class="literal">&lt;h:inputText&gt;</code> unless you are using the <span class="emphasis"><em>Tab</em></span> key to gain focus in each <code class="literal">&lt;h:inputText&gt;</code> component.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note143"/>Note</h3><p>The components grouped under <code class="literal">&lt;f:ajax&gt;</code> can still use inner (or locally used) <code class="literal">&lt;f:ajax&gt;</code> tags. In this case, the effect is cumulative. Of course, you have to be extra careful when you use this technique, because undesired behaviors may occur.</p></div></div><p>The complete application can be found in the code bundle of this chapter, and is named <code class="literal">ch7_7</code>.</p></div>
<div class="section" title="Updating input fields with AJAX after validation error"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Updating input fields with AJAX after validation error</h1></div></div></div><p>Updating input fields with AJAX after validation<a id="id980" class="indexterm"/> error is a very old, well-known, and annoying issue for JSF developers. When an AJAX request fails in the validation phase, there is no built-in way to update the input fields with some valid values because JSF does not allow access to the model value<a id="id981" class="indexterm"/> after a validation error (usually, you want to clear up those fields or provide some default values, or even some old values provided by the same user). Of course, JSF developers found different workarounds, or used other libraries, such as PrimeFaces or OmniFaces, but a JSF solution was required.</p><p>Starting with JSF 2.2, all components that should be re-rendered (components indicated in the <code class="literal">render</code> attribute) will be reset if we set the <code class="literal">resetValues</code> attribute to <code class="literal">true</code>. The easiest way to understand this is to proceed with a comparison test. First, let's use an AJAX request without <code class="literal">resetValues</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt; 
  &lt;h:message id="msgId" showDetail="true" showSummary="true" for="nameId" style="color: red;"/&gt;
  &lt;h:inputText id="nameId" value="#{ajaxBean.name}" 
                          validator="nameValidator"/&gt;
  &lt;h:commandButton value="Submit"&gt;
    &lt;f:ajax execute="@form" resetValues="false" 
      listener="#{ajaxBean.upperCaseName()}" render="nameId msgId"/&gt;
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p>Let's suppose that a valid value for our input field is an alphanumeric string (with respect to the [^a-zA-Z0-9] pattern). In the following screenshot, on the left-hand side, you can see the AJAX result after inserting a valid value, and on the right-hand side, you can see the AJAX result after inserting an invalid value:</p><div class="mediaobject"><img src="graphics/6466EN_07_03.jpg" alt="Updating input fields with AJAX after validation error"/></div><p>As you can see in the preceding screenshot, on the right-hand side, the invalid value was not reset. The invalid value retains and is very annoying.</p><p>Next, we proceed with the same case, but we<a id="id982" class="indexterm"/> add the <code class="literal">resetValues</code> attribute:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;                      
  &lt;h:message id="msgId" showDetail="true" showSummary="true" for="nameId"
  style="color: red;"/&gt;            
  &lt;h:inputText id="nameId" value="#{ajaxBean.name}" 
                          validator="nameValidator"/&gt;
  &lt;h:commandButton value="Submit"&gt;
    &lt;f:ajax execute="@form" <span class="strong"><strong>resetValues="true"</strong></span> 
       listener="#{ajaxBean.upperCaseName()}" render="nameId msgId"/&gt;
  &lt;/h:commandButton&gt;            
&lt;/h:form&gt;</pre></div><p>Now, we repeat the test. In<a id="id983" class="indexterm"/> the following screenshot, on <a id="id984" class="indexterm"/>the left-hand side, the submitted value is valid, while on the right-hand side, it is invalid:</p><div class="mediaobject"><img src="graphics/6466EN_07_04.jpg" alt="Updating input fields with AJAX after validation error"/></div><p>Now, when the submitted value was invalid, the input field was reset (in this case, cleared).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note144"/>Note</h3><p>From this example, you may misunderstand that <code class="literal">resetValues</code> works as a clear (empty) field's action. Well, it does not! When an input field is reset, the valid value that replaces the invalid one is related to the managed bean (the renderer will pick up the value from the bean). If the managed bean is in the request scope, the replacer (valid value) will be the one used for initialization of corresponding property (which may be anything, not just an empty string). But, if the managed bean is in view scope, then the replacer will be the currently valid value of the corresponding property, which may be the initialization value, or the previous valid value inserted by the user (of course, altered or not altered in a server-side method).</p></div></div><p>Keep this note in mind while testing the complete<a id="id985" class="indexterm"/> application available in the code bundle of this chapter, named <code class="literal">ch7_8_1</code>. By default, this application comes with a request scoped managed bean, but you can easily transform it into a view scoped for more tests.</p><p>Besides the <code class="literal">resetValues</code> attribute<a id="id986" class="indexterm"/> for AJAX requests, JSF 2.2 comes <a id="id987" class="indexterm"/>with a tag, named <code class="literal">&lt;f:resetValues&gt;</code>, for non-AJAX requests. Basically, this is an action listener that can be easily attached to any <code class="literal">ActionSource</code> instance (for example, <code class="literal">&lt;h:commandButton&gt;</code>). The effect will <a id="id988" class="indexterm"/>consist of resetting all components that are given in its <code class="literal">render</code> attribute (use only component IDs, not keywords such as <code class="literal">@form</code>, <code class="literal">@all</code>, and so on):</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Submit" action="#{nonAjaxBean.upperCaseName()}"&gt;
  &lt;f:resetValues render="nameId" /&gt;
&lt;/h:commandButton&gt;</pre></div><p>The complete application can be found in the code bundle of this chapter, and is named <code class="literal">ch7_8_2</code>. This tag is not recognized in all JSF 2.2 (Mojarra and MyFaces) versions, therefore you have to test it in order to be sure that you can use it.</p><div class="section" title="The Cancel and Clear buttons"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec79"/>The Cancel and Clear buttons</h2></div></div></div><p>Buttons of type<a id="id989" class="indexterm"/> <span class="strong"><strong>Cancel</strong></span> (which resets the form's fields to the initial state or to the most recent valid state) and <a id="id990" class="indexterm"/>
<span class="strong"><strong>Clear</strong></span> (which clears up the form's fields) are not very popular in web applications, but <a id="id991" class="indexterm"/>sometimes they can be useful to end users. When implementing the <span class="strong"><strong>Cancel</strong></span>/<span class="strong"><strong>Clear</strong></span> buttons, you need to find a way to skip the <span class="emphasis"><em>Process Validation</em></span> phase<a id="id992" class="indexterm"/> (which is needed for the <span class="strong"><strong>Submit</strong></span> button). The motivation is simple: when a user cancels/clears a form's values, we certainly don't need valid values in order to accomplish these tasks; therefore, no validation is needed.</p><p>In non-AJAX requests, a common technique consists of using the <code class="literal">immediate="true"</code> attribute, which, for command components (for example, <code class="literal">&lt;h:commandButton&gt;</code>), will transfer the invocation of action in <a id="id993" class="indexterm"/>
<span class="emphasis"><em>Apply Request Values</em></span> phase. This attribute is available for AJAX requests as well, but AJAX provides a better solution for these kinds of tasks. Instead of using <code class="literal">immediate="true"</code>, we can use the <code class="literal">@this</code> keyword. Furthermore, we can use the <code class="literal">resetValues</code> feature to simplify and fortify the <span class="strong"><strong>Cancel</strong></span>/<span class="strong"><strong>Clear</strong></span> buttons.</p><p>Now, let's look at some scenarios. We will keep things simple, therefore we need a form with a single input field and three buttons: <span class="strong"><strong>Submit</strong></span>, <span class="strong"><strong>Cancel</strong></span>, and <span class="strong"><strong>Clear</strong></span>. The validator will allow only<a id="id994" class="indexterm"/> alphanumeric characters (with respect to the <code class="literal">[^a-zA-Z0-9]</code> pattern).</p><div class="section" title="Value submitted to a view scoped managed bean"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec02"/>Value submitted to a view scoped managed bean</h3></div></div></div><p>In this case, run the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;                      
  &lt;h:message id="msgId" showDetail="true" showSummary="true" for="nameId" style="color: red;"/&gt;
  &lt;h:inputText id="nameId" value="#{ajaxBean.name}" 
                          validator="nameValidator"/&gt;
  &lt;h:commandButton value="Submit"&gt;
    &lt;f:ajax execute="@form" resetValues="true" 
       listener="#{ajaxBean.upperCaseName()}" render="nameId msgId"/&gt;
  &lt;/h:commandButton&gt;
  &lt;h:commandButton value="Cancel"&gt;
    &lt;f:ajax execute="@this" render="@form"/&gt;
  &lt;/h:commandButton&gt;  
  &lt;h:commandButton value="Clear"&gt;
    &lt;f:ajax execute="@this" render="@form" 
                          listener="#{ajaxBean.cancelName()}"/&gt;
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p>Press the <span class="strong"><strong>Submit</strong></span> button. In case<a id="id995" class="indexterm"/> of an invalid value, you will see a specific error message (<code class="literal">&lt;h:message&gt;</code>), and <code class="literal">resetValues</code> will reset the input field to the initial value (empty string or some suggestion) or the most recent valid value.</p><p>Press the <span class="strong"><strong>Cancel</strong></span> button. Since<a id="id996" class="indexterm"/> we are using <code class="literal">execute="@this"</code>, the input field will not be processed on the server; therefore no validation happens. The re-render process will have the same effect as <code class="literal">resetValues</code> for the input field, but will clear the <code class="literal">&lt;h:message&gt;</code> tag as well.</p><p>Press the <span class="strong"><strong>Clear</strong></span> button. This<a id="id997" class="indexterm"/> button uses <code class="literal">execute="@this"</code>, too. But, instead of resetting the input field to <code class="literal">resetValues</code>, it clears up the input field and <code class="literal">&lt;h:message&gt;</code>. For this, an additional method is needed in the managed bean as follows:</p><div class="informalexample"><pre class="programlisting">private String name = "RafaelNadal";
...
public void cancelName() {
  name = "";
}</pre></div><p>The complete application can be found in the code bundle of this chapter, which is named <code class="literal">ch7_9_1</code>.</p><p>As a simple<a id="id998" class="indexterm"/> tip and trick, for the <span class="strong"><strong>Clear</strong></span> button<a id="id999" class="indexterm"/> you may want to use a place holder as follows:</p><div class="informalexample"><pre class="programlisting">
...
&lt;h:inputText id="nameId" value="#{ajaxBean.name}" 
  validator="nameValidator"  f5:placeholder="Enter your name ..."/&gt;</pre></div></div><div class="section" title="Value submitted to a request scoped managed bean"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec03"/>Value submitted to a request scoped managed bean</h3></div></div></div><p>Since the submitted value is <a id="id1000" class="indexterm"/>not persisted across multiple AJAX requests, the <code class="literal">resetValues</code> method and the <span class="strong"><strong>Cancel</strong></span> button will reset<a id="id1001" class="indexterm"/> the input field to the initialization value (empty string or suggestion). The <span class="strong"><strong>Cancel</strong></span> button will also reset the <code class="literal">&lt;h:message&gt;</code> tag. The <span class="strong"><strong>Clear</strong></span> button will clear up input text and <code class="literal">&lt;h:message&gt;</code>. Of course, under some circumstances (such as using an empty string for initialization), the <span class="strong"><strong>Cancel</strong></span> and <span class="strong"><strong>Clear</strong></span> buttons will<a id="id1002" class="indexterm"/> do the same thing; therefore, you can drop one of them.</p><p>The complete application can be seen in the code bundle of this chapter, and is named <code class="literal">ch7_9_2</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note145"/>Note</h3><p>More examples of how to use <code class="literal">resetValues</code> and implement the <span class="strong"><strong>Cancel</strong></span> and <span class="strong"><strong>Clear</strong></span> buttons can be found in the source code that accompanies this book. A set of examples using the <code class="literal">keyup</code> event in an input field with cancel/clear facilities contain the following applications: <code class="literal">ch7_9_3</code>, <code class="literal">ch7_9_4</code>, <code class="literal">ch7_9_5</code>, and <code class="literal">ch7_9_6</code>.</p></div></div><p>Everything seems to work pretty straightforward, but there is an issue that we have to fix. Let's take a closer look at the following code (there is nothing tricky in it):</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  Name:
  &lt;h:inputText id="nameId" value="#{ajaxBean.name}" 
                          validator="nameValidator"/&gt;
  &lt;h:message id="msgNameId" showDetail="true" showSummary="true" 
                          for="nameId" style="color: red;"/&gt;
  Surname:            
  &lt;h:inputText id="surnameId" value="#{ajaxBean.surname}" 
                          validator="nameValidator"/&gt;
  &lt;h:message id="msgSurnameId" showDetail="true" showSummary="true" 
                          for="surnameId" style="color: red;"/&gt; ..
        
  &lt;h:commandButton value="Submit"&gt;
    &lt;f:ajax execute="@form" 
      listener="#{ajaxBean.upperCaseNameAndSurname()}" 
      render="@form"/&gt;
  &lt;/h:commandButton&gt;
  &lt;h:commandButton value="Cancel"&gt;
    &lt;f:ajax execute="@this" render="@form"/&gt;
  &lt;/h:commandButton&gt;  
  &lt;h:commandButton value="Clear/Reset"&gt;
    &lt;f:ajax execute="@this" render="@form" 
          listener="#{ajaxBean.cancelNameAndSurname()}"/&gt;         
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p>Let's focus on the submit process. When we submit a valid name and surname, the form is re-rendered and everything looks as expected, but if one value (or both) is invalid, then the input fields are<a id="id1003" class="indexterm"/> not reset and the corresponding error messages appear. This is normal since the <code class="literal">resetValues</code> method is not present; therefore, the first thought would be to add <code class="literal">resetValues="true"</code> to <code class="literal">&lt;f:ajax&gt;</code> that corresponds to the <span class="strong"><strong>Submit</strong></span> button. However, this will not work as expected, because nothing happens in case of invalid values. While<a id="id1004" class="indexterm"/> you may think that the input fields will be reset for invalid values, you will be surprised to see that everything remains unchanged and the invalid values are still there after re-render. The cause seems to be the presence of <code class="literal">@form</code> in the <code class="literal">render</code> attribute of the <span class="strong"><strong>Submit</strong></span> button. If you replace this with the components IDs that should be re-rendered (<code class="literal">nameId</code>, <code class="literal">msgNameId</code>, <code class="literal">surnameId</code>, and <code class="literal">msgSurnameId</code>), the <code class="literal">resetValues</code> method works perfectly.</p><p>But, what you can do if there<a id="id1005" class="indexterm"/> are many input fields and you don't want to list all the components IDs? Or you just want to use the <code class="literal">@form</code> keyword in the <code class="literal">render</code> attribute? In this case, you should be aware that the<a id="id1006" class="indexterm"/> invalid input fields will not be automatically reset (the <code class="literal">resetValues</code> method is useless) and the end user should manually cancel/clear input fields by clicking on the <span class="strong"><strong>Cancel</strong></span> or <span class="strong"><strong>Clear</strong></span> button. While the <span class="strong"><strong>Cancel</strong></span> button works fine, there is a big <span class="emphasis"><em>Oops!</em></span> for the <span class="strong"><strong>Clear</strong></span> button because JSF will not clear the input fields that are not executed (listed in the <code class="literal">execute</code> attribute) and are re-rendered (listed in the <code class="literal">render</code> attribute), unless you submit only valid values. In other words, if the name is valid and the surname is not (or any other combination involving invalid values), then after submit and clear, the input field for the name is not cleared.</p><p>One solution to this problem is given on OmniFaces (<a class="ulink" href="https://code.google.com/p/omnifaces/">https://code.google.com/p/omnifaces/</a>), which provides an action listener named <code class="literal">org.omnifaces.eventlistener.ResetInputAjaxActionListener</code> (<a class="ulink" href="http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener">http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener</a>). This listener is capable of fixing the <span class="strong"><strong>Clear</strong></span> button and other issues of the same category:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Clear/Reset"&gt;
  &lt;f:ajax execute="@this" render="@form" 
         listener="#{ajaxBean.cancelNameAndSurname()}"/&gt;
  <span class="strong"><strong>&lt;f:actionListener type="org.omnifaces.eventlistener.</strong></span>
                <span class="strong"><strong>ResetInputAjaxActionListener"/&gt;</strong></span>
&lt;/h:commandButton&gt;</pre></div><p>The<a id="id1007" class="indexterm"/> complete application<a id="id1008" class="indexterm"/> can be found in the code bundle of<a id="id1009" class="indexterm"/> this chapter, which is named <code class="literal">ch7_9_7</code>.</p></div></div></div>
<div class="section" title="Mixing AJAX and flow scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Mixing AJAX and flow scope</h1></div></div></div><p>AJAX requests are<a id="id1010" class="indexterm"/> usually associated with beans in view scope (<code class="literal">@ViewScoped</code>), which means that data can be persisted (stored) over multiple AJAX requests as long as the current view is not destroyed by a navigation case (or other causes). A flow is <a id="id1011" class="indexterm"/>defined as a collection of logical related pages/views; therefore AJAX cannot survive across flow transitions.</p><p>For better understanding, we will adapt the application developed in <a class="link" href="ch03.html" title="Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication">Chapter 3</a>, <span class="emphasis"><em>JSF Scopes – Lifespan and Use in Managed Beans Communication</em></span> (the <code class="literal">ch3_7_3</code> application, which you need to be familiar with) to support AJAX requests in the <code class="literal">registration.xhtml</code> view (the first page in flow). The main idea is to write a view scoped bean that may populate the player name and surname defined in the flow scoped bean, <code class="literal">RegistrationBean</code>. The view-scoped bean, named <code class="literal">ViewRegistrationBean</code>, will randomly generate a name-surname pair and will present them as a suggestion to the end user. The user can provide the name and surname or he can choose to use the suggested ones. So, the flow-scoped bean looks like the following code:</p><div class="informalexample"><pre class="programlisting">import javax.faces.flow.FlowScoped;
import javax.inject.Named;

@Named
@FlowScoped(value = "registration")
public class RegistrationBean {

  private String playerName ="";
  private String playerSurname="";

  //getters and setters

  public void credentialsUpperCase(){
    playerName = playerName.toUpperCase();
    playerSurname = playerSurname.toUpperCase();
  }

  public String getReturnValue() {
    return "/done";
  }

  public String registrationAction() {
    return "confirm";
  }
}</pre></div><p>Notice that the <code class="literal">getReturnValue</code> method<a id="id1012" class="indexterm"/> represents a flow return (exits flow), while the <code class="literal">registrationAction</code> method<a id="id1013" class="indexterm"/> navigates to the next page in the flow. Both of them will break down the current view.</p><p>Next, the view-scoped <a id="id1014" class="indexterm"/>bean is the method annotated with <code class="literal">@PostConstruct</code> that will help us to see if AJAX uses the same instance of this bean over <a id="id1015" class="indexterm"/>multiple requests:</p><div class="informalexample"><pre class="programlisting">@Named
@ViewScoped
public class ViewRegistrationBean implements Serializable {

  @Inject
  RegistrationBean registrationBean;
  private String playerNameView = "nothing";
  private String playerSurnameView = "nothing";
  private static final Map&lt;Integer, String&gt; myMap = new HashMap&lt;&gt;();
  static {
        myMap.put(1, "Nadal Rafael");
        myMap.put(2, "Federer Roger");
        ...
  }

  @PostConstruct
  public void init() {
    Random r = new Random();
    int key = 1 + r.nextInt(9);
    String player = myMap.get(key);
    String[] fullname = player.split(" ");

    playerNameView = fullname[0];
    playerSurnameView = fullname[1];
    playerNameView = playerNameView.toUpperCase();
    playerSurnameView = playerSurnameView.toUpperCase();
  }

  public String getPlayerNameView() {
    return playerNameView;
  }

  public void setPlayerNameView(String playerNameView) {
    this.playerNameView = playerNameView;
  }

  public String getPlayerSurnameView() {
    return playerSurnameView;
  }

  public void setPlayerSurnameView(String playerSurnameView) {
    this.playerSurnameView = playerSurnameView;
  }

  public void generateCredentials() {
    registrationBean.setPlayerName(playerNameView);
    registrationBean.setPlayerSurname(playerSurnameView);
  }
}</pre></div><p>We can easily monitor the<a id="id1016" class="indexterm"/> values of name and surname by<a id="id1017" class="indexterm"/> displaying them in <code class="literal">registration.xhtml</code> using the following code:</p><div class="informalexample"><pre class="programlisting">Your registration last credentials (in &lt;b&gt;flow&lt;/b&gt;):
&lt;h:outputText id="credentialsFlowId" 
              value="#{registrationBean.playerName} 
                     #{registrationBean.playerSurname}"/&gt;
&lt;hr/&gt;
Random credentials (in &lt;b&gt;view&lt;/b&gt;) [as long as we are in this view this value won't change]:
&lt;h:outputText id="credentialsViewId" 
              value="#{viewRegistrationBean.playerNameView} 
                     #{viewRegistrationBean.playerSurnameView}"/&gt;</pre></div><p>Now, two buttons will fire AJAX requests. One button will call the server-side<a id="id1018" class="indexterm"/> method <code class="literal">credentialsUpperCase</code> (from flow-scoped bean, <code class="literal">RegistrationBean</code>) and the other one will call the server-side<a id="id1019" class="indexterm"/> method <code class="literal">generateCredentials</code> (from view-scoped bean, <code class="literal">ViewRegistrationBean</code>). In both cases, we will re-render the player name and surname from the beans as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  Name: &lt;h:inputText value="#{registrationBean.playerName}"/&gt;
  Surname: &lt;h:inputText value="#{registrationBean.playerSurname}"/&gt;
  &lt;h:commandButton value="Register To Tournament (AJAX call a method of a
  flow bean)" action="#{registrationBean.credentialsUpperCase()}"&gt;
  &lt;f:ajax execute="@form" 
          render="@form :credentialsFlowId :credentialsViewId"/&gt;
  &lt;/h:commandButton&gt;    
  &lt;h:commandButton value="Register To Tournament (AJAX call a method of a
  view bean)" action="#{viewRegistrationBean.generateCredentials()}"&gt;
  &lt;f:ajax execute="@this" 
           render="@form :credentialsFlowId :credentialsViewId"/&gt;
  &lt;/h:commandButton&gt;  
&lt;/h:form&gt;</pre></div><p>Now, the end user<a id="id1020" class="indexterm"/> can register to the tournament in two ways: by manually<a id="id1021" class="indexterm"/> inserting the name and surname through the input fields and register by pressing the first button (the result will be the inserted name and surname in uppercase), or he/she can choose to use the suggested name and surname and register by pressing the second button (the result will be the random name and surname in uppercase).</p><p>A few important things can be noticed here, which are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firing AJAX requests, by pressing the first button, will put the submitted name and surname in the flow scope (manually entered or imported from random suggestion)</li><li class="listitem" style="list-style-type: disc">Firing AJAX requests, by pressing the second button, will assign the suggested name and surname to their counterparts in the flow-scoped bean. It will not generate new names and surnames for each request, since we are in the same view across multiple AJAX requests, and the <code class="literal">init</code> method is called only when a new instance of the <code class="literal">ViewRegistrationBean</code> bean is created.</li><li class="listitem" style="list-style-type: disc">If we exit and re-enter in the flow, the persisted name and surname lose their values. When we exit from the flow, we reach the flow-scope boundaries, which means a new <code class="literal">RegistrationBean</code> instance must be created when entering in the flow again. Moreover, this outcome will change the current view; therefore, a new instance of <code class="literal">ViewRegistrationBean</code> is also needed.</li><li class="listitem" style="list-style-type: disc">When we navigate to the next page in the flow, the submitted name and surname have the same values because they were persisted in flow scope; while the suggested name and surname are randomly generated again, the outcome has changed the view, even if we are in the same flow, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/6466EN_07_05.jpg" alt="Mixing AJAX and flow scope"/></div></li></ul></div><p>Now you know<a id="id1022" class="indexterm"/> how AJAX works with flow scope combined with<a id="id1023" class="indexterm"/> view scope. The complete application can be found in the code bundle of this chapter, which is named <code class="literal">ch7_10</code>.</p></div>
<div class="section" title="Postback and AJAX"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Postback and AJAX</h1></div></div></div><p>Throughout this book, we have<a id="id1024" class="indexterm"/> mentioned the postback request several times. For those who are not familiar with it, or just need a quick reminder, let's say that JSF<a id="id1025" class="indexterm"/> recognizes the initial request and the postback request.</p><p><span class="strong"><strong>Initial request</strong></span> (for example, <code class="literal">HTTP GET</code>) is the <a id="id1026" class="indexterm"/>first request that the browser sends for loading the page. You can obtain such a request by accessing the application URL in a browser or by following a link (it can be a link to any page of the application). Moreover, the initial request happens in <code class="literal">page_B</code> when <code class="literal">page_A</code> contains a redirection (<code class="literal">faces-redirect=true</code>) to <code class="literal">page_B</code> (this is not true for forwarding mechanism). This kind of request is processed in <span class="emphasis"><em>Restore View</em></span> phase and <span class="emphasis"><em>Render Response</em></span> phase.</p><p><span class="strong"><strong>Postback request</strong></span> happens<a id="id1027" class="indexterm"/> when we click on a button/link for submitting a form. Unlike the initial request, the postback request passes through all the phases.</p><p>JSF provides a method named <a id="id1028" class="indexterm"/>
<code class="literal">isPostback</code> that returns a Boolean value: it returns <code class="literal">true</code> for postback request and <code class="literal">false</code> for initial request. Speaking in the code lines, we can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check the initial/postback request in a managed bean using the following code:<div class="informalexample"><pre class="programlisting">FacesContext facesContext = FacesContext.getCurrentInstance();
logger.log(Level.INFO, "Is postback: {0}", facesContext.isPostback());</pre></div></li><li class="listitem" style="list-style-type: disc">Check the initial/postback request in the page using the following code:<div class="informalexample"><pre class="programlisting">Is postback ? &lt;h:outputText value="#{facesContext.postback}"/&gt;</pre></div></li></ul></div><p>For example, you can<a id="id1029" class="indexterm"/> check the initial/postback request for AJAX with a simple application. The JSF page is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:commandButton value="Click Me!"&gt;
    &lt;f:ajax listener="#{ajaxBean.requestAction()}" render=":postbackId"/&gt;
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;        
&lt;h:panelGrid id="postbackId" columns="1"&gt;
  &lt;h:outputText value="Is postback ?: #{facesContext.postback}"/&gt;
  &lt;h:outputText value="REQUEST NUMBER: #{ajaxBean.request_number}"/&gt;
&lt;/h:panelGrid&gt;</pre></div><p>The <a id="id1030" class="indexterm"/>managed bean<a id="id1031" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@ViewScoped
public class AjaxBean implements Serializable{
    
  private static final Logger logger =
         Logger.getLogger(AjaxBean.class.getName());
  private int request_number = 1;

  public int getRequest_number() {
    FacesContext facesContext = FacesContext.getCurrentInstance();
    logger.log(Level.INFO, "Is postback (getRequest_number method): {0}", 
      facesContext.isPostback());
    return request_number;
  }

  public void setRequest_number(int request_number) {
    this.request_number = request_number;
  }
    
  public void requestAction(){        
    FacesContext facesContext = FacesContext.getCurrentInstance();
    logger.log(Level.INFO, "Is postback (requestAction method): {0}", facesContext.isPostback());
    request_number ++;
  }    
}</pre></div><p>The code is very simple; therefore we <a id="id1032" class="indexterm"/>can jump directly to inspect<a id="id1033" class="indexterm"/> the initial/postback requests, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>First request</strong></span>: The first page of the application is loaded by accessing the application URL. The client side indicates an initial request as it is shown in the following screenshot on the left-hand side, and the server side indicates the same, as shown in the same screenshot on the right-hand side:<div class="mediaobject"><img src="graphics/6466EN_07_06.jpg" alt="Postback and AJAX"/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Second request</strong></span>: The <span class="strong"><strong>Click Me!</strong></span> button is clicked for the first time (the result is <code class="literal">true</code> for the second time, third time, and so on). The client side (in the browser) indicates a postback request as it is shown in the following screenshot on the left-hand side, and the server side indicates the same as shown in the same screenshot on the right-hand side:<div class="mediaobject"><img src="graphics/6466EN_07_07.jpg" alt="Postback and AJAX"/></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note146"/>Note</h3><p>It would be useful to know when the request is initial or postback. For example, you may want to accomplish a task a single time, at initial request (for example, the initialization tasks), or every time, except for the first time (for example, display a message, which is not proper to appear when a page is displayed as a result of the initial request).</p></div></div><div class="section" title="Postback request's conditional rendering/executing"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec80"/>Postback request's conditional rendering/executing</h2></div></div></div><p>We can use initial/postback request<a id="id1034" class="indexterm"/> detection to conditionally render UI components (of course, you can use it for partial processing also). Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="ajaxFormId"&gt;
  &lt;h:commandButton id="buttonId" value="Click Me!"&gt;  
    &lt;f:ajax listener="#{ajaxBean.requestAction()}" 
      render="#{facesContext.postback eq true ?
  ':postbackId': 'ajaxFormId'}"/&gt;
  &lt;/h:commandButton&gt;
  Is postback ? &lt;h:outputText value="#{facesContext.postback}"/&gt;
&lt;/h:form&gt;        
&lt;h:panelGrid id="postbackId" columns="1"&gt;
  &lt;h:outputText value="REQUEST NUMBER: #{ajaxBean.request_number}"/&gt;
&lt;/h:panelGrid&gt;</pre></div><p>So, let's see how it works! When the page is loaded, we have an initial request (<code class="literal">#{facesContext.postback}</code> returns <code class="literal">false</code>), which means that the server response will contain something like<a id="id1035" class="indexterm"/> the following code snippet (we need to focus on the <code class="literal">&lt;f:ajax&gt;</code> component):</p><div class="informalexample"><pre class="programlisting">&lt;input id="ajaxFormId:buttonId" type="submit" 
       name="ajaxFormId:buttonId" value="Click Me!"      
       <span class="strong"><strong>onclick="mojarra.ab(this,event,'action',0,'ajaxFormId');</strong></span>
       return false" /&gt;</pre></div><p>On the server side, the log line from the <code class="literal">getRequest_number</code> method will also reveal an initial request. Moreover, notice that the reported request number is <code class="literal">1</code>, which is the initial value of the <code class="literal">request_number</code> property.</p><p>Next, let's click once on the <span class="strong"><strong>Click Me!</strong></span> button. Now, the AJAX request will look like the following line of code:</p><div class="informalexample"><pre class="programlisting">ajaxFormId=ajaxFormId&amp;javax.faces.ViewState=411509096033316844%3A7611114960827713853&amp;javax.faces.source=ajaxFormId%3AbuttonId&amp;javax.faces.partial.event=click&amp;javax.faces.partial.execute=ajaxFormId%3AbuttonId%20ajaxFormId%3AbuttonId&amp;<span class="strong"><strong>javax.faces.partial.render</strong></span>
<span class="strong"><strong>=ajaxFormId</strong></span>&amp;javax.faces.behavior.event=action&amp;javax.faces.partial.ajax=true</pre></div><p>The highlighted code provides important information! This is a postback request, but the <code class="literal">render</code> attribute contains the ID of the <code class="literal">&lt;h:form&gt;</code> component, not the ID of the <code class="literal">&lt;h:panelGrid&gt;</code> component (as you may have thought); this happens because the <code class="literal">#{facesContext.postback}</code> expression was evaluated to <code class="literal">false</code> in the previous request. So, with the first click on our button, AJAX will not re-render the <code class="literal">&lt;h:panelGrid&gt;</code> component. Meanwhile, on the server side, the <code class="literal">request_number</code> property<a id="id1036" class="indexterm"/> was successfully incremented to <code class="literal">2</code>; however for the end user, it still appears as <code class="literal">1</code>.</p><p>Now, the server response for this AJAX will contain the following code:</p><div class="informalexample"><pre class="programlisting">&lt;input id="ajaxFormId:buttonId" type="submit"
       name="ajaxFormId:buttonId" value="Click Me!"    
       <span class="strong"><strong>onclick="mojarra.ab(this,event,'action',0,'postbackId');</strong></span>
       return false"&gt;</pre></div><p>Note<a id="id1037" class="indexterm"/> that the <code class="literal">postbackId</code>, which is the <code class="literal">&lt;h:panelGrid&gt;</code> ID, is present in the response. The next click (the second click) on the button will generate the next AJAX request:</p><div class="informalexample"><pre class="programlisting">ajaxFormId=ajaxFormId&amp;javax.faces.ViewState=270275638491205347%3A7563196939691682163&amp;javax.faces.source=ajaxFormId%3AbuttonId&amp;javax.faces.partial.event=click&amp;javax.faces.partial.execute=ajaxFormId%3AbuttonId%20ajaxFormId%3AbuttonId<span class="strong"><strong>&amp;javax.faces.partial.render=postbackId</strong></span>&amp;javax.faces.behavior.event=action&amp;javax.faces.partial.ajax=true</pre></div><p>Now, when the AJAX request completes, the <code class="literal">&lt;h:panelGrid&gt;</code> component will be re-rendered. The <code class="literal">request_number</code> property reaches the value <code class="literal">3</code>, and it will be displayed on the client side. Further <a id="id1038" class="indexterm"/>AJAX requests will be the postback requests.</p><p>In the following screenshot, you can see the initial request, first click on the button and second click from client and server sides:</p><div class="mediaobject"><img src="graphics/6466EN_07_08.jpg" alt="Postback request's conditional rendering/executing"/></div><p>It would be<a id="id1039" class="indexterm"/> helpful to know this behavior of AJAX with initial/postback requests—it is not a bug. Of course, once you know this <span class="emphasis"><em>issue</em></span>, there are many workarounds depending on what you really want to accomplish.</p><p>Further, you can try to test the <code class="literal">execute</code> attribute in a similar approach.</p><p>The complete<a id="id1040" class="indexterm"/> application can be found in the code bundle of this chapter, which is named <code class="literal">ch7_11</code>.</p></div></div>
<div class="section" title="Is it a non-AJAX request?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Is it a non-AJAX request?</h1></div></div></div><p>JSF can answer this<a id="id1041" class="indexterm"/> question by inspecting request headers or checking the <code class="literal">PartialViewContext.isAjaxRequest</code> method. The request headers that provide information about the request type are <code class="literal">Faces-Request</code> and <code class="literal">X-Requested-With</code>. For an AJAX request, the <code class="literal">Faces-Request</code> header will have the value <code class="literal">partial/ajax</code>, while the <code class="literal">X-Requested-With</code> request type will have the value <code class="literal">XMLHttpRequest</code> (in JSF 2.2, <code class="literal">X-Requested-With</code> doesn't seem to work; however, for the sake of completeness, you can test them again). In the following screenshot, you can see the headers of a typical JSF 2.2 AJAX request:</p><div class="mediaobject"><img src="graphics/6466EN_07_09.jpg" alt="Is it a non-AJAX request?"/></div><p>In a managed bean, you can<a id="id1042" class="indexterm"/> determine the type of the request, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void requestTypeAction() {

  FacesContext facesContext = FacesContext.getCurrentInstance();
  ExternalContext externalContext = facesContext.getExternalContext();
  Map&lt;String, String&gt; headers = externalContext.getRequestHeaderMap();
  logger.info(headers.toString());

  //determination method 1       
  PartialViewContext partialViewContext =    
                    facesContext.getPartialViewContext();
  if (partialViewContext != null) {
    if (partialViewContext.isAjaxRequest()) {
         logger.info("THIS IS AN AJAX REQUEST (DETERMINATION 1) ...");
    } else {
           logger.info("THIS IS A NON-AJAX REQUEST(DETERMINATION 1)...");
    }
  }

  //determination method 2
  String request_type_header_FR = headers.get("Faces-Request");
  if (request_type_header_FR != null) {
    if (request_type_header_FR.equals("partial/ajax")) {
         logger.info("THIS IS AN AJAX REQUEST (DETERMINATION 2) ...");
     } else {
           logger.info("THIS IS A NON-AJAX REQUEST(DETERMINATION 2)...");
     }
  }

  //determination method 3
  String request_type_header_XRW = headers.get("X-Requested-With");
  if (request_type_header_XRW != null) {
    if (request_type_header_XRW.equals("XMLHttpRequest")) {
        logger.info("THIS IS AN AJAX REQUEST (DETERMINATION 3) ...");
    } else {
           logger.info("THIS IS A NON-AJAX REQUEST(DETERMINATION 3)...");
    }
  }
}</pre></div><p>Alternatively, on a <a id="id1043" class="indexterm"/>JSF page, you can write the following code:</p><div class="informalexample"><pre class="programlisting">AJAX/NON-AJAX: 
#{facesContext.partialViewContext.ajaxRequest ? 'Yes' : 'No'}
FACES-REQUEST HEADER: #{facesContext.externalContext.requestHeaderMap['Faces-Request']}
X-REQUESTED-WITH HEADER: #{facesContext.externalContext.requestHeaderMap['X-Requested-With']}</pre></div><p>The complete application can be found in the code bundle of this chapter, which is named <code class="literal">ch7_12</code>.</p></div>
<div class="section" title="AJAX and &lt;f:param&gt;"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec74"/>AJAX and &lt;f:param&gt;</h1></div></div></div><p>The <code class="literal">&lt;f:param&gt;</code> tag can be<a id="id1044" class="indexterm"/> used to pass request parameters to a managed bean. Since<a id="id1045" class="indexterm"/> we have discussed this tag in detail in <a class="link" href="ch02.html" title="Chapter 2. Communication in JSF">Chapter 2</a>, <span class="emphasis"><em>Communication in JSF</em></span>, we can continue here with an example of using it inside <code class="literal">&lt;f:ajax&gt;</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText id="nameInputId" value="#{ajaxBean.name}"/&gt;
  &lt;h:commandButton value="Send" action="#{ajaxBean.ajaxAction()}"&gt;
    &lt;f:ajax execute ="nameInputId" render="nameOutputId"&gt;
      <span class="strong"><strong>&lt;f:param name="surnameInputId" value="Nadal"/&gt;</strong></span>
    &lt;/f:ajax&gt;
  &lt;/h:commandButton&gt;
  &lt;h:outputText id="nameOutputId" value="#{ajaxBean.name}"/&gt;
&lt;/h:form&gt;</pre></div><p>Remember that the parameter that was passed is available in the request parameter map:</p><div class="informalexample"><pre class="programlisting">FacesContext fc = FacesContext.getCurrentInstance();
  Map&lt;String, String&gt; params = 
             fc.getExternalContext().getRequestParameterMap();
  logger.log(Level.INFO, "Surname: {0}", params.get("surnameInputId"));</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note147"/>Note</h3><p>Keep in mind that <code class="literal">&lt;f:param&gt;</code> can be used with buttons and links only. Trying to add <code class="literal">&lt;f:param&gt;</code> in inputs will not work. Further details are available in <a class="link" href="ch02.html" title="Chapter 2. Communication in JSF">Chapter 2</a>, <span class="emphasis"><em>Communication in JSF</em></span>.</p></div></div><p>The complete application<a id="id1046" class="indexterm"/> can be found in the code bundle of<a id="id1047" class="indexterm"/> this chapter, which is named <code class="literal">ch7_13</code>.</p></div>
<div class="section" title="Queue control for AJAX requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Queue control for AJAX requests</h1></div></div></div><p>Queuing AJAX requests on the client side is a common practice meant to ensure that only one request is processed at a time. The goal of this approach is to protect the server from being overwhelmed and the client browser from blocking or receiving AJAX responses in an undefined order. While AJAX queuing is available in JSF 2.0, queue control for AJAX is available starting with JSF 2.2.</p><p>In order to provide AJAX queue control, JSF 2.2 introduced an attribute named <code class="literal">delay</code> for the <code class="literal">&lt;f:ajax&gt;</code> tag. The value of this attribute is a<a id="id1048" class="indexterm"/> string that represents a number of milliseconds (defaults to <code class="literal">none</code>). During this time interval, only the most recent request is actually sent to the server, while the rest of them are ignored. In other words, JSF will wait <span class="emphasis"><em>n</em></span> milliseconds until the most recent AJAX request is executed. By default, it will not wait.</p><p>Here is an example of using the<a id="id1049" class="indexterm"/> default <code class="literal">delay</code> attribute, and an explicit delay of 1000 milliseconds. In order to point out the delay effect, we've built a simple application that sends an AJAX request (submit an input text value) on the <code class="literal">keyup</code> event, and waits for a suggestion text as a server response. In the following screenshot, you can compare the number of entered keys until the server responds with the first suggestion text. In both the cases, this is the first triggered AJAX request. It is obvious that in the second case, a number of seven requests (keystrokes) were not sent because they were fired during the1000 milliseconds range. Generally speaking, every time a new key is entered, prior AJAX requests are removed, and only the last request is taken into account.</p><div class="mediaobject"><img src="graphics/6466EN_07_10.jpg" alt="Queue control for AJAX requests"/></div><p>The complete application can be found in the code bundle <a id="id1050" class="indexterm"/>of this chapter, and is named <code class="literal">ch7_14</code>. You may also want to check out the <span class="emphasis"><em>Customizing jsf.js</em></span> section, where you'll see the <code class="literal">delay</code> attribute at work.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note148"/>Note</h3><p>You can disable the effect of the <code class="literal">delay</code> attribute by setting its value to <code class="literal">none</code>. This is the default value.</p></div></div></div>
<div class="section" title="Explicit loading of jsf.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Explicit loading of jsf.js</h1></div></div></div><p>The AJAX mechanism<a id="id1051" class="indexterm"/> used by JSF is encapsulated in a JavaScript file, named <code class="literal">jsf.js</code>. This file is available in the <code class="literal">javax.faces</code> library. When we are using <code class="literal">&lt;f:ajax&gt;</code>, this file is loaded behind the scene without any explicit requirements.</p><p>However, <code class="literal">jsf.js</code> can be loaded explicitly with any of the following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">&lt;h:outputScript&gt;</code> component<a id="id1052" class="indexterm"/> as follows:<div class="informalexample"><pre class="programlisting">&lt;h:outputScript name="jsf.js" library="javax.faces" target="head"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">@ResourceDependency</code> keyword<a id="id1053" class="indexterm"/> as follows:<div class="informalexample"><pre class="programlisting">@ResourceDependency(name="jsf.js" library="javax.faces" target="head")</pre></div></li></ul></div><p>Focusing on <code class="literal">&lt;h:outputScript&gt;</code>, you<a id="id1054" class="indexterm"/> can attach AJAX to a component as shown in the following example code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form prependId="false"&gt;             
  <span class="strong"><strong>&lt;h:outputScript name="jsf.js" library</strong></span>
<span class="strong"><strong>="javax.faces" target="head"/&gt;</strong></span>
  &lt;h:inputText id="nameInId" value="#{ajaxBean.name}"/&gt;
  &lt;h:outputText id="nameOutId" value="#{ajaxBean.name}"/&gt;
  &lt;h:commandButton id="submit" value="Send" 
                  action="#{ajaxBean.upperCaseAction()}" 
                  <span class="strong"><strong>onclick="jsf.ajax.request(this, event,</strong></span>       <span class="strong"><strong>{execute:'nameInId',render:'nameOutId'});</strong></span>
                           return false;" /&gt;
&lt;/h:form&gt;  </pre></div><p>The <code class="literal">jsf.ajax.request</code> method<a id="id1055" class="indexterm"/> defined in <code class="literal">jsf.js</code> is capable of dealing with AJAX <a id="id1056" class="indexterm"/>requests. It takes the following three parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">source</code>: This is<a id="id1057" class="indexterm"/> the<a id="id1058" class="indexterm"/> DOM element (for example, <code class="literal">&lt;h:commandButton&gt;</code>, <code class="literal">&lt;h:commandLink&gt;</code>, and so on) that triggers the AJAX request (this is a mandatory parameter)</li><li class="listitem" style="list-style-type: disc"><code class="literal">event</code>: This<a id="id1059" class="indexterm"/> is an optional parameter<a id="id1060" class="indexterm"/> representing the DOM event that triggers the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">options</code>: This<a id="id1061" class="indexterm"/> is an optional<a id="id1062" class="indexterm"/> parameter that can contain the values: <code class="literal">execute</code>, <code class="literal">render</code>, <code class="literal">onevent</code>, <code class="literal">onerror</code>, <code class="literal">delay</code>, and <code class="literal">params</code>.</li></ul></div><p>The complete<a id="id1063" class="indexterm"/> application for explicitly loading the <code class="literal">jsf.js</code> file is available in the code bundle of this chapter, which is named <code class="literal">ch7_15</code>.</p><div class="section" title="Depicting the params value"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec81"/>Depicting the params value</h2></div></div></div><p>While the <code class="literal">execute</code>, <code class="literal">render</code>, <code class="literal">delay</code>, <code class="literal">onevent</code>, and <code class="literal">onerror</code> values are very well known from previous<a id="id1064" class="indexterm"/> sections, the <code class="literal">params</code> value is something new, so let's give<a id="id1065" class="indexterm"/> it some attention. The <code class="literal">params</code> value is actually an object that allows us to add supplementary parameters into the request.</p><p>For example, the following code is a fancy solution for sending a JavaScript JSON object to a managed bean. The code is straightforward as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
  var myJSONObject =
    [{
      "name": "Rafael",
      "surname": "Nadal",
      "age": 27,
      "isMarried": false,
      "address": {
                 "city": " Mallorca",
                 "country": "Spain"
                 },
      "websites": ["http://www.rafaelnadal.com", 
                   "http://rafaelnadalfans.com/"]
      },
      ...
      }]
&lt;/script&gt;
...
&lt;h:form prependId="false"&gt;             
  &lt;h:outputScript name="jsf.js" library="javax.faces" target="head"/&gt;
    Data type (e.g. JSON): &lt;h:inputText id="typeInId" 
                                     value="#{ajaxBean.type}"/&gt;   
  &lt;h:commandButton id="submit" value="Send" 
                  action="#{ajaxBean.processJSONAction()}" 
                  onclick='jsf.ajax.request(this, event, {execute: 
                  "typeInId", render: "typeOutId playersId", <span class="strong"><strong>params: JSON.stringify(myJSONObject)});</strong></span>
                  return false;' /&gt;
  &lt;h:outputText id="typeOutId" value="#{ajaxBean.type}"/&gt;
  &lt;h:dataTable id="playersId" value="#{ajaxBean.players}" var="t"&gt;
  ...
  &lt;/h:dataTable&gt;
&lt;/h:form&gt;</pre></div><p>On the server side, the <code class="literal">params</code> value<a id="id1066" class="indexterm"/> is available in the request parameter map as follows:</p><div class="informalexample"><pre class="programlisting">FacesContext facesContext = FacesContext.getCurrentInstance();
String json = facesContext.getExternalContext().
              getRequestParameterMap().get("params");
JsonArray personArray;
try (JsonReader reader = Json.createReader(new StringReader(json))) {
     personArray = reader.readArray();
    }
...</pre></div><p>The complete application<a id="id1067" class="indexterm"/> can be found in the code bundle of this chapter, and is named <code class="literal">ch7_16</code>.</p></div><div class="section" title="Non-UICommand components and jsf.ajax.request"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec82"/>Non-UICommand components and jsf.ajax.request</h2></div></div></div><p>The <code class="literal">&lt;f:ajax&gt;</code> tag is<a id="id1068" class="indexterm"/> far more popular than <code class="literal">jsf.ajax.request</code>. This is absolutely normal, since <code class="literal">&lt;f:ajax&gt;</code> fits more<a id="id1069" class="indexterm"/> natural in <span class="emphasis"><em>context</em></span> and is much more easy to use and<a id="id1070" class="indexterm"/> understand. Moreover, <code class="literal">&lt;f:ajax&gt;</code> supports the <code class="literal">listener</code> attribute, which allows us to call the server-side methods even when the <code class="literal">&lt;f:ajax&gt;</code> tag is nested in other components than in <code class="literal">UICommand</code>. By default, <code class="literal">jsf.ajax.request</code> cannot do that!</p><p>For example, let's say that we have a table (<code class="literal">&lt;h:dataTable&gt;</code>) that displays a <code class="literal">Map</code> object containing several tennis players (the <code class="literal">Map</code> key is an integer of type: <code class="literal">1</code>, <code class="literal">2</code>,<code class="literal">3</code>, ... <span class="emphasis"><em>n</em></span>, and the <code class="literal">Map</code> value is the player name):</p><div class="informalexample"><pre class="programlisting">private Map&lt;Integer, String&gt; myMap = new HashMap&lt;&gt;();
...
myMap.put(1, "Nadal Rafael");
myMap.put(2, "Federer Roger");
...</pre></div><p>Next, we want to add<a id="id1071" class="indexterm"/> a column labeled <span class="strong"><strong>Delete</strong></span> that contains a delete icon for each row, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_07_11.jpg" alt="Non-UICommand components and jsf.ajax.request"/></div><p>We want to <a id="id1072" class="indexterm"/>capture the client-side <code class="literal">onclick</code> event and trigger an AJAX request using <code class="literal">jsf.ajax.request</code> for each icon. The idea is to send<a id="id1073" class="indexterm"/> the player number (<code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>, ... <span class="emphasis"><em>n</em></span>) to a server-side method<a id="id1074" class="indexterm"/> named <code class="literal">deletePlayerAction</code>. This method will find and delete the record from the <code class="literal">Map</code> object and when the table is re-rendered, the corresponding row will disappear. So, the code can be written as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form prependId="false"&gt;
  &lt;h:outputScript name="jsf.js" library="javax.faces" target="head"/&gt;
  &lt;h:dataTable id="playersTableId" 
              value="#{ajaxBean.myMap.entrySet()}" var="t"&gt;
    &lt;h:column&gt;
      &lt;f:facet name="header"&gt;
        Delete
      &lt;/f:facet&gt;
      &lt;h:graphicImage value="./resources/default/imgs/delete.png" 
                     <span class="strong"><strong>onclick="jsf.ajax.request(this, event,</strong></span> 
                             <span class="strong"><strong>{execute: '@this', render:</strong></span> <span class="strong"><strong>'playersTableId',</strong></span> 
                              <span class="strong"><strong>params: '#{t.key}'});"/&gt;</strong></span> 
    &lt;/h:column&gt;  

  ...
  &lt;/h:dataTable&gt;
&lt;/h:form&gt;    </pre></div><p>We can use the <code class="literal">params</code> value to send the player number to delete; this will be available through the request parameter map. But the big issue here is that we can't call the server-side method, <code class="literal">deletePlayerAction</code>, because we don't have a <code class="literal">UICommand</code> component (such as a button) and <code class="literal">jsf.ajax.request</code> doesn't have a <code class="literal">listener</code> value for the <code class="literal">options</code> parameter.</p><p>Well, the solution<a id="id1075" class="indexterm"/> comes from<a id="id1076" class="indexterm"/> the JSF extensions such as PrimeFaces (check <code class="literal">&lt;p:remoteCommand&gt;</code>), OmniFaces (check <code class="literal">&lt;o:commandScript&gt;</code>), or RichFaces (check <code class="literal">&lt;a4j:jsfFunction&gt;</code>), but you can also solve the problem through pure JSF. First, you need to add a <code class="literal">UICommand</code> component that is not visible, such as a <code class="literal">&lt;h:commandLink&gt;</code> tag, as added in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;h:form prependId="false"&gt;
  &lt;h:commandLink id="commandDeleteId" immediate="true"
                action="#{ajaxBean.deletePlayerAction()}" 
                style='display: none;'/&gt;
  &lt;h:outputScript name="jsf.js" library="javax.faces" target="head"/&gt;</pre></div><p>Next, we bind the<a id="id1077" class="indexterm"/> AJAX request to this <code class="literal">UICommand</code> component, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;h:graphicImage value="./resources/default/imgs/delete.png" 
                onclick="jsf.ajax.request('commandDeleteId', event, {'javax.faces.behavior.event': 'action', 
                execute: '@this', render: 'playersTableId', params: '#{t.key}'});"/&gt;</pre></div><p>At this moment, when we click on a delete icon, the server-side method is executed. The code of this method is pretty simple, which is as follows:</p><div class="informalexample"><pre class="programlisting">public void deletePlayerAction() {
  FacesContext facesContext = FacesContext.getCurrentInstance();
  String nr = facesContext.getExternalContext().
                   getRequestParameterMap().get("params");
      
  if(nr!=null){               
    myMap.remove(Integer.valueOf(nr));
  }
}</pre></div><p>Done! The complete application can be found in the code bundle of this chapter, which is named <code class="literal">ch7_17</code>.</p><p>Of course, as the section name suggests, this was an example of using <code class="literal">jsf.ajax.request</code>, not the best solution to this scenario. Nevertheless, there are simple solutions for<a id="id1078" class="indexterm"/> this, such as using a <code class="literal">&lt;h:commandLink&gt;</code> tag in conjunction with the icon and ajaxify the link (proposed by Michael Muller at <a class="ulink" href="http://blog.mueller-bruehl.de/tutorial-web-development/">http://blog.mueller-bruehl.de/tutorial-web-development/</a>), The following code snippet shows this approach:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="playersFormId"&gt; 
  &lt;h:dataTable id="playersTableId" 
    value="#{ajaxBean.myMap.entrySet()}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Delete&lt;/f:facet&gt;
    &lt;h:commandLink id="commandDeleteId" immediate="true"
      action="#{ajaxBean.deletePlayerAction(t.key)}"&gt;
    &lt;f:ajax render="playersFormId:playersTableId"/&gt;
    &lt;h:graphicImage value=
      "#{resource['default:imgs/delete.png']}"/&gt;
    &lt;/h:commandLink&gt;     
  &lt;/h:column&gt;
  ...</pre></div><p>The<a id="id1079" class="indexterm"/> complete example can be found in the<a id="id1080" class="indexterm"/> code bundle of this chapter named <code class="literal">ch7_18</code>.</p></div><div class="section" title="Customizing jsf.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec83"/>Customizing jsf.js</h2></div></div></div><p>The biggest advantage of explicitly loading <code class="literal">jsf.js</code> is the fact that we can customize<a id="id1081" class="indexterm"/> the AJAX mechanism by altering the default code. First, we need to isolate the default <code class="literal">jsf.js</code> file in a separate place—you can easily save it in a folder such as <code class="literal">resources/default/js</code> in the web pages folder. Afterwards, you can edit the JavaScript file and perform the desired modifications. Of course, modify this code only if you really know what you are doing, because you may cause undesired issues! It is not recommended that you modify the code, unless you really need to.</p><p>As an example, we can modify the Mojarra, the <code class="literal">jsf.js</code> code to see how the AJAX queue works. More precisely, to see how requests are added in queue and removed from queue depending on the <code class="literal">delay</code> value, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In <code class="literal">jsf.js</code>, find the <code class="literal">enqueue</code> function. This function is called by JSF to add an AJAX request in queue:<div class="informalexample"><pre class="programlisting">this.enqueue = function enqueue(element) {
  // Queue the request
  queue.push(element);
};</pre></div></li><li class="listitem">Modify this function to call a JavaScript custom function and pass to it the AJAX queue:<div class="informalexample"><pre class="programlisting">this.enqueue = function enqueue(element) {
  // Queue the request                
  queue.push(element);
  <span class="strong"><strong>monitorQueue(queue);</strong></span>
};</pre></div></li><li class="listitem">Do the same thing in the <code class="literal">dequeue</code> function. This function is called by JSF to remove an AJAX request from the queue:<div class="informalexample"><pre class="programlisting">this.dequeue = function dequeue() {
  ...
  // return the removed element
  try {                    
      return element;
      } finally {
         element = null; // IE 6 leak prevention
     }
  };</pre></div></li><li class="listitem">Modify this function to call the same JavaScript custom function:<div class="informalexample"><pre class="programlisting">this.dequeue = function dequeue() {       
  ...
  <span class="strong"><strong>monitorQueue(queue);</strong></span>
  // return the removed element
  try {                    
      return element;
      } finally {
         element = null; // IE 6 leak prevention
      }
  };</pre></div></li></ol></div><p>At this point, a JavaScript <a id="id1082" class="indexterm"/>custom function will be called every time an AJAX request is added/removed in/from the queue and the current queue will be passed in. Each entry in the queue is an AJAX request; therefore, we can loop the queue and extract information about each of them:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
  function monitorQueue(q) {
    document.getElementById("ajaxqueueId").innerHTML = "";
    if (q.length &gt; 0)
      {
      //&lt;![CDATA[
      var report = "";
      document.getElementById("ajaxqueueId").innerHTML = 
           "&lt;b&gt;TOTAL REQUESTS: &lt;/b&gt;" + q.length + "&lt;hr/&gt;";
      for (var i = 0; i &lt; q.length; i++) {
        var request = q[i];
        report += (i + 1) + ".&lt;b&gt;Request Type:&lt;/b&gt; " + request.xmlReq + " &lt;b&gt;Source Id:&lt;/b&gt; " + request.context.sourceid + "  &lt;b&gt;URL: &lt;/b&gt; " + request.url + " &lt;b&gt;Taken Off Queue ?&lt;/b&gt;: " + request.fromQueue + "&lt;hr/&gt;";
      }

      document.getElementById("ajaxqueueId").innerHTML += report;
      //]]&gt;
      }
  }
&lt;/script&gt;</pre></div><p>Each request object <a id="id1083" class="indexterm"/>has a suit of properties, which can be easily seen in the following code (this is extracted directly from the <code class="literal">jsf.js</code> source code):</p><div class="informalexample"><pre class="programlisting">var AjaxEngine = function AjaxEngine(context) {

  var req = {};                  // Request Object
  req.url = null;                // Request URL
  req.context = context;         // Context of request and response
  req.context.sourceid = null;   // Source of this request
  req.context.onerror = null;    // Error handler for request
  req.context.onevent = null;    // Event handler for request
  req.xmlReq = null;             // XMLHttpRequest Object
  req.async = true;              // Default - Asynchronous
  req.parameters = {};           // Parameters For GET or POST
  req.queryString = null;        // Encoded Data For GET or POST
  req.method = null;             // GET or POST
  req.status = null;             // Response Status Code From Server
  req.fromQueue = false;          // Indicates if the request was 
                                   taken off the queue
...</pre></div><p>All you have to do now is to trigger some AJAX requests and monitor the queue report generated in the <code class="literal">monitorQueue</code> function. As you can see in the following code, each button has a different <code class="literal">delay</code> value:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h:outputScript name="js/jsf.js" library="default" target="head"/&gt; 
  &lt;hr/&gt;
  MONITOR AJAX QUEUE
  &lt;hr/&gt;
  &lt;h:form prependId="false"&gt;                                    
    &lt;h:commandButton id="button_1_Id" value="Send 1 (no delay)" 
      action="#{ajaxBean.ajaxAction()}" onclick='jsf.ajax.request(this, 
      event, {execute: "@this", render: "@this"});
      return false;' /&gt; 
    &lt;h:commandButton id="button_2_Id" value="Send 2 (delay:600)" 
      action="#{ajaxBean.ajaxAction()}" onclick='jsf.ajax.request(this, 
      event, {delay: 600, execute: "@this", render: "@this"});
      return false;' /&gt;  
    &lt;h:commandButton id="button_3_Id" value="Send 3 (delay:1000)" 
      action="#{ajaxBean.ajaxAction()}" onclick='jsf.ajax.request(this,  
      event, {delay: 1000, execute: "@this", render: "@this"});
      return false;' /&gt;  
  &lt;/h:form&gt;          
  AJAX QUEUE CONTENT:
  &lt;div id="ajaxqueueId"&gt;&lt;/div&gt;        
&lt;/h:body&gt;</pre></div><p>As you can see, all AJAX requests are referring the same server-side method, <code class="literal">ajaxAction</code>. This method <a id="id1084" class="indexterm"/>can easily simulate some business logic by sleeping for a random number of milliseconds for each request, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void ajaxAction() {
  Random rnd = new Random();
  int sleep=1000 + rnd.nextInt(4000);
  try {
      //sleep between 1 and 5 seconds
      Thread.sleep(sleep);
  } catch (InterruptedException ex) {
      Logger.getLogger(AjaxBean.class.getName()).
                         log(Level.SEVERE,null, ex);
  };        
}</pre></div><p>Once you know how to monitor the queue content, you can go further and alter its content by queuing only certain requests, changing their priority of execution, accepting a limited number of entries in queue, and so on.</p><p>The complete application can be found in the code bundle of this chapter, and is named <code class="literal">ch7_19</code>.</p></div></div>
<div class="section" title="AJAX and the progress bar/indicator"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec77"/>AJAX and the progress bar/indicator</h1></div></div></div><p>While testing on <code class="literal">localhost</code>, AJAX requests seem pretty fast, but in real production environments they cannot<a id="id1085" class="indexterm"/> be solved as fast because many aspects slow down the process (Internet connection speed, number of concurrent users, and so on).</p><p>A common practice<a id="id1086" class="indexterm"/> consists of using a progress bar/indicator that signals the user that requests are being processed and he/she should wait until the AJAX response is received and rendered accordingly. For example, PrimeFaces provides a cool determinate progress bar for upload tasks (<code class="literal">&lt;p:fileUpload&gt;</code>) and an indeterminate progress indicator for any other AJAX request (check <code class="literal">&lt;p:ajaxStatus&gt;</code>). RichFaces also have similar capabilities.</p><p>In the next chapter, you will see how to implement a progress bar for upload tasks. Without writing a custom component, such as <code class="literal">&lt;p:ajaxStatus&gt;</code>, we can easily implement a progress indicator using the <code class="literal">onevent</code> attribute, the <code class="literal">data</code> object, and a small piece of CSS, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type='text/javascript'&gt;
  function progressIndicator(data) {
  if (data.status === "begin") {
      document.getElementById("progressDivId").style.display = "block";
  }
    if (data.status === "complete") {
      document.getElementById("progressDivId").style.display = "none";
    }
  }
&lt;/script&gt;                
...
&lt;h:body&gt;        
  &lt;h:panelGrid columns="2"&gt;
    &lt;h:form&gt;
      &lt;h:inputText id="nameInputId" value="#{ajaxBean.name}"/&gt;
      &lt;h:commandButton value="Send" action="#{ajaxBean.ajaxAction()}"&gt;
      &lt;f:ajax onevent="progressIndicator" execute ="nameInputId" 
            render="nameOutputId"/&gt;
      &lt;/h:commandButton&gt;
      &lt;h:outputText id="nameOutputId" value="#{ajaxBean.name}"/&gt;
    &lt;/h:form&gt; 

  &lt;div id="progressDivId" style="display:none;"&gt;
    &lt;img src="resources/default/imgs/ajax.gif"/&gt;
  &lt;/div&gt;
  &lt;/h:panelGrid&gt;
&lt;/h:body&gt;</pre></div><p>In the following screenshot, you<a id="id1087" class="indexterm"/> can see an example of running the complete application, named <code class="literal">ch7_20</code> in the code bundle of this chapter:</p><div class="mediaobject"><img src="graphics/6466EN_07_12.jpg" alt="AJAX and the progress bar/indicator"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Summary</h1></div></div></div><p>In this chapter, we covered the AJAX support in JSF 2.2 Core. Besides common tasks such as using <code class="literal">render</code>, <code class="literal">execute</code>, <code class="literal">listener</code>, and other attributes, you learned how to use AJAX with JSF 2.2 flow scope, how to use the JSF 2.2 <code class="literal">delay</code> attribute, and how to update input fields with AJAX after validation error, using the new JSF 2.2 <code class="literal">resetValues</code> attribute and the <code class="literal">&lt;f:resetValues&gt;</code> tag. Moreover, you saw how to use postback with AJAX, how to determine if a request is AJAX or non-AJAX, customize jsf.js, how to write a progress bar/indicator, how to create the <span class="strong"><strong>Cancel</strong></span>/<span class="strong"><strong>Clear</strong></span> buttons, how to monitor AJAX queue, and so on.</p><p>In conclusion, JSF framework (including major extensions, such as PrimeFaces, OmniFaces, RichFaces, ICEfaces, and so on) has the most comprehensive and easy-to-use AJAX capabilities.</p><p>See you in the next chapter, where we will cover the JSF 2.2 support for HTML5 and the new upload mechanism.</p></div></body></html>