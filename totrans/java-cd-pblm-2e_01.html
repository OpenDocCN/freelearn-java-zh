<html><head></head><body>
  <div id="_idContainer060" class="Basic-Text-Frame">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-14" class="chapterTitle">Text Blocks, Locales, Numbers, and Math</h1>
    <p class="normal">This chapter includes 37 problems covering 4 main topics: text blocks, locales, numbers, and mathematical operations. We will start with text blocks (elegant multiline strings introduced in JDK 13 (JEP 355, preview)/ JDK 15 (JEP 378, final)), continue with problems for creating a Java <code class="inlineCode">Locale</code>, including localized locales (JDK 19’s <code class="inlineCode">ofLocalizedPattern()</code>), and finish with problems about numbers and math, such as the Babylonian method for computing the square root and different corner cases of results overflows. The last part of the chapter is dedicated to JDK 17’s (JEP 356, final) new API for pseudo-random generators.</p>
    <p class="normal">By the end of this chapter, you’ll be up to date with all the new and cool JDK features added that relate to these four topics.</p>
    <div class="note">
      <p class="normal">Throughout this book you will find references to the first edition. The role of these references is to provide you with the best resources for further reading related to certain topics. You can successfully go through this edition even if you haven’t read the first one and don’t intend to.</p>
    </div>
    <h1 id="_idParaDest-15" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your string manipulation, Java locales, and mathematical corner case programming prowess. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Creating a multiline SQL, JSON, and HTML string</strong>: Write a program that declares a multiline string (for instance, SQL, JSON, and HTML strings).</li>
      <li class="numberedList"><strong class="keyWord">Exemplifying the usage of text block delimiters</strong>: Write a program that exemplifies step-by-step how the delimiters of a text block affect the resulting string.</li>
      <li class="numberedList"><strong class="keyWord">Working with indentation in text blocks</strong>: Write a program that exemplifies different techniques to indent a text block. Explain the meaning of <em class="italic">incidental</em> and <em class="italic">essential</em> white spaces.</li>
      <li class="numberedList"><strong class="keyWord">Removing incidental white spaces in text blocks</strong>: Highlight the main steps of the algorithm used by the compiler to remove the <em class="italic">incidental</em> white spaces of a text block.</li>
      <li class="numberedList"><strong class="keyWord">Using text blocks just for readability</strong>: Write a program that creates a string looking like a text block (multiline string) but acts as a single-line string literal.</li>
      <li class="numberedList"><strong class="keyWord">Escaping quotes and line terminators in text blocks</strong>: Write a program that exemplifies how to handle Java escape sequences (including quotes, <code class="inlineCode">\"</code>, and line terminators, <code class="inlineCode">\n</code> and <code class="inlineCode">\r</code>) in a text block.</li>
      <li class="numberedList"><strong class="keyWord">Translating escape sequences programmatically</strong>: Write a program that has programmatic access for translating escape sequences in a text block. Consider that you have a text block containing embedded escape sequences, and you have to pass it to a function that gets a string that must not contain such sequences.</li>
      <li class="numberedList"><strong class="keyWord">Formatting text blocks with variables/expressions</strong>: Write a program that exposes several techniques for formatting text blocks with variables/expressions. Comment on each technique from the readability perspective. Also, provide a <strong class="keyWord">Java Microbenchmark Harness</strong> (<strong class="keyWord">JMH</strong>) benchmark for these techniques.</li>
      <li class="numberedList"><strong class="keyWord">Adding comments in text blocks</strong>: Explain how we can add comments in a text block.</li>
      <li class="numberedList"><strong class="keyWord">Mixing ordinary string literals with text blocks</strong>: Write a program that mixes ordinary string literals with text blocks – for instance, via concatenation. Also, is an ordinary string literal and a text block equal if they have the same content?</li>
      <li class="numberedList"><strong class="keyWord">Mixing regular expression with text blocks</strong>: Write an example of mixing regular expressions that have named groups with text blocks.</li>
      <li class="numberedList"><strong class="keyWord">Checking if two text blocks are isomorphic</strong>: Write a program that checks if two text blocks are isomorphic. Two strings are considered isomorphic if we can map every character of the first string to every character of the second string in a one-to-one fashion (for instance, “xxyznnxiz” and “aavurraqu” are isomorphic).</li>
      <li class="numberedList"><strong class="keyWord">Concatenating strings vs. StringBuilder</strong>: Write a JMH benchmark for comparing string concatenation (via the “<code class="inlineCode">+</code>" operator) with the <code class="inlineCode">StringBuilder</code> approach.</li>
      <li class="numberedList"><strong class="keyWord">Converting int to String</strong>: Write a program that provides several common techniques for converting an <code class="inlineCode">int</code> to a <code class="inlineCode">String</code>. Also, for the proposed solutions, provide a JMH benchmark.</li>
      <li class="numberedList"><strong class="keyWord">Introducing string templates</strong>: Explain and exemplify the usage of JDK 21’s (JEP 430, preview) string templates feature.</li>
      <li class="numberedList"><strong class="keyWord">Writing a custom template processor</strong>: Introduce an API for writing a user-defined template processor. Next, provide a few examples of custom template processors.</li>
      <li class="numberedList"><strong class="keyWord">Creating a Locale</strong>: Write a program that reveals different approaches for creating a <code class="inlineCode">Locale</code>. Also, create <em class="italic">language ranges</em> and <em class="italic">language priority lists</em>.</li>
      <li class="numberedList"><strong class="keyWord">Customizing localized date-time formats</strong>: Write a program that exemplifies the usage of custom localized date-time formats.</li>
      <li class="numberedList"><strong class="keyWord">Restoring always-strict floating-point semantics</strong>: Explain what the <code class="inlineCode">strictfp</code> modifier is and how/where to use it in a Java application.</li>
      <li class="numberedList"><strong class="keyWord">Computing mathematical absolute value for int/long and a result overflow</strong>: Write a program that exemplifies a corner case where applying the mathematical absolute value to an <code class="inlineCode">int</code>/<code class="inlineCode">long</code> leads to a result overflow. Also, provide a solution to this problem.</li>
      <li class="numberedList"><strong class="keyWord">Computing the quotient of the arguments and result overflow</strong>: Write a program that exemplifies a corner case where computing the quotient of the arguments leads to a result overflow. Also, provide a solution to this problem.</li>
      <li class="numberedList"><strong class="keyWord">Computing the largest/smallest value that is less/greater than or equal to the algebraic quotient</strong>: Write a program that relies on <code class="inlineCode">java.util.Math</code> methods to compute the largest/smallest value that is less/greater than or equal to the algebraic quotient. Don’t forget to cover the result overflow corner case as well.</li>
      <li class="numberedList"><strong class="keyWord">Getting integral and fractional parts from a double</strong>: Write a program that exposes several techniques for getting the integral and fractional parts of a <code class="inlineCode">double</code>.</li>
      <li class="numberedList"><strong class="keyWord">Testing if a double number is an integer</strong>: Write a program that shows several approaches for testing if a <code class="inlineCode">double</code> number is an integer. In addition, provide a JMH benchmark for the proposed solutions.</li>
      <li class="numberedList"><strong class="keyWord">Hooking Java (un)signed integers in a nutshell</strong>: Explain and exemplify in code the usage of signed/unsigned integers in Java.</li>
      <li class="numberedList"><strong class="keyWord">Returning the flooring/ceiling modulus</strong>: Define the <em class="italic">floor</em>/<em class="italic">ceil</em> modulus based on the <em class="italic">floor</em> and <em class="italic">ceil </em>operations, and exemplify the result in code lines.</li>
      <li class="numberedList"><strong class="keyWord">Collecting all prime factors of a given number</strong>: A prime number is a number divisible by itself and 1 (for instance, 2, 3, and 5 are prime numbers). Write a program that collects all prime factors of a given positive number.</li>
      <li class="numberedList"><strong class="keyWord">Computing the square root of a number using the Babylonian method</strong>: Explain the Babylonian method for computing the square root, elaborate a step-by-step algorithm for this method, and write the code based on this algorithm.</li>
      <li class="numberedList"><strong class="keyWord">Rounding a float number to specified decimals</strong>: Write a program that contains several approaches for rounding a given <code class="inlineCode">float</code> number to specified decimals.</li>
      <li class="numberedList"><strong class="keyWord">Clamping a value between min and max</strong>: Provide a solution for clamping a given value between a given minimum and maximum.</li>
      <li class="numberedList"><strong class="keyWord">Multiply two integers without using loops, multiplication, bitwise, division, and operators:</strong> Write a program that multiplies two integers without using loops, multiplication, bitwise, division, and operators. For instance, start from the <em class="italic">special binomial product formula</em>.</li>
      <li class="numberedList"><strong class="keyWord">Using TAU</strong>: Explain the meaning of TAU in geometry/trigonometry, and write a program that solves the following problem: A circle has a circumference of 21.33 cm. What is the radius of the circle?</li>
      <li class="numberedList"><strong class="keyWord">Selecting a pseudo-random number generator</strong>: Provide a short dissertation about the new API for generating pseudo-random numbers introduced in JDK 17 (JEP 356, final). Moreover, exemplify different techniques for selecting a pseudo-random number generator.</li>
      <li class="numberedList"><strong class="keyWord">Filling a long array with pseudo-random numbers</strong>: Write a program that fills an array of long arrays with pseudo-random numbers in a parallel and non-parallel fashion.</li>
      <li class="numberedList"><strong class="keyWord">Creating a stream of pseudo-random generators</strong>: Write a program that creates a stream of pseudo-random numbers and a stream of pseudo-random generators.</li>
      <li class="numberedList"><strong class="keyWord">Getting a legacy pseudo-random generator from new ones of JDK 17</strong>: Write a program that instantiates a legacy pseudo-random generator (for instance, <code class="inlineCode">Random</code>) that can delegate method calls to a JDK 17 <code class="inlineCode">RandomGenerator</code>.</li>
      <li class="numberedList"><strong class="keyWord">Using pseudo-random generators in a thread-safe fashion (multithreaded environments)</strong>: Explain and exemplify the usage of pseudo-random generators in a multithreaded environment (for instance, using an <code class="inlineCode">ExecutorService</code>).</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01</span></a>.</p>
    <h1 id="_idParaDest-16" class="heading-1">1. Creating a multiline SQL, JSON, and HTML string</h1>
    <p class="normal">Let’s consider the following SQL multiline string:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">UPDATE</span> "public"."office"
<span class="hljs-keyword">SET</span> ("address_first", "address_second", "phone") <span class="hljs-operator">=</span>
  (<span class="hljs-keyword">SELECT</span> "public"."employee"."first_name",
          "public"."employee"."last_name", ?
   <span class="hljs-keyword">FROM</span> "public"."employee"
   <span class="hljs-keyword">WHERE</span> "public"."employee"."job_title" <span class="hljs-operator">=</span> ?
</code></pre>
    <p class="normal">As is common<a id="_idIndexMarker000"/> knowledge, before JDK <a id="_idIndexMarker001"/>8, we could wrap this SQL as a Java <code class="inlineCode">String</code> (string literal) in<a id="_idIndexMarker002"/> several ways.</p>
    <h2 id="_idParaDest-17" class="heading-2">Before JDK 8</h2>
    <p class="normal">Probably the most common <a id="_idIndexMarker003"/>approach relies on straightforward concatenation via the well-known “<code class="inlineCode">+</code>" operator. This way, we obtain a multiline string representation, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> 
 <span class="hljs-string">"UPDATE \"public\".\"office\"\n"</span>
+ <span class="hljs-string">"SET (\"address_first\", \"address_second\", \"phone\") =\n"</span>
+ <span class="hljs-string">"</span><span class="hljs-string">  (SELECT \"public\".\"employee\".\"first_name\",\n"</span>
+ <span class="hljs-string">"          \"public\".\"employee\".\"last_name\", ?\n"</span>
+ <span class="hljs-string">"   FROM \"public\".\"employee\"\n"</span>
+ <span class="hljs-string">"   WHERE \"public\".\"employee\".\"job_title\" = ?"</span>;
</code></pre>
    <p class="normal">The compiler should be (and usually is) smart enough to internally transform the “<code class="inlineCode">+</code>" operations into a <code class="inlineCode">StringBuilder</code>/<code class="inlineCode">StringBuffer</code> instance and use the <code class="inlineCode">append()</code> method to build the final string. However, we <a id="_idIndexMarker004"/>can use <code class="inlineCode">StringBuilder</code> (not thread-safe) or <code class="inlineCode">StringBuffer</code> (thread-safe) directly, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>();
sql.append(<span class="hljs-string">"UPDATE \"public\".\"office\"\n"</span>)
   .append(<span class="hljs-string">"SET ...\n"</span>)
   .append(<span class="hljs-string">"  (SELECT...\n"</span>)
   ...
</code></pre>
    <p class="normal">Another approach (typically not so popular as the previous two) consists of using the <code class="inlineCode">String.concat()</code> method. This is an immutable operation that basically appends a given string at the end of the current one. Finally, it returns the new combined string. Trying to append <code class="inlineCode">null</code> values results in <code class="inlineCode">NullPointerException</code> (in the previous two examples, we can append <code class="inlineCode">null</code> values without getting any exceptions). Chaining <code class="inlineCode">concat()</code> calls allows us to express multiline strings, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"UPDATE \"public\".\"office\"\n"</span>
  .concat(<span class="hljs-string">"SET...\n"</span>)
  .concat(<span class="hljs-string">"  (SELECT...\n"</span>)
  ...
</code></pre>
    <p class="normal">Furthermore, we have the <code class="inlineCode">String.format()</code> method. By simply using the <code class="inlineCode">%s</code> format specifier, we can concatenate multiple strings (including <code class="inlineCode">null</code> values) in a multiline string, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">"%s%s%s%s%s%s"</span>, 
<span class="hljs-string">  "UPDATE \"public\".\"office\"\n"</span>,
<span class="hljs-string">  "SET ...\n"</span>,
<span class="hljs-string">  "  (SELECT ...\n"</span>,
  ...
</code></pre>
    <p class="normal">While these approaches are still popular these days, let’s see what JDK 8 has to say about this topic.</p>
    <h2 id="_idParaDest-18" class="heading-2">Starting with JDK 8</h2>
    <p class="normal">Starting with JDK 8, we can use the <code class="inlineCode">String.join()</code> method to represent multiline strings. This method is also specialized in string concatenation, and it allows us to have easy readability in our<a id="_idIndexMarker005"/> example. How so? This method takes as the first argument a delimiter, and it uses this between the strings that will be concatenated. So, if we consider that <code class="inlineCode">\n</code> is our line delimiter, then it can be specified only once, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">"\n"</span>
 ,<span class="hljs-string">"UPDATE \"public\".\"office\""</span>
 ,<span class="hljs-string">"SET (\"address_first\", \"address_second\", \"phone\") ="</span>
 ,<span class="hljs-string">"</span><span class="hljs-string">  (SELECT \"public\".\"employee\".\"first_name\","</span>
 ,<span class="hljs-string">"          \"public\".\"employee\".\"last_name\", ?"</span>
 ,<span class="hljs-string">"   FROM \"public\".\"employee\""</span>
 ,<span class="hljs-string">"   WHERE \"public\".\"employee\".\"job_title\" = ?;"</span>);
</code></pre>
    <p class="normal">Beside the <code class="inlineCode">String.join()</code> method, JDK 8 also comes with <code class="inlineCode">java.util.StringJoiner</code>. A <code class="inlineCode">StringJoiner</code> supports a delimiter (as <code class="inlineCode">String.join()</code>) but also supports a prefix and a suffix. Expressing our multiline SQL string doesn’t require a prefix/suffix; therefore, the delimiter remains our favorite feature:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sql</span> = <span class="hljs-keyword">new</span> <span class="hljs-title">StringJoiner</span>(<span class="hljs-string">"\n"</span>);
sql.add(<span class="hljs-string">"UPDATE \"public\".\"office\""</span>)
   .add(<span class="hljs-string">"SET (\"address_first\", ..., \"phone\") ="</span>)
   .add(<span class="hljs-string">"  (SELECT \"public\".\"employee\".\"first_name\","</span>)
   ...
</code></pre>
    <p class="normal">Finally, we cannot mention JDK 8 without touching on its mighty Stream API. More precisely, we are interested in the <code class="inlineCode">Collectors.joining()</code> collector. This collector works as <code class="inlineCode">String.join()</code>, and in our case, it looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> Stream.of(
 <span class="hljs-string">"UPDATE \"public\".\"office\""</span>,
 <span class="hljs-string">"SET (\"address_first\", \"address_second\", \"phone\") ="</span>,
<span class="hljs-string"> "  (SELECT \"public\".\"employee\".\"first_name\","</span>,
 <span class="hljs-string">"          \"public\".\"employee\".\"last_name\", ?"</span>,
 <span class="hljs-string">"   FROM \"public\".\"employee\""</span>,
 <span class="hljs-string">"   WHERE \"public\".\"employee\".\"job_title\" = ?;"</span>)
 .collect(Collectors.joining(String.valueOf(<span class="hljs-string">"\n"</span>)));
</code></pre>
    <p class="normal">All the previous examples have a bunch of shortcomings in common. The most important of these is that none of these examples represents a truly multiline string literal, and the degree of readability is seriously affected by the escaping characters and extra quotes needed for <a id="_idIndexMarker006"/>each line demarcation. Fortunately, starting with JDK 13 (as a future preview) and ending with JDK 15 (as a final feature), the new text blocks have become the standard for representing multiline string literals. Let’s see how.</p>
    <h2 id="_idParaDest-19" class="heading-2">Introducing text blocks (JDK 13/15)</h2>
    <p class="normal">JDK 13 (JEP 355) offers a<a id="_idIndexMarker007"/> preview feature that aims to add support for multiline string literals. Over two versions, in JDK 15 (JEP 378), the text block feature has become final and permanent for use. But that’s enough history; let’s quickly see how text blocks shape our multiline SQL string:</p>
    <pre class="programlisting code"><code class="hljs-code">String sql=<span class="hljs-string">"""</span>
<span class="hljs-string">           UPDATE "public"."office"</span>
<span class="hljs-string">           SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">             (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">                     "public"."employee"."last_name", ?</span>
<span class="hljs-string">              FROM "public"."employee"</span>
<span class="hljs-string">              WHERE "public"."employee"."job_title" = ?"""</span>;
</code></pre>
    <p class="normal">This is so cool, right?! We immediately see that the readability of our SQL has been restored, and we didn’t mess it up with delimiters, line terminators, and concatenations. The text block is concise, easy to update, and easy to understand. The footprint of extra code in our SQL string is zero, and the Java compiler will do the best to create a <code class="inlineCode">String</code> in the most predictable way possible. Here is another example that embeds a piece of JSON information:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">              {</span>
<span class="hljs-string">                "widget": {</span>
<span class="hljs-string">                  "debug": "on",</span>
<span class="hljs-string">                  "window": {</span>
<span class="hljs-string">                    "title": "Sample Widget 1",</span>
<span class="hljs-string">                    "name": "back_window"</span>
<span class="hljs-string">                  },</span>
<span class="hljs-string">                  "image": {</span>
<span class="hljs-string">                    "src": "images\\sw.png"</span>
<span class="hljs-string">                  },</span>
<span class="hljs-string">                  "text": {</span>
<span class="hljs-string">                    "data": "Click Me",</span>
<span class="hljs-string">                    "size": 39</span>
<span class="hljs-string">                  }</span>
<span class="hljs-string">                }</span>
<span class="hljs-string">              }"""</span>;
</code></pre>
    <p class="normal">How about representing a piece of HTML as a text block? Sure, here it is:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">              &lt;table&gt;</span>
<span class="hljs-string">                &lt;tr&gt;</span>
<span class="hljs-string">                  &lt;thcolspan="2"&gt;Name&lt;/th&gt;</span>
<span class="hljs-string">                  &lt;th&gt;Age&lt;/th&gt;</span>
<span class="hljs-string">                &lt;/tr&gt;</span>
<span class="hljs-string">                &lt;tr&gt;</span>
<span class="hljs-string">                  &lt;td&gt;John&lt;/td&gt;</span>
<span class="hljs-string">                  &lt;td&gt;Smith&lt;/td&gt;</span>
<span class="hljs-string">                  &lt;td&gt;22&lt;/td&gt;</span>
<span class="hljs-string">                &lt;/tr&gt;</span>
<span class="hljs-string">              &lt;table&gt;"""</span>;
</code></pre>
    <p class="normal">So what is the syntax of a <a id="_idIndexMarker008"/>text block?</p>
    <h3 id="_idParaDest-20" class="heading-3">Hooking text blocks syntax</h3>
    <p class="normal">The syntax of text blocks is quite simple. No bells and whistles, no complicated things – there are just two aspects to <a id="_idIndexMarker009"/>keep in mind:</p>
    <ul>
      <li class="bulletList">A text block must start with <code class="inlineCode">"""</code> (that is, three double quotation marks) and a newline. We refer to this construction as the <em class="italic">opening delimiter</em>.</li>
      <li class="bulletList">A text block must end with <code class="inlineCode">"""</code> (that is, three double quotation marks). The <code class="inlineCode">"""</code> can be on its own line (as a new line) or at the end of the last line of text (as in our example). We refer to this construction as the <em class="italic">closing delimiter. </em>However, there is a semantic difference between these two approaches (dissected in the next problem).</li>
    </ul>
    <p class="normal">In this context, the following examples are syntactically correct:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">            I'm a text block"""</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">            I'm a text block</span>
<span class="hljs-string">            """</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">            I'm a text block"""</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">            I'm a text block</span>
<span class="hljs-string">            """</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">            I'm a text block</span>
<span class="hljs-string">            """</span>;
</code></pre>
    <p class="normal">On the other hand, the following<a id="_idIndexMarker010"/> examples are incorrect and lead to compiler errors:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""I'm a text block"""</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"I'm a text block"""</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""I'm a text block";</span>
<span class="hljs-string">String tb = ""I'm a text block"""</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""I'm a text block"";</span>
<span class="hljs-string">String tb = ""I'm a text block</span>
<span class="hljs-string">            """</span>;
</code></pre>
    <p class="normal">However, please consider the following best practice.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">By looking on the previous snippets of code, we can shape a best practice for text blocks: use text blocks only when you have a multiline string; if the string fits a single line of code (as in the previous snippets), then use an ordinary string literal, since using text blocks doesn’t add any significant value.</p>
    </div>
    <p class="normal">In the bundled code, you can practice all the examples from this problem on a piece of SQL, JSON, and HTML.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">For third-party library support, please consider Apache Commons, <code class="inlineCode">StringUtils.join()</code>, and Guava’s <code class="inlineCode">Joiner.on()</code>.</p>
    </div>
    <p class="normal">Next, let’s focus on<a id="_idIndexMarker011"/> working with text block delimiters.</p>
    <h1 id="_idParaDest-21" class="heading-1">2. Exemplifying the usage of text block delimiters</h1>
    <p class="normal">Remember from the previous problem, <em class="italic">Creating a multiline SQL, JSON, and HTML string</em>, that a text block is syntactically delimited by an opening and a closing delimiter, represented by three double quotation marks, <code class="inlineCode">"""</code>.</p>
    <p class="normal">The best approach for <a id="_idIndexMarker012"/>exemplifying the usage of these delimiters consists of three simple steps: consider an example, inspect the output, and provide a conclusion. This being said, let’s start with an example that imitates some of the JEP’s examples:</p>
    <pre class="programlisting code"><code class="hljs-code">String sql= <span class="hljs-string">"""</span>
<span class="hljs-string">            UPDATE "public"."office"</span>
<span class="hljs-string">            SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">              (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">                      "public"."employee"."last_name", ?</span>
<span class="hljs-string">               FROM "public"."employee"</span>
<span class="hljs-string">               WHERE "public"."employee"."job_title" = ?)"""</span>;
</code></pre>
    <p class="normal">So by following the JEP examples, we have to align the content with the opening delimiter. It’s probable that this alignment style is not consistent with the rest of our code and is not such a good practice. What will happen with the text block content if we rename the <code class="inlineCode">sql</code> variable <code class="inlineCode">updateSql</code>, <code class="inlineCode">updateOfficeByEmployeeJobTitle</code>, or something else? Obviously, in order to preserve the alignment, this will push our content to the right even more. Fortunately, we can shift-left the content without affecting the final result, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">  UPDATE "public"."office"</span>
<span class="hljs-string">  SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">    (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">            "public"."employee"."last_name", ?</span>
<span class="hljs-string">     FROM "public"."employee"</span>
<span class="hljs-string">     WHERE "public"."employee"."job_title" = ?"""</span>;
</code></pre>
    <p class="normal">Shifting right the opening/closing delimiters themselves will not affect the resulting <code class="inlineCode">String</code>. It is unlikely that you’ll <a id="_idIndexMarker013"/>have a good reason to do this, but just for the sake of completion, the following example produces the same result as the previous two examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span>                                         <span class="hljs-string">"""</span>
<span class="hljs-string">  UPDATE "public"."office"</span>
<span class="hljs-string">  SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">    (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">            "public"."employee"."last_name", ?</span>
<span class="hljs-string">     FROM "public"."employee"</span>
<span class="hljs-string">     WHERE "public"."employee"."job_title" = ?       """</span>;
</code></pre>
    <p class="normal">Now, let’s see something more interesting. The opening delimiter doesn’t accept content on the same line, while the closing delimiter sits to the right at the end of the content. However, what happens if we move the closing delimiter to its own line, as in the following two examples?</p>
    <pre class="programlisting code"><code class="hljs-code">String sql= <span class="hljs-string">""" </span>
<span class="hljs-string">            UPDATE "public"."office"</span>
<span class="hljs-string">            SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">              (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">                      "public"."employee"."last_name", ?</span>
<span class="hljs-string">               FROM "public"."employee"</span>
<span class="hljs-string">               WHERE "public"."employee"."job_title" = ?</span>
<span class="hljs-string">            """</span>;
String sql= <span class="hljs-string">""" </span>
<span class="hljs-string">  UPDATE "public"."office"</span>
<span class="hljs-string">  SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">    (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">            "public"."employee"."last_name", ?</span>
<span class="hljs-string">     FROM "public"."employee"</span>
<span class="hljs-string">     WHERE "public"."employee"."job_title" = ?</span>
<span class="hljs-string">  """</span>;
</code></pre>
    <p class="normal">This time, the resulting string contains a new line at the end of the content. Check the following figure (the text <code class="inlineCode">-- BEFORE TEXT BLOCK –</code> and <code class="inlineCode">-- AFTER TEXT BLOCK --</code> are just guidelines added via <code class="inlineCode">System.out.println()</code> to help you delimit the text block itself; they are not necessary and not part of the text block):</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_01.png" alt="Figure 1.1.png"/></figure>
    <p class="packt_figref">Figure 1.1: Move the closing delimiter to its own line, vertically aligned with the opening delimiter</p>
    <p class="normal">In the left figure (<em class="italic">A</em>) the <a id="_idIndexMarker014"/>closing delimiter is at the end of the content. However, in the right figure (<em class="italic">B</em>), we moved the closing delimiter to its own line, and as you can see, the resulting <code class="inlineCode">String</code> was enriched with a new line at the end.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Placing the closing delimiter on its own line will append a new line to the final <code class="inlineCode">String</code>. Also, pay attention that vertically aligning the opening delimiter, the content, and the closing delimiter to the left margin may result later in extra work. If the variable name is modified, then manual re-indentation is needed to maintain this alignment.</p>
    </div>
    <p class="normal">So pay attention to how you place the closing delimiter.</p>
    <p class="normal">Do you find this weird? Well, that’s not all! In the previous example, the closing delimiter was placed on its own line but vertically aligned with the opening delimiter. Let’s take a step forward and let’s shift-left the end delimiter, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">String sql= <span class="hljs-string">""" </span>
<span class="hljs-string">            UPDATE "public"."office"</span>
<span class="hljs-string">            SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">              (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">                      "public"."employee"."last_name", ?</span>
<span class="hljs-string">               FROM "public"."employee"</span>
<span class="hljs-string">               WHERE "public"."employee"."job_title" = ?</span>
<span class="hljs-string">"""</span>;
</code></pre>
    <p class="normal">The following figure reveals the effect of this action:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_02.png" alt="Figure 1.2.png"/></figure>
    <p class="packt_figref">Figure 1.2: Moving the closing delimiter to its own line and shifting it to the left</p>
    <p class="normal">In the left figure (<em class="italic">A</em>), we have the closing <a id="_idIndexMarker015"/>delimiter on its own line and aligned with the opening delimiter. In the right figure (<em class="italic">B</em>), we have the effect of the previous code. Moving the closing delimiter to the left results in an additional indentation of the content to the right. The additional indentation depends on how much we shift-left the closing delimiter.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Placing the closing delimiter on its own line and shifting it to the left will append a new line and additional indentation to the final <code class="inlineCode">String</code>.</p>
    </div>
    <p class="normal">On the other hand, if we move the closing delimiter to its own line and shift it to the right, it doesn’t affect the final <code class="inlineCode">String</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">String sql= <span class="hljs-string">""" </span>
<span class="hljs-string">            UPDATE "public"."office"</span>
<span class="hljs-string">            SET ("address_first", "address_second", "phone") =</span>
<span class="hljs-string">              (SELECT "public"."employee"."first_name",</span>
<span class="hljs-string">                      "public"."employee"."last_name", ?</span>
<span class="hljs-string">               FROM "public"."employee"</span>
<span class="hljs-string">               WHERE "public"."employee"."job_title" = ?</span>
<span class="hljs-string">                                              """</span>;
</code></pre>
    <p class="normal">This code appends a new line to the final <code class="inlineCode">String</code> but doesn’t affect indentation. In order to better understand the<a id="_idIndexMarker016"/> behavior of opening/closing delimiters, you have to explore the next problem.</p>
    <h1 id="_idParaDest-22" class="heading-1">3. Working with indentation in text blocks</h1>
    <p class="normal">Indentation in text blocks is easy to<a id="_idIndexMarker017"/> understand if we have a clear picture of two terms:</p>
    <ul>
      <li class="bulletList"><em class="italic">Incidental</em> (or <em class="italic">unessential</em>) white spaces – represent the meaningless white spaces that result from code formatting (<em class="italic">leading</em> white spaces commonly added by the IDE) or are added intentionally/accidentally at the end of the text (<em class="italic">trailing</em> white spaces)</li>
      <li class="bulletList"><em class="italic">Essential</em> white spaces – represent the white spaces that we explicitly add, which are meaningful for the final string</li>
    </ul>
    <p class="normal">In <em class="italic">Figure 1.3</em>, you can see the incidental versus essential white spaces in a JSON text block:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_03.png" alt="Figure 1.3.png"/></figure>
    <p class="packt_figref">Figure 1.3: Incidental versus essential white spaces in a JSON text block</p>
    <p class="normal">In the left figure, you can see the incidental versus essential white spaces when the closing delimiter is placed at the end of the content. In the middle figure, the closing delimiter was moved to its own line, while in the right figure, we also shifted to the left.</p>
    <p class="normal">The incidental (unessential) white spaces are automatically removed by the Java compiler. The compiler removes all incidental trailing spaces (to enforce the same look in different text editors, which may automatically remove trailing white spaces) and uses a special internal algorithm (dissected in the next problem) to determine and remove the incidental leading <a id="_idIndexMarker018"/>white spaces. Also, it is important to mention that the line containing the closing delimiter is always part of this <a id="_idIndexMarker019"/>check (this is known as the <em class="italic">significant trailing line policy</em>).</p>
    <p class="normal">The essential white spaces are preserved in the final string. Basically, as you can intuit from the previous figures, the essential white spaces can be added in two ways, as follows:</p>
    <ul>
      <li class="bulletList">By shifting the closing delimiter left (when this delimiter is on its own line)</li>
      <li class="bulletList">By shifting the content right (by explicitly adding white spaces or by using helper methods dedicated to controlling indentation)</li>
    </ul>
    <h2 id="_idParaDest-23" class="heading-2">Shifting the closing delimiter and/or the content</h2>
    <p class="normal">Let’s<a id="_idIndexMarker020"/> start with the <a id="_idIndexMarker021"/>following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">--------------{</span>
<span class="hljs-string">--------------++"widget": {</span>
<span class="hljs-string">--------------++++"debug": "on",</span>
<span class="hljs-string">--------------++++"window": {</span>
<span class="hljs-string">--------------++++++"title": "Sample Widget 1",</span>
<span class="hljs-string">--------------++++++"name": "back_window"</span>
<span class="hljs-string">--------------++++},</span>
<span class="hljs-string">--------------++++"image": {</span>
<span class="hljs-string">--------------++++++"src": "images\\sw.png"</span>
<span class="hljs-string">--------------++++},</span>
<span class="hljs-string">--------------++++"text": {</span>
<span class="hljs-string">--------------++++++"data": "Click Me",</span>
<span class="hljs-string">--------------++++++"size": 39</span>
<span class="hljs-string">--------------++++}</span>
<span class="hljs-string">--------------++}</span>
<span class="hljs-string">--------------}"""</span>;
</code></pre>
    <p class="normal">The white spaces highlighted with the “<code class="inlineCode">–</code>" sign represent incidental leading white spaces (there are no incidental trailing white spaces), while the white spaces highlighted with the “<code class="inlineCode">+</code>" sign represent essential white spaces that you’ll see in the resulting <code class="inlineCode">String</code>. If we shift-right the whole content while the closing delimiter is at the end of the content, then the explicitly added white<a id="_idIndexMarker022"/> spaces are considered incidental and are removed by the compiler:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">----------------------{</span>
<span class="hljs-string">----------------------++"widget": {</span>
<span class="hljs-string">----------------------++++"debug": "on",</span>
<span class="hljs-string">----------------------++++"window": {</span>
<span class="hljs-string">----------------------++++++"title": "Sample Widget 1",</span>
<span class="hljs-string">----------------------++++++"name": "back_window"</span>
<span class="hljs-string">----------------------++++},</span>
<span class="hljs-string">----------------------++++"image": {</span>
<span class="hljs-string">----------------------++++++"src": "images\\sw.png"</span>
<span class="hljs-string">----------------------++++},</span>
<span class="hljs-string">----------------------++++"text": {</span>
<span class="hljs-string">----------------------++++++"data": "Click Me",</span>
<span class="hljs-string">----------------------++++++"size": 39</span>
<span class="hljs-string">----------------------++++}</span>
<span class="hljs-string">----------------------++}</span>
<span class="hljs-string">----------------------}"""</span>;
</code></pre>
    <p class="normal">However, if we move<a id="_idIndexMarker023"/> the closing delimiter to its own line (vertically aligned with the opening delimiter) and shift-right only the content, then we obtain essential white spaces that remain in the final string:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">--------------++++++++{</span>
<span class="hljs-string">--------------++++++++++"widget": {</span>
<span class="hljs-string">--------------++++++++++++"debug": "on",</span>
<span class="hljs-string">--------------++++++++++++"window": {</span>
<span class="hljs-string">--------------++++++++++++++"title": "Sample Widget 1",</span>
<span class="hljs-string">--------------++++++++++++++"name": "back_window"</span>
<span class="hljs-string">--------------++++++++++++},</span>
<span class="hljs-string">--------------++++++++++++"image": {</span>
<span class="hljs-string">--------------++++++++++++++"src": "images\\sw.png"</span>
<span class="hljs-string">--------------++++++++++++},</span>
<span class="hljs-string">--------------++++++++++++"text": {</span>
<span class="hljs-string">--------------++++++++++++++"data": "Click Me",</span>
<span class="hljs-string">--------------++++++++++++++"size": 39</span>
<span class="hljs-string">--------------++++++++++++}</span>
<span class="hljs-string">--------------++++++++++}</span>
<span class="hljs-string">--------------++++++++}</span>
<span class="hljs-string">              """</span>;
</code></pre>
    <p class="normal">Of course, we can add the same essential white spaces by left shifting the closing delimiter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">-------+++++++{</span>
<span class="hljs-string">-------++++++++++"widget": {</span>
<span class="hljs-string">-------++++++++++++"debug": "on",</span>
<span class="hljs-string">-------++++++++++++"window": {</span>
<span class="hljs-string">-------++++++++++++++"title": "Sample Widget 1",</span>
<span class="hljs-string">-------++++++++++++++"name": "back_window"</span>
<span class="hljs-string">-------++++++++++++},</span>
<span class="hljs-string">-------++++++++++++"image": {</span>
<span class="hljs-string">-------++++++++++++++"src": "images\\sw.png"</span>
<span class="hljs-string">-------++++++++++++},</span>
<span class="hljs-string">-------++++++++++++"text": {</span>
<span class="hljs-string">-------++++++++++++++"data": "Click Me",</span>
<span class="hljs-string">-------++++++++++++++"size": 39</span>
<span class="hljs-string">-------++++++++++++}</span>
<span class="hljs-string">-------++++++++++}</span>
<span class="hljs-string">-------++++++++}</span>
<span class="hljs-string">       """</span>;
</code></pre>
    <p class="normal">Moreover, we can adjust each<a id="_idIndexMarker024"/> line of text by manually adding white <a id="_idIndexMarker025"/>spaces, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">--------------{</span>
<span class="hljs-string">--------------++++"widget": {</span>
<span class="hljs-string">--------------++++++++"debug": "on",</span>
<span class="hljs-string">--------------++++++++"window": {</span>
<span class="hljs-string">--------------+++++++++++++++++++++"title": "Sample Widget 1",</span>
<span class="hljs-string">--------------+++++++++++++++++++++"name": "back_window"</span>
<span class="hljs-string">--------------++++++++},</span>
<span class="hljs-string">--------------++++++++"image":  {</span>
<span class="hljs-string">--------------+++++++++++++++++++++"src": "images\\sw.png"</span>
<span class="hljs-string">--------------++++++++},</span>
<span class="hljs-string">--------------++++++++"text":   {</span>
<span class="hljs-string">--------------+++++++++++++++++++++"data": "Click Me",</span>
<span class="hljs-string">--------------+++++++++++++++++++++"size": 39</span>
<span class="hljs-string">--------------++++++++}</span>
<span class="hljs-string">--------------++++}</span>
<span class="hljs-string">--------------}"""</span>;
</code></pre>
    <p class="normal">Next, let’s see some<a id="_idIndexMarker026"/> helper methods useful for indentation <a id="_idIndexMarker027"/>purposes.</p>
    <h2 id="_idParaDest-24" class="heading-2">Using indentation methods</h2>
    <p class="normal">Starting with JDK 12, we can add essential white spaces to a literal string via the <code class="inlineCode">String.indent(int n)</code> method, where <code class="inlineCode">n</code> represents<a id="_idIndexMarker028"/> the number of white spaces. This method can also be applied to indent the whole content of a text block, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">--------------********{</span>
<span class="hljs-string">--------------********++"widget": {</span>
<span class="hljs-string">--------------********++++"debug": "on",</span>
<span class="hljs-string">--------------********++++"window": {</span>
<span class="hljs-string">--------------********++++++"title": "Sample Widget 1",</span>
<span class="hljs-string">--------------********++++++"name": "back_window"</span>
<span class="hljs-string">--------------********++++},</span>
<span class="hljs-string">--------------********++++"image": {</span>
<span class="hljs-string">--------------********++++++"src": "images\\sw.png"</span>
<span class="hljs-string">--------------********++++},</span>
<span class="hljs-string">--------------********++++"text": {</span>
<span class="hljs-string">--------------********++++++"data": "Click Me",</span>
<span class="hljs-string">--------------********++++++"size": 39</span>
<span class="hljs-string">--------------********++++}</span>
<span class="hljs-string">--------------********++}</span>
<span class="hljs-string">--------------********}"""</span>.indent(<span class="hljs-number">8</span>);
</code></pre>
    <p class="normal">Obviously, the white spaces added via <code class="inlineCode">indent()</code> are not visible in the code editor of the IDE, but they are highlighted here via the “<code class="inlineCode">*</code>" sign, just to illustrate the effect on the final string. However, when <code class="inlineCode">indent()</code> is used, a new line is also appended, even if the closing delimiter is at the end of the content. In this context, moving the closing delimiter to its own line results in the same effect, so don’t expect to see two new lines appended. Of course, feel free to practice the bundled code for the real experience.</p>
    <p class="normal">The <code class="inlineCode">indent()</code> method may be useful to align a block of content that contains lines of text placed at the same level of indentation, like the poem that follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">              I would want to establish strength; root-like,</span>
<span class="hljs-string">              anchored in the hopes of solidity.</span>
<span class="hljs-string">              Forsake the contamination of instability.</span>
<span class="hljs-string">              Prove I'm the poet of each line of prose."""</span>;
</code></pre>
    <p class="normal">If we manually add white spaces in front of each line of the poem, then the compiler will remove them, so no essential white spaces could be added globally. We can move the closing delimiter to its own line and shift it to the left, or shift-right the content to obtain the desired essential white spaces. However, in such a case, you still need to remove the new line that is <a id="_idIndexMarker029"/>added (as a result of moving the closing delimiter to its own line). The easiest way to do this is via the JDK 14 new escape sequence, <code class="inlineCode">\</code>. By adding this escape sequence at the end of a line, we instruct the compiler to suppress appending a new line character to that line:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">              I would want to establish strength; root-like,</span>
<span class="hljs-string">              anchored in the hopes of solidity.</span>
<span class="hljs-string">              Forsake the contamination of instability.</span>
<span class="hljs-string">              Prove I'm the poet of each line of prose.\</span>
<span class="hljs-string">   """</span>;
</code></pre>
    <p class="normal">While this escape sequence (<code class="inlineCode">\</code>) is dissected in Problem 5,<em class="italic"> Using text block just for readability</em>, let’s see a few approaches based on a string API.</p>
    <p class="normal">Before JDK 11, we can remove this line via a simple regular expression such as <code class="inlineCode">replaceFirst("\\s++$", "")</code>, or rely on a third-party helper such as the Apache Commons <code class="inlineCode">StringUtils.stripEnd()</code> method. However, starting with JDK 11, we can achieve this goal via <code class="inlineCode">String.stripTrailing()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">              I would want to establish strength; root-like,</span>
<span class="hljs-string">              anchored in the hopes of solidity.</span>
<span class="hljs-string">              Forsake the contamination of instability.</span>
<span class="hljs-string">              Prove I'm the poet of each line of prose.</span>
<span class="hljs-string">   """</span>.stripTrailing();
</code></pre>
    <p class="normal">Now, the content block is indented as a result of shifting the closing delimiter left, and the automatically added new line is removed thanks to the <code class="inlineCode">stripTrailing()</code> method.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">As well as <code class="inlineCode">stripTrailing()</code>, JDK 11 also comes with <code class="inlineCode">stripLeading()</code> and <code class="inlineCode">strip()</code>. Also, starting with JDK 15, we have <code class="inlineCode">stripIndent()</code>, which removes the leading and trailing white spaces exactly as the compiler does.</p>
    </div>
    <p class="normal">However, starting with JDK 12, we can use <code class="inlineCode">String.indent(int n)</code>, which saves us from adding white spaces<a id="_idIndexMarker030"/> manually:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">              I would want to establish strength; root-like,</span>
<span class="hljs-string">              anchored in the hopes of solidity.</span>
<span class="hljs-string">              Forsake the contamination of instability.</span>
<span class="hljs-string">              Prove I'm the poet of each line of prose."""</span>
  .indent(<span class="hljs-number">6</span>)
  .stripTrailing();
</code></pre>
    <p class="normal">Now, it is time to move forward and dissect the algorithm for removing incidental white spaces.</p>
    <h1 id="_idParaDest-25" class="heading-1">4. Removing incidental white spaces in text blocks</h1>
    <p class="normal">Removing incidental white <a id="_idIndexMarker031"/>spaces in text blocks is typically a job accomplished by the compiler via a special algorithm. To understand the main aspects of this algorithm, let’s go over it with the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""                     |Compiler:</span>
<span class="hljs-string">----{                                 |Line 01: 4  lws</span>
<span class="hljs-string">----++"widget": {                     |Line 02: 6  lws</span>
<span class="hljs-string">----++++"debug": "on",                |Line 03: 8  lws</span>
<span class="hljs-string">----++++"window": {                   |Line 04: 8  lws</span>
<span class="hljs-string">----++++++"title": "Sample Widget 1", |Line 05: 10 lws</span>
<span class="hljs-string">----++++++"name": "back_window"       |Line 06: 10 lws</span>
<span class="hljs-string">----++++},                            |Line 07: 8  lws</span>
<span class="hljs-string">----++++"image": {                    |Line 08: 8  lws</span>
<span class="hljs-string">----++++++"src": "images\\sw.png"     |Line 09: 10 lws</span>
<span class="hljs-string">----++++},                            |Line 10: 8  lws</span>
<span class="hljs-string">----++++"text": {                     |Line 11: 8  lws</span>
<span class="hljs-string">----++++++"data": "Click Me",         |Line 12: 10 lws</span>
<span class="hljs-string">----++++++"size": 39                  |Line 13: 10 lws</span>
<span class="hljs-string">----++++}                             |Line 14: 8  lws</span>
<span class="hljs-string">----++}                               |Line 15: 6  lws</span>
<span class="hljs-string">----}                                 |Line 16: 4  lws</span>
<span class="hljs-string">----"""</span>;                              |Line <span class="hljs-number">17</span>: <span class="hljs-number">4</span>  lws
</code></pre>
    <p class="normal">We are especially interested in removing the incidental leading white spaces represented in the previous snippet of code, via the “<code class="inlineCode">–</code>" sign.</p>
    <p class="normal">To remove the incidental leading white spaces, the compiler has to inspect all non-blank lines (lines containing only white spaces), so in our case, it will inspect 17 lines. There are 16 lines of JSON code and the closing delimiter line.</p>
    <p class="normal">The compiler scans each of these 17 lines and counts the number of leading white spaces. The character used to represent the white space is not relevant in this count – it could be simple space, tab, and so on. They all have the same weight of 1, so a single white space is the same as <a id="_idIndexMarker032"/>a single tab. This is needed because the compiler can’t know how tab characters will be displayed in different text editors (for instance, a tab could be made of four or eight characters). Once this step of the algorithm is done, the compiler knows the exact number of leading white spaces for each of the inspected lines. For instance, line 1 has 4 <strong class="keyWord">leading white spaces</strong> (<strong class="keyWord">lws</strong>), line 2 has 6 lws, line 3 has 8 lws, and so on (check the previous snippet of code to see all the numbers).</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Let’s quickly look at another text block best practice: Don’t mix white spaces and tabs in the same text block. This way, you enforce indentation consistency and avoid any potential irregular indentation.</p>
    </div>
    <p class="normal">At this point, the compiler computes the minimum value of those numbers, and the result (in this case, 4) represents the number of incidental leading white spaces that should be removed from each of the 17 lines. So in the final result, at least one of the lines has no leading white space. Of course, the essential white space (an additional indentation represented via the “<code class="inlineCode">+</code>" sign) remains untouched. For instance, in line 5, we have 10 lws – 4 incidental lws = 6 essential lws that remain untouched.</p>
    <p class="normal">In the bundled code, you can find three more JSON examples that you can use to practice this algorithm. Now, we will tackle some text block readability aspects.</p>
    <h1 id="_idParaDest-26" class="heading-1">5. Using text blocks just for readability</h1>
    <p class="normal">Using text blocks just for readability can be translated as making a string look like a text block but act as a single-line string literal. This is especially useful for formatting long lines of text. For instance, we may <a id="_idIndexMarker033"/>want to have the following SQL string look like a text block (for readability purposes) but act as a single-line string literal (in the sense of being compact when we pass it to the database):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">SELECT</span> "public"."employee"."first_name"
<span class="hljs-keyword">FROM</span> "public"."employee" 
<span class="hljs-keyword">WHERE</span> "public"."employee"."job_title" <span class="hljs-operator">=</span> ?
</code></pre>
    <p class="normal">Starting with JDK 14, we can accomplish this goal via the new escape sequence, <code class="inlineCode">\</code> (a single backslash). By adding this escape sequence at the end of a line, we instruct the compiler to suppress appending a new line character to that line. So in our case, we can express the SQL as a single-line string literal, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             SELECT "public"."employee"."first_name" \</span>
<span class="hljs-string">             FROM "public"."employee" \</span>
<span class="hljs-string">             WHERE "public"."employee"."job_title" = ?\</span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">Pay attention to not adding any white spaces after <code class="inlineCode">\</code> because you’ll get an error.</p>
    <p class="normal">If we throw this text block in a <code class="inlineCode">System.out.println()</code>, then the output reveals the single-line string literal, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">SELECT</span> "public"."employee"."first_name" <span class="hljs-keyword">FROM</span> "public"."employee" <span class="hljs-keyword">WHERE</span> "public"."employee"."job_title" <span class="hljs-operator">=</span> ?
</code></pre>
    <p class="normal">Next, let’s check out another example, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">  UPDATE "public"."office" \</span>
<span class="hljs-string">  SET ("address_first", "address_second", "phone") = \</span>
<span class="hljs-string">    (SELECT "public"."employee"."first_name", \</span>
<span class="hljs-string">            "public"."employee"."last_name", ? \</span>
<span class="hljs-string">     FROM "public"."employee" \</span>
<span class="hljs-string">     WHERE "public"."employee"."job_title" = ?\</span>
<span class="hljs-string">  """</span>;
</code></pre>
    <p class="normal">This time, the resulting string is not exactly what we want because the essential white space is preserved. This means that the single-line string is sprinkled with sequences of spaces that we should reduce to a single space. This is where a regular expression can help:</p>
    <pre class="programlisting code"><code class="hljs-code">sql.<span class="hljs-built_in">trim</span>().replaceAll(" +", " ");
</code></pre>
    <p class="normal">Done! Now, we have a single-line SQL string that looks like a text block in an IDE.</p>
    <p class="normal">Next, let’s assume that <a id="_idIndexMarker034"/>we want to print on a nice background the following poem wrapped in a text block:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">                 An old silent pond...</span>
<span class="hljs-string">              A frog jumps into the pond,</span>
<span class="hljs-string">                 splash!! Silence again.</span>
<span class="hljs-string">              """</span>;
</code></pre>
    <p class="normal">Adding a background to this poem will result in something like the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_04.png" alt="Figure 1.4.png"/></figure>
    <p class="packt_figref">Figure 1.4: Adding a background to the poem</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong> </p>
      <p class="normal">The colored background is just a guideline for alignment, as white on white would not be legible.</p>
    </div>
    <p class="normal">Since the compiler removes the trailing white space, we will obtain something as shown in the left figure. Obviously, we want something as shown in the right figure, so we need to find a way to preserve the trailing white space as essential. Starting with JDK 14, we can do that via the new escape sequence, <code class="inlineCode">\s</code>. </p>
    <p class="normal">We can repeat this escape sequence for every space as follows (we add three white spaces to the first line and two white spaces to the last line; this way, we obtain a symmetrical text block):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">                 An old silent pond...\s\s\s</span>
<span class="hljs-string">              A frog jumps into the pond,</span>
<span class="hljs-string">                splash!! Silence again.\s\s</span>
<span class="hljs-string">              """</span>;    
</code></pre>
    <p class="normal">Alternatively, we can manually add white spaces and a single <code class="inlineCode">\s</code> at the end of the line. This is possible because the compiler preserves any white spaces in front of <code class="inlineCode">\s</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">                 An old silent pond...  \s</span>
<span class="hljs-string">              A frog jumps into the pond,</span>
<span class="hljs-string">                splash!! Silence again. \s</span>
<span class="hljs-string">              """</span>;
</code></pre>
    <p class="normal">Done! Now, we have preserved white spaces, so when the background color is applied, we will obtain something<a id="_idIndexMarker035"/> as shown on the right side of <em class="italic">Figure 1.4</em>.</p>
    <p class="normal">Next, let’s focus on escaping characters.</p>
    <h1 id="_idParaDest-27" class="heading-1">6. Escaping quotes and line terminators in text blocks</h1>
    <p class="normal">Escaping double quotes is <a id="_idIndexMarker036"/>necessary only when we want to embed, in the text block, the sequence of three double quotes (<code class="inlineCode">"""</code>), as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             She told me </span>
<span class="hljs-string">                    \"""I have no idea what's going on\""" </span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">Escaping <code class="inlineCode">"""</code> can be done with <code class="inlineCode">\"""</code>. There is no need to write <code class="inlineCode">\"\"\"</code>.</p>
    <p class="normal">The resulting string will look like this:</p>
    <pre class="programlisting con"><code class="hljs-con">She told me
        """I have no idea what's going on"""
</code></pre>
    <p class="normal">Whenever you need to embed <code class="inlineCode">"</code> or <code class="inlineCode">""</code>, simply do it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             She told me </span>
<span class="hljs-string">                     "I have no idea what's going on"</span>
<span class="hljs-string">             """</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             She told me </span>
<span class="hljs-string">                     ""I have no idea what's going on"" </span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">So even if it works, don’t <a id="_idIndexMarker037"/>do this, since is not necessary:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             She told me </span>
<span class="hljs-string">                     \"I have no idea what's going on\"</span>
<span class="hljs-string">             """</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             She told me </span>
<span class="hljs-string">                     \"\"I have no idea what's going on\"\" </span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">However, a construction such as <code class="inlineCode">""""</code> (where the first <code class="inlineCode">"</code> represents a double quote and the last <code class="inlineCode">"""</code> represents the closing delimiter of the text block) will raise an error. In such a case, you can place a space as <code class="inlineCode">" """</code> or escape the double quote as <code class="inlineCode">\""""</code>.</p>
    <p class="normal">By definition, a text block represents string literals spanning multiple lines, so there is no need to explicitly escape line terminators (new lines), such as <code class="inlineCode">\n</code>, <code class="inlineCode">\r</code>, or <code class="inlineCode">\f</code>. Just add new lines of text in the text block, and the compiler will take care of line terminators. Of course, this doesn’t mean that using them doesn’t work. For instance, obtaining a text block that has interleaved blank lines can be done via <code class="inlineCode">\n</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             SELECT "public"."employee"."first_name",\n</span>
<span class="hljs-string">                    "public"."employee"."last_name", ?\n</span>
<span class="hljs-string">             FROM "public"."employee"\n</span>
<span class="hljs-string">             WHERE "public"."employee"."job_title" = ?</span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">Using escape sequences (for example, <code class="inlineCode">\b</code>, <code class="inlineCode">\t</code>, <code class="inlineCode">\r</code>, <code class="inlineCode">\n</code>, <code class="inlineCode">\f</code>, and so on) in text blocks can be done exactly like they would be done in old-school string literals. For instance, there is nothing wrong here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">               \b\bShe told me\n</span>
<span class="hljs-string">             \t""I have no idea what's going on"" </span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">However, the same thing <a id="_idIndexMarker038"/>can be obtained without escape sequences (consider <code class="inlineCode">\t</code> (tab) as eight white spaces):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             She told me</span>
<span class="hljs-string">                    ""I have no idea what's going on"" </span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">You can practice all these examples in the bundled code.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Let’s quickly look at another text block best practice: Adding escape sequences explicitly may negatively affect the readability of the text block, so use them carefully and only when they are really needed. For instance, explicit <code class="inlineCode">\n</code> and <code class="inlineCode">\"</code> are rarely necessary for text blocks.</p>
    </div>
    <p class="normal">Speaking about the <code class="inlineCode">\n</code> line terminator (new line), it is important to be aware of the following note.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Probably the most used line<a id="_idIndexMarker039"/> terminator in Java is <code class="inlineCode">\n</code> (Unix, <strong class="keyWord">Line Feed</strong> (<strong class="keyWord">LF</strong>)), but we can also use <code class="inlineCode">\r</code> (Windows, <strong class="keyWord">Carriage Return</strong> (<strong class="keyWord">CR</strong>)) or <code class="inlineCode">\n\r</code> (Windows, <strong class="keyWord">Carriage Return Line Feed</strong> (<strong class="keyWord">CRLF</strong>)). No <a id="_idIndexMarker040"/>matter which of these we prefer, Java text blocks always use <code class="inlineCode">\n</code> (LF). First, the compiler normalizes all line breaks<a id="_idIndexMarker041"/> that are not added explicitly via escape sequences to <code class="inlineCode">\n</code> (LF). Second, after the normalization of line terminators and managed indentation, the compiler handles all the explicit escape sequences (<code class="inlineCode">\n</code> (LF), <code class="inlineCode">\f</code> (FF), <code class="inlineCode">\r</code>(CR), and so on), as in any string literal. Practically, this allows us to copy into a text block a legacy Java string containing escape sequences, obtaining the expected result without further modifications.</p>
    </div>
    <p class="normal">If you ever need to use the line terminator specific to your operating system, then you have to explicitly replace it after text block normalization via <code class="inlineCode">String.replaceAll()</code>, as <code class="inlineCode">String::replaceAll("\n", System.lineSeparator()</code>).</p>
    <p class="normal">Embedding in a text<a id="_idIndexMarker042"/> block an escape sequence can be done as usual via the <code class="inlineCode">\\</code> construction. Here is an example of embedding the <code class="inlineCode">\"</code> escape sequence as <code class="inlineCode">\\"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">  SELECT \\"public\\".\\"employee\\".\\"first_name\\",   </span>
<span class="hljs-string">         \\"public\\".\\"employee\\".\\"last_name\\", ?</span>
<span class="hljs-string">  FROM \\"public\\".\\"employee\\"</span>
<span class="hljs-string">  WHERE \\"public\\".\\"employee\\".\\"job_title\\" = ?</span>
<span class="hljs-string">  """</span>;
</code></pre>
    <p class="normal">You can check the output in the bundled code. Now, let’s see how we can translate escape sequences programmatically.</p>
    <h1 id="_idParaDest-28" class="heading-1">7. Translating escape sequences programmatically</h1>
    <p class="normal">We already know that the compiler is responsible for the translation of escape sequences, and most of the time, there is no <a id="_idIndexMarker043"/>need to explicitly interfere in this process. But there are cases when we may need programmatic access to this process (for instance, to explicitly un-escape a string before passing it to a function).</p>
    <p class="normal">Starting with JDK 15, we can accomplish this via <code class="inlineCode">String.translateEscapes()</code>, which is capable of un-escape sequences such as <code class="inlineCode">\t</code>, <code class="inlineCode">\n</code>, <code class="inlineCode">\b</code>, and so on, and octal numbers (<code class="inlineCode">\0</code>–<code class="inlineCode">\377</code>). However, this method doesn’t translate Unicode escapes (<code class="inlineCode">\uXXXX</code>).</p>
    <p class="normal">We can perform an equality test in order to reveal how <code class="inlineCode">translateEscapes()</code> works:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">newline</span> <span class="hljs-operator">=</span> <span class="hljs-string">"\\n"</span>.translateEscapes();
System.out.println((<span class="hljs-string">"\n"</span>.equals(newline)) ? <span class="hljs-string">"yes"</span> : <span class="hljs-string">"no"</span>);
</code></pre>
    <p class="normal">As you can already intuit, the result is <em class="italic">yes</em>.</p>
    <p class="normal">Next, let’s assume that we want to use an external service that prints addresses on parcels. The function responsible for this task gets a string representing the address without containing escape sequences. The problem is that our customer’s addresses pass through a formatting process that patches them with escape sequences, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">                 JASON MILLER (\\"BIGBOY\\")\\n</span>
<span class="hljs-string">                 \\tMOUNT INC\\n</span>
<span class="hljs-string">                 \\t104 SEAL AVE\\n</span>
<span class="hljs-string">                 \\tMIAMI FL 55334 1200\\n</span>
<span class="hljs-string">                 \\tUSA</span>
<span class="hljs-string">                 """</span>;
</code></pre>
    <p class="normal">The following figure reveals how the resulting string will look if we don’t translate escapes of the address (left side) and <a id="_idIndexMarker044"/>how it will look if we do (right side). Of course, our goal is to obtain the address from the right side and send it to print:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_05.png" alt="Figure 1.5.png"/></figure>
    <p class="packt_figref">Figure 1.5: We want the string from the right side </p>
    <p class="normal">Translation of escapes can be done programmatically via <code class="inlineCode">String.translateEscapes()</code>, right before sending the result to the external service. Here is the code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">translatedAddress</span> <span class="hljs-operator">=</span> address.translateEscapes();
</code></pre>
    <p class="normal">Now, <code class="inlineCode">translatedAddress</code> can be passed to the external printing service. As an exercise, you can think about how to exploit this method to write a parser of source code, provided via Java or another programming language.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Similar results (of course, read the documentation to obtain the fine-grained information) can be obtained via Apache Commons’ Lang third-party library support. Please consider <code class="inlineCode">StringEscapeUtils.unescapeJava(String)</code>.</p>
    </div>
    <p class="normal">Next, let’s talk about embedding expressions in text blocks.</p>
    <h1 id="_idParaDest-29" class="heading-1">8. Formatting text blocks with variables/expressions</h1>
    <p class="normal">In Java, it is a common practice to format string literals with variables/expressions to obtain dynamic strings. For instance, we can <a id="_idIndexMarker045"/>create a dynamic piece <a id="_idIndexMarker046"/>of XML string via the following well-known concatenation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">fn</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Jo"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">ln</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Kym"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"&lt;user&gt;&lt;firstName&gt;"</span> + fn
  + <span class="hljs-string">"&lt;/firstName&gt;&lt;lastName&gt;"</span> + ln + <span class="hljs-string">"&lt;/lastName&gt;&lt;/user&gt;"</span>;
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">// output
&lt;user&gt;&lt;firstName&gt;Jo&lt;/firstName&gt;&lt;lastName&gt;Kym&lt;/lastName&gt;&lt;/user&gt;
</code></pre>
    <p class="normal">Of course, this tiny construction has serious issues from a readability perspective. XML code is human-readable if it is formatted and indented accordingly; otherwise, is really hard to follow its hierarchy. So, can we express this XML to look like the following figure?</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_06.png" alt="Figure 1.6.png"/></figure>
    <p class="packt_figref">Figure 1.6: Formatted XML</p>
    <p class="normal">Sure we can! By using some escape sequences (for instance, <code class="inlineCode">\n</code>, <code class="inlineCode">\t</code>, and <code class="inlineCode">\s</code>), white spaces, and so on, we can construct a <code class="inlineCode">String</code> to look like <em class="italic">Figure 1.6</em>. However, it would be better to express this concatenation via a text block. Maybe we can achieve the same readability in the IDE’s code editor and console (at runtime). A possible approach looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">            &lt;user&gt;</span>
<span class="hljs-string">               &lt;firstName&gt;\</span>
<span class="hljs-string">            """</span>
        + fn
        + <span class="hljs-string">"""</span>
<span class="hljs-string">             &lt;/firstName&gt;</span>
<span class="hljs-string">                &lt;lastName&gt;\</span>
<span class="hljs-string">             """</span>
         + ln
         + <span class="hljs-string">"""</span>
<span class="hljs-string">             &lt;/lastName&gt;</span>
<span class="hljs-string">             &lt;/user&gt;</span>
<span class="hljs-string">             """</span>;
</code></pre>
    <p class="normal">So we can concatenate text blocks exactly like string literals via the “<code class="inlineCode">+</code>" operator. Cool! The output of this code <a id="_idIndexMarker047"/>corresponds to the left side of <em class="italic">Figure 1.6</em>. On the<a id="_idIndexMarker048"/> other hand, the right side of <em class="italic">Figure 1.6</em> can be achieved as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">            &lt;user&gt;</span>
<span class="hljs-string">               &lt;firstName&gt;</span>
<span class="hljs-string">            """</span>
        + fn.indent(<span class="hljs-number">4</span>)
        + <span class="hljs-string">"""</span>
<span class="hljs-string">               &lt;/firstName&gt;</span>
<span class="hljs-string">               &lt;lastName&gt;</span>
<span class="hljs-string">            """</span>
        + ln.indent(<span class="hljs-number">4</span>)
        + <span class="hljs-string">"""</span>
<span class="hljs-string">               &lt;/lastName&gt;</span>
<span class="hljs-string">            &lt;/user&gt;</span>
<span class="hljs-string">            """</span>;
</code></pre>
    <p class="normal">Well, while the resulting string looks good in both cases, we cannot say the same thing about the code itself. It still has a low readability rate.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">By looking at the previous two snippets of code, we can easily conclude a best practice for text blocks: use them only when they significantly contribute to code clarity and the readability of multiline strings. Also, avoid declaring text blocks in complex expressions (for instance, in lambda expressions), since they may affect the readability of the entire expression. It is better to extract text blocks separately in static variables and refer to them in complex expressions.</p>
    </div>
    <p class="normal">Let’s try another <a id="_idIndexMarker049"/>approach. This time, let’s <a id="_idIndexMarker050"/>use a <code class="inlineCode">StringBuilder</code> to obtain the result from the left side of <em class="italic">Figure 1.6</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sbXml</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>();
sbXml.append(<span class="hljs-string">"""</span>
<span class="hljs-string">            &lt;user&gt;</span>
<span class="hljs-string">               &lt;firstName&gt;"""</span>)
       .append(fn)
       .append(<span class="hljs-string">"""</span>
<span class="hljs-string">               &lt;/firstName&gt;</span>
<span class="hljs-string">                  &lt;lastName&gt;"""</span>)
       .append(ln)
       .append(<span class="hljs-string">"""</span>
<span class="hljs-string">            &lt;/lastName&gt;</span>
<span class="hljs-string">            &lt;/user&gt;"""</span>);
</code></pre>
    <p class="normal">Then, obtaining the result from the right side of <em class="italic">Figure 1.6</em> can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sbXml</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>();
sbXml.append(<span class="hljs-string">"""</span>
<span class="hljs-string">            &lt;user&gt;</span>
<span class="hljs-string">               &lt;firstName&gt;</span>
<span class="hljs-string">            """</span>)
      .append(fn.indent(<span class="hljs-number">4</span>))
      .append(<span class="hljs-string">"""</span>
<span class="hljs-string">             &lt;/firstName&gt;</span>
<span class="hljs-string">             &lt;lastName&gt;</span>
<span class="hljs-string">           """</span>)
      .append(ln.indent(<span class="hljs-number">4</span>))
      .append(<span class="hljs-string">"""</span>
<span class="hljs-string">             &lt;/lastName&gt;</span>
<span class="hljs-string">           &lt;/user&gt;</span>
<span class="hljs-string">           """</span>);
</code></pre>
    <p class="normal">So we can use text blocks in <code class="inlineCode">StringBuilder</code>/<code class="inlineCode">StringBuffer</code> exactly as we use string literals. While the resulting<a id="_idIndexMarker051"/> string corresponds to the examples from <em class="italic">Figure 1.6</em>, the code itself is still <a id="_idIndexMarker052"/>unsatisfactory from the readability perspective.</p>
    <p class="normal">Let’s give it another try via the JDK 1.4, <code class="inlineCode">MessageFormat.format()</code>. First, let’s shape the example from <em class="italic">Figure 1.6</em>, left side:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> MessageFormat.format(<span class="hljs-string">"""</span>
<span class="hljs-string">                           &lt;user&gt;</span>
<span class="hljs-string">                               &lt;firstName&gt;{0}&lt;/firstName&gt;</span>
<span class="hljs-string">                               &lt;lastName&gt;{1}&lt;/lastName&gt;</span>
<span class="hljs-string">                           &lt;/user&gt;</span>
<span class="hljs-string">                           """</span>, fn, ln);
</code></pre>
    <p class="normal">And obtaining the result from <em class="italic">Figure 1.6</em> (right side) can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> MessageFormat.format(<span class="hljs-string">"""</span>
<span class="hljs-string">                           &lt;user&gt;</span>
<span class="hljs-string">                               &lt;firstName&gt;</span>
<span class="hljs-string">                                {0}</span>
<span class="hljs-string">                               &lt;/firstName&gt;</span>
<span class="hljs-string">                               &lt;lastName&gt;</span>
<span class="hljs-string">                                {1}</span>
<span class="hljs-string">                               &lt;/lastName&gt;</span>
<span class="hljs-string">                           &lt;/user&gt;</span>
<span class="hljs-string">                           """</span>, fn, ln);
</code></pre>
    <p class="normal">The text blocks and <code class="inlineCode">MessageFormat.format()</code> combo is a winning approach. The code readability is obviously better. But, let’s go further, and let’s give it a try in JDK 5 <code class="inlineCode">String.format()</code>. As usual, <em class="italic">Figure 1.6</em> (left side) is first:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">"""</span>
<span class="hljs-string">                           &lt;user&gt;</span>
<span class="hljs-string">                               &lt;firstName&gt;%s&lt;/firstName&gt;</span>
<span class="hljs-string">                               &lt;lastName&gt;%s&lt;/lastName&gt;</span>
<span class="hljs-string">                           &lt;/user&gt;</span>
<span class="hljs-string">                           """</span>, fn, ln);
</code></pre>
    <p class="normal">And obtaining the result from <em class="italic">Figure 1.6</em> (right side) can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">"""</span>
<span class="hljs-string">                           &lt;user&gt;</span>
<span class="hljs-string">                               &lt;firstName&gt;</span>
<span class="hljs-string">                                %s</span>
<span class="hljs-string">                               &lt;/firstName&gt;</span>
<span class="hljs-string">                               &lt;lastName&gt;</span>
<span class="hljs-string">                                %s</span>
<span class="hljs-string">                               &lt;/lastName&gt;</span>
<span class="hljs-string">                           &lt;/user&gt;</span>
<span class="hljs-string">                           """</span>, fn, ln);
</code></pre>
    <p class="normal">The text blocks and <code class="inlineCode">String.format()</code> combo is another winning approach but is not the latest feature that we <a id="_idIndexMarker053"/>can exploit. Starting with JDK 15, <code class="inlineCode">String.format()</code> has a <a id="_idIndexMarker054"/>more convenient companion named <code class="inlineCode">formatted()</code>. Here is <code class="inlineCode">String.formatted()</code> at work to reproduce <em class="italic">Figure 1.6</em> (left side):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             &lt;user&gt;</span>
<span class="hljs-string">                 &lt;firstName&gt;%s&lt;/firstName&gt;</span>
<span class="hljs-string">                 &lt;lastName&gt;%s&lt;/lastName&gt;</span>
<span class="hljs-string">             &lt;/user&gt;</span>
<span class="hljs-string">             """</span>.formatted(fn, ln);
</code></pre>
    <p class="normal">And obtaining the result from <em class="italic">Figure 1.6</em> (right side) can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             &lt;user&gt;</span>
<span class="hljs-string">                 &lt;firstName&gt;</span>
<span class="hljs-string">                  %s</span>
<span class="hljs-string">                 &lt;/firstName&gt;</span>
<span class="hljs-string">                 &lt;lastName&gt;</span>
<span class="hljs-string">                  %s</span>
<span class="hljs-string">                 &lt;/lastName&gt;</span>
<span class="hljs-string">             &lt;/user&gt;</span>
<span class="hljs-string">             """</span>.formatted(fn, ln);
</code></pre>
    <p class="normal">That is the best we can do. We managed to achieve the same level of readability in the IDE’s code editor and runtime for a text block containing dynamic parts (variables). Cool, isn’t it?!</p>
    <p class="normal">From the performance perspective, you can find a benchmark of these approaches in the bundled code. In the following figure, you can see the results of this benchmark on an Intel<sup class="superscript">®</sup> Core<sup class="superscript">™</sup> i7-3612QM CPU @ 2.10GHz machine with Windows 10, but feel free to test it on different machines, since the<a id="_idIndexMarker055"/> results are highly dependent on the machine.</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_07.png" alt="Figure 1.7.png"/></figure>
    <p class="packt_figref">Figure 1.7: Benchmark results</p>
    <p class="normal">Conforming to these <a id="_idIndexMarker056"/>results, concatenation via the “<code class="inlineCode">+</code>" operator is the fastest, while the <code class="inlineCode">MessageFormat.format()</code> is the slowest.</p>
    <h1 id="_idParaDest-30" class="heading-1">9. Adding comments in text blocks</h1>
    <p class="normal">Question: Can we add comments in text blocks?</p>
    <p class="normal">Official answer (according to the Java Language Specification): The lexical grammar implies that comments do not <a id="_idIndexMarker057"/>occur within character literals, string literals, or text blocks.</p>
    <p class="normal">You might be tempted to try something like this, thinking it’s a quick hack, but I really don’t recommend it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             foo  /* some comment */</span>
<span class="hljs-string">             buzz //another comment</span>
<span class="hljs-string">             """</span>.replace(<span class="hljs-string">"some_regex"</span>,<span class="hljs-string">""</span>);
</code></pre>
    <p class="normal">Short answer: No, we cannot have comments in text blocks.</p>
    <p class="normal">Let’s move on and talk about mixing ordinary string literals with text blocks.</p>
    <h1 id="_idParaDest-31" class="heading-1">10. Mixing ordinary string literals with text blocks</h1>
    <p class="normal">Before mixing ordinary string<a id="_idIndexMarker058"/> literals with text blocks, let’s<a id="_idIndexMarker059"/> consider the following statement: How different is an ordinary string literal from a text block? We can answer this question via the following snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"I love Java!"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">             I love Java!"""</span>;
System.out.println(str == txt);      <span class="hljs-comment">// true</span>
System.out.println(str.equals(txt)); <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal">Wow! So our snippet of code prints <code class="inlineCode">true</code> twice. This means that an ordinary string literal and a text block are similar at runtime. We can define text blocks as string literals that span across multiple lines of text and use<a id="_idIndexMarker060"/> triple quotes as their opening and closing delimiter. How so? First, the<a id="_idIndexMarker061"/> instance produced from an ordinary string literal and a text block is of type <code class="inlineCode">java.lang.String</code>. Second, we have to look at the compiler internals. Basically, the compiler adds strings to a special cached pool named a <strong class="keyWord">String Constant Pool</strong> (<strong class="keyWord">SCP</strong>) (more details <a id="_idIndexMarker062"/>about SCP are available in <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, Problem 48, <em class="italic">Immutable string</em>) to optimize the memory usage, and starting with JDK 13, text blocks can be found in the same pool as strings.</p>
    <p class="normal">Now that we know that there are no major differences in how ordinary string literals and text blocks are treated internally, we can be confident to mix them in a simple concatenation (basically, a text block can be used anywhere an ordinary string literal can be used):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">tom</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Tom"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">jerry</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""</span>
<span class="hljs-string">               Jerry"""</span>;
System.out.println(tom + <span class="hljs-string">" and "</span> + jerry); <span class="hljs-comment">// Tom and Jerry</span>
</code></pre>
    <p class="normal">Moreover, since a text block returns a <code class="inlineCode">String</code>, we can use the entire arsenal of methods that we use for ordinary string literals. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(tom.toUpperCase() + <span class="hljs-string">" AND "</span> 
  + jerry.toUpperCase()); <span class="hljs-comment">// TOM AND JERRY</span>
</code></pre>
    <p class="normal">Also, as you just saw in <em class="italic">Problem 8</em>, <em class="italic">Formatting text blocks with variables/expressions</em>, text blocks can be used and mixed with ordinary string literals in <code class="inlineCode">StringBuilder</code>(<code class="inlineCode">Buffer</code>), <code class="inlineCode">MessageFormat.format()</code>, <code class="inlineCode">String.format()</code>, and <code class="inlineCode">String.formatted()</code>.</p>
    <h1 id="_idParaDest-32" class="heading-1">11. Mixing regular expression with text blocks</h1>
    <p class="normal">Regular expressions can be used<a id="_idIndexMarker063"/> with text blocks. Let’s consider a simple string, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">nameAndAddress</span>
  <span class="hljs-operator">=</span> <span class="hljs-string">"Mark Janson;243 West Main St;Louisville;40202;USA"</span>;
</code></pre>
    <p class="normal">So here we have a name (Mark Janson) and some details about his address, delimited by a semicolon (<code class="inlineCode">;</code>). It is a common<a id="_idIndexMarker064"/> scenario to pass such strings through regular expressions and extract the information as named groups. In this example, we can consider five named groups as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">name</code>: should contain the person’s name (Mark Janson)</li>
      <li class="bulletList"><code class="inlineCode">address</code>: should contain the person’s street information (243 West Main St)</li>
      <li class="bulletList"><code class="inlineCode">city</code>: should contain the person’s city (Louisville)</li>
      <li class="bulletList"><code class="inlineCode">zip</code>: should contain the city’s zip code (40202)</li>
      <li class="bulletList"><code class="inlineCode">country</code>: should contain the country’s name (USA)</li>
    </ul>
    <p class="normal">A regular expression that can match these named groups may look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">(?&lt;name&gt;[ a-zA-Z]+);(?&lt;address&gt;[ <span class="hljs-number">0</span>-9a-zA-Z]+);(?&lt;city&gt;[ a-zA-Z]+);(?&lt;zip&gt;[\\d]+);(?&lt;country&gt;[ a-zA-Z]+)$ 
</code></pre>
    <p class="normal">This is a single-line string, so we can use it via the <code class="inlineCode">Pattern</code> API, as follows: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">"(?&lt;name&gt;[ a-zA-Z]+);(?&lt;address&gt;[ 0-9a-zA-Z]+);(?&lt;city&gt;[ a-zA-Z]+);(?&lt;zip&gt;[\\d]+);(?&lt;country&gt;[ a-zA-Z]+)$"</span>);
</code></pre>
    <p class="normal">However, as you can see, writing our regex like this has a serious impact on readability. Fortunately, we can employ text blocks to solve this issue, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">""" </span>
<span class="hljs-string">         (?&lt;name&gt;[ a-zA-Z]+);\ </span>
<span class="hljs-string">         (?&lt;address&gt;[ 0-9a-zA-Z]+);\ </span>
<span class="hljs-string">         (?&lt;city&gt;[ a-zA-Z]+);\ </span>
<span class="hljs-string">         (?&lt;zip&gt;[\\d]+);\ </span>
<span class="hljs-string">         (?&lt;country&gt;[ a-zA-Z]+)$"""</span>); 
</code></pre>
    <p class="normal">This is more readable, right? The only thing that we should take care of is to use the JDK 14 new escape sequence, <code class="inlineCode">\</code> (a single backslash), to remove the trailing line feed at the end of each line.</p>
    <p class="normal">Next, you can simply match the<a id="_idIndexMarker065"/> address and extract the named groups, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (matcher.matches()) { 
         
  <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> matcher.group(<span class="hljs-string">"name"</span>); 
  <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> matcher.group(<span class="hljs-string">"address"</span>); 
  <span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> matcher.group(<span class="hljs-string">"city"</span>); 
  <span class="hljs-type">String</span> <span class="hljs-variable">zip</span> <span class="hljs-operator">=</span> matcher.group(<span class="hljs-string">"zip"</span>); 
  <span class="hljs-type">String</span> <span class="hljs-variable">country</span> <span class="hljs-operator">=</span> matcher.group(<span class="hljs-string">"country"</span>); 
} 
</code></pre>
    <p class="normal">If you want just to extract the names of the groups, then you can rely on JDK 20’s <code class="inlineCode">namedGroups()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// {country=5, city=3, zip=4, name=1, address=2} </span>
System.out.println(matcher.namedGroups()); 
</code></pre>
    <p class="normal">Actually, <code class="inlineCode">namedGroups()</code> returns an unmodifiable <code class="inlineCode">Map&lt;String, Integer&gt;</code>, where the key is the group name and the value is the <a id="_idIndexMarker066"/>group number. Furthermore, JDK 20 has also added the <code class="inlineCode">hasMatch()</code> method, which returns <code class="inlineCode">true</code> if the matcher contains a valid match from a previous match or find operation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (matcher.hasMatch()) { ... }
</code></pre>
    <p class="normal">Note that <code class="inlineCode">hasMatch()</code> will not attempt to trigger a match against the pattern as <code class="inlineCode">matches()</code> does. When you need to check for valid matches in different places of your code, <code class="inlineCode">hasMatch()</code> is preferable, since it will not perform matches. So, you can call <code class="inlineCode">matches()</code> once, and in subsequent checks for valid matches, just call <code class="inlineCode">hasMatch()</code>.</p>
    <p class="normal">Moreover, if you just need to extract the input subsequence captured for each named group by a given delimiter, then you can rely on JDK 21’s <code class="inlineCode">splitWithDelimiters(CharSequence input, int limit)</code>. For instance, our string can be split by a semicolon (regex, <code class="inlineCode">;+</code>), as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">String[] result = Pattern.compile(<span class="hljs-string">";+"</span>) 
  .splitWithDelimiters(nameAndAddress, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">The returned array contains the extracted data and the delimiters, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">[Mark Janson, ;, <span class="hljs-number">243</span> West Main St, ;,
Louisville, ;, <span class="hljs-number">40202</span>, ;, USA]
</code></pre>
    <p class="normal">The second argument of <code class="inlineCode">splitWithDelimiters()</code> is an integer representing how many times to apply the regex. If the <code class="inlineCode">limit</code> argument<a id="_idIndexMarker067"/> is 0, then the pattern will be applied as many times as possible, and <a id="_idIndexMarker068"/>the trailing empty strings, whether substrings or delimiters, will be discarded. If it is positive, then the pattern will be applied, at most, the <code class="inlineCode">limit</code> - 1 times, and if it is negative, the pattern will be applied as many times as possible.</p>
    <h1 id="_idParaDest-33" class="heading-1">12. Checking if two text blocks are isomorphic</h1>
    <p class="normal">Two text blocks are isomorphic if the<a id="_idIndexMarker069"/> resulting strings are isomorphic. Two string literals are considered isomorphic if we can map every character of the first string to every character of the second string in a one-to-one fashion.</p>
    <p class="normal">For example, consider that the first string is “<code class="inlineCode">abbcdd</code>" and the second string is “<code class="inlineCode">qwwerr</code>". The one-to-one character mapping is shown in <em class="italic">Figure 1.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_08.png" alt="Figure 1.7.png"/></figure>
    <p class="packt_figref">Figure 1.8: One-to-one character mapping between two strings</p>
    <p class="normal">So as you can see in <em class="italic">Figure 1.8</em>, character “a” of the first string can be replaced by character “q” of the second string. Moreover, character “b” of the first string can be replaced by character “w” of the second string, character “c” by character “e”, and character “d” by character “r”. Obviously, vice versa is also true. In other words, these two strings are isomorphic.</p>
    <p class="normal">How about the strings “aab” and “que”? These two strings are not isomorphic because “a” cannot be mapped to both “q” and “u”.</p>
    <p class="normal">If we extrapolate this logic to text blocks, then <em class="italic">Figure 1.9</em> is exactly what we need:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_09.png" alt="Figure 1.8.png"/></figure>
    <p class="packt_figref">Figure 1.9: Two isomorphic text blocks</p>
    <p class="normal">Two text blocks are isomorphic<a id="_idIndexMarker070"/> if their string lines are isomorphic in a one-to-one fashion. Moreover, notice that essential white spaces and <strong class="keyWord">Line Terminators</strong> (<strong class="keyWord">LF</strong>) should be <a id="_idIndexMarker071"/>mapped as well, while incidental leading/trailing white spaces are ignored.</p>
    <p class="normal">The algorithm for ordinary string literals and text blocks is exactly the same, and it relies on <em class="italic">hashing</em> (more details about this topic are available in <em class="italic">Example 6</em>: <em class="italic">Hash table</em> in the <em class="italic">The Complete Coding Interview Guide in Java</em> book) and consists of the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Check if the two text blocks (<code class="inlineCode">s1</code> and <code class="inlineCode">s2</code>) have the same length. If their lengths differ, then the text blocks are not isomorphic.</li>
      <li class="numberedList">Create an empty map that will store mappings of the characters from <code class="inlineCode">s1</code> (as keys) to those of <code class="inlineCode">s2</code> (as values).</li>
      <li class="numberedList">Pick up the first/next character from <code class="inlineCode">s1</code> (<code class="inlineCode">chs1</code>) and <code class="inlineCode">s2</code> (<code class="inlineCode">chs2</code>).</li>
      <li class="numberedList">Check if <code class="inlineCode">chs1</code> is present as a key in the map.</li>
      <li class="numberedList">If <code class="inlineCode">chs1</code> is present in the map as a key, then it has to be mapped to a value from <code class="inlineCode">s2</code> that is equal to <code class="inlineCode">chs2</code>; otherwise, the text blocks are not isomorphic.</li>
      <li class="numberedList">If <code class="inlineCode">chs1</code> is not present in the map as a key, then the map shouldn’t contain <code class="inlineCode">chs2</code> as a value; otherwise, the text blocks are not isomorphic.</li>
      <li class="numberedList">If <code class="inlineCode">chs1</code> is not present in the map as a key and the map doesn’t contain <code class="inlineCode">chs2</code> as a value, then put (<code class="inlineCode">chs1</code> and <code class="inlineCode">chs2</code>) in the map – <code class="inlineCode">chs1</code> as a key and <code class="inlineCode">chs2</code> as a value.</li>
      <li class="numberedList">Repeat step 3 until the<a id="_idIndexMarker072"/> entire text block (<code class="inlineCode">s1</code>) is processed.</li>
      <li class="numberedList">If the entire text block (<code class="inlineCode">s1</code>) was processed, then the text blocks are isomorphic.</li>
    </ol>
    <p class="normal">In code lines, this O(n) algorithm can be expressed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">boolean isIsomorphic</span><span class="hljs-params">(String s1, String s2)</span> {
  <span class="hljs-comment">// step 1</span>
  <span class="hljs-keyword">if</span> (s1 == <span class="hljs-literal">null</span> || s2 == <span class="hljs-literal">null</span>
                 || s1.length() != s2.length()) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-comment">// step 2</span>
  Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
  <span class="hljs-comment">// step 3(8)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s1.length(); i++) {
    <span class="hljs-type">char</span> <span class="hljs-variable">chs1</span> <span class="hljs-operator">=</span> s1.charAt(i);
    <span class="hljs-type">char</span> <span class="hljs-variable">chs2</span> <span class="hljs-operator">=</span> s2.charAt(i);
    <span class="hljs-comment">// step 4</span>
    <span class="hljs-keyword">if</span> (map.containsKey(chs1)) {
<span class="hljs-comment">      // step 5</span>
<span class="hljs-keyword">      if</span> (map.get(chs1) != chs2) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// step 6</span>
      <span class="hljs-keyword">if</span> (map.containsValue(chs2)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-comment">// step 7</span>
      map.put(chs1, chs2);
    }
  }
  <span class="hljs-comment">// step 9</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
    <p class="normal">Done! You can practice this example in the bundled code. This was the last problem covering text block topics. It is<a id="_idIndexMarker073"/> time to move on and discuss string concatenation.</p>
    <h1 id="_idParaDest-34" class="heading-1">13. Concatenating strings versus StringBuilder</h1>
    <p class="normal">Check out the following plain string concatenation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"I love"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Java"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">str12</span> <span class="hljs-operator">=</span> str1 + <span class="hljs-string">" "</span> + str2; 
</code></pre>
    <p class="normal">We know that the <code class="inlineCode">String</code> class is immutable (a created <code class="inlineCode">String</code> cannot be modified). This means that creating <code class="inlineCode">str12</code> requires an intermediary string that represents the concatenation of <code class="inlineCode">str1</code> with white space. So after <code class="inlineCode">str12</code> is created, we know that <code class="inlineCode">str1 + " "</code> is just noise or garbage, since<a id="_idIndexMarker074"/> we cannot refer to it further.</p>
    <p class="normal">In such scenarios, the recommendation is<a id="_idIndexMarker075"/> to use a <code class="inlineCode">StringBuilder</code>, since it is a mutable class and we can append strings to it. So this is how the following statement was born:<em class="italic"> </em>In Java, don’t use the “<code class="inlineCode">+</code>" operator to concatenate strings! Use <code class="inlineCode">StringBuilder</code>, which is much faster.</p>
    <p class="normal">Have you heard this statement before? I’m pretty sure you have, especially if you still run your applications on JDK 8 or even on a previous release. Well, this statement is not a myth, and it was true for sure at some moment in time, but is it still valid in the era of smart compilers?</p>
    <p class="normal">For instance, consider the following two snippets of code that represent a simple concatenation of strings:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_10.png" alt="Figure 1.10.png"/></figure>
    <p class="packt_figref">Figure 1.10: String concatenation vs. StringBuilder</p>
    <p class="normal">In JDK 8, which<a id="_idIndexMarker076"/> approach (from <em class="italic">Figure 1.10</em>) is <a id="_idIndexMarker077"/>better?</p>
    <h2 id="_idParaDest-35" class="heading-2">JDK 8</h2>
    <p class="normal">Let’s inspect the bytecode produced by <a id="_idIndexMarker078"/>these two snippets of code (use <code class="inlineCode">javap -c -p</code> or Apache Commons <strong class="keyWord">Byte Code Engineering Library</strong> (<strong class="keyWord">BCEL</strong>); we <a id="_idIndexMarker079"/>have used the BCEL). The <code class="inlineCode">concatViaPlus()</code> bytecode looks as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_11.png" alt="Figure 1.11.png"/></figure>
    <p class="packt_figref">Figure 1.11: JDK 8 bytecode of concatViaPlus()</p>
    <p class="normal">The JDK 8 compiler is smart enough to use a <code class="inlineCode">StringBuilder</code> under the hood to shape our concatenation via the “<code class="inlineCode">+</code>" operator. If you check the bytecode (skipped here for brevity) generated from <code class="inlineCode">concatViaStringBuilder()</code>, then you’ll see something more or less similar to <em class="italic">Figure 1.11</em>.</p>
    <p class="normal">In JDK 8, the compiler knows when and how to optimize the bytecode via <code class="inlineCode">StringBuilder</code>. In other words, the explicit usage of <code class="inlineCode">StringBuilder</code> doesn’t come with a significant benefit over plain <a id="_idIndexMarker080"/>concatenation via the “<code class="inlineCode">+</code>" operator. There are many simple cases where this statement applies. What does a benchmark have to say about this? Check out the results:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_12.png" alt="Figure 1.12.png"/></figure>
    <p class="packt_figref">Figure 1.12: JDK 8 benchmark concatViaPlus() versus concatViaStringBuilder()</p>
    <p class="normal">Obviously, concatenation via the “<code class="inlineCode">+</code>" operator has won this game. Let’s repeat this logic for JDK 11.</p>
    <h2 id="_idParaDest-36" class="heading-2">JDK 11</h2>
    <p class="normal">JDK 11 produces the<a id="_idIndexMarker081"/> following bytecode for <code class="inlineCode">concatViaPlus()</code>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_13.png" alt="Figure 1.13.png"/></figure>
    <p class="packt_figref">Figure 1.13: JDK 11 bytecode of concatViaPlus()</p>
    <p class="normal">We can immediately observe a big difference here. This time, the concatenation is accomplished via a call to <code class="inlineCode">invokedynamic</code> (this is a dynamic call), which acts as a delegator for our code. Here, it delegates the code to <code class="inlineCode">makeConcatWithConstants()</code>, which is a method of the <code class="inlineCode">StringConcatFactory</code> class. While you can find this in the JDK documentation, pay attention that this class API was not created to be called directly. This class was specially created and designed to serve bootstrap methods for <code class="inlineCode">invokedynamic</code> instructions. Before<a id="_idIndexMarker082"/> going further, let’s look at an important note that you should consider.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The <code class="inlineCode">invokedynamic</code> delegates/passes our concatenation code to be solved by code that is not part of the bytecode (this is why we cannot see the actual code (instructions) that solve our code). This is extremely powerful because it allows the Java engineers to continue the optimization process of the concatenation logic, while we can take advantage of it by simply moving to the next JDK. The code doesn’t even need to be recompiled to take advantage of further optimizations.</p>
    </div>
    <p class="normal"><strong class="keyWord">Fun fact</strong>: The <em class="italic">indify</em> term comes from <code class="inlineCode">invokedynamic</code>, also known as <em class="italic">indy</em>. It was introduced in JDK 7 and is used in JDK 8 lambda implementations. Since this instruction was quite useful, it becomes a solution for many other things, including JEP 280: <em class="italic">Indify String Concatenation</em>, introduced in JDK 9. I preferred to use it here with JDK 11, but this feature is available starting with JDK 9+, so you can give it a try in JDK 17 or 20, for example.</p>
    <p class="normal">In a nutshell, <code class="inlineCode">invokedynamic</code> works like this:</p>
    <ul>
      <li class="bulletList">The compiler appends an <code class="inlineCode">invokedynamic</code> call at the point of concatenation.</li>
      <li class="bulletList">The <code class="inlineCode">invokedynamic</code> call first executes the bootstrap method <code class="inlineCode">makeConcat</code>[<code class="inlineCode">WithConstants</code>].</li>
      <li class="bulletList">The <code class="inlineCode">invokedynamic</code> method calls <code class="inlineCode">makeConcat</code>[<code class="inlineCode">WithConstants</code>], which is a bootstrap method meant to call the actual code responsible for concatenation.</li>
      <li class="bulletList">The <code class="inlineCode">makeConcat</code>[<code class="inlineCode">WithConstants</code>] uses an internal strategy to determine the best method of solving the concatenation.</li>
      <li class="bulletList">The method that fits the best is called, and the concatenation logic takes place.</li>
    </ul>
    <p class="normal">This way, JEP 280 adds great flexibility, since JDK 10, 11, 12, 13, and so on can use different strategies and methods to accommodate string concatenation in the best possible way for our context.</p>
    <p class="normal">How about the bytecode of <code class="inlineCode">concatViaStringBuilder()</code>? This method doesn’t take advantage of <code class="inlineCode">invokeddynamic</code> (it relies on the classic <code class="inlineCode">invokevirtual</code> instruction), as you can see here:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_14.png" alt="Figure 1.14.png"/></figure>
    <p class="packt_figref">Figure 1.14: JDK 11 bytecode of concatViaStringBuilder()</p>
    <p class="normal">I’m sure that you’re curious<a id="_idIndexMarker083"/> about which bytecode performs better, so here are the results:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_15.png" alt="Figure 1.15.png"/></figure>
    <p class="packt_figref">Figure 1.15: JDK 11, benchmark concatViaPlus() versus concatViaStringBuilder()</p>
    <p class="normal">The results of these benchmarks were obtained on an Intel<sup class="superscript">®</sup> Core<sup class="superscript">™</sup> i7-3612QM CPU @ 2.10GHz machine with Windows 10, but feel free to test it on different machines and different JDK versions, since the results are highly dependent on the machine.</p>
    <p class="normal">Again, the <code class="inlineCode">concatViaPlus()</code> wins this game. In the bundled code, you can find the complete code for this example. Moreover, you’ll find the code for inspecting bytecode and benchmarking the concatenation in a loop via the “<code class="inlineCode">+</code>" operator and <code class="inlineCode">StringBuilder</code>. Give it a spin!</p>
    <h1 id="_idParaDest-37" class="heading-1">14. Converting int to String</h1>
    <p class="normal">As usual, in Java, we can<a id="_idIndexMarker084"/> accomplish a task in multiple ways. For instance, we can <a id="_idIndexMarker085"/>convert an <code class="inlineCode">int</code> (primitive integer) to <code class="inlineCode">String</code> via <code class="inlineCode">Integer.toString()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToStringV1</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> Integer.toString(v);
}
</code></pre>
    <p class="normal">Alternatively, you can accomplish this task via a quite common hack (the code reviewer will raise his eyebrow here), consisting of concatenating an empty string with the integer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToStringV2</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> + v;
}
</code></pre>
    <p class="normal"><code class="inlineCode">String.valueOf()</code> can also be used as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToStringV3</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> String.valueOf(v);
}
</code></pre>
    <p class="normal">A more esoteric approach via <code class="inlineCode">String.format()</code> is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToStringV4</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"%d"</span>, v);
}
</code></pre>
    <p class="normal">These methods also work for a boxed integer and, therefore, for an <code class="inlineCode">Integer</code> object. Since boxing and unboxing are costly operations, we strive to avoid them unless they are really necessary. However, you never know when an unboxing operation may sneak “behind the scenes” and ruin the performance of your application. To verify this statement, imagine that, for each of the previous methods, we also have its equal getting an <code class="inlineCode">Integer</code> instead of an <code class="inlineCode">int</code>. Here is one of them (the rest were skipped for brevity):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">integerToStringV1</span><span class="hljs-params">(Integer vo)</span> {
  <span class="hljs-keyword">return</span> Integer.toString(vo);
}
</code></pre>
    <p class="normal">Benchmarking all these methods results in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_16.png" alt="Figure 1.16.png"/></figure>
    <p class="packt_figref">Figure 1.16: The results of benchmarking int to String conversion</p>
    <p class="normal">There are two crystal-clear conclusions that we can derive from here:</p>
    <ul>
      <li class="bulletList">Using <code class="inlineCode">String.format()</code> is very slow, and it should be avoided for <code class="inlineCode">int</code> and <code class="inlineCode">Integer</code>.</li>
      <li class="bulletList">All solutions that use an <code class="inlineCode">Integer</code> are slower than those using an <code class="inlineCode">int</code> primitive. So avoid unnecessary unboxing, even for such simple cases, since they may cause <a id="_idIndexMarker086"/>serious performance penalties.</li>
    </ul>
    <p class="normal">The results of these benchmarks were obtained on an Intel<sup class="superscript">®</sup> Core<sup class="superscript">™</sup> i7-3612QM CPU @ 2.10GHz machine with<a id="_idIndexMarker087"/> Windows 10, but feel free to test it on different machines, since the results are highly dependent on the machine.</p>
    <p class="normal">Next, let’s change the topic and talk about Java locales.</p>
    <h1 id="_idParaDest-38" class="heading-1">15. Introducing string templates </h1>
    <p class="normal">Until JDK 21, Java allows us to perform string composition for SQL, JSON, XML, and so on via different approaches, covered earlier in <em class="italic">Problem 8</em>. In that problem, you can see how to use text blocks and embedded <a id="_idIndexMarker088"/>expressions via simple concatenation, using the plus (<code class="inlineCode">+</code>) operator, <code class="inlineCode">StringBuilder.append()</code>, <code class="inlineCode">String.format()</code>, <code class="inlineCode">formatted()</code>, and so on. While using the plus (<code class="inlineCode">+</code>) operator and <code class="inlineCode">StringBuilder.append()</code> can be cumbersome and affect readability, the <code class="inlineCode">String.format()</code> and <code class="inlineCode">formatted()</code> may cause type mismatches. For instance, in the following example, it is quite easy to mess up the data types (<code class="inlineCode">LocalDate</code>, <code class="inlineCode">double</code>, and <code class="inlineCode">String</code>) and the format specifiers (<code class="inlineCode">%d</code>, <code class="inlineCode">%s</code>, and <code class="inlineCode">%.2f</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">fiscalDate</span> <span class="hljs-operator">=</span> LocalDate.now(); 
<span class="hljs-type">double</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">4552.2367</span>; 
<span class="hljs-type">String</span> <span class="hljs-variable">employeeCode</span> <span class="hljs-operator">=</span> <span class="hljs-string">"RN4555"</span>; 
 
<span class="hljs-type">String</span> <span class="hljs-variable">jsonBlock</span> <span class="hljs-operator">=</span> <span class="hljs-string">""" </span>
<span class="hljs-string">                 {"sale": { </span>
<span class="hljs-string">                     "id": 1, </span>
<span class="hljs-string">                     "details": { </span>
<span class="hljs-string">                         "fiscal_year": %d, </span>
<span class="hljs-string">                         "employee_nr": "%s", </span>
<span class="hljs-string">                         "value": %.2f  </span>
<span class="hljs-string">                     } </span>
<span class="hljs-string">                 } </span>
<span class="hljs-string">                 """</span>.formatted( 
                  fiscalDate.getYear(), employeeCode, value);
</code></pre>
    <p class="normal">Moreover, any of these<a id="_idIndexMarker089"/> approaches doesn’t cover input validity (as we don’t know if the expressions are valid) and security issues (injections, which commonly affect SQL strings).</p>
    <p class="normal">Starting with JDK 21, we can address these issues via <em class="italic">string templates </em>(JEP 430).</p>
    <h2 id="_idParaDest-39" class="heading-2">What’s a string template?</h2>
    <p class="normal">String templates (template expressions) are a mechanism introduced as a preview feature in JDK 21 that can help us perform string interpolation efficiently and safely. This feature consists of three parts, as follows:</p>
    <ul>
      <li class="bulletList">A template processor (<code class="inlineCode">RAW</code>, <code class="inlineCode">STR</code>, <code class="inlineCode">FMT</code>, user-defined, and so on)</li>
      <li class="bulletList">A dot character</li>
      <li class="bulletList">A string template containing the embedded expression(s) as <code class="inlineCode">\{expression}</code></li>
    </ul>
    <p class="normal"><code class="inlineCode">RAW</code>, <code class="inlineCode">STR</code>, and <code class="inlineCode">FMT</code> are the three <em class="italic">template processors</em> provided by JDK 21, but as you’ll see, we can write our own template processors as well.</p>
    <p class="normal">A <em class="italic">template processor</em> takes a string literal and the proper expressions, and it is capable of validating and interpolating it in a final result, which can be a string or other domain-specific object (for instance, a JSON object). If the template processor cannot successfully create the result, then an exception may be thrown.</p>
    <h2 id="_idParaDest-40" class="heading-2">The STR template processor</h2>
    <p class="normal">The <code class="inlineCode">STR</code> template processor is<a id="_idIndexMarker090"/> available as a <code class="inlineCode">static</code> field in <code class="inlineCode">java.lang.StringTemplate</code>. Its goal is to serve simple<a id="_idIndexMarker091"/> string concatenation tasks. For instance, we can rewrite the previous example using <code class="inlineCode">STR</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.StringTemplate.STR; 
<span class="hljs-type">String</span> <span class="hljs-variable">jsonBlockStr</span> <span class="hljs-operator">=</span> STR.<span class="hljs-string">""" </span>
<span class="hljs-string">       {"sale": { </span>
<span class="hljs-string">           "id": 1, </span>
<span class="hljs-string">           "details": { </span>
<span class="hljs-string">               "fiscal_year": \{fiscalDate.getYear()}, </span>
<span class="hljs-string">               "employee_nr": "\{employeeCode}", </span>
<span class="hljs-string">               "value": \{value}  </span>
<span class="hljs-string">           } </span>
<span class="hljs-string">       } </span>
<span class="hljs-string">       """</span>; 
</code></pre>
    <p class="normal">Here, we have three embedded expressions (<code class="inlineCode">\{fiscalDate.getYear()}</code>, <code class="inlineCode">\{employeeCode}</code>, and <code class="inlineCode">\{value}</code>) that <code class="inlineCode">STR</code> will process in order to obtain the final string:</p>
    <pre class="programlisting con"><code class="hljs-con">{"sale": { 
    "id": 1, 
    "details": { 
        "fiscal_year": 2023, 
        "employee_nr": "RN4555", 
        "value": 4552.2367 
    } 
} 
</code></pre>
    <p class="normal">As you can see, the <code class="inlineCode">STR</code> processor has replaced every embedded expression with the string value of that expression. The returned result is a <code class="inlineCode">String</code>, and we can use any number of embedded expressions. If the expression is large, then you can split it in your IDE across multiple lines without introducing new lines in the final result.</p>
    <h2 id="_idParaDest-41" class="heading-2">The FMT template processor </h2>
    <p class="normal">In the previous example, we<a id="_idIndexMarker092"/> have the <code class="inlineCode">\{value}</code> embedded expression, which is <a id="_idIndexMarker093"/>evaluated by <code class="inlineCode">STR</code> to 4552.2367. This is correct, but we may like to format this value with two decimals, as 4552.24. In such cases, we need the <code class="inlineCode">FMT</code> processor, which is available as a <code class="inlineCode">static</code> field in <code class="inlineCode">java.util.FormatProcessor</code> and is capable of interpreting the format specifiers present in embedded expressions (<code class="inlineCode">STR</code> cannot do that). So using <code class="inlineCode">FMT</code> to rewrite our example can be <a id="_idIndexMarker094"/>done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">jsonBlockFmt</span> <span class="hljs-operator">=</span> FMT.<span class="hljs-string">""" </span>
<span class="hljs-string">       {"sale": { </span>
<span class="hljs-string">           "id": 1, </span>
<span class="hljs-string">           "details": { </span>
<span class="hljs-string">               "fiscal_year": \{fiscalDate.getYear()}, </span>
<span class="hljs-string">               "employee_nr": "\{employeeCode}", </span>
<span class="hljs-string">               "value": %.2f\{value}  </span>
<span class="hljs-string">           } </span>
<span class="hljs-string">       } </span>
<span class="hljs-string">       """</span>; 
</code></pre>
    <p class="normal">Notice how the format <a id="_idIndexMarker095"/>specifier was added to the embedded expression <code class="inlineCode">(%.2f\{value}</code>) before the backslash character. This will result in the following string:</p>
    <pre class="programlisting con"><code class="hljs-con">... 
"value": 4552.24 
... 
</code></pre>
    <p class="normal">In the same manner, you can use any other format specifier. <code class="inlineCode">FMT</code> will take each of them into account in order to return the expected result.</p>
    <h2 id="_idParaDest-42" class="heading-2">The RAW template processor</h2>
    <p class="normal">The <code class="inlineCode">RAW</code> template processor is<a id="_idIndexMarker096"/> available as a <code class="inlineCode">static</code> field of <code class="inlineCode">java.lang.StringTemplate</code>. Calling <code class="inlineCode">RAW</code> will return a <code class="inlineCode">StringTemplate</code> instance that can be<a id="_idIndexMarker097"/> used later. For instance, here is a <code class="inlineCode">StringTemplate</code> that we have extracted separately using <code class="inlineCode">RAW</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StringTemplate</span> <span class="hljs-variable">templateRaw</span> <span class="hljs-operator">=</span> RAW.<span class="hljs-string">""" </span>
<span class="hljs-string">           "employee_nr": "\{employeeCode}", </span>
<span class="hljs-string">           """</span>; 
</code></pre>
    <p class="normal">Next, we can use <code class="inlineCode">templateRaw</code> repeatedly, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">fiscalDate1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); 
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">fiscalDate2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2024</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>); 
<span class="hljs-type">double</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> <span class="hljs-number">343.23</span>; 
<span class="hljs-type">double</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1244.33</span>; 
<span class="hljs-type">String</span> <span class="hljs-variable">jsonBlockRaw</span> <span class="hljs-operator">=</span> STR.<span class="hljs-string">"""  </span>
<span class="hljs-string">       {"sale": { </span>
<span class="hljs-string">           "id": 1, </span>
<span class="hljs-string">           "details": { </span>
<span class="hljs-string">               "fiscal_year": \{fiscalDate1.getYear()}, </span>
<span class="hljs-string">               \{templateRaw.interpolate()}\ </span>
<span class="hljs-string">               "value": \{value1}      </span>
<span class="hljs-string">           } </span>
<span class="hljs-string">       }, </span>
<span class="hljs-string">       {"sale": { </span>
<span class="hljs-string">           "id": 2, </span>
<span class="hljs-string">           "details": { </span>
<span class="hljs-string">               "fiscal_year": \{fiscalDate2.getYear()}, </span>
<span class="hljs-string">               \{templateRaw.interpolate()}\ </span>
<span class="hljs-string">               "value": \{value2}     </span>
<span class="hljs-string">           } </span>
<span class="hljs-string">       }            </span>
<span class="hljs-string">       """</span>;  
  
</code></pre>
    <p class="normal">The <code class="inlineCode">\{templateRaw.interpolate()}</code> expression calls the <code class="inlineCode">interpolate()</code> method, which is responsible for processing <a id="_idIndexMarker098"/>the string defined in <code class="inlineCode">templateRaw</code>. It is like<a id="_idIndexMarker099"/> calling <code class="inlineCode">interpolate()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">employeeCodeString</span> <span class="hljs-operator">=</span> templateRaw.interpolate(); 
</code></pre>
    <p class="normal">The final result is the following string: </p>
    <pre class="programlisting con"><code class="hljs-con">{"sale": { 
    "id": 1, 
    "details": { 
       "fiscal_year": 2023, 
       "employee_nr": "RN4555", 
       "value": 343.23 
    } 
}, 
{"sale": { 
    "id": 2, 
     "details": { 
        "fiscal_year": 2024, 
        "employee_nr": "RN4555", 
        "value": 1244.33 
     } 
} 
</code></pre>
    <p class="normal">The employee code is evaluated to an RN4555 string.</p>
    <p class="normal">The character sequences that precede an embedded expression and the character sequence following the<a id="_idIndexMarker100"/> last embedded expression are known as <em class="italic">fragments</em>. If the<a id="_idIndexMarker101"/> string template begins with an embedded expression, then its fragment is zero-length. The same is true for directly adjacent embedded expressions. For <a id="_idIndexMarker102"/>instance, the fragments of <code class="inlineCode">templateRaw</code> (<code class="inlineCode">"employee_nr": "\{employeeCode}",</code>) are <code class="inlineCode">"employee_nr": "</code> and <code class="inlineCode">",</code>. We have access to these fragments as a <code class="inlineCode">List&lt;String&gt;</code> via the <code class="inlineCode">fragments()</code> method.</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; trFragments = templateRaw.fragments();
</code></pre>
    <p class="normal">Moreover, getting the results of the embedded expressions as a <code class="inlineCode">List&lt;Object&gt;</code> can be done via the <code class="inlineCode">values()</code> methods, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Object&gt; trValues = templateRaw.values();
</code></pre>
    <p class="normal">For <code class="inlineCode">templateRaw</code>, this list will contain a single entry, RN4555.</p>
    <p class="normal">In the bundled code, you can find more examples, including using <code class="inlineCode">STR</code>, <code class="inlineCode">FMT</code>, and <code class="inlineCode">RAW</code> with simple strings (not text blocks).</p>
    <h1 id="_idParaDest-43" class="heading-1">16. Writing a custom template processor</h1>
    <p class="normal">The built-in <code class="inlineCode">STR</code> and <code class="inlineCode">FMT</code> can return only <code class="inlineCode">String</code> instances and cannot throw exceptions. However, both of them are actually instances of the functional interface <code class="inlineCode">StringTemplate.Processor&lt;R,E extends Throwable&gt;</code>, which defines the <code class="inlineCode">process()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">R <span class="hljs-title">process</span><span class="hljs-params">(StringTemplate stringTemplate)</span> <span class="hljs-keyword">throws</span> E 
</code></pre>
    <p class="normal">By implementing the <code class="inlineCode">Processor&lt;R,E extends Throwable&gt;</code> interface, we can write custom template <a id="_idIndexMarker103"/>processors that return <code class="inlineCode">R</code> (any result type), not just <code class="inlineCode">String</code>. Moreover, if something goes wrong during processing (for instance, validation issues are present), we can throw checked exceptions (<code class="inlineCode">E extends Throwable</code>).</p>
    <p class="normal">For instance, let’s assume that we need to interpolate strings with expressions representing phone numbers. So we accept only the expressions that are phone numbers, matching the following regular expression:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">PHONE_PATTERN</span> <span class="hljs-operator">=</span> Pattern.compile( 
  <span class="hljs-string">"\\d{10}|(?:\\d{3}-){2}\\d{4}|\\(\\d{3}\\)\\d{3}-?\\d{4}"</span>);
</code></pre>
    <p class="normal">In this case, the result<a id="_idIndexMarker104"/> is a <code class="inlineCode">String</code>, so our custom template processor can be written as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PhoneProcessor</span>
    <span class="hljs-keyword">implements</span> <span class="hljs-title">Processor</span>&lt;String, IllegalArgumentException&gt; { 
     
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">PHONE_PATTERN</span> <span class="hljs-operator">=</span> ...; 
 
  <span class="hljs-meta">@Override</span> 
  <span class="hljs-keyword">public</span> String <span class="hljs-title">process</span><span class="hljs-params">(StringTemplate stringTemplate)</span>  
    <span class="hljs-keyword">throws</span> IllegalArgumentException { 
 
    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>(); 
    Iterator&lt;String&gt; fragmentsIter  
      = stringTemplate.fragments().iterator(); 
 
    <span class="hljs-keyword">for</span> (Object value : stringTemplate.values()) { 
      sb.append(fragmentsIter.next()); 
 
      <span class="hljs-keyword">if</span> (!PHONE_PATTERN.matcher( 
            (CharSequence) value).matches()) { 
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>( 
          <span class="hljs-string">"This is not a valid phone number"</span>); 
      } 
 
      sb.append(value); 
    } 
 
    sb.append(fragmentsIter.next()); 
 
    <span class="hljs-keyword">return</span> sb.toString(); 
  } 
} 
</code></pre>
    <p class="normal">Now, we can test our processor with a simple message, as follows (here, we use valid phone numbers):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">PhoneProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">PhoneProcessor</span>();
<span class="hljs-type">String</span> <span class="hljs-variable">workPhone</span> <span class="hljs-operator">=</span> <span class="hljs-string">"072-825-9009"</span>; 
<span class="hljs-type">String</span> <span class="hljs-variable">homePhone</span> <span class="hljs-operator">=</span> <span class="hljs-string">"(040)234-9670"</span>; 
         
<span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> pp.<span class="hljs-string">""" </span>
<span class="hljs-string">   You can contact me at work at \{workPhone}</span>
<span class="hljs-string">   or at home at \{homePhone}. </span>
<span class="hljs-string">   """</span>;
</code></pre>
    <p class="normal">The resulting string is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">You can contact me at work at 072-825-9009 
or at home at (040)234-9670.
</code></pre>
    <p class="normal">As you can see, our<a id="_idIndexMarker105"/> processor relies on a <code class="inlineCode">StringBuilder</code> to obtain the final string. However, we can use the <code class="inlineCode">StringTemplate.interpolate(List&lt;String&gt; fragments, List&lt;?&gt; values)</code> method as well and obtain a cleaner solution, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PhoneProcessor</span> <span class="hljs-keyword">implements</span>  
    <span class="hljs-title">Processor</span>&lt;String, IllegalArgumentException&gt; { 
 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">PHONE_PATTERN</span> <span class="hljs-operator">=</span> ...; 
 
  <span class="hljs-meta">@Override</span> 
  <span class="hljs-keyword">public</span> String <span class="hljs-title">process</span><span class="hljs-params">(StringTemplate stringTemplate)</span>  
      <span class="hljs-keyword">throws</span> IllegalArgumentException { 
 
    <span class="hljs-keyword">for</span> (Object value : stringTemplate.values()) { 
  
      <span class="hljs-keyword">if</span> (!PHONE_PATTERN.matcher( 
         (CharSequence) value).matches()) { 
       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>( 
         <span class="hljs-string">"This is not a valid phone number"</span>); 
      } 
    } 
 
    <span class="hljs-keyword">return</span> StringTemplate.interpolate( 
      stringTemplate.fragments(), stringTemplate.values()); 
  } 
} 
</code></pre>
    <p class="normal">However, as we said earlier, a template processor can return any type (<code class="inlineCode">R</code>). For instance, let’s assume that we<a id="_idIndexMarker106"/> shaped our previous message as a JSON string, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span> 
  <span class="hljs-attr">"contact"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> 
    <span class="hljs-attr">"work"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"072-825-9009"</span><span class="hljs-punctuation">,</span> 
    <span class="hljs-attr">"home"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"(040)234-9670"</span> 
  <span class="hljs-punctuation">}</span> 
<span class="hljs-punctuation">}</span> 
</code></pre>
    <p class="normal">This time, we want to interpolate strings with variables representing phone numbers and return a JSON object. More precisely, we want to return an instance of <code class="inlineCode">com.fasterxml.jackson.databind.JsonNode</code> (here, we use the Jackson library, but it can be GSON, JSON-B, and so on):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span> 
<span class="hljs-keyword">public</span> JsonNode <span class="hljs-title">process</span><span class="hljs-params">(StringTemplate stringTemplate)</span>  
    <span class="hljs-keyword">throws</span> IllegalArgumentException { 
 
  <span class="hljs-keyword">for</span> (Object value : stringTemplate.values()) { 
 
    <span class="hljs-keyword">if</span> (!PHONE_PATTERN.matcher( 
       (CharSequence) value).matches()) { 
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>( 
        <span class="hljs-string">"This is not a valid phone number"</span>); 
    } 
  } 
 
  <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectMapper</span>();
         
  <span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">return</span> mapper.readTree(StringTemplate.interpolate( 
      stringTemplate.fragments(), stringTemplate.values())); 
  } <span class="hljs-keyword">catch</span> (IOException ex) { 
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(ex);
  }
} 
</code></pre>
    <p class="normal">This time, the returned type is <code class="inlineCode">JsonNode</code>: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">PhoneProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">PhoneProcessor</span>(); 
<span class="hljs-type">String</span> <span class="hljs-variable">workPhone</span> <span class="hljs-operator">=</span> <span class="hljs-string">"072-825-9009"</span>; 
<span class="hljs-type">String</span> <span class="hljs-variable">homePhone</span> <span class="hljs-operator">=</span> <span class="hljs-string">"(040)234-9670"</span>; 
         
<span class="hljs-type">JsonNode</span> <span class="hljs-variable">jsonMessage</span> = pp.<span class="hljs-string">""" </span>
<span class="hljs-string">  { "contact": { </span>
<span class="hljs-string">       "work": "\{workPhone}", </span>
<span class="hljs-string">       "home": "\{homePhone}" </span>
<span class="hljs-string">       } </span>
<span class="hljs-string">  }   </span>
<span class="hljs-string">  """</span>;
</code></pre>
    <p class="normal">In the bundled code, you can also find an example that uses a lambda expression for writing the previous custom template processor. Moreover, you can find an example in which instead of throwing an exception for invalid <a id="_idIndexMarker107"/>expressions we just replace the invalid values with a default value.</p>
    <div class="note">
      <p class="normal">Please note, a recent article <em class="italic">Update on String Templates (JEP 459)</em>, which you can find at: <a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html"><span class="url">https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html</span></a>,
suggests that processors, used in this way, will ultimately be replaced with simpler method calls.</p>
    </div>
    <h1 id="_idParaDest-44" class="heading-1">17. Creating a Locale</h1>
    <p class="normal">A Java <code class="inlineCode">Locale</code> (<code class="inlineCode">java.util.Locale</code>) represents an object that wraps information about a specific geographical, political, or cultural region – that is, an object useful for internationalization purposes. A <code class="inlineCode">Locale</code> is typically used in conjunction with <code class="inlineCode">DateFormat</code>/<code class="inlineCode">DateTimeFormatter</code> to<a id="_idIndexMarker108"/> represent date-time in a format specific to a country, with <code class="inlineCode">NumberFormat</code> (or its subclass, <code class="inlineCode">DecimalFormat</code>) used to represent numbers in a format specific to a country (for instance, to represent an amount of money in a specific currency), or with <code class="inlineCode">MessageFormat</code> to create formatted messages for a specific country.</p>
    <p class="normal">For the most popular locales, Java provides a list of constants (for instance, <code class="inlineCode">Locale.GERMANY</code>, <code class="inlineCode">Locale.CANADA</code>, and so on). For locales that are not on this list, we have to use the formats defined in several RFCs. Most commonly, we use the <em class="italic">language</em> pattern (for instance, <code class="inlineCode">ro</code> for Romanian) or the <em class="italic">language_country</em> pattern (for instance, <code class="inlineCode">ro_RO</code> for Romania, <code class="inlineCode">en_US</code> for United States, and so on). Sometimes, we may need the <em class="italic">language_country _variant</em> pattern, where <em class="italic">variant</em> is useful to map additional functionalities added by software vendors, such as browsers or operating systems (for instance, <code class="inlineCode">de_DE_WIN</code> is a locale for German speakers in Germany, for Windows). However, two locales are treated as non-conforming: <code class="inlineCode">ja_JP_JP</code> (which represents Japanese, as used in Japan) and <code class="inlineCode">th_TH_TH</code> (which represents Thai, as used in Thailand, including Thai digits).</p>
    <p class="normal">While you can learn more about <code class="inlineCode">Locale</code> from its comprehensive documentation, let’s mention that, before JDK 19, we can create a <code class="inlineCode">Locale</code> via one of its three constructors – most commonly, via <code class="inlineCode">Locale(String language, String country)</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Locale</span> <span class="hljs-variable">roDep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Locale</span>(<span class="hljs-string">"ro"</span>, <span class="hljs-string">"RO"</span>); <span class="hljs-comment">// locale for Romania</span>
</code></pre>
    <p class="normal">Of course, if your <code class="inlineCode">Locale</code> has already a defined constant, you can simply embed that constant where you need it in <a id="_idIndexMarker109"/>code or simply declare a <code class="inlineCode">Locale</code>, as follows (here, for Germany):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Locale</span> <span class="hljs-variable">de</span> <span class="hljs-operator">=</span> Locale.GERMANY; <span class="hljs-comment">// de_DE</span>
</code></pre>
    <p class="normal">Another approach relies on <code class="inlineCode">Locale.Builder</code> via a chain of setters:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Locale</span>.Builder()
  .setLanguage(<span class="hljs-string">"ro"</span>).setRegion(<span class="hljs-string">"RO"</span>).build(); 
</code></pre>
    <p class="normal">Alternatively, this can be done via <code class="inlineCode">Locale.forLanguageTag()</code> to follow the IETF BCP 47 standard language tags (which can be useful to represent complex tags such as China-specific Chinese, Mandarin, Simplified script, and “<code class="inlineCode">zh-cmn-Hans-CN</code>"):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> Locale.forLanguageTag(<span class="hljs-string">"zh-cmn-Hans-CN"</span>);
</code></pre>
    <p class="normal">Moreover, Java supports <em class="italic">language ranges</em>. This means that we can define a set of language tags that share some specific attributes. For instance, “<code class="inlineCode">de-*</code>" represents a language range to recognize German in any region:</p>
    <pre class="programlisting code"><code class="hljs-code">Locale.<span class="hljs-type">LanguageRange</span> <span class="hljs-variable">lr1</span> 
  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Locale</span>.LanguageRange(<span class="hljs-string">"de-*"</span>, <span class="hljs-number">1.0</span>);
Locale.<span class="hljs-type">LanguageRange</span> <span class="hljs-variable">lr2</span> 
  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Locale</span>.LanguageRange(<span class="hljs-string">"ro-RO"</span>, <span class="hljs-number">0.5</span>);
Locale.<span class="hljs-type">LanguageRange</span> <span class="hljs-variable">lr3</span> 
  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Locale</span>.LanguageRange(<span class="hljs-string">"en-*"</span>, <span class="hljs-number">0.0</span>);
</code></pre>
    <p class="normal">The previous <code class="inlineCode">Locale.LanguageRange()</code> constructor takes two arguments: the language range and its weight (1.0, 0.5, 0.0). Typically, this weight reveals the user’s preference (1.0 at the highest and 0.0 at the lowest). The weight is useful for defining <em class="italic">priority lists</em> as follows (we prefer Castilian Spanish (Spain) over Mexican Spanish and over Brazilian Portuguese):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">rangeString</span> <span class="hljs-operator">=</span> <span class="hljs-string">"es-ES;q=1.0,es-MX;q=0.5,pt-BR;q=0.0"</span>;
List&lt;Locale.LanguageRange&gt; priorityList
  = Locale.LanguageRange.parse(rangeString);
</code></pre>
    <p class="normal">Pay attention to defining a valid string of preferences so the <code class="inlineCode">parse()</code> method can work.</p>
    <p class="normal">Starting with JDK 19, the three constructors of <code class="inlineCode">Locale</code> have been deprecated, and we can rely on three static <code class="inlineCode">of()</code> methods instead. The equivalent of the previous code via the proper <code class="inlineCode">of()</code> method is:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Locale</span> <span class="hljs-variable">ro</span> <span class="hljs-operator">=</span> Locale.of(<span class="hljs-string">"ro"</span>, <span class="hljs-string">"RO"</span>); <span class="hljs-comment">// ro_RO</span>
</code></pre>
    <p class="normal">Here are two more examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Locale</span> <span class="hljs-variable">de</span> <span class="hljs-operator">=</span> Locale.of(<span class="hljs-string">"de"</span> ,<span class="hljs-string">"DE"</span>, <span class="hljs-string">"WIN"</span>);
<span class="hljs-type">Locale</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> Locale.of(<span class="hljs-string">"it"</span>); <span class="hljs-comment">// similar to Locale.ITALIAN</span>
</code></pre>
    <p class="normal">Using a <code class="inlineCode">Locale</code> is straightforward. Here is an example of using the previous <code class="inlineCode">ro</code> to format date-time via <code class="inlineCode">DateFormat</code> for Romania and Italy:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 7 ianuarie 2023, 14:57:42 EET</span>
<span class="hljs-type">DateFormat</span> <span class="hljs-variable">rodf</span> = DateFormat.getDateTimeInstance(
  DateFormat.LONG, DateFormat.LONG, ro);
<span class="hljs-comment">// 7. Januar 2023 um 15:05:29 OEZ</span>
<span class="hljs-type">DateFormat</span> <span class="hljs-variable">dedf</span> <span class="hljs-operator">=</span> DateFormat.getDateTimeInstance(
  DateFormat.LONG, DateFormat.LONG, de);
</code></pre>
    <p class="normal">In the next problem, we <a id="_idIndexMarker110"/>continue the locale journey.</p>
    <h1 id="_idParaDest-45" class="heading-1">18. Customizing localized date-time formats</h1>
    <p class="normal">Starting with JDK 8, we have a comprehensive date-time API containing classes such as <code class="inlineCode">LocalDate</code>, <code class="inlineCode">LocalTime</code>, <code class="inlineCode">LocalDateTime</code>, <code class="inlineCode">ZonedDateTime</code>, <code class="inlineCode">OffsetDateTime</code>, and <code class="inlineCode">OffsetTime</code>.</p>
    <p class="normal">We can easily format the date-time <a id="_idIndexMarker111"/>output returned by these classes via <code class="inlineCode">DateTimeFormatter.ofPattern()</code>. For instance, here, we format a <code class="inlineCode">LocalDateTime</code> via the <code class="inlineCode">y-MM-dd HH:mm:ss</code> pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 2023-01-07 15:31:22</span>
<span class="hljs-type">String</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now()
  .format(DateTimeFormatter.ofPattern(<span class="hljs-string">"y-MM-dd HH:mm:ss"</span>));
</code></pre>
    <p class="normal">More examples are available in the bundled code.</p>
    <p class="normal">How about customizing our format based on a given locale – for instance, Germany?</p>
    <pre class="programlisting code"><code class="hljs-code">Locale.setDefault(Locale.GERMANY);
</code></pre>
    <p class="normal">We accomplish this via <code class="inlineCode">ofLocalizedDate()</code>,<code class="inlineCode">ofLocalizedTime()</code>, and <code class="inlineCode">ofLocalizedDateTime()</code>, as<a id="_idIndexMarker112"/> in the following examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 7. Januar 2023</span>
<span class="hljs-type">String</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.now().format(
  DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG));
<span class="hljs-comment">// 15:49</span>
<span class="hljs-type">String</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> LocalTime.now().format(
  DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT));
<span class="hljs-comment">// 07.01.2023, 15:49:30</span>
<span class="hljs-type">String</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now().format(
  DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));
</code></pre>
    <p class="normal">We may also use:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Samstag, 7. Januar 2023 um 15:49:30 </span>
<span class="hljs-comment">// Osteuropäische Normalzeit</span>
<span class="hljs-type">String</span> <span class="hljs-variable">zdt</span> <span class="hljs-operator">=</span> ZonedDateTime.now().format(
  DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL));
<span class="hljs-comment">// 07.01.2023, 15:49:30</span>
<span class="hljs-type">String</span> <span class="hljs-variable">odt</span> <span class="hljs-operator">=</span> OffsetDateTime.now().format(
  DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));
<span class="hljs-comment">// 15:49:30</span>
<span class="hljs-type">String</span> <span class="hljs-variable">ot</span> <span class="hljs-operator">=</span> OffsetTime.now().format(
  DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM));
</code></pre>
    <p class="normal">A localized date, time, or date-time formatter supports four format styles:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">FULL</code>: Format using all details.</li>
      <li class="bulletList"><code class="inlineCode">LONG</code>: Format using lots of detail but not all.</li>
      <li class="bulletList"><code class="inlineCode">MEDIUM</code>: Format with some detail.</li>
      <li class="bulletList"><code class="inlineCode">SHORT</code>: Format as short as possible (typically numeric).</li>
    </ul>
    <p class="normal">Depending on the combination between the localized artifact and format style, the code may end up with an exception such as <em class="italic">DateTimeException: Unable to extract….</em>. If you see such an exception, then it is time to consult the following table, which provides the accepted combos:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_17.png" alt="Figure 1.17.png"/></figure>
    <p class="packt_figref">Figure 1.17: Format style of a localized date, time, and date-time</p>
    <p class="normal">Moreover, starting with<a id="_idIndexMarker113"/> JDK 19, we can use <code class="inlineCode">ofLocalizedPattern(String pattern)</code> as well.</p>
    <p class="normal">We can pass any pattern that is shown in <em class="italic">Figure 1.18</em>.</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_18.png" alt="Figure 1.17.png"/></figure>
    <p class="packt_figref">Figure 1.18: Building a pattern for ofLocalizedPattern(String pattern)</p>
    <p class="normal">This being said, let’s change the current locale to Romania:</p>
    <pre class="programlisting code"><code class="hljs-code">Locale.setDefault(Locale.of(<span class="hljs-string">"ro"</span>, <span class="hljs-string">"RO"</span>));
</code></pre>
    <p class="normal">Let’s also have some examples of <code class="inlineCode">ofLocalizedPattern()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 01.2023</span>
<span class="hljs-type">String</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.now().format(
  DateTimeFormatter.ofLocalizedPattern(<span class="hljs-string">"yMM"</span>));
<span class="hljs-comment">// 15:49</span>
<span class="hljs-type">String</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> LocalTime.now().format(
  DateTimeFormatter.ofLocalizedPattern(<span class="hljs-string">"Hm"</span>));
<span class="hljs-comment">// 01.2023, 15:49</span>
<span class="hljs-type">String</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now().format(
  DateTimeFormatter.ofLocalizedPattern(<span class="hljs-string">"yMMHm"</span>));
</code></pre>
    <p class="normal">And even<a id="_idIndexMarker114"/> more:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 01.2023, 15:49:30 EET</span>
<span class="hljs-type">String</span> <span class="hljs-variable">zdt</span> <span class="hljs-operator">=</span> ZonedDateTime.now().format(
  DateTimeFormatter.ofLocalizedPattern(<span class="hljs-string">"yMMHmsv"</span>));
<span class="hljs-comment">// 01.2023, 15:49:30</span>
<span class="hljs-type">String</span> <span class="hljs-variable">odt</span> <span class="hljs-operator">=</span> OffsetDateTime.now().format(
  DateTimeFormatter.ofLocalizedPattern(<span class="hljs-string">"yMMHms"</span>));
<span class="hljs-comment">// 15:49:30</span>
<span class="hljs-type">String</span> <span class="hljs-variable">ot</span> <span class="hljs-operator">=</span> OffsetTime.now().format(
  DateTimeFormatter.ofLocalizedPattern(<span class="hljs-string">"Hms"</span>));
</code></pre>
    <p class="normal">You can practice all these examples in the bundled code. Moreover, in the bundled code, you can find an application that uses locales and <code class="inlineCode">NumberFormat</code> to format a royalty amount for different locales (currencies).</p>
    <h1 id="_idParaDest-46" class="heading-1">19. Restoring Always-Strict Floating-Point semantics</h1>
    <p class="normal">Floating-point calculations are not easy! Even some simple arithmetical properties don’t apply to such calculations. For instance, floating-point addition or multiplication is not associative. In other words (x + y) + z is not <a id="_idIndexMarker115"/>equal to x + (y + z) where x, y, and z are real numbers. A quick example to test the associativity of multiplication follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8793331</span>;
<span class="hljs-type">double</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.22933</span>;
<span class="hljs-type">double</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-number">901.98334884433</span>;
<span class="hljs-type">double</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (x * y) * z;   <span class="hljs-comment">// 9699.617442382583 </span>
<span class="hljs-type">double</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (x * (y * z)); <span class="hljs-comment">// 9699.617442382581</span>
<span class="hljs-comment">// m1 == m2 returns false</span>
</code></pre>
    <p class="normal">This means that floating-point arithmetic is a methodical approximation of real arithmetic. Computers have to approximate because of some limitations. For instance, exact floating-point outputs become very large quite quickly. Moreover, the exact inputs are not known, so with inexact inputs, it is difficult to obtain exact outputs.</p>
    <p class="normal">To solve this problem, Java has to adopt a <em class="italic">rounding policy</em>. In other words, Java has to use a special kind of function capable of mapping from a real value to a floating-point value. These days, Java <a id="_idIndexMarker116"/>uses the so-called <em class="italic">round to nearest policy</em>. This policy attempts to round an inexact <a id="_idIndexMarker117"/>value to a value that is nearest to the <em class="italic">infinitely precise result</em>. In the case of equality (where the representable values are equally near to the inexact value), the value having the zero-most significant bit is the winner.</p>
    <p class="normal">Moreover, floating-point calculations may produce different outputs on different platforms. In other words, running floating-point calculations on different chip architectures (for instance, 16-, 32-, or 64-bit processors) may lead to different results. Java solves this issue via the <code class="inlineCode">strictfp</code> modifier. This keyword follows the IEEE 754 standards for floating-point calculations and was introduced in JDK 1.2.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The <code class="inlineCode">strictfp</code> modifier represents<a id="_idIndexMarker118"/> all intermediate values in single/double-precision conforming to IEEE 754. However, some hardware-specific issues caused <code class="inlineCode">strictfp</code> to become optional in JDK 1.2.</p>
    </div>
    <p class="normal">Let’s assume that we have to implement a scientific calculator. Obviously, our calculator has to provide consistent results across platforms, so we rely on <code class="inlineCode">strictfp</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">strictfp</strong></span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ScientificCalculator</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-title">ScientificCalculator</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title">multiply</span><span class="hljs-params">(</span>
<span class="hljs-params">        </span><span class="hljs-keyword">final</span><span class="hljs-params"> </span><span class="hljs-type">double</span><span class="hljs-params"> v1, </span><span class="hljs-keyword">final</span><span class="hljs-params"> </span><span class="hljs-type">double</span><span class="hljs-params"> v2)</span> {
    <span class="hljs-keyword">return</span> v1 * v2;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(</span>
<span class="hljs-params">        </span><span class="hljs-keyword">final</span><span class="hljs-params"> </span><span class="hljs-type">double</span><span class="hljs-params"> v1, </span><span class="hljs-keyword">final</span><span class="hljs-params"> </span><span class="hljs-type">double</span><span class="hljs-params"> v2)</span> { 
    <span class="hljs-keyword">return</span> v1 / v2;
  }
  <span class="hljs-comment">// more computational methods</span>
}
</code></pre>
    <p class="normal">The <code class="inlineCode">strictfp</code> modifier used with the class guarantees that all member methods of this class take advantage of its effect. Now, we <a id="_idIndexMarker119"/>have consistent results across platforms. You can find this example in the bundled code.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The <code class="inlineCode">strictfp</code> modifier can be used for classes (and is applied to nested classes as well), non-abstract methods, and interfaces. It cannot be used for variables, constructors, or abstract methods.</p>
    </div>
    <p class="normal">When the <code class="inlineCode">strictfp</code> modifier is used on an interface, there are some important points to consider, as follows:</p>
    <ul>
      <li class="bulletList">It is not applied to the <code class="inlineCode">abstract</code> methods declared in the interface.</li>
      <li class="bulletList">It is applied to the <code class="inlineCode">default</code> methods declared in the interface.</li>
      <li class="bulletList">It is not applied to methods defined in classes that implement the interface.</li>
      <li class="bulletList">It is applied to all the methods declared in the inner classes of the interface.</li>
    </ul>
    <p class="normal">For instance, consider the following <code class="inlineCode">strictfp</code> interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">strictfp</strong></span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Rectangle</span> {
  <span class="hljs-keyword">default</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width)</span> {
    ...
  } 
  <span class="hljs-type">double</span> <span class="hljs-title">diagonal</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width)</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Trigonometry</span> { 
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title">smallAngleOfDiagonals</span><span class="hljs-params">(</span>
<span class="hljs-params">         </span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width)</span> {
      ...
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title">bigAngleOfDiagonals</span><span class="hljs-params">(</span>
<span class="hljs-params">         </span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width)</span> {
      ...
    }
  }
}
</code></pre>
    <p class="normal">Also, there is a non-<code class="inlineCode">strictfp</code> class that <a id="_idIndexMarker120"/>implements the previous <code class="inlineCode">strictfp</code> interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rectangle</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">diagonal</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width)</span> {
    ...
  }
  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width)</span> {
    ...
  }
}
</code></pre>
    <p class="normal">To find out which artifacts are <code class="inlineCode">strictfp</code>, let’s run a little bit of Java reflection code that will reveal the modifiers of each method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayModifiers</span><span class="hljs-params">(</span>
<span class="hljs-params">                          Class clazz, String member)</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(member, 
<span class="hljs-type">      double</span>.class, <span class="hljs-type">double</span>.class).getModifiers();
    System.out.println(member + <span class="hljs-string">"</span><span class="hljs-string"> has the following </span>
<span class="hljs-string">    modifiers: "</span> + Modifier.toString(modifiers));
  } <span class="hljs-keyword">catch</span> (NoSuchMethodException | SecurityException e) {
    e.printStackTrace(System.out);
  }
}
</code></pre>
    <p class="normal">Then, let’s call this method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// public</span>
displayModifiers(Main.class, <span class="hljs-string">"diagonal"</span>);
<span class="hljs-comment">// public</span>
displayModifiers(Main.class, <span class="hljs-string">"perimeter"</span>);
<span class="hljs-comment">// public abstract</span>
displayModifiers(Main.class.getInterfaces()[<span class="hljs-number">0</span>], <span class="hljs-string">"diagonal"</span>);
<span class="hljs-comment">// public strictfp</span>
displayModifiers(Main.class.getInterfaces()[<span class="hljs-number">0</span>], <span class="hljs-string">"area"</span>);
<span class="hljs-comment">// public static strictfp</span>
displayModifiers(Rectangle.Trigonometry.class,  
  <span class="hljs-string">"smallAngleOfDiagonals"</span>);
<span class="hljs-comment">// public static strictfp</span>
displayModifiers(Rectangle.Trigonometry.class,  
  <span class="hljs-string">"bigAngleOfDiagonals"</span>);
</code></pre>
    <p class="normal">As you can see, the <code class="inlineCode">strictfp</code> modifier is not <a id="_idIndexMarker121"/>present for all of our methods. So if we need <code class="inlineCode">strictfp</code> on <code class="inlineCode">perimeter()</code> and <code class="inlineCode">diagonal()</code>, then we have to add it manually:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="code-highlight"><strong class="hljs-keyword-slc">strictfp</strong></span> <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">diagonal</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width) </span>{
  ...
}
<span class="code-highlight"><strong class="hljs-keyword-slc">strictfp</strong></span> <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> length, </span><span class="hljs-type">double</span><span class="hljs-params"> width) </span>{
  ...
}
</code></pre>
    <p class="normal">However, starting with JDK 17, there is some big news in this area.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Hardware has seriously evolved, and the issues causing <code class="inlineCode">strictfp</code> to be optional in JDK 1.2 have been fixed, so the default floating-point semantics can be changed to consistently strict. In other words, starting with JDK 17, there is no need to explicitly use <code class="inlineCode">strictfp</code>. JEP 306, <em class="italic">Restore Always-Strict Floating-Point Semantics</em>, provides this functionality out of the box everywhere. So starting with JDK 17, all floating-point operations are consistently strict.</p>
    </div>
    <p class="normal">Besides being good news for<a id="_idIndexMarker122"/> us as developers, JEP 306 also sustains several Java classes, such as <code class="inlineCode">java.lang.Math</code> and <code class="inlineCode">java.lang.StrictMath</code>, which become more robust and easy to implement.</p>
    <h1 id="_idParaDest-47" class="heading-1">20. Computing mathematical absolute value for int/long and result overflow</h1>
    <p class="normal">Mathematical absolute value is<a id="_idIndexMarker123"/> notated by placing the value between two pipe operators and is computed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">|x| = x, |-x| = x
</code></pre>
    <p class="normal">It is commonly used for computing/expressing distances. For example, imagine that 0 represents the sea level and we have a scuba diver and a climber. The scuba diver is underwater at -45 ft (notice that we use negative numbers to express how deep in the water the scuba diver is). At the same time, the climber has climbed 30 ft high. Which of them is closer to the sea level (0)? We may think that since -45 &lt; 30, the scuba diver is closer because its value is smaller. However, we can easily find the correct answer by applying the mathematical absolute, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">|-<span class="hljs-number">45</span>| = <span class="hljs-number">45</span>, |<span class="hljs-number">30</span>| = <span class="hljs-number">30</span>
<span class="hljs-number">45</span> &gt; <span class="hljs-number">30</span>, so the climber is closer to the sea level <span class="hljs-params">(</span><span class="hljs-number">0</span><span class="hljs-params">)</span>
</code></pre>
    <p class="normal">Now, let’s dive into the solution with the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;
<span class="hljs-type">int</span> <span class="hljs-variable">absofx</span> <span class="hljs-operator">=</span> Math.abs(x); <span class="hljs-comment">// 3</span>
</code></pre>
    <p class="normal">This is a very simple use case of <code class="inlineCode">Math.abs()</code>, which returns the mathematical absolute value of the given integer. Now, let’s apply this method to the following large numbers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE; <span class="hljs-comment">// -2,147,483,648    </span>
<span class="hljs-type">int</span> <span class="hljs-variable">absofx</span> <span class="hljs-operator">=</span> Math.abs(x);  <span class="hljs-comment">// -2,147,483,648</span>
</code></pre>
    <p class="normal">This is not good! The <code class="inlineCode">int</code> domain was overflowed because of <code class="inlineCode">|Integer.MIN_VALUE| &gt; |Integer.MAX_VALUE|</code>. The expected result is the positive value of 2,147,483,648, which doesn’t fit in the <code class="inlineCode">int</code> domain. However, changing the <code class="inlineCode">x</code> type from <code class="inlineCode">int</code> to <code class="inlineCode">long</code> will solve the problem:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE; <span class="hljs-comment">// -2,147,483,648    </span>
<span class="hljs-type">long</span> <span class="hljs-variable">absofx</span> = Math.abs(x);  <span class="hljs-comment">// 2,147,483,648</span>
</code></pre>
    <p class="normal">But the problem will reappear if, instead of <code class="inlineCode">Integer.MIN_VALUE</code>, there is <code class="inlineCode">Long.MIN_VALUE</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<span class="hljs-comment">// -9,223,372,036,854,775,808</span>
<span class="hljs-type">long</span> <span class="hljs-variable">absofy</span> <span class="hljs-operator">=</span> Math.abs(y); <span class="hljs-comment">// -9,223,372,036,854,775,808</span>
</code></pre>
    <p class="normal">Starting with JDK 15, the <code class="inlineCode">Math</code> class was enriched with two <code class="inlineCode">absExact()</code> methods. There is one for <code class="inlineCode">int</code> and one for <code class="inlineCode">long</code>. These methods are very useful if the mathematical absolute result is prone to <a id="_idIndexMarker124"/>overflowing the <code class="inlineCode">int</code> or <code class="inlineCode">long</code> domain (for instance, the <code class="inlineCode">Integer</code>/<code class="inlineCode">Long.MIN_VALUE</code> values overflows the positive <code class="inlineCode">int</code>/<code class="inlineCode">long</code> range). In such cases, these methods throw <code class="inlineCode">ArithmeticException</code> instead of returning a misleading result, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">absofxExact</span> <span class="hljs-operator">=</span> Math.absExact(x);  <span class="hljs-comment">// ArithmeticException</span>
<span class="hljs-type">long</span> <span class="hljs-variable">absofyExact</span> <span class="hljs-operator">=</span> Math.absExact(y); <span class="hljs-comment">// ArithmeticException</span>
</code></pre>
    <p class="normal">In a functional style context, a potential solution will rely on the <code class="inlineCode">UnaryOperator</code> functional interface, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">IntUnaryOperator</span> <span class="hljs-variable">operatorInt</span> <span class="hljs-operator">=</span> Math::absExact;
<span class="hljs-type">LongUnaryOperator</span> <span class="hljs-variable">operatorLong</span> <span class="hljs-operator">=</span> Math::absExact;
<span class="hljs-comment">// both throw ArithmeticException</span>
<span class="hljs-type">int</span> <span class="hljs-variable">absofxExactUo</span> <span class="hljs-operator">=</span> operatorInt.applyAsInt(x);
<span class="hljs-type">long</span> <span class="hljs-variable">absofyExactUo</span> <span class="hljs-operator">=</span> operatorLong.applyAsLong(y);
</code></pre>
    <p class="normal">When working with large numbers, also focus on <code class="inlineCode">BigInteger</code> (immutable arbitrary-precision integers) and <code class="inlineCode">BigDecimal</code> (immutable arbitrary-precision signed decimal numbers).</p>
    <h1 id="_idParaDest-48" class="heading-1">21. Computing the quotient of the arguments and result overflow</h1>
    <p class="normal">Let’s start with two simple <a id="_idIndexMarker125"/>computations, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">-<span class="hljs-number">4</span>/-<span class="hljs-number">1</span> = <span class="hljs-number">4</span>, <span class="hljs-number">4</span>/-<span class="hljs-number">1</span> = -<span class="hljs-number">4</span>
</code></pre>
    <p class="normal">This is a very simple use case that works as expected. Now, let’s keep the divisor as <code class="inlineCode">-1</code>, and let’s change the dividend to <code class="inlineCode">Integer.MIN_VALUE</code> (-2,147,483,648):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;
<span class="hljs-type">int</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> x/-<span class="hljs-number">1</span>; <span class="hljs-comment">// -2,147,483,648</span>
</code></pre>
    <p class="normal">This time, the result is not correct. The <code class="inlineCode">int</code> domain was overflowed because of <code class="inlineCode">|Integer.MIN_VALUE| &gt; |Integer.MAX_VALUE|</code>. It should be the positive 2,147,483,648, which doesn’t fit in the <code class="inlineCode">int</code> domain. However, changing the <code class="inlineCode">x</code> type from <code class="inlineCode">int</code> to <code class="inlineCode">long</code> will solve the problem:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;
<span class="hljs-type">long</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> x/-<span class="hljs-number">1</span>; <span class="hljs-comment">// 2,147,483,648</span>
</code></pre>
    <p class="normal">But the problem will reappear if, instead of <code class="inlineCode">Integer.MIN_VALUE</code>, there is <code class="inlineCode">Long.MIN_VALUE</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Long.MIN_VALUE; <span class="hljs-comment">// -9,223,372,036,854,775,808</span>
<span class="hljs-type">long</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> y/-<span class="hljs-number">1</span>;    <span class="hljs-comment">// -9,223,372,036,854,775,808</span>
</code></pre>
    <p class="normal">Starting with JDK 18, the <code class="inlineCode">Math</code> class was enriched with two <code class="inlineCode">divideExact()</code> methods. There is one for <code class="inlineCode">int</code> and one for <code class="inlineCode">long</code>. These methods are very useful if the division result is prone to overflowing the <code class="inlineCode">int</code> or <code class="inlineCode">long</code> (as <code class="inlineCode">Integer</code>/<code class="inlineCode">Long.MIN_VALUE</code> overflows the positive <code class="inlineCode">int</code>/<code class="inlineCode">long</code> range). In such cases, these methods throw <code class="inlineCode">ArithmeticException</code> instead of returning a misleading result, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// throw ArithmeticException</span>
<span class="hljs-type">int</span> <span class="hljs-variable">quotientExact</span> <span class="hljs-operator">=</span> Math.divideExact(x, -<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">In a functional style context, a potential solution will rely on the <code class="inlineCode">BinaryOperator</code> functional interface, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// throw ArithmeticException</span>
BinaryOperator&lt;Integer&gt; operator = Math::divideExact;
<span class="hljs-type">int</span> <span class="hljs-variable">quotientExactBo</span> <span class="hljs-operator">=</span> operator.apply(x, -<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">As we said in the previous problem as well, when working with large numbers, also focus on <code class="inlineCode">BigInteger</code> (immutable <a id="_idIndexMarker126"/>arbitrary-precision integers) and <code class="inlineCode">BigDecimal</code> (immutable arbitrary-precision signed decimal numbers).</p>
    <h1 id="_idParaDest-49" class="heading-1">22. Computing the largest/smallest value that is less/greater than or equal to the algebraic quotient</h1>
    <p class="normal">By the largest value, we understand the value closest to positive infinity, while by the smallest value, we understand the value closest to negative infinity.</p>
    <p class="normal">Computing the largest value<a id="_idIndexMarker127"/> that is less than or equal to the algebraic quotient can be done, starting with JDK 8, via <code class="inlineCode">floorDiv(int x, int y)</code> and <code class="inlineCode">floorDiv(long x, long y)</code>. Starting with JDK 9, we also have <code class="inlineCode">floorDiv(long x, int y)</code>.</p>
    <p class="normal">Computing the smallest value that is greater than or equal to the algebraic quotient can be done, starting with JDK 18, via <code class="inlineCode">ceilDiv(int x, int y)</code>, <code class="inlineCode">ceilDiv(long x, int y)</code>, and <code class="inlineCode">ceilDiv(long x, long y)</code>.</p>
    <p class="normal">However, none of these functions are capable of managing the corner case divisions presented in the previous problem, <code class="inlineCode">Integer.MIN_VALUE/-1</code> and <code class="inlineCode">Long.MIN_VALUE/-1</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE; <span class="hljs-comment">// or, x = Long.MIN_VALUE</span>
Math.floorDiv(x, -<span class="hljs-number">1</span>); <span class="hljs-comment">// -2,147,483,648</span>
Math.ceilDiv(x, -<span class="hljs-number">1</span>);  <span class="hljs-comment">// -2,147,483,648</span>
</code></pre>
    <p class="normal">Starting with JDK 18, whenever the result returned by <code class="inlineCode">floorDiv()</code>/<code class="inlineCode">ceilDiv()</code> is prone to overflowing the <code class="inlineCode">int</code> or <code class="inlineCode">long</code> domains, we can use <code class="inlineCode">floorDivExact()</code> and <code class="inlineCode">ceilDivExact()</code>. These methods come with flavors for <code class="inlineCode">int</code> and <code class="inlineCode">long</code> arguments. As you have probably intuited already, these methods throw <code class="inlineCode">ArithmeticException</code> instead of returning a misleading result, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// throw ArtihmeticException</span>
<span class="hljs-type">int</span> <span class="hljs-variable">resultFloorExact</span> <span class="hljs-operator">=</span> Math.floorDivExact(x, -<span class="hljs-number">1</span>);
<span class="hljs-comment">// throw ArtihmeticException</span>
<span class="hljs-type">int</span> <span class="hljs-variable">resultCeilExact</span> <span class="hljs-operator">=</span> Math.ceilDivExact(x, -<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">In a functional style context, a potential solution will rely on the <code class="inlineCode">BinaryOperator</code> functional interface, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// throw ArithmeticException</span>
BinaryOperator&lt;Integer&gt; operatorf = Math::floorDivExact;
<span class="hljs-type">int</span> <span class="hljs-variable">floorExactBo</span> <span class="hljs-operator">=</span> operatorf.apply(x, -<span class="hljs-number">1</span>);
<span class="hljs-comment">// throw ArithmeticException</span>
BinaryOperator&lt;Integer&gt; operatorc = Math::ceilDivExact;
<span class="hljs-type">int</span> <span class="hljs-variable">ceilExactBo</span> <span class="hljs-operator">=</span> operatorc.apply(x, -<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">Done! As you already know, when working with large numbers, also focus on <code class="inlineCode">BigInteger</code> (immutable<a id="_idIndexMarker128"/> arbitrary-precision integers) and <code class="inlineCode">BigDecimal</code> (immutable arbitrary-precision signed decimal numbers). These may save your day.</p>
    <h1 id="_idParaDest-50" class="heading-1">23. Getting integral and fractional parts from a double</h1>
    <p class="normal">You know those problems that are very easy if you know the solution and seem very difficult if you don’t? This is <a id="_idIndexMarker129"/>exactly that kind of a problem. The solution is quite simple, as you can see in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">double</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> -<span class="hljs-number">9.33543545</span>;
<span class="hljs-type">double</span> <span class="hljs-variable">fractionalPart</span> <span class="hljs-operator">=</span> value % <span class="hljs-number">1</span>;
<span class="hljs-type">double</span> <span class="hljs-variable">integralPart</span> <span class="hljs-operator">=</span> value - fractionalPart;
</code></pre>
    <p class="normal">This was easy; I don’t think you need further explanations. But this approach is not quite accurate. I mean, the integral part is -9, but this returns -9.0. Also, the fractional part is -0.33543545, but the returned value is -0.3354354500000003.</p>
    <p class="normal">If we need a more accurate result, then using <code class="inlineCode">BigDecimal</code> is more useful:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(value);
<span class="hljs-type">int</span> <span class="hljs-variable">integralPart</span> <span class="hljs-operator">=</span> bd.intValue();
<span class="hljs-type">double</span> <span class="hljs-variable">fractionalPart</span> <span class="hljs-operator">=</span> bd.subtract(
       BigDecimal.valueOf(integralPart)).doubleValue();
</code></pre>
    <p class="normal">This time, the results are -9 and -0.33543545.</p>
    <h1 id="_idParaDest-51" class="heading-1">24. Testing if a double number is an integer</h1>
    <p class="normal">First of all, let’s consider the following <a id="_idIndexMarker130"/>expected results (false means that the double is not an integer):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">double</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-number">23.11</span>;                    <span class="hljs-comment">// false</span>
<span class="hljs-type">double</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;                       <span class="hljs-comment">// true</span>
<span class="hljs-type">double</span> <span class="hljs-variable">v3</span> <span class="hljs-operator">=</span> <span class="hljs-number">23.0</span>;                     <span class="hljs-comment">// true</span>
<span class="hljs-type">double</span> <span class="hljs-variable">v4</span> <span class="hljs-operator">=</span> Double.NaN;               <span class="hljs-comment">// false</span>
<span class="hljs-type">double</span> <span class="hljs-variable">v5</span> <span class="hljs-operator">=</span> Double.NEGATIVE_INFINITY; <span class="hljs-comment">// false</span>
<span class="hljs-type">double</span> <span class="hljs-variable">v6</span> <span class="hljs-operator">=</span> Double.POSITIVE_INFINITY; <span class="hljs-comment">// false</span>
</code></pre>
    <p class="normal">Most probably, the first solution for testing if a double number is an integer consists of a simple cast as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isDoubleIntegerV1</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> v == (<span class="hljs-type">int</span>) v;
}
</code></pre>
    <p class="normal">However, there are several other options. For instance, we can rely on modulus, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isDoubleIntegerV2</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> v % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>;
}
</code></pre>
    <p class="normal">Alternatively, we can rely on the <code class="inlineCode">Math.floor()</code> and <code class="inlineCode">Double.isFinite()</code> methods. If the given double is a finite number and is equal to the result of <code class="inlineCode">Math.floor()</code>, then it is an integer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isDoubleIntegerV3</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> ((Math.floor(v) == v) &amp;&amp; Double.isFinite(v));
}
</code></pre>
    <p class="normal">We can also replace this equality via <code class="inlineCode">Math.ceil()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isDoubleIntegerV4</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> (Math.floor(v) == Math.ceil(v) 
                        &amp;&amp; Double.isFinite(v));
}
</code></pre>
    <p class="normal">Moreover, we can combine <code class="inlineCode">Double.isFinite()</code> with <code class="inlineCode">Math.rint()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isDoubleIntegerV5</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> ((Math.rint(v) == v) &amp;&amp; Double.isFinite(v));
}
</code></pre>
    <p class="normal">Finally, we can rely on Guava’s <code class="inlineCode">DoubleMath.isMathematicalInteger()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isDoubleIntegerV6</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> DoubleMath.isMathematicalInteger(v);
}
</code></pre>
    <p class="normal">But which of these approaches has a <a id="_idIndexMarker131"/>better performance? Which one are you betting on? Well, let’s see what a benchmark has to say:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_19.png" alt="Figure 1.19.png"/></figure>
    <p class="packt_figref">Figure 1.19: Benchmark results</p>
    <p class="normal">Based on these results, the conclusion is quite obvious – the solution that relies on modulus should be avoided. Also, the Guava solution seems to be slightly slower than the rest.</p>
    <h1 id="_idParaDest-52" class="heading-1">25. Hooking Java (un)signed integers in a nutshell</h1>
    <p class="normal"><em class="italic">Signed</em> values (or variables) such as <a id="_idIndexMarker132"/>signed integers or signed longs allow us to represent negative and positive numbers.</p>
    <p class="normal"><em class="italic">Unsigned</em> values (or variables) such as <a id="_idIndexMarker133"/>unsigned integers or unsigned longs allow us to represent only positive numbers.</p>
    <p class="normal">Signed and unsigned values (variables) of the same type share the same range. However, as you can see in the following figure, unsigned variables cover a larger magnitude number.</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_20.png" alt="Figure 1.20.png"/></figure>
    <p class="packt_figref">Figure 1.20: Signed and unsigned integers</p>
    <p class="normal">The signed 32-bit integers range from –2,147,483,648 to 2,147,483,647 (around 4 billion values). Unsigned 32-bit integers range from 0 to 4,294,967,295 (also around 4 billion values).</p>
    <p class="normal">So when we use signed integer variables, we can use 2 billion positive values, but when we use unsigned integer variables, we can use 4 billion positive values. The hatched part of the figure represents the extra 2 billion positive integer values.</p>
    <p class="normal">Commonly, unsigned values are needed when we don’t need negative values at all (for instance, to count something like an event occurrence) and we need to use values that reside in the hashed area in <em class="italic">Figure 1.20</em>.</p>
    <p class="normal">Java supports only signed integers that use the popular <em class="italic">two’s complement </em>representation in a signed system (for a detailed explanation of two’s complement representation and bit manipulation, please check out <em class="italic">The Complete Coding Interview Guide in Java</em>, <em class="chapterRef">Chapter 9</em>, <em class="italic">Bit Manipulation</em>). However, starting with JDK 8, we also have the <em class="italic">Unsigned Integer API</em>, which adds support for unsigned arithmetic.</p>
    <p class="normal">Moreover, JDK 9, comes with a method named <code class="inlineCode">Math.multiplyHigh(long x, long y)</code>. This method returns a <code class="inlineCode">long</code>, representing<a id="_idIndexMarker134"/> the most significant 64 bits of the 128-bit product of two 64-bit factors. The following figure clarifies this statement:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_21.png" alt="Figure 1.21.png"/></figure>
    <p class="packt_figref">Figure 1.21: The most significant 64 bits of the 128-bit product of two 64-bit factors</p>
    <p class="normal">For example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">234253490223L</span>;
<span class="hljs-type">long</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> -<span class="hljs-number">565951223449L</span>;
<span class="hljs-type">long</span> <span class="hljs-variable">resultSigned</span> <span class="hljs-operator">=</span> Math.multiplyHigh(x, y); <span class="hljs-comment">// -7187</span>
</code></pre>
    <p class="normal">The returned result (-7187) is a <a id="_idIndexMarker135"/>signed value. The unsigned version of this method, <code class="inlineCode">unsignedMultiplyHigh(long x, long y)</code>, was introduced in JDK 18 and works as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 234253483036</span>
<span class="hljs-type">long</span> <span class="hljs-variable">resultUnsigned</span> <span class="hljs-operator">=</span> Math.unsignedMultiplyHigh(x, y);
</code></pre>
    <p class="normal">So <code class="inlineCode">unsignedMultiplyHigh(long x, long y)</code> returns a long representing the most significant 64 bits of the unsigned 128-bit product of two unsigned 64-bit factors.</p>
    <p class="normal">However, remember that Java supports unsigned arithmetic, not unsigned values/variables. However, thanks to the Data Geekery company (very well known for the famous jOOQ), we have the <strong class="keyWord">jOOU</strong> (<strong class="keyWord">Java Object Oriented Unsigned</strong>) project, created to bring unsigned number types into Java. While you can explore this project at <a href="https://github.com/jOOQ/jOOU"><span class="url">https://github.com/jOOQ/jOOU</span></a>, here is an example of defining an unsigned long:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// using jOOU</span>
ULong ux = ulong(<span class="hljs-number">234253490223L</span>);  <span class="hljs-comment">// 234253490223</span>
ULong uy = ulong(-<span class="hljs-number">565951223449L</span>); <span class="hljs-comment">// 18446743507758328167</span>
</code></pre>
    <p class="normal">Here is its use in <code class="inlineCode">unsignedMultiplyHigh(long x, long y)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">uResultUnsigned</span> <span class="hljs-operator">=</span> Math.unsignedMultiplyHigh(
    ux.longValue(), uy.longValue());
</code></pre>
    <p class="normal">You can<a id="_idIndexMarker136"/> find these examples<a id="_idIndexMarker137"/> in the bundled code.</p>
    <h1 id="_idParaDest-53" class="heading-1">26. Returning the flooring/ceiling modulus</h1>
    <p class="normal">Having the <em class="italic">dividend / divisor = quotient</em> computation, we know that the <em class="italic">floor</em> operation applied to the (<em class="italic">dividend</em>, <em class="italic">divisor</em>) pair returns<a id="_idIndexMarker138"/> the largest integer that is less than or equal to the algebraic <em class="italic">quotient</em>. By the largest integer, we understand the integer closest to positive infinity. Starting with JDK 8, this operation can be obtained via <code class="inlineCode">Math.floorDiv()</code> and, starting with JDK 18, <code class="inlineCode">Math.floorDivExact()</code>.</p>
    <p class="normal">On the other hand, the <em class="italic">ceil</em> operation applied to the (<em class="italic">dividend</em>, <em class="italic">divisor</em>) pair returns the smallest integer that is greater than or equal to the algebraic <em class="italic">quotient</em>. By the smallest integer, we understand the integer closest to negative infinity. Starting with JDK 18, this operation can be obtained via <code class="inlineCode">Math.ceilDiv()</code> and <code class="inlineCode">Math.ceilDivExact()</code>.</p>
    <p class="normal">More details are available in <em class="italic">Problem 22</em>.</p>
    <p class="normal">Now, based on the <em class="italic">floor</em> and <em class="italic">ceil </em>operations, we can define the following floor/ceil modulus relationships:</p>
    <pre class="programlisting code"><code class="hljs-code">Floor_Modulus = dividend -
  (floorDiv(dividend, divisor) * divisor)
Ceil_Modulus = dividend -
  (ceilDiv(dividend, divisor) * divisor)
</code></pre>
    <p class="normal">So we can write this in code as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">dividend</span> <span class="hljs-operator">=</span> <span class="hljs-number">162</span>;
<span class="hljs-type">int</span> <span class="hljs-variable">divisor</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;   <span class="hljs-comment">// 162 % 42 = 36</span>
<span class="hljs-type">int</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> Math.floorDiv(dividend, divisor);
<span class="hljs-type">int</span> <span class="hljs-variable">fmodJDK8</span> <span class="hljs-operator">=</span> dividend - (fd * divisor); <span class="hljs-comment">// 36</span>
<span class="hljs-type">int</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> Math.ceilDiv(dividend, divisor);
<span class="hljs-type">int</span> <span class="hljs-variable">cmodJDK18</span> <span class="hljs-operator">=</span> dividend - (cd * divisor); <span class="hljs-comment">// -6</span>
</code></pre>
    <p class="normal">Starting with JDK 8, floor modulus can be obtained via <code class="inlineCode">Math.floorMod()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">dividend</span> <span class="hljs-operator">=</span> <span class="hljs-number">162</span>;
<span class="hljs-type">int</span> <span class="hljs-variable">divisor</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;
<span class="hljs-type">int</span> <span class="hljs-variable">fmodJDK8</span> <span class="hljs-operator">=</span> Math.floorMod(dividend, divisor); <span class="hljs-comment">// 36 </span>
</code></pre>
    <p class="normal">Here, we use <code class="inlineCode">floorMod(int dividend, int divisor)</code>. But we can also use two more flavors: <code class="inlineCode">floorMod(long dividend, long divisor)</code> and, starting with JDK 9, <code class="inlineCode">floorMod(long dividend, int divisor)</code>.</p>
    <p class="normal">If the <em class="italic">dividend % divisor</em> is 0, then <code class="inlineCode">floorMod()</code> is 0. If <em class="italic">dividend % divisor</em> and <code class="inlineCode">floorMod()</code> are not 0, then their result differs only if the signs of the parameters differ.</p>
    <p class="normal">Starting with JDK 18, ceil modulus <a id="_idIndexMarker139"/>can be obtained via <code class="inlineCode">Math.ceilMod()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">cmodJDK18</span> <span class="hljs-operator">=</span> Math.ceilMod(dividend, divisor); <span class="hljs-comment">// -6</span>
</code></pre>
    <p class="normal">Here, we use <code class="inlineCode">ceilMod(int dividend, int divisor)</code>. But we can also use two more flavors: <code class="inlineCode">ceilMod(long dividend, int divisor)</code> and <code class="inlineCode">ceilMod(long dividend, long divisor)</code>.</p>
    <p class="normal">If the <em class="italic">dividend % divisor</em> is 0, then <code class="inlineCode">ceilMod()</code> is 0. If <em class="italic">dividend % divisor</em> and <code class="inlineCode">ceilMod()</code> are not 0, then their results differ only if the signs of the parameters are the same.</p>
    <p class="normal">Moreover, the relationship between <code class="inlineCode">floorMod()</code> and <code class="inlineCode">floorDiv()</code> is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">dividend == floorDiv(dividend, divisor) * divisor
              + floorMod(dividend, divisor)
</code></pre>
    <p class="normal">Also, the relationship between <code class="inlineCode">ceilMod()</code> and <code class="inlineCode">ceilDiv()</code> is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">dividend == ceilDiv(dividend, divisor) * divisor 
              + ceilMod(dividend, divisor)
</code></pre>
    <p class="normal">Notice that if the divisor is 0, then both <code class="inlineCode">floorMod()</code> and <code class="inlineCode">ceilMod()</code> throw <code class="inlineCode">ArithmeticException</code>.</p>
    <h1 id="_idParaDest-54" class="heading-1">27. Collecting all prime factors of a given number</h1>
    <p class="normal">A prime number is a number divisible<a id="_idIndexMarker140"/> by itself and 1 (for instance, 2, 3, and 5 are prime numbers). Having a given number, we can extract its prime factors, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_22.png" alt="Figure 1.22.png"/></figure>
    <p class="packt_figref">Figure 1.22: Prime factors of 90 are 2, 3, 3, and 5</p>
    <p class="normal">The prime factors of 90 are 2, 3, 3, and 5. Based on <em class="italic">Figure 1.22</em>, we can create an algorithm to solve this problem, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Define a <code class="inlineCode">List</code> to collect prime factors of the given <code class="inlineCode">v</code>.</li>
      <li class="numberedList">Initialize a variable <code class="inlineCode">s</code> with 2 (the smallest prime number).</li>
      <li class="numberedList">If <code class="inlineCode">v % s</code> is 0, collect <code class="inlineCode">s</code> as a prime factor and compute the new <code class="inlineCode">v</code> as <code class="inlineCode">v / s</code>.</li>
      <li class="numberedList">If <code class="inlineCode">v % s</code> is not 0, then increase <code class="inlineCode">s</code> by 1.</li>
      <li class="numberedList">Repeat step 3 as long as <code class="inlineCode">v</code> is greater than 1.</li>
    </ol>
    <p class="normal">In code lines, this O(n) algorithm (O(log n) for composite numbers) can be expressed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; factors(<span class="hljs-type">int</span> v) {
  List&lt;Integer&gt; factorsList = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">while</span> (v &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// each perfect division give us a prime factor</span>
    <span class="hljs-keyword">if</span> (v % s == <span class="hljs-number">0</span>) {
      factorsList.add(s);
      v = v / s;
    } <span class="hljs-keyword">else</span> {
      s++;
    }
  }
  <span class="hljs-keyword">return</span> factorsList;
}
</code></pre>
    <p class="normal">In the bundled code, you can find two more approaches. Moreover, you’ll also find an application that counts the <a id="_idIndexMarker141"/>number of primes less than the given number, <code class="inlineCode">v</code> (<code class="inlineCode">v</code> should be positive).</p>
    <h1 id="_idParaDest-55" class="heading-1">28. Computing the square root of a number using the Babylonian method</h1>
    <p class="normal">Believe it or not, the <a id="_idIndexMarker142"/>ancient Babylonians (around 1500 BC) knew how to estimate square roots long before the popular method discovered by Newton.</p>
    <p class="normal">Mathematically speaking, the <a id="_idIndexMarker143"/>Babylonian approach for estimating the square root of <code class="inlineCode">v &gt; 0</code> is the recurrence relation from the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_23.png" alt="Figure 1.23.png"/></figure>
    <p class="packt_figref">Figure 1.23: The recurrence relation of Babylonian square root approximation</p>
    <p class="normal">The recurrence formula starts with an initial guess of x<sub class="subscript">0</sub>. Next, we calculate x<sub class="subscript">1</sub>, x<sub class="subscript">2</sub>, …, x<sub class="subscript">n</sub> by substituting x<sub class="subscript">n-1</sub> in the formula on the right-hand side and evaluating the expression.</p>
    <p class="normal">For instance, let’s try to apply this formula to estimate the square root of 65 (the result is 8.06). Let’s start with x<sub class="subscript">0</sub> as 65/2, so x<sub class="subscript">0</sub> =32.5, and let’s calculate x<sub class="subscript">1</sub> as:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_001.png" alt="" role="presentation"/></figure>
    <p class="normal">Having x<sub class="subscript">1</sub>, we can<a id="_idIndexMarker144"/> calculate x<sub class="subscript">2</sub> as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_002.png" alt="" role="presentation"/></figure>
    <p class="normal">Having x<sub class="subscript">2</sub>, we can <a id="_idIndexMarker145"/>calculate x<sub class="subscript">3</sub> as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_003.png" alt="" role="presentation"/></figure>
    <p class="normal">We are getting closer to the final result. Having x<sub class="subscript">3</sub>, we can calculate x<sub class="subscript">4</sub> as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_004.png" alt="" role="presentation"/></figure>
    <p class="normal">Done! After four iterations, we found that the square root of 65 is 8.06. Of course, being an approximation of the real value, we <a id="_idIndexMarker146"/>can continue until we reach the desired precision. More <a id="_idIndexMarker147"/>precision involves more iterations.</p>
    <p class="normal">The algorithm that is based on the Babylonian approach to approximate the square root of <code class="inlineCode">v &gt; 0</code> has several steps, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">To start, choose an arbitrary positive value, <code class="inlineCode">x</code> (the closer it is to the final result, the fewer iterations are needed). For instance, we start with <code class="inlineCode">x = v/2</code> as the initial guess.</li>
      <li class="numberedList">Initialize <code class="inlineCode">y = 1</code>, and choose the desired precision (for instance, <code class="inlineCode">e = 0.000000000001</code>).</li>
      <li class="numberedList">Until the precision (<code class="inlineCode">e</code>) is achieved, do the following:<ol class="numberedList" style="list-style-type: decimal;">
          <li class="numberedList" value="1">Calculate the next approximation (<code class="inlineCode">xnext</code>) as the average of <code class="inlineCode">x</code> and <code class="inlineCode">y</code>.</li>
          <li class="numberedList">Use the next approximation to set <code class="inlineCode">y</code> as <code class="inlineCode">v/xnext</code>.</li>
        </ol>
      </li>
    </ol>
    <p class="normal">So in code lines, we have the following snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title">squareRootBabylonian</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> v)</span> {
  <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> v / <span class="hljs-number">2</span>;
  <span class="hljs-type">double</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
  <span class="hljs-type">double</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000000000001</span>; <span class="hljs-comment">// precision</span>
  <span class="hljs-keyword">while</span> (x - y &gt; e) {
    x = (x + y) / <span class="hljs-number">2</span>;
    y = v / x;
  }
  <span class="hljs-keyword">return</span> x;
}
</code></pre>
    <p class="normal">In the bundled code, you can also see an implementation that is useful if you know that <code class="inlineCode">v</code> is a perfect square (for instance, 25, 144, 169, and so on).</p>
    <h1 id="_idParaDest-56" class="heading-1">29. Rounding a float number to specified decimals</h1>
    <p class="normal">Consider the following <code class="inlineCode">float</code> number<a id="_idIndexMarker148"/> and the number of decimals that we want to keep:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">float</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">14.9877655f</span>;
<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;
</code></pre>
    <p class="normal">So the expected result after rounding up is 14.98777.</p>
    <p class="normal">We can solve this problem in a straightforward manner in at least three ways. For instance, we can rely on the <code class="inlineCode">BigDecimal</code> API, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title">roundToDecimals</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> v, </span><span class="hljs-type">int</span><span class="hljs-params"> decimals)</span> {
  <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BigDecimal</span>(Float.toString(v));
  bd = bd.setScale(decimals, RoundingMode.HALF_UP);
  <span class="hljs-keyword">return</span> bd.floatValue();
}
</code></pre>
    <p class="normal">First, we create a <code class="inlineCode">BigDecimal</code> number from the given <code class="inlineCode">float</code>. Second, we scale this <code class="inlineCode">BigDecimal</code> to the desired number of decimals. Finally, we return the new <code class="inlineCode">float</code> value.</p>
    <p class="normal">Another approach can rely on <code class="inlineCode">DecimalFormat</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title">roundToDecimals</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> v, </span><span class="hljs-type">int</span><span class="hljs-params"> decimals)</span> {
  <span class="hljs-type">DecimalFormat</span> <span class="hljs-variable">df</span> = <span class="hljs-keyword">new</span> <span class="hljs-title">DecimalFormat</span>();
  df.setMaximumFractionDigits(decimals);
  <span class="hljs-keyword">return</span> Float.parseFloat(df.format(v));
}
</code></pre>
    <p class="normal">We define the format via <code class="inlineCode">setMaximumFractionDigits()</code> and simply use this format on the given <code class="inlineCode">float</code>. The returned <code class="inlineCode">String</code> is passed through <code class="inlineCode">Float.parseFloat()</code> to obtain the final <code class="inlineCode">float</code>.</p>
    <p class="normal">Finally, we can apply a more esoteric but self-explanatory approach, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title">roundToDecimals</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> v, </span><span class="hljs-type">int</span><span class="hljs-params"> decimals)</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> Integer.parseInt(
               <span class="hljs-string">"1"</span>.concat(<span class="hljs-string">"0"</span>.repeat(decimals)));
  <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>) Math.round(v * factor) / factor;
}
</code></pre>
    <p class="normal">You can practice these <a id="_idIndexMarker149"/>examples in the bundled code. Feel free to add your own solutions.</p>
    <h1 id="_idParaDest-57" class="heading-1">30. Clamping a value between min and max</h1>
    <p class="normal">Let’s assume that we have a pressure regulator that is capable of adjusting the given pressure in a certain range. For instance, if the passed pressure is below the minimum pressure, then the regulator increases the pressure to the minimum pressure. On the other hand, if the passed pressure is<a id="_idIndexMarker150"/> higher than the maximum pressure, then the regulator decreases the pressure to the maximum pressure. Moreover, if the passed pressure is between the minimum (inclusive) and maximum (inclusive) pressure, then nothing happens – this is the normal pressure.</p>
    <p class="normal">Coding this scenario can be done in a straightforward manner, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_PRESSURE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PRESSURE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>; 
 
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">adjust</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> pressure)</span> { 
         
  <span class="hljs-keyword">if</span> (pressure &lt; MIN_PRESSURE) { 
    <span class="hljs-keyword">return</span> MIN_PRESSURE; 
  } 
         
  <span class="hljs-keyword">if</span> (pressure &gt; MAX_PRESSURE) { 
    <span class="hljs-keyword">return</span> MAX_PRESSURE; 
  } 
         
  <span class="hljs-keyword">return</span> pressure; 
} 
</code></pre>
    <p class="normal">Neat! You can find different ways of expressing this code in shorter and smarter ways, but starting with JDK 21, we can accommodate solutions to this problem via the <code class="inlineCode">Math.clamp()</code> method. One of the flavors of this method is <code class="inlineCode">clamp(long value, int min, int max)</code>, which clamps the given <code class="inlineCode">value</code> between the given <code class="inlineCode">min</code> and <code class="inlineCode">max</code>. For instance, we can rewrite the previous code via the <code class="inlineCode">clamp()</code> method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">adjust</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> pressure)</span> { 
 
  <span class="hljs-keyword">return</span> Math.clamp(pressure, MIN_PRESSURE, MAX_PRESSURE);
} 
</code></pre>
    <p class="normal">Cool, right!? The logic behind the <code class="inlineCode">clamp()</code> method relies on the following code line:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.min(max, Math.max(value, min)); 
</code></pre>
    <p class="normal">Other flavors<a id="_idIndexMarker151"/> of <code class="inlineCode">clamp()</code> are <code class="inlineCode">clamp(long value, long min, long max)</code>, <code class="inlineCode">clamp(float value, float min, float max)</code>, and <code class="inlineCode">clamp(double value, double min, double max)</code>.</p>
    <h1 id="_idParaDest-58" class="heading-1">31. Multiply two integers without using loops, multiplication, bitwise, division, and operators</h1>
    <p class="normal">The solution to this <a id="_idIndexMarker152"/>problem can start from the following algebraic formula, also<a id="_idIndexMarker153"/> known as the <em class="italic">special binomial product formula</em>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_24.png" alt="Figure 1.24.png"/></figure>
    <p class="packt_figref">Figure 1.24: Extracting a*b from a binomial formula</p>
    <p class="normal">Now that we have the a*b product, there is only one issue left. The formula of a*b contains a division by 2, and we are not allowed to explicitly use the division operation. However, the division operation can be mocked in a recursive fashion, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">divideByTwo</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> d)</span> {
  <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + divideByTwo(d - <span class="hljs-number">2</span>);
}
</code></pre>
    <p class="normal">Nothing can stop us now <a id="_idIndexMarker154"/>from using this recursive code to implement a*b, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> p, </span><span class="hljs-type">int</span><span class="hljs-params"> q)</span> {
  <span class="hljs-comment">// p * 0 = 0, 0 * q = 0</span>
  <span class="hljs-keyword">if</span> (p == <span class="hljs-number">0</span> || q == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-type">int</span> <span class="hljs-variable">pqSquare</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(p + q, <span class="hljs-number">2</span>);
  <span class="hljs-type">int</span> <span class="hljs-variable">pSquare</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(p, <span class="hljs-number">2</span>);
  <span class="hljs-type">int</span> <span class="hljs-variable">qSquare</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(q, <span class="hljs-number">2</span>);
<span class="hljs-type">  int</span> <span class="hljs-variable">squareResult</span> <span class="hljs-operator">=</span> pqSquare - pSquare - qSquare;
<span class="hljs-type">  int</span> result;
  <span class="hljs-keyword">if</span> (squareResult &gt;= <span class="hljs-number">0</span>) {
    result = divideByTwo(squareResult);
  } <span class="hljs-keyword">else</span> {
    result = <span class="hljs-number">0</span> - divideByTwo(Math.abs(squareResult));
  }
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
    <p class="normal">In the bundled code, you can also practice a recursive approach to this problem.</p>
    <h1 id="_idParaDest-59" class="heading-1">32. Using TAU</h1>
    <h2 id="_idParaDest-60" class="heading-2">What is TAU?</h2>
    <p class="normal"><strong class="keyWord">Short answer</strong>: It is <a id="_idIndexMarker155"/>the Greek letter <img src="../Images/B19665_01_005.png" alt="" role="presentation"/>.</p>
    <p class="normal"><strong class="keyWord">Long answer</strong>: It is a Greek letter used to define the proportion of the circumference of a circle to its radius. Put simply, TAU is one turn of an entire circle, so 2*PI.</p>
    <p class="normal">TAU allows us to express<a id="_idIndexMarker156"/> sinuses, cosines, and angles in a more intuitive and simple way. For instance, the well-known angles of 30<sup class="superscript">0</sup>, 45<sup class="superscript">0</sup>, 90<sup class="superscript">0</sup>, and so on can be easily expressed in radians via TAU as a fraction of a circle, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_25.png" alt="Figure 1.25.png"/></figure>
    <p class="packt_figref">Figure 1.25: Angles represented using TAU</p>
    <p class="normal">This is more intuitive than PI. It is like slicing a pie into equal parts. For instance, if we slice at TAU/8 (45<sup class="superscript">0</sup>), it means that we sliced the pie into eight equal parts. If we slice at TAU/4 (90<sup class="superscript">0</sup>), it means that we sliced the pie into four equal parts.</p>
    <p class="normal">The value of TAU is 6.283185307179586 = 2 * 3.141592653589793. So the relationship between TAU and PI is TAU=2*PI. In Java, the well-known PI is represented via the <code class="inlineCode">Math.PI</code> constant. Starting with JDK 19, the <code class="inlineCode">Math</code> class was enriched with the <code class="inlineCode">Math.TAU</code> constant.</p>
    <p class="normal">Let’s consider the following simple problem: A circle has a circumference of 21.33 cm. What is the radius of the circle?</p>
    <p class="normal">We know that C = 2*PI*r, where C is the circumference and r is the radius. Therefore, r = C/(2*PI) or r = C/TAU. In code lines, we have:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// before JDK 19, using PI</span>
<span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">21.33</span> / (<span class="hljs-number">2</span> * Math.PI);
<span class="hljs-comment">// starting with JDK 19, using TAU</span>
<span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">21.33</span> / Math.TAU;
</code></pre>
    <p class="normal">Both approaches return<a id="_idIndexMarker157"/> a radius equal to 3.394.</p>
    <h1 id="_idParaDest-61" class="heading-1">33. Selecting a pseudo-random number generator</h1>
    <p class="normal">When we flip a coin or roll the dice, we say that we see “true” or “natural” randomness at work. Even so, there are tools that pretend they are capable of predicting the path of flipping a coin, rolling dice, or spinning a roulette wheel, especially if some contextual conditions are met.</p>
    <p class="normal">Computers can generate random<a id="_idIndexMarker158"/> numbers using algorithms via the so-called <strong class="keyWord">random generators</strong>. Since algorithms are involved, the generated numbers are <a id="_idIndexMarker159"/>considered pseudo-random. This is known as “pseudo”-randomness. Obviously, pseudo-random numbers are also<a id="_idIndexMarker160"/> predictable. How so?</p>
    <p class="normal">A pseudo-random generator starts its job by <em class="italic">seeding</em> data. This is the generator’s secret (the <em class="italic">seed</em>), and it represents a piece of data used as the starting point to generate pseudo-random numbers. If we know how the algorithm works and what the <em class="italic">seed</em> was, then the output is predictable. Without knowing the <em class="italic">seed</em>, the rate of predictability is very low. So choosing the proper <em class="italic">seed</em> is a major step for every pseudo-random generator.</p>
    <p class="normal">Until JDK 17, Java’s API for generating pseudo-random numbers was a bit obtuse. Basically, we have a robust API wrapped in the well-known <code class="inlineCode">java.util.Random</code> class, and two subclasses of <code class="inlineCode">Random</code>: <code class="inlineCode">SecureRandom</code> (cryptographically pseudo-random generator) and <code class="inlineCode">ThreadLocalRandom</code> (not a thread-safe pseudo-random generator). From a performance perspective, the relationship between these pseudo-random generators is that <code class="inlineCode">SecureRandom</code> is slower than <code class="inlineCode">Random</code>, which is slower than <code class="inlineCode">ThreadLocalRandom</code>.</p>
    <p class="normal">As well as these classes, we have <code class="inlineCode">SplittableRandom</code>. This is a non-thread-safe pseudo-generator capable of spinning a new <code class="inlineCode">SplittableRandom</code> at each call of its <code class="inlineCode">split()</code> method. This way, each thread (for instance, in a fork/join architecture) can use its own <code class="inlineCode">SplittableGenerator</code>.</p>
    <p class="normal">The class hierarchy of pseudo-random generators, up to JDK 17, is shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_26.png" alt="Figure 1.26.png"/></figure>
    <p class="packt_figref">Figure 1.26: The class hierarchy of Java pseudo-random generators before JDK 17</p>
    <p class="normal">As this architecture reveals, switching <a id="_idIndexMarker161"/>between pseudo-random generators or choosing between different types of algorithms is really cumbersome. Look at that <code class="inlineCode">SplittableRandom</code> – is lost in no man’s land.</p>
    <p class="normal">Starting with JDK 17, we have a more flexible and powerful API for generating pseudo-random numbers. This is an interface-based API (released with JEP 356) that orbits the new <code class="inlineCode">RandomGenerator</code> interface. Here is the enhanced class hierarchy of JDK 17:</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_27.png" alt="Figure 1.27.png"/></figure>
    <p class="packt_figref">Figure 1.27: The class hierarchy of Java pseudo-random generators, starting with JDK 17</p>
    <p class="normal">The <code class="inlineCode">RandomGenerator</code> interface represents the climax of this API. It represents a common and uniform protocol for generating pseudo-random numbers. This interface has taken over the <code class="inlineCode">Random</code> API and added a few more.</p>
    <p class="normal">The <code class="inlineCode">RandomGenerator</code> interface is extended by five sub-interfaces meant to provide special protocols for five different types of pseudo-random generators.</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">StreamableGenerator</code> can return streams of <code class="inlineCode">RandomGenerator</code> objects</li>
      <li class="bulletList"><code class="inlineCode">SplittableGenerator</code> can return a new generator from this one (split itself)</li>
      <li class="bulletList"><code class="inlineCode">JumpableGenerator</code> can jump <a id="_idIndexMarker162"/>ahead a moderate number of draws</li>
      <li class="bulletList"><code class="inlineCode">LeapableGenerator</code> can jump ahead a large number of draws</li>
      <li class="bulletList"><code class="inlineCode">ArbitrarilyJumpableGenerator</code> can jump ahead an arbitrary number of draws</li>
    </ul>
    <p class="normal">Getting the default <code class="inlineCode">RandomGenerator</code> can be done as follows (this is the simplest approach to start generating pseudo-random numbers, but you have no control over what is chosen):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">RandomGenerator</span> <span class="hljs-variable">defaultGenerator</span>
  <span class="hljs-operator">=</span> RandomGenerator.getDefault();
<span class="hljs-comment">// start generating pseudo-random numbers</span>
defaultGenerator.nextInt/Float/...();
defaultGenerator.ints/doubles/...();
</code></pre>
    <p class="normal">Besides these interfaces, the new API comes with a class (<code class="inlineCode">RandomGeneratorFactory</code>), which is a factory of pseudo-random generators based on the selected algorithms. There are three groups of new algorithms (most probably, more are on the way); these groups are as follows:</p>
    <ul>
      <li class="bulletList">LXM group;<ul>
          <li class="bulletList"><code class="inlineCode">L128X1024MixRandom</code></li>
          <li class="bulletList"><code class="inlineCode">L128X128MixRandom</code></li>
          <li class="bulletList"><code class="inlineCode">L128X256MixRandom</code></li>
          <li class="bulletList"><code style="font-weight: bold;" class="codeHighlighted">L32X64MixRandom</code></li>
          <li class="bulletList"><code class="inlineCode">L64X1024MixRandom</code></li>
          <li class="bulletList"><code class="inlineCode">L64X128MixRandom</code></li>
          <li class="bulletList"><code class="inlineCode">L64X128StarStarRandom</code></li>
          <li class="bulletList"><code class="inlineCode">L64X256MixRandom</code></li>
        </ul>
      </li>
      <li class="bulletList">Xoroshiro group:<ul>
          <li class="bulletList"><code class="inlineCode">Xoroshiro128PlusPlus</code></li>
        </ul>
      </li>
      <li class="bulletList">Xoshiro group:<ul>
          <li class="bulletList"><code class="inlineCode">Xoshiro256PlusPlus</code></li>
        </ul>
      </li>
    </ul>
    <p class="normal">The highlighted algorithm is the default one (<code class="inlineCode">L32X64MixRandom</code>).</p>
    <p class="normal">Depending on the pseudo-random generator type, we can select all/some of the previous algorithms. For instance, the <code class="inlineCode">L128X256MixRandom</code> algorithm can be used with <code class="inlineCode">SplittableGenerator</code>, but it<a id="_idIndexMarker163"/> cannot be used with <code class="inlineCode">LeapableGenerator</code>. A mismatch between the chosen algorithm and the pseudo-random generator results in <code class="inlineCode">IllegalArgumentException</code>. The following figure can help you to decide which algorithm to use.</p>
    <figure class="mediaobject"><img src="../Images/B19665_01_28.png" alt="Figure 1.28.png"/></figure>
    <p class="packt_figref">Figure 1.28: JDK 17 random generator algorithms and their properties</p>
    <p class="normal">This figure was produced via the following code, which lists all the available algorithms and their properties (<em class="italic">streamable</em>, <em class="italic">leapable</em>, <em class="italic">statistical</em>, and so on):</p>
    <pre class="programlisting code"><code class="hljs-code">Stream&lt;RandomGeneratorFactory&lt;RandomGenerator&gt;&gt; all 
     = RandomGeneratorFactory.all();
Object[][] data = all.sorted(Comparator.comparing(
                   RandomGeneratorFactory::group))
   .map(f -&gt; {
      Object[] obj = <span class="hljs-keyword">new</span> <span class="hljs-title">Object</span>[]{
        f.name(),
        f.group(),
        f.isArbitrarilyJumpable(),
        f.isDeprecated(),
        f.isHardware(),
        f.isJumpable(),
        f.isLeapable(),
        f.isSplittable(),
        f.isStatistical(),
        f.isStochastic(),
        f.isStreamable()
     };
     <span class="hljs-keyword">return</span> obj;
  }).toArray(Object[][]::<span class="hljs-keyword">new</span>);
</code></pre>
    <p class="normal">Choosing an algorithm can<a id="_idIndexMarker164"/> be easily done by name or properties.</p>
    <h2 id="_idParaDest-62" class="heading-2">Choosing an algorithm by name</h2>
    <p class="normal">Choosing an algorithm by name <a id="_idIndexMarker165"/>can be done via a set of static <code class="inlineCode">of()</code> methods. There is an <code class="inlineCode">of()</code> method in <code class="inlineCode">RandomGenerator</code> and <code class="inlineCode">RandomGeneratorFactory</code> that can be used to create a pseudo-random generator for a specific algorithm, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">RandomGenerator</span> <span class="hljs-variable">generator</span>
<span class="hljs-operator">  =</span> RandomGenerator.of(<span class="hljs-string">"L128X256MixRandom"</span>);
<span class="hljs-type">RandomGenerator</span> <span class="hljs-variable">generator</span> 
  <span class="hljs-operator">=</span> RandomGeneratorFactory.of(<span class="hljs-string">"Xoroshiro128PlusPlus"</span>)
                          .create();
</code></pre>
    <p class="normal">Next, we can generate pseudo-random numbers by calling a well-known API (<code class="inlineCode">ints()</code>, <code class="inlineCode">doubles()</code>, <code class="inlineCode">nextInt()</code>, <code class="inlineCode">nextFloat()</code>, and so on).</p>
    <p class="normal">If we need a certain pseudo-random generator and algorithm, then we can use the <code class="inlineCode">of()</code> method of that generator, as follows (here, we create a <code class="inlineCode">LeapableGenerator</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LeapableGenerator</span> <span class="hljs-variable">leapableGenerator</span>
  <span class="hljs-operator">=</span> LeapableGenerator.of(<span class="hljs-string">"Xoshiro256PlusPlus"</span>);
<span class="hljs-type">LeapableGenerator</span> <span class="hljs-variable">leapableGenerator</span> <span class="hljs-operator">=</span> RandomGeneratorFactory
  .&lt;LeapableGenerator&gt;of(<span class="hljs-string">"Xoshiro256PlusPlus"</span>).create();
</code></pre>
    <p class="normal">In the case of <code class="inlineCode">SplittableRandom</code>, you can use the constructor as well, but you cannot specify the algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SplittableRandom</span> <span class="hljs-variable">splittableGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">SplittableRandom</span>();
</code></pre>
    <p class="normal">In the bundled code, you<a id="_idIndexMarker166"/> can see more examples.</p>
    <h2 id="_idParaDest-63" class="heading-2">Choosing an algorithm by property</h2>
    <p class="normal">As you saw in <em class="italic">Figure 1.28</em>, an algorithm <a id="_idIndexMarker167"/>has a set of properties (is <em class="italic">Jumpable</em>, is <em class="italic">Statistical</em>, and so on). Let’s pick an algorithm that is <em class="italic">statistical</em> and <em class="italic">leapable</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">RandomGenerator</span> <span class="hljs-variable">generator</span> <span class="hljs-operator">=</span> RandomGeneratorFactory.all()
  .filter(RandomGeneratorFactory::isLeapable)
  .filter(RandomGeneratorFactory::isStatistical)
  .findFirst()
  .map(RandomGeneratorFactory::create)
  .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(
       <span class="hljs-string">"Cannot find this kind of generator"</span>));
</code></pre>
    <p class="normal">The returned algorithm can be <code class="inlineCode">Xoshiro256PlusPlus</code>.</p>
    <h1 id="_idParaDest-64" class="heading-1">34. Filling a long array with pseudo-random numbers</h1>
    <p class="normal">When we want to fill up a large array with data, we can consider the <code class="inlineCode">Arrays.setAll()</code> and <code class="inlineCode">Arrays.parallelSetAll()</code>. These methods can fill up an array by applying a generator function to compute each element <a id="_idIndexMarker168"/>of the array.</p>
    <p class="normal">Since we have to fill up the array with <a id="_idIndexMarker169"/>pseudo-random data, we should consider that the generator function should be a pseudo-random generator. If we want to do this in parallel, then we should consider the <code class="inlineCode">SplittableRandom</code> (JDK 8+)/<code class="inlineCode">SplittableGenerator</code> (JDK 17+), which are dedicated to generating pseudo-random numbers in isolated parallel computations. In conclusion, the code may look as follows (JDK 17+):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SplittableGenerator</span> <span class="hljs-variable">splittableRndL64X256</span> 
  <span class="hljs-operator">=</span> RandomGeneratorFactory
     .&lt;SplittableGenerator&gt;of(<span class="hljs-string">"L64X256MixRandom"</span>).create();
<span class="hljs-type">long</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title">long</span>[<span class="hljs-number">100_000_000</span>];
Arrays.parallelSetAll(arr, 
                      x -&gt;splittableRndL64X256.nextLong());
</code></pre>
    <p class="normal">Alternatively, we can <a id="_idIndexMarker170"/>use <code class="inlineCode">SplittableRandom</code> (this time, we cannot<a id="_idIndexMarker171"/> specify the algorithm, JDK 8+):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SplittableRandom</span> <span class="hljs-variable">splittableRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">SplittableRandom</span>();
<span class="hljs-type">long</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title">long</span>[<span class="hljs-number">100_000_000</span>];
Arrays.parallelSetAll(arr, x -&gt;splittableRandom.nextLong());
</code></pre>
    <p class="normal">Next, let’s see how we can create a stream of pseudo-random generators.</p>
    <h1 id="_idParaDest-65" class="heading-1">35. Creating a stream of pseudo-random generators</h1>
    <p class="normal">Before creating a stream of pseudo-random generators, let’s create a stream of pseudo-random numbers. First thing first, let’s see how to do it with the legacy <code class="inlineCode">Random</code>, <code class="inlineCode">SecureRandom</code>, and <code class="inlineCode">ThreadLocalRandom</code>.</p>
    <p class="normal">Since these three pseudo-random<a id="_idIndexMarker172"/> generators contain methods such as <code class="inlineCode">ints()</code> returning <code class="inlineCode">IntStream</code>, <code class="inlineCode">doubles()</code> returning <code class="inlineCode">DoubleStream</code>, and so on, we can easily generate an (in)finite stream of pseudo-random numbers, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Random</span> <span class="hljs-variable">rnd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>();
<span class="hljs-comment">// the ints() flavor returns an infinite stream</span>
<span class="hljs-type">int</span>[] arrOfInts = rnd.ints(<span class="hljs-number">10</span>).toArray(); <span class="hljs-comment">// stream of 10 ints</span>
<span class="hljs-comment">// or, shortly</span>
<span class="hljs-type">int</span>[] arrOfInts = <span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>().ints(<span class="hljs-number">10</span>).toArray();
</code></pre>
    <p class="normal">In our examples, we collect the generated pseudo-random numbers in an array. Of course, you can process them as you want. We can obtain similar results via <code class="inlineCode">SecureRandom</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SecureRandom</span> <span class="hljs-variable">secureRnd</span> <span class="hljs-operator">=</span> SecureRandom.getInstanceStrong();
<span class="hljs-type">int</span>[] arrOfSecInts = secureRnd.ints(<span class="hljs-number">10</span>).toArray();
<span class="hljs-comment">// or, shortly</span>
<span class="hljs-type">int</span>[] arrOfSecInts = SecureRandom.getInstanceStrong()
  .ints(<span class="hljs-number">10</span>).toArray();
</code></pre>
    <p class="normal">How about <code class="inlineCode">ThreadLocalRandom</code>? Here it is:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ThreadLocalRandom</span> <span class="hljs-variable">tlRnd</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();
<span class="hljs-type">int</span>[] arrOfTlInts = tlRnd.ints(<span class="hljs-number">10</span>).toArray();
<span class="hljs-comment">// or, shortly</span>
<span class="hljs-type">int</span>[] arrOfTlInts = ThreadLocalRandom.current()
  .ints(<span class="hljs-number">10</span>).toArray();
</code></pre>
    <p class="normal">If you just need a stream of doubles between 0.0 and 1.0, then rely on <code class="inlineCode">Math.random()</code>, which internally uses an<a id="_idIndexMarker173"/> instance of <code class="inlineCode">java.util.Random</code>. The following example collects an array of doubles between 0.0 and 0.5. The stream will stop when the first <code class="inlineCode">double</code> larger than 0.5 is generated:</p>
    <pre class="programlisting code"><code class="hljs-code">Supplier&lt;Double&gt; doubles = Math::random;
<span class="hljs-type">double</span>[] arrOfDoubles = Stream.generate(doubles)
   .takeWhile(t -&gt; t &lt; <span class="hljs-number">0.5d</span>)
   .mapToDouble(i -&gt; i)
   .toArray();
</code></pre>
    <p class="normal">How about using the new JDK 17 API? The <code class="inlineCode">RandomGenerator</code> contains the well-known methods <code class="inlineCode">ints()</code>, <code class="inlineCode">doubles()</code>, and so on, and they are available in all its sub-interfaces. For instance, <code class="inlineCode">StreamableGenerator</code> can be used, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StreamableGenerator</span> <span class="hljs-variable">streamableRnd</span>
   <span class="hljs-operator">=</span> StreamableGenerator.of(<span class="hljs-string">"L128X1024MixRandom"</span>);
<span class="hljs-type">int</span>[] arrOfStRndInts = streamableRnd.ints(<span class="hljs-number">10</span>).toArray();
<span class="hljs-comment">// or, shortly</span>
StreamableGenerator.of(<span class="hljs-string">"L128X1024MixRandom"</span>)
  .ints(<span class="hljs-number">10</span>).toArray();
</code></pre>
    <p class="normal">Similarly, we can use <code class="inlineCode">JumpableGenerator</code>, <code class="inlineCode">LeapableGenerator</code>, and so on.</p>
    <p class="normal">OK, now let’s get back to our problem. How do we generate a stream of pseudo-random generators? All <code class="inlineCode">RandomGenerator</code> sub-interfaces contain a method named <code class="inlineCode">rngs()</code> that comes in different flavors. Without arguments, this method returns an infinite stream of new pseudo-random generators that implement the <code class="inlineCode">RandomGenerator</code> interface. The following code generated five <code class="inlineCode">StreamableGenerator</code> instances, and each of those generated 10 pseudo-random integers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">StreamableGenerator</span> <span class="hljs-variable">streamableRnd</span>
   <span class="hljs-operator">=</span> StreamableGenerator.of(<span class="hljs-string">"L128X1024MixRandom"</span>);
List&lt;<span class="hljs-type">int</span>[]&gt; listOfArrOfIntsSG
   = streamableRnd.rngs(<span class="hljs-number">5</span>) <span class="hljs-comment">// get 5 pseudo-random generators</span>
    .map(r -&gt; r.ints(<span class="hljs-number">10</span>))  <span class="hljs-comment">// generate 10 ints per generator</span>
    .map(r -&gt; r.toArray())
    .collect(Collectors.toList());
</code></pre>
    <p class="normal">We can accomplish the same thing with <code class="inlineCode">JumpableGenerator</code>, but instead of <code class="inlineCode">rngs()</code>, we may prefer <code class="inlineCode">jumps()</code>, which implements<a id="_idIndexMarker174"/> the behavior specific to this type of generator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">JumpableGenerator</span> <span class="hljs-variable">jumpableRnd</span>
   <span class="hljs-operator">=</span> JumpableGenerator.of(<span class="hljs-string">"Xoshiro256PlusPlus"</span>);
List&lt;<span class="hljs-type">int</span>[]&gt; listOfArrOfIntsJG = jumpableRnd.jumps(<span class="hljs-number">5</span>)
   .map(r -&gt; {
        <span class="hljs-type">JumpableGenerator</span> <span class="hljs-variable">jg</span> = (JumpableGenerator) r;
        <span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
           ints[i] = jg.nextInt();
           jg.jump();
        }
        <span class="hljs-keyword">return</span> ints;
   })
   .collect(Collectors.toList());
</code></pre>
    <p class="normal">The same thing can be accomplished via <code class="inlineCode">LeapableGenerator</code>. This time, we can use <code class="inlineCode">rngs()</code> or <code class="inlineCode">leaps()</code>, which implement the behavior specific to this type of generator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LeapableGenerator</span> <span class="hljs-variable">leapableRnd</span>
   <span class="hljs-operator">=</span> LeapableGenerator.of(<span class="hljs-string">"Xoshiro256PlusPlus"</span>);
List&lt;<span class="hljs-type">int</span>[]&gt; listOfArrOfIntsLG = leapableRnd.leaps(<span class="hljs-number">5</span>)
   .map(r -&gt; {
        <span class="hljs-type">LeapableGenerator</span> <span class="hljs-variable">lg</span> = (LeapableGenerator) r;
        <span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
           ints[i] = lg.nextInt();
           lg.leap();
        }
        <span class="hljs-keyword">return</span> ints;
   })
   .collect(Collectors.toList());
</code></pre>
    <p class="normal">Next, let’s see how we can<a id="_idIndexMarker175"/> interleave legacy and new pseudo-random generators.</p>
    <h1 id="_idParaDest-66" class="heading-1">36. Getting a legacy pseudo-random generator from new ones of JDK 17</h1>
    <p class="normal">A legacy pseudo-random generator such as <code class="inlineCode">Random</code>, <code class="inlineCode">SecureRandom</code>, or <code class="inlineCode">ThreadLocalRandom</code> can delegate method <a id="_idIndexMarker176"/>calls to a <code class="inlineCode">RandomGenerator</code>, passed as an argument to <code class="inlineCode">Random.from()</code>, <code class="inlineCode">SecureRandom.from()</code>, or <code class="inlineCode">ThreadLocalRandom.from()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Random</span> <span class="hljs-variable">legacyRnd</span> <span class="hljs-operator">=</span> Random.from(
   RandomGenerator.of(<span class="hljs-string">"L128X256MixRandom"</span>));
<span class="hljs-comment">// or, like his</span>
<span class="hljs-type">Random</span> <span class="hljs-variable">legacyRnd</span> <span class="hljs-operator">=</span> Random.from(RandomGeneratorFactory.
   of(<span class="hljs-string">"Xoroshiro128PlusPlus"</span>).create());
<span class="hljs-comment">// or, like this</span>
<span class="hljs-type">Random</span> <span class="hljs-variable">legacyRnd</span> <span class="hljs-operator">=</span> Random.from(RandomGeneratorFactory
   .&lt;RandomGenerator.SplittableGenerator&gt;of(
      <span class="hljs-string">"L128X256MixRandom"</span>).create());
</code></pre>
    <p class="normal">The <code class="inlineCode">from()</code> methods are available starting with JDK 19. In the bundled code, you can see more examples.</p>
    <h1 id="_idParaDest-67" class="heading-1">37. Using pseudo-random generators in a thread-safe fashion (multithreaded environments)</h1>
    <p class="normal"><code class="inlineCode">Random</code> and <code class="inlineCode">SecureRandom</code> instances are thread-safe. While this statement is true, pay attention that when a <code class="inlineCode">Random</code> instance (or <code class="inlineCode">Math.random()</code>) is used by multiple threads (multithreaded environment), your code is<a id="_idIndexMarker177"/> prone to thread contention because these threads share the same <em class="italic">seed</em>. Sharing the same seed involves synchronization of the <em class="italic">seed</em> access; therefore, it opens the door to thread contention. Obviously, thread contention leads to performance penalties, since threads may wait in the queue to gain access to the <em class="italic">seed</em>. Synchronization is typically expensive.</p>
    <p class="normal">An alternative to <code class="inlineCode">Random</code> is <code class="inlineCode">ThreadLocalRandom</code>, which uses a <code class="inlineCode">Random</code> instance for each thread and provides protection against thread contention, since it doesn’t contain synchronized code or atomic operations. The downside is that <code class="inlineCode">ThreadLocalRandom</code> uses an internal <em class="italic">seed</em> per thread that we cannot control or modify.</p>
    <p class="normal"><code class="inlineCode">SplittableRandom</code> is not thread-safe. Moreover, the new API consisting of implementations of <code class="inlineCode">RandomGenerator</code> is not thread-safe.</p>
    <p class="normal">This being said, a pseudo-random generator can be used in a multithread environment by using a thread-safe generator, or by splitting a new instance for each new thread. And when I say “splitting,” I mean using <code class="inlineCode">SplittableGenerator.splits(long n)</code>, where <code class="inlineCode">n</code> is the number of splits. Check out <a id="_idIndexMarker178"/>the code that uses 10 threads to populate a Java list with integers (each thread uses its own pseudo-random generator):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Integer&gt; listOfInts = <span class="hljs-keyword">new</span> <span class="hljs-title">CopyOnWriteArrayList</span>&lt;&gt;();
<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span>
  <span class="hljs-operator">=</span> Executors.newCachedThreadPool();
<span class="hljs-type">SplittableGenerator</span> <span class="hljs-variable">splittableGenerator</span>
  <span class="hljs-operator">=</span> RandomGeneratorFactory
     .&lt;SplittableGenerator&gt;of(<span class="hljs-string">"L128X256MixRandom"</span>).create();
splittableGenerator.splits(<span class="hljs-number">10</span>)
  .forEach((anotherSplittableGenerator) -&gt; {
    executorService.submit(() -&gt; {
      <span class="hljs-type">int</span> <span class="hljs-variable">nextInt</span> <span class="hljs-operator">=</span> anotherSplittableGenerator.nextInt(<span class="hljs-number">1_000</span>);
      logger.info(() -&gt; <span class="hljs-string">"Added in list "</span> 
          + nextInt + <span class="hljs-string">" by generator "</span> 
          + anotherSplittableGenerator.hashCode()
          + <span class="hljs-string">" running in thread"</span>
          + Thread.currentThread().getName());
      listOfInts.add(nextInt);
    });
});
shutdownExecutor(executorService);
</code></pre>
    <p class="normal">A snippet from the output:</p>
    <pre class="programlisting con"><code class="hljs-con">INFO: Added in list 192 by generator 1420516714 running in threadpool-1-thread-3
INFO: Added in list 366 by generator 1190794841 running in threadpool-1-thread-8
INFO: Added in list 319 by generator 275244369 running in threadpool-1-thread-9
...
</code></pre>
    <p class="normal">You can also use a <code class="inlineCode">JumpableGenerator</code> or <code class="inlineCode">LeapableGenerator</code>. The only difference is that instead<a id="_idIndexMarker179"/> of <code class="inlineCode">splits()</code>, <code class="inlineCode">JumpableGenerator</code> uses <code class="inlineCode">jumps()</code> and <code class="inlineCode">LeapableGenerator</code> uses <code class="inlineCode">leaps()</code>.</p>
    <h1 id="_idParaDest-68" class="heading-1">Summary</h1>
    <p class="normal">This chapter collected 37 problems related to strings, locales, numbers, and math, intended to mix classical must-know problems with a bunch of problems solved via the latest JDK features, such as text blocks and pseudo-random generators. If you want to explore other similar problems, then consider <em class="italic">Java Coding Problems, First Edition</em>, which has a similar chapter (<em class="italic">Chapter 1</em>), covering another 39 problems.</p>
    <h1 class="heading-1">Leave a review!</h1>
    <p class="normal">Enjoying this book? Help readers like you by leaving an Amazon review. Scan the QR code below for a 20% discount code.</p>
    <p class="normal"><img src="../Images/Leave_Reivew_QR.png" style="width:10em;" alt="" role="presentation"/></p>
    <p class="normal" style="font-size:0.75em;"><em class="italic">*Limited Offer</em></p>
  </div>
</body></html>