- en: Chapter 6. JSF Flows and Finesse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. JSF流程与优雅
- en: '|   | *"I''ve had a chance to fly a lot of different airplanes, but it was
    nothing like the shuttle ride."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"我有机缘驾驶过很多不同的飞机，但那次航天飞机的体验完全不同。"* |   |'
- en: '|   | --*Commander Chris Hadfield* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*指挥官克里斯·哈德菲尔德* |'
- en: This chapter is about Faces Flow, a new feature in JSF 2.2\. The idea of flows
    stems from the concepts of workflows and business process management. A workflow
    is often an orchestrated and a repeatable sequence of business activities performed
    in order to do a unit of achievable work efficiently. The unit of work can involve
    transformation of state, processing of data, and/or provision of a service or
    information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍JSF 2.2中的新特性Faces Flow。流程的概念源于工作流程和业务流程管理的概念。工作流程通常是一系列有序且可重复的业务活动，旨在高效地完成一个可实现的单位工作。这项工作可能涉及状态转换、数据处理以及/或提供服务或信息。
- en: The checkout process in many web e-commerce applications is a good example of
    a workflow as it appears to the user. When you buy a product from Amazon, the
    site takes you to a separate area of the website for entering details. Behind
    the scenes, Amazon will gracefully move you from the micro service, which is responsible
    for handling products in the electronic and photography section, to the micro
    service that is the first step in the checkout workflow. You log in to your account
    or create a new one, and then you decide on the shipping address. Next, you pay
    with your credit or debit card, and Amazon will challenge you with an invoice
    address. Finally, you can choose how you want your products to be delivered. You
    can choose to group items together and also select express or regular delivery.
    Amazon is a complicated workflow to replicate; however, JSF allows the digital
    developer to build up from the fundamental simple flows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多网络电子商务应用中，结账流程是工作流程的一个很好的例子，它对用户来说是可见的。当你从亚马逊购买产品时，网站会带你到一个网站上的单独区域输入详细信息。在幕后，亚马逊会优雅地将你从负责处理电子和摄影部分产品的微服务，移动到结账工作流程的第一步微服务。你登录你的账户或创建一个新的账户，然后你决定送货地址。接下来，你用信用卡或借记卡支付，亚马逊会要求你提供一个发票地址。最后，你可以选择你希望产品如何交付。你可以选择将项目分组，也可以选择快递或普通配送。亚马逊的复杂工作流程难以复制；然而，JSF允许数字开发者从基本的简单流程构建起来。
- en: Workflows also appear in rich user client applications for people who use desktop
    computers, especially in the government and financial services industry. You may
    have witnessed workflow-like applications that are case working systems, trading
    systems, and warehouse systems. The idea is essentially the same, which is to
    guide the employee through separate steps in a business process from start to
    finish.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程也出现在面向丰富用户客户端的应用程序中，尤其是政府及金融服务行业。你可能见证过类似工作流程的应用程序，它们是案例工作系统、交易系统和仓库系统。其基本思想是相同的，即引导员工从业务流程的开始到结束，通过不同的步骤。
- en: In JSF 2.2, Faces Flow provides the basic programming API to create a behavior
    and user experience that resembles the workflow in general applications. Open
    source frameworks such as Apache MyFaces CODI (Orchestration module), Spring Web
    Flow, and the proprietary Oracle **Application Development Framework** (**ADF**)
    inspired the design of Faces Flow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.2中，Faces Flow提供了创建类似于通用应用程序工作流程的行为和用户体验的基本编程API。Apache MyFaces CODI（编排模块）、Spring
    Web Flow和专有的Oracle **应用程序开发框架**（**ADF**）等开源框架启发了Faces Flow的设计。
- en: What is Faces Flow?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Faces Flow？
- en: Faces Flow is the encapsulation of backing beans having a special scope with
    the related pages into a module. A Faces Flow is a module with a single, well-defined
    entry point and one or more exit points. The application developer determines
    how a Faces Flow is comprised and how it would function. In other words, Faces
    Flow is a low-level API, whereas other frameworks, with BPM in particular, feature
    higher-level configurations and macro-level processes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Faces Flow是将具有特殊作用域的后台bean及其相关页面封装到一个模块中。一个Faces Flow是一个具有单个、明确定义的入口点和一到多个出口点的模块。应用程序开发者决定Faces
    Flow的组成方式和其功能。换句话说，Faces Flow是一个低级API，而其他框架，特别是具有BPM的框架，具有高级配置和宏观流程功能。
- en: A JSF Faces Flow is modular in execution; a flow can invoke another flow in
    a nested fashion.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF Faces Flow在执行上是模块化的；一个流程可以以嵌套的方式调用另一个流程。
- en: Faces Flow can pass parameters to another nested flow and the nested flow can
    also return data through a special map property called the Flow Scope.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Faces Flow 可以将参数传递给另一个嵌套流程，嵌套流程也可以通过一个称为 Flow Scope 的特殊映射属性返回数据。
- en: Application developers can package a flow with the corresponding pages into
    a module, which may be distributed to a third-party developer.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序开发者可以将流程与相应的页面打包到一个模块中，该模块可以分发给第三方开发者。
- en: There is a brand new scope called `FlowScoped`, which denotes whether a POJO
    is a flow-scoped bean. The annotation for this is `@javax.faces.flow.FlowScoped`.
    A flow-scoped bean is compatible with CDI; so you can use the familiar Java EE
    annotations and order inject references to other beans and EJB elements.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个全新的作用域称为 `FlowScoped`，它表示一个 POJO 是否是 flow-scoped 实例。这个注解是 `@javax.faces.flow.FlowScoped`。flow-scoped
    实例与 CDI 兼容；因此，你可以使用熟悉的 Java EE 注解，并按顺序注入其他实例和 EJB 元素。
- en: You can write action-controller methods and handle the logic inside the flow-scoped
    beans as you would with `@RequestScoped`, `@ConversationScoped`, `@SessionScoped`,
    and `@ApplicationScoped` beans.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以像使用 `@RequestScoped`、`@ConversationScoped`、`@SessionScoped` 和 `@ApplicationScoped`
    实例一样，编写 action-controller 方法并在 flow-scoped 实例中处理逻辑。
- en: Flow definitions and lifecycle
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程定义和生命周期
- en: Faces Flows use the `@FlowScoped` beans where the user can enter a single page,
    which is known as the start page. After entering the flow, the user can navigate
    the pages, which are associated with the flow. The user can exit the flow at predefined
    points. A flow can invoke a nested flow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Faces Flows 使用 `@FlowScoped` 实例，用户可以进入一个单页，这被称为起始页。进入流程后，用户可以导航与流程关联的页面。用户可以在预定义的点上退出流程。一个流程可以调用嵌套流程。
- en: The lifecycle of the `@FlowScoped` beans is greater than the `@ViewScoped` beans,
    but shorter than that of `@SessionScoped`. Therefore, we can compare flow scoped
    beans to their conversational brethren. A `@ConversationalScoped` bean maintains
    a state for all the views and web page tabs in a browser. Like their conversation
    mates, the `@FlowScoped` beans survive multiple requests; in fact, they are even
    better, because they have different instances for multiple windows in a session.
    The flow-scoped bean is not shared between browser tabs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FlowScoped` 实例的生命周期长于 `@ViewScoped` 实例，但短于 `@SessionScoped` 实例。因此，我们可以将 flow-scoped
    实例与它们的对话兄弟进行比较。一个 `@ConversationalScoped` 实例维护浏览器中所有视图和网页标签的状态。像它们的对话伙伴一样，`@FlowScoped`
    实例可以存活多个请求；实际上，它们甚至更好，因为它们在会话中有多个窗口的不同实例。flow-scoped 实例不会在浏览器标签之间共享。'
- en: As the user enters and leaves the flows in the application, Faces Flows has
    a dedicated CDI scope, which the JSF framework implementation uses to activate
    and passivate the data of the bean.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进入和离开应用程序中的流程时，Faces Flows 有一个专门的 CDI 作用域，JSF 框架实现使用它来激活和钝化实份数据。
- en: As soon as the user leaves a flow, that instance is susceptible to garbage collection
    by the JVM. Therefore, in comparison to `@SessionScoped` and `@ConversationalScoped`
    beans, flows tend to have lower memory demands.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户离开一个流程时，该实例就会受到 JVM 的垃圾回收。因此，与 `@SessionScoped` 和 `@ConversationalScoped`
    实例相比，流程通常有较低的内存需求。
- en: The following diagram illustrates the scope of a Faces Flow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了 Faces Flow 的作用域。
- en: '![Flow definitions and lifecycle](img/image00407.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![流程定义和生命周期](img/image00407.jpeg)'
- en: Simple Implicit Faces Flows
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单隐式 Faces Flow
- en: It is relatively straightforward to create an Implicit Faces Flow with just
    a folder name, an empty XML configuration, and some Facelet pages. A `flow` is
    a folder name in your web application, preferably at the root directory. We start
    with the basic flow in the directory of the same name called `digitalFlow`. Your
    flow must match the name of the folder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件夹名称、一个空的 XML 配置和一些 Facelet 页面创建隐式 Faces Flow 是相对直接的。`flow` 是你 web 应用程序中的一个文件夹名称，最好在根目录下。我们从同一名称的目录中的基本流程
    `digitalFlow` 开始。你的流程必须与文件夹名称匹配。
- en: 'In order to define an implicit flow, we create an empty XML file with the common
    basename and a suffix: `digitalFlow/digitalFlow-flow.xhtml`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义隐式流程，我们创建一个具有通用基本名称和后缀的空 XML 文件：`digitalFlow/digitalFlow-flow.xhtml`。
- en: We now create a start page in the folder with the common basename. This file
    is a Facelet view page called `digitalFlow/digitalFlow.xhtml`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在具有通用基本名称的文件夹中创建一个起始页。这个文件是一个 Facelet 视图页面，称为 `digitalFlow/digitalFlow.xhtml`。
- en: We can create other pages in the flow inside the folder, and they can have any
    name we like. We might have `digitalFlow/digitalFlow1.xhtml`, `digitalFlow/checkout.xhtml`,
    or `digitalFlow/song.xhtml`. Only the defined flow `digitalFlow` can ever access
    these pages. If an outside call does attempt to access any of these pages, the
    JSF implementation will report an error.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在文件夹内创建其他页面，并且它们可以有任何我们喜欢的名称。我们可能有 `digitalFlow/digitalFlow1.xhtml`、`digitalFlow/checkout.xhtml`
    或 `digitalFlow/song.xhtml`。只有定义的流程 `digitalFlow` 可以访问这些页面。如果外部调用尝试访问这些页面中的任何一个，JSF
    实现将报告错误。
- en: In order to exit the implicit flow, we must provide a special page, `/digitalFlow-return.xhtml`,
    in the root folder of the web application, which means that the file is located
    outside of the folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了退出隐式流程，我们必须在 Web 应用的根目录中提供一个特殊的页面 `/digitalFlow-return.xhtml`，这意味着该文件位于文件夹之外。
- en: Implicit navigation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式导航
- en: 'Let''s put this knowledge to good use with our first Faces Flow navigation
    example. In the source code, the project is called `jsf-implicit-simple-flow`.
    It is helpful to examine the file layout for this project, which is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些知识运用到我们的第一个 Faces Flow 导航示例中。在源代码中，项目被命名为 `jsf-implicit-simple-flow`。检查这个项目的文件布局是有帮助的，布局如下：
- en: '`src/main/java`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/java`'
- en: '`src/main/webapp`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp`'
- en: '`src/main/webapp/WEB-INF/classes/META-INF`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/WEB-INF/classes/META-INF`'
- en: '`src/main/webapp/index.xhtml`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/index.xhtml`'
- en: '`src/main/webapp/assets/`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/assets/`'
- en: '`src/main/webapp/resources/`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/`'
- en: '`src/main/webapp/basic-layout.xhtml`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/basic-layout.xhtml`'
- en: '`src/main/webapp/view-expired.xhtml`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/view-expired.xhtml`'
- en: '`src/main/webapp/digitalFlow/`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/digitalFlow/`'
- en: '`src/main/webapp/digitalFlow/digitalFlow.xml`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/digitalFlow/digitalFlow.xml`'
- en: '`src/main/webapp/digitalFlow/digitalFlow.xhtml`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/digitalFlow/digitalFlow.xhtml`'
- en: '`src/main/webapp/digitalFlow/digitalFlow-p2.xthml`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/digitalFlow/digitalFlow-p2.xthml`'
- en: '`src/main/webapp/digitalFlow/digitalFlow-p2.xthml`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/digitalFlow/digitalFlow-p2.xthml`'
- en: '`src/main/webapp/digitalFlow/digitalFlow-p4.xthml`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/digitalFlow/digitalFlow-p4.xthml`'
- en: '`src/main/webapp/digitalFlow-return.xhtml`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/digitalFlow-return.xhtml`'
- en: As you study the preceding layout, you notice that the project has a standard
    home page called `index.xhtml`, as we would expect. It has a `digitalFlow` folder,
    which is the special area of the website dedicated for this Faces Flow. Inside
    this directory, there are a bunch of Facelet files and a configuration. The start
    page is called `digitalFlow.xhtml`, and there is an empty XML file reserved for
    a flow definition, `digitalFlow.xml`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究前面的布局时，你会注意到项目有一个标准的首页 `index.xhtml`，正如我们所期望的那样。它有一个 `digitalFlow` 文件夹，这是网站专门为这个
    Faces Flow 设定的特殊区域。在这个目录中，有一系列 Facelet 文件和一个配置。起始页面被称为 `digitalFlow.xhtml`，还有一个空的
    XML 文件用于流程定义，`digitalFlow.xml`。
- en: By now you are already aware of the purpose of the assets and resources folders,
    but the we will come back to the `view-expired.xhtml` file shortly. How do we
    ensure that our folder structure is treated as a Faces Flow?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经知道了资产和资源文件夹的目的，但我们将很快回到 `view-expired.xhtml` 文件。我们如何确保我们的文件夹结构被当作 Faces
    Flow 处理？
- en: A Flow scoped bean
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程作用域的 bean
- en: 'With the annotation `@javax.faces.flow.FlowScoped`, we define a POJO as a flow
    scoped bean. The following is the code for our first Faces Flow, which is a backing
    bean:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注解 `@javax.faces.flow.FlowScoped`，我们将一个 POJO 定义为一个流程作用域的 bean。以下是我们第一个 Faces
    Flow 的代码，它是一个后端 bean：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The simple controller class, `DigitalFlow`, has action methods such as `gotoPage1()`
    and `gotoPage2()` to move the user to the appropriate page in the flow. The method
    `gotoEndFlow()` navigates to the return Facelet view that JSF detects in order
    to exit the flow.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简单控制器类 `DigitalFlow` 有 `gotoPage1()` 和 `gotoPage2()` 等动作方法，用于将用户移动到流程中的适当页面。`gotoEndFlow()`
    方法导航到 JSF 检测到的返回 Facelet 视图，以便退出流程。
- en: The annotation of `@FlowScoped` requires a single String value parameter, which
    in this case matches the name of the folder `digitalFlow`. We shall now move to
    the views.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FlowScoped` 注解需要一个单个的 String 值参数，在这个情况下与文件夹名称 `digitalFlow` 匹配。我们现在将转到视图。'
- en: Facelet views
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facelet 视图
- en: 'We use flow-scoped beans in the Facelet views just as we use any other CDI
    scoped bean. The following is an extract of the home page, `index.xhtml`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Facelet 视图中使用流程作用域的 bean，就像我们使用任何其他 CDI 作用域的 bean 一样。以下是从首页 `index.xhtml`
    的摘录：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding view, the `<h:commandButton>` defines an action with the name
    of the flow, `digitalFlow`. Invoking this action causes JSF to enter the Faces
    Flow, which matches the corresponding annotated name of the backing bean.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的视图中，`<h:commandButton>`定义了一个名为流程的名称的动作，`digitalFlow`。调用此动作会导致JSF进入Faces
    Flow，与后端bean的相应注解名称匹配。
- en: JSF recognizes that a flow has implicit navigation, because the XML Flow Definition
    file `digitalFlow.xml` is empty. This file must exist; otherwise, the implementation
    reports an error. You do not need the start or end tags inside the file either.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JSF认识到流程具有隐式导航，因为XML流程定义文件`digitalFlow.xml`为空。此文件必须存在；否则，实现会报告错误。文件内也不需要开始或结束标签。
- en: 'When a user invokes the button, JSF instantiates a flow scoped bean before
    it is forwarded to the start page. The following is an extract from the start
    page of the flow `digitalFlow.xhtml`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调用按钮时，JSF在将其转发到起始页面之前实例化一个流程作用域bean。以下是从流程`digitalFlow.xhtml`起始页面的摘录：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The view demonstrates the invocation of the flow scoped bean with the familiar
    Expression Language as well as direct page-to-page navigation. To allow the user
    to move to the second page in the flow, we have two command buttons. The command
    button with the attribute action and value `digitalFlow-2` is page navigation
    direct without validation of any form input whatsoever. The command button with
    the attribute action and the expression language value, `#{digitalFlow.gotoPage2()}`
    is an invocation to the flow scoped bean's method, which means that the entire
    JSF lifecycle is executed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该视图展示了使用熟悉的表达式语言调用流程作用域bean以及直接页面间导航的调用。为了允许用户移动到流程中的第二页，我们有两个命令按钮。具有属性action和值`digitalFlow-2`的命令按钮是页面导航直接，无需验证任何表单输入。具有属性action和表达式语言值`#{digitalFlow.gotoPage2()}`的命令按钮是对流程作用域bean方法的调用，这意味着执行整个JSF生命周期。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: See [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer Faces Lifecycle"),
    *JavaServer Faces Lifecycle*, if you have forgotten the different phases in the
    lifecycle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记了生命周期中的不同阶段，请参阅[第2章](part0025.xhtml#aid-NQU22 "第2章 JavaServer Faces生命周期")，*JavaServer
    Faces生命周期*。
- en: In this view, we also generate the output, `#{digitalFlow.debugClassName()}`,
    in order to illustrate that we can invoke arbitrary methods in a flow-scoped bean.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，我们还生成了输出`#{digitalFlow.debugClassName()}`，以说明我们可以在流程作用域bean中调用任意方法。
- en: 'Let me also draw your attention to the expression language that establishes
    if a view is a part of the flow or not through the following practical content:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我也提醒您注意以下实际内容中建立视图是否为流程一部分的表达式语言：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is functionally equivalent to the following Java statement:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这在功能上等同于以下Java语句：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other pages, `digitalFlow-p2.xhtml` and `digitalFlow-p3.xhtml`, are very
    similar, because they just add the command buttons to navigate back to the previous
    views. You can see the full code as part of the book's source distribution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其他页面，`digitalFlow-p2.xhtml`和`digitalFlow-p3.xhtml`，非常相似，因为它们只是添加了命令按钮以导航回前一个视图。您可以在书籍源代码分布中看到完整的代码。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In digital work, we often provide well-known identifiers (IDs) to certain HTML
    elements, especially form controls. This helps when we are writing testing scripts
    for web automation testing, especially with the Selenium Web Driver framework
    ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字工作中，我们经常为某些HTML元素提供众所周知的标识符（ID），尤其是表单控件。当我们编写用于网络自动化测试的测试脚本时，这非常有帮助，尤其是在使用Selenium
    Web Driver框架([http://www.seleniumhq.org/](http://www.seleniumhq.org/))时。
- en: 'We shall jump to the final view, `digitalFlow-p4.xhtml` and just extract the
    form element for study:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳转到最终视图，`digitalFlow-p4.xhtml`，并仅提取表单元素进行研究：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, the preceding content illustrates how to navigate directly and
    through the `DigitalFlow` backing bean. In order to exit the flow in an implicit
    navigation, the user must trigger an event that takes the JSF framework to the
    `/digitalFlow-return.xhtml` view, which causes the flow to finish. Directly navigating
    to the return mode avoids validation, and any data inside the form input elements
    is lost. If we want to validate the form input elements as a form request, we
    must invoke a method in the action controller, the backing bean.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的内容说明了如何直接通过`DigitalFlow`后端bean进行导航。为了在隐式导航中退出流程，用户必须触发一个事件，将JSF框架带到`/digitalFlow-return.xhtml`视图，这将导致流程结束。直接导航到返回模式会跳过验证，并且表单输入元素中的任何数据都会丢失。如果我们想将表单输入元素作为表单请求进行验证，我们必须在动作控制器、后端bean中调用一个方法。
- en: And that is implicit navigation in JSF Faces Flow.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JSF Faces Flow中的隐式导航。
- en: 'It really is that easy, so let''s see some screenshots of this simple flow
    starting with the home page `/index.html`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是这么简单，所以让我们看看这个简单流程的截图，从主页`/index.html`开始：
- en: '![Facelet views](img/image00408.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Facelet视图](img/image00408.jpeg)'
- en: 'The start page `digital-flow.xhtml` for `DigitalFlow` appears like the following
    screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`DigitalFlow`的起始页面`digital-flow.xhtml`看起来如下截图所示：'
- en: '![Facelet views](img/image00409.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Facelet视图](img/image00409.jpeg)'
- en: 'After exiting the flow, the user sees the view `/digitalFlow-return.xhtml`.
    The following is a screenshot of this view:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 退出流程后，用户看到视图`/digitalFlow-return.xhtml`。以下是这个视图的截图：
- en: '![Facelet views](img/image00410.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Facelet视图](img/image00410.jpeg)'
- en: 'If we attempt to access a Facelet view directly through a known URI `/digitalFlow/digitalFlow.xhtml`
    before entering the flow, the view would be like the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在进入流程之前尝试通过已知的URI `/digitalFlow/digitalFlow.xhtml` 直接访问Facelet视图，视图将类似于以下截图：
- en: '![Facelet views](img/image00411.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Facelet视图](img/image00411.jpeg)'
- en: With GlassFish 4.1, we receive an HTTP Response Code of 500, which is an internal
    server error. Moreover, the CDI container raises an exception that there is no
    active flow scope.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GlassFish 4.1，我们收到一个500的HTTP响应码，这是一个内部服务器错误。此外，CDI容器抛出一个异常，表示没有活动的流程作用域。
- en: Handling view expired
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理视图过期
- en: I promised you that we would add some finesse to our digital application. If
    you've worked with JSF for a while, you probably have your fair share of stack
    traces with `javax.faces.application.ViewExpiredException` as the root cause.
    This is one of the most notorious exceptions. You could increase the HTTP Session
    lifetime in order to compensate for an out-of-date request, but how long is break
    away from the computer for an average person? Meanwhile, the objects would persist
    in the memory. There is a better way and that is by using the Web XML deployment
    descriptor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺过，我们会给我们的数字应用增加一些精致。如果你已经使用JSF了一段时间，你可能有一份相当多的带有`javax.faces.application.ViewExpiredException`作为根本原因的堆栈跟踪。这是最臭名昭著的异常之一。你可以增加HTTP会话的生存时间来补偿过时的请求，但一个普通人离开电脑有多长时间呢？同时，对象会持续存在于内存中。有一种更好的方法，那就是使用Web
    XML部署描述符。
- en: 'Inside the applications `web.xml` file, we need to trigger a redirection to
    a more pleasant error page. The following is an extract of the XML file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的`web.xml`文件中，我们需要触发一个重定向到更令人愉悦的错误页面。以下是从XML文件中提取的内容：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `<error-page>` element specifies an association between an exception type
    and a page view. Whenever JSF encounters the exception type `ViewExpiredException`,
    it will progress the response action to the page view `/view-expired.xhtml`. The
    circumstance of this behavior is illustrated in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`<error-page>`元素指定了异常类型和页面视图之间的关联。每当JSF遇到异常类型`ViewExpiredException`时，它将响应动作推进到页面视图`/view-expired.xhtml`。此行为的情况在以下截图中有说明：'
- en: '![Handling view expired](img/image00412.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![处理视图过期](img/image00412.jpeg)'
- en: I am sure you'll agree that our public customer will enjoy this improved and
    dedicated page view rather than being puzzled with a stack trace.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你们会同意，我们的公开客户会喜欢这个改进的专用页面视图，而不是对堆栈跟踪感到困惑。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Flow scoped beans depend on CDI and, therefore, they require a Java EE 7 environment
    which dictates a CDI 1.1 container such as JBoss Weld. You must also use `@Named`
    and not the older style `@ManagedBean` annotation. If you don't use WildFly 8
    or GlassFish 4, then before you dive into the code, please check your container's
    implementation support for the latest JSF and CDI specifications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 流程范围内的Bean依赖于CDI，因此它们需要一个Java EE 7环境，这决定了CDI 1.1容器，例如JBoss Weld。您还必须使用`@Named`而不是较旧的`@ManagedBean`注解。如果您不使用WildFly
    8或GlassFish 4，那么在深入代码之前，请检查您容器的实现是否支持最新的JSF和CDI规范。
- en: A comparison with conversational scoped beans
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与对话范围Bean的比较
- en: If you recall, while using `@ConversationScoped` beans, we had to explicitly
    demarcate the state of the conversation. We injected the `Conversation` instance
    and from there, at specific points in the digital customer journey, called the
    `begin()` and `end()` methods. With `@FlowScoped` CDI beans, the scope is automatically
    started and finished at defined points.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在使用`@ConversationScoped` Bean时，我们必须显式地标记对话的状态。我们注入了`Conversation`实例，并在数字客户旅程的特定点上调用`begin()`和`end()`方法。使用`@FlowScoped`
    CDI Bean，作用域将在定义的点自动开始和结束。
- en: Capturing the lifecycle of flow scoped beans
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获流程范围Bean的生命周期
- en: Since the CDI container manages the flow scoped beans, they can participate
    normally in the contextual lifecycle. We can annotate a method with `@PostConstruct`
    in order to initialize the bean, acquire a database resource, or compute cacheable
    data. Likewise, when the flow goes out of scope, we can annotate a method with
    `@PreDestroy`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CDI容器管理流程范围Bean，它们可以正常参与上下文生命周期。我们可以使用`@PostConstruct`注解来初始化Bean，获取数据库资源或计算可缓存的缓存数据。同样，当流程超出作用域时，我们可以使用`@PreDestroy`注解方法。
- en: Declarative and nested flows
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明性和嵌套流程
- en: Up to now, we have seen the implicit flow in action. Implicit flow is very straightforward
    for the simplest flow, which performs like a basic web wizard where the user is
    able to navigate linearly, going forward and backward. It can also use random
    access to navigate to pages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了隐式流程的实际应用。对于最简单的流程，隐式流程非常直接，它就像一个基本的网页向导，用户可以线性地导航，向前和向后移动。它还可以使用随机访问来导航到页面。
- en: If we want to take Faces Flow further, then we must delve into the XML flow
    definition, but first let us define some terms.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要进一步扩展Faces Flow，那么我们必须深入研究XML流程定义，但首先让我们定义一些术语。
- en: The flow node terminology
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程节点术语
- en: 'The fundamental technology being inspired by workflow and BPM, the Faces Flow
    specification declares different types of nodes which are given in the following
    table:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 受工作流和BPM启发的根本技术，Faces Flow规范声明了以下表格中给出的不同类型的节点：
- en: '| Node Type Name | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 节点类型名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **View** | Represents any type of application JSF view |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **视图** | 表示任何类型的JSF应用视图 |'
- en: '| **Method Call** | Represents a method invocation in the flow graph through
    **Expression Language** (**EL**) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **方法调用** | 表示通过**表达式语言**（**EL**）在流程图中进行方法调用 |'
- en: '| **Flow Call** | Represents an invocation of another flow with outbound (call)
    and (return) inbound parameters |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **流程调用** | 表示调用另一个流程，带有出站（调用）和入站（返回）参数 |'
- en: '| **Flow Return** | Represents a return to the calling flow |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **流程返回** | 表示返回到调用流程 |'
- en: '| **Switch** | Represents navigation selection through logic determined by
    EL |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **切换** | 表示通过EL（表达式语言）确定的逻辑进行导航选择 |'
- en: The following is an illustration of two flows that represent a shopping cart
    business process. The outside flow invokes the nested flow, which handles the
    delivery method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个说明两个流程的示例，这两个流程代表了一个购物车业务流程。外部流程调用嵌套流程，该流程处理配送方式。
- en: '![The flow node terminology](img/image00413.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![流程节点术语](img/image00413.jpeg)'
- en: An XML flow definition description file
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML流程定义描述文件
- en: Given that `<<Flowname>>` is a folder name in the web application, the flow
    description filename matches the pattern, `<<Flowname>>/<<Flowname>>.xml`. The
    content of this descriptor file declares to JSF certain characteristics of the
    flow. It may define an alternative start page, define a set of return outcomes,
    and map certain outcomes to specific pages. The descriptor can also define the
    conditional Boolean logic that maps the outcomes to particular pages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `<<Flowname>>` 是 web 应用程序中的一个文件夹名称，流程描述文件名与该模式匹配，即 `<<Flowname>>/<<Flowname>>.xml`。此描述文件的内容声明了
    JSF 流的某些特性。它可以定义一个替代起始页，定义一组返回结果，并将某些结果映射到特定的页面。描述符还可以定义将结果映射到特定页面的条件布尔逻辑。
- en: 'The following is an example of an XML flow definition file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 XML 流定义文件的示例：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The root element must be a `<faces-config>` tag with the appropriate XML namespaces.
    You might be surprised by this choice of root element. This is because a flow
    definition can be defined globally, across the application, by setting the flow
    definition in the `/WEB-INF/faces-config.xml` file. However, this practice is
    an advanced use case and not recommended for modular development.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素必须是带有适当 XML 命名空间的 `<faces-config>` 标签。您可能会对这种根元素的选择感到惊讶。这是因为流程定义可以在整个应用程序范围内全局定义，通过在
    `/WEB-INF/faces-config.xml` 文件中设置流程定义来实现。然而，这种做法是一个高级用例，不建议用于模块化开发。
- en: A flow definition tag
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流定义标签
- en: The `<flow-definition>` element establishes the Faces Flow with the defined
    flow ID. The value of the identifier must match the value for the `@FlowScoped`
    bean. This element contains a collection of tags to establish the start page,
    views, flow returns, or the conditional switch statement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`<flow-definition>` 元素通过定义的流程 ID 建立 Faces 流。标识符的值必须与 `@FlowScoped` 实例的值匹配。此元素包含一系列标签，用于建立起始页、视图、流程返回或条件切换语句。'
- en: A mandatory flow return tag
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必要的流程返回标签
- en: A Faces Flow must have at least one return outcome. The `<flow-return>` element
    establishes a flow return node with an ID. It must contain a `<flow-outcome>`
    element whose body content specifies the Facelet view.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Faces 流必须至少有一个返回结果。`<flow-return>` 元素通过 ID 建立一个流程返回节点。它必须包含一个 `<flow-outcome>`
    元素，其主体内容指定了 Facelet 视图。
- en: A view page tag
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图页面标签
- en: A flow may optionally define a set of View Nodes (pages) that are useful for
    direct navigation from one view to another, within the scope. The element `<view>`
    tag establishes a view description language node through the element `<vdl-document>`.
    A view requires an identifier. The body content of this tag simply references
    a Facelet view. Therefore, the view ID does not necessarily have be the same name
    as the Facelet view.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以可选地定义一组视图节点（页面），这些节点对于在范围内从一视图直接导航到另一视图是有用的。`<view>` 标签通过 `<vdl-document>`
    元素建立视图描述语言节点。视图需要一个标识符。此标签的主体内容简单地引用了一个 Facelet 视图。因此，视图 ID 不一定必须与 Facelet 视图同名。
- en: An optional start page tag
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选的起始页标签
- en: The developer can override the name of the default start page and provide an
    alternative view. The body content of the element `<start-node>` specifies the
    view ID and, therefore, references an appropriate flow, a View Node.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以覆盖默认起始页的名称并提供一个替代视图。元素 `<start-node>` 的主体内容指定了视图 ID，因此引用了一个适当的流程，即视图节点。
- en: Switch, conditional, and case tags
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换、条件和案例标签
- en: The flow definition offers the developer the capability to define conditional
    logic through an element tag called `<switch>`. This is the highest of the low-level
    features in the XML. The `<switch>` tag specifies a Switch Node, which is very
    similar to the use of the `<if>` tags within a `<navigation-case>` in the `/WEB-INF/faces-config.xml`
    file, obviously for non-flow navigation. The switch allows a single outcome in
    the flow to map more than one Facelet view by evaluating an EL expression with
    conditional logic.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 流定义通过一个名为 `<switch>` 的元素标签为开发者提供了定义条件逻辑的能力。这是 XML 中低级功能中的最高级。`<switch>` 标签指定了一个切换节点，这与在
    `/WEB-INF/faces-config.xml` 文件中的 `<navigation-case>` 内使用 `<if>` 标签非常相似，显然是为了非流程导航。切换允许在流程中通过评估带有条件逻辑的
    EL 表达式来映射多个 Facelet 视图。
- en: 'The following is an extended version of the XML flow definition example file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个扩展的 XML 流定义示例文件：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `<switch>` tag contains a number of `<case>` elements and a single `<default-outcome>`
    element. Each `<case>` element contains a single `<if>` and `<from-outcome>` elements.
    The body content of the `<if>` defines a conditional logic EL. The `<from-outcome>`
    maps to the final Facelet view or it references the identifier of a View Node.
    It is a very good idea to a have a default outcome for a Switch Node. The body
    content of a `<default-outcome>` establishes this outcome when none of the case
    conditions happen to evaluate to true.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`<switch>`标签包含多个`<case>`元素和一个单独的`<default-outcome>`元素。每个`<case>`元素包含一个`<if>`和`<from-outcome>`元素。`<if>`的正文内容定义了一个条件逻辑EL。`<from-outcome>`映射到最终的Facelet视图或引用视图节点的标识符。为Switch节点设置一个默认结果是很好的主意。当所有case条件都不为真时，`<default-outcome>`的正文内容确定这个结果。'
- en: In the example, we have an imaginary payment controller used in a checkout process
    on an e-commerce website. When the flow encounters an outcome `customerPaymentTab`,
    which is the identifier for the Switch Node, JSF processes each of the case conditional
    logics in order. If one of those condition tests evaluates to true, then JSF chooses
    that outcome as the result of the switch. Let's say the `#{controller.paymentType
    == 'DebitCard' }` is true, then debit card is the chosen view. If none of the
    tests evaluates to true, then the resulting view is `bacs-direct`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个在电子商务网站结账过程中使用的虚拟支付控制器。当流程遇到`customerPaymentTab`结果，这是Switch节点的标识符时，JSF按顺序处理每个case条件逻辑。如果这些条件测试中的任何一个评估为真，那么JSF就选择该结果作为switch的结果。比如说`#{controller.paymentType
    == 'DebitCard' }`为真，那么借记卡就是选择视图。如果没有测试评估为真，那么结果视图是`bacs-direct`。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: But shouldn't all logic be defined in a controller instead of a Switch Node?
    The answer is controversial either way, and it depends. If you are building an
    application with a complex graph of Faces Flows as a library developer, one can
    argue for this flexibility for external configurators. If you are building simple
    applications, then maybe following the practice of YAGNI (You Aren't Going to
    Need it) will benefit in a minimum viable product.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，所有的逻辑不都应该在控制器中定义而不是在Switch节点中吗？无论哪种方式，答案都是具有争议性的，并且取决于具体情况。如果你作为一个库开发者构建一个具有复杂Faces
    Flow图的复杂应用程序，那么可以争论这种灵活性对于外部配置器是有益的。如果你在构建简单应用程序，那么遵循YAGNI（You Aren't Going to
    Need it）的实践可能有助于最小可行产品。
- en: This covers all that we need to know about the basic flow definition file. Let's
    move on to the nested declarative flow now.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们需要了解的所有关于基本流程定义文件的内容。现在让我们继续看嵌套声明性流程。
- en: A nested flow example
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是一个嵌套流程的例子
- en: 'It''s time to see a practical example of Faces Flow with nested declarative
    flow definitions. Our application is simple. It allows the customer to record
    carbon footprint data. So first let''s define a data record:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看嵌套声明性流程定义的Faces Flow的实际例子了。我们的应用程序很简单。它允许客户记录碳足迹数据。所以首先让我们定义一个数据记录：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `CarbonFootprint` is a JPA entity bean, which declares a set of properties
    to store the customer's carbon footprint data. The user can supply their industry
    or sector, the amount of electricity, natural gas, diesel, and petrol they consume
    over a time period. The record also has an `applicationId` value, which we shall
    make use of.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarbonFootprint`是一个JPA实体bean，它声明了一组属性来存储客户的碳足迹数据。用户可以提供他们的行业或部门，以及他们在一段时间内消耗的电力、天然气、柴油和汽油的数量。记录还有一个`applicationId`值，我们将利用它。'
- en: 'Let''s view the file layout for this project:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看这个项目的文件布局：
- en: '`src/main/java`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/java`'
- en: '`src/main/webapp`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp`'
- en: '`src/main/webapp/WEB-INF/classes/META-INF`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/WEB-INF/classes/META-INF`'
- en: '`src/main/webapp/index.xhtml`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/index.xhtml`'
- en: '`src/main/webapp/assets/`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/assets/`'
- en: '`src/main/webapp/resources/`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/`'
- en: '`src/main/webapp/basic-layout.xhtml`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/basic-layout.xhtml`'
- en: '`src/main/webapp/view-expired.xhtml`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/view-expired.xhtml`'
- en: '`src/main/webapp/section-flow/`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/section-flow/`'
- en: '`src/main/webapp/section-flow/section-flow.xml`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/section-flow/section-flow.xml`'
- en: '`src/main/webapp/section-flow/section-flow.xhtml`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/section-flow/section-flow.xhtml`'
- en: '`src/main/webapp/section-flow/section-flow-1a.xthml`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/section-flow/section-flow-1a.xthml`'
- en: '`src/main/webapp/section-flow/section-flow-1b.xthml`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/section-flow/section-flow-1b.xthml`'
- en: '`src/main/webapp/section-flow/section-flow-1c.xthml`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/section-flow/section-flow-1c.xthml`'
- en: '`src/main/webapp/footprint-flow/`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/footprint-flow/`'
- en: '`src/main/webapp/footprint-flow/footprint-flow.xml`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/footprint-flow/footprint-flow.xml`'
- en: '`src/main/webapp/footprint-flow/footprint-flow.xhtml`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/footprint-flow/footprint-flow.xhtml`'
- en: '`src/main/webapp/footprint-flow/footprint-flow-1a.xml`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/footprint-flow/footprint-flow-1a.xml`'
- en: '`src/main/webapp/endflow.xhtml`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/endflow.xhtml`'
- en: 'The project is called `jsf-declarative-flows` and is available as a part of
    the book''s source code. There are two flows: `section-flow` and `digital-flow`.
    The section flow captures the industry information in this made-up example. The
    footprint flow captures the energy consumption data. Both flows share a customer
    detail record, the `CarbonFootprint` entity object, which you will see later in
    the backing beans.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目名为 `jsf-declarative-flows`，并作为书籍源代码的一部分提供。该项目包含两个流程：`section-flow` 和 `digital-flow`。章节流程捕捉了这个虚构示例中的行业信息。足迹流程捕捉能源消耗数据。这两个流程共享一个客户详细信息记录，即
    `CarbonFootprint` 实体对象，您将在后面的 backing beans 中看到。
- en: XML flow definitions
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML 流程定义
- en: 'The following is the XML flow definition for the Sector flow, `sector-flow/sector-flow.xhtml`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应于行业流程的 XML 流程定义，`sector-flow/sector-flow.xhtml`：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The identifier for this flow is sector-flow, which matches the folder name.
    It also establishes the `@FlowScoped` value for the backing bean, the action controller,
    as we shall see later.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此流程的标识符为 `sector-flow`，与文件夹名称匹配。它还建立了 backing bean、动作控制器上的 `@FlowScoped` 值，正如我们稍后将要看到的。
- en: There are two Flow Return nodes, namely `goHome` and `endFlow`. The `goHome`
    has direct navigation to the home page, whereas `endFlow` invokes an action on
    the bean through the EL value, `#{sectorFlow.gotoEndFlow()}`. This technique is
    particularly useful to ensure that a customer has entered correct and validated
    data before allowing them to complete their digital journey.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个流程返回节点，即 `goHome` 和 `endFlow`。`goHome` 具有直接导航到主页的功能，而 `endFlow` 通过 EL 值 `#{sectorFlow.gotoEndFlow()}`
    在 bean 上调用操作。这种技术特别有用，可以确保在允许客户完成他们的数字旅程之前，他们已经输入了正确并经过验证的数据。
- en: The new node `callFootprintFlow` represents a nested flow invocation. The element
    `<flow-call>` defines a Flow Call node. It must have a `<flow-reference>` tag
    element with a nested tag, `<flow-id>`. The body content of the latter defines
    the identifier of the target flow.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点 `callFootprintFlow` 代表嵌套流程调用。元素 `<flow-call>` 定义了一个流程调用节点。它必须有一个 `<flow-reference>`
    标签元素，其中嵌套 `<flow-id>` 标签。后者的主体内容定义了目标流程的标识符。
- en: The `<outbound-parameter>` elements specify how the parameters and value pairs
    are passed to the target flow. Each parameter requires a `<name>` and a `<value>`
    element. The name of the outgoing parameter in the calling flow must match the
    name of the incoming parameter in the invoked flow.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`<outbound-parameter>` 元素指定了如何将参数和值对传递到目标流程。每个参数都需要一个 `<name>` 和一个 `<value>`
    元素。调用流程中传出参数的名称必须与被调用流程中传入参数的名称匹配。'
- en: 'The `param1FromSectorFlow` and `param2FromSectorFlow` demonstrate how to pass
    the literal String values from one flow to another. If you are passing numeric
    values, then you have to encode and decode these values yourself in the target
    flow. The parameters `param3FromSectorFlow` and `param4FromSectorFlow` also illustrate
    how EL can be used. Note how we can easily pass the entity record `#{sectorFlow.footprint}`
    from the Sector Flow to the Footprint Flow. We can also pass an individual property
    as we have done in the final parameter: `#{sectorFlow.footprint.applicationId}`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`param1FromSectorFlow` 和 `param2FromSectorFlow` 展示了如何从一个流程传递字面字符串值到另一个流程。如果您传递的是数值，那么您必须在目标流程中自行编码和解码这些值。参数
    `param3FromSectorFlow` 和 `param4FromSectorFlow` 也说明了如何使用 EL。注意我们如何轻松地将实体记录 `#{sectorFlow.footprint}`
    从行业流程传递到足迹流程。我们还可以像在最后一个参数中那样传递单个属性：`#{sectorFlow.footprint.applicationId}`。'
- en: 'The following is the XML flow definition for the Footprint Flow `footprint-flow/footprint-flow.xml`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应于足迹流程的 XML 流程定义，`footprint-flow/footprint-flow.xml`：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This flow is identified by the name `footprint-flow.xml`. It has a set of return
    flow nodes. The `goHome` node actually exits the flows to the calling home, despite
    the view document value `/index` value. You might think this behavior as odd.
    However, JSF is correct, because the current flow Footprint is a nested flow and
    it drives the flow pointer to the state of the calling flow sector. The nodes
    `exitFromFootprintFlow` and `exitToSectionFlow` represent different navigation
    strategies, indirect and direct respectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此流程通过名称 `footprint-flow.xml` 进行标识。它有一组返回流程节点。`goHome` 节点实际上会退出流程到调用主页，尽管视图文档值为
    `/index`。您可能会认为这种行为很奇怪。然而，JSF 是正确的，因为当前的流程足迹是一个嵌套流程，它将流程指针驱动到调用流程 `sector` 的状态。节点
    `exitFromFootprintFlow` 和 `exitToSectionFlow` 代表不同的导航策略，分别是间接和直接。
- en: The set of `<inbound-parameter>` elements specify the incoming parameter to
    the flow. The names of the parameters are extremely important, because they must
    match those in the corresponding `<outbound-parameter>` element in the calling
    flow. The values define the EL object reference, which say where these values
    are written. In other words, the passing of parameters in Faces Flow behaves like
    a mapped property name transfer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`<inbound-parameter>` 元素的集合指定了流向流程的传入参数。参数的名称非常重要，因为它们必须与调用流程中相应的 `<outbound-parameter>`
    元素中的名称匹配。值定义了 EL 对象引用，它说明了这些值被写入的位置。换句话说，在 Faces Flow 中的参数传递行为类似于映射属性名称传输。'
- en: 'Let''s analyze the third parameter from `sector-flow.xml`. It sends a value
    of the entity record instance `CarbonFootprint` to the nested Footprint Flow:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析 `sector-flow.xml` 的第三个参数。它将实体记录实例 `CarbonFootprint` 的值发送到嵌套的 Footprint
    流程：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside `footprint-flow.xml`, the inbound parameter name matches the incoming
    parameter name:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `footprint-flow.xml` 中，传入参数名称与传入参数名称匹配：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The EL specifies the location where JSF sets the value of the parameter to the
    property of the object. In this case, the `flowScope` map collection has a key
    and a value set. We can use any existing object that has a lifespan greater or
    equal to the flow lifecycle. We tend to use the `flowScope`, because it is designed
    to pass parameters between Face Flows. Because we can reference properties in
    objects, we also have the ability to return information from the nested flows.
    The calling flow may retrieve the value after the nested flow ends.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: EL 指定了 JSF 设置参数值到对象属性的位置。在这种情况下，`flowScope` 映射集合有一个键和一个值设置。我们可以使用任何具有生命周期大于或等于流程生命周期的现有对象。我们倾向于使用
    `flowScope`，因为它旨在在 Face Flows 之间传递参数。因为我们可以在对象中引用属性，所以我们也有从嵌套流程返回信息的能力。调用流程可以在嵌套流程结束后检索值。
- en: Now that we understand the nested flows from the XML perspective, we can look
    at the Java source code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从 XML 视角理解了嵌套流程，我们可以查看 Java 源代码。
- en: Flow beans
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流程 Bean
- en: 'The `sector-flow` backing bean looks as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`sector-flow` 后备 Bean 的外观如下：'
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The class `SectorFlow` is annotated with `@FlowScoped`, and the value matches
    the flow definition XML file. We annotate a method `initialize()` with `@PostConstruct`
    in order to set a random application ID in the entity record. Note that we cannot
    put this logic inside a normal Java constructor here, because our bean is given
    life through the CDI container.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`SectorFlow` 类用 `@FlowScoped` 注解，其值与流程定义 XML 文件匹配。我们用 `@PostConstruct` 注解一个
    `initialize()` 方法，以便在实体记录中设置随机应用程序 ID。请注意，我们无法在这里将此逻辑放入正常的 Java 构造函数中，因为我们的 Bean
    是通过 CDI 容器赋予生命的。'
- en: We inject a couple of instances into `SectorFlow`. The `UtilityHelper` is an
    `@ApplicationScoped` CDI POJO class that generates a random application identifier.
    There is a stateful EJB `CarbonFootprintService` that handles the JPA persistence.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `SectorFlow` 注入几个实例。`UtilityHelper` 是一个 `@ApplicationScoped` CDI POJO 类，用于生成随机应用程序标识符。有一个有状态的
    EJB `CarbonFootprintService` 负责处理 JPA 持久化。
- en: The `gotoEndflow()` method is a navigation end to exit the flow. The method,
    `saveFootprintRecord()` uses the data service to store the `CarbonFootprint` entity
    into a database.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`gotoEndflow()` 方法是一个导航结束，用于退出流程。该方法 `saveFootprintRecord()` 使用数据服务将 `CarbonFootprint`
    实体存储到数据库中。'
- en: 'That completes the inner flow, that is, `SectorFlow`; the code for the nested
    backing bean `FootprintFlow` is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了内部流程，即 `SectorFlow`；嵌套后备 Bean `FootprintFlow` 的代码如下：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We repeat the same trick as before; we annotate the `FootprintFlow` class with
    `@PostConstruct`. In the `initialize()` method, we retrieve the object from the
    flow scope programmatically through the `FacesContext` instance. Note that the
    parameter name `param3Value` must agree with the value inside the XML definition.
    The value in the flow scope happens to be the `CarbonFootprint` entity.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复之前的技巧；我们用 `@PostConstruct` 注解 `FootprintFlow` 类。在 `initialize()` 方法中，我们通过
    `FacesContext` 实例程序性地从流程作用域中检索对象。请注意，参数名称 `param3Value` 必须与 XML 定义中的值一致。流程作用域中的值恰好是
    `CarbonFootprint` 实体。
- en: You must be wondering why we go to the trouble of retrieving an entity from
    a scope and setting it as a bean property? It is just an example, and allows the
    page content designer to use a consistent markup in the pages. The EL `#{footprintFlow.footprint.diesel}`
    is more comprehensible than `#{flowScope.param3Value.diesel}`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们要费心从一个作用域中检索一个实体并将其设置为 bean 属性？这只是一个例子，允许页面内容设计者在页面中使用一致的标记。EL `#{footprintFlow.footprint.diesel}`
    比起 `#{flowScope.param3Value.diesel}` 更易于理解。
- en: We shall now move on to the markup.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向标记。
- en: Page views
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面视图
- en: 'The content markup for page views is familiar to us by now. Let''s study `sector-flow/sector-flow.xhtml`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经熟悉了页面视图的内容标记。让我们研究一下 `sector-flow/sector-flow.xhtml`：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The view uses a mix of HTML5 friendly markup and the standard JSF tags. The
    input text field, `exampleInputEmail1` and its associated label remind us about
    the HTML5 friendly markup. This input control is associated with the flow scope
    map collection, namely `#{flowScope.email}`. The answer is yes, we are allowed
    to write this, but we had better store the data value somewhere in the application!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 视图使用 HTML5 友好的标记和标准 JSF 标签的混合。输入文本字段 `exampleInputEmail1` 及其关联的标签提醒我们关于 HTML5
    友好的标记。此输入控件与流程作用域映射集合相关联，即 `#{flowScope.email}`。答案是肯定的，我们被允许这样做，但我们最好在应用程序的某个地方存储数据值！
- en: The input element `industryOrSector` shows us the JSF standard tags and it is
    directly associated with the `CarbonFootprint` entity record.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输入元素 `industryOrSector` 显示了 JSF 标准标签，并且它直接关联到 `CarbonFootprint` 实体记录。
- en: Let me draw your attention to the command button `saveBtn` that invokes the
    action method `saveFootprintRecord()` in the backing bean. Finally, there is a
    dedicated command button identified by `callFootPrintFlowBtn`, which invokes the
    nested flows. The action `callFootprintFlow` matches the node in the XML flow
    definition file for `sector-flow.xml` exactly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我提醒大家注意那个调用后端 bean 中 `saveFootprintRecord()` 动作方法的命令按钮 `saveBtn`。最后，有一个专门的命令按钮，其标识为
    `callFootPrintFlowBtn`，它调用嵌套流程。`callFootprintFlow` 动作与 `sector-flow.xml` 流定义文件中的节点完全匹配。
- en: There is a `nextBtn` command button that directly navigates to the next view
    in the flow. The `homeBtn` command button exits the flow and returns the home
    page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `nextBtn` 命令按钮，可以直接导航到流程中的下一个视图。`homeBtn` 命令按钮退出流程并返回主页。
- en: The rest of the view shows debuggable output in an HTML Bootstrap style table.
    The `prependId=false` on the JSF `<h:form>` element informs JSF to avoid sugaring
    the property HTML identifiers for the controls.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的其余部分以 HTML Bootstrap 风格的表格显示可调试的输出。JSF `<h:form>` 元素上的 `prependId=false`
    通知 JSF 避免对控件属性 HTML 标识符进行糖化。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The JSF Form `prependId` specifies whether or not the `<h:form>` should prepend
    its ID to its descendant's ID during the `clientId` generation process. The flag
    becomes relevant when importing or inserting composite components that are forms
    in an outer form. This value defaults to true.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 表单 `prependId` 指定在 `clientId` 生成过程中 `<h:form>` 是否应该将其 ID 预先附加到其子代 ID 上。当在外部表单中导入或插入复合组件（这些组件是表单）时，该标志变得相关。此值默认为
    true。
- en: 'The following is a screenshot of the start page `sector-flow/sector-flow.xhtml`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个起始页面 `sector-flow/sector-flow.xhtml` 的截图：
- en: '![Page views](img/image00414.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![页面视图](img/image00414.jpeg)'
- en: In the source code, we dumped out a set of debuggable values using EL. The project
    is called `jsf-declarative-form` in the book's source code. You will find a cleaned-out
    professional version without debuggable output, which is called `jsf-declarative-form-pro`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，我们使用 EL 输出了一系列可调试的值。在本书的源代码中，项目被命名为 `jsf-declarative-form`。你将找到一个没有调试输出的专业版本，被称为
    `jsf-declarative-form-pro`。
- en: The following is a screenshot of the nested flow, `footprint-flow-1a.xhtml`.
    After navigating to the start page, we hit the **Next** button, entered some data
    into the form, and save it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个嵌套流程的截图，`footprint-flow-1a.xhtml`。在导航到起始页面后，我们点击了 **下一步** 按钮，在表单中输入了一些数据，并将其保存。
- en: '![Page views](img/image00415.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![页面视图](img/image00415.jpeg)'
- en: 'Going back to `SectorFlow`, when we invoke the `SaveBtn` command button, JSF
    invokes the `saveFootprintRecord()` method. The record is saved to the database
    and the view `sector-flow-1c.xthml` is displayed as seen in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `SectorFlow`，当我们调用 `SaveBtn` 命令按钮时，JSF 会调用 `saveFootprintRecord()` 方法。记录将被保存到数据库中，并且会显示视图
    `sector-flow-1c.xthml`，如下截图所示：
- en: '![Page views](img/image00416.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![页面视图](img/image00416.jpeg)'
- en: The only parts that remain are the source code for the injected POJO, `UtilityHelper`
    and the EJB, `CarbonFootprintService`. Unfortunately, we cannot show all the listings
    in this book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只有注入的POJO的源代码`UtilityHelper`和EJB`CarbonFootprintService`。不幸的是，我们无法在这个书中展示所有列表。
- en: A real-world example
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个现实世界的例子
- en: To wrap up Faces Flows, let's look at adding features to our application. We
    want our JSF application to have quality and finesse. In the book's source code,
    you will find these examples under the projects `jsf-product-flow` and `jsf-product-flow-s2`.
    The first project demonstrates the prototypical design of the concepts. The second
    project illustrates the improved and cleaned-up digital design with enough quality
    to present to a business stakeholder.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结Faces Flows，让我们看看如何向我们的应用程序添加功能。我们希望我们的JSF应用程序具有质量和优雅。在本书的源代码中，你可以在`jsf-product-flow`和`jsf-product-flow-s2`项目下找到这些示例。第一个项目演示了概念的原型设计。第二个项目展示了改进和清理后的数字设计，具有足够的质量向业务利益相关者展示。
- en: Ensure the application populates the database
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保应用程序填充数据库
- en: Often, we develop applications that operate against a UAT database for testing.
    We write code that populates the database with test information, which does not
    go into production. In a lot of cases, we want to bootstrap our application just
    to check that the correct schema has been introduced.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们开发的应用程序针对UAT数据库进行测试。我们编写代码将测试信息填充到数据库中，这些信息不会进入生产环境。在许多情况下，我们只想启动应用程序以检查是否已引入了正确的模式。
- en: Our first thought would be to create an `@ApplicationScoped` POJO with an annotation
    `@PostConstruct`, and this would solve our bootstrap issue. We can write a `DataPopulator`
    class with the sole purpose to create data inside a development application. Although
    we have a firm-wide application instance, we cannot ensure that our bean is invoked
    after the startup of the web application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一想法是创建一个带有`@PostConstruct`注解的`@ApplicationScoped` POJO，这将解决我们的启动问题。我们可以编写一个`DataPopulator`类，其唯一目的是在开发应用程序中创建数据。尽管我们有全公司的应用程序实例，但我们不能保证我们的bean在Web应用程序启动后被调用。
- en: With Java EE, we can use `@javax.ejb.Startup` and `@javax.ejb.Singleton` to
    start an EJB. The `@Startup` annotation ensures that the EJB container initializes
    the bean after the application is deployed. The `@Singleton` annotations denotes
    the session bean that guarantees that there is, at the most, one instance in the
    application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java EE，我们可以使用`@javax.ejb.Startup`和`@javax.ejb.Singleton`来启动EJB。`@Startup`注解确保在应用程序部署后，EJB容器初始化bean。`@Singleton`注解表示会话bean，它保证在应用程序中最多只有一个实例。
- en: 'The following is the code for the `DataPopulator` bean:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为`DataPopulator`对象编写的代码：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, in order to populate the application with data, we delegate another bean.
    The `ExtendedPersistenceLoaderBean` is a CDI bean with a new CDI 1.1 transactional
    scope. The code for this delegate is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了用数据填充应用程序，我们委托另一个bean。`ExtendedPersistenceLoaderBean`是一个具有新CDI 1.1事务范围的CDI
    bean。以下是这个委托的代码：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We annotate the `DataPopulator` bean with `@TransactionScoped`. Whenever we
    invoke a method on the `@TranscationScoped` bean, the method, the CDI container,
    will activate a transaction or have one created. A single transaction will be
    shared amongst many methods on the same bean or shared between other `@TranscactionScoped`
    beans that may be called. In other words, the transaction context is passed around
    participating components without requiring the developer to add explicit method
    arguments to pass around `javax.transaction.TransactionContext` instances.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@TransactionScoped`注解来标注`DataPopulator`对象。每当我们在`@TransactionScoped`对象上调用方法时，方法、CDI容器将激活一个事务或创建一个事务。单个事务将在同一对象上的多个方法之间共享，或者在不同可能被调用的`@TransactionScoped`对象之间共享。换句话说，事务上下文在参与组件之间传递，而不需要开发者添加显式的方法参数来传递`javax.transaction.TransactionContext`实例。
- en: Going back, we've added another special annotation to our `DataPopulator` bean.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们在`DataPopulator`对象上添加了另一个特殊注解。
- en: As soon as any method is invoked on this bean, the thread context becomes associated
    with a brand new transaction, because we annotated the class with `@TransactionAttribute`
    and pass in an attribute value `TranscationAttributeType.NEW`. This forces the
    container to create a new transaction, regardless of if there is one existing
    already. The lifecycle of the transaction scope is the duration of the call to
    the `loadData()`. The method simply creates a couple of `UserRole` entities in
    the database, and then it creates user accounts for the login with the `UserProfile`
    entities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在这个Bean上调用任何方法，线程上下文就会与一个新的事务关联，因为我们用`@TransactionAttribute`注解了这个类，并传递了一个属性值`TranscationAttributeType.NEW`。这强制容器创建一个新的事务，无论是否已经存在一个。事务作用域的生命周期是调用`loadData()`的持续时间。该方法只是在数据库中创建几个`UserRole`实体，然后为使用`UserProfile`实体进行登录创建用户账户。
- en: Finally, the `init()` and `destroy()` methods just print the debug information
    to the console, and the details are not shown in the extract.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`init()`和`destroy()`方法只是将调试信息打印到控制台，详细内容在摘录中未显示。
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even though CDI 1.1 defines a `@javax.inject.Singleton` annotation for CDI beans,
    this exact launch of a CDI bean is not defined in the specification, because this
    specification is missing in `@javax.inject.Startup`. Therefore, we must rely on
    the EJB singleton startup bean. We probably have to wait until CDI 2.0 and Java
    EE 8 to see this annotation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CDI 1.1为CDI Bean定义了`@javax.inject.Singleton`注解，但这个CDI Bean的确切启动在规范中并没有定义，因为`@javax.inject.Startup`中缺少这个规范。因此，我们必须依赖于EJB单例启动Bean。我们可能不得不等到CDI
    2.0和Java EE 8才能看到这个注解。
- en: Now that we have user profiles and roles, how do we secure a JSF application?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用户配置文件和角色，我们如何确保JSF应用程序的安全性？
- en: Securing page views and flows
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护页面视图和流程
- en: If you want to stay with the standard Java EE libraries, then the specification
    has the Container Managed Authentication feature. In order to take advantage of
    this feature, you extend the web deployment descriptor file, `web.xml`, and add
    a security constraint to your application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要继续使用标准的Java EE库，那么规范中就有容器管理认证功能。为了利用这个功能，你需要扩展web部署描述符文件`web.xml`，并为你的应用程序添加一个安全约束。
- en: 'The following is an example of security constraints inside a `web.xml` file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`web.xml`文件中安全约束的示例：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first security constraint restricts the products, carts, checkout, and promotion
    pages of this website to any user. Note the wildcard given as the role name. The
    second security constraint restricts the admin pages of this website only to users
    with an admin role.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个安全约束将这个网站的产品、购物车、结账和促销页面限制为任何用户。注意给出的通配符作为角色名称。第二个安全约束将这个网站的admin页面仅限制为具有管理员角色的用户。
- en: The `<user-data-constraint>` element declares whether the page view is accessible
    with HTTP or HTTPS. It specifies the level of security required. The acceptable
    values are `NONE`, `INTEGRAL`, and `CONFIDENTIAL`. Setting the transport guarantee
    to `CONFIDENTIAL` informs the application server that these pages and resources
    are only accessible over SSL. The value of `INTEGRAL` is important in communication
    when the data sent over the wire from the client or the server should not be changed
    in any way.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`<user-data-constraint>`元素声明页面视图是否可以通过HTTP或HTTPS访问。它指定了所需的安全级别。可接受的值是`NONE`、`INTEGRAL`和`CONFIDENTIAL`。将传输保证设置为`CONFIDENTIAL`通知应用程序服务器，这些页面和资源只能通过SSL访问。`INTEGRAL`值在客户端或服务器发送的数据不应以任何方式更改的通信中很重要。'
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Tip Java EE 8 Security—a word on the future TODO (note for me to check on updates
    and progress. See [https://javaee8.zeef.com/arjan.tijms](https://javaee8.zeef.com/arjan.tijms)).
    There are not too many alternatives to the standard Java EE security. The other
    choices are Apache Shiro ([http://shiro.apache.org/](http://shiro.apache.org/))
    or Spring Security (formerly Acegi). It is hoped that Java EE 8 will include a
    revamp concept and perhaps a separate specification.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Java EE 8 安全性——关于未来的 TODO（供我检查更新和进展的笔记。见[https://javaee8.zeef.com/arjan.tijms](https://javaee8.zeef.com/arjan.tijms)）。对于标准的Java
    EE安全性来说，替代方案并不多。其他选择有Apache Shiro ([http://shiro.apache.org/](http://shiro.apache.org/))
    或 Spring Security（以前称为Acegi）。希望Java EE 8将包括一个全新的概念，也许是一个单独的规范。
- en: Whilst the standard mechanism is fast and easy to add, it is application-server
    specific. The mechanism applies only to coarse grain resources, and there are
    no annotations that we can apply to CDI beans. Java EE security requires the configuration
    of Security Realms, which defines the roles of groups of users. In order to secure
    a website with fine- grain permission, we have to add multiple roles, which can
    lead to high complexity.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准机制快速且易于添加，但它特定于应用服务器。该机制仅适用于粗粒度资源，并且没有可以应用于CDI Bean的注解。Java EE安全需要配置安全领域，它定义了用户组的角色。为了使用细粒度权限来保护网站，我们必须添加多个角色，这可能导致高度复杂性。
- en: It is possible to define our own custom security for JSF and the web applications.
    The advantage of this approach is that we have fine-grained control and it works
    across the containers. On the other hand, if we ignore the Java EE security standard
    features, then any home-baked security implementation is unlikely to have been
    sufficiently proven secure in the wild. Such a component will fail basic penetration
    testing. At best, custom security works if the requirements are straightforward
    and there are few demands on complex permissions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为JSF和Web应用程序定义自己的自定义安全。这种方法的优点是我们有细粒度控制，并且它可以在容器之间工作。另一方面，如果我们忽略了Java EE安全标准特性，那么任何自制的安全实现可能都没有在野外得到充分的验证，以确保其安全性。这样的组件将无法通过基本的渗透测试。在最理想的情况下，如果要求简单且对复杂权限的要求不多，自定义安全才能正常工作。
- en: 'In order to create custom security, we shall define a unique `javax.servlet.ServletFilter`,
    which protects the access to certain areas of our website. The `LoginAuthenticationFilter`
    is defined as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建自定义安全，我们应定义一个独特的`javax.servlet.ServletFilter`，以保护我们网站某些区域的访问。`LoginAuthenticationFilter`定义如下：
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We annotate the class with `@WebFilter` with the URL resources that we want
    to protect. If a user attempts to access a page under the `/protected/*` and `/simple/*`
    folder, then the filter, `LoginAuthenticationFilter` is triggered. The servlet
    container invokes the `doFilter()` method and we check if an HTTP session attribute
    is defined or not. If the key `LoginController.LOGIN_KEY` does exist, the user
    is logged into the site, otherwise, the user is redirected to the login page view.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@WebFilter`注解来标记我们想要保护的URL资源。如果用户尝试访问`/protected/*`和`/simple/*`文件夹下的页面，那么`LoginAuthenticationFilter`过滤器将被触发。Servlet容器调用`doFilter()`方法，我们检查是否存在HTTP会话属性。如果存在键`LoginController.LOGIN_KEY`，则用户已登录到网站，否则，用户将被重定向到登录页面视图。
- en: 'Let''s move to the backing bean `LoginController`, which allows a user to log
    into the website:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到后台Bean `LoginController`，它允许用户登录到网站：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `LoginController` backing bean accepts two form-based parameters: the username
    and a password. It relies on the injected `UserProfileService` to find a `UserProfile`
    record by the username. Inside the `login()` method, a user is allowed to log
    in if the password parameter matches the entity record. The method adds the username
    to the HTTP session under the key, `LOGIN_KEY`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginController`后台Bean接受两个基于表单的参数：用户名和密码。它依赖于注入的`UserProfileService`通过用户名查找`UserProfile`记录。在`login()`方法内部，如果密码参数与实体记录匹配，则允许用户登录。该方法将用户名添加到HTTP会话中，键为`LOGIN_KEY`。'
- en: There are a couple of helpful methods. The `logout()` method removes the login
    key from the HTTP session key. The `isLoggedIn()` method checks if a user has
    logged in or not.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个有用的方法。`logout()`方法从HTTP会话中移除登录键。`isLoggedIn()`方法检查用户是否已登录。
- en: The servlet filter only handles the direct navigation resources, servlets, filters,
    and paths. We need another protector for the JSF views, because `LoginAuthenticationFilter`
    is not enough.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet过滤器仅处理直接导航资源、servlet、过滤器和路径。我们需要另一个保护器来保护JSF视图，因为`LoginAuthenticationFilter`不足以做到这一点。
- en: 'The following is the code for a backing bean controller called `LoginViewAuthenticator`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为`LoginViewAuthenticator`的后台Bean控制器的代码：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The class `LoginViewAuthenticator` has a `check()` method that performs a check.
    We retrieve the known key `LOGIN_KEY` from the HTTP session. Note that we can
    access parts of the Java Servlet API through a chained call to the `getExternalContext()`
    method on `FacesContext`. We retrieve the `HttpSession` instance or create one
    and then check for the associated value. If the user is not logged in, then we
    change the destination of the current `NavigationHandler`. The navigation handler
    in JSF is an implementation-defined type that carries the target outcome string
    during a Faces request-and-response interaction.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginViewAuthenticator` 类的 `check()` 方法执行检查。我们从 HTTP 会话中检索已知的密钥 `LOGIN_KEY`。请注意，我们可以通过在
    `FacesContext` 上调用 `getExternalContext()` 方法的链式调用，访问 Java Servlet API 的一部分。我们检索
    `HttpSession` 实例或创建一个，然后检查关联的值。如果用户未登录，则我们更改当前 `NavigationHandler` 的目标。JSF 中的导航处理程序是一个实现定义的类型，它在
    Faces 请求-响应交互期间携带目标结果字符串。'
- en: 'We use `LoginViewAuthenticator` in a page view to restrict access:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在页面视图中使用 `LoginViewAuthenticator` 来限制访问：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For the page `view /protected/index.html`, we insert a pre-render view event
    using the `<f:metadata>` section. The `<f:event>` element invokes the `check()`
    method of the `LoginViewAuthenticator` bean.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于页面 `view /protected/index.html`，我们在 `<f:metadata>` 部分插入了一个预渲染视图事件。`<f:event>`
    元素调用了 `LoginViewAuthenticator` 实例的 `check()` 方法。
- en: In the project, we also secured the Faces Flow by adding the same stanza to
    the page view `/simple.xhtml`. This view is the start page and, therefore, adding
    the pre-render view event here effectively restricts access to the flow. The `LoginViewAuthenticator`
    bean ensures that unknown website users are redirected to the `/login.xhtml` view.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，我们还通过向页面视图 `/simple.xhtml` 添加相同的 stanza 来保护 Faces 流。这个视图是起始页面，因此在这里添加预渲染视图事件实际上限制了访问流。`LoginViewAuthenticator`
    实例确保未知网站用户被重定向到 `/login.xhtml` 视图。
- en: Resource Library Contracts
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源库合约
- en: JSF 2.2, as a part of Java EE 7, introduced the ability to theme and style websites
    under a facility known as the Resource Library Contracts. The idea of contracts
    is about reusing Facelets dynamically at runtime. It is possible now with contracts
    to switch between resources without having to redeploy an application. Contracts
    can also be declared statically for pages that match a URL pattern.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 作为 Java EE 7 的一部分，引入了在称为资源库合约的设施下主题化和样式化网站的能力。合约的想法是关于在运行时动态重用 Facelets。现在，通过合约可以在不重新部署应用程序的情况下在资源之间切换。合约也可以为匹配
    URL 模式的页面静态声明。
- en: The specification reserves a specially named folder called `/contracts` as the
    parent folder for the Resource Library Contracts. This folder is the default one.
    If you already have a folder named as this view, then you will have to refactor
    by name, unfortunately.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 规范保留了一个名为 `/contracts` 的特殊命名文件夹作为资源库合约的父文件夹。这个文件夹是默认的。如果你已经有一个名为此视图的文件夹，那么你将不得不按名称重构，遗憾的是。
- en: There is another default location, `META-INF/contracts`, on the classpath for
    JARs. This location allows the resource library contracts to be packaged as JAR
    for distribution to the third-party customers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在类路径上还有一个默认位置，`META-INF/contracts`，用于 JAR 文件。这个位置允许资源库合约被打包成 JAR 文件，以便分发给第三方客户。
- en: Inside the `/contracts` folder, a developer can define named contracts (or themes).
    You can only create folders inside the location folder `/contract` or (`/META-INF/contracts`),
    and each folder represents a named contract. In the specification, a contract
    has a declared template. Each contract may define resources such as images, CSS,
    JavaScript files, and other content files.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/contracts` 文件夹内，开发者可以定义命名的合约（或主题）。你只能在位置文件夹 `/contract` 或 (`/META-INF/contracts`)
    内创建文件夹，并且每个文件夹代表一个命名的合约。在规范中，合约有一个声明的模板。每个合约都可以定义资源，如图像、CSS、JavaScript 文件和其他内容文件。
- en: 'There is a project called `jsf-resource-library-contracts` in the book''s source
    distribution, and in there you will see the following files laid out:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍的源分发中有一个名为 `jsf-resource-library-contracts` 的项目，在那里你可以看到以下文件布局：
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two Resource Library Contracts: `default` and `victoria`. These folders
    share the same resources although they do not have to. The two `template.xhtml`
    files are UI composition files that lay out the page view. The two `app.css` files
    are CSS.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个资源库合约：`default` 和 `victoria`。这两个文件夹共享相同的资源，尽管它们不必这样做。两个 `template.xhtml`
    文件是 UI 组成文件，用于布局页面视图。两个 `app.css` 文件是 CSS。
- en: A resource contract must have at least one UI composition template, which is
    called a declared template in the specification. In each contract folder, the
    file `template.xhtml` is a declared template. Inside each template file that the
    specification mentions, any `<ui:insert>` tags are known as declared insertion
    points. The term declared resources means the collection of images, CSS and JavaScript,
    and other resources.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 资源合同必须至少有一个 UI 组合模板，在规范中称为声明模板。在每个合同文件夹中，文件 `template.xhtml` 是一个声明模板。在规范提到的每个模板文件中，任何
    `<ui:insert>` 标签都称为声明插入点。声明资源是指图像、CSS、JavaScript 以及其他资源的集合。
- en: 'Inside the `default/template.xhtml` file, we have an important link to the
    reference styles sheet:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `default/template.xhtml` 文件内部，我们有一个重要的链接到参考样式表：
- en: '[PRE25]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Likewise, in the `victoria/template.xhtml`, we have a link to the alternative
    style sheet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，在 `victoria/template.xhtml` 中，我们有一个链接到备选样式表：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In each resource contract, we can vary the properties of shared CSS selectors
    in the CSS files in order to produce alternate themes. The following is an extract
    of `default/styles/app.css`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个资源合同中，我们可以通过 CSS 文件中的共享 CSS 选择器的属性来变化，以产生不同的主题。以下是一个 `default/styles/app.css`
    的摘录：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And this is similar to `victoria/styles/app.css`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `victoria/styles/app.css` 类似：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is a difference of color, font family, size, and style.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着颜色、字体家族、大小和样式的差异。
- en: In order to configure the resource contracts in static usage from the matching
    URL pattern, we declare the titles in the Faces configuration file, `faces-config.xml`.
    JSF 2.2 introduces a new `<resource-library-contracts>` element. Each contract
    is associated with a name and one or more URL patterns.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从匹配的 URL 模式配置静态使用的资源合同，我们在 Faces 配置文件 `faces-config.xml` 中声明标题。JSF 2.2 引入了一个新的
    `<resource-library-contracts>` 元素。每个合同都与一个名称和一个或多个 URL 模式相关联。
- en: Static Resource Library Contract references
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态资源库合同引用
- en: 'In our example project, we should have a Faces configuration file that has
    the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们应该有一个包含以下代码的 Faces 配置文件：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `<contract-mapping>` element defines two contracts: `default` and `victoria`.
    The order of the contracts is important for processing. For the entire website,
    the `default` contract is active whereas the `victoria` contract is active only
    for the page view underneath the `/corporate/ URL`. A contract mapping may have
    more than one URL pattern.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`<contract-mapping>` 元素定义了两个合同：`default` 和 `victoria`。合同的顺序对于处理很重要。对于整个网站，`default`
    合同是激活的，而 `victoria` 合同仅在 `/corporate/` URL 下的页面视图中激活。合同映射可以包含多个 URL 模式。'
- en: 'We can write a page view to trigger this contract statically. The following
    is an extract of the page view, `/corporate/index.xhtml`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个页面视图来触发这个静态合同。以下是一个页面视图的摘录，`/corporate/index.xhtml`：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Based on the previous resource library contract definitions in `faces-config.xml`,
    the paragraph with the CSS class, fashion-headline should be green in color. Notice
    how JSF searches for and finds the `/template.xhtml` references, which lie in
    the corporate folder. So defining Resources Library Contracts that can be switched
    statically is a good feature to have, but what if we wanted to change the contract
    on the fly? We can achieve this goal and we'll learn how in the next section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `faces-config.xml` 中的先前资源库合同定义，具有 CSS 类 fashion-headline 的段落应该是绿色的。注意 JSF
    如何搜索并找到位于企业文件夹中的 `/template.xhtml` 引用。因此，定义可以静态切换的资源库合同是一个很好的特性，但如果我们想动态更改合同呢？我们可以实现这个目标，我们将在下一节中学习如何做到这一点。
- en: Dynamic Resource Library Contract references
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态资源库合同引用
- en: If you surround the UI composition with static reference with an `f:view` element,
    as we did in the page view, then we can add another new attribute called contracts.
    This attribute accepts a String expression that references a resource contract
    by name.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用 `f:view` 元素将 UI 组合静态引用包围起来，就像我们在页面视图中做的那样，那么我们可以添加另一个新属性，称为 contracts。该属性接受一个字符串表达式，通过名称引用资源合同。
- en: 'The following is an extract of this home page view `/index.xhtml`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个主页视图 `/index.xhtml` 的摘录：
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `#{fashionSelector.theme}` controller references a getter for a backing
    bean, which we will see in a moment. The value of the expression sets the chosen
    resource library contract. We make use of the CSS paragraph in order to visually
    see the contract template in action. In order to change the contract, we employ
    a form with the radio selection element. The `<f:selectItem>` tag defines the
    contract name.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`#{fashionSelector.theme}` 控制器引用了一个支撑 Bean 的 getter，我们将在稍后看到。表达式的值设置了所选的资源库合同。我们利用
    CSS 段落来直观地看到合同模板的效果。为了更改合同，我们使用了一个带有单选选择元素的表单。`<f:selectItem>` 标签定义了合同名称。'
- en: 'Our backing bean `FashionSelector` is a controller with one action method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的支撑 Bean `FashionSelector` 是一个只有一个操作方法的控制器：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We annotate the controller as a `@SessionScoped` bean in order to preserve the
    contract change across the many request-response cycles.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将控制器注释为 `@SessionScoped` Bean，以便在许多请求-响应周期中保持合同更改。
- en: 'The resource library contracts also happily function with Faces Flows. The
    technique of using either static URL patterns or the dynamic selector of the template
    equals the flows. In the book''s source, you will find more demonstrations and
    source code. In fact, the page view `/digitalFlow/digitalFlow.xhtml` looks exactly
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 资源库合同也愉快地与 Faces Flows 一起工作。使用静态 URL 模式或模板的动态选择器来等于流程的技术。在本书的源代码中，你会找到更多的演示和源代码。实际上，页面视图
    `/digitalFlow/digitalFlow.xhtml` 看起来如下所示：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, in principle, there is no difference at all.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，原则上没有任何区别。
- en: Advice for flows
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程建议
- en: 'Faces Flows are a very useful feature in JSF 2.2, because they allow developers
    and designers to put together components that achieve customer (or user centric)
    goals. They also allow an architect to define groups of page views and controllers
    into specific business defined components. If the designer is careful, they can
    be linked together efficiently and decoupled from dependencies in meaningful strategies.
    The following points should be kept in mind while using Faces Flows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Faces Flows 是 JSF 2.2 中一个非常实用的功能，因为它们允许开发者和设计师组合成实现客户（或以用户为中心）目标的组件。它们还允许架构师将一组页面视图和控制者定义成特定的业务定义组件。如果设计师小心操作，它们可以有效地链接在一起，并从有意义的策略中解耦。在使用
    Faces Flows 时，应牢记以下要点：
- en: '**Start small**: Design a Faces Flow that achieves one responsibility and one
    goal. Don''t try to build the entire process in a single flow.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从小处着手**：设计一个实现单一责任和单一目标的 Faces Flow。不要试图在一个流程中构建整个流程。'
- en: '**Pass entities and meaning types**: Implement Faces Flows that accept data
    entities and transfer objects.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递实体和意义类型**：实现接受数据实体和传输对象的 Faces Flows。'
- en: '**Compose flows together**: Group together common flows that achieve a similar
    goal. In a checkout process, you may have a flow dedicated to the shipping address
    and a flow responsible for payments. These two flows can be invoked by a master
    flow that handles the entire process.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合流程**：将实现类似目标的常见流程组合在一起。在结账过程中，你可能有一个专门处理送货地址的流程和一个负责支付的流程。这两个流程可以通过处理整个流程的主流程来调用。'
- en: '**Encapsulate flows**: Encapsulate your flow as much as possible, so that it
    is self-sufficient.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装流程**：尽可能封装你的流程，使其自给自足。'
- en: '**Persist your user''s data**: when a customer completes a task, ensure that
    user data is saved at the determined exit points.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化用户数据**：当客户完成一项任务时，确保在确定的退出点保存用户数据。'
- en: Resist the temptation of building the perfect workflow. Instead, I recommend
    that you design Faces Flow with change at the back of your mind.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 抵制构建完美工作流的诱惑。相反，我建议你在设计 Faces Flow 时，将变化放在心中。
- en: In modern digital teams building websites and applications, the most important
    person is the UX designer. Often, after several rounds of user-centric testing,
    you might find the page design and information architecture of the site changing
    and going back and forth over weeks or even months. By building small, goal-oriented
    Faces Flow components, you will protect the developer team from the constant changes
    driven by the UX design team. Design your flows not for reuse, but for replacement.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代数字团队中，构建网站和应用程序时，最重要的人是用户体验设计师。通常，经过几轮以用户为中心的测试后，你可能会发现网站的页面设计和信息架构在几周甚至几个月内不断变化和反复调整。通过构建小型、目标导向的
    Faces Flow 组件，你将保护开发团队免受用户体验设计团队驱动的持续变化的困扰。设计你的流程时，不要为了重用，而是为了替换。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we examined the poster child of the JSF 2.2 release: Faces
    Flows. We learned about flow definitions and lifecycles. We covered ground with
    implicit navigation and created POJO using the `@FlowScoped` scope. We drilled
    down into the terminology of flow processes and we studied declarative and nested
    flows. We saw how we can pass parameters from one flow to another through invocation.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了 JSF 2.2 版本的宠儿：Faces 流程。我们了解了流程定义和生命周期。我们介绍了隐式导航，并使用 `@FlowScoped`
    范围创建了 POJO。我们深入研究了流程过程的术语，并研究了声明性和嵌套流程。我们看到了如何通过调用从一个流程传递参数到另一个流程。
- en: We also learned how to add finesse to our digital application by handling expired
    views. Then we added security around page views and Resource Library Contracts
    to our new abilities. We understood how contracts allow the developer to add themes
    and styles to our JSF application. Another thing that we learned is that the Resource
    Library Contracts may be driven by static declaration or controlled by backing
    beans.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何通过处理过期视图来为我们的数字应用增添优雅。然后我们在页面视图和资源库合同中添加了安全性，并扩展了我们的新能力。我们理解了合同如何允许开发者向我们的
    JSF 应用程序添加主题和样式。我们还学到的是，资源库合同可能由静态声明驱动或由后端豆控制。
- en: In the next chapter, we will step away from JSF and delve into JavaScript programming
    and library framework.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从 JSF 脱身，深入探讨 JavaScript 编程和库框架。
- en: Exercises
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Verify that flow-scoped beans are unique with multiple web browsers and tab
    frames. Modify the `debugClassName()` method in the first flow class, `DigitalFlow`
    to report the value of `java.lang.System.identityHashCode()` as well as the class
    name. What is the result?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证在多个网络浏览器和标签帧中，流程范围内的豆是唯一的。修改第一个流程类 `DigitalFlow` 中的 `debugClassName()` 方法，报告
    `java.lang.System.identityHashCode()` 的值以及类名。结果是什么？
- en: Everyone practically knows how to make a simple breakfast of scrambled eggs;
    write down the steps for doing so. What processes do you need? What inputs do
    you need? We know the results of the tasks; are there other outputs?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个人实际上都知道如何制作简单的煎蛋早餐；写下制作步骤。你需要哪些流程？你需要哪些输入？我们知道任务的结果；还有其他输出吗？
- en: 'Develop a simple Faces Flow application that takes contact details from a user.
    Think of the number of properties that you will need. Do you need all of them?
    (Hint: Name, address, e-mail, and telephone number will do for now.)'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个简单的 Faces 流程应用，从用户那里获取联系详情。想想你需要多少个属性。你需要所有这些吗？（提示：姓名、地址、电子邮件和电话号码目前就足够了。）
- en: Take the contact details Faces Flow application from the previous question and
    now persist that entity record data to a database.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个问题中的联系详情 Faces 流程应用中获取联系详情，并将其实体记录数据持久化到数据库中。
- en: 'Now split the contact detail single flow application into separate flows. Set
    up the address part as a nested flow. (Hint: You can pass the entity record from
    one flow to another.)'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将联系详情单流程应用拆分为单独的流程。将地址部分设置为嵌套流程。（提示：您可以将实体记录从一个流程传递到另一个流程。）
- en: 'In the contact details application, how can we allow the customer to retrieve
    entities? Develop the Faces application so that he or she can save the data temporarily.
    (Hint: maybe the customer requires a temporary application ID, so add one to the
    contact details entity.)'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在联系详情应用中，我们如何允许客户检索实体？开发 Faces 应用程序，以便他或她可以暂时保存数据。（提示：也许客户需要一个临时应用程序 ID，所以将其添加到联系详情实体中。）
- en: 'At this point, we will take the contact application and copy it to a new project.
    We will rebrand the project as `welcome-new-bank-customer`. In the retail banking
    industry, this business process is called `on-boarding`. You will need one or
    two nested flows. One flow accepts the person''s work status: their salary, their
    job title, and, obviously, an occupation. If you feel confident, perhaps you can
    add a work address as another flow, and if you feel even stronger, add the national
    insurance number and tax records. With a more complicated project, consider, what
    would happen if it were possible to re-order the flows? How well is your design
    encapsulated? Can the developers easily rearrange the flows to fit the UX challenges?'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们将联系应用复制到一个新项目中。我们将重新命名项目为 `welcome-new-bank-customer`。在零售银行业务中，这个业务流程被称为
    `on-boarding`。你需要一个或两个嵌套流程。一个流程接受个人的工作状态：他们的薪水、他们的职位，以及显然的，职业。如果你很有信心，也许你可以添加一个工作地址作为另一个流程，如果你感觉更强，可以添加国家保险号码和税务记录。对于更复杂的项目，考虑如果可以重新排序流程会发生什么？你的设计封装得有多好？开发者能否轻松地重新排列流程以适应
    UX 挑战？
- en: Given the contact details/banking onboarding application up to now, you should
    have many database records of contacts. Write another Faces Flow in the same web
    application that allows a trusted member of staff, a case worker, to amend and
    delete customer records. In a real business, such an employee sits behind the
    system and approves each onboarding application request one by one. You will need
    to write the HTTP login form for security and protect the non-public page views.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据到目前为止的联系方式/银行开户申请，你应该拥有许多联系人的数据库记录。在同一个网络应用程序中编写另一个 Faces Flow，允许信任的员工，如案件工作者，修改和删除客户记录。在真实业务中，这样的员工坐在系统后面，逐个批准每个开户申请请求。你需要编写用于安全的
    HTTP 登录表单，并保护非公开页面视图。
