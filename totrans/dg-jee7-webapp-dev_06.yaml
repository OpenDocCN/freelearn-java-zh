- en: Chapter 6. JSF Flows and Finesse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"I''ve had a chance to fly a lot of different airplanes, but it was
    nothing like the shuttle ride."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Commander Chris Hadfield* |'
  prefs: []
  type: TYPE_TB
- en: This chapter is about Faces Flow, a new feature in JSF 2.2\. The idea of flows
    stems from the concepts of workflows and business process management. A workflow
    is often an orchestrated and a repeatable sequence of business activities performed
    in order to do a unit of achievable work efficiently. The unit of work can involve
    transformation of state, processing of data, and/or provision of a service or
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The checkout process in many web e-commerce applications is a good example of
    a workflow as it appears to the user. When you buy a product from Amazon, the
    site takes you to a separate area of the website for entering details. Behind
    the scenes, Amazon will gracefully move you from the micro service, which is responsible
    for handling products in the electronic and photography section, to the micro
    service that is the first step in the checkout workflow. You log in to your account
    or create a new one, and then you decide on the shipping address. Next, you pay
    with your credit or debit card, and Amazon will challenge you with an invoice
    address. Finally, you can choose how you want your products to be delivered. You
    can choose to group items together and also select express or regular delivery.
    Amazon is a complicated workflow to replicate; however, JSF allows the digital
    developer to build up from the fundamental simple flows.
  prefs: []
  type: TYPE_NORMAL
- en: Workflows also appear in rich user client applications for people who use desktop
    computers, especially in the government and financial services industry. You may
    have witnessed workflow-like applications that are case working systems, trading
    systems, and warehouse systems. The idea is essentially the same, which is to
    guide the employee through separate steps in a business process from start to
    finish.
  prefs: []
  type: TYPE_NORMAL
- en: In JSF 2.2, Faces Flow provides the basic programming API to create a behavior
    and user experience that resembles the workflow in general applications. Open
    source frameworks such as Apache MyFaces CODI (Orchestration module), Spring Web
    Flow, and the proprietary Oracle **Application Development Framework** (**ADF**)
    inspired the design of Faces Flow.
  prefs: []
  type: TYPE_NORMAL
- en: What is Faces Flow?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Faces Flow is the encapsulation of backing beans having a special scope with
    the related pages into a module. A Faces Flow is a module with a single, well-defined
    entry point and one or more exit points. The application developer determines
    how a Faces Flow is comprised and how it would function. In other words, Faces
    Flow is a low-level API, whereas other frameworks, with BPM in particular, feature
    higher-level configurations and macro-level processes.
  prefs: []
  type: TYPE_NORMAL
- en: A JSF Faces Flow is modular in execution; a flow can invoke another flow in
    a nested fashion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faces Flow can pass parameters to another nested flow and the nested flow can
    also return data through a special map property called the Flow Scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application developers can package a flow with the corresponding pages into
    a module, which may be distributed to a third-party developer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a brand new scope called `FlowScoped`, which denotes whether a POJO
    is a flow-scoped bean. The annotation for this is `@javax.faces.flow.FlowScoped`.
    A flow-scoped bean is compatible with CDI; so you can use the familiar Java EE
    annotations and order inject references to other beans and EJB elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can write action-controller methods and handle the logic inside the flow-scoped
    beans as you would with `@RequestScoped`, `@ConversationScoped`, `@SessionScoped`,
    and `@ApplicationScoped` beans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow definitions and lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Faces Flows use the `@FlowScoped` beans where the user can enter a single page,
    which is known as the start page. After entering the flow, the user can navigate
    the pages, which are associated with the flow. The user can exit the flow at predefined
    points. A flow can invoke a nested flow.
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle of the `@FlowScoped` beans is greater than the `@ViewScoped` beans,
    but shorter than that of `@SessionScoped`. Therefore, we can compare flow scoped
    beans to their conversational brethren. A `@ConversationalScoped` bean maintains
    a state for all the views and web page tabs in a browser. Like their conversation
    mates, the `@FlowScoped` beans survive multiple requests; in fact, they are even
    better, because they have different instances for multiple windows in a session.
    The flow-scoped bean is not shared between browser tabs.
  prefs: []
  type: TYPE_NORMAL
- en: As the user enters and leaves the flows in the application, Faces Flows has
    a dedicated CDI scope, which the JSF framework implementation uses to activate
    and passivate the data of the bean.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the user leaves a flow, that instance is susceptible to garbage collection
    by the JVM. Therefore, in comparison to `@SessionScoped` and `@ConversationalScoped`
    beans, flows tend to have lower memory demands.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates the scope of a Faces Flow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow definitions and lifecycle](img/image00407.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Simple Implicit Faces Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is relatively straightforward to create an Implicit Faces Flow with just
    a folder name, an empty XML configuration, and some Facelet pages. A `flow` is
    a folder name in your web application, preferably at the root directory. We start
    with the basic flow in the directory of the same name called `digitalFlow`. Your
    flow must match the name of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to define an implicit flow, we create an empty XML file with the common
    basename and a suffix: `digitalFlow/digitalFlow-flow.xhtml`.'
  prefs: []
  type: TYPE_NORMAL
- en: We now create a start page in the folder with the common basename. This file
    is a Facelet view page called `digitalFlow/digitalFlow.xhtml`.
  prefs: []
  type: TYPE_NORMAL
- en: We can create other pages in the flow inside the folder, and they can have any
    name we like. We might have `digitalFlow/digitalFlow1.xhtml`, `digitalFlow/checkout.xhtml`,
    or `digitalFlow/song.xhtml`. Only the defined flow `digitalFlow` can ever access
    these pages. If an outside call does attempt to access any of these pages, the
    JSF implementation will report an error.
  prefs: []
  type: TYPE_NORMAL
- en: In order to exit the implicit flow, we must provide a special page, `/digitalFlow-return.xhtml`,
    in the root folder of the web application, which means that the file is located
    outside of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s put this knowledge to good use with our first Faces Flow navigation
    example. In the source code, the project is called `jsf-implicit-simple-flow`.
    It is helpful to examine the file layout for this project, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/java`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/WEB-INF/classes/META-INF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/index.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/assets/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/basic-layout.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/view-expired.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/digitalFlow/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/digitalFlow/digitalFlow.xml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/digitalFlow/digitalFlow.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/digitalFlow/digitalFlow-p2.xthml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/digitalFlow/digitalFlow-p2.xthml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/digitalFlow/digitalFlow-p4.xthml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/digitalFlow-return.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: As you study the preceding layout, you notice that the project has a standard
    home page called `index.xhtml`, as we would expect. It has a `digitalFlow` folder,
    which is the special area of the website dedicated for this Faces Flow. Inside
    this directory, there are a bunch of Facelet files and a configuration. The start
    page is called `digitalFlow.xhtml`, and there is an empty XML file reserved for
    a flow definition, `digitalFlow.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: By now you are already aware of the purpose of the assets and resources folders,
    but the we will come back to the `view-expired.xhtml` file shortly. How do we
    ensure that our folder structure is treated as a Faces Flow?
  prefs: []
  type: TYPE_NORMAL
- en: A Flow scoped bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the annotation `@javax.faces.flow.FlowScoped`, we define a POJO as a flow
    scoped bean. The following is the code for our first Faces Flow, which is a backing
    bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The simple controller class, `DigitalFlow`, has action methods such as `gotoPage1()`
    and `gotoPage2()` to move the user to the appropriate page in the flow. The method
    `gotoEndFlow()` navigates to the return Facelet view that JSF detects in order
    to exit the flow.
  prefs: []
  type: TYPE_NORMAL
- en: The annotation of `@FlowScoped` requires a single String value parameter, which
    in this case matches the name of the folder `digitalFlow`. We shall now move to
    the views.
  prefs: []
  type: TYPE_NORMAL
- en: Facelet views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use flow-scoped beans in the Facelet views just as we use any other CDI
    scoped bean. The following is an extract of the home page, `index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding view, the `<h:commandButton>` defines an action with the name
    of the flow, `digitalFlow`. Invoking this action causes JSF to enter the Faces
    Flow, which matches the corresponding annotated name of the backing bean.
  prefs: []
  type: TYPE_NORMAL
- en: JSF recognizes that a flow has implicit navigation, because the XML Flow Definition
    file `digitalFlow.xml` is empty. This file must exist; otherwise, the implementation
    reports an error. You do not need the start or end tags inside the file either.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user invokes the button, JSF instantiates a flow scoped bean before
    it is forwarded to the start page. The following is an extract from the start
    page of the flow `digitalFlow.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The view demonstrates the invocation of the flow scoped bean with the familiar
    Expression Language as well as direct page-to-page navigation. To allow the user
    to move to the second page in the flow, we have two command buttons. The command
    button with the attribute action and value `digitalFlow-2` is page navigation
    direct without validation of any form input whatsoever. The command button with
    the attribute action and the expression language value, `#{digitalFlow.gotoPage2()}`
    is an invocation to the flow scoped bean's method, which means that the entire
    JSF lifecycle is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer Faces Lifecycle"),
    *JavaServer Faces Lifecycle*, if you have forgotten the different phases in the
    lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: In this view, we also generate the output, `#{digitalFlow.debugClassName()}`,
    in order to illustrate that we can invoke arbitrary methods in a flow-scoped bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me also draw your attention to the expression language that establishes
    if a view is a part of the flow or not through the following practical content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is functionally equivalent to the following Java statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The other pages, `digitalFlow-p2.xhtml` and `digitalFlow-p3.xhtml`, are very
    similar, because they just add the command buttons to navigate back to the previous
    views. You can see the full code as part of the book's source distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In digital work, we often provide well-known identifiers (IDs) to certain HTML
    elements, especially form controls. This helps when we are writing testing scripts
    for web automation testing, especially with the Selenium Web Driver framework
    ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall jump to the final view, `digitalFlow-p4.xhtml` and just extract the
    form element for study:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the preceding content illustrates how to navigate directly and
    through the `DigitalFlow` backing bean. In order to exit the flow in an implicit
    navigation, the user must trigger an event that takes the JSF framework to the
    `/digitalFlow-return.xhtml` view, which causes the flow to finish. Directly navigating
    to the return mode avoids validation, and any data inside the form input elements
    is lost. If we want to validate the form input elements as a form request, we
    must invoke a method in the action controller, the backing bean.
  prefs: []
  type: TYPE_NORMAL
- en: And that is implicit navigation in JSF Faces Flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'It really is that easy, so let''s see some screenshots of this simple flow
    starting with the home page `/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facelet views](img/image00408.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The start page `digital-flow.xhtml` for `DigitalFlow` appears like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facelet views](img/image00409.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After exiting the flow, the user sees the view `/digitalFlow-return.xhtml`.
    The following is a screenshot of this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facelet views](img/image00410.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we attempt to access a Facelet view directly through a known URI `/digitalFlow/digitalFlow.xhtml`
    before entering the flow, the view would be like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facelet views](img/image00411.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With GlassFish 4.1, we receive an HTTP Response Code of 500, which is an internal
    server error. Moreover, the CDI container raises an exception that there is no
    active flow scope.
  prefs: []
  type: TYPE_NORMAL
- en: Handling view expired
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I promised you that we would add some finesse to our digital application. If
    you've worked with JSF for a while, you probably have your fair share of stack
    traces with `javax.faces.application.ViewExpiredException` as the root cause.
    This is one of the most notorious exceptions. You could increase the HTTP Session
    lifetime in order to compensate for an out-of-date request, but how long is break
    away from the computer for an average person? Meanwhile, the objects would persist
    in the memory. There is a better way and that is by using the Web XML deployment
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the applications `web.xml` file, we need to trigger a redirection to
    a more pleasant error page. The following is an extract of the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<error-page>` element specifies an association between an exception type
    and a page view. Whenever JSF encounters the exception type `ViewExpiredException`,
    it will progress the response action to the page view `/view-expired.xhtml`. The
    circumstance of this behavior is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling view expired](img/image00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I am sure you'll agree that our public customer will enjoy this improved and
    dedicated page view rather than being puzzled with a stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flow scoped beans depend on CDI and, therefore, they require a Java EE 7 environment
    which dictates a CDI 1.1 container such as JBoss Weld. You must also use `@Named`
    and not the older style `@ManagedBean` annotation. If you don't use WildFly 8
    or GlassFish 4, then before you dive into the code, please check your container's
    implementation support for the latest JSF and CDI specifications.
  prefs: []
  type: TYPE_NORMAL
- en: A comparison with conversational scoped beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you recall, while using `@ConversationScoped` beans, we had to explicitly
    demarcate the state of the conversation. We injected the `Conversation` instance
    and from there, at specific points in the digital customer journey, called the
    `begin()` and `end()` methods. With `@FlowScoped` CDI beans, the scope is automatically
    started and finished at defined points.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the lifecycle of flow scoped beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the CDI container manages the flow scoped beans, they can participate
    normally in the contextual lifecycle. We can annotate a method with `@PostConstruct`
    in order to initialize the bean, acquire a database resource, or compute cacheable
    data. Likewise, when the flow goes out of scope, we can annotate a method with
    `@PreDestroy`.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative and nested flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, we have seen the implicit flow in action. Implicit flow is very straightforward
    for the simplest flow, which performs like a basic web wizard where the user is
    able to navigate linearly, going forward and backward. It can also use random
    access to navigate to pages.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to take Faces Flow further, then we must delve into the XML flow
    definition, but first let us define some terms.
  prefs: []
  type: TYPE_NORMAL
- en: The flow node terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fundamental technology being inspired by workflow and BPM, the Faces Flow
    specification declares different types of nodes which are given in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Node Type Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **View** | Represents any type of application JSF view |'
  prefs: []
  type: TYPE_TB
- en: '| **Method Call** | Represents a method invocation in the flow graph through
    **Expression Language** (**EL**) |'
  prefs: []
  type: TYPE_TB
- en: '| **Flow Call** | Represents an invocation of another flow with outbound (call)
    and (return) inbound parameters |'
  prefs: []
  type: TYPE_TB
- en: '| **Flow Return** | Represents a return to the calling flow |'
  prefs: []
  type: TYPE_TB
- en: '| **Switch** | Represents navigation selection through logic determined by
    EL |'
  prefs: []
  type: TYPE_TB
- en: The following is an illustration of two flows that represent a shopping cart
    business process. The outside flow invokes the nested flow, which handles the
    delivery method.
  prefs: []
  type: TYPE_NORMAL
- en: '![The flow node terminology](img/image00413.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An XML flow definition description file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that `<<Flowname>>` is a folder name in the web application, the flow
    description filename matches the pattern, `<<Flowname>>/<<Flowname>>.xml`. The
    content of this descriptor file declares to JSF certain characteristics of the
    flow. It may define an alternative start page, define a set of return outcomes,
    and map certain outcomes to specific pages. The descriptor can also define the
    conditional Boolean logic that maps the outcomes to particular pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an XML flow definition file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The root element must be a `<faces-config>` tag with the appropriate XML namespaces.
    You might be surprised by this choice of root element. This is because a flow
    definition can be defined globally, across the application, by setting the flow
    definition in the `/WEB-INF/faces-config.xml` file. However, this practice is
    an advanced use case and not recommended for modular development.
  prefs: []
  type: TYPE_NORMAL
- en: A flow definition tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<flow-definition>` element establishes the Faces Flow with the defined
    flow ID. The value of the identifier must match the value for the `@FlowScoped`
    bean. This element contains a collection of tags to establish the start page,
    views, flow returns, or the conditional switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: A mandatory flow return tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Faces Flow must have at least one return outcome. The `<flow-return>` element
    establishes a flow return node with an ID. It must contain a `<flow-outcome>`
    element whose body content specifies the Facelet view.
  prefs: []
  type: TYPE_NORMAL
- en: A view page tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A flow may optionally define a set of View Nodes (pages) that are useful for
    direct navigation from one view to another, within the scope. The element `<view>`
    tag establishes a view description language node through the element `<vdl-document>`.
    A view requires an identifier. The body content of this tag simply references
    a Facelet view. Therefore, the view ID does not necessarily have be the same name
    as the Facelet view.
  prefs: []
  type: TYPE_NORMAL
- en: An optional start page tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The developer can override the name of the default start page and provide an
    alternative view. The body content of the element `<start-node>` specifies the
    view ID and, therefore, references an appropriate flow, a View Node.
  prefs: []
  type: TYPE_NORMAL
- en: Switch, conditional, and case tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow definition offers the developer the capability to define conditional
    logic through an element tag called `<switch>`. This is the highest of the low-level
    features in the XML. The `<switch>` tag specifies a Switch Node, which is very
    similar to the use of the `<if>` tags within a `<navigation-case>` in the `/WEB-INF/faces-config.xml`
    file, obviously for non-flow navigation. The switch allows a single outcome in
    the flow to map more than one Facelet view by evaluating an EL expression with
    conditional logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extended version of the XML flow definition example file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `<switch>` tag contains a number of `<case>` elements and a single `<default-outcome>`
    element. Each `<case>` element contains a single `<if>` and `<from-outcome>` elements.
    The body content of the `<if>` defines a conditional logic EL. The `<from-outcome>`
    maps to the final Facelet view or it references the identifier of a View Node.
    It is a very good idea to a have a default outcome for a Switch Node. The body
    content of a `<default-outcome>` establishes this outcome when none of the case
    conditions happen to evaluate to true.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we have an imaginary payment controller used in a checkout process
    on an e-commerce website. When the flow encounters an outcome `customerPaymentTab`,
    which is the identifier for the Switch Node, JSF processes each of the case conditional
    logics in order. If one of those condition tests evaluates to true, then JSF chooses
    that outcome as the result of the switch. Let's say the `#{controller.paymentType
    == 'DebitCard' }` is true, then debit card is the chosen view. If none of the
    tests evaluates to true, then the resulting view is `bacs-direct`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But shouldn't all logic be defined in a controller instead of a Switch Node?
    The answer is controversial either way, and it depends. If you are building an
    application with a complex graph of Faces Flows as a library developer, one can
    argue for this flexibility for external configurators. If you are building simple
    applications, then maybe following the practice of YAGNI (You Aren't Going to
    Need it) will benefit in a minimum viable product.
  prefs: []
  type: TYPE_NORMAL
- en: This covers all that we need to know about the basic flow definition file. Let's
    move on to the nested declarative flow now.
  prefs: []
  type: TYPE_NORMAL
- en: A nested flow example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to see a practical example of Faces Flow with nested declarative
    flow definitions. Our application is simple. It allows the customer to record
    carbon footprint data. So first let''s define a data record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `CarbonFootprint` is a JPA entity bean, which declares a set of properties
    to store the customer's carbon footprint data. The user can supply their industry
    or sector, the amount of electricity, natural gas, diesel, and petrol they consume
    over a time period. The record also has an `applicationId` value, which we shall
    make use of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s view the file layout for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/java`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/WEB-INF/classes/META-INF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/index.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/assets/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/basic-layout.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/view-expired.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/section-flow/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/section-flow/section-flow.xml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/section-flow/section-flow.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/section-flow/section-flow-1a.xthml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/section-flow/section-flow-1b.xthml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/section-flow/section-flow-1c.xthml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/footprint-flow/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/footprint-flow/footprint-flow.xml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/footprint-flow/footprint-flow.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/footprint-flow/footprint-flow-1a.xml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/endflow.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is called `jsf-declarative-flows` and is available as a part of
    the book''s source code. There are two flows: `section-flow` and `digital-flow`.
    The section flow captures the industry information in this made-up example. The
    footprint flow captures the energy consumption data. Both flows share a customer
    detail record, the `CarbonFootprint` entity object, which you will see later in
    the backing beans.'
  prefs: []
  type: TYPE_NORMAL
- en: XML flow definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the XML flow definition for the Sector flow, `sector-flow/sector-flow.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The identifier for this flow is sector-flow, which matches the folder name.
    It also establishes the `@FlowScoped` value for the backing bean, the action controller,
    as we shall see later.
  prefs: []
  type: TYPE_NORMAL
- en: There are two Flow Return nodes, namely `goHome` and `endFlow`. The `goHome`
    has direct navigation to the home page, whereas `endFlow` invokes an action on
    the bean through the EL value, `#{sectorFlow.gotoEndFlow()}`. This technique is
    particularly useful to ensure that a customer has entered correct and validated
    data before allowing them to complete their digital journey.
  prefs: []
  type: TYPE_NORMAL
- en: The new node `callFootprintFlow` represents a nested flow invocation. The element
    `<flow-call>` defines a Flow Call node. It must have a `<flow-reference>` tag
    element with a nested tag, `<flow-id>`. The body content of the latter defines
    the identifier of the target flow.
  prefs: []
  type: TYPE_NORMAL
- en: The `<outbound-parameter>` elements specify how the parameters and value pairs
    are passed to the target flow. Each parameter requires a `<name>` and a `<value>`
    element. The name of the outgoing parameter in the calling flow must match the
    name of the incoming parameter in the invoked flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `param1FromSectorFlow` and `param2FromSectorFlow` demonstrate how to pass
    the literal String values from one flow to another. If you are passing numeric
    values, then you have to encode and decode these values yourself in the target
    flow. The parameters `param3FromSectorFlow` and `param4FromSectorFlow` also illustrate
    how EL can be used. Note how we can easily pass the entity record `#{sectorFlow.footprint}`
    from the Sector Flow to the Footprint Flow. We can also pass an individual property
    as we have done in the final parameter: `#{sectorFlow.footprint.applicationId}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the XML flow definition for the Footprint Flow `footprint-flow/footprint-flow.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This flow is identified by the name `footprint-flow.xml`. It has a set of return
    flow nodes. The `goHome` node actually exits the flows to the calling home, despite
    the view document value `/index` value. You might think this behavior as odd.
    However, JSF is correct, because the current flow Footprint is a nested flow and
    it drives the flow pointer to the state of the calling flow sector. The nodes
    `exitFromFootprintFlow` and `exitToSectionFlow` represent different navigation
    strategies, indirect and direct respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The set of `<inbound-parameter>` elements specify the incoming parameter to
    the flow. The names of the parameters are extremely important, because they must
    match those in the corresponding `<outbound-parameter>` element in the calling
    flow. The values define the EL object reference, which say where these values
    are written. In other words, the passing of parameters in Faces Flow behaves like
    a mapped property name transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the third parameter from `sector-flow.xml`. It sends a value
    of the entity record instance `CarbonFootprint` to the nested Footprint Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `footprint-flow.xml`, the inbound parameter name matches the incoming
    parameter name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The EL specifies the location where JSF sets the value of the parameter to the
    property of the object. In this case, the `flowScope` map collection has a key
    and a value set. We can use any existing object that has a lifespan greater or
    equal to the flow lifecycle. We tend to use the `flowScope`, because it is designed
    to pass parameters between Face Flows. Because we can reference properties in
    objects, we also have the ability to return information from the nested flows.
    The calling flow may retrieve the value after the nested flow ends.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the nested flows from the XML perspective, we can look
    at the Java source code.
  prefs: []
  type: TYPE_NORMAL
- en: Flow beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sector-flow` backing bean looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The class `SectorFlow` is annotated with `@FlowScoped`, and the value matches
    the flow definition XML file. We annotate a method `initialize()` with `@PostConstruct`
    in order to set a random application ID in the entity record. Note that we cannot
    put this logic inside a normal Java constructor here, because our bean is given
    life through the CDI container.
  prefs: []
  type: TYPE_NORMAL
- en: We inject a couple of instances into `SectorFlow`. The `UtilityHelper` is an
    `@ApplicationScoped` CDI POJO class that generates a random application identifier.
    There is a stateful EJB `CarbonFootprintService` that handles the JPA persistence.
  prefs: []
  type: TYPE_NORMAL
- en: The `gotoEndflow()` method is a navigation end to exit the flow. The method,
    `saveFootprintRecord()` uses the data service to store the `CarbonFootprint` entity
    into a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the inner flow, that is, `SectorFlow`; the code for the nested
    backing bean `FootprintFlow` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We repeat the same trick as before; we annotate the `FootprintFlow` class with
    `@PostConstruct`. In the `initialize()` method, we retrieve the object from the
    flow scope programmatically through the `FacesContext` instance. Note that the
    parameter name `param3Value` must agree with the value inside the XML definition.
    The value in the flow scope happens to be the `CarbonFootprint` entity.
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering why we go to the trouble of retrieving an entity from
    a scope and setting it as a bean property? It is just an example, and allows the
    page content designer to use a consistent markup in the pages. The EL `#{footprintFlow.footprint.diesel}`
    is more comprehensible than `#{flowScope.param3Value.diesel}`.
  prefs: []
  type: TYPE_NORMAL
- en: We shall now move on to the markup.
  prefs: []
  type: TYPE_NORMAL
- en: Page views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The content markup for page views is familiar to us by now. Let''s study `sector-flow/sector-flow.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The view uses a mix of HTML5 friendly markup and the standard JSF tags. The
    input text field, `exampleInputEmail1` and its associated label remind us about
    the HTML5 friendly markup. This input control is associated with the flow scope
    map collection, namely `#{flowScope.email}`. The answer is yes, we are allowed
    to write this, but we had better store the data value somewhere in the application!
  prefs: []
  type: TYPE_NORMAL
- en: The input element `industryOrSector` shows us the JSF standard tags and it is
    directly associated with the `CarbonFootprint` entity record.
  prefs: []
  type: TYPE_NORMAL
- en: Let me draw your attention to the command button `saveBtn` that invokes the
    action method `saveFootprintRecord()` in the backing bean. Finally, there is a
    dedicated command button identified by `callFootPrintFlowBtn`, which invokes the
    nested flows. The action `callFootprintFlow` matches the node in the XML flow
    definition file for `sector-flow.xml` exactly.
  prefs: []
  type: TYPE_NORMAL
- en: There is a `nextBtn` command button that directly navigates to the next view
    in the flow. The `homeBtn` command button exits the flow and returns the home
    page.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the view shows debuggable output in an HTML Bootstrap style table.
    The `prependId=false` on the JSF `<h:form>` element informs JSF to avoid sugaring
    the property HTML identifiers for the controls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JSF Form `prependId` specifies whether or not the `<h:form>` should prepend
    its ID to its descendant's ID during the `clientId` generation process. The flag
    becomes relevant when importing or inserting composite components that are forms
    in an outer form. This value defaults to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the start page `sector-flow/sector-flow.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Page views](img/image00414.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the source code, we dumped out a set of debuggable values using EL. The project
    is called `jsf-declarative-form` in the book's source code. You will find a cleaned-out
    professional version without debuggable output, which is called `jsf-declarative-form-pro`.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a screenshot of the nested flow, `footprint-flow-1a.xhtml`.
    After navigating to the start page, we hit the **Next** button, entered some data
    into the form, and save it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Page views](img/image00415.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Going back to `SectorFlow`, when we invoke the `SaveBtn` command button, JSF
    invokes the `saveFootprintRecord()` method. The record is saved to the database
    and the view `sector-flow-1c.xthml` is displayed as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Page views](img/image00416.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The only parts that remain are the source code for the injected POJO, `UtilityHelper`
    and the EJB, `CarbonFootprintService`. Unfortunately, we cannot show all the listings
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: A real-world example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To wrap up Faces Flows, let's look at adding features to our application. We
    want our JSF application to have quality and finesse. In the book's source code,
    you will find these examples under the projects `jsf-product-flow` and `jsf-product-flow-s2`.
    The first project demonstrates the prototypical design of the concepts. The second
    project illustrates the improved and cleaned-up digital design with enough quality
    to present to a business stakeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the application populates the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, we develop applications that operate against a UAT database for testing.
    We write code that populates the database with test information, which does not
    go into production. In a lot of cases, we want to bootstrap our application just
    to check that the correct schema has been introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Our first thought would be to create an `@ApplicationScoped` POJO with an annotation
    `@PostConstruct`, and this would solve our bootstrap issue. We can write a `DataPopulator`
    class with the sole purpose to create data inside a development application. Although
    we have a firm-wide application instance, we cannot ensure that our bean is invoked
    after the startup of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: With Java EE, we can use `@javax.ejb.Startup` and `@javax.ejb.Singleton` to
    start an EJB. The `@Startup` annotation ensures that the EJB container initializes
    the bean after the application is deployed. The `@Singleton` annotations denotes
    the session bean that guarantees that there is, at the most, one instance in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `DataPopulator` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in order to populate the application with data, we delegate another bean.
    The `ExtendedPersistenceLoaderBean` is a CDI bean with a new CDI 1.1 transactional
    scope. The code for this delegate is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We annotate the `DataPopulator` bean with `@TransactionScoped`. Whenever we
    invoke a method on the `@TranscationScoped` bean, the method, the CDI container,
    will activate a transaction or have one created. A single transaction will be
    shared amongst many methods on the same bean or shared between other `@TranscactionScoped`
    beans that may be called. In other words, the transaction context is passed around
    participating components without requiring the developer to add explicit method
    arguments to pass around `javax.transaction.TransactionContext` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Going back, we've added another special annotation to our `DataPopulator` bean.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as any method is invoked on this bean, the thread context becomes associated
    with a brand new transaction, because we annotated the class with `@TransactionAttribute`
    and pass in an attribute value `TranscationAttributeType.NEW`. This forces the
    container to create a new transaction, regardless of if there is one existing
    already. The lifecycle of the transaction scope is the duration of the call to
    the `loadData()`. The method simply creates a couple of `UserRole` entities in
    the database, and then it creates user accounts for the login with the `UserProfile`
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `init()` and `destroy()` methods just print the debug information
    to the console, and the details are not shown in the extract.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though CDI 1.1 defines a `@javax.inject.Singleton` annotation for CDI beans,
    this exact launch of a CDI bean is not defined in the specification, because this
    specification is missing in `@javax.inject.Startup`. Therefore, we must rely on
    the EJB singleton startup bean. We probably have to wait until CDI 2.0 and Java
    EE 8 to see this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have user profiles and roles, how do we secure a JSF application?
  prefs: []
  type: TYPE_NORMAL
- en: Securing page views and flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to stay with the standard Java EE libraries, then the specification
    has the Container Managed Authentication feature. In order to take advantage of
    this feature, you extend the web deployment descriptor file, `web.xml`, and add
    a security constraint to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of security constraints inside a `web.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first security constraint restricts the products, carts, checkout, and promotion
    pages of this website to any user. Note the wildcard given as the role name. The
    second security constraint restricts the admin pages of this website only to users
    with an admin role.
  prefs: []
  type: TYPE_NORMAL
- en: The `<user-data-constraint>` element declares whether the page view is accessible
    with HTTP or HTTPS. It specifies the level of security required. The acceptable
    values are `NONE`, `INTEGRAL`, and `CONFIDENTIAL`. Setting the transport guarantee
    to `CONFIDENTIAL` informs the application server that these pages and resources
    are only accessible over SSL. The value of `INTEGRAL` is important in communication
    when the data sent over the wire from the client or the server should not be changed
    in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip Java EE 8 Security—a word on the future TODO (note for me to check on updates
    and progress. See [https://javaee8.zeef.com/arjan.tijms](https://javaee8.zeef.com/arjan.tijms)).
    There are not too many alternatives to the standard Java EE security. The other
    choices are Apache Shiro ([http://shiro.apache.org/](http://shiro.apache.org/))
    or Spring Security (formerly Acegi). It is hoped that Java EE 8 will include a
    revamp concept and perhaps a separate specification.
  prefs: []
  type: TYPE_NORMAL
- en: Whilst the standard mechanism is fast and easy to add, it is application-server
    specific. The mechanism applies only to coarse grain resources, and there are
    no annotations that we can apply to CDI beans. Java EE security requires the configuration
    of Security Realms, which defines the roles of groups of users. In order to secure
    a website with fine- grain permission, we have to add multiple roles, which can
    lead to high complexity.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to define our own custom security for JSF and the web applications.
    The advantage of this approach is that we have fine-grained control and it works
    across the containers. On the other hand, if we ignore the Java EE security standard
    features, then any home-baked security implementation is unlikely to have been
    sufficiently proven secure in the wild. Such a component will fail basic penetration
    testing. At best, custom security works if the requirements are straightforward
    and there are few demands on complex permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create custom security, we shall define a unique `javax.servlet.ServletFilter`,
    which protects the access to certain areas of our website. The `LoginAuthenticationFilter`
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We annotate the class with `@WebFilter` with the URL resources that we want
    to protect. If a user attempts to access a page under the `/protected/*` and `/simple/*`
    folder, then the filter, `LoginAuthenticationFilter` is triggered. The servlet
    container invokes the `doFilter()` method and we check if an HTTP session attribute
    is defined or not. If the key `LoginController.LOGIN_KEY` does exist, the user
    is logged into the site, otherwise, the user is redirected to the login page view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move to the backing bean `LoginController`, which allows a user to log
    into the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoginController` backing bean accepts two form-based parameters: the username
    and a password. It relies on the injected `UserProfileService` to find a `UserProfile`
    record by the username. Inside the `login()` method, a user is allowed to log
    in if the password parameter matches the entity record. The method adds the username
    to the HTTP session under the key, `LOGIN_KEY`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of helpful methods. The `logout()` method removes the login
    key from the HTTP session key. The `isLoggedIn()` method checks if a user has
    logged in or not.
  prefs: []
  type: TYPE_NORMAL
- en: The servlet filter only handles the direct navigation resources, servlets, filters,
    and paths. We need another protector for the JSF views, because `LoginAuthenticationFilter`
    is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for a backing bean controller called `LoginViewAuthenticator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The class `LoginViewAuthenticator` has a `check()` method that performs a check.
    We retrieve the known key `LOGIN_KEY` from the HTTP session. Note that we can
    access parts of the Java Servlet API through a chained call to the `getExternalContext()`
    method on `FacesContext`. We retrieve the `HttpSession` instance or create one
    and then check for the associated value. If the user is not logged in, then we
    change the destination of the current `NavigationHandler`. The navigation handler
    in JSF is an implementation-defined type that carries the target outcome string
    during a Faces request-and-response interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `LoginViewAuthenticator` in a page view to restrict access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For the page `view /protected/index.html`, we insert a pre-render view event
    using the `<f:metadata>` section. The `<f:event>` element invokes the `check()`
    method of the `LoginViewAuthenticator` bean.
  prefs: []
  type: TYPE_NORMAL
- en: In the project, we also secured the Faces Flow by adding the same stanza to
    the page view `/simple.xhtml`. This view is the start page and, therefore, adding
    the pre-render view event here effectively restricts access to the flow. The `LoginViewAuthenticator`
    bean ensures that unknown website users are redirected to the `/login.xhtml` view.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Library Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.2, as a part of Java EE 7, introduced the ability to theme and style websites
    under a facility known as the Resource Library Contracts. The idea of contracts
    is about reusing Facelets dynamically at runtime. It is possible now with contracts
    to switch between resources without having to redeploy an application. Contracts
    can also be declared statically for pages that match a URL pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The specification reserves a specially named folder called `/contracts` as the
    parent folder for the Resource Library Contracts. This folder is the default one.
    If you already have a folder named as this view, then you will have to refactor
    by name, unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: There is another default location, `META-INF/contracts`, on the classpath for
    JARs. This location allows the resource library contracts to be packaged as JAR
    for distribution to the third-party customers.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `/contracts` folder, a developer can define named contracts (or themes).
    You can only create folders inside the location folder `/contract` or (`/META-INF/contracts`),
    and each folder represents a named contract. In the specification, a contract
    has a declared template. Each contract may define resources such as images, CSS,
    JavaScript files, and other content files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a project called `jsf-resource-library-contracts` in the book''s source
    distribution, and in there you will see the following files laid out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two Resource Library Contracts: `default` and `victoria`. These folders
    share the same resources although they do not have to. The two `template.xhtml`
    files are UI composition files that lay out the page view. The two `app.css` files
    are CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: A resource contract must have at least one UI composition template, which is
    called a declared template in the specification. In each contract folder, the
    file `template.xhtml` is a declared template. Inside each template file that the
    specification mentions, any `<ui:insert>` tags are known as declared insertion
    points. The term declared resources means the collection of images, CSS and JavaScript,
    and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `default/template.xhtml` file, we have an important link to the
    reference styles sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, in the `victoria/template.xhtml`, we have a link to the alternative
    style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In each resource contract, we can vary the properties of shared CSS selectors
    in the CSS files in order to produce alternate themes. The following is an extract
    of `default/styles/app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is similar to `victoria/styles/app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is a difference of color, font family, size, and style.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure the resource contracts in static usage from the matching
    URL pattern, we declare the titles in the Faces configuration file, `faces-config.xml`.
    JSF 2.2 introduces a new `<resource-library-contracts>` element. Each contract
    is associated with a name and one or more URL patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Static Resource Library Contract references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example project, we should have a Faces configuration file that has
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<contract-mapping>` element defines two contracts: `default` and `victoria`.
    The order of the contracts is important for processing. For the entire website,
    the `default` contract is active whereas the `victoria` contract is active only
    for the page view underneath the `/corporate/ URL`. A contract mapping may have
    more than one URL pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a page view to trigger this contract statically. The following
    is an extract of the page view, `/corporate/index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Based on the previous resource library contract definitions in `faces-config.xml`,
    the paragraph with the CSS class, fashion-headline should be green in color. Notice
    how JSF searches for and finds the `/template.xhtml` references, which lie in
    the corporate folder. So defining Resources Library Contracts that can be switched
    statically is a good feature to have, but what if we wanted to change the contract
    on the fly? We can achieve this goal and we'll learn how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Resource Library Contract references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you surround the UI composition with static reference with an `f:view` element,
    as we did in the page view, then we can add another new attribute called contracts.
    This attribute accepts a String expression that references a resource contract
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract of this home page view `/index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `#{fashionSelector.theme}` controller references a getter for a backing
    bean, which we will see in a moment. The value of the expression sets the chosen
    resource library contract. We make use of the CSS paragraph in order to visually
    see the contract template in action. In order to change the contract, we employ
    a form with the radio selection element. The `<f:selectItem>` tag defines the
    contract name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our backing bean `FashionSelector` is a controller with one action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We annotate the controller as a `@SessionScoped` bean in order to preserve the
    contract change across the many request-response cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource library contracts also happily function with Faces Flows. The
    technique of using either static URL patterns or the dynamic selector of the template
    equals the flows. In the book''s source, you will find more demonstrations and
    source code. In fact, the page view `/digitalFlow/digitalFlow.xhtml` looks exactly
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in principle, there is no difference at all.
  prefs: []
  type: TYPE_NORMAL
- en: Advice for flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Faces Flows are a very useful feature in JSF 2.2, because they allow developers
    and designers to put together components that achieve customer (or user centric)
    goals. They also allow an architect to define groups of page views and controllers
    into specific business defined components. If the designer is careful, they can
    be linked together efficiently and decoupled from dependencies in meaningful strategies.
    The following points should be kept in mind while using Faces Flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start small**: Design a Faces Flow that achieves one responsibility and one
    goal. Don''t try to build the entire process in a single flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pass entities and meaning types**: Implement Faces Flows that accept data
    entities and transfer objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compose flows together**: Group together common flows that achieve a similar
    goal. In a checkout process, you may have a flow dedicated to the shipping address
    and a flow responsible for payments. These two flows can be invoked by a master
    flow that handles the entire process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulate flows**: Encapsulate your flow as much as possible, so that it
    is self-sufficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persist your user''s data**: when a customer completes a task, ensure that
    user data is saved at the determined exit points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resist the temptation of building the perfect workflow. Instead, I recommend
    that you design Faces Flow with change at the back of your mind.
  prefs: []
  type: TYPE_NORMAL
- en: In modern digital teams building websites and applications, the most important
    person is the UX designer. Often, after several rounds of user-centric testing,
    you might find the page design and information architecture of the site changing
    and going back and forth over weeks or even months. By building small, goal-oriented
    Faces Flow components, you will protect the developer team from the constant changes
    driven by the UX design team. Design your flows not for reuse, but for replacement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we examined the poster child of the JSF 2.2 release: Faces
    Flows. We learned about flow definitions and lifecycles. We covered ground with
    implicit navigation and created POJO using the `@FlowScoped` scope. We drilled
    down into the terminology of flow processes and we studied declarative and nested
    flows. We saw how we can pass parameters from one flow to another through invocation.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to add finesse to our digital application by handling expired
    views. Then we added security around page views and Resource Library Contracts
    to our new abilities. We understood how contracts allow the developer to add themes
    and styles to our JSF application. Another thing that we learned is that the Resource
    Library Contracts may be driven by static declaration or controlled by backing
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will step away from JSF and delve into JavaScript programming
    and library framework.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify that flow-scoped beans are unique with multiple web browsers and tab
    frames. Modify the `debugClassName()` method in the first flow class, `DigitalFlow`
    to report the value of `java.lang.System.identityHashCode()` as well as the class
    name. What is the result?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everyone practically knows how to make a simple breakfast of scrambled eggs;
    write down the steps for doing so. What processes do you need? What inputs do
    you need? We know the results of the tasks; are there other outputs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Develop a simple Faces Flow application that takes contact details from a user.
    Think of the number of properties that you will need. Do you need all of them?
    (Hint: Name, address, e-mail, and telephone number will do for now.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the contact details Faces Flow application from the previous question and
    now persist that entity record data to a database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now split the contact detail single flow application into separate flows. Set
    up the address part as a nested flow. (Hint: You can pass the entity record from
    one flow to another.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the contact details application, how can we allow the customer to retrieve
    entities? Develop the Faces application so that he or she can save the data temporarily.
    (Hint: maybe the customer requires a temporary application ID, so add one to the
    contact details entity.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we will take the contact application and copy it to a new project.
    We will rebrand the project as `welcome-new-bank-customer`. In the retail banking
    industry, this business process is called `on-boarding`. You will need one or
    two nested flows. One flow accepts the person''s work status: their salary, their
    job title, and, obviously, an occupation. If you feel confident, perhaps you can
    add a work address as another flow, and if you feel even stronger, add the national
    insurance number and tax records. With a more complicated project, consider, what
    would happen if it were possible to re-order the flows? How well is your design
    encapsulated? Can the developers easily rearrange the flows to fit the UX challenges?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given the contact details/banking onboarding application up to now, you should
    have many database records of contacts. Write another Faces Flow in the same web
    application that allows a trusted member of staff, a case worker, to amend and
    delete customer records. In a real business, such an employee sits behind the
    system and approves each onboarding application request one by one. You will need
    to write the HTTP login form for security and protect the non-public page views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
