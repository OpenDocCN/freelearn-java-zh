<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Microbenchmarking Applications with JMH</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous chapter, we took an in-depth review of <strong class="calibre8">garbage collection</strong> to include an object life cycle, garbage collection algorithms, garbage collection options, and methods related to garbage collection. We took a brief look at upgrades to garbage collection in Java 8 and focused on changes with the new Java 9 platform. Our exploration of garbage collection in Java 9 included looks at default garbage collection, depreciated garbage collection combinations, unified garbage collection logging, and garbage collection issues that persist, even after Java 9.</p>
<p class="mce-root">In this chapter, we will look at how to write performance tests using the <strong class="calibre8">Java Microbenchmark Harness</strong> (<strong class="calibre8">JMH</strong>), a Java harness library for writing benchmarks for the <strong class="calibre8">Java Virtual Machine</strong> (<strong class="calibre8">JVM</strong>). We will use Maven along with JMH to help illustrate the power of microbenchmarking with the new Java 9 platform.</p>
<p class="mce-root">Specifically, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Microbenchmarking overview</li>
<li class="calibre14">Microbenchmarking with Maven</li>
<li class="calibre14">Benchmarking options</li>
<li class="calibre14">Techniques for avoiding microbenchmarking pitfalls</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Microbenchmarking overview</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Microbenchmarking is used to test the performance of a system. This differs from macrobenchmarking which runs tests on different platforms for efficiency comparison and subsequent analysis. With microbenchmarking, we typically target a specific slice of code on one system such as a method or loop. The primary purpose of microbenchmarking is to identify optimization opportunities in our code.</p>
<p class="mce-root">There are multiple approaches to benchmarking and we will focus on using the JMH tool. So, why benchmark at all? Developers do not always concern themselves with performance issues unless performance is a stated requirement. This can lead to post-deployment surprises that could have been avoided if microbenchmarking was conducted as part of the development process.</p>
<p class="mce-root">Microbenchmarking takes place across several phases of a process. As shown in the following diagram, the process involves design, implementation, execution, analysis, and enhancement:</p>
<div class="mce-root1"><img src="Images/9977e7cd-6e56-40fc-abfd-4c115659bf82.png" width="1000" height="684" class="calibre109"/></div>
<p class="mce-root">In the <strong class="calibre8">Design</strong> phase, we determine our goals and design our microbenchmark accordingly. In the <strong class="calibre8">Implement</strong> phase, we are writing the microbenchmark and then, in the <strong class="calibre8">Execution</strong> phase, we actually run the test. With microbenchmarking results in hand, we interpret and analyze the results in the <strong class="calibre8">Analysis</strong> phase. This leads to code improvements in the <strong class="calibre8">Enhancement</strong> phase. Once our code has been updated, we redesign the microbenchmarking test, adjust the implementation, or go straight to the <strong class="calibre8">Execution</strong> phase. This is a cyclical process that continues until we have achieved the performance optimization we identified in our goals.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Approach to using JMH</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Oracle's documentation indicates that the most ideal JMH use case is to use a Maven project that is dependent on the application's JAR files. They further recommend that microbenchmarking take place via the command-line and not from within an <strong class="calibre8">Integrated Development Environment</strong> (<strong class="calibre8">IDE</strong>), as that could impact the results.</p>
<div class="packt_infobox">Maven, also referred to as Apache Maven, is a project management and comprehension tool that we can use to manage our application project build, reporting, and documentation.</div>
<p class="mce-root">To use JMH, we will use bytecode processors (annotations) to generate the benchmark code. We use Maven archetypes to enable JMH.</p>
<p class="mce-root">In order to test the JMH, we require an IDE with support for Maven and Java 9. If you do not yet have Java 9 or an IDE with Java 9 support, you can follow the steps in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Installing Java 9 and Eclipse with Java 9 support</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">You can download and install Java 9 from the JDK 9 early access builds page--<a href="http://jdk.java.net/9/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">http://jdk.java.net/9/</a>.</p>
<p class="mce-root">Once you have Java 9 installed, download the latest version of Eclipse. At the time of writing this book, that was Oxygen. Here is the relevant link--<a href="https://www.eclipse.org/downloads/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://www.eclipse.org/downloads/</a>.</p>
<p class="mce-root">The next step is to enable Java 9 support in your IDE. Launch Eclipse Oxygen and select <span class="calibre7">Help</span> | <span class="calibre7">Eclipse Marketplace...</span> , as shown in the following screenshot:</p>
<div class="mce-root1"><img src="Images/e58605c5-04d5-43d6-942f-30f91ead584a.png" class="calibre110"/></div>
<p class="mce-root">With the <span class="calibre7">Eclipse Marketplace</span> dialog window present search for <kbd class="calibre16">Java 9 support</kbd> using the search box. As you can see in the following screenshot, you will be presented with an <span class="calibre7">Install</span> button:</p>
<div class="mce-root1"><img src="Images/88048ea3-6896-40f5-8e18-0ca017da2467.png" width="552" height="557" class="calibre111"/></div>
<p class="mce-root">During the installation process, you will be required to accept the license agreement and, upon completion, you will be required to restart Eclipse.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Hands-on experiment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now that we have Eclipse updated to support Java 9, you can run a quick test to determine if JMH is working on your development computer. Start by creating a new Maven project as illustrated in the following screenshot:</p>
<div class="mce-root1"><img src="Images/a0904716-b8d9-449f-9268-135f980bb6c6.png" width="592" height="539" class="calibre112"/></div>
<p class="mce-root">Next, we need to add a dependency. We can do this by editing the <kbd class="calibre16">pom.xml</kbd> file directly with the following code:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>      &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;<br class="calibre2"/>      &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;<br class="calibre2"/>      &lt;version&gt;0.1&lt;/version&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="mce-root">Alternatively, we can use the dependencies tab to enter the data in a dialog window, as shown in the following screenshot. Using this form updates the <kbd class="calibre16">pom.xml</kbd> file with the preceding code:</p>
<div class="mce-root1"><img src="Images/8ffc4351-aeba-4856-9192-4a51606dc064.png" class="calibre113"/></div>
<p class="mce-root">Next, we need to write a class that contains a JMH method. This is just as an initial test to confirm our recently updated development environment. Here is sample code you can use for your test:</p>
<pre class="calibre21">    package com.packt.benchmark.test.com.packt.benchmark.test;<br class="calibre2"/><br class="calibre2"/>    import org.open.jdk.jmh.Main;<br class="calibre2"/><br class="calibre2"/>    public class Test <br class="calibre2"/>    {<br class="calibre2"/><br class="calibre2"/>      public static void main(String[] args)<br class="calibre2"/>      {<br class="calibre2"/>        Main.main(args);<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">We can now compile and run our very simple test program. The results are provided in the Console tab, or the actual console if you are using the command-line. Here is what you will see:</p>
<div class="mce-root1"><img src="Images/2805c145-4579-4ce4-8cb5-ae9b8cb969e1.png" class="calibre114"/></div>
<p class="mce-root">You can see that the program worked sufficiently to let us know that JMH is working. Of course, there was, as the output indicates, no benchmarks set up. We will take care of that in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Microbenchmarking with Maven</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One approach to getting started with JMH is to use the JMH Maven archetype. The first step is to create a new JMH project. At our system's command prompt, we will enter the <kbd class="calibre16">mvn</kbd> command followed by a long set of parameters to create a new Java project and the necessary Maven <kbd class="calibre16">pom.xml</kbd> file:</p>
<pre class="calibre21"><strong class="calibre3">mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh -java-benchmark-archetype -DgroupId=com.packt -DartifactId=chapter8-benchmark -Dversion=1.0</strong></pre>
<p class="mce-root">Once you enter the <kbd class="calibre16">mvn</kbd> command and the preceding detailed parameters, you will see the results reported to you via the Terminal. Depending on your level of use, you might see a large number of downloads from <a href="https://repo.maven.apache.org/maven2/org/apache/mave/plugins" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://repo.maven.apache.org/maven2/org/apache/mave/plugins</a> and other similar repository sites.</p>
<p class="mce-root">You will also see an information section that informs you about the project build process:</p>
<div class="mce-root1"><img src="Images/14f51f0d-5ca9-43ef-9dc3-12be9b272e61.png" class="calibre115"/></div>
<p class="mce-root">There will likely be additional plugin and other resources downloaded from the <a href="https://repo.maven.apache.org" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://repo.maven.apache.org</a> repositories. Then, you will see an informational feedback component that lets you know the project is being generated in batch mode:</p>
<div class="mce-root1"><img src="Images/1426df05-6070-4f4c-a711-451f75765d2d.png" class="calibre116"/></div>
<p class="mce-root">Finally, you will be presented with a set of parameters and a note that your project build was successful. As you can see with the following example, the process took less than 21 seconds to complete:</p>
<div class="mce-root1"><img src="Images/188f1b35-cf34-416f-8019-07dd0806dbe4.png" class="calibre117"/></div>
<p class="mce-root">A folder will be created based on the parameter we included in the <kbd class="calibre16">-DartifactId</kbd> option. In our example, we used <kbd class="calibre16">-DartifactId=chapter8-benchmark</kbd>, and Maven created a <kbd class="calibre16">chapter8-benchmark</kbd> project folder:</p>
<div class="mce-root1"><img src="Images/b3aa8bd9-3964-4a9d-8f04-d22ae270f386.png" width="553" height="285" class="calibre118"/></div>
<p class="mce-root">You will see that Maven created the <kbd class="calibre16">pom.xml</kbd> file as well as a source (<kbd class="calibre16">src</kbd>) folder. In that folder, under the subdirectory structure of <kbd class="calibre16">C:chapter8-benchmarksrcmainjavacompackt</kbd>, is the <kbd class="calibre16">MyBenchmark.java</kbd> file. Maven created a benchmark class for us:</p>
<div class="mce-root1"><img src="Images/12e79714-00f2-4413-8eb4-1705d52cbc06.png" width="553" height="253" class="calibre119"/></div>
<p class="mce-root">Here are the contents of the <kbd class="calibre16">MyBenchmark.java</kbd> class created by the JMH Maven project creation process:</p>
<pre class="calibre21">    /*<br class="calibre2"/>     * Copyright (c) 2014, Oracle America, Inc.<br class="calibre2"/>     * All rights reserved.<br class="calibre2"/>     *<br class="calibre2"/>     * Redistribution and use in source and binary forms, with or <br class="calibre2"/>       without<br class="calibre2"/>     * modification, are permitted provided that the following <br class="calibre2"/>       conditions are met:<br class="calibre2"/>     *<br class="calibre2"/>     * * Redistributions of source code must retain the above<br class="calibre2"/>         copyright notice,<br class="calibre2"/>     * this list of conditions and the following disclaimer.<br class="calibre2"/>     *<br class="calibre2"/>     * * Redistributions in binary form must reproduce the above <br class="calibre2"/>         copyright<br class="calibre2"/>     * notice, this list of conditions and the following<br class="calibre2"/>       disclaimer in the<br class="calibre2"/>     * documentation and/or other materials provided with the <br class="calibre2"/>       distribution.<br class="calibre2"/>     *<br class="calibre2"/>     * * Neither the name of Oracle nor the names of its <br class="calibre2"/>         contributors may be used<br class="calibre2"/>     * to endorse or promote products derived from this software <br class="calibre2"/>       without<br class="calibre2"/>     * specific prior written permission.<br class="calibre2"/>     *<br class="calibre2"/>     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND <br class="calibre2"/>       CONTRIBUTORS "AS IS"<br class="calibre2"/>     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT <br class="calibre2"/>       LIMITED TO, THE<br class="calibre2"/>     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A <br class="calibre2"/>       PARTICULAR PURPOSE<br class="calibre2"/>     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR <br class="calibre2"/>       CONTRIBUTORS BE<br class="calibre2"/>     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, <br class="calibre2"/>       EXEMPLARY, <br class="calibre2"/>       OR<br class="calibre2"/>     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, <br class="calibre2"/>       PROCUREMENT OF<br class="calibre2"/>     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;<br class="calibre2"/>       OR BUSINESS<br class="calibre2"/>     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, <br class="calibre2"/>       WHETHER IN<br class="calibre2"/>     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR <br class="calibre2"/>       OTHERWISE)<br class="calibre2"/>     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF <br class="calibre2"/>       ADVISED OF<br class="calibre2"/>     * THE POSSIBILITY OF SUCH DAMAGE.<br class="calibre2"/>     */<br class="calibre2"/><br class="calibre2"/>    package com.packt;<br class="calibre2"/><br class="calibre2"/>    import org.openjdk.jmh.annotations.Benchmark;<br class="calibre2"/><br class="calibre2"/>    public class MyBenchmark <br class="calibre2"/>    {<br class="calibre2"/>      @Benchmark<br class="calibre2"/>      public void testMethod() <br class="calibre2"/>      {<br class="calibre2"/><br class="calibre2"/>        // This is a demo/sample template for building your JMH <br class="calibre2"/>           benchmarks. <br class="calibre2"/>        //Edit as needed.<br class="calibre2"/>        // Put your benchmark code here.<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">Our next step is to modify the <kbd class="calibre16">testMethod()</kbd> so that there is something to test. Here is the modified method we will use for the benchmark test:</p>
<pre class="calibre21">    @Benchmark<br class="calibre2"/>    public void testMethod() <br class="calibre2"/>    {<br class="calibre2"/>      int total = 0;<br class="calibre2"/>      for (int i=0; i&lt;100000; i++)<br class="calibre2"/>      {<br class="calibre2"/>        total = total + (i * 2 );<br class="calibre2"/>      }<br class="calibre2"/>      System.out.println("Total: " + total);<br class="calibre2"/>    }</pre>
<p class="mce-root">With our code edited, we will navigate back to the project folder, <kbd class="calibre16">C:chapter8-benchmark</kbd>, in our example, and execute <kbd class="calibre16">mvn clean install</kbd> at the command prompt.</p>
<p class="mce-root">You will see several repository downloads, source compilations, plugin installations and, finally the Build Success indicator, as shown here:</p>
<div class="mce-root1"><img src="Images/fe83ee6f-a43d-461b-9a11-b0d6a8f67a51.png" class="calibre120"/></div>
<p class="mce-root">You will now see <kbd class="calibre16">.classpath</kbd> and <kbd class="calibre16">.project</kbd> files as well as a new <kbd class="calibre16">.settings</kbd> and target subfolders in the project directory:</p>
<div class="mce-root1"><img src="Images/62579177-8493-4b9f-8973-68928d464e29.png" width="524" height="360" class="calibre121"/></div>
<p class="mce-root">If you navigate to the <kbd class="calibre16">target</kbd> subfolder, you will see that our <kbd class="calibre16">benchmarks.jar</kbd> file was created. This JAR contains what we need to run our benchmarks.</p>
<p class="mce-root">We can update our <kbd class="calibre16">MyBenchmark.java</kbd> file in an IDE, such as Eclipse. Then, we can execute <kbd class="calibre16">mvn clean install</kbd> again to overwrite our files. After the initial time, our builds will be much faster, as nothing will need to be downloaded. Here is a look at the output from the build process other than the first time:</p>
<div class="mce-root1"><img src="Images/25c6fa3b-caf1-4c57-af99-8c1b1cc7c8db.png" width="757" height="937" class="calibre122"/></div>
<p class="mce-root">Our last step is to run the benchmark tool. We can do that with the following command--<kbd class="calibre16">java -jar benchmarks.jar</kbd>. Even for small benchmarks on simplistic code, as with our example, the benchmarks could take some time to run. There will likely be several iterations including warmups to provide a more concise and valid set of benchmark results.</p>
<p class="mce-root">Our benchmark results are provided here. As you can see, the test ran for 8 minutes and 8 seconds:</p>
<div class="mce-root1"><img src="Images/fccf36e9-565b-4d8b-a090-3a168879b908.png" width="660" height="299" class="calibre123"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Benchmarking options</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous section, you learned how to run a benchmark test. In this section, we will look at the following configurable options for running our benchmarks:</p>
<ul class="calibre13">
<li class="calibre14">Modes</li>
<li class="calibre14">Time units</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Modes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The output of our benchmark results, from the previous section, included a <strong class="calibre8">Mode</strong> column that had the value of <strong class="calibre8">thrpt</strong> which is short for <strong class="calibre8">throughput</strong>. This is the default mode and there are an additional four modes. All JMH benchmark modes are listed and described as follows:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Mode</strong></td>
<td class="calibre33"><strong class="calibre3">Description</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">All</td>
<td class="calibre33">Measures all other modes inclusively.</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Average</td>
<td class="calibre33">This mode measures the average time for a single benchmark to run.</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sample Time</td>
<td class="calibre33">This mode measures the benchmark execution time and includes min and max times.</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Single Shot Time</td>
<td class="calibre33">With this mode, there is no JVM warm up and the test is to determine how long a single benchmark method takes to run.</td>
</tr>
<tr class="calibre35">
<td class="calibre33">Throughput</td>
<td class="calibre33">This is the default mode and measures the number of operations per second the benchmark could be run.</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">To dictate which benchmark mode to use, you will modify your <kbd class="calibre16">@Benchmark</kbd> line of code to one of the following:</p>
<pre class="calibre21">    @Benchmark @BenchmarkMode(Mode.All)<br class="calibre2"/>    @Benchmark @BenchmarkMode(Mode.Average)<br class="calibre2"/>    @Benchmark @BenchmarkMode(Mode.SamplmeTime)<br class="calibre2"/>    @Benchmark @BenchmarkMode(Mode.SingleShotTime)<br class="calibre2"/>    @Benchmark @BenchmarkMode(Mode.Throughput)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Time units</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In order to gain greater fidelity in benchmark output, we can designate a specific unit of time, listed here from shortest to longest:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">NANOSECONDS</kbd></li>
<li class="calibre14"><kbd class="calibre16">MICROSECONDS</kbd></li>
<li class="calibre14"><kbd class="calibre16">MILLISECONDS</kbd></li>
<li class="calibre14"><kbd class="calibre16">SECONDS</kbd></li>
<li class="calibre14"><kbd class="calibre16">MINUTES</kbd></li>
<li class="calibre14"><kbd class="calibre16">HOURS</kbd></li>
<li class="calibre14"><kbd class="calibre16">DAYS</kbd></li>
</ul>
<p class="mce-root">In order to make this designation, we simply add the following code to our <kbd class="calibre16">@Benchmark</kbd> line:</p>
<pre class="calibre21">    @Benchmark @BenchmarkMode(Mode.Average) <br class="calibre2"/>    @OutputTimeUnit(TimeUnit.NANOSECONDS)</pre>
<p class="mce-root">In the preceding example, we have designated the average mode and nanoseconds as the time unit.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Techniques for avoiding microbenchmarking pitfalls</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Microbenchmarking is not something that every developer will have to worry about, but for those that do, there are several pitfalls that you should be aware of. In this section we will review the most common pitfalls and suggest strategies for avoiding them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Power management</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are many subsystems that can be used to help you manage the balance between power and performance (that is, <kbd class="calibre16">cpufreq</kbd>). These systems can alter the state of time during benchmarks.</p>
<p class="mce-root">There are two suggested strategies to this pitfall:</p>
<ul class="calibre13">
<li class="calibre14">Disable any power management systems before running tests</li>
<li class="calibre14">Run the benchmarks for longer periods</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">OS schedulers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Operating system schedulers, such as Solaris schedulers, help determine which software processes gain access to a system's resources. Use of these schedulers can result in unreliable benchmarking results.</p>
<p class="mce-root">There are two suggested strategies to this pitfall:</p>
<ul class="calibre13">
<li class="calibre14">Refine your system scheduling policies</li>
<li class="calibre14">Run the benchmarks for longer periods</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Time sharing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Time-sharing systems are used to help balance system resources. Use of these systems often results in irregular gaps between a thread's start and stop time. Also, CPU load will not be uniform and our benchmarking data will not be as useful to us.</p>
<p class="mce-root">There are two suggested strategies to avoid this pitfall:</p>
<ul class="calibre13">
<li class="calibre14">Test all code before running benchmarks to ensure things work as they should</li>
<li class="calibre14">Use JMH to measure only after all threads have started or all threads have stopped</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Eliminating dead-code and constant folding</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Dead-code and constant folding are often referred to as redundant code and our modern compilers are pretty good at eliminating them. An example of dead-code is code that will never be reached. Consider the following example:</p>
<pre class="calibre21">    . . . <br class="calibre2"/><br class="calibre2"/>    int value = 10;<br class="calibre2"/><br class="calibre2"/>    if (value != null)<br class="calibre2"/>    {<br class="calibre2"/>      System.out.println("The value is " + value + ".");<br class="calibre2"/>    } else <br class="calibre2"/>      {<br class="calibre2"/>         System.out.println("The value is null."); // This is<br class="calibre2"/>         a line of Dead-Code<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    . . . </pre>
<p class="mce-root">In our preceding example, the line identified as dead-code is never reached since the variable value will never be equal to null. It is set to <kbd class="calibre16">10</kbd> immediately before the conditional <kbd class="calibre16">if</kbd> statement evaluates the variable.</p>
<p class="mce-root">The problem is that benchmarking code can sometimes be removed in the attempt to eliminate dead-code.</p>
<p class="mce-root">Constant folding is the compiler operation that occurs when compile-time constraints are replaced with actual results. The compiler performs constant folding to remove any redundant runtime computations. In the following example, we have a <kbd class="calibre16">final int</kbd> followed by a second <kbd class="calibre16">int</kbd> based on a mathematical calculation involving the first <kbd class="calibre16">int</kbd>:</p>
<pre class="calibre21">    . . . <br class="calibre2"/><br class="calibre2"/>    static final int value = 10;<br class="calibre2"/><br class="calibre2"/>    int newValue = 319 * value;<br class="calibre2"/><br class="calibre2"/>    . . . </pre>
<p class="mce-root">The constant folding operation would convert the two lines of the preceding code to the following:</p>
<pre class="calibre21">    int newValue = 3190;</pre>
<p class="mce-root">There is one suggested strategy to this pitfall:</p>
<ul class="calibre13">
<li class="calibre14">Use the JMH API support to ensure your benchmarking code is not eliminated</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Run-to-run variance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are a plethora of issues that can drastically impact the run-to-run variance in benchmarking.</p>
<p class="mce-root">There are two suggested strategies to this pitfall:</p>
<ul class="calibre13">
<li class="calibre14">Run the JVM multiple times within every subsystem</li>
<li class="calibre14">Use multiple JMH folks</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Cache capacity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre8">Dynamic randomly accessed memory</strong> (<strong class="calibre8">DRAM</strong>) is very slow. This can result in very different performance results during benchmarking.</p>
<p class="mce-root">There are two suggested strategies to this pitfall:</p>
<ul class="calibre13">
<li class="calibre14">Run multiple benchmarks with varying problem sets. Keep track of your memory footprint during tests.</li>
<li class="calibre14">Use the <kbd class="calibre16">@State</kbd> annotation to dictate the JMH state. This annotation is sued to define the instance's scope. There are three states:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">Scope.Benchmark</kbd>: The instance is shared across all threads that are running the same test.</li>
<li class="calibre14"><kbd class="calibre16">Scope.Group</kbd>: One instance is allocated per thread group.</li>
<li class="calibre14"><kbd class="calibre16">Scope.Thread</kbd>: Each thread will have its own instance. This is the default state.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we <span class="calibre7">learned</span> that <span class="calibre7">the JMH is a Java harness library for writing benchmarks for the JVM. We experimented <span class="calibre7">with writing performance tests using</span> Maven along with JMH to help illustrate the procedures of microbenchmarking with the new Java 9 platform. We started with a</span> <span class="calibre7">microbenchmarking overview, then dove deep into</span> <span class="calibre7">microbenchmarking with Maven, reviewed</span> <span class="calibre7">benchmarking options, and concluded with a few t</span><span class="calibre7">echniques for avoiding microbenchmarking pitfalls.</span></p>
<p class="mce-root">In the next chapter, we will learn to write an application that is managing other processes and utilizes the modern process management API of the Java 9 platform.</p>


            </article>

            
        </section>
    </div>



  </body></html>