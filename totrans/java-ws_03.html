<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer031">
			</div>
		</div>
		<div class="Content" id="_idContainer032">
			<h1 id="_idParaDest-71"><a id="_idTextAnchor069"/>3. Object-Oriented Programming</h1>
		</div>
		<div class="Content" id="_idContainer044">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will consider the way in which Java implements <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) concepts. For these purposes, you will first practice creating and instantiating your own classes so that you can later create methods that can handle data within them. We will then take you through how to code recursive methods, and even how to override existing methods in favor of your own. By the end of the chapter, you will be fully equipped to overload the definition of methods in order to accommodate different scenarios with different parameters to the same method or constructor, and annotate code to inform the compiler about specific actions that must be taken.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor070"/>Introduction</h1>
			<p>A Java class is a template that is used to define data types. Classes are composed of objects carrying data and methods that are used to perform operations on that data. Classes can be self-contained, extend other classes with new functionalities, or implement features from other classes. In a way, classes are categories that allow us to define what kind of data can be stored within them, as well as the ways in which that data can be handled.</p>
			<p>Classes tell the compiler how to build a certain object during runtime. Refer to the explanation of what objects are in the <em class="italic">Working with Objects in Java</em> topic.</p>
			<p>The basic structure of a class definition looks like this:</p>
			<p class="source-code">class &lt;name&gt; {</p>
			<p class="source-code">    fields;</p>
			<p class="source-code">    methods;</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Class names should start with a capital letter, as in <strong class="source-inline">TheClass</strong>, <strong class="source-inline">Animal</strong>, <strong class="source-inline">WordCount</strong>, or any other string that somehow expresses the main purpose of the class. If contained in a separate file, the filename containing the source should be named like the class: <strong class="source-inline">TheClass.java</strong>, <strong class="source-inline">Animal.java</strong>, and so on.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor071"/>The Anatomy of a Class</h2>
			<p>There are different software components in classes. The following example shows a class that includes some of the main ones. </p>
			<p class="source-code-heading">Example01.java</p>
			<p class="source-code">1  class Computer {</p>
			<p class="source-code">2      // variables</p>
			<p class="source-code">3      double cpuSpeed;  // in GHz</p>
			<p class="source-code">4  </p>
			<p class="source-code">5      // constructor</p>
			<p class="source-code">6      Computer() {</p>
			<p class="source-code">7          cpuSpeed = 0;</p>
			<p class="source-code">8      }</p>
			<p class="source-code">9  </p>
			<p class="source-code">10     //methods</p>
			<p class="source-code">11     void setCpuSpeed ( double _cpuSpeed ) {</p>
			<p class="source-code">12         cpuSpeed = _cpuSpeed;</p>
			<p class="source-code">13     }</p>
			<p class="source-code-link"><a href="https://packt.live/32w1ffg">https://packt.live/32w1ffg</a></p>
			<p>The outcome of this example is:</p>
			<p class="source-code">2.5</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The previous code listing shows the definition of a basic class called <strong class="source-inline">Computer</strong>, which includes variables and methods to deal with one of the properties of the class computer – in this case, <strong class="source-inline">cpuSpeed</strong>. The code shows two different classes. The first one is the blueprint for how to define objects of the <strong class="source-inline">Computer</strong> type in your programs. The second one, <strong class="source-inline">Example01</strong>, is the one that will be executed after compilation and will make an instance of the <strong class="source-inline">Computer</strong> class in the form of an object called <strong class="source-inline">myPC</strong>. </p>
			<p>There is one more component inside the class, the constructor, which is optional, as Java includes a default constructor for all your classes. <strong class="bold">Constructors</strong> are used to initializing the basic properties of classes, and so are used when assigning values to variables, for instance. In our case, the operation performed by the constructor is initializing the <strong class="source-inline">cpuSpeed</strong> variable with a value of <strong class="source-inline">0</strong>:</p>
			<p class="source-code">// constructor</p>
			<p class="source-code">Computer() {</p>
			<p class="source-code">    cpuSpeed = 0;</p>
			<p class="source-code">}</p>
			<p>It is also possible for constructors to have parameters. You could have the constructor of the class be this:</p>
			<p class="source-code">// constructor</p>
			<p class="source-code">Computer( double _c ) {</p>
			<p class="source-code">    cpuSpeed = _c;</p>
			<p class="source-code">}</p>
			<p>In this way, you could call the constructor with:</p>
			<p class="source-code">Computer myPC = new Computer( 2.5 );</p>
			<p>That would also require a parameter. In addition, classes can have more than one constructor. This will be explained later in the chapter.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor072"/>Working with Objects in Java</h1>
			<p>Objects are to classes what variables are to data types. While classes define the structure and possible actions of a certain data type, objects are actual usable parts of the computer memory containing that data. The action of creating an object is known as making an instance of a class. In a sense, it is like making a copy of the template and then modifying it by accessing its variables or methods. Let's see this in action:</p>
			<p class="source-code">Computer myPC = new Computer( 2.5 );</p>
			<p><strong class="source-inline">myPC</strong> is the actual object. We would say that <strong class="source-inline">myPC</strong> is an object of the <strong class="source-inline">class Computer</strong> in colloquial terms.</p>
			<p>The different fields and methods inside the class can be accessed by typing the name of the object followed by a period and the name of the variable or method you want to address. Making any changes to the variables or calling the methods will take effect only within the scope of that object. If you had more objects of the same class in your program, each one of them would have a piece of memory of its own. An example of how to address a method is as follows:</p>
			<p class="source-code">myPC.setCpuSpeed( 2.5 );</p>
			<p>An example of how to address a variable, on the other hand, would be the following assignment:</p>
			<p class="source-code">myPC.cpuSpeed = 2.5;</p>
			<p>Because of the way the <strong class="source-inline">Computer</strong> class has been defined, the last two code listings have the exact same effect. The whole class has been defined—by default—as <strong class="source-inline">public</strong>, which means that all the methods, variables, and objects from the class are available to be called with the mechanism described previously. It could be necessary to prevent users from directly interacting with the variables within the class and only allow their modification through certain methods. </p>
			<p>The different components within a class can be defined as <strong class="source-inline">public</strong> or <strong class="source-inline">private</strong>. The former will make the component available to be used as shown so far, while the latter will hinder the ability of other developers to access that part. The following example shows how to make the <strong class="source-inline">cpuSpeed</strong> variable <strong class="source-inline">private</strong>:</p>
			<p class="source-code-heading">Example02.java</p>
			<p class="source-code">1  class Computer {</p>
			<p class="source-code">2      // variables</p>
			<p class="source-code">3      private double cpuSpeed;  // in GHz</p>
			<p class="source-code">4  </p>
			<p class="source-code">5      // constructor</p>
			<p class="source-code">6      Computer() {</p>
			<p class="source-code">7          cpuSpeed = 0;</p>
			<p class="source-code">8      }</p>
			<p class="source-code">9  </p>
			<p class="source-code">10     // methods</p>
			<p class="source-code">11     void setCpuSpeed ( double _cpuSpeed ) {</p>
			<p class="source-code">12         cpuSpeed = _cpuSpeed;</p>
			<p class="source-code">13     }</p>
			<p class="source-code">14 </p>
			<p class="source-code">15     double getCpuSpeed () {</p>
			<p class="source-code">16         return cpuSpeed;</p>
			<p class="source-code">17     }</p>
			<p class="source-code">18 }</p>
			<p class="source-code-link"><a href="https://packt.live/2pBgWTS">https://packt.live/2pBgWTS</a></p>
			<p>The result of this code listing is the same as before:</p>
			<p class="source-code">2.5</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>If you tried to access the <strong class="source-inline">cpuSpeed</strong> variable directly from the <strong class="source-inline">Example02</strong> class, the program would throw an exception. The following example shows such a case. Try it out to see how the debugger informs you when you try to access a <strong class="source-inline">private</strong> variable:</p>
			<p class="source-code-heading">Example03.java</p>
			<p class="source-code">20 public class Example03 {</p>
			<p class="source-code">21     public static void main(String[] args) {</p>
			<p class="source-code">22         Computer myPC = new Computer();</p>
			<p class="source-code">23         myPC.setCpuSpeed( 2.5 );</p>
			<p class="source-code">24         System.out.println( myPC.cpuSpeed );</p>
			<p class="source-code">25     }</p>
			<p class="source-code">26 }</p>
			<p class="source-code-link"><a href="https://packt.live/2pvLu9Q">https://packt.live/2pvLu9Q</a></p>
			<p>The result of this program is:</p>
			<p class="source-code">Example03.java:23: error: cpuSpeed has private access in Computer</p>
			<p class="source-code">        System.out.println( myPC.cpuSpeed );</p>
			<p class="source-code">1 error</p>
			<p class="source-code">Process finished with exit code 1.</p>
			<p>What the compiler shows is an error in the <strong class="source-inline">Computer</strong> class, which has been derived from <strong class="source-inline">java.lang</strong>.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor073"/>Checking the Precedence of a Class with instanceof</h1>
			<p>You can check whether an object is an instance of a specific class. This can be convenient for things such as error checking, handling data in different ways depending on its precedence, and more. The following example shows the <strong class="source-inline">checkNumber</strong> method, which can discriminate between different types of variables and will print different messages based on that:</p>
			<p class="source-code">public class Example04 {</p>
			<p class="source-code">    public static void checkNumber(Number val) {</p>
			<p class="source-code">        if( val instanceof Integer )</p>
			<p class="source-code">            System.out.println("it is an Integer");</p>
			<p class="source-code">        if( val instanceof Double )</p>
			<p class="source-code">            System.out.println("it is a Double");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        int val1 = 3;</p>
			<p class="source-code">        double val2 = 2.7;</p>
			<p class="source-code">        checkNumber( val1 );</p>
			<p class="source-code">        checkNumber( val2 );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The outcome of the previous example is:</p>
			<p class="source-code">it is an Integer</p>
			<p class="source-code">it is a Double</p>
			<p class="source-code">Process finished with exit code 0</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor074"/>Exercise 1: Creating the WordTool Class</h2>
			<p><strong class="source-inline">WordTool</strong> is a class that will help you to perform a series of operations on a piece of text, including counting the number of words, looking at the frequency of letters, and searching for the occurrence of a specific string:</p>
			<ol>
				<li>Open IntelliJ and click on the <strong class="source-inline">File</strong> | <strong class="source-inline">New</strong> | <strong class="source-inline">Project</strong> menu options:<div class="IMG---Figure" id="_idContainer033"><img alt="Figure 3.1: Creating a new project&#13;&#10;" src="image/C13927_03_01.jpg"/></div><p class="figure-caption">Figure 3.1: Creating a new project</p></li>
				<li>A new interface unfolds. The default options are meant for creating a Java program. You just need to click <strong class="source-inline">Next</strong>:<div class="IMG---Figure" id="_idContainer034"><img alt="Figure 3.2: The New Project dialog box&#13;&#10;" src="image/C13927_03_02.jpg"/></div><p class="figure-caption">Figure 3.2: The New Project dialog box</p></li>
				<li>Check the box to create the project from a template. Select the template for the <strong class="source-inline">Command Line App</strong>. Click <strong class="source-inline">Next</strong>:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 3.3: Creating a project from template &#13;&#10;" src="image/C13927_03_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3: Creating a project from template </p>
			<p>Name the project <strong class="source-inline">WordTool</strong>. Click <strong class="source-inline">Finish</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer036">
					<img alt="Figure 3.4: Adding the Project name&#13;&#10;" src="image/C13927_03_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4: Adding the Project name</p>
			<ol>
				<li value="1">By default, the template calls your basic class <strong class="source-inline">Main</strong>. Let's change that to <strong class="source-inline">WordTool</strong>. First, navigate within the new project to the <strong class="source-inline">Main.java</strong> file; it is displayed as the <strong class="source-inline">main</strong> entry in the list:<div class="IMG---Figure" id="_idContainer037"><img alt="Figure 3.5: A template Java program&#13;&#10;" src="image/C13927_03_05.jpg"/></div><p class="figure-caption">Figure 3.5: A template Java program</p></li>
				<li>Right-click on the <strong class="source-inline">Main</strong> entry and, in the drop-down list, select the <strong class="source-inline">Refactor</strong> option. Within that, select <strong class="source-inline">Rename…</strong>:<div class="IMG---Figure" id="_idContainer038"><img alt="Figure 3.6: Refactoring the Java class&#13;&#10;" src="image/C13927_03_06.jpg"/></div><p class="figure-caption">Figure 3.6: Refactoring the Java class</p></li>
				<li>A dialog window pops up. Write in it the name of the class, <strong class="source-inline">WordTool</strong>. The checkboxes allow you to choose which parts of the code will be refactored to fit the new name of the class:<div class="IMG---Figure" id="_idContainer039"><img alt="Figure 3.7: Renaming the class in IntelliJ&#13;&#10;" src="image/C13927_03_07.jpg"/></div><p class="figure-caption">Figure 3.7: Renaming the class in IntelliJ</p></li>
				<li>You will see that the class is now called <strong class="source-inline">WordTool</strong> and the file is <strong class="source-inline">WordTool.java</strong>:<div class="IMG---Figure" id="_idContainer040"><img alt="Figure 3.8: WordTool &#13;&#10;&#13;&#10;" src="image/C13927_03_08.jpg"/></div><p class="figure-caption">Figure 3.8: WordTool </p></li>
				<li>Create the constructor for the class; it will be empty, in this case:<p class="source-code">WordTool() {};</p></li>
				<li>Add a method to count the number of words in a string:<p class="source-code">    public int wordCount ( String s ) {</p><p class="source-code">        int count = 0;    // variable to count words</p><p class="source-code">        // if the entry is empty or is null, count is zero</p><p class="source-code">        // therefore we evaluate it only otherwise</p><p class="source-code">        if ( !(s == null || s.isEmpty()) ) {</p><p class="source-code">            // use the split method from the String class to</p><p class="source-code">            // separate the words having the whitespace as separator</p><p class="source-code">            String[] w = s.split("\\s+");</p><p class="source-code">            count = w.length;</p><p class="source-code">        }</p><p class="source-code">        return count;</p><p class="source-code">    }</p></li>
				<li>Add a method to count the number of letters in a string, and add the ability to count both with and without whitespace characters:<p class="source-code">    public int symbolCount ( String s, boolean withSpaces ) {</p><p class="source-code">        int count = 0;  // variable to count symbols</p><p class="source-code">        // if the entry is empty or is null, count is zero</p><p class="source-code">        // therefore we evaluate it only otherwise</p><p class="source-code">        if ( !(s == null || s.isEmpty()) ) {</p><p class="source-code">            if (withSpaces) {</p><p class="source-code">                // with whitespaces return the full length</p><p class="source-code">                count = s.length();</p><p class="source-code">            } else {</p><p class="source-code">                // without whitespaces, eliminate whitespaces</p><p class="source-code">                // and get the length on the fly</p><p class="source-code">                count = s.replace(" ", "").length();</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        return count;</p><p class="source-code">    }</p></li>
				<li>In the <strong class="source-inline">main</strong> class, create an object of the <strong class="source-inline">WordTool</strong> class and add a <strong class="source-inline">String</strong> variable containing some text of your choice:<p class="source-code">WordTool wt = new WordTool();</p><p class="source-code">String text = "The river carried the memories from her childhood.";</p></li>
				<li>Add code inside the main method to print out the calculations made by <strong class="source-inline">WordTool</strong>:<p class="source-code">System.out.println( "Analyzing the text: \n" + text );</p><p class="source-code">System.out.println( "Total words: " + wt.wordCount(text) );</p><p class="source-code">System.out.println( "Total symbols (w. spaces): " + wt.symbolCount(text, true) );</p><p class="source-code">System.out.println( "Total symbols (wo. spaces): " + wt.symbolCount(text, false) );</p></li>
				<li>Run the program; the outcome should be as follows:<p class="source-code">Analyzing the text: </p><p class="source-code">The river carried the memories from her childhood.</p><p class="source-code">Total words: 8</p><p class="source-code">Total symbols (w. spaces): 50</p><p class="source-code">Total symbols (wo. spaces): 43</p><p class="source-code">Process finished with exit code 0</p><p class="callout-heading">Note</p><p class="callout">You can use the trick presented in this exercise to create classes for all the examples in this book, just by using the template and refactoring them to have the example name. After that, you will just need to copy the code in a fresh project.</p></li>
			</ol>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor075"/>Activity 1: Adding the Frequency-of-Symbol Calculation to WordTool</h2>
			<p>Add a method to the previously created <strong class="source-inline">WordTool</strong> class to calculate the frequency of a certain symbol. To do so, perform the following steps:</p>
			<ol>
				<li value="1">Add a method to count the number of words in a string.</li>
				<li>Add a method to count the number of letters in a string, and add the possibility of separating the case of having whitespaces or not.</li>
				<li>In the <strong class="source-inline">main</strong> class, create an object of the <strong class="source-inline">WordTool</strong> class and add a string variable containing a line of text of your choice.</li>
				<li>Add code inside the main method to print out the calculations made by WordTool.<p>The expected outcome of this activity is as follows:</p><p class="source-code">Analyzing the text: </p><p class="source-code">The river carried the memories from her childhood.</p><p class="source-code">Total words: 8</p><p class="source-code">Total symbols (w. spaces): 50</p><p class="source-code">Total symbols (wo. spaces): 43</p><p class="source-code">Total amount of e: 7</p><p class="source-code">Process finished with exit code 0</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 534.</p></li>
			</ol>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor076"/>Inheritance in Java</h1>
			<p>Inheritance is a key principle of object-oriented programming. It entails the transfer of the existing structure of one class, including its constructor, variables, and methods, to a different class. The new class is called the child class (or subclass), while the one it's inheriting from is called the parent class (or superclass). We say that the child class extends the parent one. The child class is said to extend the parent class in the sense that it not only inherits whatever structures are defined by the parent, but it also creates new structures. The following example shows a parent class and how the child class extends it by adding a new method to it. We will take the <strong class="source-inline">Computer</strong> class we defined earlier as a parent and create a new class called <strong class="source-inline">Tablet</strong>, which is a type of computer.</p>
			<p class="source-code-heading">Example05.java</p>
			<p class="source-code">20 class Tablet extends Computer {</p>
			<p class="source-code">21     // variables</p>
			<p class="source-code">22     private double screenSize;  // in inches</p>
			<p class="source-code">23 </p>
			<p class="source-code">24     // methods</p>
			<p class="source-code">25     void setScreenSize ( double _screenSize ) {</p>
			<p class="source-code">26         screenSize = _screenSize;</p>
			<p class="source-code">27     }</p>
			<p class="source-code">28 </p>
			<p class="source-code">29     double getScreenSize () {</p>
			<p class="source-code">30         return screenSize;</p>
			<p class="source-code">31     }</p>
			<p class="source-code">32 }</p>
			<p class="source-code">33 </p>
			<p class="source-code">34 public class Example05 {</p>
			<p class="source-code">35     public static void main(String[] args) {</p>
			<p class="source-code">36         Tablet myTab = new Tablet();</p>
			<p class="source-code">37         myTab.setCpuSpeed( 2.5 );</p>
			<p class="source-code">38         myTab.setScreenSize( 10 );</p>
			<p class="source-code">39         System.out.println( myTab.getCpuSpeed() );</p>
			<p class="source-code">40         System.out.println( myTab.getScreenSize() );</p>
			<p class="source-code">41     }</p>
			<p class="source-code">42 }</p>
			<p class="source-code-link"><a href="https://packt.live/2o3NaqE">https://packt.live/2o3NaqE</a></p>
			<p>Notice how the definition of the <strong class="source-inline">Tablet</strong> class does not include any methods called <strong class="source-inline">setCpuSpeed()</strong> or <strong class="source-inline">getCpuSpeed()</strong>; however, when calling them, not only does the program not give any errors, but the commands are also successfully launched.</p>
			<p>This is because the definition of the <strong class="source-inline">Tablet</strong> class extends the <strong class="source-inline">Computer</strong> class, thus inheriting all its internal objects, variables, and methods. When creating an object of the <strong class="source-inline">Tablet</strong> class, such as <strong class="source-inline">myTab</strong>, the JVM reserves space in memory for a <strong class="source-inline">cpuSpeed</strong> variable and the setter and getter methods that go with it.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor077"/>Overriding and Hiding Methods</h1>
			<p>When extending a class, it is possible to redefine some of the methods that are part of it. Overriding means to rewrite something's functionality. This is done by making a new declaration of the method with the same name and properties of the method from the original class. This is demonstrated in the following example. Note that we're continuing, for the sake of clarity, with <strong class="source-inline">Computer</strong> and <strong class="source-inline">Tablet</strong>, but they have been cleaned up so as not to make the example programs too long.</p>
			<p class="source-code">class Computer {</p>
			<p class="source-code">    public void whatIsIt() {</p>
			<p class="source-code">        System.out.println( "it is a PC");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Tablet extends Computer {</p>
			<p class="source-code">    public void whatIsIt() {</p>
			<p class="source-code">        System.out.println( "it is a tablet");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example06 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Tablet myTab = new Tablet();</p>
			<p class="source-code">        myTab.whatIsIt();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Since <strong class="source-inline">Tablet</strong> extends <strong class="source-inline">Computer</strong>, you could modify the main class in the program to be as follows:</p>
			<p class="source-code">class Example06 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Computer myTab = new Tablet();</p>
			<p class="source-code">        myTab.whatIsIt();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Technically, tablets are computers, which means that you can create an object of the <strong class="source-inline">Tablet</strong> class by defining it as <strong class="source-inline">Computer</strong> in the first place. The result for both cases will be the same:</p>
			<p class="source-code">it is a tablet</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The result is the same for both classes because both the child and parent classes include a non-static method called <strong class="source-inline">whatIsIt()</strong>. When calling the method, the overriding one will have priority. This is done by the JVM at runtime. This principle is what we call runtime polymorphism. There can be multiple definitions of the same method, and which definition will be executed is decided during the execution of the program. </p>
			<p>But what would happen if the method you called was static? This could be a design decision taken by the developer who is creating the class you are extending and therefore is a situation out of your control. In this case, it is not possible to override the method. The child class can, however, hide the method defined by the parent using the same mechanism. The next code listing demonstrates this.</p>
			<p class="source-code">class Computer {</p>
			<p class="source-code">    public static void whatIsIt() {</p>
			<p class="source-code">        System.out.println( "it is a PC");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Tablet extends Computer {</p>
			<p class="source-code">    public static void whatIsIt() {</p>
			<p class="source-code">        System.out.println( "it is a tablet");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example07 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Computer myTab = new Tablet();</p>
			<p class="source-code">        myTab.whatIsIt();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The outcome of this example is:</p>
			<p class="source-code">it is a PC</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The decision of what method should be used with static methods is not taken at runtime but during compilation, and this ensures that the method from the parent class is the one being called. This action is called <strong class="bold">hiding instead of overriding</strong>. It is still possible to call the method in the <strong class="source-inline">Tablet</strong> class. To do so, you should modify the code in the <strong class="source-inline">main</strong> class to the following:</p>
			<p class="source-code">class Example07 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Computer myTab = new Tablet();</p>
			<p class="source-code">        Tablet.whatIsIt();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Note how we clearly specify the actual class you call for this. The result of the modified example is:</p>
			<p class="source-code">it is a tablet</p>
			<p class="source-code">Process finished with exit code 0</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor078"/>Avoiding Overriding: Final Classes and Methods</h2>
			<p>If you want to stop other developers from overriding parts of your class, you can declare the methods you want to protect as <strong class="source-inline">final</strong>. An example of this could be a class that deals with temperature. The method that converts from Celsius into Fahrenheit is final, as it makes no sense to override such a method.</p>
			<p class="source-code">class Temperature {</p>
			<p class="source-code">    public double t = 25;</p>
			<p class="source-code">    public double getCelsius() {</p>
			<p class="source-code">        return t;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    final public double getFahrenheit() {</p>
			<p class="source-code">        return t * 9/5 + 32;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example08 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Temperature temp = new Temperature();</p>
			<p class="source-code">        System.out.println( temp.getCelsius() );</p>
			<p class="source-code">        System.out.println( temp.getFahrenheit() );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This program will give this result:</p>
			<p class="source-code">25.0</p>
			<p class="source-code">77.0</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Alternatively, you can declare a whole class <strong class="source-inline">final</strong>. A <strong class="source-inline">final</strong> class cannot be extended. An example of such a class is <strong class="source-inline">String</strong>. You could ask whether it defeats the purpose of object-oriented programming to have a class that cannot be extended. But there are some classes that are so fundamental to the programming language, such as <strong class="source-inline">String</strong>, that they are better kept as they are.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor079"/>Overloading Methods and Constructors</h1>
			<p>One very interesting property of Java is how it allows you to define methods that have the same conceptual functionality as each other by using the same name but changing either the type or number of parameters. Let's see how this could work.</p>
			<p class="source-code">class Age {</p>
			<p class="source-code">    public double a = 0;</p>
			<p class="source-code">    public void setAge ( double _a ) {</p>
			<p class="source-code">        a = _a;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void setAge ( int year, int month ) {</p>
			<p class="source-code"><strong class="bold">        a = year + (double) month / 12;</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    public double getAge () {</p>
			<p class="source-code">        return a;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example09 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Age age = new Age();</p>
			<p class="source-code">        age.setAge(12.5);</p>
			<p class="source-code">        System.out.println(age.getAge());</p>
			<p class="source-code">        age.setAge(9, 3);</p>
			<p class="source-code">        System.out.println(age.getAge());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Look at the highlighted portion in the preceding code. As we are taking the integer parameter <strong class="source-inline">month</strong> and dividing it by a number, the result of the operation will be a double. To avoid possible errors, you need to convert the integer into a floating comma number. This process, called casting, is done by adding the new type between brackets in front of the object, variable, or operation we want to convert.</p>
			<p>The result of this example is:</p>
			<p class="source-code">12.5</p>
			<p class="source-code">9.25</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>This shows that both methods modify the <strong class="source-inline">a</strong> variable in the <strong class="source-inline">Age</strong> class by taking different sets of parameters. This same mechanism for having conceptually equivalent results from different blocks of code can be used for the constructors of a class, as shown in the following example.</p>
			<p class="source-code">class Age {</p>
			<p class="source-code">    public double a = 0;</p>
			<p class="source-code">    Age ( double _a ) {</p>
			<p class="source-code">        a = _a;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    Age ( int year, int month ) {</p>
			<p class="source-code">        a = year + (double) month / 12;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public double getAge () {</p>
			<p class="source-code">        return a;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example10 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Age age1 = new Age(12.5);</p>
			<p class="source-code">        Age age2 = new Age(9, 3);</p>
			<p class="source-code">        System.out.println(age1.getAge());</p>
			<p class="source-code">        System.out.println(age2.getAge());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this case, as a way to show the functionality, instead of instantiating a single object and calling the different methods to modify its variables, we had to create two different objects, <strong class="source-inline">age1</strong> and <strong class="source-inline">age2</strong>, with one or two parameters, as those are the possible options offered by the constructors available in the <strong class="source-inline">Age</strong> class.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor080"/>Recursion</h1>
			<p>Programming languages allow the usage of certain mechanisms to simplify solving a problem. Recursion is one of those mechanisms. It is the ability of a method to call itself. When properly designed, a recursive method can simplify the way a solution to a certain problem is expressed using code.</p>
			<p>Classic examples in recursion include the computation of the factorial of a number or the sorting of an array of numbers. For the sake of simplicity, we are going to look at the first case: finding the factorial of a number.</p>
			<p class="source-code">class Example11 {</p>
			<p class="source-code">    public static long fact ( int n ) {</p>
			<p class="source-code">        if ( n == 1 ) return 1;</p>
			<p class="source-code">        return n * fact ( n – 1 );</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        int input = Integer.parseInt(args[0]);</p>
			<p class="source-code">        long factorial = fact ( input );</p>
			<p class="source-code">        System.out.println(factorial);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>To run this code, you will need to go to the terminal and call the example from there with <strong class="source-inline">java Example11 m</strong>, where <strong class="source-inline">m</strong> is the integer whose factorial will be calculated. Depending on where you created the project on your computer, it could look like this (note that we have shortened the path to the example to keep it clean):</p>
			<p class="source-code">usr@localhost:~/IdeaProjects/chapter03/[...]production/Example11$ java Example11 5</p>
			<p class="source-code">120</p>
			<p>Or, it could look like this:</p>
			<p class="source-code">usr@localhost:~/IdeaProjects/chapter03/[...]production/Example11$ java Example11 3</p>
			<p class="source-code">6</p>
			<p>The result of the call is the factorial: <strong class="source-inline">120</strong> is the factorial of <strong class="source-inline">5</strong>, and <strong class="source-inline">6</strong> is the factorial of <strong class="source-inline">3</strong>.</p>
			<p>While it might not seem so intuitive at first sight, the <strong class="source-inline">fact</strong> method calls itself in the return line. Let's take a closer look at this:</p>
			<p class="source-code">public static long fact ( int n ) {</p>
			<p class="source-code">    if ( n == 1 ) return 1;</p>
			<p class="source-code">    return n * fact ( n – 1 );</p>
			<p class="source-code">}</p>
			<p>There are a couple of conditions that you need to meet when designing a functional recursive method. Otherwise, the recursive method will not converge to anything:</p>
			<ol>
				<li value="1">There needs to be a base condition. This means you need something that will stop the recursion from happening. In the case of the <strong class="source-inline">fact</strong> method, the base condition is <strong class="source-inline">n</strong> being equal to 1:<p class="source-code">if ( n == 1 ) return 1;</p></li>
				<li>There needs to be a way to computationally reach the base condition after a certain number of steps. In our case, every time we call fact, we do it with a parameter that is one unit smaller than the parameter of the current call to the method:<p class="source-code">return n * fact ( n – 1 );</p></li>
			</ol>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor081"/>Annotations</h1>
			<p>Annotations are a special type of metadata that can be added to your code to inform the compiler about relevant aspects of it. Annotations can be used during the declaration of classes, fields, methods, variables, and parameters. One interesting aspect of annotations is that they remain visible inside classes, indicating whether a method is an override to a different one from a parent class, for example.</p>
			<p>Annotations are declared using the <strong class="source-inline">@</strong> symbol followed by the annotation's name. There are some built-in annotations, but it is also possible to declare your own. At this point, it is important to focus on some of the built-in ones, as it will help you to understand some of the concepts presented so far in this chapter</p>
			<p>The most relevant built-in annotations are <strong class="source-inline">@Override</strong>, <strong class="source-inline">@Deprecated</strong>, and <strong class="source-inline">@Suppres<a id="_idTextAnchor082"/>sWarnings</strong>. These three commands inform the compiler about different aspects of the code or the process of producing it.</p>
			<p><strong class="source-inline">@Override</strong> is used to indicate that a method defined in a child class is an override of another one in a parent class. It will check whether the parent class has a method named the same as the one in the child class and will provoke a compilation error if it doesn't exist. The use of this annotation is displayed in the following example, which builds on the code we showcased earlier in the chapter about the <strong class="source-inline">Tablet</strong> class extending the <strong class="source-inline">Computer</strong> class.</p>
			<p class="source-code">class Computer {</p>
			<p class="source-code">    public void whatIsIt() {</p>
			<p class="source-code">        System.out.println( "it is a PC");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Tablet extends Computer {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void whatIsIt() {</p>
			<p class="source-code">        System.out.println( "it is a tablet");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example12 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Tablet myTab = new Tablet();</p>
			<p class="source-code">        myTab.whatIsIt();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">@Deprecated</strong> indicates that the method is about to become obsolete. This typically means that it will be removed in a future version of the class. As Java is a living language, it is common for core classes to be revised and new methods to be produced, and for the functionality of others to cease being relevant and get deprecated. The following example revisits the previous code listing, if the maintainer of the <strong class="source-inline">Computer</strong> class has decided to rename the <strong class="source-inline">whatIsIt()</strong> method <strong class="source-inline">getDeviceType()</strong>.</p>
			<p class="source-code-heading">Example13.java</p>
			<p class="source-code">1  class Computer {</p>
			<p class="source-code">2      @Deprecated</p>
			<p class="source-code">3      public void whatIsIt() {</p>
			<p class="source-code">4          System.out.println( "it is a PC");</p>
			<p class="source-code">5      }</p>
			<p class="source-code">6  </p>
			<p class="source-code">7      public void getDeviceType() {</p>
			<p class="source-code">8          System.out.println( "it is a PC");</p>
			<p class="source-code">9      }</p>
			<p class="source-code">10 }</p>
			<p class="source-code">11 </p>
			<p class="source-code">12 class Tablet extends Computer {</p>
			<p class="source-code">13     @Override</p>
			<p class="source-code">14     public void whatIsIt() {</p>
			<p class="source-code">15         System.out.println( "it is a tablet");</p>
			<p class="source-code">16     }</p>
			<p class="source-code">17 }</p>
			<p class="source-code-link"><a href="https://packt.live/35NGCgG">https://packt.live/35NGCgG</a></p>
			<p>Calling the compilation of the previous example will issue a warning about the fact that the <strong class="source-inline">whatIsIt()</strong> method will soon be no longer used. This should help developers plan their programs, as they'll know that some methods may disappear in the future: </p>
			<p class="source-code">Warning:(13, 17) java: whatIsIt() in Computer has been deprecated</p>
			<p><strong class="source-inline">@SuppressWarnings</strong> makes the compiler hide the possible warnings that will be defined in the annotation's parameters. It should be mentioned that annotations can have parameters such as <strong class="source-inline">overrides</strong>, <strong class="source-inline">deprecation</strong>, <strong class="source-inline">divzero</strong>, and <strong class="source-inline">all</strong>. There are more types of warnings that can be hidden, but it is too early to introduce them. While we are not going to go deeper into this concept at this point, you can see an example of this in the following code listing.</p>
			<p class="source-code-heading">Example14.java</p>
			<p class="source-code">1  class Computer {</p>
			<p class="source-code">2      @Deprecated</p>
			<p class="source-code">3      public void whatIsIt() {</p>
			<p class="source-code">4          System.out.println( "it is a PC");</p>
			<p class="source-code">5      }</p>
			<p class="source-code">6  </p>
			<p class="source-code">7      public void getDeviceType() {</p>
			<p class="source-code">8          System.out.println( "it is a PC");</p>
			<p class="source-code">9      }</p>
			<p class="source-code">10 }</p>
			<p class="source-code">11 </p>
			<p class="source-code">12 @SuppressWarnings("deprecation")</p>
			<p class="source-code">13 class Tablet extends Computer {</p>
			<p class="source-code">14     @Override</p>
			<p class="source-code">15     public void whatIsIt() {</p>
			<p class="source-code">16         System.out.println( "it is a tablet");</p>
			<p class="source-code">17     }</p>
			<p class="source-code">18 }</p>
			<p class="source-code-link"><a href="https://packt.live/33GKnTt">https://packt.live/33GKnTt</a></p>
			<p>When calling the compilation of the latest example, you will see a difference in comparison to the previous one, as the compilation of this one will not produce any warnings regarding the deprecation of the <strong class="source-inline">whatIsIt()</strong> method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You should be careful when using <strong class="source-inline">@SuppressWarnings</strong> as it can hide risks derived from potential malfunctions of your code. Especially avoid using <strong class="source-inline">@SuppressWarnings("all")</strong>, as it could mask warnings that could be producing runtime errors in other parts of your code.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Interfaces</h1>
			<p>Interfaces are reference types in Java. As such, they define the skeleton of classes and objects but without including the actual functionality of methods. Classes implement interfaces but do not extend them. Let's look at an example of a simple interface, further developing the idea of building classes to represent different types of computers. </p>
			<p class="source-code">interface Computer {</p>
			<p class="source-code">    public String getDeviceType();</p>
			<p class="source-code">    public String getSpeed();  </p>
			<p class="source-code">}</p>
			<p class="source-code">class Tablet implements Computer {</p>
			<p class="source-code">    public String getDeviceType() {</p>
			<p class="source-code">        return "it is a tablet";</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public String getSpeed() {</p>
			<p class="source-code">        return "1GHz";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example15 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Tablet myTab = new Tablet();</p>
			<p class="source-code">        System.out.println( myTab.getDeviceType() );</p>
			<p class="source-code">        System.out.println( myTab.getSpeed() );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you might have guessed, the output for this example is:</p>
			<p class="source-code">it is a tablet</p>
			<p class="source-code">1GHz</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Some relevant notes on interfaces follow: </p>
			<ul>
				<li>Interfaces can extend other interfaces. </li>
				<li>Unlike classes, which can only extend one class at a time, interfaces can extend multiple interfaces at once. You do so by adding the different interfaces separated by commas. </li>
				<li>Interfaces have no constructors. </li>
			</ul>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Inner Classes</h1>
			<p>Classes, as we have seen so far, cannot be hidden to other parts of the program. In code terms, they cannot be made private. To offer this kind of security mechanism, Java developed so-called <strong class="bold">inner classes</strong>. This type of class is declared nested within other classes. A quick example of this follows: </p>
			<p class="source-code-heading">Example16.java</p>
			<p class="source-code">1  class Container {</p>
			<p class="source-code">2      // inner class</p>
			<p class="source-code">3      private class Continent {</p>
			<p class="source-code">4      public void print() {</p>
			<p class="source-code">5              System.out.println("This is an inner class");</p>
			<p class="source-code">6          }</p>
			<p class="source-code">7      }</p>
			<p class="source-code">8  </p>
			<p class="source-code">9      // method to give access to the private inner class' method</p>
			<p class="source-code">10     void printContinent() {</p>
			<p class="source-code">11         Continent continent = new Continent();</p>
			<p class="source-code">12         continent.print();</p>
			<p class="source-code">13     }</p>
			<p class="source-code">14 }</p>
			<p class="source-code-link"><a href="https://packt.live/2P2vc30">https://packt.live/2P2vc30</a></p>
			<p>The result of the previous example is:</p>
			<p class="source-code">This is an inner class</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The previous example is a case of a non-static inner class. There are two more: method-local inner classes (these are defined inside a method) and anonymous classes. There is no big difference in how method-local classes are declared in comparison to what you've seen so far. A method-local inner class's main characteristic is that it is defined only for the scope of that method; it cannot be called by other parts of the program. </p>
			<p>When it comes to anonymous inner classes, they make for an interesting case that deserves to be studied. The reason for their existence is to make code more concise. With anonymous classes, you declare and instantiate the class at the same time. This means that for such a class, only one object is created. Anonymous classes are typically created by extending existing classes or interfaces. Let's look at an example defining one of these specific types of anonymous classes:</p>
			<p class="source-code">class Container {</p>
			<p class="source-code">    int c = 17;</p>
			<p class="source-code">    public void print() {</p>
			<p class="source-code">        System.out.println("This is an outer class");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class Example17 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        // inner class</p>
			<p class="source-code">        Container container = new Container() {</p>
			<p class="source-code">            @Override</p>
			<p class="source-code">            public void print() {</p>
			<p class="source-code">                System.out.println("This is an inner class");</p>
			<p class="source-code">            }</p>
			<p class="source-code">        };</p>
			<p class="source-code">        container.print();</p>
			<p class="source-code">        System.out.println( container.c );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This example shows how an anonymous class can be created in an ad hoc way to override a single method from the original class. This is one of the many possible applications of this type of inner class. The output of this program is:</p>
			<p class="source-code">This is an inner class</p>
			<p class="source-code">17</p>
			<p class="source-code">Process finished with exit code 0</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Documenting with JavaDoc</h1>
			<p>Javadoc is a tool that comes with the JDK that can be used to generate documentation of classes directly from properly commented code. It requires the use of a specific type of commenting that is different from the ones seen in <em class="italic">Chapter 1</em>, <em class="italic">Getting Started</em>. There, we saw that comments can be added to code using either <strong class="source-inline">//</strong> or <strong class="source-inline">/*</strong> or <strong class="source-inline">*/</strong>. JavaDoc uses a specific type of marking to detect what comments were intentionally made for documentation purposes. Javadoc comments are contained within<strong class="source-inline"> /** </strong>and<strong class="source-inline"> */</strong>.<strong class="source-inline"> </strong>A simple example follows.</p>
			<p class="source-code-heading">Example18.java</p>
			<p class="source-code">1  /**</p>
			<p class="source-code">2   * Anonymous class example</p>
			<p class="source-code">3   * This example shows the declaration of an inner class extending</p>
			<p class="source-code">4   * an existing class and overriding a method. It can be used as a</p>
			<p class="source-code">5   * technique to modify an existing method for something more suitable</p>
			<p class="source-code">6   * to our purpose.</p>
			<p class="source-code">7   *</p>
			<p class="source-code">8   * @author Joe Smith</p>
			<p class="source-code">9   * @version 0.1</p>
			<p class="source-code">10  * @since 20190305</p>
			<p class="source-code">11  */</p>
			<p class="source-code-link"><a href="https://packt.live/2J5u4aT">https://packt.live/2J5u4aT</a></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are going to generate documentation from a class, you need to make sure the class is public, otherwise, the JavaDoc generator will complain about the fact that it makes no sense to document classes that aren't public.</p>
			<p>The new comments include information about the program itself. It is good practice to explain, in some detail, what the program does. Sometimes, it may be convenient to even add blocks of code. In order to support that extra information, there are tags that allow the addition of specific features or metadata to the documentation. <strong class="source-inline">@author</strong>, <strong class="source-inline">@version</strong>, and <strong class="source-inline">@since</strong> are examples of such metadata – they determine who made the code, the version of the code, and when it was first created, respectively. There is a long list of possible tags that you can use; visit <a href="https://packt.live/2J2Px4n">https://packt.live/2J2Px4n</a> for more information.</p>
			<p>JavaDoc renders the documentation as one or more HTML files. Therefore, it is possible to also add HTML markup to help messages. You could change the documentation part of the previous example as follows:</p>
			<p class="source-code">/**</p>
			<p class="source-code"> * &lt;H1&gt;Anonymous class example&lt;/H1&gt;</p>
			<p class="source-code"> * This example shows the declaration of an &lt;b&gt;inner class&lt;/b&gt; extending</p>
			<p class="source-code"> * an existing class and overriding a method. It can be used as a</p>
			<p class="source-code"> * technique to modify an existing method for something more suitable</p>
			<p class="source-code"> * to our purpose.</p>
			<p class="source-code"> *</p>
			<p class="source-code"> * @author Joe Smith</p>
			<p class="source-code"> * @version 0.1</p>
			<p class="source-code"> * @since 20190305</p>
			<p class="source-code"> */</p>
			<p>Finally, you can create the documentation file by selecting <strong class="source-inline">Tools</strong> | <strong class="source-inline">Generate JavaDoc</strong> from the menu:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Figure 3.9: Generating JavaDoc" src="image/C13927_03_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9: Generating JavaDoc</p>
			<p>The JavaDoc generation dialog box will pop up and give you some options. Make sure that you insert the folder where you want the documentation file to be stored (<strong class="source-inline">/tmp</strong> in the example) and tick the checkboxes for the <strong class="source-inline">@author</strong> and the <strong class="source-inline">@version</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer042">
					<img alt="Figure 3.10: Specifying the scope for the JavaDoc&#13;&#10;" src="image/C13927_03_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10: Specifying the scope for the JavaDoc</p>
			<p>This will generate an HTML file that is formatted in the same way that official Java documentation is:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Figure 3.11: The generated JavaDoc&#13;&#10;" src="image/C13927_03_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11: The generated JavaDoc</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Activity 2: Adding Documentation to WordTool</h2>
			<p>Create documentation for the class created in <em class="italic">Exercise 1</em>, <em class="italic">Creating the WordTool Class</em>.</p>
			<ol>
				<li value="1">Make sure you document each one of the examples and add enough metadata for people to know how to handle the different methods.</li>
				<li>Export the resulting documentation file.<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 536.</p></li>
			</ol>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Summary</h1>
			<p>This chapter introduced you to the core of object-oriented programming—the creation of classes and those operations which can be performed with them, such as extending them, using them to override parts of the code, or creating local instances.</p>
			<p>The examples provided here showed you the importance of creating classes to better structure your code and improve it economically. If there are several classes within a specific context, it is very likely that they will have common characteristics that could be described in a parent class or even an interface.</p>
			<p>A part of the chapter was dedicated to operations done with the compiler. As a developer, you may want to inform others when certain parts of your code will be deprecated, or whether a method from a specific class has been overridden. Annotating code is a good technique for maintaining communication with others. You also saw how to turn off possible warnings coming from annotations that occurred during development.</p>
			<p>Finally, we discussed the process of documentation. This is relevant when sharing code or passing it over to other people. In the next chapter, we will take a look at Java collections framework which will simplify your dealings with complex data structures.</p>
		</div>
	</body></html>