<html><head></head><body>
		<div id="_idContainer009">
			<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Peeking Inside the Java Virtual Machine</h1>
			<p>I would like to introduce you to a remarkable piece of technology that helped revolutionize the software industry. Meet the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>). Okay, so you are likely already familiar with the JVM, and it is <a id="_idIndexMarker000"/>important to understand and appreciate the tremendous value it has as the middleware between compiled Java bytecode and a virtually limitless number of hardware platforms. The ingenious design of Java and the JVM is a testament to its wild popularity and value to users <span class="No-Break">and developers.</span></p>
			<p>Since the first release of Java in the 1990s, the JVM has been the true success factor for the Java programming language. With Java and the JVM, the concept of “write once, run anywhere” was born. Java developers can write their programs once and allow the JVM to ensure the code runs on devices the JVM is installed on. The JVM also makes Java a platform-independent language. The primary objective of this chapter is to provide greater insights into the unsung hero of Java, <span class="No-Break">the JVM.</span></p>
			<p>In this chapter, we will take an extensive look at the JVM so that we can learn to get the most out of it in an effort to increase the performance of our <span class="No-Break">Java applications.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>How the <span class="No-Break">JVM works</span></li>
				<li><span class="No-Break">Garbage collection</span></li>
				<li><strong class="bold">Just-in-Time</strong> (<strong class="bold">JIT</strong>) <span class="No-Break">compiler optimizations</span></li>
			</ul>
			<p>By the end of this chapter, you should understand how to get the most out of the JVM to improve the performance of your <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need <span class="No-Break">the following:</span></p>
			<ul>
				<li>A computer with either Windows, macOS, or <span class="No-Break">Linux installed</span></li>
				<li>The current version of the <span class="No-Break">Java SDK</span></li>
				<li>Preferably, a code editor or <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) (such as Visual Studio Code, NetBeans, Eclipse, or <span class="No-Break">IntelliJ IDEA)</span></li>
			</ul>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This book is based on Java 21 and the <strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>) 21.0.1. It also uses the IntelliJ IDEA Community Edition IDE, running <span class="No-Break">on macOS.</span></p>
			<p>This chapter contains code examples that you can use to follow along with and experiment with. So, you will want to ensure your system is <span class="No-Break">properly prepared.</span></p>
			<p>Start by downloading and installing your IDE of choice. Here are a couple <span class="No-Break">of options:</span></p>
			<ul>
				<li>Visual Studio <span class="No-Break">Code (</span><a href="https://code.visualstudio.com/download"><span class="No-Break">https://code.visualstudio.com/download</span></a><span class="No-Break">)</span></li>
				<li><span class="No-Break">NetBeans (</span><a href="https://netbeans.apache.org/download/"><span class="No-Break">https://netbeans.apache.org/download/</span></a><span class="No-Break">)</span></li>
				<li><span class="No-Break">Eclipse (</span><a href="https://www.eclipse.org/downloads/"><span class="No-Break">https://www.eclipse.org/downloads/</span></a><span class="No-Break">)</span></li>
				<li>IntelliJ IDEA Community <span class="No-Break">Edition (</span><a href="https://www.jetbrains.com/idea/download/"><span class="No-Break">https://www.jetbrains.com/idea/download/</span></a><span class="No-Break">)</span></li>
			</ul>
			<p>After your IDE is set up, you need to ensure it is configured for Java development. Most modern IDEs are capable of downloading and installing the Java SDK for you. If this is not the case for you, the Java SDK can be obtained here:  <a href="https://www.oracle.com/java/technologies/downloads/"><span class="No-Break">https://www.oracle.com/java/technologies/downloads/</span></a><span class="No-Break">.</span></p>
			<p>Ensuring that your IDE is Java-ready is important. Here are some IDE-specific links in case you need <span class="No-Break">some help:</span></p>
			<ul>
				<li>Java in Visual Studio <span class="No-Break">Code (</span><a href="https://code.visualstudio.com/docs/languages/java"><span class="No-Break">https://code.visualstudio.com/docs/languages/java</span></a><span class="No-Break">)</span></li>
				<li>Java quick start tutorial for <span class="No-Break">NetBeans (</span><a href="https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/"><span class="No-Break">https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/</span></a><span class="No-Break">)</span></li>
				<li>Preparing <span class="No-Break">Eclipse (</span><a href="https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm"><span class="No-Break">https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm</span></a><span class="No-Break">)</span></li>
				<li>Creating your first Java application with IntelliJ IDEA Community <span class="No-Break">Edition (</span><a href="https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html"><span class="No-Break">https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html</span></a><span class="No-Break">)</span></li>
			</ul>
			<p>Once you have your IDE and the Java SDK installed and configured on your computer, you are ready to move to the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>How the JVM works</h1>
			<p>At the core, the <a id="_idIndexMarker001"/>JVM sits between your Java bytecode and your computer. As illustrated next, we develop our Java source code in an IDE, and our work is saved as <strong class="source-inline">.java</strong> files. We use the Java compiler to convert our Java source code to bytecode; the resulting files are <strong class="source-inline">.class</strong> files. We then use the JVM to run our bytecode on <span class="No-Break">our computer:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer008">
					<img alt="" role="presentation" src="image/B21942_01_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Java application workflow</p>
			<p>It is important to<a id="_idIndexMarker002"/> realize that Java is different from typical compile-and-execute languages where source code is fed into a compiler, which then produces a <strong class="source-inline">.exe</strong> file (for Windows), a <strong class="source-inline">.app</strong> file (for (macOS), or <strong class="source-inline">ELF</strong> files (for Linux). This impressive process is much more complex than <span class="No-Break">it seems.</span></p>
			<p>Let’s take a closer look at what is going on with regard to the JVM, using a basic example. In the following code, we implement a simple loop that prints to the console. It is presented so that we can see how the JVM handles <span class="No-Break">Java code:</span></p>
			<pre class="source-code">
// Chapter1
// Example 1
public class CH1EX1 {
    public static void main(String[] args) {
        System.out.println("Basic Java loop.");
        // Basic loop example
        for (int i = 1; i &lt;= 5; i++) {
            System.out.println("1 x " + i + " = " + i);
        }
    }
}</pre>			<p>We can use the<a id="_idIndexMarker003"/> Java compiler to compile our code into a <strong class="source-inline">.class</strong> file, which will be formatted as bytecode. Let’s open a terminal window, navigate to our project’s <strong class="source-inline">src</strong> folder as shown next, and use the <strong class="source-inline">ls</strong> command to reveal our <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">java</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
$ cd src
$ ls
CH1EX1.java
$</pre>			<p>Now that we are in the proper folder, we can use <strong class="source-inline">javac</strong> to convert our source code to bytecode. As you can see next, this created a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">class</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
$ javac CH1EX1.java
$ ls
CH1EX1.class    CH1EX1.java
$</pre>			<p>Next, we can use<a id="_idIndexMarker004"/> the <strong class="bold">Java Printer</strong> tool (<strong class="source-inline">javap</strong>) to print a decompiled version of our bytecode. As you can see next, we can use the <strong class="source-inline">javap</strong> command<a id="_idIndexMarker005"/> without <span class="No-Break">any parameters:</span></p>
			<pre class="source-code">
javap CH1EX1.class
Compiled from "CH1EX1.java"
public class CH1EX1 {
  public CH1EX1();
  public static void main(java.lang.String[]);
}</pre>			<p>As you can see, our use of the <strong class="source-inline">javap</strong> command simplified the printing of the decompiled bytecode. Now, let’s use the <strong class="source-inline">-c</strong> parameter to reveal <span class="No-Break">the bytecode:</span></p>
			<pre class="console">
$ javap -c CH1EX1.class</pre>			<p>Here is the output from running<a id="_idIndexMarker006"/> the <strong class="source-inline">javap</strong> command with the <strong class="source-inline">-c</strong> parameter, using our <span class="No-Break">example code:</span></p>
			<pre class="console">
Compiled from "CH1EX1.java"
public class CH1EX1 {
  public CH1EX1();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/
                                            Object."&lt;init&gt;":()V
       4: return
  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #7                  // Field java/lang/System.
                                            out:Ljava/io/PrintStream;
       3: ldc           #13                 // String Basic Java loop.
       5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: iconst_1
       9: istore_1
      10: iload_1
      11: iconst_5
      12: if_icmpgt     34
      15: getstatic     #7                  // Field java/lang/System.
                                            out:Ljava/io/PrintStream;
      18: iload_1
      19: iload_1
      20: invokedynamic #21,  0             // InvokeDynamic #0:makeConcatWithConstants:(II)Ljava/lang/String;
      25: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      28: iinc          1, 1
      31: goto          10
      34: return
}</pre>			<p>You should now have<a id="_idIndexMarker007"/> a better appreciation of the miraculous work the JVM does. We are just <span class="No-Break">getting started!</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>More options with javap</h2>
			<p>So far, we have used the <strong class="source-inline">javap</strong> command<a id="_idIndexMarker008"/> in two forms: without parameters and with the <strong class="source-inline">-c</strong> parameter. There are some other parameters we can use to further our understanding of our bytecode. To review these parameters, we will use an abbreviated example, <span class="No-Break">shown next:</span></p>
			<pre class="source-code">
public class CH1EX2 {
    public static void main(String[] args) {
        System.out.println("Simple Example");
    }
}</pre>			<p>You can now compile the class first using <strong class="source-inline">javac</strong> and then run it. Let’s use the <strong class="source-inline">-sysinfo</strong> parameter to output system information. As you can see next, the file path, file size, date, and a <strong class="source-inline">SHA-256</strong> hash <span class="No-Break">are printed:</span></p>
			<pre class="console">
$ javap -sysinfo CH1EX2.class</pre>			<p>Here is the output <a id="_idIndexMarker009"/>from using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">sysinfo</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="console">
Classfile /HPWJ/Code/Chapter1/CH1Example2/src/CH1EX2.class
  Last modified Oct 22, 2023; size 420 bytes
  SHA-256 checksum 9328e8bab7fcd970f73fc9eec3a856a809b7a45e7b743f8c8b3b7ae0a7fbe0da
  Compiled from "CH1EX2.java"
public class CH1EX2 {
  public CH1EX2();
  public static void main(java.lang.String[]);
}</pre>			<p>Let’s look at one more example of the <strong class="source-inline">javap</strong> command, this time using the <strong class="source-inline">-verbose</strong> parameter. Here is how to use that parameter via a terminal <span class="No-Break">command line:</span></p>
			<pre class="console">
$ javap -verbose CH1EX2.class</pre>			<p>The output from using the <strong class="source-inline">-verbose</strong> parameter is shown next. As you can see, there is a lot of additional <span class="No-Break">information provided:</span></p>
			<pre class="console">
Classfile /HPWJ/Code/Chapter1/CH1Example2/src/CH1EX2.class
  Last modified Oct 22, 2023; size 420 bytes
  SHA-256 checksum 9328e8bab7fcd970f73fc9eec3a856a809b7a45e7b743f8c8b3b7ae0a7fbe0da
  Compiled from "CH1EX2.java"</pre>			<p>The remainder of the output can be obtained <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01/java-output"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/</span><span class="No-Break">Chapter01</span><span class="No-Break">/java-output</span></a><span class="No-Break">.</span></p>
			<p>We can use the <strong class="source-inline">javap</strong> command<a id="_idIndexMarker010"/> to thoroughly examine our bytecode. Here are some common parameters that are available to us, in addition to <strong class="source-inline">-c</strong>, -<strong class="source-inline">sysinfo</strong>, and <strong class="source-inline">-verbose</strong>, which we have <span class="No-Break">already used:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">javap Parameter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">What </strong><span class="No-Break"><strong class="bold">is Printed</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">constants</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Constants (<span class="No-Break">static final)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-help (</strong><span class="No-Break"><strong class="source-inline">or -?)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Help</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-l</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Line variables and <span class="No-Break">local variables</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-private (</strong><span class="No-Break"><strong class="source-inline">or -p)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">All classes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">protected</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Protected and public classes (<span class="No-Break">not private)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">public</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Public classes (does not print <span class="No-Break">private classes)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-s</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Internal <span class="No-Break">signature types</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">version</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Java <span class="No-Break">release version</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Figure">Table 1.1 – javap parameters</p>
			<p>Now that you have seen the inside workings of the JVM, let’s take a look at the phenomenal job it does with <span class="No-Break">garbage collection.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Garbage collection</h1>
			<p>Java developers have long<a id="_idIndexMarker011"/> enjoyed the JVM’s ability to manage memory, including allocation and deallocation. The allocation component of memory management is straightforward and not wrought with inherent problems. The area that is most important is freeing previously allocated memory that is no longer needed by the application. This is referred to as deallocation or garbage collection. While not unique to Java programming language, its JVM does a wonderful job with garbage collection. This section takes a detailed look at JVM’s <span class="No-Break">garbage collection.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>The garbage collection process</h2>
			<p>The<a id="_idIndexMarker012"/> following example is the creation of two objects, making them reference each other, and then nullifying them both. Once they are nullified, they are no longer reachable, despite that they reference each other. This makes them eligible for <span class="No-Break">garbage collection:</span></p>
			<pre class="source-code">
public class Main {
    public static void main(String[] args) {
        // Creating two objects
        SampleClass object1 = new SampleClass("Object 1");
        SampleClass object2 = new SampleClass("Object 2");
        // Making the objects reference each other
        object1.reference = object2;
        object2.reference = object1;
        // References are nullified
        object1 = null;
        object2 = null;
    }
}
class SampleClass {
    String name;
    SampleClass reference;
    public SampleClass(String name) {
        this.name = name;
    }
    // Overriding finalize() method to see the garbage collection 
    // process
    @Override
    protected void finalize() throws Throwable {
        System.out.println(name + " is being garbage collected!");
        super.finalize();
    }
}</pre>			<p>In the <a id="_idIndexMarker013"/>preceding example, we could make an explicit call to the garbage collector. This is not generally advisable as the JVM does a great job of this already, and extra calls could impact performance. If you do want to make that explicit call, this is how you would <span class="No-Break">do it:</span></p>
			<pre class="source-code">
System.gc();</pre>			<p class="callout-heading">Note on the finalize() method</p>
			<p class="callout">The JVM only calls the <strong class="source-inline">finalize()</strong> method if it has been enabled. When enabled, it is possible that it will be called by the garbage collector, after an unspecified time delay. The method has been deprecated and should only be used for testing, not in <span class="No-Break">production systems.</span></p>
			<p>If you want to conduct additional testing, you can add code that attempts to reach unreachable objects. Here is how you would <span class="No-Break">do that:</span></p>
			<pre class="source-code">
try {
  object1.display();
  } catch (NullPointerException e) {
    System.out.println("Unreachable object!");
}</pre>			<p>The <a id="_idIndexMarker014"/>preceding <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> block has a call to <strong class="source-inline">object1</strong>. Since that is unreachable, it will throw a <span class="No-Break"><strong class="source-inline">NullPointerException</strong></span><span class="No-Break"> exception.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Garbage collection algorithms</h2>
			<p>The JVM has several garbage collection algorithms<a id="_idIndexMarker015"/> at its disposal, and which one is used depends upon the version of Java and the specific use case. There are a few garbage collection algorithms <span class="No-Break">worth mentioning:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Serial Collector</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Parallel Collector</strong></span></li>
				<li><strong class="bold">Concurrent Mark-Sweep </strong><span class="No-Break"><strong class="bold">Collector</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CMS</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Garbage-First</strong> (<span class="No-Break"><strong class="bold">G1</strong></span><span class="No-Break">) </span><span class="No-Break"><strong class="bold">Collector</strong></span></li>
				<li><strong class="bold">Z Garbage </strong><span class="No-Break"><strong class="bold">Collector</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ZGC</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Each of these garbage collection algorithms is described next so that you can gain a better appreciation for the heavy lifting the JVM does to deallocate memory <span class="No-Break">for us.</span></p>
			<p><span class="No-Break"><strong class="bold">Serial Collector</strong></span></p>
			<p>The serial garbage <a id="_idIndexMarker016"/>collector is the<a id="_idIndexMarker017"/> JVM’s most basic algorithm. It is used for small heaps and single-threaded applications. This type of application can be characterized as sequential execution, not concurrent execution. Since there is only one thread to consider, memory management is much easier. Another characterizing feature is that single-threaded applications often only use a portion of the host’s CPU capabilities. Finally, since the execution is sequential, predicting the need for garbage collection <span class="No-Break">is uncomplicated.</span></p>
			<p><span class="No-Break"><strong class="bold">Parallel Collector</strong></span></p>
			<p>The parallel garbage <a id="_idIndexMarker018"/>collector, also<a id="_idIndexMarker019"/> referred to as the throughput garbage collector, was the default for early Java releases through Java 8. Its capabilities exceed that of the serial collector in that it was designed for medium- to large-sized heaps and <span class="No-Break">multithreaded applications.</span></p>
			<p><span class="No-Break"><strong class="bold">CMS</strong></span></p>
			<p>The CMS garbage collector<a id="_idIndexMarker020"/> was deprecated in Java 9 and removed from the Java <a id="_idIndexMarker021"/>platform in Java 14. Its purpose was to minimize the amount of time an application was paused for garbage collection. The reasons for deprecation and removal included high resource consumption, failures due to lag, difficulty in maintaining the code base, and that there were <span class="No-Break">better alternatives.</span></p>
			<p><span class="No-Break"><strong class="bold">G1 Collector</strong></span></p>
			<p>The G1 Collector<a id="_idIndexMarker022"/> became the default garbage collector in Java 9, dethroning the parallel <a id="_idIndexMarker023"/>collector. G1 was designed to provide faster and more predictable response times and extremely high throughput. The G1 Collector can be considered the primary and default <span class="No-Break">garbage collector.</span></p>
			<p><span class="No-Break"><strong class="bold">ZGC</strong></span></p>
			<p>Java 11 was released with the ZGC<a id="_idIndexMarker024"/> garbage collector<a id="_idIndexMarker025"/> as an experimental feature. ZGC’s aim was to provide a low-latency garbage collector that was scalable. The intention was for ZGC to handle a wide range of heap sizes, from very small to very large (for example, terabytes). ZGC delivered on these goals without sacrificing pause times. This success led to ZGC being released as a Java <span class="No-Break">15 feature.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Garbage collection optimizations</h2>
			<p>Discerning Java <a id="_idIndexMarker026"/>developers are laser-focused on getting the most performance out of the JVM for their applications. To this end, several things can be done with respect to garbage collection to help improve the performance of <span class="No-Break">Java applications:</span></p>
			<ol>
				<li>Select the most appropriate garbage collection algorithm based on your use case, heap size, and <span class="No-Break">thread count.</span></li>
				<li>Initialize, monitor, and manage your heap sizes. They should not be larger than <span class="No-Break">absolutely needed.</span></li>
				<li>Limit object creation. We will discuss alternatives to this in <a href="B21942_06.xhtml#_idTextAnchor105"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">.</span></li>
				<li>Use appropriate data structures for your applications. This is the subject of <a href="B21942_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></li>
				<li>As indicated earlier in this chapter, avoid, or at least significantly limit, calls to the <strong class="source-inline">finalize</strong> method to reduce garbage collection delays and <span class="No-Break">processing overhead.</span></li>
				<li>Optimize your use of strings, with a special focus on minimizing duplicate strings. We will cover this in greater depth in <a href="B21942_07.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></li>
				<li>Be mindful of allocating memory outside of the JVM’s garbage collection reach (for example, <span class="No-Break">native code).</span></li>
				<li>Lastly, employ tools to help you monitor garbage collection in real time. We will review some of <a id="_idIndexMarker027"/>these tools in <a href="B21942_14.xhtml#_idTextAnchor250"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><span class="No-Break">.</span></li>
			</ol>
			<p>Hopefully, you have a newfound appreciation of JVM’s garbage collection and optimization methods. We will now take a look at specific <span class="No-Break">compiler optimizations.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>JIT compiler optimizations</h1>
			<p>There are three key <a id="_idIndexMarker028"/>components of the JVM: a class loader that initializes and links classes and interfaces; runtime data, which includes memory allocation; and the execution engine. This latter component, the execution engine, is the focus of <span class="No-Break">this section.</span></p>
			<p>The core responsibility of the <a id="_idIndexMarker029"/>execution engine is to convert bytecode so that it can be executed on the host <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>). There are three primary implementations of <span class="No-Break">this process:</span></p>
			<ul>
				<li><span class="No-Break">Interpretation</span></li>
				<li><strong class="bold">Ahead-of-Time</strong> (<span class="No-Break"><strong class="bold">AOT</strong></span><span class="No-Break">) compilation</span></li>
				<li><span class="No-Break">JIT compilation</span></li>
			</ul>
			<p>We will take a <a id="_idIndexMarker030"/>cursory look at interpretation and AOT compilation before diving into JIT <span class="No-Break">compilation optimizations.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Interpretation</h2>
			<p>Interpretation<a id="_idIndexMarker031"/> is a <a id="_idIndexMarker032"/>technique that the JVM can use to read and execute bytecode without converting it into machine code native to the host CPU. We can invoke this mode by using the <strong class="source-inline">java</strong> command in a terminal window. Here is <span class="No-Break">an example:</span></p>
			<pre class="console">
$ java Main.java</pre>			<p>The only real advantage of using the interpretation mode is to save time by avoiding the compilation process. This can be useful for testing and is not recommended for production systems. Performance is a typical problem when using interpretation as compared to AOT and JIT, both <span class="No-Break">described next.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>AOT compilation</h2>
			<p>We can <a id="_idIndexMarker033"/>compile our bytecode into<a id="_idIndexMarker034"/> native machine code in advance of application execution. This approach is called AOT and can be used for performance enhancements. Specific advantages to this approach include <span class="No-Break">the following:</span></p>
			<ul>
				<li>You can avoid normal <a id="_idIndexMarker035"/>application startup delays associated with the traditional JIT <span class="No-Break">compilation process</span></li>
				<li>The startup execution speed <span class="No-Break">is consistent</span></li>
				<li>Startup CPU load is <span class="No-Break">typically reduced</span></li>
				<li>Mitigate security risks by avoiding other <span class="No-Break">compilation approaches</span></li>
				<li>You can build<a id="_idIndexMarker036"/> optimization into your <span class="No-Break">startup code</span></li>
			</ul>
			<p>There are also a few <a id="_idIndexMarker037"/>disadvantages to using the AOT <span class="No-Break">compilation approach:</span></p>
			<ul>
				<li>When you compile ahead of time, you lose the ability to deploy on <span class="No-Break">any device</span></li>
				<li>It is possible that your application will be bloated, increasing storage and <span class="No-Break">related costs</span></li>
				<li>Your application will not be able to take advantage of JVM optimizations that are associated with <span class="No-Break">JIT compilation</span></li>
				<li>The complexity of code <span class="No-Break">maintenance increases</span></li>
			</ul>
			<p>Understanding the <a id="_idIndexMarker038"/>benefits and disadvantages can help you decide when to, and when not to, use the AOT <span class="No-Break">compilation process.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>JIT compilation</h2>
			<p>The JIT <a id="_idIndexMarker039"/>compilation process<a id="_idIndexMarker040"/> is likely the one we are most familiar with. We invoke the JVM and have it convert our bytecode into machine code specific to the current host machine. This machine code is referred to as native machine code because it is native to the local CPU. This compilation occurs just in time, or just before execution. This means the entirety of the bytecode is not compiled <span class="No-Break">at once.</span></p>
			<p>The advantages of JIT compilation are increased performance over the interpretation approach, the ability to deploy your application on any device (platform agnostic), and the ability to optimize. The JIT compiler process is capable of optimizing the code (for example, removing dead code, loop unrolling, and more. The disadvantages are the overhead required at the initial startup and the use of memory caused by the need to store native machine <span class="No-Break">code translations.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Summary</h1>
			<p>By now, you should have an appreciation of the complexities of the JVM and how it works. This chapter’s coverage included the <strong class="source-inline">javac</strong> and <strong class="source-inline">javap</strong> command-line tools to create and analyze bytecode. The JVM’s garbage collection function was also examined through the lens of application performance. Lastly, the optimization of JIT compilation <span class="No-Break">was covered.</span></p>
			<p>The JVM is 29 years old, as of this book’s publication date, and it has come a long way since its initial release. In addition to continual improvements and optimizations, the JVM can even support additional languages (for example, Kotlin and Scala). Java developers interested in continual performance improvement of their Java applications should stay abreast of <span class="No-Break">JVM updates.</span></p>
			<p>With a solid understanding of the JVM, we turn our focus to data structures in the next chapter. Our focus will be on using data structures optimally as part of our <span class="No-Break">high-performance strategy.</span></p>
		</div>
	</body></html>