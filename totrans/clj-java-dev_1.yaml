- en: Chapter 1. Getting Started with Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the world of Clojure! If you are here, you probably know a little
    about Lisp or Clojure, but you don't really have an idea of how things work in
    this world.
  prefs: []
  type: TYPE_NORMAL
- en: We will get to know Clojure by comparing each feature to what you already know
    from Java. You will see that there are lists, maps and sets just like in Java,
    but they are immutable. To work with these kinds of collections, you need a different
    approach; a different paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we will try to accomplish in this book, to give you a different
    way to approach problems. We hope you end up using Clojure in your every day life,
    but if you don't, we hope you use a new approach toward problem solving.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Leiningen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a **Read Eval Print Loop** (**REPL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using Cursive Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure's simple syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure's data types and their relationship to the JVM's data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special syntax for functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started with Clojure, you should know some of its features and
    what it shares with Java.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is a programming language that inherits a lot of characteristics from
    Lisp. You might think of Lisp as that weird programming language with all the
    parentheses. You need to keep in mind that Clojure chooses to embrace functional
    programming. This makes it very different from current mainstream programming
    languages. You will get to know about immutable data structures and how to write
    programs without changing variable values.
  prefs: []
  type: TYPE_NORMAL
- en: You will also find that Clojure is a dynamic programming language, which makes
    it a little easier and faster to write programs than using statically typed languages.
    There is also the concept of using a REPL, a tool that allows you to connect to
    a program running environment and change code dynamically. It is a very powerful
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: At last, you will find out that you can convert Clojure to anything you like.
    You can create or use a statically typed system and bend the language to become
    what you like. A good example of this is the `core.typed` library, which allows
    you to specify the type information without adding support to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Leiningen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are used to having certain tools to help us build our code, such as Ant,
    Maven, and Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Clojure ecosystem, the de facto standard for dependency and build management
    is Leiningen (affectionately named after the short story "Leiningen versus the
    Ants", which I recommend reading at [http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants](http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants));
    Leiningen strives to be a familiar to Java developers, it gets the best ideas
    from Maven, like: convention over configuration. It also gets ideas from Ant like
    custom scripting and plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing it is very simple, let's check how to do it on Mac OS X (installing
    on Linux should be the same) using bash as your default shell.
  prefs: []
  type: TYPE_NORMAL
- en: You should also have Java 7 or 8 already installed and configured in your path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the detailed instructions on the Leiningen project page [http://leiningen.org/](http://leiningen.org/).
    If you want to get a Leiningen installation up and running, this is what you would
    have to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first time you run the `lein` command, it downloads everything needed from
    the internet. This makes it very easy to distribute your code, you can even include
    the `lein` script with your own projects and make it easier for other developers
    to get up and running, the only real requirement is the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Using a REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main advantages of Clojure (and Lisp) is interactive development,
    the REPL is the base of what can be achieved with interactive programming, it
    allows you to connect to a running VM running Clojure and execute or modify code
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: There is a story about how NASA was able to debug and correct a bug on a $100
    million piece of hardware that was 100 million miles away ([http://www.flownet.com/gat/jpl-lisp.html](http://www.flownet.com/gat/jpl-lisp.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have that same power with Clojure and Leiningen and invoking it is very
    simple, you just need a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you''ll get after running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a REPL](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go into a bit more detail, as we can see we are running with the following
    programs:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure 1.6.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also get some nice suggestions on how to see documentation, `source`,
    `Javadoc`, and previous errors.
  prefs: []
  type: TYPE_NORMAL
- en: The nREPL protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One particular thing that is important to note is the nREPL protocol; Someday
    it might grant us the power to go into a machine running 100 million miles away.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you fire up your REPL, the first thing you see is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What it is saying is that there's a Clojure process running an nREPL server
    on port `55995`. We have connected to it using a very simple client that allows
    us to interact with the Clojure process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The really interesting bit is that you can connect to a remote host just as
    easily; let''s try attaching an REPL to the same process by simply typing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Most IDEs have a good integration with Clojure and most of them use this exact
    mechanism, as clients that work a little more intelligently.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are inside the REPL, (any of the two) let''s try writing our first
    expression, go on and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should get back a value from the REPL saying `Hello world`, this is not
    really a program, and it is the `Hello world` value printed back by the print
    phase of the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now try to write our first Lisp form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This first expression looks different from what we are used to, it is called
    an S-expression and it is the standard Lisp way.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to remember with S-expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: They are lists (hence, the name, Lisp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first element of the list is the action that we want to execute, the rest
    are the parameters of that action (one two three).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we are asking for the string `Hello world` to be printed, but if we look
    a bit closer at the output, as shown in the following screenshot, there is a `nil`
    that we weren''t expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello world](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The reason for this is that the `println` function returns the value `nil` (Clojure's
    equivalent for null) after printing `Hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Clojure, everything has a value and the REPL will always print it back for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: REPL utilities and conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw, the Leiningen nREPL client prints help text; but how does that work?
    Let's explore some of the other utilities that we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try each of them to get a feeling of what it does with the help of the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description | Sample |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `doc` | Prints out a function''s `docstring` | (`doc println`) |'
  prefs: []
  type: TYPE_TB
- en: '| `source` | Prints a function''s source code, it must be written in Clojure
    | (`source println`) |'
  prefs: []
  type: TYPE_TB
- en: '| `javadoc` | Open the `javadoc` for a class in the browser | (`javadoc java.lang.Integer`)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s check how these functions work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: What you are seeing here is metadata pertaining to the `doc` function; Clojure
    has the ability to store metadata about every function or `var` you use. Most
    of the Clojure core functions include a doc string and the source of the function
    and this is something that will become very handy in your day to day work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides these functions, we also get easy access to the latest three values
    and the latest exceptions that happened in the REPL, let''s check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`*e` gives you access to the actual plain old Java exception object, so you
    can analyze and introspect it at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine the possibilities of being able to execute and introspect code
    with this, but what about the tools that we are already used to? How can we use
    this with an IDE?
  prefs: []
  type: TYPE_NORMAL
- en: Let's check now how to create a new Clojure project, we'll use Leiningen from
    the command line to understand what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leiningen can help us create a new project using templates, there is a wide
    variety of templates available and you can build and distribute your own in Maven.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most common types of templates are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `jar` library (the default template)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a command-line app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Clojure web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a new Clojure command-line app and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leiningen is similar to other Java development tools; it uses a similar convention
    and allows for heavy customizations in the `project.clj` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Maven or Gradle, you can think of it as `pom.xml` or
    `build.gradle` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, there are four main folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources`: It holds everything that should be in the class path, such as
    files, images, configuration files, properties files, and other resources needed
    at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: Your Clojure source files; they are ordered in a very similar fashion
    to the `classpath`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev-resources`: Everything that should be in the `classpath` in development
    (when you are running Leiningen). You can override your "production" files here
    and add files that are needed for tests to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: Your tests; this code doesn''t get packaged but it is run every time
    you execute the Leiningen test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a standalone app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your project is created, you can build and run a Java standalone command-line
    app quite easily, let''s try it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is quite easy to create a standalone app and it is very similar
    to using Maven or Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cursive Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java already has some great tools to help us be more productive and write higher
    quality code and we don''t need to forget about those tools. There are several
    plugins for Clojure depending on what your IDE is. Have a look at them from the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| IDE | Plugins |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| IntelliJ | Cursive Clojure, La Clojure |'
  prefs: []
  type: TYPE_TB
- en: '| NetBeans | NetBeans Clojure (works with NetBeans 7.4) |'
  prefs: []
  type: TYPE_TB
- en: '| Eclipse | CounterClockwise |'
  prefs: []
  type: TYPE_TB
- en: '| Emacs | Cider |'
  prefs: []
  type: TYPE_TB
- en: '| VIM | vim-fireplace, vim-leiningen |'
  prefs: []
  type: TYPE_TB
- en: A lot of people writing real Clojure code use Emacs and I actually like using
    vim as my main development tool, but don't worry, our main IDE will be IntelliJ
    + Cursive Clojure throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cursive Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can check the full documentation for Cursive at their website ([https://cursiveclojure.com/](https://cursiveclojure.com/)),
    it is still under development but it is quite stable and a great aid when writing
    Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the latest IntelliJ Community Edition release, which at
    the time of this writing is version 14.
  prefs: []
  type: TYPE_NORMAL
- en: You can download IntelliJ from here [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Cursive Clojure is very simple, you need to add a repository for
    IntelliJ. You''ll find the instructions to your specific IntelliJ version here:
    [https://cursiveclojure.com/userguide/](https://cursiveclojure.com/userguide/).'
  prefs: []
  type: TYPE_NORMAL
- en: After you have installed Cursive Clojure, we are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to import our getting started project into Cursive Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cursive Clojure doesn't currently have support to create Leiningen projects
    from within the IDE; however, support is great in order to import them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you will do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the folder or the `project.clj` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the **Next** steps in the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are ready to go, you can use the Cursive Clojure as your main development
    tool. There are a few more things to do with your IDE but I recommend you to look
    for them; they are important and will come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: To know how to execute the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To know how to execute the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To open an REPL connected to some project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key binding to execute some given piece of code (run form before cursor
    in REPL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key binding to execute a given file (load file in REPL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important part of Clojure programming is that it can modify and reevaluate
    code in runtime. Check the manual of your current version of Clojure and check
    for the structural editing section ([https://cursiveclojure.com/userguide/paredit.html](https://cursiveclojure.com/userguide/paredit.html)).
    It is one of the most useful functionalities of Clojure IDEs and a direct consequence
    of the Clojure syntax.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you to check other functionalities from the manual. I really recommend
    checking the Cursive Clojure manual, it includes animations of how each functionality
    works.
  prefs: []
  type: TYPE_NORMAL
- en: You will use the last two key bindings quite a lot, so it is important to set
    them up correctly. There is more information about keybindings at [https://cursiveclojure.com/userguide/keybindings.html](https://cursiveclojure.com/userguide/keybindings.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Clojure code and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a deep dive into Clojure's syntax now, it is pretty different from
    other languages but it is actually much simpler. Lisps have a very regular syntax,
    with few special rules. As we said earlier, Clojure code is made of S-expressions
    and S-expressions are just lists. Let's look at some examples of lists to become
    familiar with lists in Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the above are lists, but not all of them are valid code. Remember, only
    lists where the first element is a function can be considered valid expressions.
    So, here only the following could be valid expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If `println` and `one` are defined as functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a piece of Clojure code, to finally explain how everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Lists in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clojure is based around "forms" or lists. In Clojure, same as every Lisp, the
    way to denote a list is with parentheses, so here are some examples of lists in
    the last code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists are one data type in Clojure and they are also the way to express code;
    you will learn later about all the benefits of expressing code as data. The first
    one is that it is really simple, anything you can do must be expressed as a list!
    Let''s look at some other examples of executable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to write everything into the REPL, so you get a good notion
    of what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: Operations in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Clojure, `MOST` of the executable forms have this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`op` is the operation to be executed followed by all the parameters it needs,
    let''s analyze each of our previous forms in this new light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are asking to execute the `+` (addition) operation with the parameters `1`,
    `2`, and `3`. The expected result is `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze something a bit more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this, we are asking to execute the `clojure.core/map` function with two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inc` is a function name, it takes a number and increments it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[1 2 3 4 5 6]` is a collection of numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map applies the `inc` function to each member of the passed collection and returns
    a new collection, what we expect is a collection containing `[2 3 4 5 6 7]`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s check how a function definition is essentially the same as the previous
    two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defn` is the operation that we are asking for. It has several parameters,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`some-function` is the name of the function that we are defining'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[times parameter]` is a collection of parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Prints a string certain number of times"` is the docstring, it is actually
    an optional parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(dotimes [x times] (println parameter))` is the body of the function that
    gets executed when you call `some-function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defn` calls a function into existence. After this piece of code is executed,
    `some-function` exists in the current namespace and you can use it with the defined
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defn` is actually written in Clojure and supports a few nice things. Let''s
    now define a `multi-arity` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Over here we are defining a function with two bodies, one of them has no arguments
    and the other one has one argument. It is actually pretty simple to understand
    what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the source in your project''s `core.clj` file similar to the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now run it, you'll get three different Hello outputs.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Clojure has a very regular syntax and even if it's a little
    strange for newcomers, it is actually quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used a few data types that we haven't properly introduced; in
    the next section we'll take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure's data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now is when everything you know about Java pays off; even the list forms that
    you saw earlier implement the `java.util.List` interface. Clojure was designed
    to be embeddable and to have a great integration with the host platform, so it's
    only natural that you can use everything you already know about Java types and
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two data types in Clojure: scalars and collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Scalars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In every language you need primitive types; you use them in everyday life as
    they represent numbers, strings, and Booleans. These primitive types are called
    scalars in the Clojure world.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has a couple of very interesting types like ratios and keywords. In
    the following table, you get to know the different types of scalars, how they
    compare to Java and a simple example of how to use each of them.
  prefs: []
  type: TYPE_NORMAL
- en: '| Clojure data type | Java data type | Sample | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| String | String | "This is a string""This is a multiline string" | A string
    of characters; in Clojure you can use multiline strings without a problem |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | Boolean | truefalse | Literal Boolean values |'
  prefs: []
  type: TYPE_TB
- en: '| Character | Character | `\c``\u0045 ;; Unicode char 45 E` | Character values,
    they are `java.lang.Character` instances, you can define Unicode characters |'
  prefs: []
  type: TYPE_TB
- en: '| Keywords | Doesn''t exist in java | `:key``:sample``:some-keyword` | They
    evaluate themselves and they are often used as keys. They are also functions that
    look for themselves in a map. |'
  prefs: []
  type: TYPE_TB
- en: '| Number | Numbers are automatically handled as `BigDecimal`, `BigInteger`
    or lower precision depending on what''s necessary | `42N ;;Big Integer``42 ;;long``0.1M
    ;;BigDecimal` | It is important to remember the trade-offs of Java numbers, if
    precision is important, you should always use big decimals and `bigintegers`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Ratio | Doesn''t exist | `22/7` | Clojure provides great numerical precision;
    if necessary it can retain the ration and execute exact operation. The tradeoff
    when using ratios is speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Symbol | Doesn''t exist | some-name | Symbols are identifiers in Clojure,
    very similar to a variable name in Java. |'
  prefs: []
  type: TYPE_TB
- en: '| nil | null | nil | The null value |'
  prefs: []
  type: TYPE_TB
- en: '| Regular expressions | `java.util.regex.Pattern` | `#"\d"` | Regular expressions,
    in Clojure you get free syntax to define regular expressions, but in the end it
    is a plain old Java reggae Pattern |'
  prefs: []
  type: TYPE_TB
- en: Collection data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Clojure there are two types of collections: sequential and associative collections.
    Sequential are things you can iterate, such as lists. Associative collections
    are maps, sets, and things you can access by a certain index. Clojure''s collections
    are fully compatible with Java and it can even implement the `java.util` interfaces,
    such as `java.util.List` and `java.util.Map`.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main characteristics of collections in Clojure is that they are immutable;
    it has a lot of benefits that we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the characteristics of each collection data type available
    in Clojure and compare them with Java with the help of a sample (in Clojure) and
    its description.
  prefs: []
  type: TYPE_NORMAL
- en: '| Clojure data type | Java data type | Sample | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | `List` | `(1 2 3 4 5)` | A simple list, notice the quote character
    before the list, if you don''t specify it Clojure will try to evaluate the form
    as an instruction |'
  prefs: []
  type: TYPE_TB
- en: '| `Vector` | `Array` | `[1 2 3 4 5]` | It is the main workhorse in Clojure,
    it is similar to an array because you can access elements in a random order |'
  prefs: []
  type: TYPE_TB
- en: '| `Set` | `HashSet` | `#{1 2 3 4}` | A normal Java hash set |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` | `HashMap` | `{:key 5 :key-2 "red"}` | A Clojure map |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, Clojure has a mature development environment that is always
    evolving. You can set up command-line tools and your IDE in a very similar fashion
    to the way you will do in a normal Java development.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned a little about Clojure's regular syntax, its data types and
    how they relate to Java's own data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, you should now be comfortable with:'
  prefs: []
  type: TYPE_NORMAL
- en: Lisp syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Leiningen project from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and packaging your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a Leiningen project into IntelliJ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the relationship between Clojure types and Java types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will get an idea of how to organize our code and how
    that organization takes advantage of Java packages.
  prefs: []
  type: TYPE_NORMAL
