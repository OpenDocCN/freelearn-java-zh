- en: Chapter 1. Getting Started with Clojure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. Clojure 入门
- en: Welcome to the world of Clojure! If you are here, you probably know a little
    about Lisp or Clojure, but you don't really have an idea of how things work in
    this world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Clojure 的世界！如果你在这里，你可能对 Lisp 或 Clojure 有一点了解，但你实际上并没有真正了解这个世界的运作方式。
- en: We will get to know Clojure by comparing each feature to what you already know
    from Java. You will see that there are lists, maps and sets just like in Java,
    but they are immutable. To work with these kinds of collections, you need a different
    approach; a different paradigm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将每个功能与您从 Java 中已知的进行比较来了解 Clojure。你会发现有列表、映射和集合，就像在 Java 中一样，但它们是不可变的。要处理这些类型的集合，你需要不同的方法；不同的范式。
- en: This is what we will try to accomplish in this book, to give you a different
    way to approach problems. We hope you end up using Clojure in your every day life,
    but if you don't, we hope you use a new approach toward problem solving.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这本书中试图达成的目标，给你提供一种不同的解决问题的方法。我们希望你在日常生活中使用 Clojure，但如果你不这样做，我们希望你在解决问题时采用一种新的方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting to know Clojure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Clojure
- en: Installing Leiningen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Leiningen
- en: Using a **Read Eval Print Loop** (**REPL**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **读取-评估-打印循环**（**REPL**）
- en: Installing and using Cursive Clojure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用 Cursive Clojure
- en: Clojure's simple syntax
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 的简单语法
- en: Clojure's data types and their relationship to the JVM's data types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 的数据类型及其与 JVM 数据类型的关系
- en: Special syntax for functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的特殊语法
- en: Getting to know Clojure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Clojure
- en: Before getting started with Clojure, you should know some of its features and
    what it shares with Java.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Clojure 之前，你应该了解一些它的特性以及它与 Java 的相似之处。
- en: Clojure is a programming language that inherits a lot of characteristics from
    Lisp. You might think of Lisp as that weird programming language with all the
    parentheses. You need to keep in mind that Clojure chooses to embrace functional
    programming. This makes it very different from current mainstream programming
    languages. You will get to know about immutable data structures and how to write
    programs without changing variable values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是一种从 Lisp 继承了许多特性的编程语言。你可能会把 Lisp 视为那种充满括号的奇怪编程语言。你需要记住的是，Clojure 选择拥抱函数式编程。这使得它与当前的主流编程语言非常不同。你将了解不可变数据结构以及如何编写不改变变量值的程序。
- en: You will also find that Clojure is a dynamic programming language, which makes
    it a little easier and faster to write programs than using statically typed languages.
    There is also the concept of using a REPL, a tool that allows you to connect to
    a program running environment and change code dynamically. It is a very powerful
    tool.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现 Clojure 是一种动态编程语言，这使得编写程序比使用静态类型语言更容易、更快。还有使用 REPL 的概念，这是一个允许你连接到正在运行的环境并动态更改代码的工具。这是一个非常强大的工具。
- en: At last, you will find out that you can convert Clojure to anything you like.
    You can create or use a statically typed system and bend the language to become
    what you like. A good example of this is the `core.typed` library, which allows
    you to specify the type information without adding support to the compiler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会发现你可以将 Clojure 转换为你喜欢的东西。你可以创建或使用静态类型系统，并使语言适应你的喜好。一个很好的例子是 `core.typed`
    库，它允许你指定类型信息，而无需向编译器添加支持。
- en: Installing Leiningen
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Leiningen
- en: We are used to having certain tools to help us build our code, such as Ant,
    Maven, and Gradle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于拥有某些工具来帮助我们构建代码，例如 Ant、Maven 和 Gradle。
- en: 'In the Clojure ecosystem, the de facto standard for dependency and build management
    is Leiningen (affectionately named after the short story "Leiningen versus the
    Ants", which I recommend reading at [http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants](http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants));
    Leiningen strives to be a familiar to Java developers, it gets the best ideas
    from Maven, like: convention over configuration. It also gets ideas from Ant like
    custom scripting and plugins.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 生态系统里，依赖和构建管理的默认标准是 Leiningen（亲切地以短篇小说《莱宁根对抗蚂蚁》命名，我推荐阅读[http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants](http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants)）；Leiningen
    努力成为对 Java 开发者来说熟悉的工具，它从 Maven 中汲取了最佳想法，比如：约定优于配置。它也从 Ant 中获得了灵感，比如自定义脚本和插件。
- en: Installing it is very simple, let's check how to do it on Mac OS X (installing
    on Linux should be the same) using bash as your default shell.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装非常简单，让我们看看如何在 Mac OS X 上使用 bash 作为默认 shell 来完成它（在 Linux 上的安装应该相同）。
- en: You should also have Java 7 or 8 already installed and configured in your path.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该已经安装并配置了Java 7或8在你的路径中。
- en: 'You can check the detailed instructions on the Leiningen project page [http://leiningen.org/](http://leiningen.org/).
    If you want to get a Leiningen installation up and running, this is what you would
    have to do:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Leiningen项目页面上查看详细说明[http://leiningen.org/](http://leiningen.org/)。如果你想安装并运行Leiningen，你需要做以下事情：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first time you run the `lein` command, it downloads everything needed from
    the internet. This makes it very easy to distribute your code, you can even include
    the `lein` script with your own projects and make it easier for other developers
    to get up and running, the only real requirement is the JDK.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行`lein`命令时，它会从互联网下载所有需要的文件。这使得分发你的代码变得非常容易，你甚至可以将`lein`脚本包含在你的项目中，使其他开发者更容易启动和运行，唯一真正的要求是JDK。
- en: Using a REPL
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REPL
- en: One of the main advantages of Clojure (and Lisp) is interactive development,
    the REPL is the base of what can be achieved with interactive programming, it
    allows you to connect to a running VM running Clojure and execute or modify code
    on the fly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure（以及Lisp）的主要优势之一是交互式开发，REPL是交互式编程可以实现的基石，它允许你连接到一个正在运行的Clojure VM，并实时执行或修改代码。
- en: There is a story about how NASA was able to debug and correct a bug on a $100
    million piece of hardware that was 100 million miles away ([http://www.flownet.com/gat/jpl-lisp.html](http://www.flownet.com/gat/jpl-lisp.html)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于NASA如何能够在100亿英里外的1000万美元的硬件上调试和纠正错误的故事([http://www.flownet.com/gat/jpl-lisp.html](http://www.flownet.com/gat/jpl-lisp.html))。
- en: 'We have that same power with Clojure and Leiningen and invoking it is very
    simple, you just need a single command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Clojure和Leiningen中也有同样的能力，调用它非常简单，你只需要一个命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is what you''ll get after running the preceding command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令后，你会得到以下内容：
- en: '![Using a REPL](img/00002.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用REPL](img/00002.jpeg)'
- en: 'Let''s go into a bit more detail, as we can see we are running with the following
    programs:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下，正如我们所看到的，我们正在运行以下程序：
- en: Java 8
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8
- en: Clojure 1.6.0
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 1.6.0
- en: We can also get some nice suggestions on how to see documentation, `source`,
    `Javadoc`, and previous errors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获得一些关于如何查看文档、`source`、`Javadoc`和以前错误的良好建议。
- en: The nREPL protocol
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nREPL协议
- en: One particular thing that is important to note is the nREPL protocol; Someday
    it might grant us the power to go into a machine running 100 million miles away.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特别需要注意的事情是nREPL协议；有一天它可能会赋予我们进入运行在100亿英里外的机器的能力。
- en: 'When you fire up your REPL, the first thing you see is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动你的REPL时，你首先看到的是：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What it is saying is that there's a Clojure process running an nREPL server
    on port `55995`. We have connected to it using a very simple client that allows
    us to interact with the Clojure process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它所表达的意思是，有一个Clojure进程在端口`55995`上运行nREPL服务器。我们已经通过一个非常简单的客户端连接到它，这个客户端允许我们与Clojure进程交互。
- en: 'The really interesting bit is that you can connect to a remote host just as
    easily; let''s try attaching an REPL to the same process by simply typing the
    following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的是，你可以像连接到远程主机一样轻松地连接；让我们尝试通过简单地输入以下命令将REPL附加到同一个进程：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most IDEs have a good integration with Clojure and most of them use this exact
    mechanism, as clients that work a little more intelligently.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IDE都与Clojure有很好的集成，它们中的大多数都使用这个机制，作为稍微智能一点的客户端。
- en: Hello world
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello world
- en: 'Now that we are inside the REPL, (any of the two) let''s try writing our first
    expression, go on and type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了REPL内部（任意一个），让我们尝试编写我们的第一个表达式，继续并输入：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should get back a value from the REPL saying `Hello world`, this is not
    really a program, and it is the `Hello world` value printed back by the print
    phase of the REPL.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从REPL得到一个返回值，显示`Hello world`，这实际上不是一个程序，而是REPL打印阶段的`Hello world`值。
- en: 'Let''s now try to write our first Lisp form:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试编写我们的第一个Lisp形式：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This first expression looks different from what we are used to, it is called
    an S-expression and it is the standard Lisp way.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个表达式与我们习惯的不同，它被称为S表达式，这是Lisp的标准方式。
- en: 'There are a couple of things to remember with S-expressions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在S表达式中，有几件事情需要记住：
- en: They are lists (hence, the name, Lisp)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是列表（因此，得名，Lisp）
- en: The first element of the list is the action that we want to execute, the rest
    are the parameters of that action (one two three).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的第一元素是我们想要执行的操作，其余的是该操作的参数（一个、两个、三个）。
- en: 'So we are asking for the string `Hello world` to be printed, but if we look
    a bit closer at the output, as shown in the following screenshot, there is a `nil`
    that we weren''t expecting:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们要求打印字符串 `Hello world`，但如果我们仔细观察输出，如图下所示，会出现一个我们未预期的 `nil`：
- en: '![Hello world](img/00003.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Hello world](img/00003.jpeg)'
- en: The reason for this is that the `println` function returns the value `nil` (Clojure's
    equivalent for null) after printing `Hello world`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 `println` 函数在打印 `Hello world` 后返回值 `nil`（Clojure的null等价物）。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Clojure, everything has a value and the REPL will always print it back for
    you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，一切都有值，REPL会始终为您打印它。
- en: REPL utilities and conventions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REPL实用工具和约定
- en: As we saw, the Leiningen nREPL client prints help text; but how does that work?
    Let's explore some of the other utilities that we have.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Leiningen nREPL客户端打印帮助文本；但它是如何工作的？让我们探索一些其他我们拥有的实用工具。
- en: 'Try each of them to get a feeling of what it does with the help of the following
    table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下表格中的每一个，以了解它们的功能：
- en: '| Function | Description | Sample |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `doc` | Prints out a function''s `docstring` | (`doc println`) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `doc` | 打印出函数的 `docstring` | (`doc println`) |'
- en: '| `source` | Prints a function''s source code, it must be written in Clojure
    | (`source println`) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `source` | 打印函数的源代码，它必须用Clojure编写 | (`source println`) |'
- en: '| `javadoc` | Open the `javadoc` for a class in the browser | (`javadoc java.lang.Integer`)
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `javadoc` | 在浏览器中打开类的 `javadoc` | (`javadoc java.lang.Integer`) |'
- en: 'Let''s check how these functions work:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些函数是如何工作的：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: What you are seeing here is metadata pertaining to the `doc` function; Clojure
    has the ability to store metadata about every function or `var` you use. Most
    of the Clojure core functions include a doc string and the source of the function
    and this is something that will become very handy in your day to day work.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的是与 `doc` 函数相关的元数据；Clojure具有存储您使用的每个函数或 `var` 的元数据的能力。大多数Clojure核心函数都包含一个doc字符串和函数的源代码，这在您日常工作中将非常有用。
- en: 'Besides these functions, we also get easy access to the latest three values
    and the latest exceptions that happened in the REPL, let''s check this out:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些函数外，我们还可以轻松访问REPL中最近的三条值和最近发生的异常，让我们来看看：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`*e` gives you access to the actual plain old Java exception object, so you
    can analyze and introspect it at runtime.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`*e` 使您能够访问实际的Java异常对象，因此您可以在运行时分析和检查它。'
- en: You can imagine the possibilities of being able to execute and introspect code
    with this, but what about the tools that we are already used to? How can we use
    this with an IDE?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以想象使用这种方式执行和检查代码的可能性，但关于我们已经习惯使用的工具呢？我们如何使用IDE来使用它？
- en: Let's check now how to create a new Clojure project, we'll use Leiningen from
    the command line to understand what is happening.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何创建一个新的Clojure项目，我们将使用命令行中的Leiningen来理解发生了什么。
- en: Creating a new project
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新项目
- en: Leiningen can help us create a new project using templates, there is a wide
    variety of templates available and you can build and distribute your own in Maven.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen可以帮助我们使用模板创建新项目，有各种各样的模板可供选择，您可以在Maven中构建和分发自己的模板。
- en: 'Some of the most common types of templates are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的模板类型包括：
- en: Creating a `jar` library (the default template)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `jar` 库（默认模板）
- en: Creating a command-line app
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命令行应用程序
- en: Creating a Clojure web app
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Clojure网络应用程序
- en: 'Let''s create a new Clojure command-line app and run it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Clojure命令行应用程序并运行它：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Project structure
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: Leiningen is similar to other Java development tools; it uses a similar convention
    and allows for heavy customizations in the `project.clj` file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen类似于其他Java开发工具；它使用类似的约定，并允许在 `project.clj` 文件中进行大量自定义。
- en: If you are familiar with Maven or Gradle, you can think of it as `pom.xml` or
    `build.gradle` respectively.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Maven或Gradle，您可以将其分别视为 `pom.xml` 或 `build.gradle`。
- en: 'The following screenshot is the project structure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是项目结构：
- en: '![Project structure](img/00004.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/00004.jpeg)'
- en: 'As you can see in the preceding screenshot, there are four main folders:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，有四个主要文件夹：
- en: '`resources`: It holds everything that should be in the class path, such as
    files, images, configuration files, properties files, and other resources needed
    at runtime.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`: 它包含应在类路径中的所有内容，例如文件、图像、配置文件、属性文件和其他在运行时需要的资源。'
- en: '`src`: Your Clojure source files; they are ordered in a very similar fashion
    to the `classpath`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 您的 Clojure 源文件；它们的排列方式与 `classpath` 非常相似。'
- en: '`dev-resources`: Everything that should be in the `classpath` in development
    (when you are running Leiningen). You can override your "production" files here
    and add files that are needed for tests to run.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev-resources`: 在开发中应位于 `classpath` 中的所有内容（当您运行 Leiningen 时）。您可以在此处覆盖您的“生产”文件，并添加运行测试所需的文件。'
- en: '`test`: Your tests; this code doesn''t get packaged but it is run every time
    you execute the Leiningen test.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 您的测试；此代码不会被打包，但每次您执行 Leiningen 测试时都会运行。'
- en: Creating a standalone app
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建独立应用程序
- en: 'Once your project is created, you can build and run a Java standalone command-line
    app quite easily, let''s try it now:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，您就可以非常容易地构建和运行 Java 独立命令行应用程序，现在让我们试试：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it is quite easy to create a standalone app and it is very similar
    to using Maven or Gradle.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建独立应用程序非常简单，并且与使用 Maven 或 Gradle 非常相似。
- en: Using Cursive Clojure
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cursive Clojure
- en: 'Java already has some great tools to help us be more productive and write higher
    quality code and we don''t need to forget about those tools. There are several
    plugins for Clojure depending on what your IDE is. Have a look at them from the
    following table:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java 已经有一些优秀的工具可以帮助我们提高生产力和编写更高质量的代码，我们不应该忘记这些工具。根据您的 IDE，有几个 Clojure 插件。请从以下表格中查看：
- en: '| IDE | Plugins |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| IDE | 插件 |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| IntelliJ | Cursive Clojure, La Clojure |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| IntelliJ | Cursive Clojure, La Clojure |'
- en: '| NetBeans | NetBeans Clojure (works with NetBeans 7.4) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| NetBeans | NetBeans Clojure (与 NetBeans 7.4 兼容) |'
- en: '| Eclipse | CounterClockwise |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| Eclipse | CounterClockwise |'
- en: '| Emacs | Cider |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Emacs | Cider |'
- en: '| VIM | vim-fireplace, vim-leiningen |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| VIM | vim-fireplace, vim-leiningen |'
- en: A lot of people writing real Clojure code use Emacs and I actually like using
    vim as my main development tool, but don't worry, our main IDE will be IntelliJ
    + Cursive Clojure throughout the book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编写真实 Clojure 代码的人使用 Emacs，我实际上喜欢使用 vim 作为我的主要开发工具，但不用担心，本书中我们将主要使用 IntelliJ
    + Cursive Clojure。
- en: Installing Cursive Clojure
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Cursive Clojure
- en: You can check the full documentation for Cursive at their website ([https://cursiveclojure.com/](https://cursiveclojure.com/)),
    it is still under development but it is quite stable and a great aid when writing
    Clojure code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在他们的网站上查看 Cursive 的完整文档（[https://cursiveclojure.com/](https://cursiveclojure.com/)），它仍在开发中，但相当稳定，在编写
    Clojure 代码时非常有帮助。
- en: We are going to use the latest IntelliJ Community Edition release, which at
    the time of this writing is version 14.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最新的 IntelliJ Community Edition 版本，在撰写本文时是版本 14。
- en: You can download IntelliJ from here [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里下载 IntelliJ：[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)。
- en: 'Installing Cursive Clojure is very simple, you need to add a repository for
    IntelliJ. You''ll find the instructions to your specific IntelliJ version here:
    [https://cursiveclojure.com/userguide/](https://cursiveclojure.com/userguide/).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Cursive Clojure 非常简单，您需要为 IntelliJ 添加一个仓库。您可以在以下位置找到您特定 IntelliJ 版本的说明：[https://cursiveclojure.com/userguide/](https://cursiveclojure.com/userguide/)。
- en: After you have installed Cursive Clojure, we are ready to go.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Cursive Clojure 后，我们就可以开始了。
- en: Now, we are ready to import our getting started project into Cursive Clojure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将入门项目导入到 Cursive Clojure 中。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Cursive Clojure doesn't currently have support to create Leiningen projects
    from within the IDE; however, support is great in order to import them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Cursive Clojure 目前不支持在 IDE 内创建 Leiningen 项目；然而，导入它们的支持非常好。
- en: 'Here is how you will do it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何操作的：
- en: Click on **File**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **文件**。
- en: Import project.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入项目。
- en: Look for your project.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找您的项目。
- en: Open the folder or the `project.clj` file.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件夹或 `project.clj` 文件。
- en: Follow the **Next** steps in the IDE.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IDE 中遵循 **下一步** 指令。
- en: 'Now, we are ready to go, you can use the Cursive Clojure as your main development
    tool. There are a few more things to do with your IDE but I recommend you to look
    for them; they are important and will come in handy:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了，你可以使用Cursive Clojure作为你的主要开发工具。在你的IDE中还有更多的事情要做，但我建议你自己去寻找它们；它们很重要，并且会很有用：
- en: To know how to execute the project
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何执行项目
- en: To know how to execute the tests
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何执行测试
- en: To open an REPL connected to some project.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个连接到某个项目的REPL。
- en: The key binding to execute some given piece of code (run form before cursor
    in REPL)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一些给定代码片段的关键绑定（在REPL中运行光标前的形式）
- en: The key binding to execute a given file (load file in REPL)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行指定文件的关键绑定（在REPL中加载文件）
- en: One important part of Clojure programming is that it can modify and reevaluate
    code in runtime. Check the manual of your current version of Clojure and check
    for the structural editing section ([https://cursiveclojure.com/userguide/paredit.html](https://cursiveclojure.com/userguide/paredit.html)).
    It is one of the most useful functionalities of Clojure IDEs and a direct consequence
    of the Clojure syntax.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure编程的一个重要部分是它可以在运行时修改和重新评估代码。检查你当前版本的Clojure手册，并查看结构编辑部分([https://cursiveclojure.com/userguide/paredit.html](https://cursiveclojure.com/userguide/paredit.html))。这是Clojure
    IDEs中最有用的功能之一，并且是Clojure语法的直接后果。
- en: I recommend you to check other functionalities from the manual. I really recommend
    checking the Cursive Clojure manual, it includes animations of how each functionality
    works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你查看手册中的其他功能。我真心建议查看Cursive Clojure手册，它包括每个功能如何工作的动画。
- en: You will use the last two key bindings quite a lot, so it is important to set
    them up correctly. There is more information about keybindings at [https://cursiveclojure.com/userguide/keybindings.html](https://cursiveclojure.com/userguide/keybindings.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你将非常频繁地使用最后两个键绑定，因此正确设置它们非常重要。有关键绑定的更多信息，请参阅[https://cursiveclojure.com/userguide/keybindings.html](https://cursiveclojure.com/userguide/keybindings.html)。
- en: Getting started with Clojure code and data
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Clojure代码和数据
- en: Let's take a deep dive into Clojure's syntax now, it is pretty different from
    other languages but it is actually much simpler. Lisps have a very regular syntax,
    with few special rules. As we said earlier, Clojure code is made of S-expressions
    and S-expressions are just lists. Let's look at some examples of lists to become
    familiar with lists in Lisp.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解Clojure的语法，它与其他语言非常不同，但实际上要简单得多。Lisp有非常规则的语法，只有很少的特殊规则。正如我们之前所说的，Clojure代码由S表达式组成，而S表达式只是列表。让我们看看一些列表的例子，以便熟悉Lisp中的列表。
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All of the above are lists, but not all of them are valid code. Remember, only
    lists where the first element is a function can be considered valid expressions.
    So, here only the following could be valid expressions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有都是列表，但并非所有都是有效的代码。记住，只有第一个元素是函数的列表才能被认为是有效的表达式。所以，这里只有以下可以是有效的表达式：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `println` and `one` are defined as functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`println`和`one`被定义为函数。
- en: Let's see a piece of Clojure code, to finally explain how everything works.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一段Clojure代码，最终解释一切是如何工作的。
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lists in Clojure
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure中的列表
- en: 'Clojure is based around "forms" or lists. In Clojure, same as every Lisp, the
    way to denote a list is with parentheses, so here are some examples of lists in
    the last code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure基于“形式”或列表。在Clojure中，与每个Lisp一样，表示列表的方式是用括号，所以这里有一些最后代码中的列表示例：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lists are one data type in Clojure and they are also the way to express code;
    you will learn later about all the benefits of expressing code as data. The first
    one is that it is really simple, anything you can do must be expressed as a list!
    Let''s look at some other examples of executable code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是Clojure中的一种数据类型，也是表达代码的方式；你将在以后了解将代码表达为数据的所有好处。第一个好处是它真的很简单，你可以做的任何事都必须以列表的形式表达出来！让我们看看其他一些可执行代码的例子：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I encourage you to write everything into the REPL, so you get a good notion
    of what's happening.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你将所有内容都写入REPL，这样你就能很好地理解正在发生的事情。
- en: Operations in Clojure
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure中的操作
- en: 'In Clojure, `MOST` of the executable forms have this structure:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，`MOST`的可执行形式都具有这种结构：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`op` is the operation to be executed followed by all the parameters it needs,
    let''s analyze each of our previous forms in this new light:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`op`是要执行的操作，后面跟着它需要的所有参数，让我们用新的眼光分析我们之前的每个形式：'
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are asking to execute the `+` (addition) operation with the parameters `1`,
    `2`, and `3`. The expected result is `6`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求执行`+`（加法）操作，参数为`1`、`2`和`3`。预期的结果是`6`。
- en: 'Let''s analyze something a bit more complicated:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一些更复杂的东西：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this, we are asking to execute the `clojure.core/map` function with two
    parameters:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们请求使用两个参数执行 `clojure.core/map` 函数：
- en: '`inc` is a function name, it takes a number and increments it'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inc` 是一个函数名，它接受一个数字并将其增加'
- en: '`[1 2 3 4 5 6]` is a collection of numbers'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1 2 3 4 5 6]` 是一组数字'
- en: Map applies the `inc` function to each member of the passed collection and returns
    a new collection, what we expect is a collection containing `[2 3 4 5 6 7]`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Map 将 `inc` 函数应用于传递的集合中的每个成员，并返回一个新的集合，我们期望的是一个包含 `[2 3 4 5 6 7]` 的集合。
- en: Functions in Clojure
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure 中的函数
- en: 'Now let''s check how a function definition is essentially the same as the previous
    two forms:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一个函数定义本质上与前面两个形式相同：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `defn` is the operation that we are asking for. It has several parameters,
    such as:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`defn` 是我们请求的操作。它有几个参数，例如：'
- en: '`some-function` is the name of the function that we are defining'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`some-function` 是我们定义的函数的名称'
- en: '`[times parameter]` is a collection of parameters'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[times 参数]` 是一组参数'
- en: '`"Prints a string certain number of times"` is the docstring, it is actually
    an optional parameter'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"打印字符串特定次数"` 是文档字符串，它实际上是一个可选参数'
- en: '`(dotimes [x times] (println parameter))` is the body of the function that
    gets executed when you call `some-function`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(dotimes [x times] (println parameter))` 是在调用 `some-function` 时执行的函数体'
- en: The `defn` calls a function into existence. After this piece of code is executed,
    `some-function` exists in the current namespace and you can use it with the defined
    parameters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`defn` 调用函数以使其存在。在这段代码执行之后，`some-function` 就存在于当前命名空间中，你可以使用它并传入定义好的参数。'
- en: 'The `defn` is actually written in Clojure and supports a few nice things. Let''s
    now define a `multi-arity` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`defn` 实际上是用 Clojure 编写的，并支持一些不错的东西。现在让我们定义一个 `multi-arity` 函数：'
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Over here we are defining a function with two bodies, one of them has no arguments
    and the other one has one argument. It is actually pretty simple to understand
    what's happening.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个具有两个主体的函数，其中一个没有参数，另一个有一个参数。实际上，理解所发生的事情相当简单。
- en: 'Try changing the source in your project''s `core.clj` file similar to the following
    example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改你项目 `core.clj` 文件中的源代码，类似于以下示例：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now run it, you'll get three different Hello outputs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它，你会得到三个不同的 Hello 输出。
- en: As you can see, Clojure has a very regular syntax and even if it's a little
    strange for newcomers, it is actually quite simple.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Clojure 有着非常规范的语法，即使对于新手来说可能有些奇怪，但实际上它相当简单。
- en: Here, we have used a few data types that we haven't properly introduced; in
    the next section we'll take a look at them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了几个尚未适当介绍的数据类型；在下一节中，我们将查看它们。
- en: Clojure's data types
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 的数据类型
- en: Now is when everything you know about Java pays off; even the list forms that
    you saw earlier implement the `java.util.List` interface. Clojure was designed
    to be embeddable and to have a great integration with the host platform, so it's
    only natural that you can use everything you already know about Java types and
    objects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是你所知道的关于 Java 的所有知识都能派上用场的时候了；甚至你之前看到的列表形式也实现了 `java.util.List` 接口。Clojure
    被设计成可嵌入的，并且与宿主平台有很好的集成，因此你可以使用你已知的所有关于 Java 类型和对象的知识。
- en: 'There are two data types in Clojure: scalars and collections.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 中有两种数据类型：标量和集合。
- en: Scalars
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标量
- en: In every language you need primitive types; you use them in everyday life as
    they represent numbers, strings, and Booleans. These primitive types are called
    scalars in the Clojure world.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种语言中，你都需要原始类型；你在日常生活中使用它们，因为它们代表数字、字符串和布尔值。在 Clojure 世界中，这些原始类型被称为标量。
- en: Clojure has a couple of very interesting types like ratios and keywords. In
    the following table, you get to know the different types of scalars, how they
    compare to Java and a simple example of how to use each of them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有一些非常有趣的类型，如比例和关键字。在下面的表中，你可以了解不同的标量类型，它们与 Java 的比较以及如何使用它们的简单示例。
- en: '| Clojure data type | Java data type | Sample | Description |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| Clojure 数据类型 | Java 数据类型 | 示例 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| String | String | "This is a string""This is a multiline string" | A string
    of characters; in Clojure you can use multiline strings without a problem |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 字符串 | "这是一个字符串""这是一个多行字符串" | 字符串字符；在 Clojure 中，你可以无问题使用多行字符串 |'
- en: '| Boolean | Boolean | truefalse | Literal Boolean values |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | 布尔值 | truefalse | 文字布尔值 |'
- en: '| Character | Character | `\c``\u0045 ;; Unicode char 45 E` | Character values,
    they are `java.lang.Character` instances, you can define Unicode characters |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 字符 | `\c``\u0045 ;; Unicode char 45 E` | 字符值，它们是 `java.lang.Character`
    实例，你可以定义 Unicode 字符 |'
- en: '| Keywords | Doesn''t exist in java | `:key``:sample``:some-keyword` | They
    evaluate themselves and they are often used as keys. They are also functions that
    look for themselves in a map. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | Java 中不存在 | `:key``:sample``:some-keyword` | 它们会自我评估，并且经常用作键。它们也是查找自己在映射中的函数。
    |'
- en: '| Number | Numbers are automatically handled as `BigDecimal`, `BigInteger`
    or lower precision depending on what''s necessary | `42N ;;Big Integer``42 ;;long``0.1M
    ;;BigDecimal` | It is important to remember the trade-offs of Java numbers, if
    precision is important, you should always use big decimals and `bigintegers`.
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | 数字会自动处理为 `BigDecimal`、`BigInteger` 或根据需要使用较低精度 | `42N ;;大整数``42 ;;long``0.1M
    ;;BigDecimal` | 记住 Java 数字的权衡很重要，如果精度很重要，你应该始终使用大数和 `bigintegers`。 |'
- en: '| Ratio | Doesn''t exist | `22/7` | Clojure provides great numerical precision;
    if necessary it can retain the ration and execute exact operation. The tradeoff
    when using ratios is speed. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 比率 | 不存在 | `22/7` | Clojure 提供了出色的数值精度；如果需要，它可以保留比率并执行精确操作。使用比率时的权衡是速度。 |'
- en: '| Symbol | Doesn''t exist | some-name | Symbols are identifiers in Clojure,
    very similar to a variable name in Java. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 不存在 | some-name | 符号是 Clojure 中的标识符，与 Java 中的变量名非常相似。 |'
- en: '| nil | null | nil | The null value |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| nil | null | nil | 空值 |'
- en: '| Regular expressions | `java.util.regex.Pattern` | `#"\d"` | Regular expressions,
    in Clojure you get free syntax to define regular expressions, but in the end it
    is a plain old Java reggae Pattern |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | `java.util.regex.Pattern` | `#"\d"` | 正则表达式，在 Clojure 中你可以免费使用语法来定义正则表达式，但最终它是一个普通的
    Java 正则表达式模式 |'
- en: Collection data types
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合数据类型
- en: 'In Clojure there are two types of collections: sequential and associative collections.
    Sequential are things you can iterate, such as lists. Associative collections
    are maps, sets, and things you can access by a certain index. Clojure''s collections
    are fully compatible with Java and it can even implement the `java.util` interfaces,
    such as `java.util.List` and `java.util.Map`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中有两种类型的集合：顺序集合和关联集合。顺序集合是可以迭代的，例如列表。关联集合是映射、集合以及你可以通过某个索引访问的东西。Clojure
    的集合与 Java 完全兼容，甚至可以实现 `java.util` 接口，如 `java.util.List` 和 `java.util.Map`。
- en: One of the main characteristics of collections in Clojure is that they are immutable;
    it has a lot of benefits that we'll see later.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 中集合的一个主要特征是它们是不可变的；它有很多好处，我们稍后会看到。
- en: Let's have a look at the characteristics of each collection data type available
    in Clojure and compare them with Java with the help of a sample (in Clojure) and
    its description.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Clojure 中可用的每种集合数据类型的特征，并使用示例（在 Clojure 中）及其描述与 Java 进行比较。
- en: '| Clojure data type | Java data type | Sample | Description |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| Clojure 数据类型 | Java 数据类型 | 示例 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `List` | `List` | `(1 2 3 4 5)` | A simple list, notice the quote character
    before the list, if you don''t specify it Clojure will try to evaluate the form
    as an instruction |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `List` | `List` | `(1 2 3 4 5)` | 一个简单的列表，注意列表前的引号字符，如果你没有指定它，Clojure 会尝试将形式评估为指令
    |'
- en: '| `Vector` | `Array` | `[1 2 3 4 5]` | It is the main workhorse in Clojure,
    it is similar to an array because you can access elements in a random order |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `Vector` | `Array` | `[1 2 3 4 5]` | 它是 Clojure 中的主要工作马，它类似于数组，因为你可以以随机顺序访问元素
    |'
- en: '| `Set` | `HashSet` | `#{1 2 3 4}` | A normal Java hash set |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `Set` | `HashSet` | `#{1 2 3 4}` | 一个普通的 Java 哈希集合 |'
- en: '| `Map` | `HashMap` | `{:key 5 :key-2 "red"}` | A Clojure map |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | `HashMap` | `{:key 5 :key-2 "red"}` | 一个 Clojure 映射 |'
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, Clojure has a mature development environment that is always
    evolving. You can set up command-line tools and your IDE in a very similar fashion
    to the way you will do in a normal Java development.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Clojure 拥有一个成熟且不断发展的开发环境。您可以以非常类似的方式设置命令行工具和您的 IDE，就像在正常的 Java 开发中做的那样。
- en: We also learned a little about Clojure's regular syntax, its data types and
    how they relate to Java's own data types.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了一些关于 Clojure 的常规语法、其数据类型以及它们与 Java 自身数据类型之间关系的内容。
- en: 'Overall, you should now be comfortable with:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，你现在应该对以下内容感到舒适：
- en: Lisp syntax
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp 语法
- en: Creating a Leiningen project from scratch
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建 Leiningen 项目
- en: Running and packaging your code
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和打包你的代码
- en: Importing a Leiningen project into IntelliJ
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Leiningen 项目导入 IntelliJ
- en: Using the REPL
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 REPL
- en: Knowing the relationship between Clojure types and Java types
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Clojure类型与Java类型之间的关系
- en: In the next chapter, we will get an idea of how to organize our code and how
    that organization takes advantage of Java packages.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何组织我们的代码，以及这种组织如何利用Java包的优势。
