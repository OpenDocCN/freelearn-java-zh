- en: Modularization and Main Screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of modularization is to decrease the complexity of a system.
    By dividing the functionality into many modules, developers can *forget* about
    parts of the system that are not relevant to the functionality under development.
    It also enables a more powerful deployment process by, for example, allowing activation
    of features depending on environments or customers, and the creation of third-party
    modules to customize and extend the capabilities of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrates how to modularize your applications to make them more
    manageable and maintainable, and how to implement a main screen that supports
    the registration of new modules at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularization of Vaadin applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of an application's main screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/VnLouE](https://goo.gl/VnLouE)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multi-module Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *multi-module* Maven project aggregates several Maven projects into a single
    one. In this chapter, we will create three modules that form the whole application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webapp`: A Vaadin web application packaged as a WAR file that includes everything
    needed to deploy it to a server such as Tomcat, Wildfly, Jetty, or any other Java
    server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api`: A Java API packaged as a JAR used by the webapp and any *functional
    module*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example-module`: An example *functional module* that uses the `api` JAR to
    add functionality to the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these modules are aggregated into a single Maven project with the name
    `chapter-02`. Let''s start by creating this aggregator project by using the `pom-root`
    Maven archetype. Run the following in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following properties when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupId`: `packt.vaadin.datacentric`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`artifactId`: `chapter-02`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: `1.0-SNAPSHOT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package`: `packt.vaadin.datacentric.chapter02`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using this archetype, Maven generates a `pom.xml` file for a top-level
    multi-module or aggregator project. You can remove the `<name>` tag as it’s redundant
    for our purposes. Modify the file to include a property for the Vaadin version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the code provided with this book, you'll find a `<parent>` section
    in the `pom.xml` file of the `chapter-02` project. This is because all the demo
    applications of the book have been aggregated into a single `Data-centric-Applications-with-Vaadin-8`
    Maven project for your convenience. You don’t need to add any `<parent>` sections
    to your project if you are following the steps in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This project (`chapter-02`) can be seen as the root directory for a full-blown
    application that contains several Maven modules, each one dedicated to a specific
    aspect of the functionality of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an application's main screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a concrete component: A main screen, something
    every web application needs. Please keep in mind that there''s not only one way
    of implementing main screens. The example presented here may be good for your
    own application, or it might inspire you to develop even more sophisticated implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main screen in this example consists of a *header*, a *menu,* and a *working
    area* where other components are shown when the user selects an option from the
    main menu. To the external world, this component should include the following
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding components to the header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding components to the working area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding options to the main menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding listeners to respond to menu actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting components from the working area and the header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an API for an application's main screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to explore and learn about API design in web development with Vaadin,
    let''s assume we want the main screen to be a general purpose component not intended
    to be used only in this demo application. For this reason, we need to provide
    the component in a separate JAR file. Start by creating a new Maven module inside
    the `chapter-02` project using the `maven-archetype-simple` archetype as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following properties when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupId: packt.vaadin.datacentric.chapter02`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`artifactId: api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version: 1.0-SNAPSHOT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package: packt.vaadin.datacentric.chapter02.api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check that the new `api` module is listed in the `chapter-02/pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Clean up as desired and add the Vaadin BOM and the `vaadin-server` dependency.
    You can also delete the generated `App` and `AppTest` classes. You will also need
    to configure Java 8 using properties, similar to how it was done in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full `pom.xml` file in the `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API should allow developers to create additional concrete main screen implementations
    with similar functionality. Abstracting this functionality can be done by defining
    a Java interface like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `ApplicationLayout` interface and related classes are located in the `Data-centric-Applications-with-Vaadin-8/chapter-02/api`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: This interface extends `Component`, so any concrete implementation can be used
    as a regular UI component and added into any Vaadin component container, such
    as `VerticalLayout`, for instance. Concrete implementations will extend `Composite`,
    as will be shown later.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing support classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous interface won''t compile. There are two classes that need to be
    implemented: `WorkingAreaComponent` and `MenuOption`. The `addWorkingAreaComponent(WorkingAreaComponent)`
    method expects a `WorkingAreaComponent` that encapsulates a caption and the corresponding
    Vaadin component to be shown. This interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `WorkingAreaComponent` class implements `Serializable`. Vaadin is mostly
    a server-side framework. Components are stored in HTTP sessions. In order to serialize
    the session, all contained objects must be `Serializable`. This serialization
    is done, for example, when you stop a web container such as Jetty or Tomcat. All
    HTTP sessions are serialized to the disk, and the next time the server starts,
    sessions are restored. Notice also how `SerializableConsumer` was used in the
    `ApplicationLayout` interface for the same reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Why is that needed? Why not simply let the `addWorkingAreaComponent(WorkingAreaComponent)`
    method have the parameters for the caption and component, as shown in the following
    snippet of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you were a hundred percent sure that a caption and a component are the only
    things you need to have when you add a new component to the working area, that
    would be fine. However, you don't know how concrete `ApplicationLayouts` will
    evolve. What if an icon is needed? What about a color or a help text?
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have decided to implement the method as `addWorkingAreaComponent(String,
    Component)` and some months after the component is released, some application
    that uses the component needs to have an icon for each component added into the
    working area. A possible solution is to modify the method to accept a new parameter
    for the icon, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This modification will break any existing client that references the old method's
    signature. Another approach is to overload the method by adding a new parameter.
    However, this will break all current implementations of `ApplicationLayout`. Encapsulating
    what is subject to change is always a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to encapsulate the parameters of `addWorkingAreaComponent(WorkingAreaComponent)`
    is the `getWorkingAreaComponents()` method. Suppose you want to implement a concrete
    `ApplicationLayout` that allows users to switch between tabs and windows. In order
    to implement this functionality, you need to get all the current components shown
    in the working area (using the `getWorkingAreaComponents(WorkingAreaComponent)`
    method) and place them in tabs or windows accordingly. For each component, you
    need to create a tab or a window, set its caption, and add the corresponding Vaadin
    component. You need both, the caption and the component. Encapsulating these objects
    in a single class greatly simplifies this task; otherwise, we would need to have
    an extra method that returns the captions as an ordered collection. Additionally,
    the `getWorkingAreaComponents()` method should return an ordered collection as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to notice about the `ApplicationLayout` class is the `addMenuOption(MenuOption,
    SerializableConsumer<MenuOption>)` method. This method expects a `MenuOption`
    (that encapsulates the caption to render) and a `SerializableConsumer` that serves
    as a click listener for the menu option. When the user clicks the option, the
    `Consumer.accept(MenuOption)` method is called, passing the clicked `MenuOption`
    as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`SerializableConsumer` is a serializable version of the `Consumer` class, a
    functional interface introduced in Java 8\. A functional interface has only one
    abstract method. This allows clients to create instances of the interface using
    lambda expressions. For more information about functional interfaces see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html](http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MenuOption` class can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a concrete application's main screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section explains how to implement and use a basic tab-based layout using
    the `ApplicationLayout` interface developed in the previous section. The layout
    includes a header on the top and a lateral menu on the left. When users click
    an option on the main menu a new component is added inside a new tab. The following
    is a screenshot of this layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1c3e7cb-52b4-472c-aaa4-66a94bcae509.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding and configuring the required UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create the required Vaadin UI components and configure
    them using the standard Vaadin API. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code to configure the UI elements is omitted, as it is not the purpose of
    this book to explain Vaadin UI components' basic usage and configuration. The
    full implementation can be found in the `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ApplicationLayout interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to implement the `ApplicationLayout` interface and add the
    required methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void addHeaderComponent(Component)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void addWorkingAreaComponent(WorkingAreaComponent)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<Component> getHeaderComponents()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<WorkingAreaComponent> getWorkingAreaComponents()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void addMenuOption(MenuOption, SerializableConsumer<MenuOption>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing the `addHeaderComponent(Component)` method is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addWorkingAreaComponent(WorkingAreaComponent)` method should avoid adding
    two tabs with the same caption. Instead of adding the same tab twice it should
    select the corresponding existing tab. A `Collection` is used to keep track of
    the added components, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because this concrete implementation is based on a `TabSheet` where each tab
    can or cannot be closed, it makes sense to overload the `ApplicationLayout.addWorkingAreaComponent(WorkingAreaComponent)`
    method to allow clients to specify this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting part of the previous code is the `showComponent(String)` method,
    which selects a tab by its caption. This method uses an `IntStream` to loop through
    the tabs in the `TabSheet`. This method is equivalent to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `showComponents(String)` uses two Java 8 features called
    streams and pipelines. For more information on streams and pipelines, see [http://docs.oracle.com/javase/tutorial/collections/streams/index.html](http://docs.oracle.com/javase/tutorial/collections/streams/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method to implement is `getHeaderComponents()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method uses an `IntStream` similar to the one in the `showComponent(String)`
    method. A `Collector` is used to create a `List` containing all the components
    in the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already have a `Collection` object with all the components in the
    working area, the `getWorkingAreaComponents()` method implementation is just a
    regular getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the menu work, we can implement the `addMenuOption(MenuOption, SerializableConsumer<MenuOption>)`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This method iterates over the `menuButtonStyles` collection to add each style
    to the new button. Lastly, the methods to set styles for menu options and also
    for the header should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The component is now ready! We can use it in any Vaadin application now. You
    can create a Vaadin application in a similar way as we did in the previous chapter,
    or use a standard Vaadin Maven archetype. The `chapter-02` module includes the
    `webapp` submodule, a Vaadin web application. The following is the init method
    of the `UI` implementation in the `webapp` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to add the `api` dependency to the `pom.xml` file of the `webapp`
    module before compiling and running the application again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although we have learned how to build a bare-bones main screen in the previous
    sections by using the core of Vaadin Framework, you should consider using the
    *SideMenu Add-on* published in the Vaadin Directory website ([https://vaadin.com/directory/component/sidemenu-add-on](https://vaadin.com/directory/component/sidemenu-add-on)).
    This component allows you to quickly implement side menus like the one in the
    official *dashboard demo* you can see at [https://demo.vaadin.com/dashboard](https://demo.vaadin.com/dashboard).
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing Vaadin applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we use the term module to refer to a software component that can
    be independently developed and deployed. In that sense, a modularized application
    can be customized and extended without distributing or modifying the source code
    of the original application. For our purposes, when a new module is deployed,
    it must register with the application. The functionality of the module is incorporated
    into the application at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there are also Maven modules. This book uses the full term
    Maven module or Maven project when referring to this kind of modules.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying alternatives for modularization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several mechanisms and ways of implementing modularized applications
    in Java. For example, you can use OSGi if you need to provide hot deployment—that
    is, the capability of deploying and un-deploying modules at runtime. Another option
    is **Service Provider Interface** (**SPI**), a set of standard interfaces and
    classes included in Java SE that help with the development of extensible applications.
    You can even use **Contexts and Dependency Injection** (**CDI**) or an *inversion
    of control* framework such as the one provided by the Spring Framework to develop
    a custom module system based on the injection mechanism. Moreover, you could go
    down to the Java Reflection API to create instances of classes not known at compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because explaining all these alternatives is out of the scope of this book,
    we''ll use the simplest alternative: SPI.'
  prefs: []
  type: TYPE_NORMAL
- en: Registering modules with the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Registering a module with the application means adding the module''s functionality
    into the application. What this module registration performs depends on the application''s
    requirements. For example, if the application includes a main menu, then a possible
    registration action for a module is to add menu items to the main menu. If the
    application is based on tabs, a possible registration action can be adding tabs
    to the main screen. All these actions need to be performed through a shared API.
    Take the example of adding a menu item. In this case, a possible interface could
    be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Modules can implement this interface to add menu items into the existing application's
    main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we already have an `ApplicationLayout` interface, which defines methods
    to manipulate the layout, the following interface is good enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `AppModule` interface is located in the `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This interface can be packaged in a separate JAR file so it can be distributed
    to any third-party developers. This JAR should contain all the classes and interfaces
    that could be needed by module implementations. This is the reason we previously
    created the `api` Maven module. There also is another advantage: The `api` JAR
    can be distributed to third-party developers to allow them to create new functionality
    for the application without distributing the whole compiled code of your web application.'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `webapp` application should detect all the implementations of `AppModule`
    at run-time. For each implementation, it should create a new instance and call
    the `register(ApplicationLayout)` method. Doing this with Java SPI is surprisingly
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ServiceLoader` class is used to discover all the classes that implement
    the `AppModule` interface. For each module, we call its `register` method, passing
    the layout of the application to give the module the chance to initialize itself
    and modify the layout if required.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing new modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New modules have to implement the `AppModule` interface and follow the SPI requirements
    for packaging by adding a new file with the name `packt.vaadin.datacentric.chapter02.api.AppModule`
    into the `META-INF/services` directory. This file must contain the name of the
    fully qualified name of the `AppModule` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to develop a module that adds an option to the main menu
    that shows a notification when clicked. This can be easily implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This class can be located in a separate Maven project and should include the
    `api` dependency.
  prefs: []
  type: TYPE_NORMAL
- en: The `ExampleModule` implementation is located in the `Data-centric-Applications-with-Vaadin-8\chapter-02\example-module`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the module discoverable by the `webapp` application, you must add a
    file with the name `packt.vaadin.datacentric.chapter02.api.AppModule` in the `main/resources/META-INF/services`
    directory of the new module. The file must contain the fully-qualified name of
    the `AppModule` implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once packaged, you can deploy the JAR file independently and the `webapp` application
    should automatically discover and register the module.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy a module with the web application, you can add it as a dependency
    in the `pom.xml` file of the `Data-centric-Applications-with-Vaadin-8/chapter-02/webapp`
    Maven project. If you are deploying the application as a WAR file to a servlet
    container, you can add the JAR to the `WEB-INF/lib` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the application, showing the example module
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5732e1cf-2f64-419e-9da7-9719ddbecada.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a self-packaged UI component (a *main screen*
    component), created a multi-module Maven project, and learned how to implement
    application-specific modules that are discovered and registered with a Vaadin
    application at run-time. While explaining these concepts, we also saw some Java
    8 and Vaadin 8 snippets of code that highlighted good practices such as making
    your code more maintainable and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to implement a login form with multi-language
    capabilities.
  prefs: []
  type: TYPE_NORMAL
