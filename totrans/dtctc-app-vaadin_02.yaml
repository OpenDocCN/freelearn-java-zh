- en: Modularization and Main Screens
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化和主屏幕
- en: The main purpose of modularization is to decrease the complexity of a system.
    By dividing the functionality into many modules, developers can *forget* about
    parts of the system that are not relevant to the functionality under development.
    It also enables a more powerful deployment process by, for example, allowing activation
    of features depending on environments or customers, and the creation of third-party
    modules to customize and extend the capabilities of the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的主要目的是降低系统的复杂性。通过将功能划分为多个模块，开发者可以 *忘记* 与正在开发的功能不相关的系统部分。它还通过例如允许根据环境或客户激活功能，以及创建第三方模块以自定义和扩展应用程序的功能等方式，使部署过程更加高效。
- en: This chapter demonstrates how to modularize your applications to make them more
    manageable and maintainable, and how to implement a main screen that supports
    the registration of new modules at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了如何模块化您的应用程序以使其更易于管理和维护，以及如何实现一个支持在运行时注册新模块的主屏幕。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Modularization of Vaadin applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vaadin 应用程序的模块化
- en: Implementation of an application's main screens
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序主屏幕的实现
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要拥有 Java SE 开发工具包和 Java EE 开发工具包版本 8 或更高版本。您还需要 Maven 版本 3 或更高版本。建议使用具有 Maven
    支持的 Java IDE，例如 IntelliJ IDEA、Eclipse 或 NetBeans。最后，为了使用本书的 Git 仓库，您需要安装 Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[https://goo.gl/VnLouE](https://goo.gl/VnLouE)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/VnLouE](https://goo.gl/VnLouE)'
- en: Creating a multi-module Maven project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多模块 Maven 项目
- en: 'A *multi-module* Maven project aggregates several Maven projects into a single
    one. In this chapter, we will create three modules that form the whole application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *多模块* Maven 项目将多个 Maven 项目聚合为一个单一的项目。在本章中，我们将创建三个模块，形成一个完整的应用程序：
- en: '`webapp`: A Vaadin web application packaged as a WAR file that includes everything
    needed to deploy it to a server such as Tomcat, Wildfly, Jetty, or any other Java
    server'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webapp`: 一个打包为 WAR 文件的 Vaadin 网络应用程序，包括部署到服务器（如 Tomcat、Wildfly、Jetty 或任何其他
    Java 服务器）所需的一切'
- en: '`api`: A Java API packaged as a JAR used by the webapp and any *functional
    module*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`: 一个打包为 JAR 的 Java API，由 webapp 和任何 *功能模块* 使用'
- en: '`example-module`: An example *functional module* that uses the `api` JAR to
    add functionality to the application'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example-module`: 一个使用 `api` JAR 添加应用程序功能的 *功能模块* 示例'
- en: 'All these modules are aggregated into a single Maven project with the name
    `chapter-02`. Let''s start by creating this aggregator project by using the `pom-root`
    Maven archetype. Run the following in a terminal:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模块都聚合到一个名为 `chapter-02` 的单个 Maven 项目中。让我们首先使用 `pom-root` Maven 架构创建这个聚合项目。在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the following properties when prompted:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，请使用以下属性：
- en: '`groupId`: `packt.vaadin.datacentric`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupId`: `packt.vaadin.datacentric`'
- en: '`artifactId`: `chapter-02`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`artifactId`: `chapter-02`'
- en: '`version`: `1.0-SNAPSHOT`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: `1.0-SNAPSHOT`'
- en: '`package`: `packt.vaadin.datacentric.chapter02`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`: `packt.vaadin.datacentric.chapter02`'
- en: 'When using this archetype, Maven generates a `pom.xml` file for a top-level
    multi-module or aggregator project. You can remove the `<name>` tag as it’s redundant
    for our purposes. Modify the file to include a property for the Vaadin version:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此架构时，Maven 为顶级多模块或聚合项目生成一个 `pom.xml` 文件。您可以删除 `<name>` 标签，因为它对我们来说是不必要的。修改文件以包含一个用于
    Vaadin 版本的属性：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that in the code provided with this book, you'll find a `<parent>` section
    in the `pom.xml` file of the `chapter-02` project. This is because all the demo
    applications of the book have been aggregated into a single `Data-centric-Applications-with-Vaadin-8`
    Maven project for your convenience. You don’t need to add any `<parent>` sections
    to your project if you are following the steps in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本书提供的代码中，您会在`chapter-02`项目的`pom.xml`文件中找到一个`<parent>`部分。这是因为本书的所有演示应用程序都已聚合到一个单独的`Data-centric-Applications-with-Vaadin-8`
    Maven项目中，以便您使用。如果您遵循本章中的步骤，则不需要在项目中添加任何`<parent>`部分。
- en: This project (`chapter-02`) can be seen as the root directory for a full-blown
    application that contains several Maven modules, each one dedicated to a specific
    aspect of the functionality of the system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目（`chapter-02`）可以被视为一个完整应用程序的根目录，该应用程序包含多个Maven模块，每个模块都致力于系统功能的一个特定方面。
- en: Implementing an application's main screen
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现应用程序的主屏幕
- en: 'Let''s start by implementing a concrete component: A main screen, something
    every web application needs. Please keep in mind that there''s not only one way
    of implementing main screens. The example presented here may be good for your
    own application, or it might inspire you to develop even more sophisticated implementations.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个具体组件开始：一个主屏幕，这是每个Web应用程序都需要的东西。请记住，实现主屏幕的方式不止一种。这里提供的示例可能适合您的应用程序，或者它可能激发您开发更复杂的实现。
- en: 'The main screen in this example consists of a *header*, a *menu,* and a *working
    area* where other components are shown when the user selects an option from the
    main menu. To the external world, this component should include the following
    functionality:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中的主屏幕主要由一个*标题栏*、一个*菜单*和一个*工作区域*组成，当用户从主菜单中选择一个选项时，其他组件会显示在工作区域中。对于外部世界来说，这个组件应该包括以下功能：
- en: Adding components to the header
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向标题栏添加组件
- en: Adding components to the working area
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向工作区域添加组件
- en: Adding options to the main menu
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向主菜单添加选项
- en: Adding listeners to respond to menu actions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加监听器以响应用户操作
- en: Getting components from the working area and the header
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从工作区域和标题栏获取组件
- en: Defining an API for an application's main screen
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序主屏幕的API
- en: 'In order to explore and learn about API design in web development with Vaadin,
    let''s assume we want the main screen to be a general purpose component not intended
    to be used only in this demo application. For this reason, we need to provide
    the component in a separate JAR file. Start by creating a new Maven module inside
    the `chapter-02` project using the `maven-archetype-simple` archetype as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索和学习使用Vaadin进行Web开发中的API设计，让我们假设我们希望主屏幕是一个通用组件，不仅仅用于这个演示应用程序。因此，我们需要将组件提供在一个单独的JAR文件中。首先，在`chapter-02`项目中使用`maven-archetype-simple`存档创建一个新的Maven模块，如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the following properties when prompted:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，请使用以下属性：
- en: '`groupId: packt.vaadin.datacentric.chapter02`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupId: packt.vaadin.datacentric.chapter02`'
- en: '`artifactId: api`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`artifactId: api`'
- en: '`version: 1.0-SNAPSHOT`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version: 1.0-SNAPSHOT`'
- en: '`package: packt.vaadin.datacentric.chapter02.api`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package: packt.vaadin.datacentric.chapter02.api`'
- en: 'Check that the new `api` module is listed in the `chapter-02/pom.xml` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 确认新的`api`模块已列在`chapter-02/pom.xml`文件中：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clean up as desired and add the Vaadin BOM and the `vaadin-server` dependency.
    You can also delete the generated `App` and `AppTest` classes. You will also need
    to configure Java 8 using properties, similar to how it was done in the previous
    chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要清理，并添加Vaadin BOM和`vaadin-server`依赖项。您还可以删除生成的`App`和`AppTest`类。您还需要使用属性配置Java
    8，类似于上一章中所述的方法。
- en: You can find the full `pom.xml` file in the `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven project of the source code that accompanies this book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书所附源代码的`Data-centric-Applications-with-Vaadin-8\chapter-02\api` Maven项目的`pom.xml`文件中找到完整的`pom.xml`文件。
- en: 'The API should allow developers to create additional concrete main screen implementations
    with similar functionality. Abstracting this functionality can be done by defining
    a Java interface like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: API应该允许开发者创建具有类似功能的其他具体主屏幕实现。可以通过定义以下Java接口来抽象这个功能：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ApplicationLayout` interface and related classes are located in the `Data-centric-Applications-with-Vaadin-8/chapter-02/api`
    Maven project of the source code that accompanies this book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationLayout`接口和相关类位于本书所附源代码的`Data-centric-Applications-with-Vaadin-8/chapter-02/api`
    Maven项目中。'
- en: This interface extends `Component`, so any concrete implementation can be used
    as a regular UI component and added into any Vaadin component container, such
    as `VerticalLayout`, for instance. Concrete implementations will extend `Composite`,
    as will be shown later.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口扩展了 `Component`，因此任何具体的实现都可以用作常规 UI 组件，并添加到任何 Vaadin 组件容器中，例如 `VerticalLayout`。具体的实现将扩展
    `Composite`，这将在稍后展示。
- en: Implementing support classes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现支持类
- en: 'The previous interface won''t compile. There are two classes that need to be
    implemented: `WorkingAreaComponent` and `MenuOption`. The `addWorkingAreaComponent(WorkingAreaComponent)`
    method expects a `WorkingAreaComponent` that encapsulates a caption and the corresponding
    Vaadin component to be shown. This interface is defined as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的界面无法编译。需要实现两个类：`WorkingAreaComponent` 和 `MenuOption`。`addWorkingAreaComponent(WorkingAreaComponent)`
    方法期望传入一个 `WorkingAreaComponent`，它封装了一个标题和要显示的相应的 Vaadin 组件。此接口定义如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `WorkingAreaComponent` class implements `Serializable`. Vaadin is mostly
    a server-side framework. Components are stored in HTTP sessions. In order to serialize
    the session, all contained objects must be `Serializable`. This serialization
    is done, for example, when you stop a web container such as Jetty or Tomcat. All
    HTTP sessions are serialized to the disk, and the next time the server starts,
    sessions are restored. Notice also how `SerializableConsumer` was used in the
    `ApplicationLayout` interface for the same reasons.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkingAreaComponent` 类实现了 `Serializable` 接口。Vaadin 主要是一个服务器端框架。组件存储在 HTTP
    会话中。为了序列化会话，所有包含的对象都必须是 `Serializable` 的。例如，在停止像 Jetty 或 Tomcat 这样的 Web 容器时，会进行这种序列化。所有
    HTTP 会话都会序列化到磁盘，下次服务器启动时，会话会被恢复。注意，`SerializableConsumer` 在 `ApplicationLayout`
    接口中也是出于同样的原因被使用的。'
- en: Why is that needed? Why not simply let the `addWorkingAreaComponent(WorkingAreaComponent)`
    method have the parameters for the caption and component, as shown in the following
    snippet of code?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要这样做？为什么不简单地将 `addWorkingAreaComponent(WorkingAreaComponent)` 方法的参数设置为标题和组件，就像以下代码片段所示？
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you were a hundred percent sure that a caption and a component are the only
    things you need to have when you add a new component to the working area, that
    would be fine. However, you don't know how concrete `ApplicationLayouts` will
    evolve. What if an icon is needed? What about a color or a help text?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你百分之百确定，当你向工作区域添加新组件时，只需要一个标题和一个组件，那就没问题。然而，你不知道具体的 `ApplicationLayouts` 将如何发展。如果需要图标怎么办？颜色或帮助文本呢？
- en: 'Suppose you have decided to implement the method as `addWorkingAreaComponent(String,
    Component)` and some months after the component is released, some application
    that uses the component needs to have an icon for each component added into the
    working area. A possible solution is to modify the method to accept a new parameter
    for the icon, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经决定将方法实现为 `addWorkingAreaComponent(String, Component)`，几个月后，某个使用该组件的应用程序需要为添加到工作区域中的每个组件提供一个图标。一个可能的解决方案是将方法修改为接受一个用于图标的新的参数，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This modification will break any existing client that references the old method's
    signature. Another approach is to overload the method by adding a new parameter.
    However, this will break all current implementations of `ApplicationLayout`. Encapsulating
    what is subject to change is always a good idea.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改将破坏任何引用旧方法签名的现有客户端。另一种方法是通过添加新参数来重载方法。然而，这将破坏所有当前的 `ApplicationLayout` 实现。封装可能发生变化的内容总是一个好主意。
- en: Another reason to encapsulate the parameters of `addWorkingAreaComponent(WorkingAreaComponent)`
    is the `getWorkingAreaComponents()` method. Suppose you want to implement a concrete
    `ApplicationLayout` that allows users to switch between tabs and windows. In order
    to implement this functionality, you need to get all the current components shown
    in the working area (using the `getWorkingAreaComponents(WorkingAreaComponent)`
    method) and place them in tabs or windows accordingly. For each component, you
    need to create a tab or a window, set its caption, and add the corresponding Vaadin
    component. You need both, the caption and the component. Encapsulating these objects
    in a single class greatly simplifies this task; otherwise, we would need to have
    an extra method that returns the captions as an ordered collection. Additionally,
    the `getWorkingAreaComponents()` method should return an ordered collection as
    well.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 `addWorkingAreaComponent(WorkingAreaComponent)` 方法的参数的另一个原因是 `getWorkingAreaComponents()`
    方法。假设你想实现一个具体的 `ApplicationLayout`，允许用户在标签页和窗口之间切换。为了实现这个功能，你需要获取当前显示在工作区域中的所有组件（使用
    `getWorkingAreaComponents(WorkingAreaComponent)` 方法），并将它们相应地放置在标签页或窗口中。对于每个组件，你需要创建一个标签页或窗口，设置其标题，并添加相应的
    Vaadin 组件。你需要标题和组件。将这些对象封装在单个类中可以极大地简化这项任务；否则，我们需要有一个额外的方法来返回有序集合形式的标题。此外，`getWorkingAreaComponents()`
    方法也应该返回一个有序集合。
- en: The last thing to notice about the `ApplicationLayout` class is the `addMenuOption(MenuOption,
    SerializableConsumer<MenuOption>)` method. This method expects a `MenuOption`
    (that encapsulates the caption to render) and a `SerializableConsumer` that serves
    as a click listener for the menu option. When the user clicks the option, the
    `Consumer.accept(MenuOption)` method is called, passing the clicked `MenuOption`
    as its parameter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `ApplicationLayout` 类需要注意的最后一件事是 `addMenuOption(MenuOption, SerializableConsumer<MenuOption>)`
    方法。此方法期望一个 `MenuOption`（封装要渲染的标题）和一个 `SerializableConsumer`，它作为菜单选项的点击监听器。当用户点击选项时，会调用
    `Consumer.accept(MenuOption)` 方法，并将点击的 `MenuOption` 作为其参数传递。
- en: '`SerializableConsumer` is a serializable version of the `Consumer` class, a
    functional interface introduced in Java 8\. A functional interface has only one
    abstract method. This allows clients to create instances of the interface using
    lambda expressions. For more information about functional interfaces see:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`SerializableConsumer` 是 `Consumer` 类的可序列化版本，它是 Java 8 中引入的一种函数式接口。函数式接口只有一个抽象方法。这允许客户端使用
    lambda 表达式创建接口的实例。有关函数式接口的更多信息，请参阅：'
- en: '[http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html](http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html](http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html).'
- en: 'The `MenuOption` class can be implemented as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuOption` 类可以按照以下方式实现：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implementing a concrete application's main screen
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现具体应用程序的主屏幕
- en: 'This section explains how to implement and use a basic tab-based layout using
    the `ApplicationLayout` interface developed in the previous section. The layout
    includes a header on the top and a lateral menu on the left. When users click
    an option on the main menu a new component is added inside a new tab. The following
    is a screenshot of this layout:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何使用上一节中开发的 `ApplicationLayout` 接口实现和使用基本的基于标签的布局。布局包括顶部的标题和左侧的侧边菜单。当用户在主菜单上点击选项时，会在新的标签页内添加一个新的组件。以下是这个布局的截图：
- en: '![](img/e1c3e7cb-52b4-472c-aaa4-66a94bcae509.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1c3e7cb-52b4-472c-aaa4-66a94bcae509.png)'
- en: Adding and configuring the required UI components
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和配置所需的 UI 组件
- en: 'The first step is to create the required Vaadin UI components and configure
    them using the standard Vaadin API. This can be done as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建所需的 Vaadin UI 组件，并使用标准 Vaadin API 进行配置。这可以按照以下方式完成：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code to configure the UI elements is omitted, as it is not the purpose of
    this book to explain Vaadin UI components' basic usage and configuration. The
    full implementation can be found in the `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven project of the source code that accompanies this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 UI 元素的代码被省略了，因为本书的目的不是解释 Vaadin UI 组件的基本使用和配置。完整的实现可以在本书附带的源代码的 `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven 项目中找到。
- en: Implementing the ApplicationLayout interface
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 ApplicationLayout 接口
- en: 'The next step is to implement the `ApplicationLayout` interface and add the
    required methods:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现 `ApplicationLayout` 接口并添加所需的方法：
- en: '`void addHeaderComponent(Component)`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void addHeaderComponent(Component)`'
- en: '`void addWorkingAreaComponent(WorkingAreaComponent)`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void addWorkingAreaComponent(WorkingAreaComponent)`'
- en: '`Collection<Component> getHeaderComponents()`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<Component> getHeaderComponents()`'
- en: '`Collection<WorkingAreaComponent> getWorkingAreaComponents()`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<WorkingAreaComponent> getWorkingAreaComponents()`'
- en: '`void addMenuOption(MenuOption, SerializableConsumer<MenuOption>)`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void addMenuOption(MenuOption, SerializableConsumer<MenuOption>)`'
- en: 'Implementing the `addHeaderComponent(Component)` method is quite straightforward:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`addHeaderComponent(Component)`方法相当直接：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `addWorkingAreaComponent(WorkingAreaComponent)` method should avoid adding
    two tabs with the same caption. Instead of adding the same tab twice it should
    select the corresponding existing tab. A `Collection` is used to keep track of
    the added components, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`addWorkingAreaComponent(WorkingAreaComponent)`方法应避免添加具有相同标题的两个标签页。而不是两次添加相同的标签页，它应该选择相应的现有标签页。使用`Collection`来跟踪添加的组件，如下面的代码所示：'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because this concrete implementation is based on a `TabSheet` where each tab
    can or cannot be closed, it makes sense to overload the `ApplicationLayout.addWorkingAreaComponent(WorkingAreaComponent)`
    method to allow clients to specify this behavior.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个具体实现基于一个`TabSheet`，其中每个标签页可以关闭或不能关闭，因此重载`ApplicationLayout.addWorkingAreaComponent(WorkingAreaComponent)`方法以允许客户端指定此行为是有意义的。
- en: 'An interesting part of the previous code is the `showComponent(String)` method,
    which selects a tab by its caption. This method uses an `IntStream` to loop through
    the tabs in the `TabSheet`. This method is equivalent to the following one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中一个有趣的部分是`showComponent(String)`方法，该方法通过标题选择标签页。此方法使用`IntStream`遍历`TabSheet`中的标签页。此方法等同于以下方法：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The implementation of `showComponents(String)` uses two Java 8 features called
    streams and pipelines. For more information on streams and pipelines, see [http://docs.oracle.com/javase/tutorial/collections/streams/index.html](http://docs.oracle.com/javase/tutorial/collections/streams/index.html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`showComponents(String)` 方法的实现使用了两个Java 8特性：流和管道。有关流和管道的更多信息，请参阅[http://docs.oracle.com/javase/tutorial/collections/streams/index.html](http://docs.oracle.com/javase/tutorial/collections/streams/index.html)。'
- en: 'The next method to implement is `getHeaderComponents()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要实现的方法是`getHeaderComponents()`：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method uses an `IntStream` similar to the one in the `showComponent(String)`
    method. A `Collector` is used to create a `List` containing all the components
    in the header.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用与`showComponent(String)`方法中类似的`IntStream`。使用`Collector`创建一个包含标题中所有组件的`List`。
- en: 'Since we already have a `Collection` object with all the components in the
    working area, the `getWorkingAreaComponents()` method implementation is just a
    regular getter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个包含工作区域所有组件的`Collection`对象，因此`getWorkingAreaComponents()`方法的实现只是一个常规的getter：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Implementing the menu
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现菜单
- en: 'To make the menu work, we can implement the `addMenuOption(MenuOption, SerializableConsumer<MenuOption>)`
    method as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使菜单正常工作，我们可以按照以下方式实现`addMenuOption(MenuOption, SerializableConsumer<MenuOption>)`方法：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This method iterates over the `menuButtonStyles` collection to add each style
    to the new button. Lastly, the methods to set styles for menu options and also
    for the header should look as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历`menuButtonStyles`集合，将每个样式添加到新按钮中。最后，设置菜单选项和标题样式的相关方法应如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The component is now ready! We can use it in any Vaadin application now. You
    can create a Vaadin application in a similar way as we did in the previous chapter,
    or use a standard Vaadin Maven archetype. The `chapter-02` module includes the
    `webapp` submodule, a Vaadin web application. The following is the init method
    of the `UI` implementation in the `webapp` module:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 组件现在已准备就绪！我们可以在任何Vaadin应用程序中使用它。您可以通过与上一章类似的方式创建Vaadin应用程序，或者使用标准的Vaadin Maven存档。`chapter-02`模块包括`webapp`子模块，一个Vaadin网络应用程序。以下是在`webapp`模块中`UI`实现的初始化方法：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remember to add the `api` dependency to the `pom.xml` file of the `webapp`
    module before compiling and running the application again:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译和再次运行应用程序之前，请记住将`api`依赖项添加到`webapp`模块的`pom.xml`文件中：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although we have learned how to build a bare-bones main screen in the previous
    sections by using the core of Vaadin Framework, you should consider using the
    *SideMenu Add-on* published in the Vaadin Directory website ([https://vaadin.com/directory/component/sidemenu-add-on](https://vaadin.com/directory/component/sidemenu-add-on)).
    This component allows you to quickly implement side menus like the one in the
    official *dashboard demo* you can see at [https://demo.vaadin.com/dashboard](https://demo.vaadin.com/dashboard).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前几节中我们已经通过使用 Vaadin 框架的核心学习了如何构建一个裸骨的主屏幕，但你应该考虑使用在 Vaadin 目录网站发布的 *SideMenu
    Add-on*（[https://vaadin.com/directory/component/sidemenu-add-on](https://vaadin.com/directory/component/sidemenu-add-on)）。这个组件允许你快速实现类似于在官方
    *dashboard demo* 中的侧菜单，你可以在 [https://demo.vaadin.com/dashboard](https://demo.vaadin.com/dashboard)
    上看到这个 demo。
- en: Modularizing Vaadin applications
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化 Vaadin 应用程序
- en: In this book, we use the term module to refer to a software component that can
    be independently developed and deployed. In that sense, a modularized application
    can be customized and extended without distributing or modifying the source code
    of the original application. For our purposes, when a new module is deployed,
    it must register with the application. The functionality of the module is incorporated
    into the application at runtime.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用术语模块来指代一个可以独立开发和部署的软件组件。从这个意义上讲，模块化应用程序可以在不分发或修改原始应用程序源代码的情况下进行定制和扩展。就我们的目的而言，当一个新的模块被部署时，它必须向应用程序注册。模块的功能在运行时被整合到应用程序中。
- en: Keep in mind that there are also Maven modules. This book uses the full term
    Maven module or Maven project when referring to this kind of modules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，也存在 Maven 模块。本书在提到这类模块时使用完整的术语 Maven 模块或 Maven 项目。
- en: Identifying alternatives for modularization
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别模块化的替代方案
- en: There are several mechanisms and ways of implementing modularized applications
    in Java. For example, you can use OSGi if you need to provide hot deployment—that
    is, the capability of deploying and un-deploying modules at runtime. Another option
    is **Service Provider Interface** (**SPI**), a set of standard interfaces and
    classes included in Java SE that help with the development of extensible applications.
    You can even use **Contexts and Dependency Injection** (**CDI**) or an *inversion
    of control* framework such as the one provided by the Spring Framework to develop
    a custom module system based on the injection mechanism. Moreover, you could go
    down to the Java Reflection API to create instances of classes not known at compile
    time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中实现模块化应用程序有几种机制和方法。例如，如果你需要提供热部署——即运行时部署和卸载模块的能力，你可以使用 OSGi。另一个选项是 **服务提供者接口**（**SPI**），它是
    Java SE 中包含的一组标准接口和类，有助于开发可扩展的应用程序。你甚至可以使用 **上下文和依赖注入**（**CDI**）或一个 *控制反转* 框架，例如
    Spring 框架提供的框架，来开发基于注入机制的定制模块系统。此外，你还可以使用 Java 反射 API 来创建编译时未知的类的实例。
- en: 'Because explaining all these alternatives is out of the scope of this book,
    we''ll use the simplest alternative: SPI.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解释所有这些替代方案超出了本书的范围，我们将使用最简单的替代方案：SPI。
- en: Registering modules with the application
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中注册模块
- en: 'Registering a module with the application means adding the module''s functionality
    into the application. What this module registration performs depends on the application''s
    requirements. For example, if the application includes a main menu, then a possible
    registration action for a module is to add menu items to the main menu. If the
    application is based on tabs, a possible registration action can be adding tabs
    to the main screen. All these actions need to be performed through a shared API.
    Take the example of adding a menu item. In this case, a possible interface could
    be something like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中注册模块意味着将模块的功能添加到应用程序中。这个模块注册执行的操作取决于应用程序的需求。例如，如果应用程序包含主菜单，那么一个模块的可能的注册操作是向主菜单添加菜单项。如果应用程序基于标签页，一个可能的注册操作可以是向主屏幕添加标签页。所有这些操作都需要通过一个共享的
    API 来执行。以添加菜单项为例。在这种情况下，一个可能的接口可能如下所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Modules can implement this interface to add menu items into the existing application's
    main menu.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以实现此接口，将菜单项添加到现有应用程序的主菜单中。
- en: 'Because we already have an `ApplicationLayout` interface, which defines methods
    to manipulate the layout, the following interface is good enough:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个 `ApplicationLayout` 接口，该接口定义了用于操作布局的方法，所以以下接口就足够好了：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `AppModule` interface is located in the `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven project of the source code that accompanies this book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppModule` 接口位于本书附带源代码的 `Data-centric-Applications-with-Vaadin-8\chapter-02\api`
    Maven 项目中。'
- en: 'This interface can be packaged in a separate JAR file so it can be distributed
    to any third-party developers. This JAR should contain all the classes and interfaces
    that could be needed by module implementations. This is the reason we previously
    created the `api` Maven module. There also is another advantage: The `api` JAR
    can be distributed to third-party developers to allow them to create new functionality
    for the application without distributing the whole compiled code of your web application.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口可以打包到一个单独的 JAR 文件中，以便可以将其分发给任何第三方开发者。此 JAR 应包含模块实现可能需要的所有类和接口。这就是我们之前创建 `api`
    Maven 模块的原因。这也有另一个优点：`api` JAR 可以分发给第三方开发者，使他们能够在不分发整个 Web 应用程序编译代码的情况下为应用程序创建新功能。
- en: Discovering modules
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现模块
- en: 'The `webapp` application should detect all the implementations of `AppModule`
    at run-time. For each implementation, it should create a new instance and call
    the `register(ApplicationLayout)` method. Doing this with Java SPI is surprisingly
    simple:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`webapp` 应用程序应在运行时检测所有 `AppModule` 的实现。对于每个实现，它应该创建一个新的实例并调用 `register(ApplicationLayout)`
    方法。使用 Java SPI 来做这件事非常简单：'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ServiceLoader` class is used to discover all the classes that implement
    the `AppModule` interface. For each module, we call its `register` method, passing
    the layout of the application to give the module the chance to initialize itself
    and modify the layout if required.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ServiceLoader` 类来发现实现 `AppModule` 接口的所有类。对于每个模块，我们调用其 `register` 方法，传递应用程序布局以给模块机会初始化自身并在需要时修改布局。
- en: Implementing new modules
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现新模块
- en: New modules have to implement the `AppModule` interface and follow the SPI requirements
    for packaging by adding a new file with the name `packt.vaadin.datacentric.chapter02.api.AppModule`
    into the `META-INF/services` directory. This file must contain the name of the
    fully qualified name of the `AppModule` implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 新模块必须实现 `AppModule` 接口，并遵循 SPI 要求进行打包，通过在 `META-INF/services` 目录中添加一个名为 `packt.vaadin.datacentric.chapter02.api.AppModule`
    的新文件来实现。此文件必须包含 `AppModule` 实现的完全限定名称。
- en: 'Let''s say you want to develop a module that adds an option to the main menu
    that shows a notification when clicked. This can be easily implemented as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想开发一个模块，该模块在点击主菜单时显示通知选项。这可以很容易地实现如下：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This class can be located in a separate Maven project and should include the
    `api` dependency.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此类可以位于一个单独的 Maven 项目中，并应包含 `api` 依赖项。
- en: The `ExampleModule` implementation is located in the `Data-centric-Applications-with-Vaadin-8\chapter-02\example-module`
    Maven project of the source code that accompanies this book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExampleModule` 的实现位于本书附带源代码的 `Data-centric-Applications-with-Vaadin-8\chapter-02\example-module`
    Maven 项目中。'
- en: 'To make the module discoverable by the `webapp` application, you must add a
    file with the name `packt.vaadin.datacentric.chapter02.api.AppModule` in the `main/resources/META-INF/services`
    directory of the new module. The file must contain the fully-qualified name of
    the `AppModule` implementation as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使模块可由 `webapp` 应用程序发现，你必须在新模块的 `main/resources/META-INF/services` 目录中添加一个名为
    `packt.vaadin.datacentric.chapter02.api.AppModule` 的文件。该文件必须包含 `AppModule` 实现的完全限定名称，如下所示：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once packaged, you can deploy the JAR file independently and the `webapp` application
    should automatically discover and register the module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打包，你可以独立部署 JAR 文件，并且 `webapp` 应用程序应该自动发现并注册该模块。
- en: To deploy a module with the web application, you can add it as a dependency
    in the `pom.xml` file of the `Data-centric-Applications-with-Vaadin-8/chapter-02/webapp`
    Maven project. If you are deploying the application as a WAR file to a servlet
    container, you can add the JAR to the `WEB-INF/lib` directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模块与 Web 应用程序一起部署，你可以在 `Data-centric-Applications-with-Vaadin-8/chapter-02/webapp`
    Maven 项目的 `pom.xml` 文件中将其添加为依赖项。如果你将应用程序作为 WAR 文件部署到 Servlet 容器，你可以将 JAR 文件添加到
    `WEB-INF/lib` 目录。
- en: 'The following is a screenshot of the application, showing the example module
    in action:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是应用程序的截图，显示了正在运行的示例模块：
- en: '![](img/5732e1cf-2f64-419e-9da7-9719ddbecada.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/5732e1cf-2f64-419e-9da7-9719ddbecada.png)'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a self-packaged UI component (a *main screen*
    component), created a multi-module Maven project, and learned how to implement
    application-specific modules that are discovered and registered with a Vaadin
    application at run-time. While explaining these concepts, we also saw some Java
    8 and Vaadin 8 snippets of code that highlighted good practices such as making
    your code more maintainable and extensible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个自包装的UI组件（一个*主屏幕*组件），创建了一个多模块Maven项目，并学习了如何在运行时通过Vaadin应用程序发现和注册特定应用模块的实现方法。在解释这些概念的同时，我们还看到了一些Java
    8和Vaadin 8的代码片段，这些片段突出了良好的实践，例如使代码更易于维护和扩展。
- en: In the next chapter, you will learn how to implement a login form with multi-language
    capabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何实现具有多语言功能的登录表单。
